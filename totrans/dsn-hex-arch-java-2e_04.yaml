- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Adapters to Interact with the Outside World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a time in software development at which we need to decide which technologies
    will be supported by a system. We’ve discussed in previous chapters how technological
    choices should not be the primary driver for developing hexagonal applications.
    In fact, applications based on this architecture present a high degree of changeability,
    enabling a system to be integrated with different technologies with as little
    friction as possible. This is because the **hexagonal architecture** establishes
    a clear frontier between which part of the code is related to business and which
    is related to technology.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to explore the hexagonal approach to establishing
    this frontier. We’ll learn about the role adapters play when we need to set up
    technologies or protocols to enable a hexagonal application to communicate with
    the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll learn about the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using input adapters to allow driving operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using output adapters to speak with different data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know how input adapters, in conjunction with
    input ports, can be used to expose the same software features to work with different
    technologies. In the same vein, you will learn how output adapters are powerful
    in making your application more versatile when it needs to talk to different data
    source technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you need the
    latest `curl` and `jq`. All those tools are available for **Linux**, **Mac**,
    and **Windows** operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In hexagonal architecture, adapters have a different role from those employed
    as a design pattern in object-oriented languages. As a design pattern, we use
    adapters to make the interfaces of two diverging classes compatible. In the hexagonal
    architecture, we use adapters to allow a system to be compatible with different
    technologies or protocols. Although the adapter’s role as a hexagonal architecture
    concept or as a design pattern may differ, it would be correct to state that both
    approaches share the same purpose: to adapt something to fit correctly into another
    thing.'
  prefs: []
  type: TYPE_NORMAL
- en: A practical analogy to understand the role adapters play in hexagonal architecture
    is about remote connections to a computer. Every modern operating system is compatible
    with remote connection protocols. In the past (and even today in certain situations),
    it was common to use **Telnet** to open a remote connection to a computer. Over
    time, other protocols emerged, such as **SSH** for console connections, **RDP**,
    and **Virtual Network Computing** (**VNC**) for a graphical alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Those protocols only define how you’re going to access the operating system,
    and once you’re there, you can execute commands and have access to the features
    that an operating system provides. It’s not uncommon for an operating system to
    offer more than one protocol to allow remote connection. That’s good because it
    widens the communication possibilities. There may be situations in which it’s
    necessary to support both Telnet and SSH connections simultaneously, maybe because
    there is an unusual client that works only with Telnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the preceding analogy, we can replace the operating system with an
    application developed using **Java**, or any other programming language, and we
    can replace remote connection protocols such as SSH and Telnet with HTTP-based
    communication protocols, such as **REST** and **gRPC**. Assuming our Java application
    is a hexagonal one, the features offered by such applications are organized into
    use cases, ports, and business rules from the **Application** and **Domain** hexagons.
    If you want to make those features available for both REST and gRPC clients, you
    need to create REST and gRPC adapters. Adapters used to expose application features
    are called **input adapters**. To connect those input adapters to the rest of
    our system, we associate input ports with input adapters, as illustrated in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The relationship between adapters and ports](img/B19777_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The relationship between adapters and ports
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define input adapters to allow users and other systems to interact with
    the application. In the same way, we can also define output adapters to translate
    data generated by the hexagonal application and communicate with external systems.
    Here we can see that both input and output adapters live in the extremities of
    the **Framework** hexagon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The location of input and output adapters](img/B19777_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The location of input and output adapters
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore in the next section how we can work with input adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using input adapters to allow driving operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have heard before that if there’s something we can always count on,
    it’s that things will always change. And when we talk about technological changes,
    that statement is even stronger. We live in an era where computers are not as
    expensive as they used to be in the past. No matter whether we’re dealing with
    desktops, mobile, or cloud computing, year by year, computer resources, in general,
    become cheaper and more accessible to everyone. This accessibility means that
    more people tend to be involved and can collaborate with software development
    initiatives.
  prefs: []
  type: TYPE_NORMAL
- en: That growing collaboration results in newer programming languages, tools, and
    development frameworks to support the creative effort to solve people’s problems
    with better and modern solutions. In this innovative and technological heterogeneous
    context, a good amount of current software development is made. One of the concerns
    that arises when developing software in this context is how a system will stay
    relevant and profitable in the face of constant technological changes. If a system
    is designed to intertwine business rules with technological details, it won’t
    be easy to incorporate new technology without significant refactoring. In hexagonal
    architecture, input adapters are the elements that help us to make the software
    compatible with different technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Input adapters are like the remote communication protocols mentioned in the
    example presented in the previous section. That comparison is valid because input
    adapters work like protocols, defining which technologies are supported as a means
    to access the features provided by a hexagonal system. Input adapters mark a clear
    frontier between what is inside the hexagon and what is outside, and perform what
    we call driving operations.
  prefs: []
  type: TYPE_NORMAL
- en: From outside the hexagon, there may be users or other systems interacting with
    the hexagonal application. We have learned that these users and systems are also
    known as primary actors, playing a pivotal role in shaping application use cases.
    The interaction between primary actors and the hexagonal application occurs through
    input adapters. Such interaction is defined by driving operations. We call them
    driving because primary actors drive, in the sense that they initiate and influence
    the state and behavior of hexagonal systems.
  prefs: []
  type: TYPE_NORMAL
- en: Input adapters, when put together, form the hexagonal application’s API. Because
    input adapters are in this boundary that exposes the hexagonal system to the outside
    world, they naturally become the interface for anyone interested in interacting
    with the system. As we progress in the book, we’ll see how to leverage the input
    adapters’ arrangement to structure and expose the application APIs, using tools
    such as **Swagger**.
  prefs: []
  type: TYPE_NORMAL
- en: We have emphasized the adapters’ characteristics to make a system compatible
    with different technologies or protocols. A more **Domain-Driven Design** (**DDD**)
    approach suggests other purposes for using an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A prevalent concern in DDD-based architectures is about integrating the elements
    of a legacy system into a new one. This occurs in scenarios where a legacy system
    with relevant knowledge crunched into its domain model solves some important problems
    but also shows inconsistencies in its design. You don’t want to give up the legacy
    system, but you also don’t want the new system design to be influenced by the
    legacy system’s design. To tackle this situation, you can employ what *Implementing
    Domain-Driven Design* by Vaughn Vernon and *Domain-Driven Design: Tackling Complexity
    in the Heart of Software* by Eric Evans call an **anti-corruption layer**. This
    layer is based on the adapters used to integrate bounded contexts from both the
    legacy and the new systems. In such a scenario, the adapters are responsible for
    preventing the new system’s design from being contaminated by the legacy system’s
    design.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we’re not applying this kind of usage of adapters in the hexagonal
    architecture, it’s important to be aware that we can use this DDD-based adapter
    approach for a hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that the connection between primary actors and the hexagonal application
    occurs through input adapters. Let’s see now how to make input adapters connect
    to other hexagons in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating input adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Input ports** are the means through which we implement use cases, specifying
    how an input port performs the operations to achieve use case goals. The input
    port object needs to receive what Jacobson (1992) called a *stimulus* to perform
    its operations. This stimulus is nothing more than an object calling another.
    The input port object receives all the necessary data to conduct its operations
    through the stimulus sent by an input adapter. However, it’s at this stage that
    eventual transformations may take place to convert input data into a format that’s
    compatible with the Domain hexagon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created a use case to add networks to a router.
    To achieve the use case goals, we’ll create two input adapters: an adapter for
    communication through HTTP REST and another for command-line execution. In the
    following UML diagram, we have **RouterNetworkAdapter** as an abstract parent
    class extended by the **RouterNetworkRestAdapter** and **RouterNetworkCLIAdapter**
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – UML representation of input adapters](img/B19777_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – UML representation of input adapters
  prefs: []
  type: TYPE_NORMAL
- en: We will define an adapter abstract base class, followed by two implementations,
    one for an adapter to receive data from HTTP REST connections and another for
    the console `STDIN` connection. To simulate access to these two adapters, we’ll
    create a client class to bootstrap the application.
  prefs: []
  type: TYPE_NORMAL
- en: The base adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by defining the `RouterNetworkAdapter` abstract base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The idea of this base adapter is to provide standard operations for communicating
    with the adapter’s correspondent input port. In that case, we use the `addNetworkToRouter`
    adapter method to receive the parameters required to build the `RouterID` and
    `Network` objects, which are utilized to start the use case operation to add the
    network to a router. These parameters may come from different sources, either
    via an HTTP request or via the shell/console with `STDIN`, but they are treated
    the same way once they arrive at the `addNetworkToRouter` method.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t refer to input ports directly. Instead, we utilize a use case interface
    reference. This use case reference is passed and initialized by the input adapter’s
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The REST input adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have defined the base `RouterNetworkAdapter` abstract class, we
    can proceed to create the REST adapter. We start by defining the `RouterNetworkRestAdapter`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use the `RouterNetworkRestAdapter` constructor to receive and initialize
    the `RouterNetworkUseCase` use case reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows us how a client could call-initialize this `RouterNetworkRestAdapter`
    input adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The intent here is to express that the REST input adapter requires an H2 in-memory
    database output adapter. Here, we’re explicitly stating which output adapter object
    the input adapter needs to perform its activities. That can be considered a vanilla
    approach, where we don’t use framework-based dependency injection techniques such
    as **CDI beans**. Later on, all those adapter constructors can be removed to use
    dependency injection annotations from frameworks such as **Quarkus** or **Spring**.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the `RouterNetworkAdapter` constructor, we then implement the
    `processRequest` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This method receives an `httpServer` object, which is used to create the HTTP
    endpoint to receive `GET` requests at `/network/add`. The client code that calls
    `processRequest` is similar to the following excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The REST adapter receives user data via an HTTP request, parses request parameters,
    and uses them to call `addNetworkToRouter` defined in the `RouterNetworkAdapter`
    parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the input adapter is responsible for converting user data into
    suitable parameters used to trigger an input port by using its use case reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this moment, the data leaves the Framework hexagon and goes to the `STDIN`).
  prefs: []
  type: TYPE_NORMAL
- en: The CLI input adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the second input adapter, we again extend the base adapter class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We define the `RouterNetworkCLIAdapter` constructor to receive and initialize
    the `RouterNetworkUseCase` use case that this input adapter needs.
  prefs: []
  type: TYPE_NORMAL
- en: For the CLI input adapter, we use a different output adapter. Instead of persisting
    an in-memory database, this output adapter uses the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows us how a client could initialize the `RouterNetworkCLIAdapter`
    input adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we get a `RouterNetworkOutputPort` output port reference. Then, with
    that reference, we retrieve a `RouterNetworkUseCase` use case. Finally, we get
    `RouterNetworkAdapter` using the use case defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we implement the `processRequest` method for the CLI adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the REST adapter, we have the `httpParams` method to retrieve data from an
    HTTP request. Now, in `processRequest` from the CLI adapter, we have a `stdinParams`
    method to retrieve data from the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `processRequest` methods from the REST and CLI adapters have differences
    in how they handle input data, but both have one thing in common. Once they capture
    input data into the `params` variable, they both call the `addNetworkToRouter`
    method inherited from the adapter base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From this point on, the data follows the same flow as the one described in the
    REST adapter scenario, where the input adapter calls the input port through a
    use case interface reference.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished creating the REST and CLI input adapters, let’s see
    how to call these adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the input adapters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the client code to control which adapter to choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass `rest` as a parameter when executing the program, the `switch`-`case`
    condition will create a REST adapter instance and call the `rest` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `rest` method, in turn, calls the `processRequest` method from the REST
    input adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, if we pass the `cli` parameter when executing the program, `switch`-`case`
    will, by default, create a CLI adapter and call the `cli` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `cli` method then calls the `processRequest` method from the CLI input adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for calling the input adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the code sample from GitHub within the `chapter4` directory, you can compile
    the application by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar rest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'GET request to create and add a network:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar cli
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Please inform the Router ID:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ca23800e-9b5a-11eb-a8b3-0242ac130003
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Please inform the IP address:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 40.0.0.0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Please inform the Network Name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Please inform the CIDR:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application will ask you to specify the router ID and other network additional
    details for calling the CLI adapter. Here, we gave the same data as used to call
    the REST adapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use input adapters to expose hexagonal application
    features. By defining first a base input adapter, we extended it to create a REST
    adapter for HTTP requests and a CLI adapter for console/`STDIN` requests. This
    arrangement helped us grasp the fundamental role input adapters play in exploring
    different ways to access the same functionality in the hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Input adapters are the front doors through which we access all the features
    a hexagonal application can provide. With input adapters, we can easily make the
    system accessible through different technologies without disturbing business logic.
    By the same token, we can make the hexagonal application speak to varying data
    sources. We accomplish that with output adapters, which we’ll see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: "Using output adapters to speak with different \Ldata sources"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What characterizes an object-oriented system is its ability to treat data and
    behavior as closely related things. This proximity happens to mimic the way things
    are in the real world. Both animate and inanimate beings have attributes and can
    perform or be the target of some action. For people starting to learn object-oriented
    programming, we present examples such as a car, which has four wheels and can
    drive – wheels being the data and driving the behavior. Examples such as this
    express the fundamental principle that data and behavior should not be treated
    as separate things but should be united inside what we call objects.
  prefs: []
  type: TYPE_NORMAL
- en: This object idea has laid the ground for the development of vast and complex
    systems over the last decades. A good part of those systems is business applications
    running on enterprise environments. The object paradigm has conquered enterprise
    development because its high-level approach has allowed people to be more productive
    and precise when creating software to solve business problems. The procedural
    paradigm was cumbersome and too low-level for the demands of enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to object-oriented languages, enterprise software also relies on
    ways to obtain and persist data. It’s hard to imagine a system that is not integrated
    with data sources such as databases, message queues, or file servers, for example.
    The need to store things has always been present in computation. The problem,
    though, has been how this need has influenced and dictated the whole software
    structure. With the advent of **RDBMSs**, there comes the requirement to formalize
    data through **schemas** as well. These schemas, then, serve as a reference for
    establishing data relationships and how the application deals with such relationships.
    After some time, people started to look for alternatives to avoid the formalism
    and strict normalization principles imposed by RDBMSs. The problem is not in the
    formalism per se but in using RDBMSs where there’s no need for that.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to RDBMSs, there came **NoSQL** databases, proposing a way
    to store data that didn’t rely on tables, columns, and schemas as a means of data
    organization. The NoSQL approach offers different data storage techniques, based
    on documents, key-value stores, wide-column stores, and graphs. Not constrained
    solely by the RDBMS approach, software developers then started using these NoSQL
    techniques to meet business requirements in a better way and avoid cumbersome
    solutions that relied on RDBMSs because there were no alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from databases, other data sources have been used to fulfill software
    needs to handle data. Filesystems, message brokers, directory-based storage (**LDAP**),
    and mainframe storage, to name a few, are some of the ways software can handle
    data. In the world of cloud computing, it’s becoming more natural to integrate
    a system with different technologies to send or receive data. This integration
    presents some challenges in software development because the system now needs
    to understand and make itself understandable in a heterogeneous technological
    context. That situation is even more exacerbated by architectures such as microservices
    that promote this heterogeneity. To tackle this challenge, we need techniques
    to overcome the challenges of technologically heterogeneous environments.
  prefs: []
  type: TYPE_NORMAL
- en: We saw in the previous section that we can plug multiple input adapters into
    the same input port. This also applies to output adapters and ports. Next, we’ll
    see how to create output adapters and plug them into the hexagon system output
    ports.
  prefs: []
  type: TYPE_NORMAL
- en: Creating output adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Together with input adapters, output adapters are the second component that
    comprises the Framework hexagon. The output adapter’s role in a hexagonal architecture
    is to deal with driven operations. Remember, driven operations are those initiated
    by the hexagonal application itself to interact with external systems to send
    or receive some data. These driven operations are described through use cases
    and are triggered by operations present in the use case’s input port implementations.
    Whenever a use case states the need to deal with data that lives in external systems,
    this means the hexagonal application will require at least one output adapter
    and port to meet such requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that output ports present in the Application hexagon express interactions
    with external systems in abstract ways. Output adapters, in turn, have the responsibility
    to describe, in concrete terms, how these interactions will occur. With output
    adapters, we make up our minds about which technologies the system will use to
    allow data persistence and other types of external integration.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have talked about data based solely on the requirements expressed
    by the domain model we created in the Domain hexagon. After all, it’s the domain
    model from the Domain hexagon that drives the shape of the whole hexagonal system.
    Technological concerns are just mere details that must adhere to the domain model
    and not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: By using the output port as an interface in the Application hexagon and the
    output adapter as the implementation of that interface in the Framework hexagon,
    we are structuring the hexagonal system to support different technologies. In
    this structure, the output adapter in the Framework hexagon must conform to the
    output port interface in the Application hexagon, which, in turn, must rely on
    the domain model from the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, you may have noticed the usage of two different output
    adapters – the `RouterNetworkH2Adapter` adapter to deal with data from in-memory
    databases and the `RouterNetworkFileAdapter` adapter to read and persist files
    from a local filesystem. These two output adapters are implementations of the
    output ports we created in the Application hexagon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – UML representation of output adapters](img/B19777_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – UML representation of output adapters
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by implementing `RouterNetworkH2Adapter`. It uses an H2 in-memory
    database to set up all the required tables and relationships. This adapter implementation
    shows us how to adapt the domain model data to a relational database. Then, we
    proceed to implement `RouterNetworkFileAdapter`, which uses a **JSON** file-backed
    data structure. Both H2 and JSON file implementations are based on the data provided
    by the topology and inventory sample system we’ve been working on. These two adapters
    will allow two ways to attach an additional network to an existing switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Topology and inventory system with a finance network](img/B19777_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Topology and inventory system with a finance network
  prefs: []
  type: TYPE_NORMAL
- en: Using the same input data from the previous section, we’ll attach **Finance
    Network** to **Layer 3 Switch** from **Edge Router** using one of the available
    two output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: The H2 output adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before implementing the H2 output adapter, we first need to define the database
    structure of the topology and inventory system. To determine that structure, we
    create the `resources/inventory.sql` file with the following SQL statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Although `switches` and `networks` have primary keys, we treat switches as entities
    and `networks` as value objects that are part of the `Router` entity in the domain
    model. We are imposing our model on the technological arrangement and not the
    other way around.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t use these primary keys from the `switches` and `networks` tables as
    references in the domain model. Instead, we use the `router_id` value to correlate
    the `Router` entity with its `Switch` and `Network` value objects and their respective
    database tables. This correlation enables the formation of an aggregate where
    `Router` is the aggregate root, and `Switch` and `Network` are the objects used
    to compose the aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can proceed to implement `RouterNetworkOutputPort` to create the `RouterNetworkH2Adapter`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first method we override is `fetchRouterById`, where we receive `routerId`
    to fetch a router from the H2 database using our entity manager reference. We
    cannot use the `Router` domain entity class to map directly to the database. Also,
    we cannot use the database entity as a domain entity. That’s why we use the `toDomain`
    method on `fetchRouterById` to map data from the H2 database to the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do the same mapping procedure, using the `toH2` method on `persistRouter`
    to convert it from a domain model entity into an H2 database entity. The `setUpH2Database`
    method initiates the database when the application starts. To create only one
    instance of the H2 adapter, we define a singleton using the `getInstance` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instance` field is used to provide a singleton object of the H2 output
    adapter. Note that the constructor calls the `setUpH2Database` method to create
    a database connection using `EntityManagerFactory`. To properly configure the
    entity manager, we create the `resources/META-INF/persistence.xml` file with a
    property to set up the H2 database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, our domain model comes first, so we don’t want to couple the system
    with database technology. That’s why we need to create a `RouterData` **ORM**
    class to map directly to the database types. Here, we are using **EclipseLink**,
    but you can use any **JPA-compliant** implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We use `@Getter`, `@NoArgsConstructor`, and `@AllArgsConstructor` annotations
    to diminish the verbosity of the class. We will use the getters and constructor
    later to convert the data class into a domain model class.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of the `@Table` and `@SecondaryTable` annotations serves to represent
    the relationship between the `routers` and `switches` tables. This relationship
    is mapped using the `@OntToOne` and `@JoinColumn` annotations, specifying that
    both tables must be linked through the `router_id` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `UUID` as an ID in EclipseLink, we need to create the following converter
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is the class we use inside the `@Converter` annotation at the top of the
    `RouterData` class. Without this converter, there will be an exception stating
    a problem in mapping the `routerId` attribute. Following the declaration of `routerId`,
    there is a `RouterTypeData` attribute called `routerType`. For every ORM attribute,
    we add the `Data` suffix to the class name. Aside from `RouterData`, we do that
    with `RouterTypeData` and `SwitchData`. Remember that in the domain model, the
    equivalent types are `Router`, `RouterType`, and `Switch`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterTypeData` is the `enum` in which we store the router type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Embeddable` annotation allows the `enum` data to be mapped to the `router_type`
    field in the database using the `@``Embedded` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last `RouterData` field, we refer to `SwitchData` in the `networkSwitch`
    variable, which we use to create the relationship between a router and switch.
    Let’s see how the `SwitchData` class is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We apply the same techniques to `SwitchData` that we applied to `RouterData`.
    There is a subtle difference though, which is the relationship established between
    the `switches` and `networks` tables. To create this relationship, we use the
    `@OneToMany` and `@JoinColumn` annotations to create a link between the `SwitchData`
    and `NetworkData` types using the `switch_id` attribute. A reference to a list
    of `NetworkData` objects is required because of the `@``OneToMany` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `RouterDataType`, we have `SwitchDataType`, which is an `enum` equivalent
    of `SwitchType` from the domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the topology and inventory system, we attach networks directly to a switch.
    To map the domain value object to the H2 database entity, we implement the `NetworkData`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All attributes we have in `NetworkData` are the same ones present in its domain
    value object counterpart. The only difference is the annotations we add to turn
    it into a database entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `SwitchData` and `NetworkData` classes declare the `IPData` field.
    We encounter a similar behavior in the domain model, where `Switch` and `Network`
    classes have an `IP` attribute. Here is how we should implement the `IPData` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`ProtocolData` follows the same pattern used by other `enum`-based types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We could argue that there is some repetition in creating all those classes to
    integrate the system with a database. That’s true. It’s a trade-off where we give
    up reusability in favor of changeability, making the application capable of better
    integration with RDBMSes and other data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created all the ORM classes to allow integration with the
    H2 database, we need to translate database objects into domain model objects and
    vice versa. We accomplish this by creating a mapper class with mapper methods.
    Let’s start with the methods we use to convert database entities into domain entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `toDomain` method receives a `RouterData` type representing the database
    entity and returns a `Router` domain entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a list of `NetworkData` database entity objects into a list of `Network`
    domain value objects, we use the `getNetworksFromData` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It receives a list of `NetworkData` database entity objects and returns a list
    of `Network` domain entity objects. Then, to convert from a domain model entity
    into an H2 database entity, we create the `toH2` mapper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `toH2` method receives a `Router` domain entity object as a parameter, to
    do the proper mapping, and then it returns a `RouterData` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to convert a list of `Network` domain value objects into a list of
    `NetworkData` database entity objects, we have the `getNetworksFromDomain` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `getNetworksFromDomain` method receives a list of `Network` domain value
    objects and a `UUID`-type switch ID as parameters. With that data, this method
    is able to do the proper mapping, returning a list of `NetworkData` database entity
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toDomain` static method is used when we need to convert the H2 database
    object into its domain model counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When persisting the domain model entity as the H2 database entity, we use the
    `toH2` static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetchRouterById` and `persistRouter` methods are called from the `RouterNetworkInputPort`
    object, using a `RouterNetworkOutputPort` interface reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `RouterNetworkOutputPort` is resolved at runtime based on the
    parameter we pass to the `RouterNetworkInputPort` constructor. With this technique,
    we blind the hexagonal system regarding where it needs to go to get data. It can
    be a relational database or a `.json` file, as we’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The file adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the file adapter, we can apply the same ideas used to create the
    H2 database adapter, with just some minor adjustments to accommodate the file-backed
    data source. This data source is a `.json` file containing the same data used
    to create the previous database. So, to start, you can create a `.json` file at
    `resources/inventory.json` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of adding a network to fulfill our use case goals remains the same,
    so again we will implement the `RouterNetworkOutputPort` interface to create `RouterNetworkFileAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchRouterById` method returns a `Router` object by parsing a `.json`
    file using the `RouterId` parameter. The `persistRouter` method persists changes
    in the `inventory.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using an entity manager and EclipseLink, we use the `Jackson` libraries
    to serialize and deserialize the JSON data. To load the `inventory.json` file
    into memory, we use the adapter constructor to call the `readJsonFile` method
    to load the `inventory.json` file into a list of `RouterJson` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the H2 case, with JSON, we also need to create special classes to map
    between JSON objects and domain model objects. The classes’ structure is similar
    to the H2 ORM classes, with differences mainly in the annotations used to create
    adequate mapping. Let’s see how to implement the `RouterJson` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We use the `@JsonInclude` and `@JsonProperty` annotations to map class attributes
    to JSON fields. These JSON mappings are much more straightforward than H2 mappings
    because we don’t need to deal with database relationships. `RouterTypeJson`, `SwitchJson`,
    and all other JSON map classes are similar in that they use the same annotations
    to convert JSON and domain model objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert `RouterJson` into `Router`, we use the `toDomain` method from the
    `RouterJsonFileMapper` mapper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `toJson` method to convert from `Router` into `RouterJson`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`RouterJsonFileMapper` is similar to its H2 counterpart but simpler because
    we don’t need to deal with **one-to-many** or **one-to-one** relationships. Let’s
    start with the methods used to convert JSON objects into domain objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toDomain` method here receives a `RouterJson` object as a parameter, performs
    the proper mapping, and then returns a `Router` object. A similar procedure occurs
    when we need to convert a list of `NetworkJson` JSON objects into a list of `Network`
    domain objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `getNetworksFromJson` method receives a list of `NetworkJson` objects as
    parameters and returns an adequately mapped list of `Network` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the methods used to convert domain objects into JSON objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `toJson` method does the opposite of what `toDomain` does. Instead of a
    JSON object as a parameter, the `toJson` method here receives a `Router` domain
    object, performs the proper mapping, and returns a `RouterJson` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a situation where it’s necessary to convert a list of `Network`
    domain objects into a list of `NetworkJson` JSON objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: By receiving a list of `Network` objects as parameters, the `getNetworksFromDomain`
    method can proceed to map the needed attributes and return a list of `NetworkJson`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed the file output adapter implementation, let’s play
    around, calling both the file and H2 output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the output adapters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before calling the adapter, let’s compile the application. Navigate to the
    `Chapter04` directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the H2 output adapter, we need to use the REST input adapter. We can
    do that by providing the `rest` parameter when executing the `.``jar` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The file output adapter is accessible through the CLI input adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of calling both the H2 and file output adapters will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note the `Finance` network block at the end of the output, which confirms that
    the data was correctly persisted.
  prefs: []
  type: TYPE_NORMAL
- en: By creating these two output adapters, we enabled the hexagonal application
    to speak with different data sources. The best part was that we didn’t need to
    change anything in the Domain or Application hexagons.
  prefs: []
  type: TYPE_NORMAL
- en: The only requirement for creating an output adapter is implementing an output
    port interface from the Application hexagon. These output adapter examples showed
    how a hexagonal approach protects the business logic from technological concerns.
    Of course, there is a trade-off when we decide to follow this path. However, if
    we aim to make change-tolerant systems centered in the domain model, the hexagonal
    architecture provides the necessary techniques needed for that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned in this chapter that adapters are used to define the technologies
    that are supported by a hexagonal application. We created two input adapters to
    allow driving operations, that is, a REST adapter to receive data from HTTP connections
    and a CLI adapter to receive data from `STDIN`. Both input adapters were attached
    to the same input port, allowing the hexagonal system to use the same logic to
    process requests coming in distinct formats.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created an H2 database output adapter and a JSON file output adapter
    to allow the hexagonal application to communicate with different data sources.
    These two output adapters were attached to the same output port, enabling the
    hexagonal system to persist and obtain data from external sources so that the
    data source technology did not influence the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: By knowing the purpose of input and output adapters and understanding how to
    implement them, we can now create systems that can tolerate significant technological
    changes without substantial refactoring. This benefit is achieved because all
    the system components, including the adapters, are developed around the domain
    model.
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand the dynamic between adapters and other hexagonal architecture
    elements, we’re going to look into the life cycle of driving and driven operations
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When should we create an input adapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of connecting multiple input adapters to the same input
    port?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What interface must we implement to create output adapters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which hexagon do the input and output adapters belong to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create an input adapter when we need to expose software features to be accessed
    by driving actors. These actors can access the hexagonal application using different
    technologies or protocols, such as HTTP REST or via the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main benefit is that the same logic, contained in an input port, can be
    used to treat data that comes from different input adapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output adapters must always implement output ports. By doing that, we are sure
    that the adapters are in line with the requirements expressed by the domain model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are both from the Framework hexagon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Get Your Hands Dirty on Clean Architecture: A hands-on guide to creating clean
    web applications with code examples in Java*, Tom Hombergs, Packt Publishing Ltd.,
    2019'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object-Oriented Software Engineering: A Use Case Driven Approach*, Ivar Jacobson,
    Pearson Education, 1992'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software*, Eric
    Evans, Pearson Education, 2003'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing Domain-Driven Design*, Vaughn Vernon, Pearson Education, 2013'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hexagonal architecture* ([https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)),
    Alistair Cockburn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
