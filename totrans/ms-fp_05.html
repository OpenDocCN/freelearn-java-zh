<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Effect Types - Abstracting Away Side Effects</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we saw why side effects may be a source of trouble. We also briefly discussed effect types. Effect types are a technique of functional programming that allow for the abstraction of side effects.</p>
<p>In this chapter, we will have a look at how this works. We will learn the philosophy behind the pattern. Also, we will see how to sequentially combine side effects trapped in effect types.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Turning effects into data</li>
<li>The sequential combination of effect types with Monads <span>– the</span> <kbd>map</kbd> and <kbd>flatMap</kbd> functions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Turning effects into data</h1>
                </header>
            
            <article>
                
<p>It's possible to compare the process of writing programs with modeling and describing a particular reality. For example, when you are writing an application for warehouse management, you are encoding in the rules of logic the concept of an online shop, its inventory, the place where the inventory is stored, and the rules according to which this inventory can be moved in and out of the warehouse. This is the reality of the business domain for which you are writing the application. We can say that your goal as a programmer is to model your business domain, that is, to encode it using your programming language into specific logical rules—to define the way information is to be stored, transformed, and interacted with.</p>
<p class="mce-root"/>
<p>However, in the process of execution, programs create their own reality. The same way a warehouse, an online shop, and a user are all members of the reality of the business domain, some elements are members of the domain of program execution. The same way you can define certain phenomena as they happen in your business domain, such as inventory shortage or the users buying from your shop, you can define certain phenomena that exist in the world of writing and running a program.</p>
<p>Reality is what is on your mind when you are working on a certain level of abstraction. When you are working in the business-domain level, one category of thing is on your mind. However, when you are creating programs, entirely different things are on your mind. These two separate sets of concepts and phenomena can be understood as separate realities you're working in.</p>
<p>For example, errors are in the reality of program-execution. The errors' life cycle is also the reality of the program execution. Errors can propagate up the call stack. When they are handled, they stop propagation. They disrupt programs in places where they happen.</p>
<p>Delays are also the reality of program-execution. When you perform a database operation, an input-output operation, or wait for a response from a server, you deal with delays.</p>
<p>Concurrency, modularity, class hierarchies—all of these are elements of your programming reality. The programming reality is the concept and phenomena you are concerned with when you write your program. This reality, however, does not concern your boss, who lives in the reality of the business domain.</p>
<p>For simplicity, let's name the business-domain reality the first-order reality, and the programming reality the second-order reality. Such naming is because the business-domain reality is something that you are immediately concerned with. The reality of your program is something that arises in the process of solving the business-domain problems, the first-order reality.</p>
<p>Sometimes, a programmer focuses only on the first-order reality. They may not care about the quality of the code or how it handles the second-order reality. Their primary concern is to describe the first order reality and to solve the business task. This situation can arise from the lack of experience of a programmer, or from a lack of infrastructure that would allow them to deal with the second-order reality quickly. Under pressing deadlines, trade-offs sometimes have to be made in favor of completing the task rather than the code quality.</p>
<p><span>Why is it dangerous to ignore the programming reality? Well, because it is a reality in itself, independent of the realities that may occur in business.</span> This reality still exists, whether you ignore or address it. And if you do not pay attention to it, it may escalate in complexity, especially in large code bases.</p>
<p>For example, if there are too many asynchronous computations, you may find yourself in the situation of callback hell. In the context of callbacks, it is not easy to follow the execution flow of the program. Callback hell is when your program relies on callbacks too much, to the point where it starts to be hard to track what it does.</p>
<p>When you are dealing with a concurrent program and multithreaded computations, if you're not careful, you may end up in a situation of race conditions. Alternatively, you may encounter deadlocks or problems with system liveliness. Without specific techniques to deal with these, such as an actor system, they may produce bugs that are particularly tricky to debug.</p>
<p>If you are not careful about when you throw exceptions and return nulls from methods, you can expect pretty much every method to throw an exception or return null. Abusing exceptions and nulls by itself should not lead to detrimental bugs, but this will still give you a headache.</p>
<p>Finally, mutation is another reality that you are going to face. In the previous chapters, we discussed how mutation can increase your mental load.</p>
<p>The several programming situations previously discussed demonstrate the mental load that we were talking about so extensively in the previous chapters. It is the second-order reality of how programs are run and how they are written. The programs are supposed to model the reality of their business domains. However, there is an entirely different reality that you encounter when you solve, run, or write programs. If you ignore this reality, it will overwhelm you with complexity and cause a mental overload.</p>
<p>Consider the following example of the division function, which we have encountered in previous chapters:</p>
<pre>def imperativeDivision(n1: Double, n2: Double): Double =<br/>  if (n2 == 0) throw new RuntimeException("Division by zero!")<br/>  else n1 / n2</pre>
<p>The first-order reality here is arithmetics. It is the business domain that we are trying to model. Precisely, we model an operation of dividing one number by another number. That's our first-order reality.</p>
<p>However, when we start to write the code, we quickly encounter the second-order reality. That is, the possibility of the division by zero and the necessity to handle this case in the program. Now, we move from the world of mathematics and our primary business task to the world of programming.</p>
<p>A naive way to handle this reality is to throw an exception in case of division by zero. However, if you do not pay enough attention to the second-order reality, it will create the mental overhead that we've already discussed. There is nothing to warn you about the possibility of an error. There's nothing to force you to handle it. Hence, you need to remember all of this yourself, which contributes to the complexity of the program you need to keep in mind. The more things you need to keep in mind, the harder it is to do this, and the more things can go wrong.</p>
<p>A more sophisticated programmer will think of both the first- and the second-order realities when designing their program. They will not only model the business domain; they will also design the program so that the complexity of its execution does not prevent scalability. Scalability means the size of the code base does not contribute to the complexity of the programming of individual components.</p>
<p>To develop a program qualitatively, programmers need specific tools and approaches. Functional programming offers one approach.</p>
<p>Functional programming follows the fundamental principle of engineering—abstract away what repeats. The second-order reality has repeating phenomena. So functional programming devises its own abstractions to deal with them.</p>
<p>Learning how to describe both realities at once is harder than learning how to describe only the first-order reality. Hence, languages such as Python are much easier to learn than, say, Java. Although Java is not a functional language, it also provides an infrastructure and a methodology to deal with the complexity of programming. At the same time, Python is focused on speed and ease of prototyping. Moreover, Java is much simpler than Scala because Scala provides even more abstractions and a means for you to control both realities of your program.</p>
<p>Although it is harder to learn the languages that allow for more qualitative programming, the value is well worth its price. You learn to control the effects of the second-order reality. Not only can <span>you </span>describe your immediate business domain, but you are also able to describe the way your program is run. The way to scalability and bug-free programming is having control over complexity.</p>
<p class="mce-root"/>
<p>Let's revisit the division by zero example, but take into account the second-order reality:</p>
<pre>def functionalDivision(n1: Double, n2: Double): Try[Double] =<br/>  if (n2 == 0) Failure(new RuntimeException("Division by zero!"))<br/>  else Success(n1 / n2)</pre>
<p>The first thing to notice is that the second-order reality effect of an error gets modeled with the <kbd>Try</kbd> data structure. The concept of error handling is modeled by analyzing the <kbd>Try</kbd> data structure. It is enforced by the compiler—you cannot access the result value unless you analyze the data structure for errors. Hence the complexity is reduced.</p>
<p>The pattern where we detect a specific phenomenon of the second-order reality and create a data structure to encapsulate (reify) it is typical in functional programming. In this book, we will be calling the data structures that reify the phenomena of the second-order reality <strong>effect types</strong>.</p>
<p>The main point of this section is to look at the side effects from a wide angle to see the general pattern behind their abstraction. If you only focus on your business domain while ignoring your program's technical reality, the latter will create a tough mental load. A sophisticated programmer focuses on both realities equally. Functional programming allows you to address them adequately.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The sequential combination of effects with Monads</h1>
                </header>
            
            <article>
                
<p>Analyzing the preceding data structure was cumbersome. The code that has to do with analyzing functional data structures turns out to be pretty hard to read.</p>
<p>However, analyzing the data structures is a pattern in the functional world. Patterns are abstracted away in programming.</p>
<p>In this section, we will have a look at some common abstractions that you will deal with as a functional programmer when working with effect types.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the map function</h1>
                </header>
            
            <article>
                
<p>Imagine that we need to build upon the previous example of the custom-division function to construct another function. The function is parameterized by an argument, <kbd>x</kbd>, and computes an expression, <kbd>2 / x + 3</kbd>.</p>
<p>How do we express it in terms of our custom-division function? One approach is first to perform the division, then analyze its result, and if it is not an error, continue with the addition. However, if it is an error, return that error:</p>
<pre>def f1(x: Double): Try[Double] =<br/>divide(2, x) match {<br/>  case Success(res) =&gt; res + 3<br/>  case f: Failure   =&gt; f<br/>}</pre>
<p>The situation where we have a computation that returns an effect type, and we need to continue it with another computation that returns a raw value that is not wrapped in an effect type, is a frequent pattern in functional programming. The pattern is to analyze the structure returned by a computation, extract the result, and then apply the second computation to this result.</p>
<p>This pattern is encapsulated in the <kbd>map</kbd> method. Most effect types have the <kbd>map</kbd> method defined on them. Here is how the preceding example will look if implemented with the help of the <kbd>map</kbd> method:</p>
<pre>def f1Map(x: Double): Try[Double] =<br/> divide(2, x).map(r =&gt; r + 3)</pre>
<p>Let's try to develop an intuition for the <kbd>map</kbd> method. First of all, you can think of the <kbd>map</kbd> method as of the following higher-order function—<kbd>(A =&gt; B) =&gt; (Try[A] =&gt; Try[B])</kbd>. This is a higher-order function that accepts an <kbd>A =&gt; B</kbd> function and outputs a <kbd>Try[A] =&gt; Try[B]</kbd> function.</p>
<p>What it means is that if you have a function to convert a value of the <kbd>A</kbd> type into a value of the <kbd>B</kbd> type, you can also have a function to convert a value of the <kbd>Try[B]</kbd> type to a value of the <kbd>Try[B]</kbd> type. You can think of the <kbd>map</kbd> function as a lift that allows you to produce functions that work under the <kbd>Try</kbd> effect type from functions that work on the raw values.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the flatMap function</h1>
                </header>
            
            <article>
                
<p>Another example of a function that encapsulates a pattern of functional programming is <kbd>flatMap</kbd>. Imagine we need to create a function that computes the following mathematical expression: <kbd>(2 / x)  / y + 3</kbd>. Let's try to do this with the division function that we defined previously:</p>
<pre>def f2Match(x: Double, y: Double): Try[Double] =<br/>  divide(2, x) match {<br/>    case Success(r1) =&gt; divide(r1, y) match {<br/>      case Success(r2) =&gt; Success(r2 + 3)<br/>      case f@Failure(_) =&gt; f<br/>    }<br/>    case f@Failure(_) =&gt; f<br/>  }</pre>
<p>The code becomes spaghetti-like here. First, we analyze the result of dividing <kbd>2</kbd> by <kbd>x</kbd>. If successful, we would divide it by <kbd>y</kbd>. Then we analyze the result of that division, and if there was no error, we add <kbd>3</kbd> to the result.</p>
<p>Here, we can no longer use the <kbd>map</kbd> function because the division by <kbd>y</kbd> returns another try. <kbd>map</kbd> is a lift for a function that returns a raw value, not <kbd>Try</kbd>. If the logic sounds obscure to you, you are encouraged to try to implement the preceding example with the <kbd>map</kbd> function to see the problem.</p>
<p>The <kbd>flatMap</kbd> function exists specifically for this situation. You can think of it as of a higher-order function with the <kbd>(A =&gt; Try[B]) =&gt; (Try[A] =&gt; Try[B])</kbd> signature. You can interpret it as follows. If you have a function that produces a value wrapped in the <kbd>Try</kbd> structure, <kbd>A =&gt; Try[B]</kbd>, you can turn it into another function, <kbd>Try[A] =&gt; Try[B]</kbd>, that lifts the original function's <kbd>A</kbd> domain to the domain of <kbd>Try[A]</kbd>. This means that if the original <kbd>A =&gt; Try[B]</kbd> function could be used on the <kbd>A</kbd> raw values, the new <kbd>Try[A] =&gt; Try[B]</kbd> function can be used on <kbd>Try[A]</kbd> as its input.</p>
<p>Let's have a look at how it can be implemented with <kbd>flatMap</kbd>:</p>
<pre>def f2FlatMap(x: Double, y: Double): Try[Double] =<br/>  divide(2, x).flatMap(r1 =&gt; divide(r1, y))<br/>   .map(r2 =&gt; r2 + 3)</pre>
<p>We need to extract the raw result from the <kbd>Try</kbd> data structure we got after computing <kbd>2</kbd>/<kbd>x</kbd>, and we need to perform another computation on this result. This computation, the result divided by <kbd>y</kbd>, also produces <kbd>Try</kbd>. With the help of <kbd>flatMap</kbd>, we can lift the <kbd>Int =&gt; Try[Int]</kbd> computation into <kbd>Try[Int] =&gt; Try[Int]</kbd>. In other words, once we have computed <kbd>2</kbd>/<kbd>x</kbd>, we can divide its result by <kbd>y</kbd>.</p>
<p class="mce-root"/>
<p>So <kbd>flatMap</kbd> is for situations when you need to continue a computation with another computation, and the continuation will produce a <kbd>Try</kbd> as its result. Compare that to the situation with the <kbd>map</kbd> function, which requires the continuation to produce a raw value. Corresponding versions of <kbd>map</kbd> and <kbd>flatMap</kbd> also exist for other effect types, such as Option or Future.</p>
<p>One thing can be confusing here regarding the signatures of <kbd>map</kbd> and <kbd>flatMap</kbd> that we have analyzed. The signatures are functions. They take a function as an input and return another function as an output. However, the <kbd>map</kbd> and <kbd>flatMap</kbd> methods we have called on the <kbd>Try</kbd> object do not return functions but <kbd>Try</kbd> objects. However, both of our <kbd>map</kbd> and <kbd>flatMap</kbd> signatures, as we have discussed previously, return a <kbd>Try[A] =&gt; Try[B]</kbd> function.</p>
<p>In the functional world, we view functions outside the context of object-oriented programming. Scala is a convenient language because it combines the object-oriented and functional approaches. So, functions such as <kbd>flatMap</kbd> or <kbd>map</kbd> are defined as methods of the <kbd>Try</kbd> class. However, in functional programming, we get a better grasp of the nature of the functions by viewing them outside the context of object-oriented programming. In functional programming, they are not viewed as members of any class. They are means to transform the data.</p>
<p>Imagine you have a function that is defined as a member of some <kbd>Dummy</kbd> class:</p>
<pre>class Dummy(val id: Int) {<br/>  val f: Int =&gt; String = x =&gt; s"Number: $x; Dummy: $id"<br/>}</pre>
<p>The function <kbd>f</kbd> takes some argument of type <kbd>Int</kbd> and outputs some result of type <kbd>String</kbd>. Its signature is <kbd>Int =&gt; String</kbd>. This signature is the signature of the function as it is defined inside the <kbd>Dummy</kbd> class. However, notice that since it is defined inside the <kbd>Dummy</kbd> object, the context of that object is always implied. We can use the data of the enclosing object when performing the computation inside the function.</p>
<p>What happens if we decide to bring this function outside the scope of the class? Will the <kbd>Int =&gt; String</kbd> signature still reflect the nature of the function? Can we even implement it that way? Consider the following:</p>
<pre>// val f: Int =&gt; String = x =&gt; s"Number: $x; Dummy: $id"  // No `id` in scope, does not compile</pre>
<p>The answer is no because now we do not have the required class context. The preceding code produces a compile-time error. If we move the function outside the scope of the class, we need to define it with the <kbd>Dummy =&gt; (Int =&gt; String)</kbd> signature. That is, if we have a <kbd>Dummy</kbd> object, we can define a function from <kbd>Int</kbd> to <kbd>String</kbd>, with this object in context:</p>
<pre>val f1: Dummy =&gt; (Int =&gt; String) = d =&gt; (x =&gt; s"Number: $x; Dummy: ${d.id}")</pre>
<p>Note that it is also possible to have it another way, <kbd>Int =&gt; (Dummy =&gt; String)</kbd>, without compromising the semantics:</p>
<pre>val f2: Int =&gt; (Dummy =&gt; String) = x =&gt; (d =&gt; s"Number: $x; Dummy: ${d.id}")</pre>
<p>This idea was applied here when analyzing the <kbd>map</kbd> and <kbd>flatMap</kbd> signatures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the philosophy behind side effects. We found out that in the process of solving a business-domain problem, programmers end up in a reality different from the one of their business logic. The way you write the program and the phenomena that happen at runtime constitute a reality of their own. If you ignore it, the latter reality can grow in complexity, and this results in a mental overhead.</p>
<p>Functional programming allows you to address the problem of the second-order reality by providing techniques to reify its phenomena into effect types and define their behavior in the language of data structures and pure functions.</p>
<p>Effect types lessen your mental load because they eliminate the necessity to remember all the phenomena that happen in your program, even outside the scope of the code you may currently be looking at.</p>
<p>Effect types also make the compiler force you to handle such phenomena. Working with effect types can quickly become quite verbose. Hence, functions such as <kbd>map</kbd> and <kbd>flatMap</kbd> exist to abstract away common scenarios that involve effect types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which realities does a programmer need to consider when writing a program?</li>
<li>How does pure functional programming address the problem of complexity in the second-order reality?</li>
<li>What are the benefits of taking the second-order reality into account in our programs?</li>
</ol>


            </article>

            
        </section>
    </body></html>