<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;A Look at Reactive Extensions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. A Look at Reactive Extensions</h1></div></div></div><p class="calibre7">Reactive Extensions—or Rx<a id="id82" class="calibre1"/>—is a Reactive Programming library from Microsoft to build complex asynchronous programs. It models time-varying values and events as observable sequences and is implemented by extending the Observer design pattern.</p><p class="calibre7">Its first target platform was .NET, but Netflix has ported Rx to the JVM under the name RxJava. Microsoft<a id="id83" class="calibre1"/> also develops and maintains a port of Rx to JavaScript called <a id="id84" class="calibre1"/>RxJS, which is the tool we used to build the sine-wave application. The two ports work a treat for us since Clojure runs on the JVM and ClojureScript in JavaScript environments.</p><p class="calibre7">As we saw in <a class="calibre1" title="Chapter 1. What is Reactive Programming?" href="part0015_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre8">What is Reactive Programming?</em></span>, Rx is inspired by Functional Reactive Programming but uses different terminology. In FRP, the two main abstractions are behaviors and events. Although the implementation details are different, observable sequences represent events. Rx also provides a behavior-like abstraction through another data type called <code class="email">BehaviorSubject</code>.</p><p class="calibre7">In this chapter, we will:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Explore Rx's main abstraction: observables</li><li class="listitem">Learn about the duality between iterators and observables</li><li class="listitem">Create and manipulate observable sequences</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;A Look at Reactive Extensions">
<div class="book" title="The Observer pattern revisited"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec14" class="calibre1"/>The Observer pattern revisited</h1></div></div></div><p class="calibre7">In <a class="calibre1" title="Chapter 1. What is Reactive Programming?" href="part0015_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre8">What is Reactive Programming?</em></span>, we saw a brief overview of the Observer design pattern and<a id="id85" class="calibre1"/> a simple implementation of it in Clojure using watches. Here's how we did it:</p><div class="informalexample"><pre class="programlisting">(def numbers (atom []))

(defn adder [key ref old-state new-state]
  (print "Current sum is " (reduce + new-state)))

(add-watch numbers :adder adder) </pre></div><p class="calibre7">In the preceding example, our observable subject is the var, <code class="email">numbers</code>. The observer is the <code class="email">adder</code> watch. When the observable changes, it <span class="strong"><em class="calibre8">pushes</em></span> its changes to the observer <span class="strong"><em class="calibre8">synchronously</em></span>.</p><p class="calibre7">Now, contrast <a id="id86" class="calibre1"/>this to working with sequences:</p><div class="informalexample"><pre class="programlisting">(-&gt;&gt; [1 2 3 4 5 6]
     (map inc)
     (filter even?)
     (reduce +))</pre></div><p class="calibre7">This time around, the vector is the subject being observed and the functions processing it can be thought of as the observers. However, this works in a pull-based model. The vector doesn't push any elements down the sequence. Instead, <code class="email">map</code> and friends ask the sequence for more elements. This is a synchronous operation.</p><p class="calibre7">Rx makes sequences—and more—behave like observables so that you can still map, filter, and compose them just as you would compose functions over normal sequences.</p></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;A Look at Reactive Extensions">
<div class="book" title="The Observer pattern revisited">
<div class="book" title="Observer – an Iterator's dual"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec22" class="calibre1"/>Observer – an Iterator's dual</h2></div></div></div><p class="calibre7">Clojure's sequence operators such as map, filter, reduce, and so on support Java Iterables. As the name implies, an Iterable is an object that can be iterated over. At a low level, this is supported<a id="id87" class="calibre1"/> by retrieving an Iterator reference from <a id="id88" class="calibre1"/>such object. Java's Iterator interface looks like the following:</p><div class="informalexample"><pre class="programlisting">public interface Iterator&lt;E&gt; {
    boolean hasNext();
    E next();
    void remove();
}</pre></div><p class="calibre7">When passed in an object that implements this interface, Clojure's sequence operators pull data from it by using the <code class="email">next</code> method, while using the <code class="email">hasNext</code> method to know when to stop.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre7">The <code class="email">remove</code> method is required to remove its last element from the underlying collection. This in-place mutation is clearly unsafe in a multithreaded environment. Whenever Clojure implements this interface for the purposes of interoperability, the <code class="email">remove</code> method simply throws <code class="email">UnsupportedOperationException</code>.</p></div><p class="calibre7">An observable, on the other hand, has observers subscribed to it. Observers have the following interface:</p><div class="informalexample"><pre class="programlisting">public interface Observer&lt;T&gt; {
    void onCompleted();
    void onError(Throwable e);
    void onNext(T t);
}</pre></div><p class="calibre7">As we<a id="id89" class="calibre1"/> can see, an Observer implementing <a id="id90" class="calibre1"/>this interface will have its <code class="email">onNext</code> method called with the next value available from whatever observable it's subscribed to. Hence, it being a <span class="strong"><em class="calibre8">push</em></span>-based notification model.</p><p class="calibre7">This duality [4] becomes clearer if we look at both the interfaces side by side:</p><div class="informalexample"><pre class="programlisting">Iterator&lt;E&gt; {                       Observer&lt;T&gt; {
    boolean hasNext();                  void onCompleted();
    E next();                           void onError(Throwable e);
    void remove();                      void onNext(T t);
}                                       }</pre></div><p class="calibre7">Observables provide the ability to have producers push items <span class="strong"><em class="calibre8">asynchronously</em></span> to consumers. A few examples will help solidify our understanding.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating Observables"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Creating Observables</h1></div></div></div><p class="calibre7">This<a id="id91" class="calibre1"/> chapter is all about Reactive Extensions, so let's go ahead and <a id="id92" class="calibre1"/>create a project called <code class="email">rx-playground</code> that we will be using in our exploratory tour. We will use <a id="id93" class="calibre1"/>RxClojure (see <a class="calibre1" href="https://github.com/ReactiveX/RxClojure">https://github.com/ReactiveX/RxClojure</a>), a library that provides Clojure bindings for <code class="email">RxJava()</code> <a id="id94" class="calibre1"/>(see <a class="calibre1" href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ lein new rx-playground</strong></span>
</pre></div><p class="calibre7">Open the project file and add a dependency on RxJava's Clojure bindings:</p><div class="informalexample"><pre class="programlisting">(defproject rx-playground "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [io.reactivex/rxclojure "1.0.0"]])<span class="strong"><strong class="calibre2">"]</strong></span>])</pre></div><p class="calibre7">Now, fire up a REPL in the project's root directory so that we can start creating some observables:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ lein repl</strong></span>
</pre></div><p class="calibre7">The first thing we need to do is import RxClojure, so let's get this out of the way by typing<a id="id95" class="calibre1"/> the following in the REPL:</p><div class="informalexample"><pre class="programlisting">(require '[rx.lang.clojure.core :as rx])
(import '(rx Observable))</pre></div><p class="calibre7">The <a id="id96" class="calibre1"/>simplest way to create a new observable is by calling the <code class="email">justreturn</code> function:</p><div class="informalexample"><pre class="programlisting">(def obs (rx/return 10))</pre></div><p class="calibre7">Now, we can subscribe to it:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe obs
              (fn [value]
                (prn (str "Got value: " value))))</pre></div><p class="calibre7">This will print the string <code class="email">"Got value: 10"</code> to the REPL.</p><p class="calibre7">The <code class="email">subscribe</code> function of an observable allows us to register handlers for three main things that happen throughout its life cycle: new values, errors, or a notification that the observable is done emitting values. This corresponds to the <code class="email">onNext</code>, <code class="email">onError</code>, and <code class="email">onCompleted</code> methods of the Observer interface, respectively.</p><p class="calibre7">In the preceding example, we are simply subscribing to <code class="email">onNext</code>, which is why we get notified about the observable's only value, 10.</p><p class="calibre7">A single-value Observable isn't terribly interesting though. Let's create and interact with one that emits multiple values:</p><div class="informalexample"><pre class="programlisting">(-&gt; (rx/seq-&gt;o [1 2 3 4 5 6 7 8 9 10])
    (rx/subscribe prn))</pre></div><p class="calibre7">This will print the numbers from 1 to 10, inclusive, to the REPL. <code class="email">seq-&gt;o</code> is a way to create observables from Clojure sequences. It just so happens that the preceding snippet can be rewritten using Rx's own <code class="email">range</code> operator:</p><div class="informalexample"><pre class="programlisting">(-&gt; (rx/range 1 10)
    (rx/subscribe prn))</pre></div><p class="calibre7">Of course, this doesn't yet present any advantages to working with raw values or sequences in Clojure.</p><p class="calibre7">But what if we need an observable that emits an undefined number of integers at a given interval? This becomes challenging to represent as a sequence in Clojure, but Rx makes it trivial:</p><div class="informalexample"><pre class="programlisting">(import '(java.util.concurrent TimeUnit))
(rx/subscribe (Observable/interval 100 TimeUnit/MILLISECONDS)
              prn-to-repl)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre7">RxClojure doesn't yet provide bindings to all of RxJava's API. The <code class="email">interval</code> method is one such example. We're required to use interoperability and call the method directly on the <code class="email">Observable</code> class from RxJava.</p></div><p class="calibre7">Observable/interval takes as arguments a number and a time unit. In this case, we are telling it to emit an integer—starting from zero—every 100 milliseconds. If we type this in an REPL-connected editor, however, two things will happen:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We will not see any output (depending on your REPL; this is true for Emacs)</li><li class="listitem">We will have a rogue thread emitting numbers indefinitely</li></ul></div><p class="calibre7">Both issues arise from the fact that <code class="email">Observable/interval</code> is the first factory method we have<a id="id97" class="calibre1"/> used that doesn't emit values synchronously. Instead, it<a id="id98" class="calibre1"/> returns an Observable that defers the work to a separate thread.</p><p class="calibre7">The first issue is simple enough to fix. Functions such as <code class="email">prn</code> will print to whatever the dynamic var <code class="email">*out*</code> is bound to. When working in certain REPL environments such as Emacs', this is bound to the REPL stream, which is why we can generally see everything we print.</p><p class="calibre7">However, since Rx is deferring the work to a separate thread, <code class="email">*out*</code> isn't bound to the REPL stream anymore so we don't see the output. In order to fix this, we need to capture the current value of <code class="email">*out*</code> and bind it in our subscription. This will be incredibly useful as we experiment with Rx in the REPL. As such, let's create a helper function for it:</p><div class="informalexample"><pre class="programlisting">(def  repl-out *out*)
(defn prn-to-repl [&amp; args]
  (binding [*out* repl-out]
    (apply prn args)))</pre></div><p class="calibre7">The first thing we do is create a var <code class="email">repl-out</code> that contains the current REPL stream. Next, we create a function <code class="email">prn-to-repl</code> that works just like <code class="email">prn</code>, except it uses the <code class="email">binding</code> macro to create a new binding for <code class="email">*out*</code> that is valid within that scope.</p><p class="calibre7">This still leaves us with the rogue thread problem. Now is the appropriate time to mention that the <code class="email">subscribe</code> method from an Observable returns a subscription object. By holding onto a reference to it, we can call its <code class="email">unsubscribe</code> method to indicate that we are no longer interested in the values produced by that observable.</p><p class="calibre7">Putting it all together, our interval example can be rewritten like the following:</p><div class="informalexample"><pre class="programlisting"> (def subscription (rx/subscribe (Observable/interval 100 TimeUnit/MILLISECONDS)
                                prn-to-repl))

(Thread/sleep 1000)

(rx/unsubscribe subscription)</pre></div><p class="calibre7">We<a id="id99" class="calibre1"/> create a new interval observable and immediately subscribe <a id="id100" class="calibre1"/>to it, just as we did before. This time, however, we assign the resulting subscription to a local var. Note that it now uses our helper function <code class="email">prn-to-repl</code>, so we will start seeing values being printed to the REPL straight away.</p><p class="calibre7">Next, we sleep the current—the REPL—thread for a second. This is enough time for the Observable to produce numbers from 0 to 9. That's roughly when the REPL thread wakes up and unsubscribes from that observable, causing it to stop emitting values.</p></div>

<div class="book" title="Creating Observables">
<div class="book" title="Custom Observables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec23" class="calibre1"/>Custom Observables</h2></div></div></div><p class="calibre7">Rx provides <a id="id101" class="calibre1"/>many more factory methods<a id="id102" class="calibre1"/> to create Observables (see <a class="calibre1" href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables">https://github.com/ReactiveX/RxJava/wiki/Creating-Observables</a>), but it is beyond the scope of this book to cover them all.</p><p class="calibre7">Nevertheless, sometimes, none of the built-in factories is what you want. For such cases, Rx provides the <code class="email">create</code> method. We can use it to create a custom observable from scratch.</p><p class="calibre7">As an example, we'll create our own version of the just observable we used earlier in this chapter:</p><div class="informalexample"><pre class="programlisting">(defn just-obs [v]
  (rx/observable*
   (fn [observer]
     (rx/on-next observer v)
     (rx/on-completed observer))))

(rx/subscribe (just-obs 20) prn)</pre></div><p class="calibre7">First, we create a function, <code class="email">just-obs</code>, which implements our observable by calling the <code class="email">observable*</code> function.</p><p class="calibre7">When creating an observable this way, the function passed to <code class="email">observable*</code> will get called with an observer as soon as one subscribes to us. When this happens, we are free to do whatever computation—and even I/O—we need in order to produce values and push them to the observer.</p><p class="calibre7">We should remember to call the observer's <code class="email">onCompleted</code> method whenever we're done producing <a id="id103" class="calibre1"/>values. The preceding snippet will print <code class="email">20</code> to the REPL.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre7">While creating custom observables is fairly straightforward, we should make sure we exhaust the built-in factory functions first, only then resorting to creating our own.</p></div></div></div>
<div class="book" title="Manipulating Observables"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Manipulating Observables</h1></div></div></div><p class="calibre7">Now that we know how to create observables, we should look at what kinds of interesting things we<a id="id104" class="calibre1"/> can do with them. In this section, we will see what it <a id="id105" class="calibre1"/>means to treat Observables as sequences.</p><p class="calibre7">We'll start with something simple. Let's print the sum of the first five positive even integers from an observable of all integers:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (Observable/interval 1 TimeUnit/MICROSECONDS)
                   (rx/filter even?)
                   (rx/take 5)
                   (rx/reduce +))
                   prn-to-repl)</pre></div><p class="calibre7">This is starting to look awfully familiar to us. We create an interval that will emit all positive integers starting at zero every 1 microsecond. Then, we filter all even numbers in this observable. Obviously, this is too big a list to handle, so we simply take the first five elements from it. Finally, we reduce the value using <code class="email">+</code>. The result is 20.</p><p class="calibre7">To drive home the point that programming with observables really is just like operating on sequences, we will look at one more example where we will combine two different Observable sequences. One contains the names of musicians I'm a fan of and the other the names of their respective bands:</p><div class="informalexample"><pre class="programlisting">(defn musicians []
  (rx/seq-&gt;o ["James Hetfield" "Dave Mustaine" "Kerry King"]))

(defn bands     []
  (rx/seq-&gt;o ["Metallica" "Megadeth" "Slayer"]))</pre></div><p class="calibre7">We would like to print to the REPL a string of the format <code class="email">Musician name – from: band name</code>. An added requirement is that the band names should be printed in uppercase for impact.</p><p class="calibre7">We'll start by creating another observable that contains the uppercased band names:</p><div class="informalexample"><pre class="programlisting">(defn uppercased-obs []
  (rx/map (fn [s] (.toUpperCase s)) (bands)))</pre></div><p class="calibre7">While not <a id="id106" class="calibre1"/>strictly necessary, this makes a reusable piece of <a id="id107" class="calibre1"/>code that can be handy in several places of the program, thus avoiding duplication. Subscribers interested in the original band names can keep subscribing to the <code class="email">bands</code> observable.</p><p class="calibre7">With the two observables in hand, we can proceed to combine them:</p><div class="informalexample"><pre class="programlisting">(-&gt; (rx/map vector
            (musicians)
            (uppercased-obs))
    (rx/subscribe (fn [[musician band]]
                    (prn-to-repl (str musician " - from: " band)))))</pre></div><p class="calibre7">Once more, this example should feel familiar. The solution we were after was a way to zip the two observables together. RxClojure provides <code class="email">zip</code> behavior through map, much like Clojure's core <code class="email">map</code> function does. We call it with three arguments: the two observables to <code class="email">zip</code> and a function that will be called with both elements, one from each observable, and should return an appropriate representation. In this case, we simply turn them into a vector.</p><p class="calibre7">Next, in our subscriber, we simply destructure the vector in order to access the musician and band names. We can finally print the final result to the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">"James Hetfield - from: METALLICA"</strong></span>
<span class="strong"><strong class="calibre2">"Dave Mustaine - from: MEGADETH"</strong></span>
<span class="strong"><strong class="calibre2">"Kerry King - from: SLAYER"</strong></span>
</pre></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Flatmap and friends"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Flatmap and friends</h1></div></div></div><p class="calibre7">In the previous section, we learned how to transform and combine observables with operations such <a id="id108" class="calibre1"/>as map, reduce, and <code class="email">zip</code>. However, the two observables <a id="id109" class="calibre1"/>above—musicians and bands—were perfectly capable of producing values on their own. They did not need any extra input.</p><p class="calibre7">In this section, we examine a different scenario: we'll learn how we can combine observables, where the output of one is the input of another. We encountered <code class="email">flatmap</code> before in <a class="calibre1" title="Chapter 1. What is Reactive Programming?" href="part0015_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre8">What is Reactive Programming?</em></span> If you have been wondering what its role is, this section addresses exactly that.</p><p class="calibre7">Here's what we<a id="id110" class="calibre1"/> are going to do: given an observable representing a list of all<a id="id111" class="calibre1"/> positive integers, we'll calculate the factorial for all even numbers in that list. Since the list is too big, we'll take five items from it. The end result should be the factorials of 0, 2, 4, 6, and 8, respectively.</p><p class="calibre7">The first thing we need is a function to calculate the factorial of a number <span class="strong"><em class="calibre8">n</em></span>, as well as our observable:</p><div class="informalexample"><pre class="programlisting">(defn factorial [n]
  (reduce * (range 1 (inc n))))

(defn all-positive-integers []
  (Observable/interval 1 TimeUnit/MICROSECONDS))</pre></div><p class="calibre7">Using some type of visual aid will be helpful in this section, so we'll start with a marble diagram representing the previous observable:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Flatmap and friends" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The middle arrow represents time and it flows from left to right. This diagram represents an infinite Observable sequence, as indicated by the use of ellipsis at the end of it.</p><p class="calibre7">Since we're combining all the observables now, we'll create one that, given a number, emits its factorial using the helper function defined earlier. We'll use Rx's <code class="email">create</code> method for this purpose:</p><div class="informalexample"><pre class="programlisting">(defn fact-obs [n]
  (rx/observable*
   (fn [observer]
     (rx/on-next observer (factorial n))
     (rx/on-completed observer))))</pre></div><p class="calibre7">This is very similar to the <code class="email">just-obs</code> observable we created earlier in this chapter, except that it calculates the factorial of its argument and emits the result/factorial instead, ending the sequence immediately<a id="id112" class="calibre1"/> thereafter. The following diagram illustrates how it works:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Flatmap and friends" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We feed the <a id="id113" class="calibre1"/>number 5 to the observable, which in turn emits its factorial, 120. The vertical bar at the end of the time line indicates the sequence terminates then.</p><p class="calibre7">Running the code confirms that our function is correct:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (fact-obs 5) prn-to-repl)

<span class="strong"><strong class="calibre2">;; 120</strong></span>
</pre></div><p class="calibre7">So far so good. Now, we need to combine both observables in order to achieve our goal. This is where <code class="email">flatmap</code> of Rx comes in. We'll first see it in action and then get into the explanation:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (all-positive-integers)
                   (rx/filter  even?)
                   (rx/flatmap fact-obs)
                   (rx/take 5))
              prn-to-repl)</pre></div><p class="calibre7">If we run the preceding code, it will print the factorials for 0, 2, 4, 6, and 8, just like we wanted:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
<span class="strong"><strong class="calibre2">24</strong></span>
<span class="strong"><strong class="calibre2">720</strong></span>
<span class="strong"><strong class="calibre2">40320</strong></span>
</pre></div><p class="calibre7">Most of the<a id="id114" class="calibre1"/> preceding code snippet should look familiar. The first thing we do is<a id="id115" class="calibre1"/> filter all even numbers from <code class="email">all-positive-numbers</code>. This leaves us with the following observable sequence:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Flatmap and friends" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Much like <code class="email">all-positive-integers</code>, this, too, is an infinite observable.</p><p class="calibre7">However, the next line of our code looks a little odd. We call <code class="email">flatmap</code> and give it the <code class="email">fact-obs</code> function. A function we know itself returns another observable. <code class="email">flatmap</code> will call <code class="email">fact-obs</code> with each value it emits. <code class="email">fact-obs</code> will, in turn, return a single-value observable for each number. However, our subscriber doesn't know how to deal with observables! It's simply interested in the factorials!</p><p class="calibre7">This is why, after calling <code class="email">fact-obs</code> to obtain an observable, <code class="email">flatmap</code> flattens all of them into a single observable we can subscribe to. This is quite a mouthful, so let's visualize what this means:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Flatmap and friends" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can<a id="id116" class="calibre1"/> see in the preceding diagram, throughout the execution of <code class="email">flatmap</code>, we<a id="id117" class="calibre1"/> end up with a list of observables. However, we don't care about each observable but rather about the values they emit. <code class="email">Flatmap</code>, then, is the perfect tool as it combines—<span class="strong"><em class="calibre8">flattens</em></span>—all of them into the observable sequence shown at the bottom of the figure.</p><p class="calibre7">You can think of <code class="email">flatmap</code> as <span class="strong"><em class="calibre8">mapcat</em></span> for observable sequences.</p><p class="calibre7">The rest of the code is straightforward. We simply take the first five elements from this observable and subscribe to it, as we have been doing so far.</p></div>

<div class="book" title="Flatmap and friends">
<div class="book" title="One more flatmap for the road"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec24" class="calibre1"/>One more flatmap for the road</h2></div></div></div><p class="calibre7">You might be wondering what would happen if the observable sequence we're <span class="strong"><em class="calibre8">flatmapping</em></span> emitted <a id="id118" class="calibre1"/>more than one value. What then?</p><p class="calibre7">We'll see one last example before we begin the next section in order to illustrate the behavior of <code class="email">flatMap</code> in such cases.</p><p class="calibre7">Here's an observable that emits its argument twice:</p><div class="informalexample"><pre class="programlisting">(defn repeat-obs [n]
  (rx/seq-&gt;o (repeat 2 n)))</pre></div><p class="calibre7">Using it is straightforward:</p><div class="informalexample"><pre class="programlisting">(-&gt; (repeat-obs 5)
    (rx/subscribe prn-to-repl))

<span class="strong"><strong class="calibre2">;; 5</strong></span>
<span class="strong"><strong class="calibre2">;; 5</strong></span>
</pre></div><p class="calibre7">As previously, we'll now combine this observable with the one we created earlier, <code class="email">all-positive-integers</code>. Before reading on, think about what you expect the output to be for, say, the first three positive integers.</p><p class="calibre7">The code is as follows:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (all-positive-integers)
                   (rx/flatmap repeat-obs)
                   (rx/take 6))
              prn-to-repl)</pre></div><p class="calibre7">And the output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">0</strong></span>
<span class="strong"><strong class="calibre2">0</strong></span>
<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
</pre></div><p class="calibre7">The result might be unexpected for some readers. Let's have a look at the marble diagram for this example and make sure we understand how it works:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="One more flatmap for the road" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Each time <code class="email">repeat-obs</code> gets called, it emits two values and terminates. <code class="email">flatmap</code> then combines <a id="id119" class="calibre1"/>them all in a single observable, making the previous output clearer.</p><p class="calibre7">One last thing worth mentioning about <code class="email">flatmap</code>—and the title of this section—is that its "friends" refer to the several names by which <code class="email">flatmap</code> is known.</p><p class="calibre7">For instance, Rx.NET calls it <code class="email">selectMany</code>. RxJava and Scala call it <code class="email">flatMap</code>—though RxJava has an alias for it called <code class="email">mapMany</code>. The Haskell community calls it <span class="strong"><em class="calibre8">bind</em></span>. Though they have different names, these functions semantics are the same and are part of a higher-order abstraction called a <a id="id120" class="calibre1"/>Monad. We don't need to know anything about Monads to proceed.</p><p class="calibre7">The important thing to keep in mind is that when you're sitting at the bar talking to your friends <a id="id121" class="calibre1"/>about <span class="strong"><strong class="calibre2">Compositional Event Systems</strong></span>, all these names mean the same thing.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Error handling"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Error handling</h1></div></div></div><p class="calibre7">A very important <a id="id122" class="calibre1"/>aspect of building reliable applications is knowing what <a id="id123" class="calibre1"/>to do when things go wrong. It is naive to assume that the network is reliable, that hardware won't fail, or that we, as developers, won't make mistakes.</p><p class="calibre7">RxJava embraces this fact and provides a rich set of combinators to deal with failure, a few of which we examine here.</p></div>

<div class="book" title="Error handling">
<div class="book" title="OnError"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec25" class="calibre1"/>OnError</h2></div></div></div><p class="calibre7">Let's get <a id="id124" class="calibre1"/>started by creating a badly behaved observable that always throws an <a id="id125" class="calibre1"/>exception:</p><div class="informalexample"><pre class="programlisting">(defn exceptional-obs []
  (rx/observable*
   (fn [observer]
     (rx/on-next observer (throw (Exception. "Oops. Something went wrong")))
     (rx/on-completed observer))))</pre></div><p class="calibre7">Now let's watch what happens if we subscribe to it:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (exceptional-obs)
                   (rx/map inc))
              (fn [v] (prn-to-repl "result is " v)))

;; Exception Oops. Something went wrong  rx-playground.core/exceptional-obs/fn--1505</pre></div><p class="calibre7">The exception thrown by <code class="email">exceptional-obs</code> isn't caught anywhere so it simply bubbles up to the REPL. If this was a web application our users would be presented with a web server error such as the <span class="strong"><strong class="calibre2">HTTP code 500 – Internal Server Error</strong></span>. Those users would probably not use our system again.</p><p class="calibre7">Ideally, we would like to get a chance to handle this exception gracefully, possibly rendering a friendly error message that will let ours users know we care about them.</p><p class="calibre7">As we have seen earlier in the chapter, the <code class="email">subscribe</code> function can take up to 3 functions as arguments:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first, or the <code class="email">onNext</code> handler, is called when the observable emits a new value</li><li class="listitem">The second, or <code class="email">onError</code>, is called whenever the observable throws an exception</li><li class="listitem">The third and last function, or <code class="email">onComplete</code>, is called when the observable has completed and will not emit any new items</li></ul></div><p class="calibre7">For our<a id="id126" class="calibre1"/> purposes we are interested in the <code class="email">onError</code> handler, and using<a id="id127" class="calibre1"/> it is straightforward:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (exceptional-obs)
                   (rx/map inc))
              (fn [v] (prn-to-repl "result is " v))
              (fn [e] (prn-to-repl "error is " e)))

;; "error is " #&lt;Exception java.lang.Exception: Oops. Something went wrong&gt;</pre></div><p class="calibre7">This time, instead of throwing the exception, our error handler gets called with it. This gives us the opportunity to display an appropriate message to our users.</p></div></div>

<div class="book" title="Error handling">
<div class="book" title="Catch"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec26" class="calibre1"/>Catch</h2></div></div></div><p class="calibre7">The use of <code class="email">onError</code> gives us a much better experience overall but it isn't very flexible.</p><p class="calibre7">Let's imagine<a id="id128" class="calibre1"/> a different scenario where we have an observable <a id="id129" class="calibre1"/>retrieving data from the network. What if, when this observer fails, we would like to present the user with a cached value instead of an error message?</p><p class="calibre7">This is where the <code class="email">catch</code> combinator comes in. It allows us to specify a function to be invoked when the observable throws an exception, much like <code class="email">OnError</code> does. </p><p class="calibre7">Differently from <code class="email">OnError</code>, however, <code class="email">catch</code> has to return a new Observable that will be the new source of items from the moment the exception was thrown:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (exceptional-obs)
                   (rx/catch Exception e
                       (rx/return 10))
                   (rx/map inc))
              (fn [v] (prn-to-repl "result is " v)))

;; "result is " 11</pre></div><p class="calibre7">In the previous example, we are essentially specifying that, whenever <code class="email">exceptional-obs</code> throws, we should return the value <code class="email">10</code>. We are not limited to single values, however. In fact, we can use any Observable we like as the new source:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (exceptional-obs)
                   (rx/catch Exception e
                     (rx/seq-&gt;o (range 5)))
                   (rx/map inc))
              (fn [v] (prn-to-repl "result is " v)))

;; "result is " 1
;; "result is " 2
;; "result is " 3
;; "result is " 4
;; "result is " 5</pre></div></div></div>

<div class="book" title="Error handling">
<div class="book" title="Retry"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec27" class="calibre1"/>Retry</h2></div></div></div><p class="calibre7">The last error handling combinator we'll examine is <code class="email">retry</code>. This combinator is useful when we know<a id="id130" class="calibre1"/> an error or exception is only transient so we should probably<a id="id131" class="calibre1"/> give it another shot by resubscribing to the Observable.</p><p class="calibre7">First, we'll create an observable that fails when it is subscribed to for the first time. However, the next time it is subscribed to, it succeeds and emits a new item:</p><div class="informalexample"><pre class="programlisting">(defn retry-obs []
  (let [errored (atom false)]
    (rx/observable*
     (fn [observer]
       (if @errored
         (rx/on-next observer 20)
         (do (reset! errored true)
             (throw (Exception. "Oops. Something went wrong"))))))))</pre></div><p class="calibre7">Let's see what happens if we simply subscribe to it:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (retry-obs)
              (fn [v] (prn-to-repl "result is " v)))

;; Exception Oops. Something went wrong  rx-playground.core/retry-obs/fn--1476</pre></div><p class="calibre7">As expected, the exception simply bubbles up as in our first example. However we know—for the purposes of this example—that this is a transient failure. Let's see what changes if we use <code class="email">retry</code>:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (retry-obs)
                   (.retry))
              (fn [v] (prn-to-repl "result is " v)))

;; "result is " 20</pre></div><p class="calibre7">Now, our code is responsible for retrying the Observable and as expected we get the correct output.</p><p class="calibre7">It's important to note that <code class="email">retry</code> will attempt to resubscribe indefinitely until it succeeds. This might not be what you want so Rx provides a variation, called <code class="email">retryWith</code>, which allows us to<a id="id132" class="calibre1"/> specify a predicate function that controls when and if retrying <a id="id133" class="calibre1"/>should stop.</p><p class="calibre7">All these operators give us the tools we need to build reliable reactive applications and we should always keep them in mind as they are, without a doubt, a great addition to our toolbox. The <a id="id134" class="calibre1"/>RxJava wiki on the subject should be referred to for more information: <a class="calibre1" href="https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators">https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Backpressure"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Backpressure</h1></div></div></div><p class="calibre7">Another issue we might be faced with is the one of observables that produce items faster than <a id="id135" class="calibre1"/>we can consume. The problem that arises in this scenario is what to do with this ever-growing backlog of items.</p><p class="calibre7">As an example, think about zipping two observables together. The <code class="email">zip</code> operator (or <code class="email">map</code> in RxClojure) will only emit a new value when all observables have emitted an item.</p><p class="calibre7">So if one of these observables is a lot faster at producing items than the others, <code class="email">map</code> will need to buffer these items and wait for the others, which will most likely cause an error, as shown here:</p><div class="informalexample"><pre class="programlisting">(defn fast-producing-obs []
  (rx/map inc (Observable/interval 1 TimeUnit/MILLISECONDS)))

(defn slow-producing-obs []
  (rx/map inc (Observable/interval 500 TimeUnit/MILLISECONDS)))

(rx/subscribe (-&gt;&gt; (rx/map vector
                           (fast-producing-obs)
                           (slow-producing-obs))
                   (rx/map (fn [[x y]]
                             (+ x y)))
                   (rx/take 10))
              prn-to-repl
              (fn [e] (prn-to-repl "error is " e)))

;; "error is " #&lt;MissingBackpressureException rx.exceptions.MissingBackpressureException&gt;</pre></div><p class="calibre7">As seen in the preceding code, we have a fast producing observable that emits items 500 times faster than the slower Observable. Clearly, we can't keep up with it and surely enough, Rx throws <code class="email">MissingBackpressureException</code>.</p><p class="calibre7">What this<a id="id136" class="calibre1"/> exception is telling us is that the fast producing observable doesn't support any type of backpressure—what Rx calls <span class="strong"><em class="calibre8">Reactive pull backpressure</em></span>—that is, consumers can't tell it to go slower. Thankfully Rx provides us with combinators that are helpful in these scenarios.</p></div>

<div class="book" title="Backpressure">
<div class="book" title="Sample"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec28" class="calibre1"/>Sample</h2></div></div></div><p class="calibre7">One such <a id="id137" class="calibre1"/>combinator is <code class="email">sample</code>, which allows us to sample <a id="id138" class="calibre1"/>an observable at a given interval, thus throttling the source observable's output. Let's apply it to our previous example:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (rx/map vector
                           (.sample (fast-producing-obs) 200
                                    TimeUnit/MILLISECONDS)
                           (slow-producing-obs))
                   (rx/map (fn [[x y]]
                             (+ x y)))
                   (rx/take 10))
              prn-to-repl
              (fn [e] (prn-to-repl "error is " e)))

;; 204
;; 404
;; 604
;; 807
;; 1010
;; 1206
;; 1407
;; 1613
;; 1813
;; 2012</pre></div><p class="calibre7">The only change is that we call <code class="email">sample</code> on our fast producing Observable before calling <code class="email">map</code>. We will sample it every 200 milliseconds.</p><p class="calibre7">By ignoring all other items emitted in this time slice, we have mitigated our initial problem, even though the original Observable doesn't support any form of backpressure.</p><p class="calibre7">The sample combinator is only one of the combinators useful in such cases. Others include <code class="email">throttleFirst</code>, <code class="email">debounce</code>, <code class="email">buffer</code>, and <code class="email">window</code>. One drawback of this approach, however, is that a lot of the items generated end up being ignored.</p><p class="calibre7">Depending <a id="id139" class="calibre1"/>on the type of application we are building, this <a id="id140" class="calibre1"/>might be an acceptable compromise. But what if we are interested in all items?</p></div></div>

<div class="book" title="Backpressure">
<div class="book" title="Backpressure strategies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec29" class="calibre1"/>Backpressure strategies</h2></div></div></div><p class="calibre7">If an Observable <a id="id141" class="calibre1"/>doesn't support backpressure but we are still interested in all items it emits, we can use one of the built-in backpressure combinators provided by Rx.</p><p class="calibre7">As an example we will look at one such combinator, <code class="email">onBackpressureBuffer</code>:</p><div class="informalexample"><pre class="programlisting">(rx/subscribe (-&gt;&gt; (rx/map vector
                           (.onBackpressureBuffer (fast-producing-obs))
                           (slow-producing-obs))
                   (rx/map (fn [[x y]]
                             (+ x y)))
                   (rx/take 10))
              prn-to-repl
              (fn [e] (prn-to-repl "error is " e)))

;; 2
;; 4
;; 6
;; 8
;; 10
;; 12
;; 14
;; 16
;; 18
;; 20</pre></div><p class="calibre7">The example is very similar to the one where we used <code class="email">sample</code>, but the output is fairly different. This time we get all items emitted by both observables.</p><p class="calibre7">The <code class="email">onBackpressureBuffer</code> strategy implements a strategy that simply buffers all items emitted by the slower Observable, emitting them whenever the consumer is ready. In our case, that happens every 500 milliseconds.</p><p class="calibre7">Other strategies include <code class="email">onBackpressureDrop</code> and <code class="email">onBackpressureBlock</code>.</p><p class="calibre7">It's worth noting that Reactive pull backpressure is still work in progress and the best way to keep up to <a id="id142" class="calibre1"/>date with progress is on the RxJava wiki on the<a id="id143" class="calibre1"/> subject: <a class="calibre1" href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">https://github.com/ReactiveX/RxJava/wiki/Backpressure</a>.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we took a deep dive into RxJava, a port form Microsoft's Reactive Extensions from .NET. We learned about its main abstraction, the observable, and how it relates to iterables.</p><p class="calibre7">We also learned how to create, manipulate, and combine observables in several ways. The examples shown here were contrived to keep things simple. Nevertheless, all concepts presented are extremely useful in real applications and will come in handy for our next chapter, where we put them to use in a more substantial example.</p><p class="calibre7">Finally, we finished by looking at error handling and backpressure, both of which are important characteristics of reliable applications that should always be kept in mind.</p></div></body></html>