- en: A Look at Monad Transformers and Free Monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In
    Effects*, we looked at standard effects and promised to reveal the truth about
    the concepts underlying them; we also discussed the topic of combining them. Since
    then, we have discussed algebraic structures, such as monoids and groups, functors,
    applicatives, and monads, delivering on our first promise. But the composition
    topic has remained uncovered all this time.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml), *Dealing with Effects*,
    we implemented a general way to compose applicatives—which is very useful on its
    own, but can't help us with combining the standard effects of a monadic nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will finally take on and keep our second promise by discussing
    some ways to bring different monadic effects together. We will look at the complications
    related to that and some of the solutions used in the Scala community to deal
    with these obstacles, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monad transformer stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Combining monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In
    Effects*, we talked about standard effects such as `Option`, `Try`, `Either`,
    and `Future`. In [Chapter 9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing
    Yourself with Basic Monads*, we moved on and implemented monads for all of them.
    In our examples, we demonstrated how Scala provides nice syntax for the code formulated
    in monadic terms by having for-comprehension, which is a syntactic sugar for the
    combination of `map`, `flatMap`, and possibly `filter` methods. In all our examples,
    we used for-comprehension to define a sequence of steps which constitute some
    process where the result of the previous computation is consumed by the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an instance, this is the way we defined the process of fishing in terms
    of `Option` in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With our new obtained knowledge about monads, we could make this implementation
    effect-agnostic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One thing we can't do with this approach is to use the `orElse` method specific
    to `Option` to define the unhappy path for bait-acquiring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another simplification we''re making here is pretending that all our actions
    can be described by the same effect. In reality, this will almost definitely not
    be the case. To be more specific, obtaining the bait and waiting to hook the fish
    will probably take much longer than casting the line. Thus, we probably would
    like to represent these actions with `Future` instead of `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in generic terms, we would have the type of effect `N` instead of `M`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But, unfortunately, this won''t compile anymore. Let''s consider a simpler
    example to understand why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler ceases to accept `Future` instead of the `Option`. Let''s desugar
    our for-comprehension to see what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the problem lies on the surface—the `Option.flatMap` expects some function
    returning an `Option` as an effect (this is using the definition of `Option.flatMap[B](f:
    A => Option[B]): Option[B]` in particular, and `Monad.flatMap` in general). But
    the value we return is wrapped in `Future`, as a result of applying the `map`
    function of the `Future`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generalising this reasoning, we can conclude that it is only possible to use
    effects of the same type in the single for-comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, it looks like we have two possibilities to combine desired
    effects:'
  prefs: []
  type: TYPE_NORMAL
- en: Put them in separate for-comprehensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lift different effects to some kind of common denominator type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can compare both approaches using our fishing example as the playground.
    The variation of separate for-comprehensions would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This looks slightly worse than the original version but is still quite nice,
    apart from the fact that the type of the result has changed from `N[Fish]` to
    the `M[N[M[N[Fish]]]]`. In the specific cases of `Future` and `Option`, it would
    be `Option[Future[Option[Future[Fish]]]]` and there is no easy way to extract
    the result other than going through all of the layers one by one. This is not
    a very nice thing to do and we'll leave it as an exercise for the scrupulous reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option would be to abandon the generosity of our implementation and
    make it nonpolymorphic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Besides losing general applicability, this implementation has the obvious disadvantage
    of being much less readable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's hope that the second approach, the common denominator for the effect type,
    will bear more fruit than the first one.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to decide how we want to compose the two effects we currently
    have. There are two choices: `Future[Option[?]]` and `Option[Future[?]]`. Semantically,
    having an optional result at some point later feels better than optionally having
    an operation which will complete in the future, hence we will continue with the
    first alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this fixed new type, the functions we have became invalid—they all now
    have the wrong type of result. Conversion to the proper type just involves juggling
    the types and we can do this on the spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is to wrap `Option` into the `Future` or `Future` into the
    `Option`, depending on the return type of the original function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep everything consistent, we''ll also change the type of the argument
    and return type of the `goFishing` function in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we strive to formulate the logic itself as a for-comprehension, it is reasonable
    to try to draw it up it in terms of the `flatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As an argument to `flatMap`, we have to provide some function which takes an
    `Option[String]` and returns `Future[Option[Fish]]`. But our functions expect
    "real" input, not optional. We can''t `flatMap` over the `Option` as discussed
    before and we can''t just use `Option.map` because it will wrap our result type
    in an additional layer of optionality. What we can use is a pattern match to extract
    the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `None`, we just shortcut the process and return the result.
    In that case, we indeed have a `name`; we can call a corresponding function, passing
    this `name` as an argument. The question is, how do we proceed further? If we
    look carefully at the return type of `buyBaitFO(name)`, we will see that this
    is the same as we had for the initial argument—`Future[Option[?]]`. Hence, we
    can try to reuse the approach with flatmapping and pattern matching again, which after
    all its iterations gives us the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of duplication in this snippet, but it already looks somehow
    structured. It is possible to improve its readability by extracting the repetitive
    code fragments. First, we can make the case of *no result* polymorphic as shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we might capture our reasoning about `flatMap` and pattern match as
    a standalone polymorphic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, our last attempt starts to look more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is arguably something that is already quite good, and we could stop at
    this moment, but there is one aspect we might improve further on. The `continue`
    function calls are nested. This makes it nontrivial to formulate the business
    logic flow. It might be beneficial if we could have a kind of fluent interface
    instead and we would be able to chain the `continue` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easily achieved by capturing the first argument of `continue` as a value
    of some class. This will change our implementation to the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to improve this further. First, the signature of `continue`
    reveals that it is a Kleisli arrow, which we introduced in the previous chapter.
    Second, in this form, we will need to wrap the `value` in `FutureOption` manually
    each time we need to call the `continue` method. This will make the code unnecessarily
    verbose and we can enhance our implementation by making it an `implicit` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at what our main flow looks like with these changes incorporated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! Can you spot further possibility for improvement? If we scrutinise
    the type signature of the `FutureOption`, we''ll see that everything we''re doing
    with the wrapped `value` is calling a `flatMap` method which is defined on `Future`.
    But we already know the proper abstraction for that—this is a monad. Utilizing
    this knowledge will allow us to make our class polymorphic and possibly reuse
    it for other types of effects, if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate that the polymorphic nature of the new implementation won't harm
    our flexibility to define helper functions as needed, we've also added a method
    to check that the composition of monads we have is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, if we'll try to make this implementation polymorphic in the type
    of the second effect, we'll see that it is impossible—we need to decompose it
    as explained previously, and for this we need to know the specifics of the effect's
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, an astute reader will remember that all monads we developed
    in the previous chapter were implemented in terms of `compose` function, which
    had the same signature. Could we try to do the same trick again and implement
    a monad for the `FutureOption` type? Readers familiar with the previous chapter
    will know that this is almost a mechanical task of delegating to the implementation
    we just came up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we also need to change the return type of the original functions to be
    a `FOption[Future, ?]` to match the type signature of our new monad. We don''t
    need to touch the implementation—the compiler will wrap `implicit FOption` around
    the result automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can formulate our logic once again, this time in terms of for-comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, this is nice and clean! The final touch would be to do something with
    the adhoc name of `FOption`. What the type does is *transform* an `Option` into
    something monadic of higher order, by wrapping an `Option` into a monadic effect
    of our choice. We could rename it into `OptionTransformer` or `OptionT` for short.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We just implemented a monad transformer.
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's hold on for a second and recap what we just did.
  prefs: []
  type: TYPE_NORMAL
- en: We made a small sacrifice and increased the complexity of the return type of
    our original functions to some "common denominator" type. This sacrifice is rather
    small because in our example, as well as in real life, this is usually done by
    just lifting the original functions into their proper context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signatures we came up with look a little awkward, but this is partly because
    we started to develop them as concrete implementations. In fact, the user-facing
    API of our fishing component should be similar to the following snippet straight
    from the beginning, if implemented in a more abstract way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This approach abstracts over the type of effect, giving more flexibility to
    us as library authors and more structure to the user of our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This API can be used with any effect with a monad. This is an example of how
    it can be implemented utilizing functions we currently have—returning mixed `Future`
    and `Optional` results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Exactly as before, we implemented facades for our original functions, doing
    nothing more than routine lifting of them into the appropriate effect. And the
    `goFishing` method can be used as is—the compiler takes only a monad for the `OptoinT[Future]`
    available to make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, at some point the implementor of the underlying functions can
    decide that they should return `Try` instead of the future now. This is OK because
    requirements change and we can incorporate this change in our logic quite easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the change in the library is given, the only things we need to
    alter on our side are:'
  prefs: []
  type: TYPE_NORMAL
- en: The lifting approach for the `castLine` function; it changes from `Future.success`
    to `Try.apply`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type parameter we're passing over for the wrapper for the initial argument
    of the `goFishing` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And we're done. We don't need to touch our fishing "business" logic at all!
  prefs: []
  type: TYPE_NORMAL
- en: The monad transformer in a sense "flattens" both monads, such that it is possible
    to cut through all layers at once when calling the `map` and `flatMap` methods—and
    thus also in for-comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, it is not possible to change the type of the "inner" effect though—
    we only have an `OptionT` monad transformer available. But this is just a matter
    of implementing another transformer once, entirely like we did with monads. To
    be more specific, let''s see the effect of altering the return type of the basic
    functions to `Either` instead of `Option`. Supposing it is expected that the new
    version uses `String` as a description of the unhappy case; we would have the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The return type of `castLineImpl` is now `Either[String, Line]` as new requirements
    dictate. The lifting we are doing is slightly convoluted, just because we need
    to convey the types of both the left and right side of `Either` to the compiler.
    The rest of the implementation is the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'And it relies on the fact that we have an instance of `EitherT` and a corresponding
    monad available. We already know how to implement monad transformers and can come
    up with the code in no time. First, the `EitherT` class, which resembles an `OptionT`
    almost identically, with respect to the need to carry the type of the left side
    of `Either` around as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Instead of pattern matching on `None` and `Some`, we pattern-match on the `Left`
    and `Right` sides of `Either`. We also replace the helper method `isEmpty` with
    the more suitable `isRight`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifting function and the implementation of the monad are also considerably
    similar—just boilerplate, if you will:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Incredible! We now have two monad transformers in our toolbox and the previously
    broken definition of `Ch10EitherTFutureFishing` has started to compile and run!
  prefs: []
  type: TYPE_NORMAL
- en: Eager to implement `TryT` to cement this newly gained knowledge? We're happy
    to leave this as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformers stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the meantime, we''ll entertain ourselves with the following ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformers require an instance of a monad for the outer layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A monad transformer itself has a monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will something bad happen if we use a monad transformer as an instance of a
    monad for another monad transformer?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try it out. We''ve already implemented two monad transformers so let''s
    bring them together. To start, we''ll define the type of stack. It will be `EitherT`
    wrapped in `OptionT`. This will give us an unwrapped type of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This can be interpreted as an operation which takes time and might return an
    error in the case of nontechnical failure and needs to have an explanation (technical
    failures are denoted by failed `Futures`). An `Option` represents an operation
    which can return no result in a natural way that requires no further explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With type aliases, we can represent the type of the inner transformer, fixing
    `String` as the type of the left side, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The outer transformer in the stack is even simpler. In contrast to the inner
    type, where we fixed the type of effect to be `Future`, it takes a type constructor
    for an effect as the type parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use these aliases to define the whole stack as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the situation realistic, we''ll just take the last version of our original
    fishing functions—the one with `castLineImpl` returns `Either[String, Line]`.
    We need to decorate all original functions so that the result type matches the
    type of the stack we now have. This is where it starts to become unwieldy. The
    compiler is not allowed to apply two implicit conversions in a row, so therefore
    we have to apply one of them by hand. For the two functions returning `Future[?]`,
    we also need to envelop the bottom layer into the `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now the compiler will be able to apply implicit conversion to the `OptionT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the function returning `Either[String, Line]` needs to be converted
    to `EitherT` on the outer side as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Internally, we have to `map` the contents of `Either` into an `Option` and apply
    `Future` to the whole result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler can help us to create an input of the proper type by applying
    implicit conversions as required—we won''t see a lot of changes on this side,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A small tweak is needed at the moment as we''re calling our business logic
    with this transformer stack—now we have two layers of transformation, so we need
    to call `value` two times to extract the result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It can become tedious quite quickly to turn to the `value` method repeatedly
    on each of the monad transformers that constitute the stack. Why do we need to?
    Because returning the result with the type of specific transformer can pollute
    the client''s code quite quickly. Hence, there are usually a couple of suggestions
    related to the monad transformers and monad transformer stacks worth considering,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacking monads and especially monad transformers adds performance and garbage
    collection overhead. It is essential to carefully consider the necessity of adding
    every additional layer of effects to the existing type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also arguable that more layers in the stack add mental overhead and clutter
    the code. The approach is the same as with the first suggestion—don't do this
    unless absolutely needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients usually do not operate in terms of monad transformers, therefore they
    (transformers) should be considered to be an implementation detail. The API should
    be defined in generic terms. If it needs to be specific, prefer effect types over
    transformer types. In our example, it is better to return the result of the type
    `Future[Option[?]]` compared to `OptionT[Future, ?]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given all these considerations, are monad transformers really useful in real
    life? Surely they are! Nevertheless, as always there are alternatives, for example
    the free monad.
  prefs: []
  type: TYPE_NORMAL
- en: Free monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter and the previous chapters, we represented sequenced computations
    with monads. The `flatMap` method of the monad describes how the computation steps
    should be joined and the function given to it as an argument—the computation step
    itself. The free monad elevates the concept of sequenced computations to the next
    level.
  prefs: []
  type: TYPE_NORMAL
- en: First, we start to represent the computation steps as instances of some **ADT**
    (**algebraic data type**) of our choice. Second, we represent the monadic concept
    with instances of another ADT.
  prefs: []
  type: TYPE_NORMAL
- en: To substantiate this approach, we can turn to the fishing example once again.
    Earlier, we had three actions we encoded as functions. These actions will be represented
    as value classes now. We also need to give specific meaning to the type aliases
    we've used before to be able to run examples later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of the fishing model and corresponding ADT as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the model, we represent some properties of the bait, line, and a fish so
    that we can make use of them later.
  prefs: []
  type: TYPE_NORMAL
- en: The `Action` type has a few aspects worth discussing. First of all, the instances
    of `Action` reflect that the functions we had before take a single parameter by
    declaring this parameter as a field of the class. Second, all actions are typed
    by the *type of the next action* and this next action is captured as another field
    of the class, in the form of a function which expects the result of the wrapping
    action to be an argument. This second field is how we encode the sequencing of
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to represent the monadic methods as classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`Done` assembles an instance of `Free` from a value the same way as `Monad.unit`
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `F[_]` refers to the type of actions to wrap and `A` is the type of the
    result. `F` needs to have a `Functor`; we will see why in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Join` constructs a representation of `flatMap`—it should do so by applying
    the `F` to the previous instance of `Free`. This gives us the following type of `action`
    parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as we said, this is a monad, so we need to provide an implementation of
    `flatMap`. We''ll do this on the `Free` so that it is possible to use both instances
    of `Done` and `Join` in for-comprehensions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `flatMap` naturally takes the Kleisli arrow as an argument. Similar to the
    definitions of `flatMap` on other monads, for example, an `Option`, we distinguish
    between shortcutting and exiting and continuing the computation chain. In the
    former case, we can just apply the given function; in the latter case we have
    to build up the sequence. This is where we're using the `Functor[F]` to get inside
    the `F` and apply the `flatMap` on the wrapped `Free[F, A]`, basically doing the
    sequencing in a good, old monadic way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the functor is here to give us the possibility to succeed in
    computations dictates how the functor for our actions should be implemented —the
    given function should be called on the result of the next action. Our actions
    might have quite a different structure, hence the easiest way to describe this
    approach is pattern matching, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Values of our ADT are structured similarly and this is the reason why the tranformations
    look alike for all actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last preparation step we need is to have a user-friendly way to create
    instances of the free monad for each of the actions. Let''s create helper methods
    for that in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Each of these methods creates a free monad instance which describes a computation
    consisting of a single action; the `Done(...)` encodes the fact that we are, well,
    done, and have some result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use these helper functions to build a computation chain like we
    did before. But this time the computation won''t be something callable—it is just
    a sequence of instances of the free monad captured as a single instance of `Free`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This single instance we have incorporates all of the steps in the form of `Free`
    containing actions. Represented as pseudo-code, the result of calling this method
    would look like a nested structure, as given below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, we have created the computation sequence, but this sequence
    is useless because it''s just a data structure. We need a way to make it useful—we
    have to create an interpreter for it. And this is where the free monad really
    starts to shine—it is up to us how we will render this data. We can create as
    many interpreters as we wish, for example, one for testing purposes and another
    for production use. For instance, for testing, it might be useful just to collect
    all of the actions which should happen in some journal—in an event-sourced way
    (we''ll look at event sourcing in detail later in this book). As we''re just testing,
    our journal does not need to be persistent—hence, we can just use some kind of
    collection; for example, a `List` would do, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet is indeed an interpreter for the program which is built
    in terms of the actions wrapped in `Free`. The logic is repetitive—we're producing
    the result of the action and calling this action recursively, passing the log
    with the added entry as a parameter. In the case of `Done`, we're ignoring the
    result; our goal is the log, and we return it in reversed form by calling `.reverse` to
    compensate for building it up in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the execution looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For production, we can do something else, such as collecting the executed actions.
    We will model this side-effecting by writing to the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The structure of this interpreter is naturally the same as before. The result
    type of the computation is `Unit`—everything we do is side-effecting, so there
    is no need to pass anything around. Instead of accumulating actions into the log
    we are just writing a report directly to the console. The case of `Done` is also
    little different—we're returning the `fish`, the result of the performed combined
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the execution changes as expected, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We managed to implement a very basic version of the free monad along with a
    small fishing language and two different interpreters. It is quite a bit of code
    so it''s time to answer an obvious question: for what purpose do we invest this
    additional effort?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The free monad has obvious advantages; we touched upon these, and they are
    as as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gluing the computations together as classes happens in a heap and saves stack
    memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to pass the computation over to different parts of the code and
    the side-effects will be deferred until it is explicitly run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having multiple interpreters allows for different behaviour in different circumstances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's scope has not allowed us to show how different "languages" (ADTs)
    can be composed into one algebraic structure, which then can be used to define
    the logic using both languages at the same time. This possibility offers an alternative
    to the monad transformers and monad transformer stacks, for example, a language
    that combines business terms and persistence terms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantages lie in the same plane as they do for monads. These include
    additional initial implementation effort, runtime overhead for the garbage collector,
    and processing additional instructions and mental overhead for developers new
    to the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monads are arguably the most ubiquitous abstraction in functional programming.
    Unfortunately they cannot be composed in general—in contrast to functions and
    applicatives.
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformers provide a way to work around this limitation by specifying
    a set of overarching structures to represent combinations of monads, each combination
    being specific to a single internal effect type. Monad transformers compose monads
    in a way that it is possible to cross both effects with a single call of the `flatMap`
    or `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformer stacks lift the concept of monad transformers one level higher,
    utilizing the fact that each monad transformer is also a monad. By stacking monad
    transformers, it is possible to work with virtually any number of effects combined
    together in a single pile the same way we would do with a single monad.
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformers are not without disadvantages. The list includes increased
    garbage collection footprint and processor utilization because of the need to
    unpack and repack  effects in the stack. The same reasoning applies to the mental
    model developers needed to build and maintain in their head while working with
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: The free monad provides a reasonable alternative by clearly separating structure
    and interpretation of the computations. It does so by representing business logic
    as a sequence of steps encoded as data by some ADT and executing these steps with
    suitable interpreter(s).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the second part of the book. In this part and the first
    part, we refrained from using third-party libraries and focused on giving readers
    a deep understanding of the language features and underlying theoretical concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, the code examples in this part were decidedly simplistic and
    only suitable for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically to the functional programming aspects, there are two exceptionally
    good libraries, worth mentioning one more time and available for Scala: Cats ([https://typelevel.org/cats/](https://typelevel.org/cats/))
    and Scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)).
    If we managed to ignite your interest in programming Scala using the functional
    style shown in this part of the book, we highly recommend taking a look at both
    of them. Besides offering production-ready implementation for the concepts we
    studied, they also contain lots of abstractions we weren''t able to discuss.'
  prefs: []
  type: TYPE_NORMAL
- en: In the third part of the book we will relax our self-imposed constraint about
    third-party dependencies and dedicate it to the topic of reactive programming
    in Scala using different Akka libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why does the type of monad transformer reflect the type of the stack "upside-down"
    with its name referring to the type of innermost monad?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it possible to reuse existing monads for the top layer of the stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it impossible to reuse existing monads for the bottom layer of the stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `TryT` monad transformer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `TryT` monad transformer instead of `EitherT` with the example functions
    from the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement another take on the monad transformer stack, this time with the layers
    placed upside-down: `EitherT[OptionT[Future, A], String, A]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an action to release the caught fish in the free monad example we developed
    in the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anatolii Kmetiuk, *Mastering Functional Programming*: Learn how functional
    programming can help you in deploying web servers and working with databases in
    a declarative and pure way'
  prefs: []
  type: TYPE_NORMAL
- en: Atul S. Khot, *Scala Functional Programming Patterns*: Grok and perform effective
    functional programming in Scala
  prefs: []
  type: TYPE_NORMAL
- en: Ivan Nikolov, *Scala Design Patterns* - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala
  prefs: []
  type: TYPE_NORMAL
