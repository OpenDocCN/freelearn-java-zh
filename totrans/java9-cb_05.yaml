- en: Stream Operations and Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the latest Java releases (8 and 9), the collections API has gotten a major
    facelift with the introduction of streams and internal iteration by leveraging
    lambda expressions. This chapter shows you how to leverage streams and chain multiple
    operations on a collection to create a pipeline. Also, we would like to show you
    how these operations can be done in parallel. We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the new factory methods to create collection objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and operating on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an operation pipeline on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel computations on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions described and demonstrated in the previous chapter were introduced
    in Java 8\. Together with functional interfaces, they added functional programming
    capability to Java, allowing the passing of behavior (functions) as parameters
    to the libraries optimized for the performance of data processing. This way, an
    application programmer can concentrate on the business aspects of the developed
    system, leaving performance aspects to the specialists--the authors of the library.
  prefs: []
  type: TYPE_NORMAL
- en: One example of such a library is the `java.util.stream` package, which is going
    to be the focus of this chapter. This package allows you to have a declarative
    presentation of the procedures that can be subsequently applied to the data, also
    in parallel; these procedures are presented as streams, which are objects of the `Stream` interface. For
    better transition from the traditional collections to streams, two default methods
    (`stream()` and `parallelStream()`) were added to the `java.util.Collection` interface
    along with the addition of new factory methods of stream generation to the `Stream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: This approach takes advantage of the power of composition, discussed in one
    of the previous chapters. Together with other design principles--encapsulation,
    interface, and polymorphism--it facilitates a highly extensible and flexible design,
    while lambda expressions allow you to implement it in a concise and succinct manner.
  prefs: []
  type: TYPE_NORMAL
- en: Today, when the machine learning requirements of massive data processing and
    the fine-tuning of operations have become ubiquitous, these new features reinforce
    the position of Java among the few modern programming languages of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new factory methods to create collection objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will revisit traditional ways of creating collections and
    introduce the new factory methods, namely `List.of()`, `Set.of()`, `Map.of()`,
    and `Map.ofEntries()`, that come with Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Java 9, there were several ways of creating collections. Here is the
    most popular way that was used to create `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice the usage of a default method, `forEach(Consumer)`, added to the `Iterable`
    interface in Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da7daa20-403b-4fd7-9d2e-bb011109e779.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The shorter way of doing this would be by starting with an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27db3f63-043e-4299-a8a3-93789e534dd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, while creating `Set`, we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an illustration of the results of the last two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d169fd5-e76e-4436-8fc9-6e4f3a52cf89.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that unlike `List`, the order of elements in `Set` is not preserved.
    It depends on the hash code implementation and can change from computer to computer.
    But the order remains the same between the runs on the same computer (please take
    note of this last fact because we will come back to it later).
  prefs: []
  type: TYPE_NORMAL
- en: 'The same structure, that is, the order of elements, applies to `Map` too. This
    is how we used to create `Map` before Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf84676d-a5c6-4d2b-b6cf-ebc5ecb80e14.png)'
  prefs: []
  type: TYPE_IMG
- en: Those who had to create collections often appreciated the JDK enhancement-Proposal
    269 *Convenience Factory Methods for Collections* (JEP 269) that stated *Java
    is often criticized for its verbosity* and its goal of *Provide static factory
    methods on the collection interfaces that will create compact, unmodifiable collection
    instances.*
  prefs: []
  type: TYPE_NORMAL
- en: 'In response to the criticism and the proposal, Java 9 introduced twelve `of()` static
    factory methods for each of the three interfaces. The following is the code for
    `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Twelve similar static methods were added to `Set` and `Map` too. Ten overloaded
    factory methods with a fixed number of elements were optimized for performance,
    and as stated in JEP 269, these methods *avoid array allocation, initialization,
    and garbage collection overhead that is incurred by* *varargs calls.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the same examples now becomes much more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `System.out.println()` statement was added to inject a line break between
    the different types of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a140e303-133d-4d46-b3f6-03cc1d912a11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the twelve static factory methods added to the `Map` interface was different
    from the other `of()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1109e20a-7a9b-496e-a12b-95917c5eddfd.png)'
  prefs: []
  type: TYPE_IMG
- en: So, there is no `Map.of()` factory method for an unlimited number of elements.
    One has to use `Map.ofEntries()` when creating a map with more than 10 elements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have probably noticed the `Set.of()`, `Map.of()`, and `Map.ofEntries()`
    methods do not preserve the order of their elements. This is different from the
    previous (before Java 9) instances of `Set` and `Map`; the order of elements now
    changes between runs even on the same computer (but does not change during the
    same run, no matter how many times the collection is iterated). This is an intentional
    feature intended to help programmers avoid reliance on a certain order because
    it might produce a defect as the order changes when the code is run on another
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of the collections generated by the new `of()` static methods
    of the `List`, `Set`, and `Map` interfaces is that these collections are immutable.
    What does this mean? Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the preceding code throws `java.lang.UnsupportedOperationException`
    at runtime and the following code will throw the same exception too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the collections generated by the new `of()` static methods do not allow
    null elements, and the following code throws the `java.lang.NullPointerException`
    exception at runtime too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not an accident that non-null values and immutability guarantees were
    added soon after lambda and streams were introduced. As you will see in subsequent
    recipes, the functional programming and stream pipelines encourage a fluent style
    of coding (using method chaining, as we did in the case of using the `forEach()`
    method in the examples of this recipe). This fluent style provides more compact
    and readable code and the non-null guarantee helps support it by removing the
    need for checking the `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The immutability feature, in turn, aligns well with the, effectively, final
    concept for the variables in the outside context used by lambda expressions. For
    example, a mutable collection allows you to work around this limitation and the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45e30365-bc46-4ab0-8c07-236b7d083f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that it is possible--intentionally or not--to introduce a state in
    a lambda expression and cause different outcomes of the same function in different
    contexts. This is especially dangerous in parallel processing because one cannot
    predict the state of each possible context. This is why immutability of a collection
    is a helpful addition that helps make the code more robust and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and operating on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an operation pipeline on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and operating on streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will describe how streams can be created and the operations
    that can be applied to the elements emitted by the streams.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to create a stream. Since Java 8, the `Collection` interface
    has the `stream()` method that returns a sequential stream with this collection
    as its source and the `parallelStream()` method that returns a possibly parallel
    stream with this collection as its source. This means that all the subinterfaces,
    including `Set` and `List`, also have these methods. Also, eight overloaded `stream()`
    methods were added to the `Arrays` class that created streams of different types
    from a corresponding array or subset.
  prefs: []
  type: TYPE_NORMAL
- en: The `Stream` interface has the `of()`, `generate()`, and `iterate()` methods.
    The specialized interfaces `IntStream`, `DoubleStream`, and `LongStream` have
    similar methods too, while `IntStream` also has the `range()` and `rangeClosed()` methods;
    both return `IntStream`.
  prefs: []
  type: TYPE_NORMAL
- en: There are `Files.list()`, `Files.lines()`, `Files.find()`, `BufferedReader.lines()`,
    and many other methods in the JDK that produce streams.
  prefs: []
  type: TYPE_NORMAL
- en: After a stream is created, various operations can be applied to its elements.
    A stream itself does not store data. It rather acquires them from the source (and
    provides or emits them to the operations) as needed. The operations can form a
    pipeline using the fluent style since many intermediate operations can return
    a stream too. Such operations are called *intermediate* operations. Examples of
    intermediate operations are `filter()` (selects only elements matching a criterion),
    `map()` (transforms elements according to a function), `distinct()` (removes duplicates),
    `limit()` (limits a stream to the specified number of elements), `sorted()` (transforms
    an unsorted stream into a sorted one), and other methods of the `Stream` interface
    that return `Stream` too (except those that create a stream we just mentioned).
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline ends with a **terminal operation**. The processing of the stream
    elements actually begins only when a terminal operation is being executed. Then,
    all the intermediate operations (if present) start processing and the stream closes
    and cannot be reopened as soon as the terminal operation is finished with the
    execution. Examples of terminal operations are `forEach()`, `findFirst()`, `reduce()`,
    `collect()`, `sum()`, `max()`, and other methods of the `Stream` interface that
    do not return `Stream`. Terminal operations return a result or produce a side
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: All the `Stream` methods support parallel processing, which is especially helpful
    in the case of a large amount of data processed on a multicore computer. All the
    Java Stream API interfaces and classes are in the `java.util.stream` package.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to mostly demonstrate sequential streams, created
    by the `stream()` method and similar. The processing of parallel streams is not
    much different than sequential streams. One just has to watch that the processing
    pipeline does not use a context state that can vary across different processing
    environments. We will discuss parallel processing in another recipe later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section of the recipe, we will present methods of stream creation. As
    mentioned in the introduction, each class that implements the `Set` interface
    or the `List` interface has the `stream()` method and the `parallelStream()` method
    that return an instance of the `Stream` interface. For now, we will only look
    at sequential streams created by the `stream()` method and get back to parallel
    streams later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following examples of stream creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We used the fluent style to make the code more compact and interjected `System.out.println()`
    in order to start a new line in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the preceding examples and see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c6db9b1-1228-420f-a22f-695464875d51.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that `List` preserves the order of the elements, while the order of `Set`
    elements changes at every run. This helps uncover the defects based on the reliance
    of certain order when this order is not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the Javadoc of the `Arrays` class. It has eight overloaded `stream()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Write an example of the usage of the last two methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3911a09e-22e8-4c9e-a6d7-2951e593a3d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that only the first two elements--with indexes `0` and `1`--were selected
    to be included in the stream, as the preceding second example intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the Javadoc of the `Stream` interface and see the factory methods `of()`,
    `generate()`, and `iterate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first two methods are simple, so we skip their demo and start with the third
    method, namely `of()`. It can accept either an array or just comma-delimited elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the example as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53bdba33-f03b-4498-9100-fbe8570808f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Write the examples of the usage of the `generate()` and `iterate()` methods
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We had to put a limit on the size of the streams generated by the first two
    examples. Otherwise, they would be infinite. The third example accepts a predicate
    that provides the criterion for when the iteration has to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the examples and observe the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1490742b-52b5-486a-8500-b4cd3ddb6380.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now write examples for the specialized interfaces `IntStream`, `DoubleStream`,
    and `LongStream`. Their implementations are optimized for performance when you
    process primitives by avoiding the overhead of boxing and unboxing. In addition,
    the `IntStream` interface has two more stream-generating methods, namely `range()`
    and `rangeClosed()`. Both return `IntStream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run them and see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb1ec491-591a-4845-887e-ee39c415f73b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can guess, the `range()` method produces the sequence of integers by
    an incremental step of `1`, starting with the left parameter but not including
    the right parameter. While the `rangeClosed()` method generates a similar sequence,
    it includes the right parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the example of the `Files.list(Path dir)` method, which
    returns `Stream<Path>` of all the entries of the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following excerpt is from the JDK API: *This method must be used within
    a try-with-resources statement or similar control structure to ensure that the
    stream''s open directory is closed promptly after the stream''s operations are
    completed*. This is what we did; we used a `try`-with-resources statement in this
    case. Alternatively, we could use a `try...catch...finally` construct and close
    the stream in the finally block and the result would not change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the examples and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6561316-4601-4f30-8660-2d736deaf32f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The need to close a stream explicitly can be confusing because the `Stream`
    interface extends `AutoCloseable`, and with this, one would expect that a stream
    will be closed automatically. But that is not the case. Here is what the Javadoc
    for the `Stream` interface has to say about it: *Streams have a BaseStream.close()
    method and implement AutoCloseable. Most stream instances do not actually need
    to be closed after use, as they are backed by collections, arrays, or generating
    functions, which require no special resource management. Generally, only streams
    whose source is an I/O channel, such as those returned by Files.lines(Path), will
    require closing*. This means that a programmer has to know the source of the stream
    and make sure they close it if the API for the source requires it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write an example of the `Files.lines()` method''s usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The intent was to read the first three lines of the specified file and print
    non-empty lines with an indentation of three spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run it and see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e358b49d-3156-451b-b837-5dfde91de367.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Write the example of the usage of the `ind()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous case, a stream generated by this method has to be closed
    explicitly too. The `find()` method walks the file tree rooted at a given starting
    file and at the requested depth and returns the paths to the files that match
    the predicate (which includes file attributes). Write the following code now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and you''ll get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/454b54a6-a181-4d14-8904-9510363ff393.png)'
  prefs: []
  type: TYPE_IMG
- en: If necessary, `FileVisitorOption.FOLLOW_LINKS` could be included as the last
    parameter of `Files.find()` if we need to perform a search that would follow all
    symbolic links it might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for using the `BufferedReader.lines()` method, which returns
    `Stream<String>` of lines read from a file, is a little bit different. According to
    Javadoc, *The reader must not be operated on during the execution of the terminal
    stream operation. Otherwise, the result of the terminal stream operation is undefined*.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other methods in the JDK that produce streams. But they are more
    specialized, and we will not demonstrate them here because of shortage of space.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the preceding examples, we have demonstrated several stream operations
    already--methods of the `Stream` interface. We used `forEach()` most often and
    used `limit()` a few times. The first one is a terminal operation and the second
    one is an intermediate one. Let''s look at other methods of the `Stream` interface now.
    Here are the intermediate operations, methods that return `Stream` and can be
    connected in a fluent style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The signatures of the preceding methods typically include ` "? super T"` for
    an input parameter and `"? extends R"` for the result (see the Javadoc for the
    formal definition). We simplified them by removing these notations in order to
    provide a better overview of the variety and commonality of the methods. To compensate,
    we would like to recap the meaning of the related generic notations since they
    are used extensively in the Stream API and might confuse you. Let''s look at the
    formal definition of the `flatMap()` method because it has all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `<R>`  interface in front of the method indicates to the compiler that it
    is a generic method (the one with its own type parameters). Without it, the compiler
    would be looking for the definition of a class or the `R` interface. The type
    `T` is not listed in front of the method because it is included in the `Stream<T>`
    interface definition. The `? super T` notation means that the type `T` is allowed
    here or in its superclass. The `? extends R` notation means that the type `R`
    is allowed here or its subclass. The same applies to `? extends Stream...` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get back to our (simplified) list of intermediate operations, methods
    of the `Stream` interface. We have broken them into several groups by similarity.
    The first group contains only one `peek()` method that allows you to apply the `Consumer`
    function to each of the stream elements without affecting it whatsoever because
    the `Consumer` function does not return anything. It is typically used for debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c6cd744-2804-497f-b14f-e40484870f63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second group of intermediate operations, the first three are self-explanatory.
    The `filter()` method is one of the most used operations. It does what its name
    suggests; it discards the elements that match the criterion passed as the `Predicate`
    function to the method. We saw an example of its usage in the last snippet of
    code. The `dropWhile()` method discards the elements as long as the criterion
    is met (then allows the rest of the stream elements to flow to the next operation).
    The `takeWhile()` method does the opposite; it allows the elements to flow as
    long as the criterion is met (then discards the rest of the elements). Here is
    an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code reads the file where this code is stored. It discards all the first
    lines of the file that do not have the `dropWhile().takeWhile()` substring, then
    allows all the lines to flow until the `} catch` substring is found. Notice that
    we had to break this string into `"} catch" + "h" ` so that the criterion would
    not return `true` for this line. The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62ee8c12-3312-435c-a973-e13884cb3837.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The group of `map()` operations is pretty straightforward too. Such an operation
    transforms each element of the stream by applying to it a function that was passed
    in as a parameter. We have already seen an example of the usage of the `mapToInt()`
    method. Here is another example of the `map()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we transform `String` literals into `boolean`. The result
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a2e5626-3536-45d8-b75d-29dafa75b623.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next group of intermediate operations, called `flatMap()`, provides more
    complex processing. A `flatMap()` operation applies the passed-in function (that
    returns a stream) to each of the elements so that the operation could produce
    a stream composed of the streams extracted from each of the elements. Here''s
    an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'From the input stream, the preceding code selects only literals that contain
    `Th` and converts them into a stream of characters, which are then printed out
    by `forEach()`. The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cf67794-6dd0-4a5d-9c0d-5a10fbce7b58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `concat()` method creates a stream from two input streams so that all the
    elements of the first stream are followed by all the elements of the second stream.
    Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/284c93ff-e7ea-4ee3-abc0-f5f41c2ee1fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case there are more than two stream concatenations, you can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Function.identity()` is a function that returns its input argument (because
    we do not need to transform the input streams but just pass them as is to the
    resulting stream). The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad05dc2c-a8f6-474b-a382-9baef7e45811.png)'
  prefs: []
  type: TYPE_IMG
- en: The last group of intermediate operations is composed of the `sorted()` methods
    that sort the stream elements in a natural (without parameters) or specified (according to
    the passed-in `Comparator`) order. It is a stateful operation (as well as `distinct()`,
    `limit()`, and `skip()`) that yields a non-deterministic result in the case of
    parallel processing; this is, however, the topic of a later recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at terminal operations (we simplified their signature too by
    removing `? super T` and `? extends R`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two groups are self-explanatory, but we need to say a few words about `Optional`.
    The Javadoc defines it this way: *A container object which may or may not contain
    a non-null value. If a value is present, isPresent() returns true and get() returns
    the value*. It allows you to avoid `NullPointerException` or check for `null`
    (which would break the one-line style of code writing). For the same reason, it
    has its own methods: `map()`, `filter()`, and `flatMap()`. In addition, Optional
    has methods that include the `isPresent()` check implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ifPresent(Consumer<T> action)`: This performs the action with the value (if
    present, or it does nothing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifPresentOrElse(Consumer<T> action, Runnable emptyAction)`: This performs
    the given action with the value (if present, or it performs the given empty-based
    action).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or(Supplier<Optional<T>> supplier)`: This returns an `Optional` class describing
    the value (if present, or it returns an `Optional` class produced by the supplying
    function).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orElse(T other)`: This returns the value (if present, or it returns `other`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orElseGet(Supplier<T> supplier)`: This returns the value (if present, or it
    returns the result produced by the supplying function).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orElseThrow(Supplier<X> exceptionSupplier)`: This returns the value (if present,
    or it throws an exception produced by the exception-supplying function).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that `Optional` is used as a return value in cases when `null` is a possible
    result. Here is an example of the usage. We reimplemented the stream-concatenating
    code using the `reduce()` operation that returns `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the same as in the previous implementation with a `flatMap()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad05dc2c-a8f6-474b-a382-9baef7e45811.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next group of terminal operations is referred to as `forEach()`. These
    operations guarantee that the given function will be applied to each element of
    the stream, but `forEach()` does not say anything about the order, which might
    be changed for better performance. By contrast, `forEachOrdered()` guarantees not
    only the processing of all the elements of the stream, but also doing this in
    the order specified by its source, regardless of whether the stream is sequential
    or parallel. Here are a couple of examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4c32012-5098-4e71-9ac7-1b08651205b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, in the case of parallel processing, `forEach()` does not guarantee
    the order, while `forEachOrdered()` does. Here is another example of using both `Optional`
    and `forEach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We could not use `Optional.of()` and used `Optional.ofNullable()` instead because
    `Optional.of()` would throw `NullPointerException` on `null`. In such a case, `Optional.ofNullable()`
    just returns `Optional` empty. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/121b8403-b056-4116-8aa2-ac7e319e8275.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's talk about the next group of terminal operations, called `reduce()`.
    Each of the three overloaded methods returns a single value after processing all
    the stream elements. Among the most simple examples are finding a sum of the stream
    elements in case they are numbers, or max, min, and similar. But a more complex
    result can be constructed too for a stream of objects of any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method, namely `reduce(BinaryOperator<T> accumulator)`, returns `Optional` because
    it is the responsibility of the provided accumulator function to calculate the
    result. And, the authors of the JDK implementation cannot guarantee it will always
    have some value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The passed-in function is provided the result of the previous result of the
    same function (as the first parameter `p`) and the next element of the stream
    (as the second parameter `e`). For the very first element, `p` gets its value,
    while `e` is the second element. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da547cd3-0ddb-4698-bbcf-e717a1f6900b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To avoid the extra step with `Optional`, the second method returns the value
    provided as the first parameter `identity` of the type `T` (which is the type
    of the elements of `Stream<T>`) in case the stream is empty. This parameter has
    to comply with this requirement (from Javadoc): *for all t, accumulator.apply(identity,
    t) is equal to t*. In our case, it has to be `0` for it to comply with `0 + e
    == e`. Here is an example of how to use the second method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the same as with the first `reduce()` method. The third one converts
    the value of the type `T` into a value of the type `U` with the help of the `BiFunction<U,T,U>` function.
    Then, the result (of the type `R`) goes through the same logic of processing it
    as the type `T`, as in the previous method. Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'One naturally expects to see the result as `1,2,3`. Instead, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f453e234-85f7-47da-9afe-f3adad0ba221.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make the stream parallel like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Only if you do this, you will see what''s expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d862ec3f-c521-4e50-8dd2-928d9b51bf7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that the combiner is called only for parallel processing in order
    to assemble (combine) the results of different streams (processed in parallel).
    This is the only deviation we have noticed so far from the declared intent of
    providing the same behavior for sequential and parallel streams. But there are
    many ways to accomplish the same result without using this third version of `reduce()`.
    For example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the same result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d9b41e2-ae9e-4d68-a4b6-c96d0ee5d12b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next group of intermediate operations, called `collect()`, consists of
    two methods. The first one accepts `Collector` as a parameter. It is much more
    popular than the second one because it is backed up by the `Collectors` class,
    which provides a wide variety of implementations of the `Collector` interface.
    We encourage you to go through the Javadoc of the `Collectors` class and see what
    it offers. Let''s discuss a few examples of this. First, we''ll create a small
    `demo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to demonstrate a few collectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d68dd3e2-b17e-4ccb-b09b-3183f04842b1.png)'
  prefs: []
  type: TYPE_IMG
- en: The joining collector is a source of joy for any programmer who has ever had
    to write code that checks whether the added element is the first, the last, or
    removes the last character (like we did in the last example of the `reduce()`
    operation). The `joining()` collector does this behind the scenes. All the programmer
    has to pass are the delimiter, prefix, and suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Most programmers will never need to write a custom collector. But in case there
    is a need, one can use the second method `collect()` of `Stream` (and provide
    functions that will compose a collector) or use one of the two static methods
    `Collector.of()` that generates a collector that can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the `reduce()` and `collect()` operations, you'll notice that
    the primary purpose of `reduce()` is to operate on immutable objects and primitives.
    The result of `reduce()` is one value that is typically (but not exclusively)
    of the same type as the elements of the stream. The `collect()`, by contrast,
    produces the result of a different type wrapped in a mutable container. The most
    popular usage of `collect()` is centered around producing `List`, `Set`, or `Map` using
    the corresponding `Collectors.toList()`, `Collectors.toSet()`, or `Collectors.toMap()` collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last group of terminal operations consists of two methods `toArray()`.
    One of them returns `Object[]`, another one returns an array of the specified
    type. Let''s look at the examples of their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these examples is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e1381e8-e62e-47fa-b87c-24959060fb00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first example is quite straightforward. It is worth commenting though that
    we cannot write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is because `toArray()` is a terminal operation and the stream is closed
    automatically after it. That's why we have to open a new stream in the second
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example--with the overloaded `A[] toArray(IntFunction<A[]> generator)`
    method--is more complicated. The Javadoc says this: *The generator function takes
    an integer, which is the size of the desired array, and produces an array of the
    desired size*. This means that the method reference to a `toArray(String[]::new)` constructor
    in the last example is a shorter version of `toArray(size -> new String[size])`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.stream` package also provides specialized interfaces, namely `IntStream`,
    `DoubleStream`, and `LongStream`, that are optimized for processing streams of
    values of corresponding primitive types. It is very convenient to use them in
    the case of reducing operations. For example, they have `max()`, `min()`, `average()`,
    `sum()`, and many other simplified (tuned for performance) methods that can be
    called on these streams directly as intermediate and terminal operations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create operation pipeline on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel computations on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an operation pipeline on streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to build a pipeline from `Stream` operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, while creating a lambda-friendly API, we ended up
    with the following API method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The specified number of `TrafficUnit` instances were produced inside the `speedAfterStart()`
    method. They were limited by the `limitTrafficAndSpeed` function and processed
    according to the `speedModel` function inside the `speedAfterStart()` method.
    The results were shown on the device and in the format specified by the `printResults` function.
  prefs: []
  type: TYPE_NORMAL
- en: It is a very flexible design that allows you to have quite a range of experimentation
    via the modification of functions that are passed to the API. In reality, though,
    especially during the early stages of data analysis, having an API creates an
    overhead. If the provided flexibility is not enough, one needs to change it and
    build and deploy a new version. It takes time and the implementation lacks transparency.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, the encapsulation of the implementation details was one of the API
    design requirements. But it works well with the established processes that need
    to be wrapped as a product for a population of users. The situation radically
    changes during the research phase. When new algorithms are developed and tested
    and when the need for processing a large amount of data presents its own challenge,
    transparency across all the layers of the developed system becomes a foundational
    requirement. Without it, many of today's successes in the big data analysis world
    would be impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Streams and the pipelines of stream operations address the problem of transparency
    and minimize the overhead of writing infrastructural code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recall how a user called the lambda-friendly API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As we have already noticed, the freedom of the speed calculation manipulation
    with such an API (without changing it) extends to the formula of the speed calculation,
    device and format of the output, and the selection of traffic. This is not bad
    in our simplistic application, but it might not cover all the possibilities of
    the model evolution in the case of more complex calculations. But it is a good
    start that allows us to construct the stream and the pipeline of operations for
    more transparency and flexibility of experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the API implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we convert the `for` loop into a stream of traffic units and apply the
    same functions directly to the elements of the stream. But first, we can request
    the traffic-generating system to supply us with `Stream` instead of `List` of
    data. This allows you to avoid the storing of all the data in the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to process an endless number of traffic units without storing
    more than one unit at a time in the memory. In the demo code, we still create
    `List`, so the streaming does not save us memory. But there are real systems,
    such as sensors, that can provide streams without storing all of the data in the
    memory first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also create a convenience method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we will now write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We mapped (transform) `TrafficUnit` to `Vehicle`, then mapped `Vehicle` to
    `speed`, then used the current `TrafficUnit` instance and calculated `speed` to
    limit the traffic and print results. If you have this code in a modern editor,
    you will notice that it does not compile because after the first map, the current
    `TrafficUnit` element is not accessible anymore; it is replaced by `Vehicle`.
    This means we need to carry along the original elements and add new values on
    the way. To accomplish this, we need a container--some kind of a traffic unit
    wrapper. Let''s create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can build a pipeline that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The code looks a bit verbose, especially the `Vehicle` and `SpeedModel` setting.
    We can hide these plumbing details by moving them to the `TrafficUntiWrapper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we return `this` from the `setSpeedModel()` and `setSpeed()` methods.
    This allows us to preserve the fluent style. Now the pipeline looks much cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no need to keep the formula for the speed calculations easily accessible
    to the modification, we can move it to the `TrafficUnitWrapper` class too by changing
    the `setSpeed()` method to `calcSpeed()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the pipeline becomes even less verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this technique, we can now create a method that calculates traffic
    density--the count of vehicles in each lane of a multilane road for the given
    speed limit in each of these lanes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses two private classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'It also uses the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses the private method too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 15](823213ae-b820-450c-abb8-8a98a70caf70.xhtml), *Testing*, we will
    discuss this method (of the `TrafficDensity` class) in more detail and revisit
    this implementation to allow you to have better unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: This is why writing a unit test parallel to the code development brings higher
    productivity by eliminating the need for changing the code afterward. It also
    results in more testable (better quality) code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pipeline allows you to add another filter (or any other operation) easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It is especially important when many types of data have to be processed. It's
    worth mentioning that having a filter before the calculations is the best way
    to improve performance because it allows you to avoid unnecessary calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Another major advantage of using a stream is that the process can be made parallel
    without extra coding. All one needs to do is change the first line of the pipeline
    to `getTrafficUnitStream(trafficUnitsNumber).parallel()` (assuming the source
    does not generate the parallel stream, which can be identified by the `.isParallel()`
    operation). We will talk about this in more detail in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel computations on streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel computations on streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we have already demonstrated some of the parallel stream
    processing techniques. In this recipe, we will discuss this in greater detail
    and share the best practices and possible problems and how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is tempting to just set up all the streams parallelly and not think about
    it again. Unfortunately, parallelism does not always provides an advantage. In
    fact, it incurs an overhead because of the worker threads' coordination. Besides,
    some stream sources are sequential in nature and some operations may share the
    same (synchronized) resource. Even worse, the usage of a stateful operation can
    lead to an unpredictable result. It is not that you cannot use a stateful operation
    for a parallel stream; it requires careful planning and clear understanding of
    the state management.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous recipe, a parallel stream can be created by the
    `parallelStream()` method of a collection or the `parallel()` method applied to
    a stream. Conversely, the existing parallel stream can be converted into a sequential
    one by calling the stream using the `sequential()` method.
  prefs: []
  type: TYPE_NORMAL
- en: As the first best practice, use a sequential stream by default and start thinking
    about the parallel one only if you have to and you can. The have to usually comes
    up if the performance is not good enough and a large amount of data has to be
    processed. The possibilities are limited by the nature of the stream source and
    operations. Some of them cannot be either processed in parallel or produce non-deterministic
    results.  For example, reading from a file is sequential and a file-based stream
    does not perform better in parallel. Any blocking operation also negates performance
    improvement in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the areas where sequential and parallel streams are different is ordering.
    Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/954a43e1-a594-454f-b30b-a83e2f6431ec.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `List` preserves the order of the elements but does not keep
    it in the case of parallel streams.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating and operating on streams* recipe, we showed that with the `reduce()`
    and `collect()` operations, a combiner is called only for a parallel stream. So,
    it is not needed for a sequential stream, but it must be present while operating
    on a parallel one. Without it, the results of multiple workers are not correctly
    aggregated.
  prefs: []
  type: TYPE_NORMAL
- en: We have also demonstrated the stateful operations `sorted()`, `distinct()`,
    `limit()`, and `skip()` yielding a non-deterministic result in the case of parallel
    processing. If an order is important, you can rely on the stream method.
  prefs: []
  type: TYPE_NORMAL
- en: If an order is important, we have shown that you can rely on the `forEachOrdered()` 
    stream method. It not only guarantees the processing of all the elements of the
    stream, but also doing it in the order specified by its source, regardless of
    whether the stream is sequential or parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Whether a parallel stream is created by the `parallelStream()` method of a collection
    or by the `parallel()` method applied to a stream, the underlying implementation
    uses the same `ForkJoin` framework introduced in Java 7\. The stream is broken
    down into segments that are then given to different worker threads for processing.
    On a computer with only one processor, it does not have an advantage, but on a
    multicore computer, worker threads can be executed by different processors. Even
    more, if one worker becomes idle, it can *steal* a part of the job from a busy
    one. The results are then collected from all the workers and aggregated for the
    terminal operation completion (that is, when a combiner of a collect operation
    becomes busy).
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, if there is a resource that is not safe for a concurrent
    access, it is not safe to use it during parallel stream processing. Consider these
    two examples (`ArrayList` is not known to be threadsafe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If run several times, this code may produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89610f0d-2b4c-417d-a22a-87c3c08dcca4.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Collectors.toList()` method always generates the same list that consists
    of `is` and `Stream.of(literals)`, while `forEach()` misses either `is` or `Stream.of(literals)`
    once in a while.
  prefs: []
  type: TYPE_NORMAL
- en: If possible, try using collectors constructed by the `Collectors` class first
    and avoid shared resource during parallel computations.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, using stateless functions is your best bet for parallel stream pipelines.
    If in doubt, test your code, most importantly, run the same test many times to
    check whether the result is stable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the [Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml), *Concurrent
    and Multithreaded Programming* for more examples of the usage of classes from
    the package `java.util.stream`.
  prefs: []
  type: TYPE_NORMAL
