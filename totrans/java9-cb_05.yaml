- en: Stream Operations and Pipelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流操作和管道
- en: 'In the latest Java releases (8 and 9), the collections API has gotten a major
    facelift with the introduction of streams and internal iteration by leveraging
    lambda expressions. This chapter shows you how to leverage streams and chain multiple
    operations on a collection to create a pipeline. Also, we would like to show you
    how these operations can be done in parallel. We will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的Java版本（8和9）中，通过利用lambda表达式引入了流和内部迭代，集合API得到了重大改进。本章将向您展示如何利用流在集合上链式执行多个操作以创建管道。此外，我们还想向您展示这些操作如何并行执行。我们将涵盖以下食谱：
- en: Using the new factory methods to create collection objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的工厂方法创建集合对象
- en: Creating and operating on streams
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作流
- en: Creating an operation pipeline on streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流上创建操作管道
- en: Parallel computations on streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的并行计算
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Lambda expressions described and demonstrated in the previous chapter were introduced
    in Java 8\. Together with functional interfaces, they added functional programming
    capability to Java, allowing the passing of behavior (functions) as parameters
    to the libraries optimized for the performance of data processing. This way, an
    application programmer can concentrate on the business aspects of the developed
    system, leaving performance aspects to the specialists--the authors of the library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中描述和演示的lambda表达式是在Java 8中引入的。与函数式接口一起，它们为Java添加了函数式编程能力，允许将行为（函数）作为参数传递给针对数据处理性能优化的库。这样，应用程序程序员可以专注于开发系统的业务方面，将性能方面留给专家——库的作者。
- en: One example of such a library is the `java.util.stream` package, which is going
    to be the focus of this chapter. This package allows you to have a declarative
    presentation of the procedures that can be subsequently applied to the data, also
    in parallel; these procedures are presented as streams, which are objects of the `Stream` interface. For
    better transition from the traditional collections to streams, two default methods
    (`stream()` and `parallelStream()`) were added to the `java.util.Collection` interface
    along with the addition of new factory methods of stream generation to the `Stream` interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的库的一个例子是`java.util.stream`包，这个包将是本章的重点。这个包允许你以声明性的方式展示可以随后应用于数据的程序，也可以并行执行；这些程序以流的形式呈现，是`Stream`接口的对象。为了更好地从传统集合过渡到流，`java.util.Collection`接口中添加了两个默认方法（`stream()`和`parallelStream()`），同时还在`Stream`接口中添加了新的流生成工厂方法。
- en: This approach takes advantage of the power of composition, discussed in one
    of the previous chapters. Together with other design principles--encapsulation,
    interface, and polymorphism--it facilitates a highly extensible and flexible design,
    while lambda expressions allow you to implement it in a concise and succinct manner.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了在前面章节中讨论的复合能力的优势。与其他设计原则——封装、接口和多态性一起，它促进了高度可扩展和灵活的设计，而lambda表达式允许你以简洁的方式实现它。
- en: Today, when the machine learning requirements of massive data processing and
    the fine-tuning of operations have become ubiquitous, these new features reinforce
    the position of Java among the few modern programming languages of choice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当大规模数据处理的需求和操作的微调变得普遍时，这些新特性加强了Java在现代编程语言选择中的地位。
- en: Using the new factory methods to create collection objects
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的工厂方法创建集合对象
- en: In this recipe, we will revisit traditional ways of creating collections and
    introduce the new factory methods, namely `List.of()`, `Set.of()`, `Map.of()`,
    and `Map.ofEntries()`, that come with Java 9.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将回顾传统的创建集合的方法，并介绍Java 9带来的新工厂方法，即`List.of()`、`Set.of()`、`Map.of()`和`Map.ofEntries()`。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before Java 9, there were several ways of creating collections. Here is the
    most popular way that was used to create `List`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，有几种创建集合的方法。以下是最流行的创建`List`的方法：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the usage of a default method, `forEach(Consumer)`, added to the `Iterable`
    interface in Java 8.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在Java 8中添加到`Iterable`接口的默认方法`forEach(Consumer)`的使用。
- en: 'If we run the preceding code, we get this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们会得到以下结果：
- en: '![](img/da7daa20-403b-4fd7-9d2e-bb011109e779.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da7daa20-403b-4fd7-9d2e-bb011109e779.png)'
- en: 'The shorter way of doing this would be by starting with an array:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的更简单的方法是从一个数组开始：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/27db3f63-043e-4299-a8a3-93789e534dd3.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27db3f63-043e-4299-a8a3-93789e534dd3.png)'
- en: 'Similarly, while creating `Set`, we can write this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在创建`Set`时，我们可以写出以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we can write the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以写出以下内容：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s an illustration of the results of the last two examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最后两个示例结果的说明：
- en: '![](img/9d169fd5-e76e-4436-8fc9-6e4f3a52cf89.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d169fd5-e76e-4436-8fc9-6e4f3a52cf89.png)'
- en: Notice that unlike `List`, the order of elements in `Set` is not preserved.
    It depends on the hash code implementation and can change from computer to computer.
    But the order remains the same between the runs on the same computer (please take
    note of this last fact because we will come back to it later).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`List`不同，`Set`中元素的顺序不被保留。它取决于哈希码实现，并且可能因计算机而异。但在同一台计算机上的运行之间顺序保持不变（请注意这个事实，因为我们稍后会回到它）。
- en: 'The same structure, that is, the order of elements, applies to `Map` too. This
    is how we used to create `Map` before Java 9:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的结构，即元素顺序，也适用于`Map`。这就是我们在Java 9之前创建`Map`的方式：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/bf84676d-a5c6-4d2b-b6cf-ebc5ecb80e14.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf84676d-a5c6-4d2b-b6cf-ebc5ecb80e14.png)'
- en: Those who had to create collections often appreciated the JDK enhancement-Proposal
    269 *Convenience Factory Methods for Collections* (JEP 269) that stated *Java
    is often criticized for its verbosity* and its goal of *Provide static factory
    methods on the collection interfaces that will create compact, unmodifiable collection
    instances.*
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那些经常需要创建集合的人会欣赏JDK增强提案269（JEP 269）——*集合的便利工厂方法*，该提案指出*Java经常因其冗长而受到批评*，其目标是*在集合接口上提供静态工厂方法，以创建紧凑、不可修改的集合实例*。
- en: 'In response to the criticism and the proposal, Java 9 introduced twelve `of()` static
    factory methods for each of the three interfaces. The following is the code for
    `List`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对批评和建议的回应，Java 9为三个接口中的每一个引入了十二个`of()`静态工厂方法。以下是`List`的代码：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Twelve similar static methods were added to `Set` and `Map` too. Ten overloaded
    factory methods with a fixed number of elements were optimized for performance,
    and as stated in JEP 269, these methods *avoid array allocation, initialization,
    and garbage collection overhead that is incurred by* *varargs calls.*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还为`Set`和`Map`添加了十二个类似的静态方法。十个具有固定元素数量的重载工厂方法被优化以提高性能，并且如JEP 269所述，这些方法*避免了由varargs调用产生的数组分配、初始化和垃圾回收开销*。
- en: 'The code of the same examples now becomes much more compact:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相同示例的代码现在变得更加紧凑：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `System.out.println()` statement was added to inject a line break between
    the different types of output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`System.out.println()`语句以在不同类型的输出之间注入换行符：
- en: '![](img/a140e303-133d-4d46-b3f6-03cc1d912a11.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a140e303-133d-4d46-b3f6-03cc1d912a11.png)'
- en: 'One of the twelve static factory methods added to the `Map` interface was different
    from the other `of()` methods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`Map`接口的十二个静态工厂方法中的一个与其他`of()`方法不同：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is an example of its usage:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它使用的一个例子：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s its output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的输出：
- en: '![](img/1109e20a-7a9b-496e-a12b-95917c5eddfd.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1109e20a-7a9b-496e-a12b-95917c5eddfd.png)'
- en: So, there is no `Map.of()` factory method for an unlimited number of elements.
    One has to use `Map.ofEntries()` when creating a map with more than 10 elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，没有为无限数量的元素提供`Map.of()`工厂方法。在创建包含超过10个元素的映射时，必须使用`Map.ofEntries()`。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: You may have probably noticed the `Set.of()`, `Map.of()`, and `Map.ofEntries()`
    methods do not preserve the order of their elements. This is different from the
    previous (before Java 9) instances of `Set` and `Map`; the order of elements now
    changes between runs even on the same computer (but does not change during the
    same run, no matter how many times the collection is iterated). This is an intentional
    feature intended to help programmers avoid reliance on a certain order because
    it might produce a defect as the order changes when the code is run on another
    computer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了`Set.of()`、`Map.of()`和`Map.ofEntries()`方法不保留其元素的顺序。这与Java 9之前的`Set`和`Map`实例不同；现在元素的顺序在运行之间会发生变化，即使在同一台计算机上也是如此（但在同一运行期间不会变化，无论集合被迭代多少次）。这是一个旨在帮助程序员避免依赖特定顺序的故意特性，因为当代码在另一台计算机上运行时，顺序可能会发生变化。
- en: 'Another feature of the collections generated by the new `of()` static methods
    of the `List`, `Set`, and `Map` interfaces is that these collections are immutable.
    What does this mean? Consider the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`List`、`Set`和`Map`接口的`of()`静态方法生成的集合的另一个特性是这些集合是不可变的。这是什么意思？考虑以下代码：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This means that the preceding code throws `java.lang.UnsupportedOperationException`
    at runtime and the following code will throw the same exception too:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着前面的代码在运行时会抛出`java.lang.UnsupportedOperationException`异常，而下面的代码也会抛出相同的异常：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, the collections generated by the new `of()` static methods do not allow
    null elements, and the following code throws the `java.lang.NullPointerException`
    exception at runtime too:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由新的`of()`静态方法生成的集合不允许包含null元素，下面的代码在运行时也会抛出`java.lang.NullPointerException`异常：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is not an accident that non-null values and immutability guarantees were
    added soon after lambda and streams were introduced. As you will see in subsequent
    recipes, the functional programming and stream pipelines encourage a fluent style
    of coding (using method chaining, as we did in the case of using the `forEach()`
    method in the examples of this recipe). This fluent style provides more compact
    and readable code and the non-null guarantee helps support it by removing the
    need for checking the `null` value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 非空值和不可变性保证在lambda和流引入后不久就被添加，这并非偶然。正如你将在后续食谱中看到的，函数式编程和流管道鼓励一种流畅的编码风格（使用方法链，就像我们在本食谱示例中使用`forEach()`方法时做的那样）。这种流畅风格提供了更紧凑和可读的代码，非空保证通过消除检查`null`值的需要来支持它。
- en: 'The immutability feature, in turn, aligns well with the, effectively, final
    concept for the variables in the outside context used by lambda expressions. For
    example, a mutable collection allows you to work around this limitation and the
    following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变特性反过来又很好地与lambda表达式在外部上下文中使用的变量的实际最终概念相一致。例如，可变集合允许你绕过这种限制，以下代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code produces the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成以下输出：
- en: '![](img/45e30365-bc46-4ab0-8c07-236b7d083f3b.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45e30365-bc46-4ab0-8c07-236b7d083f3b.png)'
- en: This means that it is possible--intentionally or not--to introduce a state in
    a lambda expression and cause different outcomes of the same function in different
    contexts. This is especially dangerous in parallel processing because one cannot
    predict the state of each possible context. This is why immutability of a collection
    is a helpful addition that helps make the code more robust and reliable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着有意或无意地在lambda表达式中引入状态，并导致同一函数在不同上下文中有不同的输出。这在并行处理中尤其危险，因为无法预测每个可能上下文的状态。这就是为什么集合的不可变性是一个有用的补充，它有助于使代码更加健壮和可靠。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'Refer to the following recipes of this chapter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Creating and operating on streams
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作流
- en: Creating an operation pipeline on streams
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流上创建操作管道
- en: Creating and operating on streams
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和操作流
- en: In this recipe, we will describe how streams can be created and the operations
    that can be applied to the elements emitted by the streams.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将描述如何创建流以及可以应用于流输出的元素的运算。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are many ways to create a stream. Since Java 8, the `Collection` interface
    has the `stream()` method that returns a sequential stream with this collection
    as its source and the `parallelStream()` method that returns a possibly parallel
    stream with this collection as its source. This means that all the subinterfaces,
    including `Set` and `List`, also have these methods. Also, eight overloaded `stream()`
    methods were added to the `Arrays` class that created streams of different types
    from a corresponding array or subset.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建流有许多方法。自从Java 8以来，`Collection`接口有了`stream()`方法，该方法返回一个顺序流，该集合作为其源，以及`parallelStream()`方法，该方法返回一个可能并行流，该集合作为其源。这意味着包括`Set`和`List`在内的所有子接口也有这些方法。此外，`Arrays`类还增加了八个重载的`stream()`方法，可以从相应的数组或子集创建不同类型的流。
- en: The `Stream` interface has the `of()`, `generate()`, and `iterate()` methods.
    The specialized interfaces `IntStream`, `DoubleStream`, and `LongStream` have
    similar methods too, while `IntStream` also has the `range()` and `rangeClosed()` methods;
    both return `IntStream`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口有`of()`、`generate()`和`iterate()`方法。专门的接口`IntStream`、`DoubleStream`和`LongStream`也有类似的方法，而`IntStream`还有`range()`和`rangeClosed()`方法；两者都返回`IntStream`。'
- en: There are `Files.list()`, `Files.lines()`, `Files.find()`, `BufferedReader.lines()`,
    and many other methods in the JDK that produce streams.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中有许多产生流的函数，例如`Files.list()`、`Files.lines()`、`Files.find()`、`BufferedReader.lines()`等。
- en: After a stream is created, various operations can be applied to its elements.
    A stream itself does not store data. It rather acquires them from the source (and
    provides or emits them to the operations) as needed. The operations can form a
    pipeline using the fluent style since many intermediate operations can return
    a stream too. Such operations are called *intermediate* operations. Examples of
    intermediate operations are `filter()` (selects only elements matching a criterion),
    `map()` (transforms elements according to a function), `distinct()` (removes duplicates),
    `limit()` (limits a stream to the specified number of elements), `sorted()` (transforms
    an unsorted stream into a sorted one), and other methods of the `Stream` interface
    that return `Stream` too (except those that create a stream we just mentioned).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 流创建后，可以对其元素应用各种操作。流本身不存储数据。它更像是根据需要从源（并提供或输出给操作）获取它们。由于许多中间操作也可以返回流，因此操作可以形成一个使用流畅式风格的管道。这些操作被称为**中间操作**。中间操作的例子包括`filter()`（仅选择符合标准的元素）、`map()`（根据函数转换元素）、`distinct()`（删除重复项）、`limit()`（将流限制为指定的元素数量）、`sorted()`（将未排序的流转换为排序后的流），以及`Stream`接口返回`Stream`的其他方法（除了我们刚才提到的创建流的方法）。
- en: The pipeline ends with a **terminal operation**. The processing of the stream
    elements actually begins only when a terminal operation is being executed. Then,
    all the intermediate operations (if present) start processing and the stream closes
    and cannot be reopened as soon as the terminal operation is finished with the
    execution. Examples of terminal operations are `forEach()`, `findFirst()`, `reduce()`,
    `collect()`, `sum()`, `max()`, and other methods of the `Stream` interface that
    do not return `Stream`. Terminal operations return a result or produce a side
    effect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 管道以**终端操作**结束。流元素的加工实际上只有在执行终端操作时才开始。然后，所有中间操作（如果有的话）开始处理，一旦终端操作执行完毕，流就会关闭，并且无法重新打开。终端操作的例子有`forEach()`、`findFirst()`、`reduce()`、`collect()`、`sum()`、`max()`以及`Stream`接口的其他不返回`Stream`的方法。终端操作返回一个结果或产生副作用。
- en: All the `Stream` methods support parallel processing, which is especially helpful
    in the case of a large amount of data processed on a multicore computer. All the
    Java Stream API interfaces and classes are in the `java.util.stream` package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`Stream`方法都支持并行处理，这在处理大量数据的多核计算机上特别有帮助。所有的Java Stream API接口和类都在`java.util.stream`包中。
- en: In this recipe, we are going to mostly demonstrate sequential streams, created
    by the `stream()` method and similar. The processing of parallel streams is not
    much different than sequential streams. One just has to watch that the processing
    pipeline does not use a context state that can vary across different processing
    environments. We will discuss parallel processing in another recipe later in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将主要演示由`stream()`方法及其类似方法创建的顺序流。并行流的处理与顺序流没有太大区别。只需注意处理管道不要使用可能在不同处理环境中变化的上下文状态。我们将在本章后面的另一个食谱中讨论并行处理。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In this section of the recipe, we will present methods of stream creation. As
    mentioned in the introduction, each class that implements the `Set` interface
    or the `List` interface has the `stream()` method and the `parallelStream()` method
    that return an instance of the `Stream` interface. For now, we will only look
    at sequential streams created by the `stream()` method and get back to parallel
    streams later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的这一部分，我们将介绍流创建的方法。正如引言中提到的，每个实现了`Set`接口或`List`接口的类都有`stream()`方法和`parallelStream()`方法，这两个方法返回`Stream`接口的实例。目前，我们将只查看由`stream()`方法创建的顺序流，稍后再回到并行流。
- en: 'Consider the following examples of stream creation:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下流创建的示例：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We used the fluent style to make the code more compact and interjected `System.out.println()`
    in order to start a new line in the output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了流畅式风格来使代码更加紧凑，并在输出中插入`System.out.println()`以开始新的一行。
- en: 'Run the preceding examples and see the result:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的示例并查看结果：
- en: '![](img/6c6db9b1-1228-420f-a22f-695464875d51.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c6db9b1-1228-420f-a22f-695464875d51.png)'
- en: Notice that `List` preserves the order of the elements, while the order of `Set`
    elements changes at every run. This helps uncover the defects based on the reliance
    of certain order when this order is not guaranteed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`List`保留了元素的顺序，而`Set`元素的顺序在每次运行时都会改变。这有助于揭示基于某些顺序的缺陷，当这个顺序无法保证时。
- en: 'Look at the Javadoc of the `Arrays` class. It has eight overloaded `stream()` methods:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看一下`Arrays`类的Javadoc。它有八个重载的`stream()`方法：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Write an example of the usage of the last two methods:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最后两个方法的用法示例：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run it and see the result:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并查看结果：
- en: '![](img/3911a09e-22e8-4c9e-a6d7-2951e593a3d4.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3911a09e-22e8-4c9e-a6d7-2951e593a3d4.png)'
- en: Notice that only the first two elements--with indexes `0` and `1`--were selected
    to be included in the stream, as the preceding second example intended.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有前两个元素（索引为`0`和`1`）被选中包含在流中，正如前面的第二个示例所意图的。
- en: 'Now open the Javadoc of the `Stream` interface and see the factory methods `of()`,
    `generate()`, and `iterate()`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`Stream`接口的Javadoc，查看工厂方法`of()`、`generate()`和`iterate()`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first two methods are simple, so we skip their demo and start with the third
    method, namely `of()`. It can accept either an array or just comma-delimited elements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法很简单，所以我们跳过它们的演示，从第三个方法`of()`开始。它可以接受一个数组或逗号分隔的元素。
- en: 'Write the example as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式编写示例：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run it and observe the output:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并观察输出：
- en: '![](img/53bdba33-f03b-4498-9100-fbe8570808f4.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53bdba33-f03b-4498-9100-fbe8570808f4.png)'
- en: 'Write the examples of the usage of the `generate()` and `iterate()` methods
    as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式编写`generate()`和`iterate()`方法的用法示例：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We had to put a limit on the size of the streams generated by the first two
    examples. Otherwise, they would be infinite. The third example accepts a predicate
    that provides the criterion for when the iteration has to stop.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不对前两个示例生成的流的尺寸进行限制。否则，它们将是无限的。第三个示例接受一个谓词，它提供了迭代何时停止的标准。
- en: 'Run the examples and observe the results:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并观察结果：
- en: '![](img/1490742b-52b5-486a-8500-b4cd3ddb6380.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1490742b-52b5-486a-8500-b4cd3ddb6380.png)'
- en: 'Now write examples for the specialized interfaces `IntStream`, `DoubleStream`,
    and `LongStream`. Their implementations are optimized for performance when you
    process primitives by avoiding the overhead of boxing and unboxing. In addition,
    the `IntStream` interface has two more stream-generating methods, namely `range()`
    and `rangeClosed()`. Both return `IntStream`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为专门的接口`IntStream`、`DoubleStream`和`LongStream`编写示例。它们的实现通过避免装箱和拆箱的开销，在处理原始数据时优化了性能。此外，`IntStream`接口还有两个额外的流生成方法，即`range()`和`rangeClosed()`。两者都返回`IntStream`：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run them and see the output:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它们并查看输出：
- en: '![](img/eb1ec491-591a-4845-887e-ee39c415f73b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb1ec491-591a-4845-887e-ee39c415f73b.png)'
- en: As you can guess, the `range()` method produces the sequence of integers by
    an incremental step of `1`, starting with the left parameter but not including
    the right parameter. While the `rangeClosed()` method generates a similar sequence,
    it includes the right parameter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`range()`方法通过增量步长`1`生成整数序列，从左参数开始但不包括右参数。而`rangeClosed()`方法生成一个类似的序列，包括右参数。
- en: 'Now let''s look at the example of the `Files.list(Path dir)` method, which
    returns `Stream<Path>` of all the entries of the directory:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看`Files.list(Path dir)`方法的示例，它返回目录中所有条目的`Stream<Path>`：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following excerpt is from the JDK API: *This method must be used within
    a try-with-resources statement or similar control structure to ensure that the
    stream''s open directory is closed promptly after the stream''s operations are
    completed*. This is what we did; we used a `try`-with-resources statement in this
    case. Alternatively, we could use a `try...catch...finally` construct and close
    the stream in the finally block and the result would not change.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录来自JDK API：*此方法必须在try-with-resources语句或类似控制结构中使用，以确保在流操作完成后立即关闭流的打开目录*。这正是我们所做的；在这种情况下，我们使用了try-with-resources语句。或者，我们也可以使用`try...catch...finally`结构，并在finally块中关闭流，结果不会改变。
- en: 'Run the examples and observe the output:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并观察输出：
- en: '![](img/f6561316-4601-4f30-8660-2d736deaf32f.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6561316-4601-4f30-8660-2d736deaf32f.png)'
- en: 'The need to close a stream explicitly can be confusing because the `Stream`
    interface extends `AutoCloseable`, and with this, one would expect that a stream
    will be closed automatically. But that is not the case. Here is what the Javadoc
    for the `Stream` interface has to say about it: *Streams have a BaseStream.close()
    method and implement AutoCloseable. Most stream instances do not actually need
    to be closed after use, as they are backed by collections, arrays, or generating
    functions, which require no special resource management. Generally, only streams
    whose source is an I/O channel, such as those returned by Files.lines(Path), will
    require closing*. This means that a programmer has to know the source of the stream
    and make sure they close it if the API for the source requires it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 明确关闭流的需求可能会让人困惑，因为`Stream`接口扩展了`AutoCloseable`接口，因此人们会预期流会自动关闭。但实际上并非如此。以下是`Stream`接口的Javadoc对这一点的说明：*流有一个`BaseStream.close()`方法，并实现了`AutoCloseable`接口。大多数流实例在使用后实际上不需要关闭，因为它们由集合、数组或生成函数支持，这些不需要特殊资源管理。通常，只有源为I/O通道的流，例如由`Files.lines(Path)`返回的流，才需要关闭*。这意味着程序员必须知道流的来源，并确保在API要求时关闭它。
- en: 'Write an example of the `Files.lines()` method''s usage:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请看`Files.lines()`方法的使用示例：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The intent was to read the first three lines of the specified file and print
    non-empty lines with an indentation of three spaces.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是读取指定文件的头三行，并打印带有三个空格缩进的非空行。
- en: 'Run it and see the result:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并查看结果：
- en: '![](img/e358b49d-3156-451b-b837-5dfde91de367.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e358b49d-3156-451b-b837-5dfde91de367.png)'
- en: 'Write the example of the usage of the `ind()` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请看`ind()`方法的使用示例：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similar to the previous case, a stream generated by this method has to be closed
    explicitly too. The `find()` method walks the file tree rooted at a given starting
    file and at the requested depth and returns the paths to the files that match
    the predicate (which includes file attributes). Write the following code now:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前一个案例类似，由该方法生成的流也必须显式关闭。`find()`方法遍历以给定起始文件为根的文件树和请求的深度，并返回匹配谓词（包括文件属性）的文件路径。现在请编写以下代码：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run it and you''ll get the following output:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它，你会得到以下输出：
- en: '![](img/454b54a6-a181-4d14-8904-9510363ff393.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/454b54a6-a181-4d14-8904-9510363ff393.png)'
- en: If necessary, `FileVisitorOption.FOLLOW_LINKS` could be included as the last
    parameter of `Files.find()` if we need to perform a search that would follow all
    symbolic links it might encounter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以将`FileVisitorOption.FOLLOW_LINKS`作为`Files.find()`的最后一个参数包含在内，如果我们需要执行会跟随所有遇到的符号链接的搜索。
- en: The requirements for using the `BufferedReader.lines()` method, which returns
    `Stream<String>` of lines read from a file, is a little bit different. According to
    Javadoc, *The reader must not be operated on during the execution of the terminal
    stream operation. Otherwise, the result of the terminal stream operation is undefined*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BufferedReader.lines()`方法（该方法返回从文件中读取的`Stream<String>`行）的要求略有不同。根据Javadoc，*在终端流操作执行期间，不得对读取器进行操作。否则，终端流操作的结果是未定义的*。
- en: There are many other methods in the JDK that produce streams. But they are more
    specialized, and we will not demonstrate them here because of shortage of space.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中还有许多其他方法可以生成流。但它们更专业化，我们不会在这里演示它们，因为空间有限。
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Throughout the preceding examples, we have demonstrated several stream operations
    already--methods of the `Stream` interface. We used `forEach()` most often and
    used `limit()` a few times. The first one is a terminal operation and the second
    one is an intermediate one. Let''s look at other methods of the `Stream` interface now.
    Here are the intermediate operations, methods that return `Stream` and can be
    connected in a fluent style:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经展示了几个流操作——`Stream`接口的方法。我们最常使用`forEach()`，几次使用了`limit()`。第一个是一个终端操作，第二个是一个中间操作。现在让我们看看`Stream`接口的其他方法。以下是中间操作，返回`Stream`的方法，可以以流畅的方式连接：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The signatures of the preceding methods typically include ` "? super T"` for
    an input parameter and `"? extends R"` for the result (see the Javadoc for the
    formal definition). We simplified them by removing these notations in order to
    provide a better overview of the variety and commonality of the methods. To compensate,
    we would like to recap the meaning of the related generic notations since they
    are used extensively in the Stream API and might confuse you. Let''s look at the
    formal definition of the `flatMap()` method because it has all of them:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法的签名通常包括输入参数的 `"? super T"` 和结果的 `"? extends R"`（参见 Javadoc 的正式定义）。我们通过移除这些符号来简化它们，以便更好地概述方法的多样性和共性。为了补偿，我们希望回顾相关泛型符号的含义，因为它们在
    Stream API 中被广泛使用，可能会让您感到困惑。让我们看看 `flatMap()` 方法的正式定义，因为它包含了所有这些符号：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `<R>`  interface in front of the method indicates to the compiler that it
    is a generic method (the one with its own type parameters). Without it, the compiler
    would be looking for the definition of a class or the `R` interface. The type
    `T` is not listed in front of the method because it is included in the `Stream<T>`
    interface definition. The `? super T` notation means that the type `T` is allowed
    here or in its superclass. The `? extends R` notation means that the type `R`
    is allowed here or its subclass. The same applies to `? extends Stream...` .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 方法前的 `<R>` 接口表示编译器这是一个泛型方法（具有自己的类型参数）。没有它，编译器会寻找类或 `R` 接口的定义。类型 `T` 不在方法前列出，因为它包含在
    `Stream<T>` 接口定义中。`? super T` 表示类型 `T` 可以在这里或其超类中使用。`? extends R` 表示类型 `R` 可以在这里或其子类中使用。同样适用于
    `? extends Stream...` 。
- en: 'Now let''s get back to our (simplified) list of intermediate operations, methods
    of the `Stream` interface. We have broken them into several groups by similarity.
    The first group contains only one `peek()` method that allows you to apply the `Consumer`
    function to each of the stream elements without affecting it whatsoever because
    the `Consumer` function does not return anything. It is typically used for debugging:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的（简化后的）中间操作列表，`Stream` 接口的方法。我们根据相似性将它们分为几个组。第一组只包含一个 `peek()` 方法，允许您将
    `Consumer` 函数应用于流中的每个元素，而不会对其产生任何影响，因为 `Consumer` 函数不返回任何内容。它通常用于调试：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/5c6cd744-2804-497f-b14f-e40484870f63.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c6cd744-2804-497f-b14f-e40484870f63.png)'
- en: 'In the second group of intermediate operations, the first three are self-explanatory.
    The `filter()` method is one of the most used operations. It does what its name
    suggests; it discards the elements that match the criterion passed as the `Predicate`
    function to the method. We saw an example of its usage in the last snippet of
    code. The `dropWhile()` method discards the elements as long as the criterion
    is met (then allows the rest of the stream elements to flow to the next operation).
    The `takeWhile()` method does the opposite; it allows the elements to flow as
    long as the criterion is met (then discards the rest of the elements). Here is
    an example of this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个中间操作组中，前三个是自解释的。`filter()` 方法是最常用的操作之一。它做其名字暗示的事情；它丢弃了匹配传递给方法的 `Predicate`
    函数作为标准的元素。我们在上一段代码的示例中看到了它的用法。`dropWhile()` 方法在满足标准的情况下丢弃元素（然后允许流中的其余元素流向下一个操作）。`takeWhile()`
    方法做相反的事情；它在满足标准的情况下允许元素流动（然后丢弃其余元素）。以下是一个示例：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code reads the file where this code is stored. It discards all the first
    lines of the file that do not have the `dropWhile().takeWhile()` substring, then
    allows all the lines to flow until the `} catch` substring is found. Notice that
    we had to break this string into `"} catch" + "h" ` so that the criterion would
    not return `true` for this line. The result of this is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码读取存储此代码的文件。它丢弃了所有不包含 `dropWhile().takeWhile()` 子串的第一行，然后允许所有行流动，直到找到 `}
    catch` 子串。请注意，我们必须将这个字符串拆分为 `"} catch" + "h"`，这样标准就不会对这一行返回 `true`。结果是以下内容：
- en: '![](img/62ee8c12-3312-435c-a973-e13884cb3837.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62ee8c12-3312-435c-a973-e13884cb3837.png)'
- en: 'The group of `map()` operations is pretty straightforward too. Such an operation
    transforms each element of the stream by applying to it a function that was passed
    in as a parameter. We have already seen an example of the usage of the `mapToInt()`
    method. Here is another example of the `map()` operation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 操作组也很简单。这种操作通过将传入的函数应用于每个流元素来转换流中的每个元素。我们已经看到了 `mapToInt()` 方法使用的一个例子。以下是
    `map()` 操作的另一个例子：'
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we transform `String` literals into `boolean`. The result
    is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `String` 字面量转换为 `boolean`。结果如下：
- en: '![](img/7a2e5626-3536-45d8-b75d-29dafa75b623.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a2e5626-3536-45d8-b75d-29dafa75b623.png)'
- en: 'The next group of intermediate operations, called `flatMap()`, provides more
    complex processing. A `flatMap()` operation applies the passed-in function (that
    returns a stream) to each of the elements so that the operation could produce
    a stream composed of the streams extracted from each of the elements. Here''s
    an example of this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个中间操作组，称为 `flatMap()`，提供了更复杂的处理。`flatMap()` 操作将传入的函数（返回一个流）应用于每个元素，以便操作可以生成由每个元素提取的流组成的流。以下是一个例子：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'From the input stream, the preceding code selects only literals that contain
    `Th` and converts them into a stream of characters, which are then printed out
    by `forEach()`. The result of this is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入流中，前面的代码只选择包含 `Th` 的字面量，并将它们转换成一个字符流，然后通过 `forEach()` 打印出来。结果如下：
- en: '![](img/3cf67794-6dd0-4a5d-9c0d-5a10fbce7b58.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3cf67794-6dd0-4a5d-9c0d-5a10fbce7b58.png)'
- en: 'The `concat()` method creates a stream from two input streams so that all the
    elements of the first stream are followed by all the elements of the second stream.
    Here''s an example of this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()` 方法从两个输入流创建一个流，使得第一个流的所有元素都跟随第二个流的所有元素。以下是一个例子：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/284c93ff-e7ea-4ee3-abc0-f5f41c2ee1fa.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/284c93ff-e7ea-4ee3-abc0-f5f41c2ee1fa.png)'
- en: 'In case there are more than two stream concatenations, you can write the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在超过两个流连接，你可以写如下：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, `Function.identity()` is a function that returns its input argument (because
    we do not need to transform the input streams but just pass them as is to the
    resulting stream). The result is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Function.identity()` 是一个返回其输入参数的函数（因为我们不需要转换输入流，只需将它们原样传递给结果流）。结果如下：
- en: '![](img/ad05dc2c-a8f6-474b-a382-9baef7e45811.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad05dc2c-a8f6-474b-a382-9baef7e45811.png)'
- en: The last group of intermediate operations is composed of the `sorted()` methods
    that sort the stream elements in a natural (without parameters) or specified (according to
    the passed-in `Comparator`) order. It is a stateful operation (as well as `distinct()`,
    `limit()`, and `skip()`) that yields a non-deterministic result in the case of
    parallel processing; this is, however, the topic of a later recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个中间操作组由 `sorted()` 方法组成，这些方法按自然顺序（无参数）或指定顺序（根据传入的 `Comparator`）对流元素进行排序。这是一个有状态的操作（以及
    `distinct()`、`limit()` 和 `skip()`），在并行处理的情况下会产生非确定性的结果；然而，这将是后续菜谱的主题。
- en: 'Now let''s look at terminal operations (we simplified their signature too by
    removing `? super T` and `? extends R`):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看终端操作（我们也通过移除 `? super T` 和 `? extends R` 简化了它们的签名）：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first two groups are self-explanatory, but we need to say a few words about `Optional`.
    The Javadoc defines it this way: *A container object which may or may not contain
    a non-null value. If a value is present, isPresent() returns true and get() returns
    the value*. It allows you to avoid `NullPointerException` or check for `null`
    (which would break the one-line style of code writing). For the same reason, it
    has its own methods: `map()`, `filter()`, and `flatMap()`. In addition, Optional
    has methods that include the `isPresent()` check implicitly:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前两组是自解释的，但我们需要说几句关于 `Optional` 的话。Javadoc 这样定义它：*一个可能包含或不包含非空值的容器对象。如果存在值，isPresent()
    返回 true，get() 返回该值*。它允许你避免 `NullPointerException` 或检查 `null`（这会破坏代码的一行风格）。出于同样的原因，它有自己的方法：`map()`、`filter()`
    和 `flatMap()`。此外，Optional 还包含隐式包含 `isPresent()` 检查的方法：
- en: '`ifPresent(Consumer<T> action)`: This performs the action with the value (if
    present, or it does nothing).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresent(Consumer<T> action)`: 如果存在值，则执行该操作。'
- en: '`ifPresentOrElse(Consumer<T> action, Runnable emptyAction)`: This performs
    the given action with the value (if present, or it performs the given empty-based
    action).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresentOrElse(Consumer<T> action, Runnable emptyAction)`: 如果存在值，则执行给定操作；如果不存在，则执行给定的空操作。'
- en: '`or(Supplier<Optional<T>> supplier)`: This returns an `Optional` class describing
    the value (if present, or it returns an `Optional` class produced by the supplying
    function).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or(Supplier<Optional<T>> supplier)`: 返回一个 `Optional` 类，描述了值（如果存在，或者返回由供应函数产生的
    `Optional` 类）。'
- en: '`orElse(T other)`: This returns the value (if present, or it returns `other`).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse(T other)`: 如果存在值，则返回该值，或者返回 `other`。'
- en: '`orElseGet(Supplier<T> supplier)`: This returns the value (if present, or it
    returns the result produced by the supplying function).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseGet(Supplier<T> supplier)`: 如果存在值，则返回该值，或者返回由供应函数产生的结果。'
- en: '`orElseThrow(Supplier<X> exceptionSupplier)`: This returns the value (if present,
    or it throws an exception produced by the exception-supplying function).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseThrow(Supplier<X> exceptionSupplier)`: 如果存在值，则返回该值，或者抛出由异常供应函数产生的异常。'
- en: 'Note that `Optional` is used as a return value in cases when `null` is a possible
    result. Here is an example of the usage. We reimplemented the stream-concatenating
    code using the `reduce()` operation that returns `Optional`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当可能返回 `null` 时，使用 `Optional` 作为返回值。以下是一个使用示例。我们重新实现了使用返回 `Optional` 的 `reduce()`
    操作的流连接代码：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is the same as in the previous implementation with a `flatMap()` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前的实现相同，使用了 `flatMap()` 方法：
- en: '![](img/ad05dc2c-a8f6-474b-a382-9baef7e45811.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad05dc2c-a8f6-474b-a382-9baef7e45811.png)'
- en: 'The next group of terminal operations is referred to as `forEach()`. These
    operations guarantee that the given function will be applied to each element of
    the stream, but `forEach()` does not say anything about the order, which might
    be changed for better performance. By contrast, `forEachOrdered()` guarantees not
    only the processing of all the elements of the stream, but also doing this in
    the order specified by its source, regardless of whether the stream is sequential
    or parallel. Here are a couple of examples of this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个终端操作组被称为 `forEach()`。这些操作确保给定的函数将被应用到流中的每个元素上，但 `forEach()` 并没有说明任何关于顺序的内容，这可能为了更好的性能而改变。相比之下，`forEachOrdered()`
    不仅保证了处理流中的所有元素，而且无论流是顺序的还是并行的，都会按照其源指定的顺序执行。以下是一些示例：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/c4c32012-5098-4e71-9ac7-1b08651205b5.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4c32012-5098-4e71-9ac7-1b08651205b5.png)'
- en: 'As you can see, in the case of parallel processing, `forEach()` does not guarantee
    the order, while `forEachOrdered()` does. Here is another example of using both `Optional`
    and `forEach()`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在并行处理的情况下，`forEach()` 不保证顺序，而 `forEachOrdered()` 则保证。以下是一个同时使用 `Optional`
    和 `forEach()` 的示例：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We could not use `Optional.of()` and used `Optional.ofNullable()` instead because
    `Optional.of()` would throw `NullPointerException` on `null`. In such a case, `Optional.ofNullable()`
    just returns `Optional` empty. The result is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用 `Optional.of()`，而是使用了 `Optional.ofNullable()`，因为 `Optional.of()` 在遇到
    `null` 时会抛出 `NullPointerException`。在这种情况下，`Optional.ofNullable()` 只会返回一个空的 `Optional`。结果如下：
- en: '![](img/121b8403-b056-4116-8aa2-ac7e319e8275.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/121b8403-b056-4116-8aa2-ac7e319e8275.png)'
- en: Now let's talk about the next group of terminal operations, called `reduce()`.
    Each of the three overloaded methods returns a single value after processing all
    the stream elements. Among the most simple examples are finding a sum of the stream
    elements in case they are numbers, or max, min, and similar. But a more complex
    result can be constructed too for a stream of objects of any type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈下一组终端操作，称为 `reduce()`。这三个重载方法在处理所有流元素后返回一个单一值。最简单的例子是找到流元素的总和（如果它们是数字），或者最大、最小值等。但也可以为任何类型的对象流构建更复杂的结果。
- en: 'The first method, namely `reduce(BinaryOperator<T> accumulator)`, returns `Optional` because
    it is the responsibility of the provided accumulator function to calculate the
    result. And, the authors of the JDK implementation cannot guarantee it will always
    have some value:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，即 `reduce(BinaryOperator<T> accumulator)`，返回 `Optional`，因为计算结果的责任在于提供的累加器函数。而且，JDK
    实现的作者不能保证它总是有一些值：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The passed-in function is provided the result of the previous result of the
    same function (as the first parameter `p`) and the next element of the stream
    (as the second parameter `e`). For the very first element, `p` gets its value,
    while `e` is the second element. The result is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的函数提供了相同函数的前一个结果（作为第一个参数 `p`）和流中的下一个元素（作为第二个参数 `e`）。对于第一个元素，`p` 获取其值，而 `e`
    是第二个元素。结果如下：
- en: '![](img/da547cd3-0ddb-4698-bbcf-e717a1f6900b.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da547cd3-0ddb-4698-bbcf-e717a1f6900b.png)'
- en: 'To avoid the extra step with `Optional`, the second method returns the value
    provided as the first parameter `identity` of the type `T` (which is the type
    of the elements of `Stream<T>`) in case the stream is empty. This parameter has
    to comply with this requirement (from Javadoc): *for all t, accumulator.apply(identity,
    t) is equal to t*. In our case, it has to be `0` for it to comply with `0 + e
    == e`. Here is an example of how to use the second method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用`Optional`的额外步骤，第二个方法在流为空的情况下返回作为第一个参数`identity`的类型`T`（它是`Stream<T>`元素的类型）的值。此参数必须符合以下要求（来自Javadoc）：*对于所有t，accumulator.apply(identity,
    t)等于t*。在我们的情况下，它必须是`0`，以便符合`0 + e == e`。以下是如何使用第二个方法的例子：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result is the same as with the first `reduce()` method. The third one converts
    the value of the type `T` into a value of the type `U` with the help of the `BiFunction<U,T,U>` function.
    Then, the result (of the type `R`) goes through the same logic of processing it
    as the type `T`, as in the previous method. Here is an example of this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与第一个`reduce()`方法相同。第三个方法使用`BiFunction<U,T,U>`函数将类型`T`的值转换为类型`U`的值。然后，结果（类型为`R`）通过与类型`T`相同的逻辑进行处理，就像上一个方法一样。以下是一个例子：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'One naturally expects to see the result as `1,2,3`. Instead, we see the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 人们自然期望看到的结果是`1,2,3`。然而，我们看到的是以下内容：
- en: '![](img/f453e234-85f7-47da-9afe-f3adad0ba221.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f453e234-85f7-47da-9afe-f3adad0ba221.png)'
- en: 'Make the stream parallel like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将流并行化如下：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Only if you do this, you will see what''s expected:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只有这样做，你才会看到预期的结果：
- en: '![](img/d862ec3f-c521-4e50-8dd2-928d9b51bf7c.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d862ec3f-c521-4e50-8dd2-928d9b51bf7c.png)'
- en: 'This means that the combiner is called only for parallel processing in order
    to assemble (combine) the results of different streams (processed in parallel).
    This is the only deviation we have noticed so far from the declared intent of
    providing the same behavior for sequential and parallel streams. But there are
    many ways to accomplish the same result without using this third version of `reduce()`.
    For example, consider this code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着组合器仅在并行处理时被调用，以便组装（组合）不同流（并行处理）的结果。这是我们迄今为止发现的唯一一个与声明意图提供顺序和并行流相同行为的偏差。但是，有许多方法可以实现相同的结果，而不使用`reduce()`的第三个版本。例如，考虑以下代码：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It produces the same result, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生相同的结果，如下所示：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the result:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![](img/7d9b41e2-ae9e-4d68-a4b6-c96d0ee5d12b.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d9b41e2-ae9e-4d68-a4b6-c96d0ee5d12b.png)'
- en: 'The next group of intermediate operations, called `collect()`, consists of
    two methods. The first one accepts `Collector` as a parameter. It is much more
    popular than the second one because it is backed up by the `Collectors` class,
    which provides a wide variety of implementations of the `Collector` interface.
    We encourage you to go through the Javadoc of the `Collectors` class and see what
    it offers. Let''s discuss a few examples of this. First, we''ll create a small
    `demo` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个中间操作组，称为`collect()`，由两个方法组成。第一个方法接受`Collector`作为参数。它比第二个方法更受欢迎，因为它得到了`Collectors`类的支持，该类提供了`Collector`接口的多种实现。我们鼓励您查阅`Collectors`类的Javadoc，看看它提供了什么。让我们讨论一些这个方法的例子。首先，我们将创建一个小的`demo`类：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can use it to demonstrate a few collectors:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来演示几个收集器：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result will be as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/d68dd3e2-b17e-4ccb-b09b-3183f04842b1.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d68dd3e2-b17e-4ccb-b09b-3183f04842b1.png)'
- en: The joining collector is a source of joy for any programmer who has ever had
    to write code that checks whether the added element is the first, the last, or
    removes the last character (like we did in the last example of the `reduce()`
    operation). The `joining()` collector does this behind the scenes. All the programmer
    has to pass are the delimiter, prefix, and suffix.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 连接收集器是任何编写过检查添加的元素是否是第一个、最后一个或删除最后一个字符（就像我们在`reduce()`操作的最后一个例子中所做的那样）的代码的程序员的一种快乐来源。`joining()`收集器在幕后完成这项工作。程序员只需要传递分隔符、前缀和后缀。
- en: Most programmers will never need to write a custom collector. But in case there
    is a need, one can use the second method `collect()` of `Stream` (and provide
    functions that will compose a collector) or use one of the two static methods
    `Collector.of()` that generates a collector that can be reused.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员永远不会需要编写自定义收集器。但在需要的情况下，可以使用`Stream`的第二个`collect()`方法（并提供将组合收集器的函数）或使用两个静态方法`Collector.of()`之一来生成可以重用的收集器。
- en: If you compare the `reduce()` and `collect()` operations, you'll notice that
    the primary purpose of `reduce()` is to operate on immutable objects and primitives.
    The result of `reduce()` is one value that is typically (but not exclusively)
    of the same type as the elements of the stream. The `collect()`, by contrast,
    produces the result of a different type wrapped in a mutable container. The most
    popular usage of `collect()` is centered around producing `List`, `Set`, or `Map` using
    the corresponding `Collectors.toList()`, `Collectors.toSet()`, or `Collectors.toMap()` collector.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你比较 `reduce()` 和 `collect()` 操作，你会注意到 `reduce()` 的主要目的是操作不可变对象和原始数据类型。`reduce()`
    的结果是通常（但不限于）与流中的元素类型相同的一个值。相比之下，`collect()` 产生一个不同类型的封装在可变容器中的结果。`collect()` 最受欢迎的使用集中在使用相应的
    `Collectors.toList()`、`Collectors.toSet()` 或 `Collectors.toMap()` 收集器来生成 `List`、`Set`
    或 `Map`。 '
- en: 'The last group of terminal operations consists of two methods `toArray()`.
    One of them returns `Object[]`, another one returns an array of the specified
    type. Let''s look at the examples of their usage:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个终端操作组包括两个 `toArray()` 方法。其中一个返回 `Object[]`，另一个返回指定类型的数组。让我们看看它们使用的例子：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of these examples is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子的输出如下：
- en: '![](img/3e1381e8-e62e-47fa-b87c-24959060fb00.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e1381e8-e62e-47fa-b87c-24959060fb00.png)'
- en: 'The first example is quite straightforward. It is worth commenting though that
    we cannot write the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子相当直接。不过，值得注意的是，我们不能写出以下内容：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is because `toArray()` is a terminal operation and the stream is closed
    automatically after it. That's why we have to open a new stream in the second
    line.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `toArray()` 是一个终端操作，在它之后流会自动关闭。这就是为什么我们不得不在第二行打开一个新的流。
- en: 'The second example--with the overloaded `A[] toArray(IntFunction<A[]> generator)`
    method--is more complicated. The Javadoc says this: *The generator function takes
    an integer, which is the size of the desired array, and produces an array of the
    desired size*. This means that the method reference to a `toArray(String[]::new)` constructor
    in the last example is a shorter version of `toArray(size -> new String[size])`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子——使用重载的 `A[] toArray(IntFunction<A[]> generator)` 方法——更为复杂。Javadoc 中说：“生成器函数接收一个整数，它是所需数组的尺寸，并生成所需尺寸的数组。”这意味着在最后一个例子中，`toArray(String[]::new)`
    构造函数的方法引用是 `toArray(size -> new String[size])` 的简短版本。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `java.util.stream` package also provides specialized interfaces, namely `IntStream`,
    `DoubleStream`, and `LongStream`, that are optimized for processing streams of
    values of corresponding primitive types. It is very convenient to use them in
    the case of reducing operations. For example, they have `max()`, `min()`, `average()`,
    `sum()`, and many other simplified (tuned for performance) methods that can be
    called on these streams directly as intermediate and terminal operations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream` 包还提供了专门接口，即 `IntStream`、`DoubleStream` 和 `LongStream`，它们针对处理相应原始类型值的流进行了优化。在执行减少操作时使用它们非常方便。例如，它们有
    `max()`、`min()`、`average()`、`sum()` 以及许多其他可以直接作为中间和终端操作调用的简化（针对性能调优）方法。'
- en: See also
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下食谱：
- en: Create operation pipeline on streams
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流上创建操作管道
- en: Parallel computations on streams
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流上执行并行计算
- en: Creating an operation pipeline on streams
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在流上创建操作管道
- en: In this recipe, you will learn how to build a pipeline from `Stream` operations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何从 `Stream` 操作构建管道。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'In the previous chapter, while creating a lambda-friendly API, we ended up
    with the following API method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们创建一个适合 lambda 表达式的 API 时，我们得到了以下 API 方法：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The specified number of `TrafficUnit` instances were produced inside the `speedAfterStart()`
    method. They were limited by the `limitTrafficAndSpeed` function and processed
    according to the `speedModel` function inside the `speedAfterStart()` method.
    The results were shown on the device and in the format specified by the `printResults` function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `speedAfterStart()` 方法内部生成了指定的 `TrafficUnit` 实例。它们被 `limitTrafficAndSpeed`
    函数限制，并按照 `speedAfterStart()` 方法内部的 `speedModel` 函数进行处理。结果在设备上以及由 `printResults`
    函数指定的格式中显示。
- en: It is a very flexible design that allows you to have quite a range of experimentation
    via the modification of functions that are passed to the API. In reality, though,
    especially during the early stages of data analysis, having an API creates an
    overhead. If the provided flexibility is not enough, one needs to change it and
    build and deploy a new version. It takes time and the implementation lacks transparency.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常灵活的设计，允许你通过修改传递给API的函数进行相当广泛的实验。然而，在现实中，尤其是在数据分析的早期阶段，拥有一个API会带来开销。如果提供的灵活性不足，就需要对其进行更改，构建和部署新版本。这需要时间，而且实现缺乏透明度。
- en: To be fair, the encapsulation of the implementation details was one of the API
    design requirements. But it works well with the established processes that need
    to be wrapped as a product for a population of users. The situation radically
    changes during the research phase. When new algorithms are developed and tested
    and when the need for processing a large amount of data presents its own challenge,
    transparency across all the layers of the developed system becomes a foundational
    requirement. Without it, many of today's successes in the big data analysis world
    would be impossible.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，封装实现细节是API设计要求之一。但是，它与需要封装为产品供用户群体使用的过程相结合时效果良好。在研究阶段，情况发生了根本性的变化。当开发并测试新的算法，以及需要处理大量数据时，其自身带来的挑战，使得整个开发系统的透明度成为一项基本要求。没有它，今天在大数据分析领域中的许多成功将是不可能的。
- en: Streams and the pipelines of stream operations address the problem of transparency
    and minimize the overhead of writing infrastructural code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 流和流操作管道解决了透明度问题，并最小化了编写基础设施代码的开销。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s recall how a user called the lambda-friendly API:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下用户是如何调用lambda友好的API的：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we have already noticed, the freedom of the speed calculation manipulation
    with such an API (without changing it) extends to the formula of the speed calculation,
    device and format of the output, and the selection of traffic. This is not bad
    in our simplistic application, but it might not cover all the possibilities of
    the model evolution in the case of more complex calculations. But it is a good
    start that allows us to construct the stream and the pipeline of operations for
    more transparency and flexibility of experimentation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经注意到的，使用这样的API（不改变它）对速度计算操作的自由度扩展到了速度计算的公式、输出设备和格式，以及交通的选择。在我们的简单应用中，这并不坏，但在更复杂的计算情况下，它可能无法涵盖模型演变的所有可能性。但这是一个良好的开端，使我们能够构建流和操作管道，以实现更高的透明度和实验灵活性。
- en: 'Now let''s look at the API implementation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看API实现：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we convert the `for` loop into a stream of traffic units and apply the
    same functions directly to the elements of the stream. But first, we can request
    the traffic-generating system to supply us with `Stream` instead of `List` of
    data. This allows you to avoid the storing of all the data in the memory:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`for`循环转换为交通单位流，并将相同的函数直接应用于流的元素。但首先，我们可以要求交通生成系统提供`Stream`而不是数据`List`。这允许你避免在内存中存储所有数据：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This allows you to process an endless number of traffic units without storing
    more than one unit at a time in the memory. In the demo code, we still create
    `List`, so the streaming does not save us memory. But there are real systems,
    such as sensors, that can provide streams without storing all of the data in the
    memory first.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在不存储超过一个单位的同时处理无限数量的交通单位。在演示代码中，我们仍然创建`List`，因此流不会节省我们内存。但有一些真实系统，例如传感器，可以在不首先将所有数据存储在内存中的情况下提供流。
- en: 'We will also create a convenience method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个便利的方法：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this, we will now write the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将写下以下内容：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We mapped (transform) `TrafficUnit` to `Vehicle`, then mapped `Vehicle` to
    `speed`, then used the current `TrafficUnit` instance and calculated `speed` to
    limit the traffic and print results. If you have this code in a modern editor,
    you will notice that it does not compile because after the first map, the current
    `TrafficUnit` element is not accessible anymore; it is replaced by `Vehicle`.
    This means we need to carry along the original elements and add new values on
    the way. To accomplish this, we need a container--some kind of a traffic unit
    wrapper. Let''s create one:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`TrafficUnit`映射（转换）为`Vehicle`，然后将`Vehicle`映射到`speed`，接着使用当前的`TrafficUnit`实例计算`speed`以限制交通并打印结果。如果你在现代编辑器中看到这段代码，你会注意到它无法编译，因为第一次映射之后，当前的`TrafficUnit`元素就不再可访问了；它被`Vehicle`所取代。这意味着我们需要携带原始元素并在过程中添加新值。为了实现这一点，我们需要一个容器——一种交通单元包装器。让我们创建一个：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can build a pipeline that works:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建一个有效的管道：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The code looks a bit verbose, especially the `Vehicle` and `SpeedModel` setting.
    We can hide these plumbing details by moving them to the `TrafficUntiWrapper` class:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来有点冗长，特别是`Vehicle`和`SpeedModel`设置。我们可以通过将它们移动到`TrafficUnitWrapper`类来隐藏这些管道细节：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Notice how we return `this` from the `setSpeedModel()` and `setSpeed()` methods.
    This allows us to preserve the fluent style. Now the pipeline looks much cleaner:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何从`setSpeedModel()`和`setSpeed()`方法返回`this`的。这允许我们保持流畅的风格。现在管道看起来更加清晰：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If there is no need to keep the formula for the speed calculations easily accessible
    to the modification, we can move it to the `TrafficUnitWrapper` class too by changing
    the `setSpeed()` method to `calcSpeed()`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有必要让速度计算的公式易于修改，我们可以通过将`setSpeed()`方法更改为`calcSpeed()`将这个公式也移动到`TrafficUnitWrapper`类中：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'So, the pipeline becomes even less verbose:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，管道变得更加简洁：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Based on this technique, we can now create a method that calculates traffic
    density--the count of vehicles in each lane of a multilane road for the given
    speed limit in each of these lanes:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这项技术，我们现在可以创建一个计算交通密度的方法——对于每条车道给定的速度限制，计算多车道道路上每条车道中的车辆数量：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It uses two private classes, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了两个私有类，如下所示：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It also uses the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使用了以下内容：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It uses the private method too:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它也使用了私有方法：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In [Chapter 15](823213ae-b820-450c-abb8-8a98a70caf70.xhtml), *Testing*, we will
    discuss this method (of the `TrafficDensity` class) in more detail and revisit
    this implementation to allow you to have better unit testing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](823213ae-b820-450c-abb8-8a98a70caf70.xhtml) *测试* 中，我们将更详细地讨论这个方法（`TrafficDensity`类的这个方法），并重新审视这个实现，以便你可以进行更好的单元测试。
- en: This is why writing a unit test parallel to the code development brings higher
    productivity by eliminating the need for changing the code afterward. It also
    results in more testable (better quality) code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在代码开发的同时编写单元测试可以带来更高的生产力，因为它消除了之后修改代码的需求。这也导致了更可测试（质量更好）的代码。
- en: There's more...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The pipeline allows you to add another filter (or any other operation) easily:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 管道允许你轻松地添加另一个过滤器（或任何其他操作）：
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It is especially important when many types of data have to be processed. It's
    worth mentioning that having a filter before the calculations is the best way
    to improve performance because it allows you to avoid unnecessary calculations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要处理多种类型的数据时，这一点尤为重要。值得一提的是，在计算之前有一个过滤器是提高性能的最佳方式，因为它允许你避免不必要的计算。
- en: Another major advantage of using a stream is that the process can be made parallel
    without extra coding. All one needs to do is change the first line of the pipeline
    to `getTrafficUnitStream(trafficUnitsNumber).parallel()` (assuming the source
    does not generate the parallel stream, which can be identified by the `.isParallel()`
    operation). We will talk about this in more detail in the next recipe.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流的另一个主要优点是，可以在不额外编码的情况下使过程并行化。所有你需要做的就是将管道的第一行更改为`getTrafficUnitStream(trafficUnitsNumber).parallel()`（假设源不生成并行流，可以通过`.isParallel()`操作识别）。我们将在下一章中更详细地讨论这一点。
- en: See also
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe in this chapter:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下配方：
- en: Parallel computations on streams
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的并行计算
- en: Parallel computations on streams
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流的并行计算
- en: In the previous recipes, we have already demonstrated some of the parallel stream
    processing techniques. In this recipe, we will discuss this in greater detail
    and share the best practices and possible problems and how to avoid them.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们已经演示了一些并行流处理技术。在这个菜谱中，我们将更详细地讨论这个问题，并分享最佳实践和可能的问题以及如何避免它们。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is tempting to just set up all the streams parallelly and not think about
    it again. Unfortunately, parallelism does not always provides an advantage. In
    fact, it incurs an overhead because of the worker threads' coordination. Besides,
    some stream sources are sequential in nature and some operations may share the
    same (synchronized) resource. Even worse, the usage of a stateful operation can
    lead to an unpredictable result. It is not that you cannot use a stateful operation
    for a parallel stream; it requires careful planning and clear understanding of
    the state management.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易就设置所有流为并行，并且不再考虑它。不幸的是，并行性并不总是提供优势。事实上，它因为工作线程的协调而产生了开销。此外，一些流源本质上是顺序的，一些操作可能共享相同的（同步）资源。更糟糕的是，使用有状态的操作可能导致不可预测的结果。并不是说不能为并行流使用有状态的操作；它需要仔细规划和清楚理解状态管理。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: As mentioned in the previous recipe, a parallel stream can be created by the
    `parallelStream()` method of a collection or the `parallel()` method applied to
    a stream. Conversely, the existing parallel stream can be converted into a sequential
    one by calling the stream using the `sequential()` method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一道菜谱中所述，可以通过集合的 `parallelStream()` 方法或应用于流的 `parallel()` 方法创建并行流。相反，可以通过调用流的
    `sequential()` 方法将现有的并行流转换为顺序流。
- en: As the first best practice, use a sequential stream by default and start thinking
    about the parallel one only if you have to and you can. The have to usually comes
    up if the performance is not good enough and a large amount of data has to be
    processed. The possibilities are limited by the nature of the stream source and
    operations. Some of them cannot be either processed in parallel or produce non-deterministic
    results.  For example, reading from a file is sequential and a file-based stream
    does not perform better in parallel. Any blocking operation also negates performance
    improvement in parallel.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一条最佳实践，默认使用顺序流，并且只有在必须且能够这样做的情况下才考虑并行流。通常，当性能不足且需要处理大量数据时，这种情况才会出现。可能性受到流源和操作性质的限制。其中一些既不能并行处理，也可能产生非确定性的结果。例如，从文件中读取是顺序的，基于文件的流在并行时并不表现更好。任何阻塞操作也会否定并行带来的性能提升。
- en: 'One of the areas where sequential and parallel streams are different is ordering.
    Here is an example of this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序流和并行流不同的领域之一是排序。以下是一个例子：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The result is as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/954a43e1-a594-454f-b30b-a83e2f6431ec.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/954a43e1-a594-454f-b30b-a83e2f6431ec.png)'
- en: As you can see, `List` preserves the order of the elements but does not keep
    it in the case of parallel streams.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`List` 保留了元素的顺序，但在并行流的情况下并不保持它。
- en: In the *Creating and operating on streams* recipe, we showed that with the `reduce()`
    and `collect()` operations, a combiner is called only for a parallel stream. So,
    it is not needed for a sequential stream, but it must be present while operating
    on a parallel one. Without it, the results of multiple workers are not correctly
    aggregated.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *创建和操作流* 的菜谱中，我们展示了使用 `reduce()` 和 `collect()` 操作时，组合器只为并行流调用。因此，对于顺序流来说，它不是必需的，但在操作并行流时必须存在。如果没有它，多个工作者的结果将无法正确汇总。
- en: We have also demonstrated the stateful operations `sorted()`, `distinct()`,
    `limit()`, and `skip()` yielding a non-deterministic result in the case of parallel
    processing. If an order is important, you can rely on the stream method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还演示了 `sorted()`、`distinct()`、`limit()` 和 `skip()` 等有状态操作在并行处理的情况下产生非确定性的结果。如果顺序很重要，您可以通过流方法来依赖。
- en: If an order is important, we have shown that you can rely on the `forEachOrdered()` 
    stream method. It not only guarantees the processing of all the elements of the
    stream, but also doing it in the order specified by its source, regardless of
    whether the stream is sequential or parallel.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顺序很重要，我们已经展示了您可以通过依赖 `forEachOrdered()` 流方法来确保处理流的所有元素，并且按照其源指定的顺序进行处理，无论流是顺序的还是并行的。
- en: Whether a parallel stream is created by the `parallelStream()` method of a collection
    or by the `parallel()` method applied to a stream, the underlying implementation
    uses the same `ForkJoin` framework introduced in Java 7\. The stream is broken
    down into segments that are then given to different worker threads for processing.
    On a computer with only one processor, it does not have an advantage, but on a
    multicore computer, worker threads can be executed by different processors. Even
    more, if one worker becomes idle, it can *steal* a part of the job from a busy
    one. The results are then collected from all the workers and aggregated for the
    terminal operation completion (that is, when a combiner of a collect operation
    becomes busy).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 无论并行流是由集合的 `parallelStream()` 方法创建，还是由应用于流的 `parallel()` 方法创建，其底层实现都使用了在 Java
    7 中引入的相同 `ForkJoin` 框架。流被分解成段，然后分配给不同的工作线程进行处理。在只有一个处理器的计算机上，它没有优势，但在多核计算机上，工作线程可以由不同的处理器执行。更重要的是，如果一个工作线程空闲，它可以
    *窃取* 来自忙碌工作线程的一部分工作。然后从所有工作线程收集结果，并聚合以完成终端操作（即，当收集操作的合并器变得忙碌时）。
- en: 'Generally speaking, if there is a resource that is not safe for a concurrent
    access, it is not safe to use it during parallel stream processing. Consider these
    two examples (`ArrayList` is not known to be threadsafe):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，如果一个资源不适合并发访问，那么在并行流处理期间使用它是不安全的。考虑以下两个例子（`ArrayList` 并非线程安全）：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If run several times, this code may produce the following result:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多次运行此代码，可能会产生以下结果：
- en: '![](img/89610f0d-2b4c-417d-a22a-87c3c08dcca4.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89610f0d-2b4c-417d-a22a-87c3c08dcca4.png)'
- en: The `Collectors.toList()` method always generates the same list that consists
    of `is` and `Stream.of(literals)`, while `forEach()` misses either `is` or `Stream.of(literals)`
    once in a while.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors.toList()` 方法始终生成由 `is` 和 `Stream.of(literals)` 组成的相同列表，而 `forEach()`
    有时会错过 `is` 或 `Stream.of(literals)`。'
- en: If possible, try using collectors constructed by the `Collectors` class first
    and avoid shared resource during parallel computations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，首先尝试使用由 `Collectors` 类构建的收集器，并在并行计算期间避免使用共享资源。
- en: Overall, using stateless functions is your best bet for parallel stream pipelines.
    If in doubt, test your code, most importantly, run the same test many times to
    check whether the result is stable.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，使用无状态函数是并行流管道的最佳选择。如果有疑问，测试你的代码，最重要的是，多次运行相同的测试以检查结果是否稳定。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the [Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml), *Concurrent
    and Multithreaded Programming* for more examples of the usage of classes from
    the package `java.util.stream`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 7 章 [Concurrent and Multithreaded Programming](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml)，了解更多关于
    `java.util.stream` 包中类使用示例。
