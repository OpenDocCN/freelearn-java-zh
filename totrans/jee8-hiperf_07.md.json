["```java\n@ApplicationScoped\npublic class ExternalServiceClient {\n    @Inject\n    private Client client;\n\n    public Data get() {\n        return Stream.of(\"http://server1.company.com\",\n        \"http://server2.company.com\")\n                .map(server -> {\n                    try {\n                        return client.target(server)\n                                .path(\"/api/quote\")\n                                .request(APPLICATION_JSON_TYPE)\n                                .get(Data.class);\n                    } catch (final WebApplicationException wae) {\n                        if (supportsFailover(wae)) {\n                            return null;\n                        }\n                        throw wae;\n                    }\n                })\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElseThrow(() -> new IllegalStateException(\"No\n                available target\n                server\"));\n    }\n}\n```", "```java\nprivate boolean supportsFailover(final WebApplicationException wae) {\n    final Response response = wae.getResponse();\n    if (response == null) { // client error, no need to retry\n        return false;\n    }\n    return response.getStatus() > 412;\n    // 404, 412 are correct answers we don't need to retry\n}\n```", "```java\ntry {\n    return getRemoteResponse();\n    } catch (final UnexpectedError error) {\n    return getLocalResponse();\n}\n```", "```java\n@ApplicationScoped\npublic class ExternalServiceClient {\n    @Inject\n    private Client client;\n\n    public Data get() {\n        return Stream.<Supplier<Data>>of(\n                    () -> getData(\"http://server1.company.com\"),\n                    () -> getData(\"http://server1.company.com\"))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElseThrow(() -> new IllegalStateException(\"No\n                available remote\n                server\"));\n    }\n\n    private Data getData(final String host) {\n        try {\n            return client.target(host)\n                    .path(\"/api/quote\")\n                    .request(APPLICATION_JSON_TYPE)\n                    .get(Data.class);\n        } catch (final WebApplicationException wae) {\n            if (supportsFailover(wae)) {\n                return null;\n            }\n            throw wae;\n        }\n    }\n\n    // supportsFailover() as before\n}\n```", "```java\nStream.<Supplier<Data>>of(\n            () -> getData(\"http://server1.company.com\"),\n            () -> new Data(\"some value\"))\n```", "```java\n@Fallback(method = \"getDataFallback\")\npublic Data getData() {\n    return client.target(\"http://server1.company.com\")\n               .request(APPLICATION_JSON_TYPE)\n               .get(Data.Class);\n}\n\nprivate Data getDataFallback() {\n    return new Data(...);\n}\n```", "```java\n@Failoverable\npublic interface GetData {\n    Data fetch();\n}\n```", "```java\n@ApplicationScoped\n@Priority(0)\n@Failoverable\npublic class RemoteGetData {\n    @Inject\n    private Client client;\n\n    @Override\n    public Data fetch() {\n        return client.\n        ....\n        get(Data.class);\n    }\n}\n```", "```java\n@ApplicationScoped\n@Priority(1000)\n@Failoverable\npublic class LocalGetData {\n    @Override\n    public Data fetch() {\n        return new Data(...);\n    }\n}\n```", "```java\npublic class MyService {\n    @Inject\n    private GetData dataService;\n\n    public void saveData() {\n        final Data data = dataService.fetch();\n        doSave(data);\n    }\n\n    // implement doSave as you need\n}\n```", "```java\n@Target(TYPE)\n@Retention(RUNTIME)\npublic @interface Failoverable {\n}\n```", "```java\npublic class FailoverExtension implements Extension {\n  private final Map<Class<?>, Collection<Bean<?>>> beans = new\n  HashMap<>();\n  private final Annotation failoverableQualifier = new\n  AnnotationLiteral<Failoverable>() {\n  };\n\n  // ensure our @Failoverable annotation is qualifying the beans who\n  used this\n  annotation\n  // to avoid any ambiguous resolution during the startup\n  void addQualifier(@Observes final BeforeBeanDiscovery\n  beforeBeanDiscovery) {\n    beforeBeanDiscovery.addQualifier(Failoverable.class);\n  }\n\n  // find all API we want to have support for failover\n  void captureFailoverable(@Observes\n  @WithAnnotations(Failoverable.class) final\n  ProcessAnnotatedType<?> processAnnotatedType) {\n    final AnnotatedType<?> annotatedType =\n    processAnnotatedType.getAnnotatedType();\n    final Class<?> javaClass = annotatedType.getJavaClass();\n    if (javaClass.isInterface() &&\n    annotatedType.isAnnotationPresent(Failoverable.class)) {\n      getOrCreateImplementationsFor(javaClass);\n    }\n  }\n\n  // find all implementations of the failover API/interfaces\n  void findService(@Observes final ProcessBean<?> processBean) {\n    extractFailoverable(processBean)\n        .ifPresent(api ->\n        getOrCreateImplementationsFor(api).add(processBean.getBean()));\n  }\n\n  // iterates over all API and create a new implementation for them\n  which is\n  added\n  // as a new CDI bean with @Default (implicit) qualifier.\n  // to do that we use the new CDI 2.0 configurator API (addBean())\n  which allows\n  // us to define a bean \"inline\".\n  void addFailoverableImplementations(@Observes final\n  AfterBeanDiscovery\n  afterBeanDiscovery, final BeanManager beanManager) {\n    beans.forEach((api, implementations) ->\n        afterBeanDiscovery.addBean()\n          .types(api, Object.class)\n          .scope(ApplicationScoped.class)\n          .id(Failoverable.class.getName() + \"(\" + api.getName() + \")\")\n          .qualifiers(Default.Literal.INSTANCE, Any.Literal.INSTANCE)\n          .createWith(ctx -> {\n            final Collection<Object> delegates =\n            implementations.stream()\n                .sorted(Comparator.comparingInt(b -> getPriority(b,\n                beanManager)))\n                .map(b -> beanManager.createInstance()\n                    .select(b.getBeanClass(),\n                    failoverableQualifier).get())\n                .collect(toList());\n            final FailoverableHandler handler = new\n            FailoverableHandler(delegates);\n            return Proxy.newProxyInstance(api.getClassLoader(), new\n            Class<?>[\n            ]{api}, handler);\n          }));\n    beans.clear();\n  }\n\n  // helper method to extract the priority of an implementation\n  // to be able to sort the implementation and failover properly\n  // on lower priority implementations\n  private int getPriority(final Bean<?> bean, final BeanManager\n  beanManager) {\n    final AnnotatedType<?> annotatedType =\n    beanManager.createAnnotatedType(bean.getBeanClass());\n    return\n  Optional.ofNullable(annotatedType.getAnnotation(Priority.class))\n        .map(Priority::value)\n        .orElse(1000);\n  }\n\n  // if the api doesn't have yet a \"bucket\" (list) for its\n  implementations\n  // create one, otherwise reuse it\n  private Collection<Bean<?>> getOrCreateImplementationsFor(final Class\n  api) {\n    return beans.computeIfAbsent(api, i -> new ArrayList<>());\n  }\n\n  // if the bean is an implementation then extract its API.\n  // we do it filtering the interfaces of the implementation\n  private Optional<Class> extractFailoverable(final ProcessBean<?>\n  processBean) {\n    return \n  processBean.getBean().getQualifiers().contains(failoverableQualifier)\n    ?\n        processBean.getBean().getTypes().stream()\n          .filter(Class.class::isInstance)\n          .map(Class.class::cast)\n          .filter(i -> i.isAnnotationPresent(Failoverable.class))\n          .flatMap(impl -> Stream.of(impl.getInterfaces()).filter(i ->\n          i !=\n          Serializable.class))\n          .findFirst() : Optional.empty();\n  }\n}\n```", "```java\nclass FailoverableHandler implements InvocationHandler {\n    private final Collection<Object> delegates;\n\n    FailoverableHandler(final Collection<Object> implementations) {\n        this.delegates = implementations;\n    }\n\n    @Override\n    public Object invoke(final Object proxy, final Method method, final\n    Object[]\n    args) throws Throwable {\n        for (final Object delegate : delegates) {\n            try {\n                return method.invoke(delegate, args);\n            } catch (final InvocationTargetException ite) {\n                final Throwable targetException =\n                ite.getTargetException();\n                if (supportsFailover(targetException)) {\n                    continue;\n                }\n                throw targetException;\n            }\n        }\n        throw new FailoverException(\"No success for \" + method + \"\n        between \" +\n        delegates.size() + \" services\");\n    }\n\n    private boolean supportsFailover(final Throwable targetException) {\n        return \n    targetException.getClass().isAnnotationPresent(Failoverable.class);\n    }\n}\n```", "```java\n@ApplicationScoped\npublic class QuoteServiceClient {\n    @Inject\n    private Client client;\n\n    @CacheResult(skipGet = true)\n    public Data fetch() {\n        return client.target(....)....get(Data.class);\n    }\n}\n```", "```java\n@ApplicationScoped\npublic class QuoteServiceCache {\n\n    @CacheResult(cacheName =\n    \"com.company.quote.QuoteServiceClient.fetch()\")\n    public Data fetch() {\n        return null;\n    }\n}\n```", "```java\n@ApplicationScoped\npublic class QuoteServiceClient {\n    @Inject\n    private Client client;\n\n    @CacheResult\n    public Data fetch() {\n        return client.....get(Data.Class);\n    }\n}\n```", "```java\n@ApplicationScoped\npublic class QuoteServiceClient {\n    @CacheResult\n    public Data fetch() {\n        return null;\n    }\n}\n```", "```java\nnew MutableConfiguration<>()\n .setCacheLoaderFactory(new FactoryBuilder.SingletonFactory<>(new QuoteLoader()))\n```", "```java\n@ApplicationScoped\npublic class QuoteLoader implements CacheLoader<QuoteGeneratedCacheKey, Quote> {\n    @Inject\n    private QuoteClient client;\n\n    @Override\n    public Quote load(QuoteGeneratedCacheKey generatedCacheKey) throws\n    CacheLoaderException {\n        return client.load(key.extractSymbol());\n    }\n\n    @Override\n    public Map<QuoteGeneratedCacheKey, Quote> loadAll(final Iterable<?\n extends\n    QuoteGeneratedCacheKey> iterable) throws CacheLoaderException {\n        return StreamSupport.stream(\n            Spliterators.spliteratorUnknownSize(iterable.iterator(),\n            Spliterator.IMMUTABLE), false)\n                .collect(toMap(identity(), this::load));\n    }\n}\n```", "```java\nCache<String, Quote> quotes = getNewQuoteCacheWithLoader();\nQuote pckt = quotes.get(\"PCKT\");\n```", "```java\n@Resource(name = \"threads/quote-manager/quote/findById\")\nprivate ManagedExecutorService findByIdPool;\n\n@GET\n@Path(\"{id}\")\npublic void findById(@PathParam(\"id\") final long id,\n                     @Suspended final AsyncResponse response) {\n    findByIdPool.execute(() -> {\n        final Optional<JsonQuote> result = quoteService.findById(id)\n                .map(quote -> {\n                    final JsonQuote json = new JsonQuote();\n                    json.setId(quote.getId());\n                    json.setName(quote.getName());\n                    json.setValue(quote.getValue());\n                    json.setCustomerCount(ofNullable\n                    (quote.getCustomers())\n                    .map(Collection::size).orElse(0));\n                    return json;\n                });\n        if (result.isPresent()) {\n            response.resume(result.get());\n        } else {\n            response.resume(new\n            WebApplicationException(Response.Status.NO_CONTENT));\n        }\n    });\n}\n```", "```java\nreturn threadPool.submit(() -> {\n    // execute your logic\n    }).get(10, TimeUnit.SECONDS);\n```", "```java\nFuture<?> task = null;\ntry {\n    task = threadPool.submit(() -> {\n        // some logic\n    });\n    task.get(10, TimeUnit.SECONDS);\n} catch (final TimeoutException te) {\n    if (task != null) {\n        task.cancel(true);\n    }\n}\n```"]