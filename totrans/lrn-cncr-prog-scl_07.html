<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 7. Software Transactional Memory"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/><span class="koboSpan" id="kobo.1.1">Chapter 7. Software Transactional Memory</span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"Everybody who learns concurrency and thinks they understand it, ends up finding mysterious races they thought weren't possible, and discovers that they didn't actually understand it yet after all."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Herb Sutter</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">While investigating the fundamental primitives of concurrency in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.9.1">Chapter 2</span></a><span class="koboSpan" id="kobo.10.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.12.1">, we recognized the need for protecting parts of the program from shared access. </span><span class="koboSpan" id="kobo.12.2">We saw that a basic way of achieving this isolation is the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">synchronized</span></code><span class="koboSpan" id="kobo.14.1"> statement, which uses intrinsic object locks to ensure that at most a single thread executes a specific part of the program at the same time. </span><span class="koboSpan" id="kobo.14.2">The disadvantage of using locks is that they can easily cause deadlocks, a situation in which the program cannot progress.</span></p><p><span class="koboSpan" id="kobo.15.1">In this chapter, we will introduce </span><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">Software Transactional Memory</span></strong></span><span class="koboSpan" id="kobo.17.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">STM</span></strong></span><span class="koboSpan" id="kobo.19.1">), a concurrency control mechanism for controlling access to shared memory, which greatly reduces the risk of deadlocks and races. </span><span class="koboSpan" id="kobo.19.2">An STM is used to designate critical sections of the code. </span><span class="koboSpan" id="kobo.19.3">Instead of using locks in order to protect critical sections, STM tracks the reads and writes to shared memory, and serializes critical sections with interleaving reads and writes. </span><span class="koboSpan" id="kobo.19.4">The </span><code class="literal"><span class="koboSpan" id="kobo.20.1">synchronized</span></code><span class="koboSpan" id="kobo.21.1"> statement is replaced with the atomic blocks that express segments of the program that need to be executed in isolation. </span><span class="koboSpan" id="kobo.21.2">STM is safer and easier to use, and at the same time, guarantees relatively good scalability.</span></p><p><span class="koboSpan" id="kobo.22.1">The idea of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.23.1">memory transactions</span></em></span><span class="koboSpan" id="kobo.24.1"> stems from database transactions, which ensure that a sequence of database queries occurs in isolation. </span><span class="koboSpan" id="kobo.24.2">A memory transaction is a sequence of reads and writes to shared memory that logically occur at a single point in time. </span><span class="koboSpan" id="kobo.24.3">When a memory transaction T occurs, concurrent memory transactions observe the state of the memory either before the transaction T started, or after the transaction T completed, but not the intermediate states during the execution of T. </span><span class="koboSpan" id="kobo.24.4">This property is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">isolation</span></strong></span><span class="koboSpan" id="kobo.26.1">.</span></p><p><span class="koboSpan" id="kobo.27.1">As we will see, </span><span class="strong"><strong><span class="koboSpan" id="kobo.28.1">composability</span></strong></span><span class="koboSpan" id="kobo.29.1"> is another important advantage of using an STM. </span><span class="koboSpan" id="kobo.29.2">Consider a lock-based hash table implementation with thread-safe </span><code class="literal"><span class="koboSpan" id="kobo.30.1">insert</span></code><span class="koboSpan" id="kobo.31.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.32.1">remove</span></code><span class="koboSpan" id="kobo.33.1"> operations. </span><span class="koboSpan" id="kobo.33.2">While the individual </span><code class="literal"><span class="koboSpan" id="kobo.34.1">insert</span></code><span class="koboSpan" id="kobo.35.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.36.1">remove</span></code><span class="koboSpan" id="kobo.37.1"> operations can be safely invoked by different threads, it is impossible to implement a method that removes an element from one hash table and adds it to another hash table, without exposing the intermediate state in which the element is not present in either hash table. </span><span class="koboSpan" id="kobo.37.2">Traditionally, STM was proposed as a part of the programming language with the advantage that certain transaction limitations can be ensured at compile time. </span><span class="koboSpan" id="kobo.37.3">Since this approach requires intrusive changes to a language, many software transactional memories are implemented as libraries. </span><span class="koboSpan" id="kobo.37.4">ScalaSTM is one such example. </span><span class="koboSpan" id="kobo.37.5">We will use ScalaSTM as the concrete STM implementation. </span><span class="koboSpan" id="kobo.37.6">Concretely, we cover the following topics in this chapter:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.38.1">The disadvantages of atomic variables</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.39.1">The semantics and internals of STM</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.40.1">Transactional references</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.41.1">The interaction between transactions and external side effects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.42.1">Semantics of single operation transactions and nested transactions</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.43.1">Retrying transactions conditionally and timing out transactions</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.44.1">Transaction-local variables, transactional arrays, and transactional maps</span></li></ul></div><p><span class="koboSpan" id="kobo.45.1">We already learned in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.46.1">Chapter 3</span></a><span class="koboSpan" id="kobo.47.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.48.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.49.1">, that using atomic variables and concurrent collections allows expressing lock-free programs. </span><span class="koboSpan" id="kobo.49.2">Why not just use atomic variables to express concurrently shared data? </span><span class="koboSpan" id="kobo.49.3">To better emphasize the need for STM, we will start by presenting a situation in which atomic variables prove inadequate.</span></p><div class="section" title="The trouble with atomic variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/><span class="koboSpan" id="kobo.50.1">The trouble with atomic variables</span></h1></div></div></div><p><span class="koboSpan" id="kobo.51.1">Atomic variables from </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.52.1">Chapter 3</span></a><span class="koboSpan" id="kobo.53.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.54.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.55.1">, are one of the fundamental synchronization mechanisms. </span><span class="koboSpan" id="kobo.55.2">We already know that volatile variables, introduced in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.56.1">Chapter 2</span></a><span class="koboSpan" id="kobo.57.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.59.1">, allow race conditions, in which the program correctness is subject to the precise execution schedule of different threads. </span><span class="koboSpan" id="kobo.59.2">Atomic variables can ensure that no thread concurrently modifies the variable between a read and a write operation. </span><span class="koboSpan" id="kobo.59.3">At the same time, atomic variables reduce the risk of deadlocks. </span><span class="koboSpan" id="kobo.59.4">Regardless of their advantages, there are situations when using atomic variables is not satisfactory.</span></p><p><span class="koboSpan" id="kobo.60.1">In </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.61.1">Chapter 6</span></a><span class="koboSpan" id="kobo.62.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.63.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.64.1">, we implemented a minimalistic web browser using the </span><span class="strong"><strong><span class="koboSpan" id="kobo.65.1">Rx</span></strong></span><span class="koboSpan" id="kobo.66.1"> framework. </span><span class="koboSpan" id="kobo.66.2">Surfing around the Web is great, but we would like to have some additional features in our browser. </span><span class="koboSpan" id="kobo.66.3">For example, we would like to maintain the browser's history--the list of URLs that were previously visited. </span><span class="koboSpan" id="kobo.66.4">We decide to keep the list of URLs in the Scala </span><code class="literal"><span class="koboSpan" id="kobo.67.1">List[String]</span></code><span class="koboSpan" id="kobo.68.1"> collection. </span><span class="koboSpan" id="kobo.68.2">Additionally, we decide to track the total character length of all the URLs. </span><span class="koboSpan" id="kobo.68.3">If we want to copy the URL strings into an array, this information allows us to quickly allocate an array of an appropriate size.</span></p><p><span class="koboSpan" id="kobo.69.1">Different parts of our browser execute asynchronously, so we need to synchronize access to this mutable state. </span><span class="koboSpan" id="kobo.69.2">We can keep the list of URLs and their total character length in private mutable fields and use the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">synchronized</span></code><span class="koboSpan" id="kobo.71.1"> statement to access them. </span><span class="koboSpan" id="kobo.71.2">However, having seen the culprits of the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">synchronized</span></code><span class="koboSpan" id="kobo.73.1"> statement in earlier chapters, we decide to avoid locks. </span><span class="koboSpan" id="kobo.73.2">Instead, we will use atomic variables. </span><span class="koboSpan" id="kobo.73.3">We will store the list of URLs and their total character length in two atomic variables, that are </span><code class="literal"><span class="koboSpan" id="kobo.74.1">urls</span></code><span class="koboSpan" id="kobo.75.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.76.1">clen</span></code><span class="koboSpan" id="kobo.77.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.78.1">import java.util.concurrent.atomic._ 
val urls = new AtomicReference[List[String]](Nil) 
val clen = new AtomicInteger(0) 
</span></pre><p><span class="koboSpan" id="kobo.79.1">Whenever the browser opens URL, we need to update these atomic variables. </span><span class="koboSpan" id="kobo.79.2">To do this more easily, we define a helper method called </span><code class="literal"><span class="koboSpan" id="kobo.80.1">addUrl</span></code><span class="koboSpan" id="kobo.81.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.82.1">import scala.annotation.tailrec 
def addUrl(url: String): Unit = { 
  @tailrec def append(): Unit = { 
    val oldUrls = urls.get 
    val newUrls = url :: oldUrls 
    if (!urls.compareAndSet(oldUrls, newUrls)) append() 
  } 
  append() 
  clen.addAndGet(url.length + 1) 
} 
</span></pre><p><span class="koboSpan" id="kobo.83.1">As we learned in the introductory chapters, we need to use atomic operations on atomic variables to ensure that their values consistently change from one state to another. </span><span class="koboSpan" id="kobo.83.2">In the previous code snippet, we use the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">compareAndSet</span></code><span class="koboSpan" id="kobo.85.1"> operation to atomically replace the old list of URLs called </span><code class="literal"><span class="koboSpan" id="kobo.86.1">oldUrls</span></code><span class="koboSpan" id="kobo.87.1"> with the updated version </span><code class="literal"><span class="koboSpan" id="kobo.88.1">newUrls</span></code><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">As discussed at length in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.90.1">Chapter 3</span></a><span class="koboSpan" id="kobo.91.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.92.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.93.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">compareAndSet</span></code><span class="koboSpan" id="kobo.95.1"> operation can fail when two threads call it simultaneously on the same atomic variable. </span><span class="koboSpan" id="kobo.95.2">For this reason, we define a nested, tail-recursive method, </span><code class="literal"><span class="koboSpan" id="kobo.96.1">append</span></code><span class="koboSpan" id="kobo.97.1">, which calls the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">compareAndSet</span></code><span class="koboSpan" id="kobo.99.1"> method and restarts if the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">compareAndSet</span></code><span class="koboSpan" id="kobo.101.1"> method fails. </span><span class="koboSpan" id="kobo.101.2">Updating the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">clen</span></code><span class="koboSpan" id="kobo.103.1"> field is easier. </span><span class="koboSpan" id="kobo.103.2">We just call the atomic </span><code class="literal"><span class="koboSpan" id="kobo.104.1">addAndGet</span></code><span class="koboSpan" id="kobo.105.1"> method defined on atomic integers.</span></p><p><span class="koboSpan" id="kobo.106.1">Other parts of the web browser can use the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">urls</span></code><span class="koboSpan" id="kobo.108.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.109.1">clen</span></code><span class="koboSpan" id="kobo.110.1"> variables to render the browsing history, dump it to a </span><code class="literal"><span class="koboSpan" id="kobo.111.1">log</span></code><span class="koboSpan" id="kobo.112.1"> file or to export browser data, in case our users decide they like Firefox better. </span><span class="koboSpan" id="kobo.112.2">For convenience, we define a </span><code class="literal"><span class="koboSpan" id="kobo.113.1">getUrlArray</span></code><span class="koboSpan" id="kobo.114.1"> auxiliary method that returns a character array in which the URLs are separated with a newline character. </span><span class="koboSpan" id="kobo.114.2">The </span><code class="literal"><span class="koboSpan" id="kobo.115.1">clen</span></code><span class="koboSpan" id="kobo.116.1"> field is a quick way to get the required size of the array. </span><span class="koboSpan" id="kobo.116.2">We call the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">get</span></code><span class="koboSpan" id="kobo.118.1"> method to read the value of the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">clen</span></code><span class="koboSpan" id="kobo.120.1"> field and allocate the array. </span><span class="koboSpan" id="kobo.120.2">We then call </span><code class="literal"><span class="koboSpan" id="kobo.121.1">get</span></code><span class="koboSpan" id="kobo.122.1"> to read the current list of URLs, append the newline character to each URL, flatten the list of strings into a single list, zip the characters with their indices, and store them into the array:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.123.1">def getUrlArray(): Array[Char] = { 
  val array = new Array[Char](clen.get) 
  val urlList = urls.get 
  for ((ch, i) &lt;- urlList.map(_ + "\n").flatten.zipWithIndex) { 
    array(i) = ch 
  } 
  array 
} 
</span></pre><p><span class="koboSpan" id="kobo.124.1">To test these methods, we can simulate user interaction with two asynchronous computations. </span><span class="koboSpan" id="kobo.124.2">The first asynchronous computation calls the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">getUrlArray</span></code><span class="koboSpan" id="kobo.126.1"> method to dump the browsing history to a file. </span><span class="koboSpan" id="kobo.126.2">The second asynchronous computation visits three separate URLs by calling the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">addURL</span></code><span class="koboSpan" id="kobo.128.1"> method three times, and then prints the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">"done browsing"</span></code><span class="koboSpan" id="kobo.130.1"> string to the standard output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.131.1">import scala.concurrent._ 
import ExecutionContext.Implicits.global 
object AtomicHistoryBad extends App { 
  Future { 
    try { log(s"sending: ${getUrlArray().mkString}") } 
    catch { case e: Exception =&gt; log(s"Houston... </span><span class="koboSpan" id="kobo.131.2">$e!") } 
  } 
  Future { 
    addUrl("http://scala-lang.org") 
    addUrl("https://github.com/scala/scala") 
    addUrl("http://www.scala-lang.org/api") 
    log("done browsing") 
  } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.132.1">Running this program several times reveals a bug. </span><span class="koboSpan" id="kobo.132.2">The program sometimes mysteriously crashes with an </span><code class="literal"><span class="koboSpan" id="kobo.133.1">ArrayIndexOutOfBoundsException</span></code><span class="koboSpan" id="kobo.134.1"> exception. </span><span class="koboSpan" id="kobo.134.2">By analyzing the </span><code class="literal"><span class="koboSpan" id="kobo.135.1">getUrlArray</span></code><span class="koboSpan" id="kobo.136.1"> method, we find the cause to the bug. </span><span class="koboSpan" id="kobo.136.2">This bug occurs when the retrieved value of the </span><code class="literal"><span class="koboSpan" id="kobo.137.1">clen</span></code><span class="koboSpan" id="kobo.138.1"> field is not equal to the length of the list. </span><span class="koboSpan" id="kobo.138.2">The </span><code class="literal"><span class="koboSpan" id="kobo.139.1">getUrlArray</span></code><span class="koboSpan" id="kobo.140.1"> method first reads the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">clen</span></code><span class="koboSpan" id="kobo.142.1"> atomic variable, and later reads the list of the URLs from the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">urls</span></code><span class="koboSpan" id="kobo.144.1"> atomic variable. </span><span class="koboSpan" id="kobo.144.2">Between these two reads, the first thread modifies the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">urls</span></code><span class="koboSpan" id="kobo.146.1"> variable by adding an additional URL string. </span><span class="koboSpan" id="kobo.146.2">By the time </span><code class="literal"><span class="koboSpan" id="kobo.147.1">getUrlArray</span></code><span class="koboSpan" id="kobo.148.1"> reads the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">urls</span></code><span class="koboSpan" id="kobo.150.1"> variable, the total character length becomes longer than the allocated array, and we eventually get an exception.</span></p><p><span class="koboSpan" id="kobo.151.1">This example illustrates an important disadvantage of atomic variables. </span><span class="koboSpan" id="kobo.151.2">Although specific atomic operations are themselves atomic and occur at a single point in time, invoking multiple atomic operations is typically not atomic. </span><span class="koboSpan" id="kobo.151.3">When multiple threads simultaneously execute multiple atomic operations, the operations might interleave in unforeseen ways and lead to the same kind of race conditions that result from using volatile variables. </span><span class="koboSpan" id="kobo.151.4">Note that swapping the updates to the </span><code class="literal"><span class="koboSpan" id="kobo.152.1">clen</span></code><span class="koboSpan" id="kobo.153.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.154.1">urls</span></code><span class="koboSpan" id="kobo.155.1"> variables does not solve the problem. </span><span class="koboSpan" id="kobo.155.2">Although there are other ways to ensure atomicity in our example, they are not immediately obvious.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/><span class="koboSpan" id="kobo.156.1">Note</span></h3><p><span class="koboSpan" id="kobo.157.1">Reading multiple atomic variables is not an atomic operation and it can observe the program data in an inconsistent state.</span></p></div></div><p><span class="koboSpan" id="kobo.158.1">When all threads in the program observe that an operation occurs at the same, single point in time, we can say that the operation is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.159.1">linearizable</span></em></span><span class="koboSpan" id="kobo.160.1">. </span><span class="koboSpan" id="kobo.160.2">The point in time at which the operation occurs is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.161.1">linearization point</span></strong></span><span class="koboSpan" id="kobo.162.1">. </span><span class="koboSpan" id="kobo.162.2">The </span><code class="literal"><span class="koboSpan" id="kobo.163.1">compareAndSet</span></code><span class="koboSpan" id="kobo.164.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.165.1">addAndGet</span></code><span class="koboSpan" id="kobo.166.1"> operations are inherently linearizable operations. </span><span class="koboSpan" id="kobo.166.2">They execute atomically, usually as a single processor instruction and at a single point in time, from the perspective of all the threads. </span><span class="koboSpan" id="kobo.166.3">The </span><code class="literal"><span class="koboSpan" id="kobo.167.1">append</span></code><span class="koboSpan" id="kobo.168.1"> nested method in the previous example is also linearizable. </span><span class="koboSpan" id="kobo.168.2">Its linearization point is a successful </span><code class="literal"><span class="koboSpan" id="kobo.169.1">compareAndSet</span></code><span class="koboSpan" id="kobo.170.1"> operation, because that is the only place where </span><code class="literal"><span class="koboSpan" id="kobo.171.1">append</span></code><span class="koboSpan" id="kobo.172.1"> modifies the program state. </span><span class="koboSpan" id="kobo.172.2">On the other hand, the </span><code class="literal"><span class="koboSpan" id="kobo.173.1">addUrl</span></code><span class="koboSpan" id="kobo.174.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.175.1">getUrlArray</span></code><span class="koboSpan" id="kobo.176.1"> methods are not linearizable. </span><span class="koboSpan" id="kobo.176.2">They contain no single atomic operation that modifies or reads the state of the program. </span><span class="koboSpan" id="kobo.176.3">The </span><code class="literal"><span class="koboSpan" id="kobo.177.1">addUrl</span></code><span class="koboSpan" id="kobo.178.1"> method modifies the program state twice. </span><span class="koboSpan" id="kobo.178.2">First, it calls the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">append</span></code><span class="koboSpan" id="kobo.180.1"> method and then it calls the </span><code class="literal"><span class="koboSpan" id="kobo.181.1">addAndGet</span></code><span class="koboSpan" id="kobo.182.1"> method. </span><span class="koboSpan" id="kobo.182.2">Similarly, the </span><code class="literal"><span class="koboSpan" id="kobo.183.1">getUrlArray</span></code><span class="koboSpan" id="kobo.184.1"> method reads the program state with two separate atomic </span><code class="literal"><span class="koboSpan" id="kobo.185.1">get</span></code><span class="koboSpan" id="kobo.186.1"> operations. </span><span class="koboSpan" id="kobo.186.2">This is a commonly misunderstood point when using atomic variables, and we say that atomic variables do not compose into larger programs.</span></p><p><span class="koboSpan" id="kobo.187.1">We can fix our example by removing the </span><code class="literal"><span class="koboSpan" id="kobo.188.1">clen</span></code><span class="koboSpan" id="kobo.189.1"> atomic variable, and computing the required array length after reading the </span><code class="literal"><span class="koboSpan" id="kobo.190.1">urls</span></code><span class="koboSpan" id="kobo.191.1"> variable once. </span><span class="koboSpan" id="kobo.191.2">Similarly, we can use a single atomic reference to store a tuple with the URL list and the size of that list. </span><span class="koboSpan" id="kobo.191.3">Both approaches would make the </span><code class="literal"><span class="koboSpan" id="kobo.192.1">addUrl</span></code><span class="koboSpan" id="kobo.193.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.194.1">getUrlArray</span></code><span class="koboSpan" id="kobo.195.1"> methods linearizable.</span></p><p><span class="koboSpan" id="kobo.196.1">Concurrent programming experts have proven that it is possible to express any program state using atomic variables, and arbitrarily modify this state with linearizable operations. </span><span class="koboSpan" id="kobo.196.2">In practice, implementing such linearizable operations efficiently can be quite challenging. </span><span class="koboSpan" id="kobo.196.3">It is generally hard to implement arbitrary linearizable operations correctly, and it is even harder to implement them efficiently.</span></p><p><span class="koboSpan" id="kobo.197.1">Unlike atomic variables, multiple </span><code class="literal"><span class="koboSpan" id="kobo.198.1">synchronized</span></code><span class="koboSpan" id="kobo.199.1"> statements can be used together more easily. </span><span class="koboSpan" id="kobo.199.2">We can modify multiple fields of an object when we use the </span><code class="literal"><span class="koboSpan" id="kobo.200.1">synchronized</span></code><span class="koboSpan" id="kobo.201.1"> statement, and we can even nest multiple </span><code class="literal"><span class="koboSpan" id="kobo.202.1">synchronized</span></code><span class="koboSpan" id="kobo.203.1"> statements. </span><span class="koboSpan" id="kobo.203.2">We are thus left with a dilemma. </span><span class="koboSpan" id="kobo.203.3">We can use atomic variables and risk race conditions when composing larger programs, or we can revert to using the </span><code class="literal"><span class="koboSpan" id="kobo.204.1">synchronized</span></code><span class="koboSpan" id="kobo.205.1"> statement, but risk deadlocks. </span><span class="koboSpan" id="kobo.205.2">Luckily, STM is a technology that offers the best of both worlds; it allows you to compose simple atomic operations into more complex atomic operations, without the risk of deadlocks.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using Software Transactional Memory"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/><span class="koboSpan" id="kobo.1.1">Using Software Transactional Memory</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this section, we will study the basics of using STM. </span><span class="koboSpan" id="kobo.2.2">Historically, multiple STM implementations were introduced for Scala and the JVM platform. </span><span class="koboSpan" id="kobo.2.3">The particular STM implementation described in this chapter is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">ScalaSTM</span></strong></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">There are two reasons that ScalaSTM is our STM of choice. </span><span class="koboSpan" id="kobo.4.3">First, ScalaSTM was authored by a group of STM experts who agreed on a standardized set of APIs and features. </span><span class="koboSpan" id="kobo.4.4">Future STM implementations for Scala are strongly encouraged to implement these APIs. </span><span class="koboSpan" id="kobo.4.5">Second, the ScalaSTM API is designed for multiple STM implementations, and comes with an efficient default implementation. </span><span class="koboSpan" id="kobo.4.6">Different STM implementations can be chosen when the program starts. </span><span class="koboSpan" id="kobo.4.7">Users can write applications using a standardized API, and seamlessly switch to a different STM implementation later.</span></p><p><span class="koboSpan" id="kobo.5.1">The </span><code class="literal"><span class="koboSpan" id="kobo.6.1">atomic</span></code><span class="koboSpan" id="kobo.7.1"> statement is a fundamental abstraction at the core of every STM. </span><span class="koboSpan" id="kobo.7.2">When the program executes a block of code marked with the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">atomic</span></code><span class="koboSpan" id="kobo.9.1"> symbol, it starts a memory transaction, a sequence of reads and writes operations to memory that occur atomically for other threads in the program. </span><span class="koboSpan" id="kobo.9.2">The </span><code class="literal"><span class="koboSpan" id="kobo.10.1">atomic</span></code><span class="koboSpan" id="kobo.11.1"> statement is similar to the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">synchronized</span></code><span class="koboSpan" id="kobo.13.1"> statement, and ensures that a block of code executes in isolation, without the interference of other threads, thus avoiding race conditions. </span><span class="koboSpan" id="kobo.13.2">Unlike the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">synchronized</span></code><span class="koboSpan" id="kobo.15.1"> statement, the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">atomic</span></code><span class="koboSpan" id="kobo.17.1"> statement does not cause deadlocks.</span></p><p><span class="koboSpan" id="kobo.18.1">The following methods, </span><code class="literal"><span class="koboSpan" id="kobo.19.1">swap</span></code><span class="koboSpan" id="kobo.20.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.21.1">inc</span></code><span class="koboSpan" id="kobo.22.1">, show how to use the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">atomic</span></code><span class="koboSpan" id="kobo.24.1"> statement on a high level. </span><span class="koboSpan" id="kobo.24.2">The </span><code class="literal"><span class="koboSpan" id="kobo.25.1">swap</span></code><span class="koboSpan" id="kobo.26.1"> method atomically exchanges the contents of two memory locations, </span><code class="literal"><span class="koboSpan" id="kobo.27.1">a</span></code><span class="koboSpan" id="kobo.28.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.29.1">b</span></code><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">Between the time that a thread reads the memory location </span><code class="literal"><span class="koboSpan" id="kobo.31.1">a</span></code><span class="koboSpan" id="kobo.32.1"> (or </span><code class="literal"><span class="koboSpan" id="kobo.33.1">b</span></code><span class="koboSpan" id="kobo.34.1">) and the time that the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">atomic</span></code><span class="koboSpan" id="kobo.36.1"> statement ends, no other thread can effectively modify the value at location </span><code class="literal"><span class="koboSpan" id="kobo.37.1">a</span></code><span class="koboSpan" id="kobo.38.1"> (or </span><code class="literal"><span class="koboSpan" id="kobo.39.1">b</span></code><span class="koboSpan" id="kobo.40.1">). </span><span class="koboSpan" id="kobo.40.2">Similarly, the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">inc</span></code><span class="koboSpan" id="kobo.42.1"> method atomically increments the integer value at the memory location </span><code class="literal"><span class="koboSpan" id="kobo.43.1">a</span></code><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">When a thread, which calls the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">inc</span></code><span class="koboSpan" id="kobo.46.1"> method, reads the value of </span><code class="literal"><span class="koboSpan" id="kobo.47.1">a</span></code><span class="koboSpan" id="kobo.48.1"> in the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">atomic</span></code><span class="koboSpan" id="kobo.50.1"> statement, no other thread can change the value of the memory location </span><code class="literal"><span class="koboSpan" id="kobo.51.1">a</span></code><span class="koboSpan" id="kobo.52.1"> until the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">atomic</span></code><span class="koboSpan" id="kobo.54.1"> statement ends:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.55.1">def swap() = atomic { // not actual code 
  val tmp = a 
  a = b 
  b = tmp 
} 
def inc() = atomic { a = a + 1 } 
</span></pre><p><span class="koboSpan" id="kobo.56.1">The ways in which an STM implements deadlock-freedom and ensures that no two threads simultaneously modify the same memory locations are quite complex. </span><span class="koboSpan" id="kobo.56.2">In most STM implementations, the </span><code class="literal"><span class="koboSpan" id="kobo.57.1">atomic</span></code><span class="koboSpan" id="kobo.58.1"> statement maintains a log of read and write operations. </span><span class="koboSpan" id="kobo.58.2">Every time a memory location is read during a memory transaction, the corresponding memory address is added to the log. </span><span class="koboSpan" id="kobo.58.3">Similarly, whenever a memory location is written during a memory transaction, the memory address and the proposed value are written to the log. </span><span class="koboSpan" id="kobo.58.4">Once the execution reaches the end of the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">atomic</span></code><span class="koboSpan" id="kobo.60.1"> block, all the writes from the transaction log are written to the memory. </span><span class="koboSpan" id="kobo.60.2">When this happens, we say that the transaction is committed. </span><span class="koboSpan" id="kobo.60.3">On the other hand, during the transaction, the STM might detect that another concurrent transaction performed by some other thread is concurrently reading or writing the same memory location. </span><span class="koboSpan" id="kobo.60.4">This situation is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.61.1">transactional conflict</span></strong></span><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">When a transactional conflict occurs, one or both of the transactions are cancelled, and re-executed serially, one after another. </span><span class="koboSpan" id="kobo.62.3">We say that the STM </span><span class="emphasis"><em><span class="koboSpan" id="kobo.63.1">rolls back</span></em></span><span class="koboSpan" id="kobo.64.1"> these transactions. </span><span class="koboSpan" id="kobo.64.2">Such STMs are called </span><span class="strong"><strong><span class="koboSpan" id="kobo.65.1">optimistic</span></strong></span><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">Optimistic STMs try to execute a transaction under the assumption that it will succeed, and roll back when they detect a conflict. </span><span class="koboSpan" id="kobo.66.3">When we say that a transaction is completed, we mean that it was either committed or rolled back, and re-executed.</span></p><p><span class="koboSpan" id="kobo.67.1">To illustrate how a memory transaction works, we consider the scenario in which two threads, </span><span class="strong"><strong><span class="koboSpan" id="kobo.68.1">T1</span></strong></span><span class="koboSpan" id="kobo.69.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.70.1">T2</span></strong></span><span class="koboSpan" id="kobo.71.1">, simultaneously call the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">swap</span></code><span class="koboSpan" id="kobo.73.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.74.1">inc</span></code><span class="koboSpan" id="kobo.75.1"> methods. </span><span class="koboSpan" id="kobo.75.2">Since both the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">atomic</span></code><span class="koboSpan" id="kobo.77.1"> statements in these methods modify the memory location </span><code class="literal"><span class="koboSpan" id="kobo.78.1">a</span></code><span class="koboSpan" id="kobo.79.1">, the execution results in a runtime transactional conflict. </span><span class="koboSpan" id="kobo.79.2">During the execution of the program, the STM detects that the entries in the transactional logs overlap: the transaction associated with the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">swap</span></code><span class="koboSpan" id="kobo.81.1"> method has both memory locations </span><code class="literal"><span class="koboSpan" id="kobo.82.1">a</span></code><span class="koboSpan" id="kobo.83.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.84.1">b</span></code><span class="koboSpan" id="kobo.85.1"> in its read and write sets, while the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">inc</span></code><span class="koboSpan" id="kobo.87.1"> method has </span><code class="literal"><span class="koboSpan" id="kobo.88.1">a</span></code><span class="koboSpan" id="kobo.89.1"> in its read and write sets. </span><span class="koboSpan" id="kobo.89.2">This indicates a potential conflict. </span><span class="koboSpan" id="kobo.89.3">Both the transactions can be rolled back, and then executed serially one after another, as shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.90.1"><img src="graphics/image_07_001.jpg" alt="Using Software Transactional Memory"/></span></div><p><span class="koboSpan" id="kobo.91.1">We will not delve more deeply into the internals of the ScalaSTM implementation, as this is beyond the scope of this book. </span><span class="koboSpan" id="kobo.91.2">Instead, we will focus on how to use ScalaSTM to easily write concurrent applications. </span><span class="koboSpan" id="kobo.91.3">Where reasonable, we hint at some implementation details to better understand the reasons behind the ScalaSTM semantics.</span></p><p><span class="koboSpan" id="kobo.92.1">In some STMs, the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">atomic</span></code><span class="koboSpan" id="kobo.94.1"> statement tracks all the reads and writes to the memory. </span><span class="koboSpan" id="kobo.94.2">ScalaSTM only tracks specially marked memory locations within transactions. </span><span class="koboSpan" id="kobo.94.3">There are several reasons for this. </span><span class="koboSpan" id="kobo.94.4">First, an STM cannot ensure safety if some parts of the program access memory locations outside the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">atomic</span></code><span class="koboSpan" id="kobo.96.1"> statements, while other parts access the same memory locations inside the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">atomic</span></code><span class="koboSpan" id="kobo.98.1"> statements. </span><span class="koboSpan" id="kobo.98.2">ScalaSTM avoids accidental uses outside transactions by explicitly marking the memory locations that can only be used in transactions. </span><span class="koboSpan" id="kobo.98.3">Second, STM frameworks for the JVM need to use post-compilation or bytecode introspection in order to accurately capture all the reads and writes. </span><span class="koboSpan" id="kobo.98.4">ScalaSTM is a library-only STM implementation, so it cannot analyze and transform the program in the same way a compiler can.</span></p><p><span class="koboSpan" id="kobo.99.1">In ScalaSTM, the effects of the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">atomic</span></code><span class="koboSpan" id="kobo.101.1"> statement are limited to special objects called </span><span class="strong"><strong><span class="koboSpan" id="kobo.102.1">transactional references</span></strong></span><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">Before showing how to use the </span><code class="literal"><span class="koboSpan" id="kobo.104.1">atomic</span></code><span class="koboSpan" id="kobo.105.1"> statement to perform memory transactions, we will study how to create transactional references.</span></p><div class="section" title="Transactional references"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec61"/><span class="koboSpan" id="kobo.106.1">Transactional references</span></h2></div></div></div><p><span class="koboSpan" id="kobo.107.1">In this section, we will study how to declare transactional references. </span><span class="koboSpan" id="kobo.107.2">A transactional reference is a memory location that provides transactional read and write access to a single memory location. </span><span class="koboSpan" id="kobo.107.3">In ScalaSTM, transactional references to the values of type </span><code class="literal"><span class="koboSpan" id="kobo.108.1">T</span></code><span class="koboSpan" id="kobo.109.1"> are encapsulated within the objects of the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">Red[T]</span></code><span class="koboSpan" id="kobo.111.1"> type:</span></p><p><span class="koboSpan" id="kobo.112.1">Before we begin using STM in Scala, we need to add an external dependency to our project, since ScalaSTM is not a part of the Scala standard library:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.113.1">libraryDependencies += "org.scala-stm" %% "scala-stm" % "0.7" 
</span></pre><p><span class="koboSpan" id="kobo.114.1">To use the ScalaSTM </span><code class="literal"><span class="koboSpan" id="kobo.115.1">atomic</span></code><span class="koboSpan" id="kobo.116.1"> statement in a compilation unit, we import the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">scala.concurrent.stm</span></code><span class="koboSpan" id="kobo.118.1"> package:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.119.1">import scala.concurrent.stm._ 
</span></pre><p><span class="koboSpan" id="kobo.120.1">To instantiate a </span><code class="literal"><span class="koboSpan" id="kobo.121.1">Ref</span></code><span class="koboSpan" id="kobo.122.1"> object, we use the </span><code class="literal"><span class="koboSpan" id="kobo.123.1">Ref.apply</span></code><span class="koboSpan" id="kobo.124.1"> factory method on the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">Ref</span></code><span class="koboSpan" id="kobo.126.1"> companion object. </span><span class="koboSpan" id="kobo.126.2">Let's rewrite our browser history example using transactional memory. </span><span class="koboSpan" id="kobo.126.3">We start by replacing atomic variables with transactional references. </span><span class="koboSpan" id="kobo.126.4">We pass the initial value of each transactional reference to the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">Ref.apply</span></code><span class="koboSpan" id="kobo.128.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.129.1">val urls = Ref[List[String]](Nil) 
val clen = Ref(0) 
</span></pre><p><span class="koboSpan" id="kobo.130.1">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">apply</span></code><span class="koboSpan" id="kobo.132.1"> method on a transactional reference returns its value, and calling the </span><code class="literal"><span class="koboSpan" id="kobo.133.1">update</span></code><span class="koboSpan" id="kobo.134.1"> method modifies it. </span><span class="koboSpan" id="kobo.134.2">However, we cannot call these methods from outside of a transaction. </span><span class="koboSpan" id="kobo.134.3">The </span><code class="literal"><span class="koboSpan" id="kobo.135.1">apply</span></code><span class="koboSpan" id="kobo.136.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.137.1">update</span></code><span class="koboSpan" id="kobo.138.1"> methods take an implicit argument of type </span><code class="literal"><span class="koboSpan" id="kobo.139.1">InTxn</span></code><span class="koboSpan" id="kobo.140.1"> (which stands for </span><span class="emphasis"><em><span class="koboSpan" id="kobo.141.1">in transaction</span></em></span><span class="koboSpan" id="kobo.142.1">), which designates that a transaction is under way. </span><span class="koboSpan" id="kobo.142.2">Without the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">InTxn</span></code><span class="koboSpan" id="kobo.144.1"> object, we cannot call the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">apply</span></code><span class="koboSpan" id="kobo.146.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.147.1">update</span></code><span class="koboSpan" id="kobo.148.1"> methods. </span><span class="koboSpan" id="kobo.148.2">This constraint protects us from accidentally circumventing the ScalaSTM safety mechanisms.</span></p><p><span class="koboSpan" id="kobo.149.1">To read and modify transactional references, we must first start a transaction that provides the implicit </span><code class="literal"><span class="koboSpan" id="kobo.150.1">InTxn</span></code><span class="koboSpan" id="kobo.151.1"> object. </span><span class="koboSpan" id="kobo.151.2">We will study how to do this next.</span></p></div><div class="section" title="Using the atomic statement"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec62"/><span class="koboSpan" id="kobo.152.1">Using the atomic statement</span></h2></div></div></div><p><span class="koboSpan" id="kobo.153.1">After redefining the </span><code class="literal"><span class="koboSpan" id="kobo.154.1">urls</span></code><span class="koboSpan" id="kobo.155.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.156.1">clen</span></code><span class="koboSpan" id="kobo.157.1"> variables as transactional references, we redefine the </span><code class="literal"><span class="koboSpan" id="kobo.158.1">addUrl</span></code><span class="koboSpan" id="kobo.159.1"> method. </span><span class="koboSpan" id="kobo.159.2">Instead of separately updating two atomic variables, we start a memory transaction with the </span><code class="literal"><span class="koboSpan" id="kobo.160.1">atomic</span></code><span class="koboSpan" id="kobo.161.1"> statement. </span><span class="koboSpan" id="kobo.161.2">In ScalaSTM, the </span><code class="literal"><span class="koboSpan" id="kobo.162.1">atomic</span></code><span class="koboSpan" id="kobo.163.1"> statement takes a block of type </span><code class="literal"><span class="koboSpan" id="kobo.164.1">InTxn =&gt; T</span></code><span class="koboSpan" id="kobo.165.1">, where </span><code class="literal"><span class="koboSpan" id="kobo.166.1">InTxn</span></code><span class="koboSpan" id="kobo.167.1"> is the type of the previously mentioned transaction object, and </span><code class="literal"><span class="koboSpan" id="kobo.168.1">T</span></code><span class="koboSpan" id="kobo.169.1"> is the type of the return value of the transaction. </span><span class="koboSpan" id="kobo.169.2">Note that we can annotate the </span><code class="literal"><span class="koboSpan" id="kobo.170.1">InTxn</span></code><span class="koboSpan" id="kobo.171.1"> parameter with the </span><code class="literal"><span class="koboSpan" id="kobo.172.1">implicit</span></code><span class="koboSpan" id="kobo.173.1"> keyword:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.174.1">def addUrl(url: String): Unit = atomic { implicit txn =&gt; 
  urls() = url :: urls() 
  clen() = clen() + url.length + 1 
} 
</span></pre><p><span class="koboSpan" id="kobo.175.1">The new definition of </span><code class="literal"><span class="koboSpan" id="kobo.176.1">addUrl</span></code><span class="koboSpan" id="kobo.177.1"> is surprisingly simple. </span><span class="koboSpan" id="kobo.177.2">It first reads the value of the </span><code class="literal"><span class="koboSpan" id="kobo.178.1">urls</span></code><span class="koboSpan" id="kobo.179.1"> list, prepends a new URL to the list, and assigns the updated list back to the </span><code class="literal"><span class="koboSpan" id="kobo.180.1">urls</span></code><span class="koboSpan" id="kobo.181.1"> variable. </span><span class="koboSpan" id="kobo.181.2">Then, it reads the current value of the total character length </span><code class="literal"><span class="koboSpan" id="kobo.182.1">clen</span></code><span class="koboSpan" id="kobo.183.1">, increments it by the length of the new URL, and assigns the new value back to </span><code class="literal"><span class="koboSpan" id="kobo.184.1">clen</span></code><span class="koboSpan" id="kobo.185.1">. </span><span class="koboSpan" id="kobo.185.2">Note that the new definition of the </span><code class="literal"><span class="koboSpan" id="kobo.186.1">addUrl</span></code><span class="koboSpan" id="kobo.187.1"> method looks almost identical to a single-threaded implementation.</span></p><p><span class="koboSpan" id="kobo.188.1">An important limitation of the </span><code class="literal"><span class="koboSpan" id="kobo.189.1">atomic</span></code><span class="koboSpan" id="kobo.190.1"> statement in ScalaSTM is that it does not track reads and writes to ordinary local variables and object fields. </span><span class="koboSpan" id="kobo.190.2">As we will see later, these are considered as arbitrary side effects, and are not allowed inside the transaction.</span></p><p><span class="koboSpan" id="kobo.191.1">We reimplement the </span><code class="literal"><span class="koboSpan" id="kobo.192.1">getUrlArray</span></code><span class="koboSpan" id="kobo.193.1"> method in a similar fashion. </span><span class="koboSpan" id="kobo.193.2">We start by creating a transaction with the </span><code class="literal"><span class="koboSpan" id="kobo.194.1">atomic</span></code><span class="koboSpan" id="kobo.195.1"> statement. </span><span class="koboSpan" id="kobo.195.2">The value of the </span><code class="literal"><span class="koboSpan" id="kobo.196.1">clen</span></code><span class="koboSpan" id="kobo.197.1"> variable is used in order to allocate a character array of an appropriate size. </span><span class="koboSpan" id="kobo.197.2">We then read the </span><code class="literal"><span class="koboSpan" id="kobo.198.1">urls</span></code><span class="koboSpan" id="kobo.199.1"> list and assign its characters to the array in a </span><code class="literal"><span class="koboSpan" id="kobo.200.1">for</span></code><span class="koboSpan" id="kobo.201.1"> loop. </span><span class="koboSpan" id="kobo.201.2">Again, the implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">getUrlArray</span></code><span class="koboSpan" id="kobo.203.1"> method looks surprisingly similar to the corresponding single-threaded implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.204.1">def getUrlArray(): Array[Char] = atomic { implicit txn =&gt; 
  val array = new Array[Char](clen()) 
  for ((ch, i) &lt;- urls().map(_ + "\n").flatten.zipWithIndex) { 
    array(i) = ch 
  } 
  array 
} 
</span></pre><p><span class="koboSpan" id="kobo.205.1">This time, there is no danger of seeing inconsistent values of the </span><code class="literal"><span class="koboSpan" id="kobo.206.1">clen</span></code><span class="koboSpan" id="kobo.207.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.208.1">urls</span></code><span class="koboSpan" id="kobo.209.1"> variables. </span><span class="koboSpan" id="kobo.209.2">When used in a transaction, the two values are always consistent with each other, as shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.210.1">object AtomicHistorySTM extends App { 
  Future { 
    addUrl("http://scala-lang.org") 
    addUrl("https://github.com/scala/scala") 
    addUrl("http://www.scala-lang.org/api") 
    log("done browsing") 
  } 
  Thread.sleep(25) 
  Future { 
    try { log(s"sending: ${getUrlArray().mkString}") } 
    catch { case e: Exception =&gt; log(s"Ayayay... </span><span class="koboSpan" id="kobo.210.2">$e") } 
  } 
  Thread.sleep(5000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.211.1">Note that we added the </span><code class="literal"><span class="koboSpan" id="kobo.212.1">sleep</span></code><span class="koboSpan" id="kobo.213.1"> statement in the main program, as this sets the timing of the two asynchronous computations to occur approximately at the same time. </span><span class="koboSpan" id="kobo.213.2">You can tweak the duration of the </span><code class="literal"><span class="koboSpan" id="kobo.214.1">sleep</span></code><span class="koboSpan" id="kobo.215.1"> statement in order to observe the various interleavings of the two asynchronous computations. </span><span class="koboSpan" id="kobo.215.2">Convince yourself with the fact that dumping the browsing history to the </span><code class="literal"><span class="koboSpan" id="kobo.216.1">log</span></code><span class="koboSpan" id="kobo.217.1"> file always observes some prefix of the three </span><code class="literal"><span class="koboSpan" id="kobo.218.1">addUrl</span></code><span class="koboSpan" id="kobo.219.1"> calls, and does not throw an exception.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip73"/><span class="koboSpan" id="kobo.220.1">Tip</span></h3><p><span class="koboSpan" id="kobo.221.1">When encoding a complex program state, use multiple transactional references. </span><span class="koboSpan" id="kobo.221.2">To atomically perform multiple changes on the program state, use the </span><code class="literal"><span class="koboSpan" id="kobo.222.1">atomic</span></code><span class="koboSpan" id="kobo.223.1"> statement.</span></p></div></div><p><span class="koboSpan" id="kobo.224.1">Having seen basic way of using the </span><code class="literal"><span class="koboSpan" id="kobo.225.1">atomic</span></code><span class="koboSpan" id="kobo.226.1"> statement with transactional references, we will proceed to show more advanced examples and study the STM semantics in more detail.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Composing transactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/><span class="koboSpan" id="kobo.1.1">Composing transactions</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">When used correctly, transactional memory is a powerful tool for building concurrent applications that modify shared data. </span><span class="koboSpan" id="kobo.2.2">Nevertheless, no technology is a silver bullet, and neither is STM. </span><span class="koboSpan" id="kobo.2.3">In this section, we will study how to compose transactions in larger programs and learn how transactional memory interacts with other features of Scala. </span><span class="koboSpan" id="kobo.2.4">We investigate some of the caveats of STM, and go beyond transactional references and the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">atomic</span></code><span class="koboSpan" id="kobo.4.1"> statement blocks to show how to use STM more effectively.</span></p><div class="section" title="The interaction between transactions and side effects"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec63"/><span class="koboSpan" id="kobo.5.1">The interaction between transactions and side effects</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">Previously, we learned that an STM may roll back and retry a transaction. </span><span class="koboSpan" id="kobo.6.2">An attentive reader might notice that retrying a transaction means re-executing its side effects. </span><span class="koboSpan" id="kobo.6.3">Here, the side effects are arbitrary reads and writes to regular </span><code class="literal"><span class="koboSpan" id="kobo.7.1">object</span></code><span class="koboSpan" id="kobo.8.1"> fields and variables.</span></p><p><span class="koboSpan" id="kobo.9.1">Sometimes, side effects are not a problem. </span><span class="koboSpan" id="kobo.9.2">Transactional references cannot be modified outside a transaction, and inside a transaction their modifications are aborted when retrying. </span><span class="koboSpan" id="kobo.9.3">Still, the other kinds of side effect are not rolled back. </span><span class="koboSpan" id="kobo.9.4">Consider the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">object CompositionSideEffects extends App {` 
  val myValue = Ref(0) 
  def inc() = atomic { implicit txn =&gt; 
    log(s"Incrementing ${myValue()}") 
    myValue() = myValue() + 1 
  } 
  Future { inc() } 
  Future { inc() } 
  Thread.sleep(5000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.11.1">The preceding program declares a </span><code class="literal"><span class="koboSpan" id="kobo.12.1">myValue</span></code><span class="koboSpan" id="kobo.13.1"> transactional reference, and an </span><code class="literal"><span class="koboSpan" id="kobo.14.1">inc</span></code><span class="koboSpan" id="kobo.15.1"> method that increments </span><code class="literal"><span class="koboSpan" id="kobo.16.1">myValue</span></code><span class="koboSpan" id="kobo.17.1"> inside an </span><code class="literal"><span class="koboSpan" id="kobo.18.1">atomic</span></code><span class="koboSpan" id="kobo.19.1"> block. </span><span class="koboSpan" id="kobo.19.2">The </span><code class="literal"><span class="koboSpan" id="kobo.20.1">inc</span></code><span class="koboSpan" id="kobo.21.1"> method also contains a </span><code class="literal"><span class="koboSpan" id="kobo.22.1">log</span></code><span class="koboSpan" id="kobo.23.1"> statement which prints the current value of the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">myValue</span></code><span class="koboSpan" id="kobo.25.1"> reference. </span><span class="koboSpan" id="kobo.25.2">The program asynchronously calls the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">inc</span></code><span class="koboSpan" id="kobo.27.1"> method twice. </span><span class="koboSpan" id="kobo.27.2">Upon executing this program, we get the following output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">ForkJoinPool-1-worker-1: Incrementing 0 
ForkJoinPool-1-worker-3: Incrementing 0 
ForkJoinPool-1-worker-3: Incrementing 1 
</span></pre><p><span class="koboSpan" id="kobo.29.1">The two asynchronous computations call the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">inc</span></code><span class="koboSpan" id="kobo.31.1"> method at the same time, and both start a transaction. </span><span class="koboSpan" id="kobo.31.2">One of the transactions adds the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">myValue</span></code><span class="koboSpan" id="kobo.33.1"> reference to its read set, calls the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">log</span></code><span class="koboSpan" id="kobo.35.1"> statement with the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">0</span></code><span class="koboSpan" id="kobo.37.1"> value, and proceeds to increment the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">myValue</span></code><span class="koboSpan" id="kobo.39.1"> reference by adding the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">myValue</span></code><span class="koboSpan" id="kobo.41.1"> reference to its write set. </span><span class="koboSpan" id="kobo.41.2">In the meantime, the other transaction first logs the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">0</span></code><span class="koboSpan" id="kobo.43.1"> value, then attempts to read </span><code class="literal"><span class="koboSpan" id="kobo.44.1">myValue</span></code><span class="koboSpan" id="kobo.45.1"> again, and detects that </span><code class="literal"><span class="koboSpan" id="kobo.46.1">myValue</span></code><span class="koboSpan" id="kobo.47.1"> is in a write set of another active transaction. </span><span class="koboSpan" id="kobo.47.2">The second transaction is rolled back, and retried after the first transaction commits. </span><span class="koboSpan" id="kobo.47.3">The second transaction reads the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">myValue</span></code><span class="koboSpan" id="kobo.49.1"> reference once more, prints </span><code class="literal"><span class="koboSpan" id="kobo.50.1">1</span></code><span class="koboSpan" id="kobo.51.1">, and then increments </span><code class="literal"><span class="koboSpan" id="kobo.52.1">myValue</span></code><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">The two transactions commit, but the side-effecting </span><code class="literal"><span class="koboSpan" id="kobo.54.1">log</span></code><span class="koboSpan" id="kobo.55.1"> call is executed three times as a result of the rollback.</span></p><p><span class="koboSpan" id="kobo.56.1">It might not be harmful to execute a simple </span><code class="literal"><span class="koboSpan" id="kobo.57.1">log</span></code><span class="koboSpan" id="kobo.58.1"> statement multiple times, but repeating arbitrary side effects can easily break the correctness of a program. </span><span class="koboSpan" id="kobo.58.2">Avoiding side effects in transactions is a recommended practice.</span></p><p><span class="koboSpan" id="kobo.59.1">Recall that an operation is idempotent if executing it multiple times has the same effect as executing it once, as discussed in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.60.1">Chapter 6</span></a><span class="koboSpan" id="kobo.61.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.62.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">You might conclude that, if a side-effecting operation is idempotent, then it is safe to execute it in a transaction. </span><span class="koboSpan" id="kobo.63.3">After all, the worst thing that can happen is that the idempotent operation gets executed more than once, right? </span><span class="koboSpan" id="kobo.63.4">Unfortunately, this reasoning is flawed. </span><span class="koboSpan" id="kobo.63.5">After a transaction is rolled back and retried, the values of the transactional references might change. </span><span class="koboSpan" id="kobo.63.6">The second time a transaction is executed, the arguments to the idempotent operation might be different, or the idempotent operation might not be invoked at all. </span><span class="koboSpan" id="kobo.63.7">The safest way to avoid such situations is to avoid external side effects altogether.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip74"/><span class="koboSpan" id="kobo.64.1">Tip</span></h3><p><span class="koboSpan" id="kobo.65.1">Avoid external side effects inside the transactions, as transactions can be re-executed multiple times.</span></p></div></div><p><span class="koboSpan" id="kobo.66.1">In practice, we usually want to execute a side effect only if the transaction commits, that is, after we are sure that the changes to the transactional references are visible to other threads. </span><span class="koboSpan" id="kobo.66.2">To do this, we use the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">Txn</span></code><span class="koboSpan" id="kobo.68.1"> singleton object, which can schedule multiple operations that execute after the transaction commits or rolls back.</span></p><p><span class="koboSpan" id="kobo.69.1">After a rollback, these operations are removed, and potentially re-registered when retrying the transaction. </span><span class="koboSpan" id="kobo.69.2">Its methods can only be called from inside an active transaction. </span><span class="koboSpan" id="kobo.69.3">In the following code, we rewrite the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">inc</span></code><span class="koboSpan" id="kobo.71.1"> method to call the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">Txn</span></code><span class="koboSpan" id="kobo.73.1"> object's </span><code class="literal"><span class="koboSpan" id="kobo.74.1">afterCommit</span></code><span class="koboSpan" id="kobo.75.1"> method, and schedule the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">log</span></code><span class="koboSpan" id="kobo.77.1"> statement to execute after the transaction commits:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.78.1">def inc() = atomic { implicit txn =&gt; 
  val valueAtStart = myValue() 
  Txn.afterCommit { _ =&gt; 
    log(s"Incrementing $valueAtStart") 
  } 
  myValue() = myValue() + 1 
} 
</span></pre><p><span class="koboSpan" id="kobo.79.1">Note that we read the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">myValue</span></code><span class="koboSpan" id="kobo.81.1"> reference inside the transaction and assign the value to a local variable </span><code class="literal"><span class="koboSpan" id="kobo.82.1">valueAtStart</span></code><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">The value of the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">valueAtStart</span></code><span class="koboSpan" id="kobo.85.1"> local variable is later printed to the standard output. </span><span class="koboSpan" id="kobo.85.2">This is different from reading the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">myValue</span></code><span class="koboSpan" id="kobo.87.1"> reference inside the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">afterCommit</span></code><span class="koboSpan" id="kobo.89.1"> block:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">def inc() = atomic { implicit txn =&gt; 
  Txn.afterCommit { _ =&gt; 
    log(s"Incrementing ${myValue()}") // don't do this! 
  </span><span class="koboSpan" id="kobo.90.2">} 
  myValue() = myValue() + 1 
} 
</span></pre><p><span class="koboSpan" id="kobo.91.1">Calling the last version of </span><code class="literal"><span class="koboSpan" id="kobo.92.1">inc</span></code><span class="koboSpan" id="kobo.93.1"> fails with an exception. </span><span class="koboSpan" id="kobo.93.2">Although the transactional context </span><code class="literal"><span class="koboSpan" id="kobo.94.1">txn</span></code><span class="koboSpan" id="kobo.95.1"> exists when the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">afterCommit</span></code><span class="koboSpan" id="kobo.97.1"> method is called, the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">afterCommit</span></code><span class="koboSpan" id="kobo.99.1"> block is executed later, after the transaction is already over and the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">txn</span></code><span class="koboSpan" id="kobo.101.1"> object is no longer valid. </span><span class="koboSpan" id="kobo.101.2">It is illegal to read or modify transactional references outside a transaction. </span><span class="koboSpan" id="kobo.101.3">Before using it in an </span><code class="literal"><span class="koboSpan" id="kobo.102.1">afterCommit</span></code><span class="koboSpan" id="kobo.103.1"> block, we need to store the value of the transactional reference into a local variable in the transaction itself.</span></p><p><span class="koboSpan" id="kobo.104.1">Why does accessing a transactional reference inside the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">afterCommit</span></code><span class="koboSpan" id="kobo.106.1"> block only fail at runtime, when the transaction executes, instead of failing during compilation? </span><span class="koboSpan" id="kobo.106.2">The </span><code class="literal"><span class="koboSpan" id="kobo.107.1">afterCommit</span></code><span class="koboSpan" id="kobo.108.1"> method is in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.109.1">static scope</span></strong></span><span class="koboSpan" id="kobo.110.1"> of the transaction, or, in other words is statically nested within an </span><code class="literal"><span class="koboSpan" id="kobo.111.1">atomic</span></code><span class="koboSpan" id="kobo.112.1"> statement. </span><span class="koboSpan" id="kobo.112.2">For this reason, the compiler resolves the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">txn</span></code><span class="koboSpan" id="kobo.114.1"> object of the transaction, and allows you to access the transactional references, such as </span><code class="literal"><span class="koboSpan" id="kobo.115.1">myValue</span></code><span class="koboSpan" id="kobo.116.1">. </span><span class="koboSpan" id="kobo.116.2">However, the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">afterCommit</span></code><span class="koboSpan" id="kobo.118.1"> block is not executed in the dynamic scope of the transaction. </span><span class="koboSpan" id="kobo.118.2">In other words, the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">afterCommit</span></code><span class="koboSpan" id="kobo.120.1"> block is run </span><span class="emphasis"><em><span class="koboSpan" id="kobo.121.1">after</span></em></span><span class="koboSpan" id="kobo.122.1"> the </span><code class="literal"><span class="koboSpan" id="kobo.123.1">atomic</span></code><span class="koboSpan" id="kobo.124.1"> block returns.</span></p><p><span class="koboSpan" id="kobo.125.1">By contrast, accessing a transactional reference outside of the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">atomic</span></code><span class="koboSpan" id="kobo.127.1"> block is not in the static scope of a transaction, so the compiler detects this and reports an error.</span></p><p><span class="koboSpan" id="kobo.128.1">In general, the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">InTxn</span></code><span class="koboSpan" id="kobo.130.1"> objects must not escape the transaction block. </span><span class="koboSpan" id="kobo.130.2">For example, it is not legal to start an asynchronous operation from within the transaction, and use the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">InTxn</span></code><span class="koboSpan" id="kobo.132.1"> object to access transactional references.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip75"/><span class="koboSpan" id="kobo.133.1">Tip</span></h3><p><span class="koboSpan" id="kobo.134.1">Only use the transactional context within the thread that started the transaction.</span></p></div></div><p><span class="koboSpan" id="kobo.135.1">In some cases, we want to execute some side-effecting operations when a rollback occurs. </span><span class="koboSpan" id="kobo.135.2">For instance, we would like to log each rollback to track the contention in our program. </span><span class="koboSpan" id="kobo.135.3">This information can help us restructure the program and eliminate potential performance bottlenecks. </span><span class="koboSpan" id="kobo.135.4">To achieve this, we use the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">afterRollback</span></code><span class="koboSpan" id="kobo.137.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.138.1">  def inc() = atomic { implicit txn =&gt; 
    Txn.afterRollback { _ =&gt; 
      log(s"rollin' back") 
    } 
    myValue() = myValue() + 1 
  } 
</span></pre><p><span class="koboSpan" id="kobo.139.1">Importantly, after a rollback, the transaction is no longer under way. </span><span class="koboSpan" id="kobo.139.2">Just as in the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">afterCommit</span></code><span class="koboSpan" id="kobo.141.1"> blocks, it is illegal to access the transactional references in the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">afterRollback</span></code><span class="koboSpan" id="kobo.143.1"> blocks.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip76"/><span class="koboSpan" id="kobo.144.1">Tip</span></h3><p><span class="koboSpan" id="kobo.145.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.146.1">Txn</span></code><span class="koboSpan" id="kobo.147.1"> object's </span><code class="literal"><span class="koboSpan" id="kobo.148.1">afterCommit</span></code><span class="koboSpan" id="kobo.149.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.150.1">afterRollback</span></code><span class="koboSpan" id="kobo.151.1"> methods to perform side-effecting operations in transactions without the danger of executing them multiple times.</span></p></div></div><p><span class="koboSpan" id="kobo.152.1">Not all side-effecting operations inside the transactions are bad. </span><span class="koboSpan" id="kobo.152.2">As long as the side effects are confined to mutating objects that are created inside the transaction, we are free to use them. </span><span class="koboSpan" id="kobo.152.3">In fact, such side effects are sometimes necessary. </span><span class="koboSpan" id="kobo.152.4">To demonstrate this, let's define the </span><code class="literal"><span class="koboSpan" id="kobo.153.1">Node</span></code><span class="koboSpan" id="kobo.154.1"> class for a transactional linked list collection. </span><span class="koboSpan" id="kobo.154.2">A transactional list is a concurrent, thread-safe linked list that is modified using memory transactions. </span><span class="koboSpan" id="kobo.154.3">Similar to a functional cons list, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.155.1">List</span></code><span class="koboSpan" id="kobo.156.1"> class in Scala, the transactional </span><code class="literal"><span class="koboSpan" id="kobo.157.1">Node</span></code><span class="koboSpan" id="kobo.158.1"> class contains two fields that we call </span><code class="literal"><span class="koboSpan" id="kobo.159.1">elem</span></code><span class="koboSpan" id="kobo.160.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.161.1">next</span></code><span class="koboSpan" id="kobo.162.1">. </span><span class="koboSpan" id="kobo.162.2">The </span><code class="literal"><span class="koboSpan" id="kobo.163.1">elem</span></code><span class="koboSpan" id="kobo.164.1"> field contains the value of the current node. </span><span class="koboSpan" id="kobo.164.2">To keep things simple, the </span><code class="literal"><span class="koboSpan" id="kobo.165.1">elem</span></code><span class="koboSpan" id="kobo.166.1"> field is a value field and can only contain integers.</span></p><p><span class="koboSpan" id="kobo.167.1">The </span><code class="literal"><span class="koboSpan" id="kobo.168.1">next</span></code><span class="koboSpan" id="kobo.169.1"> field is a transactional reference containing the next node in the linked list. </span><span class="koboSpan" id="kobo.169.2">We can read and modify the </span><code class="literal"><span class="koboSpan" id="kobo.170.1">next</span></code><span class="koboSpan" id="kobo.171.1"> field only inside memory transactions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.172.1">case class Node(elem: Int, next: Ref[Node]) 
</span></pre><p><span class="koboSpan" id="kobo.173.1">We now define a </span><code class="literal"><span class="koboSpan" id="kobo.174.1">nodeToString</span></code><span class="koboSpan" id="kobo.175.1"> method, which takes a transactional linked list node </span><code class="literal"><span class="koboSpan" id="kobo.176.1">n</span></code><span class="koboSpan" id="kobo.177.1">, and creates a </span><code class="literal"><span class="koboSpan" id="kobo.178.1">String</span></code><span class="koboSpan" id="kobo.179.1"> representation of the transactional list starting with the </span><code class="literal"><span class="koboSpan" id="kobo.180.1">n</span></code><span class="koboSpan" id="kobo.181.1"> node:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.182.1">def nodeToString(n: Node): String = atomic { implicit txn =&gt; 
  val b = new StringBuilder 
  var curr = n 
  while (curr != null) { 
    b ++= s"${curr.elem}, " 
    curr = curr.next() 
  } 
  b.toString 
} 
</span></pre><p><span class="koboSpan" id="kobo.183.1">In the preceding code snippet, we were careful to confine the side effects to objects that were created inside the transaction, in this case, the </span><code class="literal"><span class="koboSpan" id="kobo.184.1">StringBuilder</span></code><span class="koboSpan" id="kobo.185.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.186.1">b</span></code><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">Had we instantiated the </span><code class="literal"><span class="koboSpan" id="kobo.188.1">StringBuilder</span></code><span class="koboSpan" id="kobo.189.1"> object before the transaction started, the </span><code class="literal"><span class="koboSpan" id="kobo.190.1">nodeToString</span></code><span class="koboSpan" id="kobo.191.1"> method would not work correctly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.192.1">def nodeToStringWrong(n: Node): String = { 
  val b = new StringBuilder // very bad 
  atomic { implicit txn =&gt; 
    var curr = n 
    while (curr != null) { 
      b ++= s"${curr.elem}, " 
      curr = curr.next() 
    } 
  } 
  b.toString 
} 
</span></pre><p><span class="koboSpan" id="kobo.193.1">If the transaction gets rolled back in the </span><code class="literal"><span class="koboSpan" id="kobo.194.1">nodeToStringWrong</span></code><span class="koboSpan" id="kobo.195.1"> example, the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.196.1">StringBuilder</span></code><span class="koboSpan" id="kobo.197.1"> object are not cleared. </span><span class="koboSpan" id="kobo.197.2">The second time a transaction runs, it will modify the already existing, non-empty </span><code class="literal"><span class="koboSpan" id="kobo.198.1">StringBuilder</span></code><span class="koboSpan" id="kobo.199.1"> object and return a string representation that does not correspond to the state of the transactional list.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip77"/><span class="koboSpan" id="kobo.200.1">Tip</span></h3><p><span class="koboSpan" id="kobo.201.1">When mutating an object inside a transaction, make sure that the object is created inside the transaction and that the reference to it does not escape the scope of the transaction.</span></p></div></div><p><span class="koboSpan" id="kobo.202.1">Having seen how to manage side effects inside transactions, we now examine several special kinds of transactions and study how to compose smaller transactions into larger ones.</span></p></div><div class="section" title="Single-operation transactions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec64"/><span class="koboSpan" id="kobo.203.1">Single-operation transactions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.204.1">In some cases, we only want to read or modify a single transactional reference. </span><span class="koboSpan" id="kobo.204.2">It can be cumbersome to type the </span><code class="literal"><span class="koboSpan" id="kobo.205.1">atomic</span></code><span class="koboSpan" id="kobo.206.1"> keyword and the implicit </span><code class="literal"><span class="koboSpan" id="kobo.207.1">txn</span></code><span class="koboSpan" id="kobo.208.1"> argument just to read a single </span><code class="literal"><span class="koboSpan" id="kobo.209.1">Ref</span></code><span class="koboSpan" id="kobo.210.1"> object. </span><span class="koboSpan" id="kobo.210.2">To alleviate this, ScalaSTM defines single-operation transactions on transactional references. </span><span class="koboSpan" id="kobo.210.3">Single-operation transactions are executed by calling a single method on a </span><code class="literal"><span class="koboSpan" id="kobo.211.1">Ref</span></code><span class="koboSpan" id="kobo.212.1"> object. </span><span class="koboSpan" id="kobo.212.2">This method returns a </span><code class="literal"><span class="koboSpan" id="kobo.213.1">Ref.View</span></code><span class="koboSpan" id="kobo.214.1"> object, which has the same interface as a </span><code class="literal"><span class="koboSpan" id="kobo.215.1">Ref</span></code><span class="koboSpan" id="kobo.216.1"> object, but its methods can be called from outside a transaction. </span><span class="koboSpan" id="kobo.216.2">Each operation on a </span><code class="literal"><span class="koboSpan" id="kobo.217.1">Ref.View</span></code><span class="koboSpan" id="kobo.218.1"> object acts like a single-operation transaction.</span></p><p><span class="koboSpan" id="kobo.219.1">Recall the </span><code class="literal"><span class="koboSpan" id="kobo.220.1">Node</span></code><span class="koboSpan" id="kobo.221.1"> class for transactional linked lists from the previous section, which stored integers in an </span><code class="literal"><span class="koboSpan" id="kobo.222.1">elem</span></code><span class="koboSpan" id="kobo.223.1"> field, and the reference to the next node in the transactional reference called </span><code class="literal"><span class="koboSpan" id="kobo.224.1">next</span></code><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">Let's augment </span><code class="literal"><span class="koboSpan" id="kobo.226.1">Node</span></code><span class="koboSpan" id="kobo.227.1"> with two linked list methods. </span><span class="koboSpan" id="kobo.227.2">The </span><code class="literal"><span class="koboSpan" id="kobo.228.1">append</span></code><span class="koboSpan" id="kobo.229.1"> method takes a single </span><code class="literal"><span class="koboSpan" id="kobo.230.1">Node</span></code><span class="koboSpan" id="kobo.231.1"> argument </span><code class="literal"><span class="koboSpan" id="kobo.232.1">n</span></code><span class="koboSpan" id="kobo.233.1">, and inserts </span><code class="literal"><span class="koboSpan" id="kobo.234.1">n</span></code><span class="koboSpan" id="kobo.235.1"> after the current node. </span><span class="koboSpan" id="kobo.235.2">The </span><code class="literal"><span class="koboSpan" id="kobo.236.1">nextNode</span></code><span class="koboSpan" id="kobo.237.1"> method returns the reference to the next node, or </span><code class="literal"><span class="koboSpan" id="kobo.238.1">null</span></code><span class="koboSpan" id="kobo.239.1"> if the current node is at the end of the list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.240.1">case class Node(val elem: Int, val next: Ref[Node]) { 
  def append(n: Node): Unit = atomic { implicit txn =&gt; 
    val oldNext = next() 
    next() = n 
    n.next() = oldNext 
  } 
  def nextNode: Node = next.single() 
} 
</span></pre><p><span class="koboSpan" id="kobo.241.1">The </span><code class="literal"><span class="koboSpan" id="kobo.242.1">nextNode</span></code><span class="koboSpan" id="kobo.243.1"> method does a single-operation transaction. </span><span class="koboSpan" id="kobo.243.2">It calls single on the </span><code class="literal"><span class="koboSpan" id="kobo.244.1">next</span></code><span class="koboSpan" id="kobo.245.1"> transactional reference, and then calls the </span><code class="literal"><span class="koboSpan" id="kobo.246.1">apply</span></code><span class="koboSpan" id="kobo.247.1"> method in order to obtain the value of the next node. </span><span class="koboSpan" id="kobo.247.2">This is equivalent to the following definition:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.248.1">def nextNode: Node = atomic { implicit txn =&gt; 
  next() 
} 
</span></pre><p><span class="koboSpan" id="kobo.249.1">We can use our transactional </span><code class="literal"><span class="koboSpan" id="kobo.250.1">Node</span></code><span class="koboSpan" id="kobo.251.1"> class to declare a linked list called </span><code class="literal"><span class="koboSpan" id="kobo.252.1">nodes</span></code><span class="koboSpan" id="kobo.253.1">, initially containing values </span><code class="literal"><span class="koboSpan" id="kobo.254.1">1</span></code><span class="koboSpan" id="kobo.255.1">, </span><code class="literal"><span class="koboSpan" id="kobo.256.1">4</span></code><span class="koboSpan" id="kobo.257.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.258.1">5</span></code><span class="koboSpan" id="kobo.259.1">, and then concurrently modify it. </span><span class="koboSpan" id="kobo.259.2">We start two futures </span><code class="literal"><span class="koboSpan" id="kobo.260.1">f</span></code><span class="koboSpan" id="kobo.261.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.262.1">g</span></code><span class="koboSpan" id="kobo.263.1">, which call </span><code class="literal"><span class="koboSpan" id="kobo.264.1">append</span></code><span class="koboSpan" id="kobo.265.1"> to add nodes with the values </span><code class="literal"><span class="koboSpan" id="kobo.266.1">2</span></code><span class="koboSpan" id="kobo.267.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.268.1">3</span></code><span class="koboSpan" id="kobo.269.1">, respectively. </span><span class="koboSpan" id="kobo.269.2">After the futures complete, we call </span><code class="literal"><span class="koboSpan" id="kobo.270.1">nextNode</span></code><span class="koboSpan" id="kobo.271.1"> and print the value of the next node. </span><span class="koboSpan" id="kobo.271.2">The following code snippet will print the node with either the value </span><code class="literal"><span class="koboSpan" id="kobo.272.1">2</span></code><span class="koboSpan" id="kobo.273.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.274.1">3</span></code><span class="koboSpan" id="kobo.275.1">, depending on which future completes last:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.276.1">val nodes = Node(1, Ref(Node(4, Ref(Node(5, Ref(null)))))) 
val f = Future { nodes.append(Node(2, Ref(null))) } 
val g = Future { nodes.append(Node(3, Ref(null))) } 
for (_ &lt;- f; _ &lt;- g) log(s"Next node is: ${nodes.nextNode}") 
</span></pre><p><span class="koboSpan" id="kobo.277.1">We can also use the </span><code class="literal"><span class="koboSpan" id="kobo.278.1">single</span></code><span class="koboSpan" id="kobo.279.1"> method to invoke other transactional reference operations. </span><span class="koboSpan" id="kobo.279.2">In the following code snippet, we use the </span><code class="literal"><span class="koboSpan" id="kobo.280.1">transform</span></code><span class="koboSpan" id="kobo.281.1"> operation to define an </span><code class="literal"><span class="koboSpan" id="kobo.282.1">appendIfEnd</span></code><span class="koboSpan" id="kobo.283.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.284.1">Node</span></code><span class="koboSpan" id="kobo.285.1"> class, which appends a node </span><code class="literal"><span class="koboSpan" id="kobo.286.1">n</span></code><span class="koboSpan" id="kobo.287.1"> after the current node only if the current node is followed by </span><code class="literal"><span class="koboSpan" id="kobo.288.1">null</span></code><span class="koboSpan" id="kobo.289.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.290.1">def appendIfEnd(n: Node) = next.single.transform { 
  oldNext =&gt; if (oldNext == null) n else oldNext 
} 
</span></pre><p><span class="koboSpan" id="kobo.291.1">The </span><code class="literal"><span class="koboSpan" id="kobo.292.1">transform</span></code><span class="koboSpan" id="kobo.293.1"> operation on a </span><code class="literal"><span class="koboSpan" id="kobo.294.1">Ref</span></code><span class="koboSpan" id="kobo.295.1"> object containing the values of type </span><code class="literal"><span class="koboSpan" id="kobo.296.1">T</span></code><span class="koboSpan" id="kobo.297.1"> takes a transformation function of type </span><code class="literal"><span class="koboSpan" id="kobo.298.1">T =&gt; T</span></code><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">It atomically performs a read of the transactional reference, applies the transformation function to the current value, and writes the new value back. </span><span class="koboSpan" id="kobo.299.3">Other single-operation transactions include </span><code class="literal"><span class="koboSpan" id="kobo.300.1">update</span></code><span class="koboSpan" id="kobo.301.1">, </span><code class="literal"><span class="koboSpan" id="kobo.302.1">compareAndSet</span></code><span class="koboSpan" id="kobo.303.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.304.1">swap</span></code><span class="koboSpan" id="kobo.305.1"> operations. </span><span class="koboSpan" id="kobo.305.2">We refer the readers to the online documentation to learn their precise semantics.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip78"/><span class="koboSpan" id="kobo.306.1">Tip</span></h3><p><span class="koboSpan" id="kobo.307.1">Use single-operation transactions for single read, write, and CAS-like operations in order to avoid the syntactic boilerplate associated with the </span><code class="literal"><span class="koboSpan" id="kobo.308.1">atomic</span></code><span class="koboSpan" id="kobo.309.1"> blocks.</span></p></div></div><p><span class="koboSpan" id="kobo.310.1">Single-operation transactions are convenience methods that are easier to type, and are possibly more efficient, depending on the underlying STM implementation. </span><span class="koboSpan" id="kobo.310.2">They can be useful, but as programs grow, we are more interested in building larger transactions from simple ones. </span><span class="koboSpan" id="kobo.310.3">We will investigate how to do this in the next section.</span></p></div><div class="section" title="Nesting transactions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec65"/><span class="koboSpan" id="kobo.311.1">Nesting transactions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.312.1">Recall from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.313.1">Chapter 2</span></a><span class="koboSpan" id="kobo.314.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.315.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.316.1">, that a </span><code class="literal"><span class="koboSpan" id="kobo.317.1">synchronized</span></code><span class="koboSpan" id="kobo.318.1"> statement can be nested inside other </span><code class="literal"><span class="koboSpan" id="kobo.319.1">synchronized</span></code><span class="koboSpan" id="kobo.320.1"> statements. </span><span class="koboSpan" id="kobo.320.2">This property is essential when composing programs from multiple software modules. </span><span class="koboSpan" id="kobo.320.3">For example, a money transfer module in a banking system must call operations from a logging module to persist the transactions. </span><span class="koboSpan" id="kobo.320.4">Both the modules might internally use arbitrary sets of locks, without the knowledge of other modules. </span><span class="koboSpan" id="kobo.320.5">An unfortunate disadvantage of arbitrarily nested </span><code class="literal"><span class="koboSpan" id="kobo.321.1">synchronized</span></code><span class="koboSpan" id="kobo.322.1"> statements is that they allow the possibility of a deadlock.</span></p><p><span class="koboSpan" id="kobo.323.1">Separate </span><code class="literal"><span class="koboSpan" id="kobo.324.1">atomic</span></code><span class="koboSpan" id="kobo.325.1"> statements can also nest arbitrarily. </span><span class="koboSpan" id="kobo.325.2">The motivation for this is the same as with the </span><code class="literal"><span class="koboSpan" id="kobo.326.1">synchronized</span></code><span class="koboSpan" id="kobo.327.1"> statement. </span><span class="koboSpan" id="kobo.327.2">A transaction inside a software module must be able to invoke operations inside other software modules, which themselves might start the transactions. </span><span class="koboSpan" id="kobo.327.3">Not having to know about the transactions inside an operation allows a better separation between different software components.</span></p><p><span class="koboSpan" id="kobo.328.1">Let's illustrate this with a concrete example. </span><span class="koboSpan" id="kobo.328.2">Recall the </span><code class="literal"><span class="koboSpan" id="kobo.329.1">Node</span></code><span class="koboSpan" id="kobo.330.1"> class from the previous section, which was used for transactional linked lists. </span><span class="koboSpan" id="kobo.330.2">The </span><code class="literal"><span class="koboSpan" id="kobo.331.1">Node</span></code><span class="koboSpan" id="kobo.332.1"> class was somewhat low-level. </span><span class="koboSpan" id="kobo.332.2">We can only call the </span><code class="literal"><span class="koboSpan" id="kobo.333.1">append</span></code><span class="koboSpan" id="kobo.334.1"> method to insert new nodes after the specified node, and call </span><code class="literal"><span class="koboSpan" id="kobo.335.1">nodeToString</span></code><span class="koboSpan" id="kobo.336.1"> on a specific node to convert its elements to a </span><code class="literal"><span class="koboSpan" id="kobo.337.1">String</span></code><span class="koboSpan" id="kobo.338.1"> object.</span></p><p><span class="koboSpan" id="kobo.339.1">In this section, we define the transactional sorted list class, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.340.1">TSortedList</span></code><span class="koboSpan" id="kobo.341.1"> class. </span><span class="koboSpan" id="kobo.341.2">This class stores integers in ascending order. </span><span class="koboSpan" id="kobo.341.3">It maintains a single transactional reference </span><code class="literal"><span class="koboSpan" id="kobo.342.1">head</span></code><span class="koboSpan" id="kobo.343.1">, which points to the head of the linked list of the </span><code class="literal"><span class="koboSpan" id="kobo.344.1">Node</span></code><span class="koboSpan" id="kobo.345.1"> objects. </span><span class="koboSpan" id="kobo.345.2">We define the </span><code class="literal"><span class="koboSpan" id="kobo.346.1">toString</span></code><span class="koboSpan" id="kobo.347.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.348.1">TSortedList</span></code><span class="koboSpan" id="kobo.349.1"> class to convert its contents into a textual representation. </span><span class="koboSpan" id="kobo.349.2">The </span><code class="literal"><span class="koboSpan" id="kobo.350.1">toString</span></code><span class="koboSpan" id="kobo.351.1"> method needs to read the transactional reference </span><code class="literal"><span class="koboSpan" id="kobo.352.1">head</span></code><span class="koboSpan" id="kobo.353.1">, so it starts by creating a new transaction. </span><span class="koboSpan" id="kobo.353.2">After reading the value of the </span><code class="literal"><span class="koboSpan" id="kobo.354.1">head</span></code><span class="koboSpan" id="kobo.355.1"> transactional reference into a local value </span><code class="literal"><span class="koboSpan" id="kobo.356.1">headNode</span></code><span class="koboSpan" id="kobo.357.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.358.1">toString</span></code><span class="koboSpan" id="kobo.359.1"> method can reuse the </span><code class="literal"><span class="koboSpan" id="kobo.360.1">nodeToString</span></code><span class="koboSpan" id="kobo.361.1"> method that we defined earlier:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.362.1">class TSortedList { 
  val head = Ref[Node](null) 
  override def toString: String = atomic { implicit txn =&gt; 
    val h = head() 
    nodeToString(h) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.363.1">Recall that the </span><code class="literal"><span class="koboSpan" id="kobo.364.1">nodeToString</span></code><span class="koboSpan" id="kobo.365.1"> method starts another transaction to read the next references in each node. </span><span class="koboSpan" id="kobo.365.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.366.1">toString</span></code><span class="koboSpan" id="kobo.367.1"> method calls </span><code class="literal"><span class="koboSpan" id="kobo.368.1">nodeToString</span></code><span class="koboSpan" id="kobo.369.1">, the second transaction becomes </span><span class="emphasis"><em><span class="koboSpan" id="kobo.370.1">nested</span></em></span><span class="koboSpan" id="kobo.371.1"> in the transaction started by </span><code class="literal"><span class="koboSpan" id="kobo.372.1">toString</span></code><span class="koboSpan" id="kobo.373.1">. </span><span class="koboSpan" id="kobo.373.2">The </span><code class="literal"><span class="koboSpan" id="kobo.374.1">atomic</span></code><span class="koboSpan" id="kobo.375.1"> block in the </span><code class="literal"><span class="koboSpan" id="kobo.376.1">nodeToString</span></code><span class="koboSpan" id="kobo.377.1"> method does not start a new, separate transaction. </span><span class="koboSpan" id="kobo.377.2">Instead, the nested transaction becomes a part of the existing transaction. </span><span class="koboSpan" id="kobo.377.3">This has two important consequences. </span><span class="koboSpan" id="kobo.377.4">First, if the nested transaction fails, it is not rolled back to the start of its </span><code class="literal"><span class="koboSpan" id="kobo.378.1">atomic</span></code><span class="koboSpan" id="kobo.379.1"> block in the </span><code class="literal"><span class="koboSpan" id="kobo.380.1">nodeToString</span></code><span class="koboSpan" id="kobo.381.1"> method. </span><span class="koboSpan" id="kobo.381.2">Instead, it rolls back to the start of the </span><code class="literal"><span class="koboSpan" id="kobo.382.1">atomic</span></code><span class="koboSpan" id="kobo.383.1"> block in the </span><code class="literal"><span class="koboSpan" id="kobo.384.1">toString</span></code><span class="koboSpan" id="kobo.385.1"> method. </span><span class="koboSpan" id="kobo.385.2">We say that the start of the transaction is determined by the dynamic scope, rather than the static scope. </span><span class="koboSpan" id="kobo.385.3">Similarly, the nested transaction does not commit when it reaches the end of the </span><code class="literal"><span class="koboSpan" id="kobo.386.1">atomic</span></code><span class="koboSpan" id="kobo.387.1"> block in the </span><code class="literal"><span class="koboSpan" id="kobo.388.1">nodeToString</span></code><span class="koboSpan" id="kobo.389.1"> method. </span><span class="koboSpan" id="kobo.389.2">The changes induced by the nested transaction become visible when the initial transaction commits. </span><span class="koboSpan" id="kobo.389.3">We say that the scope of the transaction is always that of the top-level transaction.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/><span class="koboSpan" id="kobo.390.1">Note</span></h3><p><span class="koboSpan" id="kobo.391.1">Nested </span><code class="literal"><span class="koboSpan" id="kobo.392.1">atomic</span></code><span class="koboSpan" id="kobo.393.1"> blocks result in a transaction that starts when the top-level </span><code class="literal"><span class="koboSpan" id="kobo.394.1">atomic</span></code><span class="koboSpan" id="kobo.395.1"> block starts, and can commit only after the top-level </span><code class="literal"><span class="koboSpan" id="kobo.396.1">atomic</span></code><span class="koboSpan" id="kobo.397.1"> block completes. </span><span class="koboSpan" id="kobo.397.2">Similarly, rollbacks retry the transaction starting from the top-level </span><code class="literal"><span class="koboSpan" id="kobo.398.1">atomic</span></code><span class="koboSpan" id="kobo.399.1"> block.</span></p></div></div><p><span class="koboSpan" id="kobo.400.1">We now study another example of using nested transactions. </span><span class="koboSpan" id="kobo.400.2">Atomically converting transactional sorted lists to their string representation is useful, but we also need to insert elements in the list. </span><span class="koboSpan" id="kobo.400.3">We define the </span><code class="literal"><span class="koboSpan" id="kobo.401.1">insert</span></code><span class="koboSpan" id="kobo.402.1"> method, which takes an integer and inserts it into a proper position in the transactional list.</span></p><p><span class="koboSpan" id="kobo.403.1">Since </span><code class="literal"><span class="koboSpan" id="kobo.404.1">insert</span></code><span class="koboSpan" id="kobo.405.1"> can modify both the transactional reference </span><code class="literal"><span class="koboSpan" id="kobo.406.1">head</span></code><span class="koboSpan" id="kobo.407.1"> and the nodes in the list, it starts by creating a transaction. </span><span class="koboSpan" id="kobo.407.2">It then checks for two special cases. </span><span class="koboSpan" id="kobo.407.3">A list can be empty, in this case we set </span><code class="literal"><span class="koboSpan" id="kobo.408.1">head</span></code><span class="koboSpan" id="kobo.409.1"> to a new node containing </span><code class="literal"><span class="koboSpan" id="kobo.410.1">x</span></code><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">Likewise, the </span><code class="literal"><span class="koboSpan" id="kobo.412.1">x</span></code><span class="koboSpan" id="kobo.413.1"> integer might be smaller than the first value in the list; in which case, the </span><code class="literal"><span class="koboSpan" id="kobo.414.1">head</span></code><span class="koboSpan" id="kobo.415.1"> reference is set to a new node containing </span><code class="literal"><span class="koboSpan" id="kobo.416.1">x</span></code><span class="koboSpan" id="kobo.417.1">, and its </span><code class="literal"><span class="koboSpan" id="kobo.418.1">next</span></code><span class="koboSpan" id="kobo.419.1"> field is set to the previous value of the </span><code class="literal"><span class="koboSpan" id="kobo.420.1">head</span></code><span class="koboSpan" id="kobo.421.1"> reference. </span><span class="koboSpan" id="kobo.421.2">If neither of these conditions applies, we call a tail-recursive, nested method </span><code class="literal"><span class="koboSpan" id="kobo.422.1">insert</span></code><span class="koboSpan" id="kobo.423.1"> to process the remainder of the list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.424.1">import scala.annotation.tailrec 
def insert(x: Int): this.type = atomic { implicit txn =&gt; 
  @tailrec def insert(n: Node): Unit = { 
    if (n.next() == null || n.next().elem &gt; x) 
      n.append(new Node(x, Ref(null))) 
    else insert(n.next()) 
  } 
  if (head() == null || head().elem &gt; x) 
    head() = new Node(x, Ref(head())) 
  else insert(head()) 
  this 
} 
</span></pre><p><span class="koboSpan" id="kobo.425.1">The nested </span><code class="literal"><span class="koboSpan" id="kobo.426.1">insert</span></code><span class="koboSpan" id="kobo.427.1"> method traverses the linked list in order to find the correct position for the </span><code class="literal"><span class="koboSpan" id="kobo.428.1">x</span></code><span class="koboSpan" id="kobo.429.1"> integer. </span><span class="koboSpan" id="kobo.429.2">It takes the current node </span><code class="literal"><span class="koboSpan" id="kobo.430.1">n</span></code><span class="koboSpan" id="kobo.431.1"> and checks if the node is followed by </span><code class="literal"><span class="koboSpan" id="kobo.432.1">null</span></code><span class="koboSpan" id="kobo.433.1">, indicating the end of the list, or if the next element is greater than </span><code class="literal"><span class="koboSpan" id="kobo.434.1">x</span></code><span class="koboSpan" id="kobo.435.1">. </span><span class="koboSpan" id="kobo.435.2">In both cases, we call the </span><code class="literal"><span class="koboSpan" id="kobo.436.1">append</span></code><span class="koboSpan" id="kobo.437.1"> method on the node. </span><span class="koboSpan" id="kobo.437.2">If the node following </span><code class="literal"><span class="koboSpan" id="kobo.438.1">n</span></code><span class="koboSpan" id="kobo.439.1"> is not </span><code class="literal"><span class="koboSpan" id="kobo.440.1">null</span></code><span class="koboSpan" id="kobo.441.1">, and its </span><code class="literal"><span class="koboSpan" id="kobo.442.1">elem</span></code><span class="koboSpan" id="kobo.443.1"> field is less than or equal to </span><code class="literal"><span class="koboSpan" id="kobo.444.1">x</span></code><span class="koboSpan" id="kobo.445.1">, we call </span><code class="literal"><span class="koboSpan" id="kobo.446.1">insert</span></code><span class="koboSpan" id="kobo.447.1"> recursively on the next node.</span></p><p><span class="koboSpan" id="kobo.448.1">Note that the tail-recursive, nested method </span><code class="literal"><span class="koboSpan" id="kobo.449.1">insert</span></code><span class="koboSpan" id="kobo.450.1"> uses the transactional context </span><code class="literal"><span class="koboSpan" id="kobo.451.1">txn</span></code><span class="koboSpan" id="kobo.452.1"> of the enclosing </span><code class="literal"><span class="koboSpan" id="kobo.453.1">atomic</span></code><span class="koboSpan" id="kobo.454.1"> block. </span><span class="koboSpan" id="kobo.454.2">We can also define a separate tail-recursive method </span><code class="literal"><span class="koboSpan" id="kobo.455.1">insert</span></code><span class="koboSpan" id="kobo.456.1"> outside the scope of the transaction. </span><span class="koboSpan" id="kobo.456.2">In this case, we need to encode the transactional context </span><code class="literal"><span class="koboSpan" id="kobo.457.1">txn</span></code><span class="koboSpan" id="kobo.458.1"> as a separate implicit parameter:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.459.1">@tailrec 
final def insert(n: Node, x: Int)(implicit txn: InTxn): Unit = { 
  if (n.next() == null || n.next().elem &gt; x) 
    n.append(new Node(x, Ref(null))) 
  else insert(n.next(), x) 
} 
</span></pre><p><span class="koboSpan" id="kobo.460.1">Alternatively, we can omit the implicit </span><code class="literal"><span class="koboSpan" id="kobo.461.1">txn</span></code><span class="koboSpan" id="kobo.462.1"> transactional context parameter, but then we have to start a nested transaction inside the tail-recursive </span><code class="literal"><span class="koboSpan" id="kobo.463.1">insert</span></code><span class="koboSpan" id="kobo.464.1"> method. </span><span class="koboSpan" id="kobo.464.2">This might be slightly less efficient than the previous approach, but it is semantically equivalent:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.465.1">@tailrec 
final def insert(n: Node, x: Int): Unit = atomic { implicit txn =&gt; 
  if (n.next() == null || n.next().elem &gt; x) 
    n.append(new Node(x, Ref(null))) 
  else insert(n.next(), x) 
} 
</span></pre><p><span class="koboSpan" id="kobo.466.1">We test our transactional sorted list with the following snippet. </span><span class="koboSpan" id="kobo.466.2">We instantiate an empty transactional sorted list and insert several integers concurrently from the asynchronous computations </span><code class="literal"><span class="koboSpan" id="kobo.467.1">f</span></code><span class="koboSpan" id="kobo.468.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.469.1">g</span></code><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">After both the corresponding futures complete execution, we print the contents of the sorted list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.471.1">val sortedList = new TSortedList 
val f = Future { sortedList.insert(1); sortedList.insert(4) } 
val g = Future { sortedList.insert(2); sortedList.insert(3) } 
for (_ &lt;- f; _ &lt;- g) log(s"sorted list - $sortedList") 
</span></pre><p><span class="koboSpan" id="kobo.472.1">Running the preceding snippet always outputs the elements </span><code class="literal"><span class="koboSpan" id="kobo.473.1">1</span></code><span class="koboSpan" id="kobo.474.1">, </span><code class="literal"><span class="koboSpan" id="kobo.475.1">2</span></code><span class="koboSpan" id="kobo.476.1">, </span><code class="literal"><span class="koboSpan" id="kobo.477.1">3</span></code><span class="koboSpan" id="kobo.478.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.479.1">4</span></code><span class="koboSpan" id="kobo.480.1"> in the same sorted order, regardless of the execution schedule of the futures. </span><span class="koboSpan" id="kobo.480.2">We created a thread-safe transactional sorted list class, and the implementation is almost identical to the corresponding sequential sorted list implementation. </span><span class="koboSpan" id="kobo.480.3">This example shows the true potential of STM. </span><span class="koboSpan" id="kobo.480.4">It allows you to create concurrent data structures and thread-safe data models without having to worry too much about concurrency.</span></p><p><span class="koboSpan" id="kobo.481.1">There is one more aspect of transactions that we have not yet considered. </span><span class="koboSpan" id="kobo.481.2">What happens if a transaction fails due to an exception? </span><span class="koboSpan" id="kobo.481.3">For example, the tail-recursive </span><code class="literal"><span class="koboSpan" id="kobo.482.1">insert</span></code><span class="koboSpan" id="kobo.483.1"> method can get called with a </span><code class="literal"><span class="koboSpan" id="kobo.484.1">null</span></code><span class="koboSpan" id="kobo.485.1"> value instead of a valid </span><code class="literal"><span class="koboSpan" id="kobo.486.1">Node</span></code><span class="koboSpan" id="kobo.487.1"> reference. </span><span class="koboSpan" id="kobo.487.2">This results in throwing a </span><code class="literal"><span class="koboSpan" id="kobo.488.1">NullPointerException</span></code><span class="koboSpan" id="kobo.489.1">, but how does it affect the transaction? </span><span class="koboSpan" id="kobo.489.2">We will explore the exception semantics of the transactions in the following section.</span></p></div><div class="section" title="Transactions and exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec66"/><span class="koboSpan" id="kobo.490.1">Transactions and exceptions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.491.1">From what we've learned about transactions so far, it is not clear what happens with a transaction if it throws an exception. </span><span class="koboSpan" id="kobo.491.2">An exception could roll back the transaction, or it could commit its changes. </span><span class="koboSpan" id="kobo.491.3">ScalaSTM does a rollback, by default, but this behavior can be overridden.</span></p><p><span class="koboSpan" id="kobo.492.1">Let's assume that the clients of our transactional sorted list want to use it as a concurrent priority queue. </span><span class="koboSpan" id="kobo.492.2">A </span><span class="emphasis"><em><span class="koboSpan" id="kobo.493.1">priority queue</span></em></span><span class="koboSpan" id="kobo.494.1"> is a collection that contains ordered elements, such as integers. </span><span class="koboSpan" id="kobo.494.2">An arbitrary element can be inserted into a priority queue using the </span><code class="literal"><span class="koboSpan" id="kobo.495.1">insert</span></code><span class="koboSpan" id="kobo.496.1"> method. </span><span class="koboSpan" id="kobo.496.2">At each point, we can retrieve the smallest element currently in the priority queue using the </span><code class="literal"><span class="koboSpan" id="kobo.497.1">head</span></code><span class="koboSpan" id="kobo.498.1"> method. </span><span class="koboSpan" id="kobo.498.2">The priority queue also allows you to remove the smallest element with the </span><code class="literal"><span class="koboSpan" id="kobo.499.1">pop</span></code><span class="koboSpan" id="kobo.500.1"> method.</span></p><p><span class="koboSpan" id="kobo.501.1">The transactional sorted list is already sorted and supports element insertion with the </span><code class="literal"><span class="koboSpan" id="kobo.502.1">insert</span></code><span class="koboSpan" id="kobo.503.1"> method, however, once added, elements cannot be removed. </span><span class="koboSpan" id="kobo.503.2">To make our transactional sorted list usable as a priority queue, we define a </span><code class="literal"><span class="koboSpan" id="kobo.504.1">pop</span></code><span class="koboSpan" id="kobo.505.1"> method, which removes the first </span><code class="literal"><span class="koboSpan" id="kobo.506.1">n</span></code><span class="koboSpan" id="kobo.507.1"> elements from a transactional list </span><code class="literal"><span class="koboSpan" id="kobo.508.1">xs</span></code><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">We start a transaction inside the </span><code class="literal"><span class="koboSpan" id="kobo.510.1">pop</span></code><span class="koboSpan" id="kobo.511.1"> method, and declare a local variable </span><code class="literal"><span class="koboSpan" id="kobo.512.1">left</span></code><span class="koboSpan" id="kobo.513.1">, initializing it with the number of removed elements </span><code class="literal"><span class="koboSpan" id="kobo.514.1">n</span></code><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">We then use a </span><code class="literal"><span class="koboSpan" id="kobo.516.1">while</span></code><span class="koboSpan" id="kobo.517.1"> loop to remove nodes from </span><code class="literal"><span class="koboSpan" id="kobo.518.1">head</span></code><span class="koboSpan" id="kobo.519.1"> and decrease the </span><code class="literal"><span class="koboSpan" id="kobo.520.1">left</span></code><span class="koboSpan" id="kobo.521.1"> variable until it becomes 0:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.522.1">def pop(xs: TSortedList, n: Int): Unit = atomic { implicit txn =&gt; 
  var left = n 
  while (left &gt; 0) { 
    xs.head() = xs.head().next() 
    left -= 1 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.523.1">To test the </span><code class="literal"><span class="koboSpan" id="kobo.524.1">pop</span></code><span class="koboSpan" id="kobo.525.1"> method, we declare a new transactional list </span><code class="literal"><span class="koboSpan" id="kobo.526.1">lst</span></code><span class="koboSpan" id="kobo.527.1">, and insert integers </span><code class="literal"><span class="koboSpan" id="kobo.528.1">4</span></code><span class="koboSpan" id="kobo.529.1">, </span><code class="literal"><span class="koboSpan" id="kobo.530.1">9</span></code><span class="koboSpan" id="kobo.531.1">, </span><code class="literal"><span class="koboSpan" id="kobo.532.1">1</span></code><span class="koboSpan" id="kobo.533.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.534.1">16</span></code><span class="koboSpan" id="kobo.535.1">. </span><span class="koboSpan" id="kobo.535.2">The list is sorted, so the integers appear in the list in the order </span><code class="literal"><span class="koboSpan" id="kobo.536.1">1</span></code><span class="koboSpan" id="kobo.537.1">, </span><code class="literal"><span class="koboSpan" id="kobo.538.1">4</span></code><span class="koboSpan" id="kobo.539.1">, </span><code class="literal"><span class="koboSpan" id="kobo.540.1">9</span></code><span class="koboSpan" id="kobo.541.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.542.1">16</span></code><span class="koboSpan" id="kobo.543.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.544.1">val lst = new TSortedList 
lst.insert(4).insert(9).insert(1).insert(16) 
</span></pre><p><span class="koboSpan" id="kobo.545.1">Next, we start an asynchronous computation that removes the first two integers in the list by calling </span><code class="literal"><span class="koboSpan" id="kobo.546.1">pop</span></code><span class="koboSpan" id="kobo.547.1">. </span><span class="koboSpan" id="kobo.547.2">After the asynchronous computation is successfully completed, we print the contents of the transactional list to the standard output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.548.1">Future { pop(lst, 2) } foreach { 
  case _ =&gt; log(s"removed 2 elements; list = $lst") 
} 
</span></pre><p><span class="koboSpan" id="kobo.549.1">So far, so good. </span><span class="koboSpan" id="kobo.549.2">The </span><code class="literal"><span class="koboSpan" id="kobo.550.1">log</span></code><span class="koboSpan" id="kobo.551.1"> statement outputs the list with the elements </span><code class="literal"><span class="koboSpan" id="kobo.552.1">9</span></code><span class="koboSpan" id="kobo.553.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.554.1">16</span></code><span class="koboSpan" id="kobo.555.1">. </span><span class="koboSpan" id="kobo.555.2">We proceed by starting another asynchronous computation, which removes the first three elements from the transactional list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.556.1">Future { pop(lst, 3) } onComplete { 
  case Failure(t) =&gt; log(s"whoa $t; list = $lst") 
} 
</span></pre><p><span class="koboSpan" id="kobo.557.1">However, when we call the </span><code class="literal"><span class="koboSpan" id="kobo.558.1">pop</span></code><span class="koboSpan" id="kobo.559.1"> method again, it throws a </span><code class="literal"><span class="koboSpan" id="kobo.560.1">NullPointerException</span></code><span class="koboSpan" id="kobo.561.1">; there are only two elements left in the transactional list. </span><span class="koboSpan" id="kobo.561.2">As a result, the reference </span><code class="literal"><span class="koboSpan" id="kobo.562.1">head</span></code><span class="koboSpan" id="kobo.563.1"> is eventually assigned </span><code class="literal"><span class="koboSpan" id="kobo.564.1">null</span></code><span class="koboSpan" id="kobo.565.1"> during the transaction. </span><span class="koboSpan" id="kobo.565.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.566.1">pop</span></code><span class="koboSpan" id="kobo.567.1"> method tries to call </span><code class="literal"><span class="koboSpan" id="kobo.568.1">next</span></code><span class="koboSpan" id="kobo.569.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.570.1">null</span></code><span class="koboSpan" id="kobo.571.1">, an exception is thrown.</span></p><p><span class="koboSpan" id="kobo.572.1">In the </span><code class="literal"><span class="koboSpan" id="kobo.573.1">onComplete</span></code><span class="koboSpan" id="kobo.574.1"> callback, we output the name of the exception and the contents of the transactional list. </span><span class="koboSpan" id="kobo.574.2">It turns out that the transactional list still contains the elements </span><code class="literal"><span class="koboSpan" id="kobo.575.1">9</span></code><span class="koboSpan" id="kobo.576.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.577.1">16</span></code><span class="koboSpan" id="kobo.578.1">, although the </span><code class="literal"><span class="koboSpan" id="kobo.579.1">head</span></code><span class="koboSpan" id="kobo.580.1"> reference of the transactional list had been set to </span><code class="literal"><span class="koboSpan" id="kobo.581.1">null</span></code><span class="koboSpan" id="kobo.582.1"> in the transaction. </span><span class="koboSpan" id="kobo.582.2">When an exception is thrown, the effects of the transaction are reverted.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note80"/><span class="koboSpan" id="kobo.583.1">Note</span></h3><p><span class="koboSpan" id="kobo.584.1">When an exception is thrown inside a transaction, the transaction is rolled back and the exception is rethrown at the point where the top-level </span><code class="literal"><span class="koboSpan" id="kobo.585.1">atomic</span></code><span class="koboSpan" id="kobo.586.1"> block started.</span></p></div></div><p><span class="koboSpan" id="kobo.587.1">Importantly, the nested transactions are also rolled back. </span><span class="koboSpan" id="kobo.587.2">In the following code snippet, the nested </span><code class="literal"><span class="koboSpan" id="kobo.588.1">atomic</span></code><span class="koboSpan" id="kobo.589.1"> block in the </span><code class="literal"><span class="koboSpan" id="kobo.590.1">pop</span></code><span class="koboSpan" id="kobo.591.1"> method completes successfully, but its changes are not committed. </span><span class="koboSpan" id="kobo.591.2">Instead, the entire transaction is rolled back when the </span><code class="literal"><span class="koboSpan" id="kobo.592.1">sys.error</span></code><span class="koboSpan" id="kobo.593.1"> call throws a </span><code class="literal"><span class="koboSpan" id="kobo.594.1">RuntimeException</span></code><span class="koboSpan" id="kobo.595.1"> in the enclosing top-level </span><code class="literal"><span class="koboSpan" id="kobo.596.1">atomic</span></code><span class="koboSpan" id="kobo.597.1"> block:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.598.1">Future { 
  atomic { implicit txn =&gt; 
    pop(lst, 1) 
    sys.error("") 
  } 
} onComplete { 
  case Failure(t) =&gt; log(s"oops again $t - $lst") 
} 
</span></pre><p><span class="koboSpan" id="kobo.599.1">Unlike ScalaSTM, some other STM implementations do not roll back transactions when an exception is thrown; instead, they commit the transaction. </span><span class="koboSpan" id="kobo.599.2">STM experts have not yet reached a consensus on what the exception semantics should be. </span><span class="koboSpan" id="kobo.599.3">ScalaSTM uses a hybrid approach. </span><span class="koboSpan" id="kobo.599.4">Most exceptions roll back the transaction, but Scala's </span><span class="strong"><strong><span class="koboSpan" id="kobo.600.1">control exceptions</span></strong></span><span class="koboSpan" id="kobo.601.1"> are excluded from this rule. </span><span class="koboSpan" id="kobo.601.2">Control exceptions are exceptions that are used for control flow in Scala programs. </span><span class="koboSpan" id="kobo.601.3">They extend the </span><code class="literal"><span class="koboSpan" id="kobo.602.1">ControlThrowable</span></code><span class="koboSpan" id="kobo.603.1"> trait from the </span><code class="literal"><span class="koboSpan" id="kobo.604.1">scala.util.control</span></code><span class="koboSpan" id="kobo.605.1"> package, and are sometimes treated differently by the Scala compiler and runtime. </span><span class="koboSpan" id="kobo.605.2">When a control exception is thrown inside a transaction, ScalaSTM does not roll back the transaction. </span><span class="koboSpan" id="kobo.605.3">Instead, the transaction is committed.</span></p><p><span class="koboSpan" id="kobo.606.1">Control exceptions are used to support the </span><code class="literal"><span class="koboSpan" id="kobo.607.1">break</span></code><span class="koboSpan" id="kobo.608.1"> statement in Scala, which is not a native language construct. </span><span class="koboSpan" id="kobo.608.2">The </span><code class="literal"><span class="koboSpan" id="kobo.609.1">break</span></code><span class="koboSpan" id="kobo.610.1"> statement throws a control exception, which is then caught by the enclosing breakable block. </span><span class="koboSpan" id="kobo.610.2">In the next example, we define a breakable block for the </span><code class="literal"><span class="koboSpan" id="kobo.611.1">break</span></code><span class="koboSpan" id="kobo.612.1"> statement and start a transaction that calls </span><code class="literal"><span class="koboSpan" id="kobo.613.1">pop</span></code><span class="koboSpan" id="kobo.614.1"> in a </span><code class="literal"><span class="koboSpan" id="kobo.615.1">for</span></code><span class="koboSpan" id="kobo.616.1"> loop with the values </span><code class="literal"><span class="koboSpan" id="kobo.617.1">1</span></code><span class="koboSpan" id="kobo.618.1">, </span><code class="literal"><span class="koboSpan" id="kobo.619.1">2</span></code><span class="koboSpan" id="kobo.620.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.621.1">3</span></code><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">After the first iteration, we break the loop. </span><span class="koboSpan" id="kobo.622.3">The example shows that the changes in the first </span><code class="literal"><span class="koboSpan" id="kobo.623.1">pop</span></code><span class="koboSpan" id="kobo.624.1"> statement are committed. </span><span class="koboSpan" id="kobo.624.2">The transactional list now contains only the element </span><code class="literal"><span class="koboSpan" id="kobo.625.1">16</span></code><span class="koboSpan" id="kobo.626.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.627.1">import scala.util.control.Breaks._ 
Future { 
  breakable { 
    atomic { implicit txn =&gt; 
      for (n &lt;- List(1, 2, 3)) { 
        pop(lst, n) 
        break 
      } 
    } 
  } 
  log(s"after removing - $lst") 
} 
</span></pre><p><span class="koboSpan" id="kobo.628.1">Furthermore, it is possible to override how a specific transaction handles exceptions by calling the </span><code class="literal"><span class="koboSpan" id="kobo.629.1">withControlFlowRecognizer</span></code><span class="koboSpan" id="kobo.630.1"> method on the atomic block. </span><span class="koboSpan" id="kobo.630.2">This method takes a partial function from </span><code class="literal"><span class="koboSpan" id="kobo.631.1">Throwable</span></code><span class="koboSpan" id="kobo.632.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.633.1">Boolean</span></code><span class="koboSpan" id="kobo.634.1">, and uses it to decide whether a particular exception is to be considered as a control exception or not. </span><span class="koboSpan" id="kobo.634.2">If the partial function is not defined for particular exception, the decision is deferred to the default control flow recognizer.</span></p><p><span class="koboSpan" id="kobo.635.1">In the following example, the </span><code class="literal"><span class="koboSpan" id="kobo.636.1">atomic</span></code><span class="koboSpan" id="kobo.637.1"> block overrides the default control flow recognizer. </span><span class="koboSpan" id="kobo.637.2">For this specific transaction, subclasses of the </span><code class="literal"><span class="koboSpan" id="kobo.638.1">ControlThrowable</span></code><span class="koboSpan" id="kobo.639.1"> trait are considered as regular exceptions. </span><span class="koboSpan" id="kobo.639.2">The </span><code class="literal"><span class="koboSpan" id="kobo.640.1">pop</span></code><span class="koboSpan" id="kobo.641.1"> call removes the last element of the transactional list as part of this transaction, but when we call </span><code class="literal"><span class="koboSpan" id="kobo.642.1">break</span></code><span class="koboSpan" id="kobo.643.1">; the transaction is rolled back. </span><span class="koboSpan" id="kobo.643.2">The </span><code class="literal"><span class="koboSpan" id="kobo.644.1">log</span></code><span class="koboSpan" id="kobo.645.1"> statement at the end of the asynchronous computation shows that the list still contains the number </span><code class="literal"><span class="koboSpan" id="kobo.646.1">16</span></code><span class="koboSpan" id="kobo.647.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.648.1">import scala.util.control._ 
Future { 
  breakable { 
    atomic.withControlFlowRecognizer { 
      case c: ControlThrowable =&gt; false 
    } { implicit txn =&gt; 
      for (n &lt;- List(1, 2, 3)) { 
        pop(lst, n) 
        break 
      } 
    } 
  } 
  log(s"after removing - $lst") 
} 
</span></pre><p><span class="koboSpan" id="kobo.649.1">Note that the exceptions thrown inside the transactions can also be intercepted using the </span><code class="literal"><span class="koboSpan" id="kobo.650.1">catch</span></code><span class="koboSpan" id="kobo.651.1"> statement. </span><span class="koboSpan" id="kobo.651.2">In this case, the effects of the nested transactions are aborted, and the execution proceeds from the point where the exception was caught. </span><span class="koboSpan" id="kobo.651.3">In the following example, we catch the exception thrown by the second </span><code class="literal"><span class="koboSpan" id="kobo.652.1">pop</span></code><span class="koboSpan" id="kobo.653.1"> call:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.654.1">val lst = new TSortedList 
lst.insert(4).insert(9).insert(1).insert(16) 
atomic { implicit txn =&gt; 
  pop(lst, 2) 
  log(s"lst = $lst") 
  try { pop(lst, 3) } 
  catch { case e: Exception =&gt; log(s"Houston... </span><span class="koboSpan" id="kobo.654.2">$e!") } 
  pop(lst, 1) 
} 
log(s"result - $lst") 
</span></pre><p><span class="koboSpan" id="kobo.655.1">The second </span><code class="literal"><span class="koboSpan" id="kobo.656.1">pop</span></code><span class="koboSpan" id="kobo.657.1"> method call should not remove any elements from the list, so we expect to see the element </span><code class="literal"><span class="koboSpan" id="kobo.658.1">16</span></code><span class="koboSpan" id="kobo.659.1"> at the end. </span><span class="koboSpan" id="kobo.659.2">Running this code snippet results in the following output:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.660.1">run-main-26: lst = 9, 16,</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.661.1">run-main-26: lst = 9, 16,</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.662.1">run-main-26: Houston... </span><span class="koboSpan" id="kobo.662.2">java.lang.NullPointerException!</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.663.1">run-main-26: result - 16,</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.664.1">Interestingly, the output reveals that the first </span><code class="literal"><span class="koboSpan" id="kobo.665.1">log</span></code><span class="koboSpan" id="kobo.666.1"> statement is invoked twice. </span><span class="koboSpan" id="kobo.666.2">The reason is that, when the exception is thrown the first time, both the nested and the top-level transactions are rolled back. </span><span class="koboSpan" id="kobo.666.3">This is an optimization in the ScalaSTM implementation, since it is more efficient to flatten the nested and the top-level transaction during the first execution attempt. </span><span class="koboSpan" id="kobo.666.4">Note that, after the transactional block is executed the second time, the exception from the nested transaction is correctly handled.</span></p><p><span class="koboSpan" id="kobo.667.1">These examples are useful in understanding the semantics of exceptions inside the transactions. </span><span class="koboSpan" id="kobo.667.2">Still, the clients of our transactional sorted list want more than an exception when they call the </span><code class="literal"><span class="koboSpan" id="kobo.668.1">pop</span></code><span class="koboSpan" id="kobo.669.1"> method on an empty sorted list. </span><span class="koboSpan" id="kobo.669.2">In some cases, like the producer-consumer pattern from </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.670.1">Chapter 3</span></a><span class="koboSpan" id="kobo.671.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.672.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.673.1">, a thread has to wait and repeat the transaction when the sorted list becomes non-empty. </span><span class="koboSpan" id="kobo.673.2">This is called retrying, and is the topic of the next section.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Retrying transactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/><span class="koboSpan" id="kobo.1.1">Retrying transactions</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In sequential computing, a single thread is responsible for executing the program. </span><span class="koboSpan" id="kobo.2.2">If a specific value is not available, the single thread is responsible for producing it. </span><span class="koboSpan" id="kobo.2.3">In concurrent programming, the situation is different. </span><span class="koboSpan" id="kobo.2.4">When a value is not available, some other thread, called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">producer</span></strong></span><span class="koboSpan" id="kobo.4.1">, might eventually produce the value. </span><span class="koboSpan" id="kobo.4.2">The thread consuming the value, called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">consumer</span></strong></span><span class="koboSpan" id="kobo.6.1">, can either block the execution until the value becomes available, or temporarily execute some other work before checking for the value again. </span><span class="koboSpan" id="kobo.6.2">We have seen various mechanisms for achieving this relationship, ranging from monitors and the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">synchronized</span></code><span class="koboSpan" id="kobo.8.1"> statement from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.9.1">Chapter 2</span></a><span class="koboSpan" id="kobo.10.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.12.1">, concurrent queues from </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.13.1">Chapter 3</span></a><span class="koboSpan" id="kobo.14.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.16.1">; futures and promises in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.17.1">Chapter 4</span></a><span class="koboSpan" id="kobo.18.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.20.1">; to event-streams in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.21.1">Chapter 6</span></a><span class="koboSpan" id="kobo.22.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.23.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.24.1">.</span></p><p><span class="koboSpan" id="kobo.25.1">Syntactically, the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">atomic</span></code><span class="koboSpan" id="kobo.27.1"> statement best corresponds to the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">synchronized</span></code><span class="koboSpan" id="kobo.29.1"> statement. </span><span class="koboSpan" id="kobo.29.2">Recall that the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">synchronized</span></code><span class="koboSpan" id="kobo.31.1"> statement support the guarded block pattern, in which the thread acquires a monitor, checks for some condition, and then calls </span><code class="literal"><span class="koboSpan" id="kobo.32.1">wait</span></code><span class="koboSpan" id="kobo.33.1"> on the monitor. </span><span class="koboSpan" id="kobo.33.2">When some other thread fulfills this condition, it calls the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">notify</span></code><span class="koboSpan" id="kobo.35.1"> method on the same monitor, indicating that the first thread should wake up and continue its work. </span><span class="koboSpan" id="kobo.35.2">Although sometimes fragile, this mechanism allows us to circumvent busy-waiting.</span></p><p><span class="koboSpan" id="kobo.36.1">From what we have learned about STMs so far, monitors and the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">notify</span></code><span class="koboSpan" id="kobo.38.1"> method have no direct counterpart in the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">atomic</span></code><span class="koboSpan" id="kobo.40.1"> statement. </span><span class="koboSpan" id="kobo.40.2">Without them, busy-waiting is the only option when a transaction needs to wait for a specific condition to proceed. </span><span class="koboSpan" id="kobo.40.3">To illustrate this, let's consider the transactional sorted lists from the last section. </span><span class="koboSpan" id="kobo.40.4">We would like to augment the transactional sorted lists with the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">headWait</span></code><span class="koboSpan" id="kobo.42.1"> method which takes a list and returns the first integer in the list if the list is non-empty. </span><span class="koboSpan" id="kobo.42.2">Otherwise, the execution should block until the list becomes non-empty:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">def headWait(lst: TSortedList): Int = atomic { implicit txn =&gt; 
  while (lst.head() == null) {} // never do this 
  lst.head().elem 
} 
</span></pre><p><span class="koboSpan" id="kobo.44.1">The </span><code class="literal"><span class="koboSpan" id="kobo.45.1">headWait</span></code><span class="koboSpan" id="kobo.46.1"> method starts a transaction, and busy-waits until the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">head</span></code><span class="koboSpan" id="kobo.48.1"> reference of the transactional list </span><code class="literal"><span class="koboSpan" id="kobo.49.1">lst</span></code><span class="koboSpan" id="kobo.50.1"> becomes different from </span><code class="literal"><span class="koboSpan" id="kobo.51.1">null</span></code><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">To test this method, we create an empty transaction sorted list, and start an asynchronous computation that calls the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">headWait</span></code><span class="koboSpan" id="kobo.54.1"> method. </span><span class="koboSpan" id="kobo.54.2">After one second, we start another asynchronous computation that adds the number </span><code class="literal"><span class="koboSpan" id="kobo.55.1">1</span></code><span class="koboSpan" id="kobo.56.1"> to the list. </span><span class="koboSpan" id="kobo.56.2">During the one-second delay, the first asynchronous computation repetitively busy-waits:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">object RetryHeadWaitBad extends App { 
  val myList = new TSortedList 
  Future { 
    val headElem = headWait(myList) 
    log(s"The first element is $headElem") 
  } 
  Thread.sleep(1000) 
  Future { myList.insert(1) } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.58.1">The first time we ran this example, it completed successfully after one second and reported that the first element of the list is </span><code class="literal"><span class="koboSpan" id="kobo.59.1">1</span></code><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">However, this example is likely to fail. </span><span class="koboSpan" id="kobo.60.3">ScalaSTM will eventually detect that there is a conflict between the transaction in the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">headWait</span></code><span class="koboSpan" id="kobo.62.1"> method and the transaction in the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">insert</span></code><span class="koboSpan" id="kobo.64.1"> method, and will serialize the two transactions. </span><span class="koboSpan" id="kobo.64.2">In the case where the STM chooses the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">headWait</span></code><span class="koboSpan" id="kobo.66.1"> method to execute first, number </span><code class="literal"><span class="koboSpan" id="kobo.67.1">1</span></code><span class="koboSpan" id="kobo.68.1"> is never inserted into </span><code class="literal"><span class="koboSpan" id="kobo.69.1">myList</span></code><span class="koboSpan" id="kobo.70.1"> value. </span><span class="koboSpan" id="kobo.70.2">Effectively, this program ends up in a deadlock. </span><span class="koboSpan" id="kobo.70.3">This example illustrates that busy-waiting in a transaction is just as bad as busy-waiting inside a </span><code class="literal"><span class="koboSpan" id="kobo.71.1">synchronized</span></code><span class="koboSpan" id="kobo.72.1"> statement.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip81"/><span class="koboSpan" id="kobo.73.1">Tip</span></h3><p><span class="koboSpan" id="kobo.74.1">Avoid long-running transactions whenever possible. </span><span class="koboSpan" id="kobo.74.2">Never execute an infinite loop inside a transaction, as it can cause deadlocks.</span></p></div></div><p><span class="koboSpan" id="kobo.75.1">An STM is more than just support for executing isolated memory transactions. </span><span class="koboSpan" id="kobo.75.2">To fully replace monitors and the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">synchronized</span></code><span class="koboSpan" id="kobo.77.1"> statement, an STM must provide an additional utility for transactions that block until a specific condition is fulfilled. </span><span class="koboSpan" id="kobo.77.2">ScalaSTM defines the </span><code class="literal"><span class="koboSpan" id="kobo.78.1">retry</span></code><span class="koboSpan" id="kobo.79.1"> statement for this purpose. </span><span class="koboSpan" id="kobo.79.2">When the execution inside the transaction reaches a </span><code class="literal"><span class="koboSpan" id="kobo.80.1">retry</span></code><span class="koboSpan" id="kobo.81.1"> statement, the transaction is rolled back to the enclosing top-level </span><code class="literal"><span class="koboSpan" id="kobo.82.1">atomic</span></code><span class="koboSpan" id="kobo.83.1"> block with a special exception, and the calling thread is blocked. </span><span class="koboSpan" id="kobo.83.2">After the rollback, the read set of the transaction is saved.</span></p><p><span class="koboSpan" id="kobo.84.1">Values from the transactional references in the read set are the reason why the transaction decides to call the </span><code class="literal"><span class="koboSpan" id="kobo.85.1">retry</span></code><span class="koboSpan" id="kobo.86.1"> method. </span><span class="koboSpan" id="kobo.86.2">If and when some transactional reference in the read set changes its value from within another transaction, the blocked transaction can be retried.</span></p><p><span class="koboSpan" id="kobo.87.1">We now reimplement the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">headWait</span></code><span class="koboSpan" id="kobo.89.1"> method so that it calls the </span><code class="literal"><span class="koboSpan" id="kobo.90.1">retry</span></code><span class="koboSpan" id="kobo.91.1"> method if the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">head</span></code><span class="koboSpan" id="kobo.93.1"> value of the transactional list is </span><code class="literal"><span class="koboSpan" id="kobo.94.1">null</span></code><span class="koboSpan" id="kobo.95.1">, indicating that the list is empty:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.96.1">def headWait(lst: TSortedList): Int = atomic { implicit txn =&gt; 
  if (lst.head() != null) lst.head().elem 
  else retry 
} 
</span></pre><p><span class="koboSpan" id="kobo.97.1">We rerun the complete program. </span><span class="koboSpan" id="kobo.97.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">headWait</span></code><span class="koboSpan" id="kobo.99.1"> method is a potential blocking operation, so we need to use the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">blocking</span></code><span class="koboSpan" id="kobo.101.1"> call inside the asynchronous computation. </span><span class="koboSpan" id="kobo.101.2">The transaction in </span><code class="literal"><span class="koboSpan" id="kobo.102.1">headWait</span></code><span class="koboSpan" id="kobo.103.1"> reads the transactional reference </span><code class="literal"><span class="koboSpan" id="kobo.104.1">head</span></code><span class="koboSpan" id="kobo.105.1">, and puts it into the read set after calling the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">retry</span></code><span class="koboSpan" id="kobo.107.1"> method. </span><span class="koboSpan" id="kobo.107.2">When the reference </span><code class="literal"><span class="koboSpan" id="kobo.108.1">head</span></code><span class="koboSpan" id="kobo.109.1"> later changes, the transaction is automatically retried:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.110.1">object RetryHeadWait extends App { 
  val myList = new TSortedList 
  Future { 
    blocking { 
      log(s"The first element is ${headWait(myList)}") 
    } 
  } 
  Thread.sleep(1000) 
  Future { myList.insert(1) } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.111.1">This time, the program runs as expected. </span><span class="koboSpan" id="kobo.111.2">The first asynchronous computation is suspended until the second asynchronous computation adds </span><code class="literal"><span class="koboSpan" id="kobo.112.1">1</span></code><span class="koboSpan" id="kobo.113.1"> to the list. </span><span class="koboSpan" id="kobo.113.2">This awakens the first asynchronous computation and repeats the transaction.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip82"/><span class="koboSpan" id="kobo.114.1">Tip</span></h3><p><span class="koboSpan" id="kobo.115.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.116.1">retry</span></code><span class="koboSpan" id="kobo.117.1"> statement to block the transaction until a specific condition is fulfilled, and retry the transaction automatically once its read set changes.</span></p></div></div><p><span class="koboSpan" id="kobo.118.1">In some cases, when a specific condition is not fulfilled and the transaction cannot proceed, we would like to retry a different transaction. </span><span class="koboSpan" id="kobo.118.2">Assume that there are many producer threads in the program, and a single consumer thread. </span><span class="koboSpan" id="kobo.118.3">To decrease contention between the producers, we decide to introduce two transactional sorted lists called </span><code class="literal"><span class="koboSpan" id="kobo.119.1">queue1</span></code><span class="koboSpan" id="kobo.120.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.121.1">queue2</span></code><span class="koboSpan" id="kobo.122.1">. </span><span class="koboSpan" id="kobo.122.2">To avoid creating contention by simultaneously accessing both lists, the consumer thread must check the contents of these transactional sorted lists in two separate transactions. </span><span class="koboSpan" id="kobo.122.3">The </span><code class="literal"><span class="koboSpan" id="kobo.123.1">orAtomic</span></code><span class="koboSpan" id="kobo.124.1"> construct allows you to do this.</span></p><p><span class="koboSpan" id="kobo.125.1">The following snippet illustrates how to use </span><code class="literal"><span class="koboSpan" id="kobo.126.1">orAtomic</span></code><span class="koboSpan" id="kobo.127.1"> in this situation. </span><span class="koboSpan" id="kobo.127.2">We instantiate two empty transactional sorted lists: </span><code class="literal"><span class="koboSpan" id="kobo.128.1">queue1</span></code><span class="koboSpan" id="kobo.129.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.130.1">queue2</span></code><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">We then start an asynchronous computation that represents the consumer and starts a transaction that calls the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">headWait</span></code><span class="koboSpan" id="kobo.133.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.134.1">queue1</span></code><span class="koboSpan" id="kobo.135.1"> list. </span><span class="koboSpan" id="kobo.135.2">We call the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">orAtomic</span></code><span class="koboSpan" id="kobo.137.1"> method after the first transaction. </span><span class="koboSpan" id="kobo.137.2">This specifies an alternative transaction if the first transaction calls </span><code class="literal"><span class="koboSpan" id="kobo.138.1">retry</span></code><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">In the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">orAtomic</span></code><span class="koboSpan" id="kobo.141.1"> block, we call the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">headWait</span></code><span class="koboSpan" id="kobo.143.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.144.1">queue2</span></code><span class="koboSpan" id="kobo.145.1"> list. </span><span class="koboSpan" id="kobo.145.2">When the first </span><code class="literal"><span class="koboSpan" id="kobo.146.1">atomic</span></code><span class="koboSpan" id="kobo.147.1"> block calls the </span><code class="literal"><span class="koboSpan" id="kobo.148.1">retry</span></code><span class="koboSpan" id="kobo.149.1"> method, the control is passed to the </span><code class="literal"><span class="koboSpan" id="kobo.150.1">orAtomic</span></code><span class="koboSpan" id="kobo.151.1"> block, and a different transaction starts.</span></p><p><span class="koboSpan" id="kobo.152.1">Since both the transactional lists, </span><code class="literal"><span class="koboSpan" id="kobo.153.1">queue1</span></code><span class="koboSpan" id="kobo.154.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.155.1">queue2</span></code><span class="koboSpan" id="kobo.156.1">, are initially empty, the second transaction also calls the </span><code class="literal"><span class="koboSpan" id="kobo.157.1">retry</span></code><span class="koboSpan" id="kobo.158.1"> method, and the transaction chain is blocked until one of the transactional lists changes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.159.1">val queue1 = new TSortedList 
val queue2 = new TSortedList 
val consumer = Future { 
  blocking { 
    atomic { implicit txn =&gt; 
      log(s"probing queue1") 
      log(s"got: ${headWait(queue1)}") 
    } orAtomic { implicit txn =&gt; 
      log(s"probing queue2") 
      log(s"got: ${headWait(queue2)}") 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.160.1">We now simulate several producers that call the </span><code class="literal"><span class="koboSpan" id="kobo.161.1">insert</span></code><span class="koboSpan" id="kobo.162.1"> method 50 milliseconds later:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.163.1">Thread.sleep(50) 
Future { queue2.insert(2) } 
Thread.sleep(50) 
Future { queue1.insert(1) } 
Thread.sleep(2000) 
</span></pre><p><span class="koboSpan" id="kobo.164.1">The consumer first prints the </span><code class="literal"><span class="koboSpan" id="kobo.165.1">"probing queue1"</span></code><span class="koboSpan" id="kobo.166.1"> string, calls the </span><code class="literal"><span class="koboSpan" id="kobo.167.1">retry</span></code><span class="koboSpan" id="kobo.168.1"> method inside the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">headWait</span></code><span class="koboSpan" id="kobo.170.1"> method, and proceeds to the next transaction. </span><span class="koboSpan" id="kobo.170.2">It prints the </span><code class="literal"><span class="koboSpan" id="kobo.171.1">"probing queue2"</span></code><span class="koboSpan" id="kobo.172.1"> string in the same way and then blocks its execution. </span><span class="koboSpan" id="kobo.172.2">After the first producer computation inserts </span><code class="literal"><span class="koboSpan" id="kobo.173.1">2</span></code><span class="koboSpan" id="kobo.174.1"> into the second transactional list, the consumer retries the chain of transactions again. </span><span class="koboSpan" id="kobo.174.2">It attempts to execute the first transaction and prints the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">"probing queue1"</span></code><span class="koboSpan" id="kobo.176.1"> string again before finding that the </span><code class="literal"><span class="koboSpan" id="kobo.177.1">queue1</span></code><span class="koboSpan" id="kobo.178.1"> list is empty. </span><span class="koboSpan" id="kobo.178.2">It then prints the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">"probing queue2"</span></code><span class="koboSpan" id="kobo.180.1"> string and successfully outputs the element </span><code class="literal"><span class="koboSpan" id="kobo.181.1">2</span></code><span class="koboSpan" id="kobo.182.1"> from the </span><code class="literal"><span class="koboSpan" id="kobo.183.1">queue2</span></code><span class="koboSpan" id="kobo.184.1"> list.</span></p><div class="section" title="Retrying with timeouts"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec67"/><span class="koboSpan" id="kobo.185.1">Retrying with timeouts</span></h2></div></div></div><p><span class="koboSpan" id="kobo.186.1">We have seen that it is useful to suspend a transaction until a specific condition gets fulfilled. </span><span class="koboSpan" id="kobo.186.2">In some cases, we want to prevent a transaction from being blocked forever. </span><span class="koboSpan" id="kobo.186.3">The </span><code class="literal"><span class="koboSpan" id="kobo.187.1">wait</span></code><span class="koboSpan" id="kobo.188.1"> method on the object monitors comes with an overload that takes the timeout argument. </span><span class="koboSpan" id="kobo.188.2">When the timeout elapses without a </span><code class="literal"><span class="koboSpan" id="kobo.189.1">notify</span></code><span class="koboSpan" id="kobo.190.1"> call from some other thread, an </span><code class="literal"><span class="koboSpan" id="kobo.191.1">InterruptedException</span></code><span class="koboSpan" id="kobo.192.1"> is thrown. </span><span class="koboSpan" id="kobo.192.2">The ScalaSTM </span><code class="literal"><span class="koboSpan" id="kobo.193.1">withRetryTimeout</span></code><span class="koboSpan" id="kobo.194.1"> method is a similar mechanism for handling timeouts.</span></p><p><span class="koboSpan" id="kobo.195.1">In the following code snippet, we create a </span><code class="literal"><span class="koboSpan" id="kobo.196.1">message</span></code><span class="koboSpan" id="kobo.197.1"> transactional reference that initially contains an empty string. </span><span class="koboSpan" id="kobo.197.2">We then start an </span><code class="literal"><span class="koboSpan" id="kobo.198.1">atomic</span></code><span class="koboSpan" id="kobo.199.1"> block whose timeout is set to </span><code class="literal"><span class="koboSpan" id="kobo.200.1">1000</span></code><span class="koboSpan" id="kobo.201.1"> milliseconds. </span><span class="koboSpan" id="kobo.201.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">message</span></code><span class="koboSpan" id="kobo.203.1"> transactional reference does not change its value within that time, the transaction fails by throwing an </span><code class="literal"><span class="koboSpan" id="kobo.204.1">InterruptedException</span></code><span class="koboSpan" id="kobo.205.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.206.1">val message = Ref("") 
Future { 
  blocking { 
    atomic.withRetryTimeout(1000) { implicit txn =&gt; 
      if (message() != "") log(s"got a message - ${message()}") 
      else retry 
    } 
  } 
} 
Thread.sleep(1025) 
message.single() = "Howdy!" 
</span></pre><p><span class="koboSpan" id="kobo.207.1">We deliberately set the timeout to </span><code class="literal"><span class="koboSpan" id="kobo.208.1">1025</span></code><span class="koboSpan" id="kobo.209.1"> milliseconds to create a race condition. </span><span class="koboSpan" id="kobo.209.2">This program will either print the </span><code class="literal"><span class="koboSpan" id="kobo.210.1">"Howdy!"</span></code><span class="koboSpan" id="kobo.211.1"> message or fail with an exception.</span></p><p><span class="koboSpan" id="kobo.212.1">We use the </span><code class="literal"><span class="koboSpan" id="kobo.213.1">withRetryTimeout</span></code><span class="koboSpan" id="kobo.214.1"> method when timing out is an exceptional behavior. </span><span class="koboSpan" id="kobo.214.2">Shutting down the application is one example of such a behavior. </span><span class="koboSpan" id="kobo.214.3">We want to avoid having a blocked transaction that prevents the program from terminating. </span><span class="koboSpan" id="kobo.214.4">Another example is waiting for a network reply. </span><span class="koboSpan" id="kobo.214.5">If there is no reply after some duration of time, we want to fail the transaction.</span></p><p><span class="koboSpan" id="kobo.215.1">In some cases, a timeout is a part of a normal program behavior. </span><span class="koboSpan" id="kobo.215.2">In this case, we wait for a specific amount of time for conditions relevant to the transaction to change. </span><span class="koboSpan" id="kobo.215.3">If they do, we roll back and retry the transaction, as before. </span><span class="koboSpan" id="kobo.215.4">If the specified amount of time elapses without any changes, the transaction should continue. </span><span class="koboSpan" id="kobo.215.5">In ScalaSTM, the method that does this is called </span><code class="literal"><span class="koboSpan" id="kobo.216.1">retryFor</span></code><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">In the following code snippet, we rewrite the previous example using the </span><code class="literal"><span class="koboSpan" id="kobo.218.1">retryFor</span></code><span class="koboSpan" id="kobo.219.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.220.1">Future { 
  blocking { 
    atomic { implicit txn =&gt; 
      if (message() == "") { 
        retryFor(1000) 
        log(s"no message.") 
      } else log(s"got a message - '${message()}'") 
    } 
  } 
} 
Thread.sleep(1025) 
message.single() = "Howdy!" 
</span></pre><p><span class="koboSpan" id="kobo.221.1">This time, the transaction inside the asynchronous computation does not throw an exception. </span><span class="koboSpan" id="kobo.221.2">Instead, the transaction prints the </span><code class="literal"><span class="koboSpan" id="kobo.222.1">"no message."</span></code><span class="koboSpan" id="kobo.223.1"> string if a timeout occurs.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip83"/><span class="koboSpan" id="kobo.224.1">Tip</span></h3><p><span class="koboSpan" id="kobo.225.1">When a timeout represents exceptional program behavior, use the </span><code class="literal"><span class="koboSpan" id="kobo.226.1">withRetryTimeout</span></code><span class="koboSpan" id="kobo.227.1"> method to set the timeout duration in the transaction. </span><span class="koboSpan" id="kobo.227.2">When the transaction proceeds normally after a timeout, use the </span><code class="literal"><span class="koboSpan" id="kobo.228.1">retryFor</span></code><span class="koboSpan" id="kobo.229.1"> method.</span></p></div></div><p><span class="koboSpan" id="kobo.230.1">The different </span><code class="literal"><span class="koboSpan" id="kobo.231.1">retry</span></code><span class="koboSpan" id="kobo.232.1"> variants are the ScalaSTM powerful additions to the standard STM model. </span><span class="koboSpan" id="kobo.232.2">They are as expressive as the </span><code class="literal"><span class="koboSpan" id="kobo.233.1">wait</span></code><span class="koboSpan" id="kobo.234.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.235.1">notify</span></code><span class="koboSpan" id="kobo.236.1"> calls, and much safer to use. </span><span class="koboSpan" id="kobo.236.2">Together with the </span><code class="literal"><span class="koboSpan" id="kobo.237.1">atomic</span></code><span class="koboSpan" id="kobo.238.1"> statement, they unleash the full potential of synchronization.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Transactional collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/><span class="koboSpan" id="kobo.1.1">Transactional collections</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this section, we take a step away from transactional references, and study more powerful transactional constructs, called, transactional collections. </span><span class="koboSpan" id="kobo.2.2">While transactional references can only hold a single value at once, transactional collections can manipulate multiple values. </span><span class="koboSpan" id="kobo.2.3">In principle, the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">atomic</span></code><span class="koboSpan" id="kobo.4.1"> statements and transactional references are sufficient to express any kind of transaction over shared data. </span><span class="koboSpan" id="kobo.4.2">However, ScalaSTM's transactional collections are deeply integrated with the STM. </span><span class="koboSpan" id="kobo.4.3">They can be used to express shared data operations more conveniently and execute the transactions more efficiently.</span></p><div class="section" title="Transaction-local variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec68"/><span class="koboSpan" id="kobo.5.1">Transaction-local variables</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">We have already seen that some transactions need to create a local mutable state that exists only during the execution of the transaction. </span><span class="koboSpan" id="kobo.6.2">Sometimes, we need to re-declare the same state over and over again for multiple transactions. </span><span class="koboSpan" id="kobo.6.3">In such cases, we would like to declare the same state once, and reuse it in multiple transactions. </span><span class="koboSpan" id="kobo.6.4">A construct that supports this in ScalaSTM is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">transaction-local variable</span></strong></span><span class="koboSpan" id="kobo.8.1">.</span></p><p><span class="koboSpan" id="kobo.9.1">To declare a transaction-local variable, we instantiate an object of the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">TxnLocal[T]</span></code><span class="koboSpan" id="kobo.11.1"> type, giving it an initial value of type </span><code class="literal"><span class="koboSpan" id="kobo.12.1">T</span></code><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">In the following code, we instantiate a </span><code class="literal"><span class="koboSpan" id="kobo.14.1">myLog</span></code><span class="koboSpan" id="kobo.15.1"> transaction-local variable. </span><span class="koboSpan" id="kobo.15.2">We will use </span><code class="literal"><span class="koboSpan" id="kobo.16.1">myLog</span></code><span class="koboSpan" id="kobo.17.1"> inside the transactional sorted list operations to log the flow of different transactions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">val myLog = TxnLocal("") 
</span></pre><p><span class="koboSpan" id="kobo.19.1">The value of the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">myLog</span></code><span class="koboSpan" id="kobo.21.1"> transaction-local variable is seen separately by each transaction. </span><span class="koboSpan" id="kobo.21.2">When a transaction starts, the value of </span><code class="literal"><span class="koboSpan" id="kobo.22.1">myLog</span></code><span class="koboSpan" id="kobo.23.1"> is equal to an empty string, as specified when </span><code class="literal"><span class="koboSpan" id="kobo.24.1">myLog</span></code><span class="koboSpan" id="kobo.25.1"> was declared. </span><span class="koboSpan" id="kobo.25.2">When the transaction updates the value of the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">myLog</span></code><span class="koboSpan" id="kobo.27.1"> variable, this change is only visible to that specific transaction. </span><span class="koboSpan" id="kobo.27.2">Other transactions behave as if they have their own separate copies of </span><code class="literal"><span class="koboSpan" id="kobo.28.1">myLog</span></code><span class="koboSpan" id="kobo.29.1"> variable.</span></p><p><span class="koboSpan" id="kobo.30.1">We now declare a </span><code class="literal"><span class="koboSpan" id="kobo.31.1">clearList</span></code><span class="koboSpan" id="kobo.32.1"> method that atomically removes all elements from the specified transactional sorted list. </span><span class="koboSpan" id="kobo.32.2">This method uses the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">myLog</span></code><span class="koboSpan" id="kobo.34.1"> variable to log the elements that were removed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">def clearList(lst: TSortedList): Unit = atomic { implicit txn =&gt; 
  while (lst.head() != null) { 
    myLog() = myLog() + "\nremoved " + lst.head().elem 
    lst.head() = lst.head().next() 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">Usually, we are not interested in the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">myLog</span></code><span class="koboSpan" id="kobo.38.1"> variable. </span><span class="koboSpan" id="kobo.38.2">However, we might occasionally want to inspect the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">myLog</span></code><span class="koboSpan" id="kobo.40.1"> variable for debugging purposes. </span><span class="koboSpan" id="kobo.40.2">Hence, we declare the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">clearWithLog</span></code><span class="koboSpan" id="kobo.42.1"> method that clears the list and then returns the contents of </span><code class="literal"><span class="koboSpan" id="kobo.43.1">myLog</span></code><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">clearWithLog</span></code><span class="koboSpan" id="kobo.46.1"> method on a non-empty transactional list from two separate asynchronous computations. </span><span class="koboSpan" id="kobo.46.2">After both asynchronous computations complete execution, we output their logs:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">val myList = new TSortedList().insert(14).insert(22) 
def clearWithLog(): String = atomic { implicit txn =&gt; 
  clearList(myList)  
  myLog() 
} 
val f = Future { clearWithLog() } 
val g = Future { clearWithLog() } 
for (h1 &lt;- f; h2 &lt;- g) log(s"Log for f: $h1\nLog for g: $h2") 
</span></pre><p><span class="koboSpan" id="kobo.48.1">Since the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">clearList</span></code><span class="koboSpan" id="kobo.50.1"> operation is atomic, only one of the transactions can remove all the elements. </span><span class="koboSpan" id="kobo.50.2">The contents of the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">myLog</span></code><span class="koboSpan" id="kobo.52.1"> object reflect this. </span><span class="koboSpan" id="kobo.52.2">Depending on the timing between the asynchronous computations, elements </span><code class="literal"><span class="koboSpan" id="kobo.53.1">14</span></code><span class="koboSpan" id="kobo.54.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.55.1">22</span></code><span class="koboSpan" id="kobo.56.1"> both appear either in the log of the </span><code class="literal"><span class="koboSpan" id="kobo.57.1">f</span></code><span class="koboSpan" id="kobo.58.1"> future or in the log of the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">g</span></code><span class="koboSpan" id="kobo.60.1"> future. </span><span class="koboSpan" id="kobo.60.2">This shows that each of the two transactions sees a separate duplicate of the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">myLog</span></code><span class="koboSpan" id="kobo.62.1"> variable.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip84"/><span class="koboSpan" id="kobo.63.1">Tip</span></h3><p><span class="koboSpan" id="kobo.64.1">Transaction-local variables are syntactically more lightweight than creating transactional references and passing them between different methods.</span></p></div></div><p><span class="koboSpan" id="kobo.65.1">Transaction-local variables are used while logging or gathering statistics on the execution of the program. </span><span class="koboSpan" id="kobo.65.2">The </span><code class="literal"><span class="koboSpan" id="kobo.66.1">TxnLocal</span></code><span class="koboSpan" id="kobo.67.1"> constructor additionally allows you to specify the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">afterCommit</span></code><span class="koboSpan" id="kobo.69.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.70.1">afterRollback</span></code><span class="koboSpan" id="kobo.71.1"> callbacks, invoked on the transaction-local variable when the transaction commits or rolls back, respectively. </span><span class="koboSpan" id="kobo.71.2">We refer the reader to the online documentation to find out how to use them. </span><span class="koboSpan" id="kobo.71.3">To build more complex concurrent data models, we use transactional arrays and maps, which we will study in the next section.</span></p></div><div class="section" title="Transactional arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec69"/><span class="koboSpan" id="kobo.72.1">Transactional arrays</span></h2></div></div></div><p><span class="koboSpan" id="kobo.73.1">Transactional references are a handy way to encapsulate a transactional state, but they come with certain overheads. </span><span class="koboSpan" id="kobo.73.2">First, a </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Ref</span></code><span class="koboSpan" id="kobo.75.1"> object is more heavyweight than a simple object reference and consumes more memory. </span><span class="koboSpan" id="kobo.75.2">Second, every access to a new </span><code class="literal"><span class="koboSpan" id="kobo.76.1">Ref</span></code><span class="koboSpan" id="kobo.77.1"> object needs to add an entry in the transaction's read set. </span><span class="koboSpan" id="kobo.77.2">When we are dealing with many </span><code class="literal"><span class="koboSpan" id="kobo.78.1">Ref</span></code><span class="koboSpan" id="kobo.79.1"> objects, these overheads can become substantial. </span><span class="koboSpan" id="kobo.79.2">Let's illustrate this with an example.</span></p><p><span class="koboSpan" id="kobo.80.1">Assume that we are working in the marketing department of a company that does Scala consulting. </span><span class="koboSpan" id="kobo.80.2">We are asked to write a program that updates the content of the company website with the marketing information about the Scala 2.10 release. </span><span class="koboSpan" id="kobo.80.3">Naturally, we decide to use ScalaSTM for this task. </span><span class="koboSpan" id="kobo.80.4">The website consists of five separate pages, each represented with a string. </span><span class="koboSpan" id="kobo.80.5">We declare the contents of the website in a sequence called </span><code class="literal"><span class="koboSpan" id="kobo.81.1">pages</span></code><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">We then assign the content of the pages to an array of transactional references. </span><span class="koboSpan" id="kobo.82.3">If some page changes later, we can update its transactional reference in a transaction:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.83.1">val pages: Seq[String] = Seq.fill(5)("Scala 2.10 is out, " * 7) 
val website: Array[Ref[String]] = pages.map(Ref(_)).toArray 
</span></pre><p><span class="koboSpan" id="kobo.84.1">This solution is not satisfactory. </span><span class="koboSpan" id="kobo.84.2">We created a lot of transactional reference objects, and the definition of </span><code class="literal"><span class="koboSpan" id="kobo.85.1">website</span></code><span class="koboSpan" id="kobo.86.1"> is not easily understandable. </span><span class="koboSpan" id="kobo.86.2">Luckily, ScalaSTM has an alternative called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.87.1">transactional array</span></strong></span><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">A transactional array, represented with the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">TArray</span></code><span class="koboSpan" id="kobo.90.1"> class, is similar to an ordinary Scala array, but can be accessed only from within a transaction. </span><span class="koboSpan" id="kobo.90.2">Its modifications are only made visible to the other threads when a transaction commits. </span><span class="koboSpan" id="kobo.90.3">Semantically, a </span><code class="literal"><span class="koboSpan" id="kobo.91.1">TArray</span></code><span class="koboSpan" id="kobo.92.1"> class corresponds to an array of transactional references, but it is more memory-efficient and concise:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.93.1">val pages: Seq[String] = Seq.fill(5)("Scala 2.10 is out, " * 7) 
val website: TArray[String] = TArray(pages) 
</span></pre><p><span class="koboSpan" id="kobo.94.1">Scala development proceeds at an amazing pace. </span><span class="koboSpan" id="kobo.94.2">Not long after Scala 2.10 was announced, the 2.11 release of Scala became available. </span><span class="koboSpan" id="kobo.94.3">The marketing team asks us to update the contents of the website. </span><span class="koboSpan" id="kobo.94.4">All occurrences of the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">"2.10"</span></code><span class="koboSpan" id="kobo.96.1"> string should be replaced with the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">"2.11"</span></code><span class="koboSpan" id="kobo.98.1"> string. </span><span class="koboSpan" id="kobo.98.2">We write a </span><code class="literal"><span class="koboSpan" id="kobo.99.1">replace</span></code><span class="koboSpan" id="kobo.100.1"> method that does this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.101.1">def replace(p: String, s: String): Unit = atomic { implicit txn =&gt; 
  for (i &lt;- 0 until website.length) 
    website(i) = website(i).replace(p, s) 
} 
</span></pre><p><span class="koboSpan" id="kobo.102.1">Using the </span><code class="literal"><span class="koboSpan" id="kobo.103.1">TArray</span></code><span class="koboSpan" id="kobo.104.1"> class is much nicer than storing transactional references in an array. </span><span class="koboSpan" id="kobo.104.2">Not only does it spare us from a parenthesis soup resulting from calling the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">apply</span></code><span class="koboSpan" id="kobo.106.1"> operation on the transactional references in the array, but it also occupies less memory. </span><span class="koboSpan" id="kobo.106.2">This is because a single contiguous array object is created for the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">TArray[T]</span></code><span class="koboSpan" id="kobo.108.1"> object, whereas an </span><code class="literal"><span class="koboSpan" id="kobo.109.1">Array[Ref[T]]</span></code><span class="koboSpan" id="kobo.110.1"> object requires many </span><code class="literal"><span class="koboSpan" id="kobo.111.1">Ref</span></code><span class="koboSpan" id="kobo.112.1"> objects, each of which has a memory overhead.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip85"/><span class="koboSpan" id="kobo.113.1">Tip</span></h3><p><span class="koboSpan" id="kobo.114.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.115.1">TArray</span></code><span class="koboSpan" id="kobo.116.1"> class instead of arrays of transactional references to optimize memory usage and make programs more concise.</span></p></div></div><p><span class="koboSpan" id="kobo.117.1">Let's test the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">TArray</span></code><span class="koboSpan" id="kobo.119.1"> class and the </span><code class="literal"><span class="koboSpan" id="kobo.120.1">replace</span></code><span class="koboSpan" id="kobo.121.1"> method in a short program. </span><span class="koboSpan" id="kobo.121.2">We first define an additional method, </span><code class="literal"><span class="koboSpan" id="kobo.122.1">asString</span></code><span class="koboSpan" id="kobo.123.1">, which concatenates the contents of all the website pages. </span><span class="koboSpan" id="kobo.123.2">We then replace all occurrences of the </span><code class="literal"><span class="koboSpan" id="kobo.124.1">2.10</span></code><span class="koboSpan" id="kobo.125.1"> string with the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">2.11</span></code><span class="koboSpan" id="kobo.127.1"> string. </span><span class="koboSpan" id="kobo.127.2">To test whether </span><code class="literal"><span class="koboSpan" id="kobo.128.1">replace</span></code><span class="koboSpan" id="kobo.129.1"> works correctly, we concurrently replace all occurrences of the </span><code class="literal"><span class="koboSpan" id="kobo.130.1">out</span></code><span class="koboSpan" id="kobo.131.1"> word with </span><code class="literal"><span class="koboSpan" id="kobo.132.1">"released"</span></code><span class="koboSpan" id="kobo.133.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.134.1">def asString = atomic { implicit txn =&gt; 
  var s: String = "" 
  for (i &lt;- 0 until website.length) 
    s += s"Page $i\n======\n${website(i)}\n\n" 
  s 
} 
val f = Future { replace("2.10", "2.11") } 
val g = Future { replace("out", "released") } 
for (_ &lt;- f; _ &lt;- g) log(s"Document\n$asString") 
</span></pre><p><span class="koboSpan" id="kobo.135.1">The </span><code class="literal"><span class="koboSpan" id="kobo.136.1">asString</span></code><span class="koboSpan" id="kobo.137.1"> method captured all the entries in the transactional array. </span><span class="koboSpan" id="kobo.137.2">In effect, the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">asString</span></code><span class="koboSpan" id="kobo.139.1"> method atomically produced a snapshot of the state of the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">TArray</span></code><span class="koboSpan" id="kobo.141.1"> object. </span><span class="koboSpan" id="kobo.141.2">Alternatively, we could have copied the contents of </span><code class="literal"><span class="koboSpan" id="kobo.142.1">website</span></code><span class="koboSpan" id="kobo.143.1"> into another </span><code class="literal"><span class="koboSpan" id="kobo.144.1">TArray</span></code><span class="koboSpan" id="kobo.145.1"> object, instead of a string. </span><span class="koboSpan" id="kobo.145.2">In either case, computing the snapshot of a </span><code class="literal"><span class="koboSpan" id="kobo.146.1">TArray</span></code><span class="koboSpan" id="kobo.147.1"> object requires traversing all its entries, and can conflict with the transactions that modify only a subset of the </span><code class="literal"><span class="koboSpan" id="kobo.148.1">TArray</span></code><span class="koboSpan" id="kobo.149.1"> class.</span></p><p><span class="koboSpan" id="kobo.150.1">Recall the transactional conflict example from the beginning of this chapter. </span><span class="koboSpan" id="kobo.150.2">A transaction with many reads and writes, as in the </span><code class="literal"><span class="koboSpan" id="kobo.151.1">asString</span></code><span class="koboSpan" id="kobo.152.1"> method, can be inefficient, because all the other transactions need to serialize with the </span><code class="literal"><span class="koboSpan" id="kobo.153.1">asString</span></code><span class="koboSpan" id="kobo.154.1"> method when a conflict occurs. </span><span class="koboSpan" id="kobo.154.2">When the array is large, this creates a scalability bottleneck. </span><span class="koboSpan" id="kobo.154.3">In the next section, we will examine another collection capable of producing atomic snapshots in a much more scalable manner, namely, the transactional maps.</span></p></div><div class="section" title="Transactional maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/><span class="koboSpan" id="kobo.155.1">Transactional maps</span></h2></div></div></div><p><span class="koboSpan" id="kobo.156.1">Similar to transactional arrays, transactional maps avoid the need to store transactional reference objects inside a map. </span><span class="koboSpan" id="kobo.156.2">As a consequence, they reduce memory consumption, improve the transaction performance, and provide a more intuitive syntax. </span><span class="koboSpan" id="kobo.156.3">In ScalaSTM, transactional maps are represented with the </span><code class="literal"><span class="koboSpan" id="kobo.157.1">TMap</span></code><span class="koboSpan" id="kobo.158.1"> class.</span></p><p><span class="koboSpan" id="kobo.159.1">ScalaSTM's </span><code class="literal"><span class="koboSpan" id="kobo.160.1">TMap</span></code><span class="koboSpan" id="kobo.161.1"> class has an additional advantage. </span><span class="koboSpan" id="kobo.161.2">It exposes a scalable, constant-time, atomic </span><code class="literal"><span class="koboSpan" id="kobo.162.1">snapshot</span></code><span class="koboSpan" id="kobo.163.1"> operation. </span><span class="koboSpan" id="kobo.163.2">The </span><code class="literal"><span class="koboSpan" id="kobo.164.1">snapshot</span></code><span class="koboSpan" id="kobo.165.1"> operation returns an immutable </span><code class="literal"><span class="koboSpan" id="kobo.166.1">Map</span></code><span class="koboSpan" id="kobo.167.1"> object with the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.168.1">TMap</span></code><span class="koboSpan" id="kobo.169.1"> object at the time of the snapshot. </span><span class="koboSpan" id="kobo.169.2">Let's declare a transactional map, </span><code class="literal"><span class="koboSpan" id="kobo.170.1">alphabet</span></code><span class="koboSpan" id="kobo.171.1">, which maps character strings to their position in the alphabet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.172.1">val alphabet = TMap("a" -&gt; 1, "B" -&gt; 2, "C" -&gt; 3) 
</span></pre><p><span class="koboSpan" id="kobo.173.1">We are unsatisfied with the fact that the letter </span><code class="literal"><span class="koboSpan" id="kobo.174.1">A</span></code><span class="koboSpan" id="kobo.175.1"> is in lowercase. </span><span class="koboSpan" id="kobo.175.2">We start a transaction that atomically replaces the lowercase letter </span><code class="literal"><span class="koboSpan" id="kobo.176.1">a</span></code><span class="koboSpan" id="kobo.177.1"> with the uppercase letter </span><code class="literal"><span class="koboSpan" id="kobo.178.1">A</span></code><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">Simultaneously, we start another asynchronous computation that calls the </span><code class="literal"><span class="koboSpan" id="kobo.180.1">snapshot</span></code><span class="koboSpan" id="kobo.181.1"> operation on the </span><code class="literal"><span class="koboSpan" id="kobo.182.1">alphabet</span></code><span class="koboSpan" id="kobo.183.1"> map. </span><span class="koboSpan" id="kobo.183.2">We tune the timing of the second asynchronous computation so that it creates a race condition with the first transaction:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.184.1">Future { 
  atomic { implicit txn =&gt; 
    alphabet("A") = 1 
    alphabet.remove("a") 
  } 
} 
Thread.sleep(23) 
Future { 
  val snap = alphabet.single.snapshot 
  log(s"atomic snapshot: $snap") 
} 
Thread.sleep(2000) 
</span></pre><p><span class="koboSpan" id="kobo.185.1">In this example, the </span><code class="literal"><span class="koboSpan" id="kobo.186.1">snapshot</span></code><span class="koboSpan" id="kobo.187.1"> operation cannot interleave with the two updates in the </span><code class="literal"><span class="koboSpan" id="kobo.188.1">atomic</span></code><span class="koboSpan" id="kobo.189.1"> block. </span><span class="koboSpan" id="kobo.189.2">We can run the program several times to convince ourselves of this. </span><span class="koboSpan" id="kobo.189.3">The second asynchronous computation prints either the map with the lowercase letter </span><code class="literal"><span class="koboSpan" id="kobo.190.1">a</span></code><span class="koboSpan" id="kobo.191.1">, or the map with the uppercase letter </span><code class="literal"><span class="koboSpan" id="kobo.192.1">A</span></code><span class="koboSpan" id="kobo.193.1">, but it can never output a map with both the lowercase and the uppercase occurrence of the letter </span><code class="literal"><span class="koboSpan" id="kobo.194.1">A</span></code><span class="koboSpan" id="kobo.195.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip86"/><span class="koboSpan" id="kobo.196.1">Tip</span></h3><p><span class="koboSpan" id="kobo.197.1">Use </span><code class="literal"><span class="koboSpan" id="kobo.198.1">TMap</span></code><span class="koboSpan" id="kobo.199.1"> (instead of maps of transactional references) to optimize memory usage, make programs more concise, and efficiently retrieve atomic snapshots.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned how STM works and how to apply it in concurrent programs. </span><span class="koboSpan" id="kobo.2.2">We saw the advantages of using STM's transactional references and </span><code class="literal"><span class="koboSpan" id="kobo.3.1">atomic</span></code><span class="koboSpan" id="kobo.4.1"> blocks over the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">synchronized</span></code><span class="koboSpan" id="kobo.6.1"> statements, and investigated their interaction with side effects. </span><span class="koboSpan" id="kobo.6.2">We studied the semantics of exception handling inside transactions and learned how to retry and conditionally re-execute transactions. </span><span class="koboSpan" id="kobo.6.3">Finally, we learned about transactional collections, which allow us to encode shared program data more efficiently.</span></p><p><span class="koboSpan" id="kobo.7.1">These features together enable a concurrent programming model in which the programmer can focus on expressing the meaning of the program, without having to worry about handling lock objects, or avoiding deadlocks and race conditions. </span><span class="koboSpan" id="kobo.7.2">This is especially important when it comes to modularity. </span><span class="koboSpan" id="kobo.7.3">It is hard or near impossible to reason about deadlocks or race conditions in the presence of separate software components. </span><span class="koboSpan" id="kobo.7.4">STM exists to liberate the programmer from such concerns, and is essential when composing large concurrent programs from simpler modules.</span></p><p><span class="koboSpan" id="kobo.8.1">These advantages come with a cost, however, as using an STM for data access is slower than using locks and the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">synchronized</span></code><span class="koboSpan" id="kobo.10.1"> statement. </span><span class="koboSpan" id="kobo.10.2">For many applications, the performance penalty of using an STM is acceptable. </span><span class="koboSpan" id="kobo.10.3">When it is not, we need to revert to simpler primitives, such as locks, atomic variables, and concurrent data structures.</span></p><p><span class="koboSpan" id="kobo.11.1">To learn more about STMs, we recommend reading the related chapter in the book </span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">The Art of Multiprocessor Programming</span></em></span><span class="koboSpan" id="kobo.13.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">Maurice Herlihy and Nir Shavit</span></em></span><span class="koboSpan" id="kobo.15.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">Morgan Kauffman</span></em></span><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">There are many different STM implementations in the wild, and you will need to study various research articles to obtain an in-depth understanding of STMs. </span><span class="koboSpan" id="kobo.17.3">An extensive list of STM research literature is available at </span><a class="ulink" href="http://research.cs.wisc.edu/trans-memory/biblio/index.html"><span class="koboSpan" id="kobo.18.1">http://research.cs.wisc.edu/trans-memory/biblio/index.html</span></a><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">To learn more about the specifics of ScalaSTM, consider reading the doctoral thesis entitled </span><span class="emphasis"><em><span class="koboSpan" id="kobo.20.1">Composable Operations on High-Performance Concurrent Collections</span></em></span><span class="koboSpan" id="kobo.21.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.22.1">Nathan G. </span><span class="koboSpan" id="kobo.22.2">Bronson</span></em></span><span class="koboSpan" id="kobo.23.1">.</span></p><p><span class="koboSpan" id="kobo.24.1">In the next chapter, we will study the actor programming model, which takes a different approach to achieving memory consistency. </span><span class="koboSpan" id="kobo.24.2">As we will see, separate computations never access each other's regions of memory in the actor model, and communicate mainly by exchanging messages.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the following exercises, you will use ScalaSTM to implement various transactional programming abstractions. </span><span class="koboSpan" id="kobo.2.2">In most cases, their implementation will closely resemble a sequential implementation, while using transactions. </span><span class="koboSpan" id="kobo.2.3">In some cases, you might need to consult external literature or ScalaSTM documentation to correctly solve the exercise.</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Implement the transactional pair abstraction, represented with the </span><code class="literal"><span class="koboSpan" id="kobo.4.1">TPair</span></code><span class="koboSpan" id="kobo.5.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.6.1">        class TPair[P, Q](pinit: P, qinit: Q) { 
          def first(implicit txn: InTxn): P = ??? 
          </span><span class="koboSpan" id="kobo.6.2">def first_=(x: P)(implicit txn: InTxn): P = ??? 
          </span><span class="koboSpan" id="kobo.6.3">def second(implicit txn: InTxn): Q = ??? 
          </span><span class="koboSpan" id="kobo.6.4">def second_=(x: Q)(implicit txn: InTxn): Q = ??? 
          </span><span class="koboSpan" id="kobo.6.5">def swap()(implicit e: P =:= Q, txn: InTxn): Unit = ??? 
        </span><span class="koboSpan" id="kobo.6.6">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.7.1">In addition to getters and setters for the two fields, the transactional pair defines the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">swap</span></code><span class="koboSpan" id="kobo.9.1"> method that swaps the fields, and can only be called if types </span><code class="literal"><span class="koboSpan" id="kobo.10.1">P</span></code><span class="koboSpan" id="kobo.11.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Q</span></code><span class="koboSpan" id="kobo.13.1"> are the same.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.14.1">Use ScalaSTM to implement the mutable location abstraction from Haskell, represented with the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">MVar</span></code><span class="koboSpan" id="kobo.16.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">        class MVar[T] { 
          def put(x: T)(implicit txn: InTxn): Unit = ??? 
          </span><span class="koboSpan" id="kobo.17.2">def take()(implicit txn: InTxn): T = ??? 
        </span><span class="koboSpan" id="kobo.17.3">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.18.1">An </span><code class="literal"><span class="koboSpan" id="kobo.19.1">MVar</span></code><span class="koboSpan" id="kobo.20.1"> object can be either full or empty. </span><span class="koboSpan" id="kobo.20.2">Calling </span><code class="literal"><span class="koboSpan" id="kobo.21.1">put</span></code><span class="koboSpan" id="kobo.22.1"> on a full </span><code class="literal"><span class="koboSpan" id="kobo.23.1">MVar</span></code><span class="koboSpan" id="kobo.24.1"> object blocks until the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">MVar</span></code><span class="koboSpan" id="kobo.26.1"> object becomes empty, and adds an element. </span><span class="koboSpan" id="kobo.26.2">Similarly, calling </span><code class="literal"><span class="koboSpan" id="kobo.27.1">take</span></code><span class="koboSpan" id="kobo.28.1"> on an empty </span><code class="literal"><span class="koboSpan" id="kobo.29.1">MVar</span></code><span class="koboSpan" id="kobo.30.1"> object blocks until the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">MVar</span></code><span class="koboSpan" id="kobo.32.1"> object becomes full, and removes the element. </span><span class="koboSpan" id="kobo.32.2">Now, implement a method called </span><code class="literal"><span class="koboSpan" id="kobo.33.1">swap</span></code><span class="koboSpan" id="kobo.34.1">, which takes two </span><code class="literal"><span class="koboSpan" id="kobo.35.1">MVar</span></code><span class="koboSpan" id="kobo.36.1"> objects and swaps their values:</span></p><p>
</p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">        def swap[T](a: MVar[T], b: MVar[T])(implicit txn: InTxn) 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.38.1">Contrast the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">MVar</span></code><span class="koboSpan" id="kobo.40.1"> class with the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">SyncVar</span></code><span class="koboSpan" id="kobo.42.1"> class from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.43.1">Chapter 2</span></a><span class="koboSpan" id="kobo.44.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.45.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Is it possible to implement the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">swap</span></code><span class="koboSpan" id="kobo.48.1"> method for </span><code class="literal"><span class="koboSpan" id="kobo.49.1">SyncVar</span></code><span class="koboSpan" id="kobo.50.1"> objects without modifying the internal implementation of the SyncVar class?</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.51.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">atomicRollbackCount</span></code><span class="koboSpan" id="kobo.53.1"> method, which is used to track how many times a transaction was rolled back before it completed successfully:</span><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">        def atomicRollbackCount[T](block: InTxn =&gt; T): (T, Int) 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.55.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.56.1">atomicWithRetryMax</span></code><span class="koboSpan" id="kobo.57.1"> method, which is used to start a transaction that can be retried at most </span><code class="literal"><span class="koboSpan" id="kobo.58.1">n</span></code><span class="koboSpan" id="kobo.59.1"> times:</span><pre class="programlisting"><span class="koboSpan" id="kobo.60.1">       def atomicWithRetryMax[T](n: Int)(block: InTxn =&gt; T): T 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.61.1">Reaching the maximum number of retries throws an exception.</span></p><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip87"/><span class="koboSpan" id="kobo.62.1">Tip</span></h3><p><span class="koboSpan" id="kobo.63.1">        Use the </span><code class="literal"><span class="koboSpan" id="kobo.64.1">Txn</span></code><span class="koboSpan" id="kobo.65.1"> object.</span></p></div></div></li><li class="listitem"><span class="koboSpan" id="kobo.66.1">Implement a transactional </span><span class="strong"><strong><span class="koboSpan" id="kobo.67.1">First In First Out</span></strong></span><span class="koboSpan" id="kobo.68.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.69.1">FIFO</span></strong></span><span class="koboSpan" id="kobo.70.1">) queue, represented with the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">TQueue</span></code><span class="koboSpan" id="kobo.72.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">        class TQueue[T] { 
          def enqueue(x: T)(implicit txn: InTxn): Unit = ??? 
          </span><span class="koboSpan" id="kobo.73.2">def dequeue()(implicit txn: InTxn): T = ??? 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.74.1">The </span><code class="literal"><span class="koboSpan" id="kobo.75.1">TQueue</span></code><span class="koboSpan" id="kobo.76.1"> class has similar semantics as </span><code class="literal"><span class="koboSpan" id="kobo.77.1">scala.collection.mutable.Queue</span></code><span class="koboSpan" id="kobo.78.1">, but calling </span><code class="literal"><span class="koboSpan" id="kobo.79.1">dequeue</span></code><span class="koboSpan" id="kobo.80.1"> on an empty queue blocks until a value becomes available.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.81.1">Use ScalaSTM to implement a thread-safe </span><code class="literal"><span class="koboSpan" id="kobo.82.1">TArrayBuffer</span></code><span class="koboSpan" id="kobo.83.1"> class, which extends the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">scala.collection.mutable.Buffer</span></code><span class="koboSpan" id="kobo.85.1"> interface.</span></li><li class="listitem"><span class="koboSpan" id="kobo.86.1">The </span><code class="literal"><span class="koboSpan" id="kobo.87.1">TSortedList</span></code><span class="koboSpan" id="kobo.88.1"> class described in this chapter is always sorted, but accessing the last element requires traversing the entire list, and can be slow. </span><span class="koboSpan" id="kobo.88.2">An AVL tree can be used to address this problem. </span><span class="koboSpan" id="kobo.88.3">There are numerous descriptions of AVL trees available online. </span><span class="koboSpan" id="kobo.88.4">Use ScalaSTM to implement the thread-safe transactional sorted set as an AVL tree:</span><pre class="programlisting"><span class="koboSpan" id="kobo.89.1">        class TSortedSet[T] { 
          def add(x: T)(implicit txn: InTxn): Unit = ??? 
          </span><span class="koboSpan" id="kobo.89.2">def remove(x: T)(implicit txn: InTxn): Boolean = ??? 
          </span><span class="koboSpan" id="kobo.89.3">def apply(x: T)(implicit txn: InTxn): Boolean = ??? 
        </span><span class="koboSpan" id="kobo.89.4">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.90.1">The </span><code class="literal"><span class="koboSpan" id="kobo.91.1">TSortedSet</span></code><span class="koboSpan" id="kobo.92.1"> class has similar semantics as </span><code class="literal"><span class="koboSpan" id="kobo.93.1">scala.collection.mutable.Set</span></code><span class="koboSpan" id="kobo.94.1">.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.95.1">Use ScalaSTM to implement a banking system that tracks amounts of money on user accounts. </span><span class="koboSpan" id="kobo.95.2">Different threads can call the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">send</span></code><span class="koboSpan" id="kobo.97.1"> method to transfer money from one account to another, the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">deposit</span></code><span class="koboSpan" id="kobo.99.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.100.1">withdraw</span></code><span class="koboSpan" id="kobo.101.1"> methods which deposit to or withdraw money from a specific account, respectively, and the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">totalStock</span></code><span class="koboSpan" id="kobo.103.1"> method which returns the total amount of money currently deposited in the bank. </span><span class="koboSpan" id="kobo.103.2">Finally, implement the </span><code class="literal"><span class="koboSpan" id="kobo.104.1">totalStockIn</span></code><span class="koboSpan" id="kobo.105.1"> method that returns the total amount of money currently deposited in the specified set of banks.</span></li><li class="listitem"><span class="koboSpan" id="kobo.106.1">Implement the generic transactional priority queue class, represented with the type </span><code class="literal"><span class="koboSpan" id="kobo.107.1">TPriorityQueue</span></code><span class="koboSpan" id="kobo.108.1">, used to sort elements. </span><span class="koboSpan" id="kobo.108.2">Then implement a method called </span><code class="literal"><span class="koboSpan" id="kobo.109.1">scheduleTask</span></code><span class="koboSpan" id="kobo.110.1">, which adds a task to the priority queue. </span><span class="koboSpan" id="kobo.110.2">Each task has a priority level. </span><span class="koboSpan" id="kobo.110.3">A set of workers must wait for the queue to become non-empty, at which point they repetitively remove tasks with the highest priority, and execute them.</span></li><li class="listitem"><span class="koboSpan" id="kobo.111.1">Implement a generic transactional directed graph data structure, whose nodes are represented with the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">Node</span></code><span class="koboSpan" id="kobo.113.1"> class. </span><span class="koboSpan" id="kobo.113.2">Then implement a method </span><code class="literal"><span class="koboSpan" id="kobo.114.1">scheduleTask</span></code><span class="koboSpan" id="kobo.115.1">, which adds a task to into the graph. </span><span class="koboSpan" id="kobo.115.2">Each task has the list of dependencies - other tasks in the graph that must be executed before it begins; and this list represents the directed edges in the graph. </span><span class="koboSpan" id="kobo.115.3">A set of workers repetitively queries the graph, and schedules tasks for execution. </span><span class="koboSpan" id="kobo.115.4">A task can only be executed after its dependencies are done executing.</span></li></ol></div></div></div></div></body></html>