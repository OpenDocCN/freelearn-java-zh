<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;JSON and Asynchronous Processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. JSON and Asynchronous Processing</h1></div></div></div><p>This chapter covers a brand new <a id="id2961" class="indexterm"/>JSR, The <a id="id2971" class="indexterm"/>JSR 353: Java API for JSON Processing <a class="ulink" href="http://jcp.org/en/jsr/detail?id=353">http://jcp.org/en/jsr/detail?id=353</a>, and related APIs along with some updates in different services and components in Java EE that provide better support for asynchronous interaction between different components of a system. The following list shows an itemized list of topics that are covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Producing, parsing and manipulating JSON data using Java</li><li class="listitem" style="list-style-type: disc">Introducing NIO API in Servlet 3.1</li><li class="listitem" style="list-style-type: disc">New features in JAX-RS 2.0</li></ul></div><div class="section" title="Producing and parsing JSON documents"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Producing and parsing JSON documents</h1></div></div></div><p>JSON format<a id="id2198" class="indexterm"/> was introduced as a <a id="id29911" class="indexterm"/>replacement for the XML format when the extensibility and <a id="id3001" class="indexterm"/>verbosity of XML were not required and thus to lift the resource consumption of complex <a id="id3011" class="indexterm"/>XML processing to let smaller devices consume streams of data or data packets produced by different services they needed to interact with.</p><p>Before the Java EE 7 <a id="id3012" class="indexterm"/>specification there was no standard API to process JSON documents in Java but rather there were some open source projects such as <a id="id3013" class="indexterm"/>
<span class="strong"><strong>google-gson</strong></span>, <a class="ulink" href="https://code.google.com/p/google-gson ">https://code.google.com/p/google-gson </a>and <a id="id3104" class="indexterm"/>
<span class="strong"><strong>Jackson</strong></span>, <a class="ulink" href="http://jackson.codehaus.org">http://jackson.codehaus.org</a> to manipulate JSON documents. With Java EE 7 and the addition of JSON-P to the arsenal, a standard API is added to Java EE to let the developers manipulate JSON documents in a standard fashion similar to XML processing of APIs.</p><p>The <a id="id305" class="indexterm"/>JSON-P API provides two parsing methods to parse JSON documents, the same two models that are available for parsing XML documents. The streaming event-based parsing and the object model tree parsing which are explained in the next two sections.</p><div class="section" title="An overview of JSON API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>An overview of JSON API</h2></div></div></div><p>The following table shows the<a id="id306" class="indexterm"/> important API segments of JSON-P along with a brief description of each class. The JSON API-related classes are placed under the<a id="id307" class="indexterm"/> <code class="literal">javax.json</code> package. The follow-up sections cover how each one of these can be used.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Class</p>
</th><th style="text-align: left" valign="bottom">
<p>Description and use</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JsonParser</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A Pull <a id="id308" class="indexterm"/>parser to parse JSON objects <a id="id309" class="indexterm"/>using event model.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JsonGenerator</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A<a id="id310" class="indexterm"/> JSON stream writer to write JSON <a id="id311" class="indexterm"/>objects to an output source such as <code class="literal">OutputStream</code> and <code class="literal">Writ</code>
<code class="literal">er</code> in a streaming manner.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JsonBuilder</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Builds<a id="id312" class="indexterm"/> <code class="literal">JsonObject</code> and <code class="literal">JsonArray</code> <a id="id313" class="indexterm"/>Programmatically</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JsonReader</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Reads<a id="id314" class="indexterm"/> <code class="literal">JsonObject</code> and <code class="literal">JsonArray</code> from <a id="id315" class="indexterm"/>input source</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JsonWriter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Writes<a id="id316" class="indexterm"/> <code class="literal">JsonObject</code> and <code class="literal">JsonArray</code> to output <a id="id317" class="indexterm"/>source</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JsonObject and JsonArray</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To<a id="id318" class="indexterm"/> store<a id="id319" class="indexterm"/> <code class="literal">JSONObject</code><a id="id320" class="indexterm"/> and array structure</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JsonString and JsonNumber</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To <a id="id321" class="indexterm"/>store<a id="id322" class="indexterm"/> string<a id="id323" class="indexterm"/> and <a id="id324" class="indexterm"/>numerical values</p>
</td></tr></tbody></table></div><p>The <code class="literal">JSONObject</code> is the entry point to the entire JSON API arsenal. For each one of the following objects JSON API provides a factory method as well as a creator to create them. For example, <code class="literal">Json.createParser</code> and <code class="literal">Json.createParserFactory</code> can be used to create a JSON parser. The factory can be configured to produce customized parsers or, when more than one parser is required, to reduce the performance overhead of creating the parsers while the <code class="literal">createParser</code> overloads can be used to create a JSON parser with a default configuration.</p></div><div class="section" title="Manipulating JSON documents using the event-based API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Manipulating JSON documents using the event-based API</h2></div></div></div><p>The event-based API is best<a id="id325" class="indexterm"/> used when a one way, going <a id="id326" class="indexterm"/>forward, parsing or producing of JSON documents is required. The event-based API works similar to <span class="strong"><strong>StAX</strong></span><a id="id327" class="indexterm"/> parsing of XML documents but in a much simpler (due to the JSON format being much simpler) fashion.</p></div><div class="section" title="Producing JSON documents"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Producing JSON documents</h2></div></div></div><p>Producing JSON documents using the <a id="id328" class="indexterm"/>event-based API is most suitable when a stream of events is arriving and they require transforming to JSON format for another processor that consumes JSON format.</p><p>The following sample code shows how to generate JSON output using <code class="literal">JsonGenerator</code>:</p><div class="informalexample"><pre class="programlisting">public static void main(String[] args) {
        Map&lt;String, Object&gt;configs = new HashMap&lt;String, Object&gt;(1);
configs.put(JsonGenerator.PRETTY_PRINTING, true);
JsonGeneratorFactory factory = Json.createGeneratorFactory(configs);
JsonGeneratorgenerator = factory.createGenerator(System.out);

generator.writeStartObject()                    
            .write("title", "Getting Started with RESTful Web Services")  
                .write("type", "paperback")    
                .write("author", "Bhakti Mehta, Masoud Kalali")   
                .write("publisher", "Packt")            
                .write("publication year", "2013")     
                .write("edition",  "1")
        .writeEnd()                             
        .close();
    }</pre></div><p>Executing the preceding code produces the following content in the standard output:</p><div class="informalexample"><pre class="programlisting">{
    "title":" Getting Started with RESTful Web Services",
        "type":" paperback",
        "author":" Bhakti Mehta, Masoud Kalali",
        "publisher":"Packt",
        "edition":"1"
}</pre></div><p>In the beginning of the code, the <a id="id329" class="indexterm"/>properties object that is created can be used to add directives on what behaviors are expected from the <code class="literal">JsonGenerator</code> object. The directives that can be specified differ from implementation to implementation but here the <code class="literal">JsonGenerator.PRETTY_PRINTING</code> is used to ensure that the resulting JSON document is formatted and human-readable.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The <code class="literal">JsonParser</code>, <code class="literal">JsonGenerator</code>, <code class="literal">JsonReader</code>, <code class="literal">JsonWriter</code> can be used in Automatic Resource Management blocks, for example:</p><div class="informalexample"><pre class="programlisting">try (JsonGenerator generator = factory.createGenerator(System.out);) 
       {
        }</pre></div></div></div></div><div class="section" title="Parsing JSON documents"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Parsing JSON documents</h2></div></div></div><p>Assuming that the result <a id="id330" class="indexterm"/>of the previous sample is saved to a file named <code class="literal">output.json</code>, the following snippet can be used to parse the <code class="literal">output.json</code> using stream parser.</p><div class="informalexample"><pre class="programlisting">FileInputStreambooksInputfile = new FileInputStream("output.json");
JsonParser parser = Json.createParser(booksInputfile);
            Event event = null;
            while(parser.hasNext()) {
                event = parser.next();
                if(event == Event.KEY_NAME&amp;&amp;"details".equals(parser.getString())) {
                    event = parser.next();
                    break;
                }
            }
            while(event != Event.END_OBJECT) {
                switch(event) {
                    case KEY_NAME: {
                        System.out.print(parser.getString());
                        System.out.print(" = ");
                        break;
                    }
                    case VALUE_NUMBER: {
                        if(parser.isIntegralNumber()) {
                          System.out.println(parser.getInt());
                        } else {
                          System.out.println(parser.getBigDecimal());
                        }
                       break;
                    }
                    case VALUE_STRING: {
                         System.out.println(parser.getString());
                        break;
                    }
                    default: {
                    }
                }
                event = parser.next();
            }</pre></div><p>The event types that should be<a id="id331" class="indexterm"/> processed when parsing a JSON document are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">START_ARRAY</code>: Indicating start of an array in the JSON document</li><li class="listitem" style="list-style-type: disc"><code class="literal">START_OBJECT</code>: Indicating start of an object</li><li class="listitem" style="list-style-type: disc"><code class="literal">KEY_NAME</code>: Name of the key</li><li class="listitem" style="list-style-type: disc"><code class="literal">VALUE_STRING</code>: When the key's value is string</li><li class="listitem" style="list-style-type: disc"><code class="literal">VALUE_NUMBER</code>: When the value is number</li><li class="listitem" style="list-style-type: disc"><code class="literal">VALUE_NULL</code>: If the value is null</li><li class="listitem" style="list-style-type: disc"><code class="literal">VALUE_FALSE</code>: If value is Boolean false</li><li class="listitem" style="list-style-type: disc"><code class="literal">VALUE_TRUE</code>: If value is Boolean true</li><li class="listitem" style="list-style-type: disc"><code class="literal">END_OBJECT</code>: End of an object is reached</li><li class="listitem" style="list-style-type: disc"><code class="literal">END_ARRAY</code>: End of an array is reached</li></ul></div></div><div class="section" title="Manipulating JSON documents using the JSON object model"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Manipulating JSON documents using the JSON object model</h2></div></div></div><p>The document object<a id="id332" class="indexterm"/> model for parsing JSON provides the <a id="id333" class="indexterm"/>same flexibilities and limitation that XML DOM parsing provides. The list of flexibilities includes but not limited to, forward and backward traversing and manipulating the DOM tree; the disadvantages or the tradeoff are on the parser speed and memory requirement.</p><div class="section" title="Generating JSON documents"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec19"/>Generating JSON documents</h3></div></div></div><p>The following sample <a id="id334" class="indexterm"/>code shows how to generate JSON documents using the builder API and later on writing the produced object to standard output:</p><div class="informalexample"><pre class="programlisting">Map&lt;String, Object&gt;configs = new HashMap&lt;String, Object&gt;();        
JsonBuilderFactory factory = Json.createBuilderFactory(configs);
JsonObject book= factory.createObjectBuilder()
.add("title", "Getting Started with RESTful Web Services")
.add("type", "paperback")
.add("author", "Bhakti Mehta, Masoud Kalali")
.add("publisher", "Packt")
.add("publication year", "2013")
.add("edition", "1")
.build();   
configs.put(JsonGenerator.PRETTY_PRINTING, true);
JsonWriter writer = Json.createWriterFactory(configs).createWriter(System.out);
writer.writeObject(book);</pre></div><p>Note the use of configuration properties passed when the <code class="literal">JsonBuilderFactory</code> is created. Depending on the JSON API implementation, different configuration parameters can be passed to the factory to produce customized <code class="literal">JsonBuilder</code> objects.</p><p>The resulting JSON output looks like:</p><div class="informalexample"><pre class="programlisting">{
    "title":" Getting Started with RESTful Web Services",
        "type":" paperback",
        "author":" Bhakti Mehta, Masoud Kalali",
        " publisher ":" Packt",
        " edition":"1"
}</pre></div></div><div class="section" title="Parsing JSON documents"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec20"/>Parsing JSON documents</h3></div></div></div><p>Parsing a <code class="literal">JSONObject</code> using the object model is straightforward and starts with creating a reader object and reading the input file/document into a <code class="literal">JSONObject</code>. After having access to the <code class="literal">JSONObject</code>, it is possible to traverse over the primitive and array attributes of the <code class="literal">JSONObject</code>.</p><div class="informalexample"><pre class="programlisting">Map&lt;String, Object&gt;configs = 
new HashMap&lt;String, Object&gt;(1);        
JsonReader  reader = 
Json.createReader(new FileInputStream("book.json"));        
JsonObject book=reader.readObject();       
        String title = book.getString("title");
int edition = book.getString("edition");</pre></div><p>As the sample code shows, reading each attribute of the <code class="literal">JSONObject</code>is performed through typed getters; for example <code class="literal">getString</code>, <code class="literal">getInt</code>, <code class="literal">getNull</code>, <code class="literal">getBoolean</code>, and so on.</p></div></div><div class="section" title="When to use the streaming versus the object API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>When to use the streaming versus the object API</h2></div></div></div><p>The streaming event based API is<a id="id335" class="indexterm"/> useful when you are manipulating large<a id="id336" class="indexterm"/> JSON documents, which you do not want to store in memory. The object model API is useful in the case when you have navigated between different nodes of the JSON document.</p></div></div></div>
<div class="section" title="Introducing Servlet 3.1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Introducing Servlet 3.1</h1></div></div></div><p>The Java EE 7 specification brings <a id="id337" class="indexterm"/>along an updated specification for Servlet API, which addresses some of the community-requested and industry-required changes including but not limited to the following list of changes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Addition of the NIO API to servlet specification</li><li class="listitem" style="list-style-type: disc">Adding new protocol upgrading support for WebSockets, and so on</li></ul></div><p>The next two sections cover the details of these changes and how they can be used.</p><div class="section" title="NIO API and Servlet 3.1"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>NIO API and Servlet 3.1</h2></div></div></div><p>Servlet 3 introduced <a id="id338" class="indexterm"/>async processing of incoming requests in which a request could be placed in a processing queue without a thread being bound to the request until the request processing is finished. In Servlet 3.1, another forward step made forward in which receiving the request data writing back the response can be done in a non-blocking, callback-oriented manner.</p></div><div class="section" title="Introducing ReadListener and WriteListener"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Introducing ReadListener and WriteListener</h2></div></div></div><p>The two listeners are introduced to allow developers to basically receive notification when there is incoming data available to read rather than blocking until the data arrives and to be receiving notification when it is possible to write output without being blocked.</p><p>The<a id="id339" class="indexterm"/> <code class="literal">ReadListener</code> interface, which<a id="id340" class="indexterm"/> provides callback notification on availability of data in request's <code class="literal">InputStream</code> code, is shown in the following listing, a simple interface with three methods, which are described after the code snippet.</p><div class="informalexample"><pre class="programlisting">public interface ReadListener extends EventListener { 
 public void onDataAvailable(ServletRequest request); 
 public void onAllDataRead(ServletRequest request); 
 public void onError(Throwable t); 
}</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onDataAvailable</code>: Invoked when all <a id="id341" class="indexterm"/>data<a id="id342" class="indexterm"/> for the current request has been read.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onAllDataRead</code>: Invoked by the <a id="id343" class="indexterm"/>container <a id="id344" class="indexterm"/>the first time it is possible to read data.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">onError</code>: Invoked when an <a id="id345" class="indexterm"/>error occurs <a id="id346" class="indexterm"/>processing the request.</li></ul></div><p>The <code class="literal">WriteListener</code>, which provides<a id="id347" class="indexterm"/> callback notification <a id="id348" class="indexterm"/>when it is possible to write data in the Servlet's <code class="literal">OutputStream</code>, is a simple two methods interface that is shown in the following snippet and described afterward.</p><div class="informalexample"><pre class="programlisting">public interface WriteListener extends EventListener { 
public void onWritePossible(ServletResponse response); 
public void onError(Throwable t); 
}</pre></div><p>The container invokes the <code class="literal">onWritePossible</code> method<a id="id349" class="indexterm"/> when it is possible to write in the Servlet's <code class="literal">OutputStream</code>.</p><p>The <code class="literal">onError</code> is invoked when writing in the Servlet's <code class="literal">OutputStream</code> encounters an exception<code class="literal">.</code>
</p><p>The sample code on how these two listeners can be used is included at the end of Servlet 3.1 introduction section.</p></div><div class="section" title="Changes in the Servlet API interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Changes in the Servlet API interfaces</h2></div></div></div><p>There are some changes in the<a id="id350" class="indexterm"/> Servlet API to make it possible to use the newly introduced interfaces. These changes are as follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <code class="literal">ServletOutputStream</code> interface:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isReady</code>: This<a id="id351" class="indexterm"/> method can be used to determine if data can be written without blocking</li><li class="listitem" style="list-style-type: disc"><code class="literal">setWriteListener</code>: Instructs <a id="id352" class="indexterm"/>the <code class="literal">ServletOutputStream</code> to invoke the provided <code class="literal">WriteListener</code> when it is possible to write</li></ul></div></li><li class="listitem" style="list-style-type: disc">In the <code class="literal">ServletInputStream</code> <a id="id353" class="indexterm"/>interface<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isFinished</code>: Returns<a id="id354" class="indexterm"/> true when all the data from the stream has been read else it returns false</li><li class="listitem" style="list-style-type: disc"><code class="literal">isReady</code>: Returns true <a id="id355" class="indexterm"/>if data can be read without blocking else returns false</li><li class="listitem" style="list-style-type: disc"><code class="literal">setReadListener</code>: Instructs the <code class="literal">ServletInputStream</code> to invoke the provided <code class="literal">ReadListener</code> <a id="id356" class="indexterm"/>when it is possible to read</li></ul></div></li></ul></div><p>Now it is time to see how the non-blocking Servlet 3.1 API works. The following snippet shows an Async Servlet, which uses the non-blocking APIs:</p><div class="informalexample"><pre class="programlisting">@WebServlet(urlPatterns="/book-servlet", asyncSupported=true)
public class BookServlet extends HttpServlet {
    protected void doPost(HttpServletRequestreq, HttpServletResponse res)
            throws IOException, ServletException {
AsyncContext ac = req.startAsync();
ac.addListener(new AsyncListener() {
            public void onComplete(AsyncEvent event) throws IOException {
event.getSuppliedResponse().getOutputStream().print("Async Operation Completed");
            }
            public void onError(AsyncEvent event) {
System.out.println(event.getThrowable());
            }
            public void onStartAsync(AsyncEvent event) {
System.out.println("Async Operation Started");
            }
            public void onTimeout(AsyncEvent event) {
System.out.println("Async Operation Timedout");
            }
        });
ServletInputStream input = req.getInputStream();
ReadListenerreadListener =  new ReservationRequestReadListener(input, res, ac);
input.setReadListener(readListener);
    }
}</pre></div><p>The code starts<a id="id357" class="indexterm"/> with declaring the Servlet and enabling asynchronous support by specifying the <code class="literal">asyncSupported=true</code>in the <code class="literal">@WebServlet</code> annotation.</p><p>The next step is to set the <code class="literal">AsyncListener</code> to handle the <code class="literal">AsyncEvent</code>s. Invoking one of the <code class="literal">AsyncContext</code> sets the <code class="literal">AsyncListener</code> for <code class="literal">AsyncContext#addListner</code> overloads. The listener will receive the <code class="literal">AsyncEvents</code> when an asynchronous invocation of the Servlet is completed successfully or ended with timeout or error. Multiple listeners can be registered and listeners receive the events in the same order they are registered.</p><p>The last part of the code sets the <code class="literal">readListener</code> for the servlet to a <code class="literal">ReadListener</code> implementation included below. When the <code class="literal">ReadListener</code>is set, reading the incoming requests is delegated to the <code class="literal">ReservationRequestReadListener</code>.</p><div class="informalexample"><pre class="programlisting">class ReservationRequestReadListener implements ReadListener {
    private ServletInputStream input = null;
    private HttpServletResponse response = null;
    private AsyncContext context = null;    
    private Queue queue = new LinkedBlockingQueue();

ReservationRequestReadListener(ServletInputStream in, HttpServletResponse r, AsyncContext c) {
this.input = in;
this.response = r;
this.context = c;
    }

    public void onDataAvailable() throws IOException {
StringBuildersb = new StringBuilder();
int read;
byte b[] = new byte[1024];
while (input.isReady() &amp;&amp; (read = input.read(b)) != -1) {
String data = new String(b, 0, read);
sb.append(data);
        }
queue.add(sb.toString());
    }

public void onAllDataRead() throws IOException {
performBusinessOperation();
ServletOutputStream output = response.getOutputStream();
WriteListenerwriteListener = new ResponseWriteListener(output, queue, context);
output.setWriteListener(writeListener);
    }

public void onError(Throwable t) {
context.complete();        
    }
}</pre></div><p>The <code class="literal">ReservationRequestReadListener.onDataAvailable</code> is invoked by the container<a id="id358" class="indexterm"/> when there is data to read and when reading the data is finished the <code class="literal">onAllDataRead</code> is invoked. The <code class="literal">onAllDataRead</code> performs the business operation on the available data and the set the <code class="literal">ResponseWriteListener</code>, which writes the data, is stored in the queue back to the client. The <code class="literal">ResponseWriteListener</code> is shown in the following listing:</p><div class="informalexample"><pre class="programlisting">class ResponseWriteListener implements WriteListener {
    private ServletOutputStream output = null;
    private Queue queue = null;
    private AsyncContext context = null;

ResponseWriteListener(ServletOutputStreamsos, Queue q, AsyncContext c) {
this.output = sos;
this.queue = q;
this.context = c;
    }

    public void onWritePossible() throws IOException {
        while (queue.peek() != null &amp;&amp;output.isReady()) {
            String data = (String) queue.poll();
            output.print(data);
        }
        if (queue.peek() == null) {
            context.complete();
        }
    }

    public void onError(final Throwable t) {
           context.complete();
           t.printStackTrace();
    }
}</pre></div><p>When the writing<a id="id359" class="indexterm"/> operation is finished either normally or fatally, the context needs to be closed for this operation using the <code class="literal">context.complete()</code> method.</p><div class="section" title="More changes in Servlet 3.1"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec21"/>More changes in Servlet 3.1</h3></div></div></div><p>In addition to non-blocking <a id="id360" class="indexterm"/>IO inclusion, Servlet 3.1 brings in support for protocol upgrade in order to support the new WebSockets API. The addition of the <code class="literal">upgrade</code> method to <code class="literal">HttpServletRequest</code> allows developers to upgrade the communication protocol to other protocols, if supported by the container.</p><p>When an upgrade request is sent, the application decides to perform the upgrader, the <code class="literal">HttpServletRequest#upgrade(ProtocolHandler)</code> is invoked, and application prepares and sends an appropriate response to the client as usual. At this point the web container unwinds all the servlet filters and marks the connection to be handled by the protocol handler.</p></div></div></div>
<div class="section" title="New features in JAX-RS 2.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>New features in JAX-RS 2.0</h1></div></div></div><p>JAX-RS 2.0 brings in several <a id="id361" class="indexterm"/>new features aligned with other lightweight and async processing features provided in other components. The new features include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Client API</li><li class="listitem" style="list-style-type: disc">Common configuration</li><li class="listitem" style="list-style-type: disc">Asynchronous processing</li><li class="listitem" style="list-style-type: disc">Filters/interceptors</li><li class="listitem" style="list-style-type: disc">Hypermedia support</li><li class="listitem" style="list-style-type: disc">Server-side content negotiation</li></ul></div><p>From this list of features, this section covers asynchronous processing and also the relevance of asynchronous processing to filters/interceptors.</p><div class="section" title="Asynchronous request and response processing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Asynchronous request and response processing</h2></div></div></div><p>Asynchronous processing <a id="id362" class="indexterm"/>is included<a id="id363" class="indexterm"/> in both client and server side APIs of JAX-RS 2.0 to facilitate asynchronous interaction between client and server components. The following list shows the new interfaces and classes added to support this feature:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Server side:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AsyncResponse</code>:<code class="literal"> </code>An injectable JAX-RS asynchronous response that provides the means for asynchronous server side response processing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Suspended</code>:<code class="literal"> @Suspended</code> instructs the container that the HTTP request processing should happen in a secondary thread.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CompletionCallback</code>: A request processing callback that receives request processing completion events.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConnectionCallback</code>: Asynchronous request processing lifecycle callback that receives connection-related asynchronous response lifecycle events.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Client side:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">InvocationCallback</code>: Callback that can be implemented to receive the asynchronous processing events from the invocation processing</li><li class="listitem" style="list-style-type: disc"><code class="literal">Future</code>: Allows the client to poll for completion of the asynchronous operation or to block and wait for it</li></ul></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>The <code class="literal">Future</code> interface introduced in Java SE 5 provides two different mechanism to get the result of an asynchronous operation: first by invoking the <code class="literal">Future.get(…)</code> variants, which block until the result is available or a timeout occurs; the second way is to check for the completion by invoking the <code class="literal">isDone()</code> and <code class="literal">isCancelled()</code>, which are Boolean methods returning the current status of the Future.</p></div></div><p>The following <a id="id364" class="indexterm"/>sample code shows how an<a id="id365" class="indexterm"/> asynchronous resource can be developed using JAX-RS 2 API:</p><div class="informalexample"><pre class="programlisting">@Path("/books/borrow")
@Stateless
public class BookResource {   
  @Context private ExecutionContextctx;
  @GET @Produce("application/json")
  @Asynchronous
  public void borrow() {
         Executors.newSingleThreadExecutor().submit( new Runnable() {
         public void run() { 
         Thread.sleep(10000);     
         ctx.resume("Hello async world!"); 
         } });  
         ctx.suspend();		
         return;
  } 
} </pre></div><p>
<code class="literal">BookResource</code> is a stateless session bean which has a method <code class="literal">borrow()</code>. This method is annotated with <code class="literal">@Asynchronous</code> annotation, which will work in the fire-and-forget manner. When the resource is requested through the <code class="literal">borrow()</code> method's resource path, a new thread is spawned to work on preparing the request's response. The thread is submitted to the executor for execution and the thread processing the client request is released (via <code class="literal">ctx.suspend</code>) to process other incoming requests. When the worker thread, created to prepare the response, is done with preparing the response, it invokes the<code class="literal">ctx.resume</code>, which lets the container know the response is ready to be sent back to the client. If the<code class="literal">ctx.resume</code> is invoked before the <code class="literal">ctx.suspend</code> (the worker thread has prepared the result before the execution reaching the <code class="literal">ctx.suspend</code>) the suspension is ignored and the result will be sent to the client.</p><p>Same functionality can be achieved using the <code class="literal">@Suspended</code> annotation that is shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">@Path("/books/borrow")
@Stateless
public class BookResource {   
  @GET @Produce("application/json")
  @Asynchronous
  public void borrow(@Suspended AsyncResponsear) {
  final String result = prepareResponse();
  ar.resume(result)  } 
}   </pre></div><p>Using <code class="literal">@Suspended</code> is <a id="id366" class="indexterm"/>cleaner as it does <a id="id367" class="indexterm"/>not involve use of <code class="literal">ExecutionContext</code> method to instruct container to suspend and then resume the communication thread when the worker thread, aka the <code class="literal">prepareResponse()</code> method in this case, is finished. The client code to consume the asynchronous resource can use the callback mechanism or polling at the code level. The following code shows how to use polling via <code class="literal">Future</code> interface:</p><div class="informalexample"><pre class="programlisting">Future&lt;Book&gt; future = client.target("("books/borrow/borrow")
               .request()
               .async()
               .get(Book.class);
try {
   Book book = future.get(30, TimeUnit.SECONDS);
} catch (TimeoutException ex) {
  System.err.println("Timeout occurred");
}</pre></div><p>The code begins with forming the request to the book resource and then the <code class="literal">Future.get(…)</code> blocks until the response is back from the server or the 30 seconds timeout reaches.</p><p>Another API for the asynchronous client is to use the <code class="literal">InvocationCallback</code>.</p></div><div class="section" title="Filters and interceptors"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Filters and interceptors</h2></div></div></div><p>The <a id="id368" class="indexterm"/>filters and<a id="id369" class="indexterm"/> interceptors are two new concepts added to JAX-RS 2.0 that allow developers to intercept incoming and outgoing requests and responses as well as operating at stream level on the incoming and outgoing payloads.</p><p>The filters work the<a id="id370" class="indexterm"/> same way as Servlet filters work and provide access to inbound and outbound messages for tasks such as authentication/logging, auditing, etc. while interceptors can be used to perform dumb operations on payload such as compressing/decompressing the outgoing responses and incoming requests.</p><p>Filters and interceptors<a id="id371" class="indexterm"/> are asynchronous-aware, meaning that they can handle both synchronous and asynchronous communications.</p></div></div>
<div class="section" title="Asynchronous processing in EJB 3.1 and 3.2"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Asynchronous processing in EJB 3.1 and 3.2</h1></div></div></div><p>Before Java EE 6 the only asynchronous processing facility in Java EE was <span class="strong"><strong>JMS</strong></span> (<span class="strong"><strong>Java Message Service</strong></span>)<a id="id372" class="indexterm"/> and <span class="strong"><strong>MDBs</strong></span> (<span class="strong"><strong>Message Driven Beans</strong></span>)<a id="id373" class="indexterm"/> in which a session bean method could send a JMS message to describe a request and then let an MDB process the request in an asynchronous manner. Using the JMS and MDBs the session bean method could return immediately and the client could check for the request completion using the reference returned by the method for the long running operation being handled by some MDBs.</p><p>The above solution works <a id="id374" class="indexterm"/>well, as it has worked for a decade now, but it is not <a id="id375" class="indexterm"/>easy to use and that was the reason for Java EE 6 to introduce the <code class="literal">@Asynchronous</code> annotation<a id="id376" class="indexterm"/> to annotate a method in a session bean or the whole session bean class as asynchronous. The <code class="literal">@Asynchronous </code>can be placed on a class to mark all the methods in that class as asynchronous or on a method to mark that particular method as asynchronous.</p><p>There are two types of asynchronous EJB invocation<a id="id377" class="indexterm"/> which are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the first model the method returns <code class="literal">void</code> and there is no container-provided standard mechanism to check the result of the method invocation. This is referred to as a <a id="id378" class="indexterm"/><span class="strong"><strong>fire-and-forget</strong></span> mechanism.</li><li class="listitem" style="list-style-type: disc">In the second model, the container provides a mechanism to check back the result of the invocation using a <code class="literal">Future&lt;?&gt;</code> object returned from the method invocation. This mechanism is referred to as<a id="id379" class="indexterm"/> <span class="strong"><strong>invoke-and-check-later</strong></span>. Note that <code class="literal">Future</code> is part of the Java SE concurrency package. Having the Future object returned from the method, the client can check the result of invocation by using different Future methods such as <code class="literal">isDone()</code> and <code class="literal">get(…)</code>.</li></ul></div><p>Before we dive down into sample codes or use the <code class="literal">@Asynchronous</code> it is worth mentioning that, in Java EE 6, the <code class="literal">@Asynchronous</code> was only available in full profile while in Java EE 7 the annotation is added to the web profile as well.</p><div class="section" title="Developing an asynchronous session bean"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Developing an asynchronous session bean</h2></div></div></div><p>The following listing shows how to<a id="id380" class="indexterm"/> use the invoke-and-check-later asynchronous EJB methods:</p><div class="informalexample"><pre class="programlisting">@Stateless
@LocalBean
public class FTSSearch {

    @Asynchronous
    public Future&lt;List&lt;String&gt;&gt; search(String text, intdummyWait) {        
        List&lt;String&gt; books = null;
        try {
           books= performSearch(text,dummyWait);
        } catch (InterruptedException e) {
            //handling exception
        }
        return new AsyncResult&lt;List&lt;String&gt;&gt;(books);        
    }
    private List&lt;String&gt;performSearch(String content, intdummyWait) throws InterruptedException{
Thread.sleep(dummyWait);
return Arrays.asList(content);
    }
}</pre></div><p>
<code class="literal">@Stateless</code> and <code class="literal">@LocalBean</code> are self-explanatory; they mark this class as a stateless session bean with a local interface.</p><p>The <code class="literal">search</code> method is annotated with <code class="literal">@Asynchronous</code> and this tells the container that the method invocation should happen in a separate detached thread; when the result is available the returned Future object's <code class="literal">isDone()</code> returns true.</p><p>The <code class="literal">search</code> itself invokes a<a id="id381" class="indexterm"/> presumably long running method, <code class="literal">performSearch</code>, to get the result of the long running search operation the client has requested.</p></div><div class="section" title="Developing a client servlet for the async session bean"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Developing a client servlet for the async session bean</h2></div></div></div><p>Now that the<a id="id382" class="indexterm"/> stateless session bean is developed it is time to develop <a id="id383" class="indexterm"/>a client that accesses the session bean's business method. In this case the client is a Servlet, which is included in the following code without some of the boilerplate codes:</p><div class="informalexample"><pre class="programlisting">@WebServlet(name = "FTSServlet", urlPatterns = {"/FTSServlet"})
public class FTSServlet extends HttpServlet {

    @EJB
FTSSearchftsSearch;

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        Future&lt;List&lt;String&gt;&gt;wsResult = ftsSearch.search("WebSockets", 5000);
        Future&lt;List&lt;String&gt;&gt;sseResult = ftsSearch.search("SSE", 1000);

        while (!sseResult.isDone()) {
            try {
Thread.sleep(500);
                //perform other tasks... e.g. show progress status
            } catch (InterruptedException ex) {
Logger.getLogger(FTSServlet.class.getName()).log(Level.SEVERE, null, ex);
            }
        }


response.setContentType("text/html;charset=UTF-8");
PrintWriter out = response.getWriter();
        try {
            /* TODO output your page here. You may use following sample code. */
out.println("&lt;!DOCTYPE html&gt;");
out.println("&lt;html&gt;");
out.println("&lt;head&gt;");
out.println("&lt;title&gt;Servlet d&lt;/title&gt;");
out.println("&lt;/head&gt;");
out.println("&lt;body&gt;");
out.println("&lt;h1&gt;SSE Search result: " + sseResult.get().get(0) + "&lt;/h1&gt;");
            while (!wsResult.isDone()) {
                try {
Thread.sleep(500);
                } catch (InterruptedException ex) {
Logger.getLogger(FTSServlet.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
out.println("&lt;h1&gt;WS Search result: " + wsResult.get().get(0) + "&lt;/h1&gt;");
out.println("&lt;/body&gt;");
out.println("&lt;/html&gt;");
        } catch (InterruptedException ex) {
Logger.getLogger(FTSServlet.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ExecutionException ex) {
Logger.getLogger(FTSServlet.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
out.close();
        }
    }

}</pre></div><p>Starting from the <a id="id384" class="indexterm"/>top, we have the servlet declaration <a id="id385" class="indexterm"/>annotations, injection of the stateless EJB, and the <code class="literal">get</code> method's implementation.</p><p>The get in the <code class="literal">get</code> method's implementation invokes the EJB's <code class="literal">search</code> method while passing two different <code class="literal">dummyTime</code> to simulate the wait. Between invocations of the <code class="literal">search</code> method till the Future object's <code class="literal">isDone</code> returns true, the client code can perform other required operations. </p><p>Now that the invoke-and-check-later model is described we can discuss the other Asynchronous EJB invocation model in which the EJB business methods return <code class="literal">void</code> and there is no container-provided way to check the result. We usually use these methods to trigger a long-running task that the current thread does not need to wait for it to be finished. </p><p>An example of this <a id="id386" class="indexterm"/>case is when a new e-book is added to the library and the full text search index needs to be updated to include the new book. In such a case the procedure that adds the book can invoke a <code class="literal">@Asynchronous</code> EJB<a id="id387" class="indexterm"/> method to index the book during the book's registration and after it is uploaded to the server's repository. In this way the registration process does not need to wait for the FTS indexing to complete while the FTS indexing starts right after the book is added to the library.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Summary</h1></div></div></div><p>This chapter, the final chapter before showing you some real-world examples, discusses JSON processing, Asynchronous JAX-RS resources, which can produce or consume JSON data along with discussing the new NIO support in the Servlet 3.1. As <code class="literal">@Asynchronous</code> EJB is now included in Java EE 7's Web profile we discussed that feature along with other new features that are introduced in Java EE7. The next chapter shows real-world examples on how these technologies and APIs can be used together to form a solution.</p></div></body></html>