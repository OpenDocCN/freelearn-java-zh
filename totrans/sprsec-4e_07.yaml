- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember-me Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll add the ability for an application to remember a user
    even after their session has expired and the browser is closed. The following
    topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussing what **remember-me** is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use the token-based remember-me feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing how secure remember-me is, and various ways of making it more secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the persistent-based remember-me feature, and how to handle additional
    considerations for using it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting the overall remember-me architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to create a custom remember-me implementation that is restricted
    to the user’s IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/WEEx2](https://packt.link/WEEx2).'
  prefs: []
  type: TYPE_NORMAL
- en: What is remember-me?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A convenient feature to offer frequent users of a website is the remember-me
    feature. This feature allows a user to elect to be remembered even after their
    browser is closed. In Spring Security, this is implemented through the use of
    a remember-me **cookie** that is stored in the user’s browser. If Spring Security
    recognizes that the user is presenting a remember-me cookie, then the user will
    automatically be logged into the application, and will not need to enter a username
    or password.
  prefs: []
  type: TYPE_NORMAL
- en: What is a cookie?
  prefs: []
  type: TYPE_NORMAL
- en: A cookie is a way for a client (that is, a web browser) to persist the state.
    For more information about cookies, refer to additional online resources, such
    as Wikipedia ([https://en.wikipedia.org/wiki/HTTP_cookie](https://en.wikipedia.org/wiki/HTTP_cookie)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security provides the following two different strategies that we will
    discuss in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the token-based remember-me feature, which relies on a cryptographic
    signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second method, the `persistent-based remember-me` feature, requires a datastore
    (a database)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we previously mentioned, we will discuss these strategies in much greater
    detail throughout this chapter. The remember-me feature must be explicitly configured
    in order to enable it. Let’s start by trying the token-based remember-me feature
    and see how it affects the flow of the login experience.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The token-based remember-me section does not need any additional dependencies
    other than the basic setup from [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. However, you will want to ensure you include
    the following additional dependencies in your `build.gradle` file if you are leveraging
    the persistent-based remember-me feature. We have already included these dependencies
    in the chapter’s sample, so there is no need to update the sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The token-based remember-me feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Security provides two different implementations of the remember-me feature.
    We will start by exploring how to set up token-based remember-me services.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the token-based remember-me feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Completing this exercise will allow us to provide a simple and secure method
    to keep users logged in for extended periods of time. To start, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `SecurityConfig.java` configuration file and add the `rememberMe`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try running the application now, we’ll see nothing different in the flow.
    This is because we also need to add a field to the login form that allows the
    user to opt for this functionality. Edit the `login.xhtml` file and add a checkbox,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: When we next log in, if the remember-me box is selected, a remember-me cookie
    is set in the user’s browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Security understands that it should remember the user by inspecting the
    `remember-me` HTTP parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In Spring Security 4.x and after, the default remember-me form field is `remember-me`.
    This can be overridden with the `rememberMeParameter` method.
  prefs: []
  type: TYPE_NORMAL
- en: If the user then closes their browser and reopens it to an authenticated page
    on the JBCP calendar website, they won’t be presented with the login page a second
    time. Try it yourself now—log in with the remember-me option selected, bookmark
    the home page, then restart the browser and access the home page. You’ll see that
    you’re immediately logged in successfully without needing to supply your login
    credentials again. If this appears to be happening to you, it means that your
    browser or a browser plugin is restoring the session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Try closing the tab first and then close the browser.
  prefs: []
  type: TYPE_NORMAL
- en: One more effective solution is to use Chrome developer tools to remove the `JSESSIONID`
    cookie. This can often save time and annoyance during the development and verification
    of this type of feature on your site.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Exploring the remember-me cookie](img/B21757_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Exploring the remember-me cookie
  prefs: []
  type: TYPE_NORMAL
- en: After logging in and selecting `remember-me`, you should see two cookies have
    been set, `JSESSIONID` and `remember-me`, as shown in the screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: How the token-based remember-me feature works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The remember-me feature sets a cookie in the user’s browser containing a Base64-encoded
    string with the following pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: The username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expiration date/time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An SHA-256 hash value of the `expiration` date/time, `username`, `password`,
    and the `key` attribute of the `rememberMe` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are combined into a single cookie value that is stored in the browser
    for later use. The cookie is composed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the upcoming section, we’ll explore the SHA-256 algorithm in conjunction
    with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, this implementation uses the SHA-256 algorithm to encode the token
    signature. To verify the token signature, the algorithm retrieved from `algorithmName`
    is parsed and used. If `algorithmName` is not present, the default matching algorithm
    will be used, which is `SHA-256`. You can specify different algorithms for signature
    encoding and for signature matching; this allows users to safely upgrade to a
    different encoding algorithm while still being able to verify old ones if `algorithmName`
    is not present. To do that, you can specify your customized `TokenBasedRememberMeServices`
    as a bean and use it in the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To recap, we’ve covered the SHA-256 algorithm, and in the next section, we’ll
    delve into the remember-me signature.
  prefs: []
  type: TYPE_NORMAL
- en: Remember-me signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see how `SHA-256` can ensure that we have downloaded the correct file,
    but how does this apply to Spring Security’s remember-me service? Much like the
    file we downloaded, the cookie is untrusted, but we can trust it if we can validate
    the signature that originated from our application. When a request comes in with
    the remember-me cookie, its contents are extracted, and the expected signature
    is compared to the signature found in the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in calculating the expected signature are illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – SHA-256 Hash-Based Token Approach](img/B21757_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – SHA-256 Hash-Based Token Approach
  prefs: []
  type: TYPE_NORMAL
- en: The remember-me cookie contains the `username`, `expiration`, and `signature`.
    Spring Security will extract the `username` and `expiration` from the cookie.
    It will then utilize the `username` from the cookie to look up the `password`
    using `UserDetailsService`. The `key` is already known because it was provided
    using the `rememberMe` method. Now that all of the arguments are known, Spring
    Security can calculate the expected signature using the `username`, `expiration`,
    `password`, and `key`. It then compares the `expected` `signature` against the
    cookie’s `signature`.
  prefs: []
  type: TYPE_NORMAL
- en: If the two signatures match, we can trust that the `username` and `expiration`
    date are valid. Forging a `signature` is next to impossible without knowing the
    remember-me key (which only the application knows) and the user’s password (which
    only this user knows). This means that if the signatures match and the token is
    not expired, the user can be logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You have anticipated that if the user changes their username or password, any
    remember-me token set will no longer be valid. Make sure that you provide appropriate
    messaging to users if you allow them to change these bits of their account. Later
    in this chapter, we will look at an alternative remember-me implementation that
    is reliant only on the username and not on the password.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is still possible to differentiate between users who have been
    authenticated with a remember-me cookie and users who have presented the username
    and password (or equivalent) credentials. We’ll experiment with this shortly when
    we investigate the security of the remember-me feature.
  prefs: []
  type: TYPE_NORMAL
- en: Token-based remember-me configuration directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two configuration changes are commonly made to alter the default
    behavior of the remember-me functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | This defines a unique key used when producing the remember-me cookie’s
    signature. |'
  prefs: []
  type: TYPE_TB
- en: '| `tokenValiditySeconds` | This defines the length of time (in seconds). The
    remember-me cookie will be considered valid for authentication. It is also used
    to set the cookie expiration timestamp. |'
  prefs: []
  type: TYPE_TB
- en: Table 7.3 – The main configuration of the remember-me cookie
  prefs: []
  type: TYPE_NORMAL
- en: As you may infer from the discussion of how the cookie contents are hashed,
    the `key` attribute is critical for the security of the remember-me feature. Make
    sure that the key you choose is likely to be unique to your application and long
    enough so that it can’t be easily guessed.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind the purpose of this book, we’ve kept the `key` values relatively
    simple, but if you’re using remember-me in your application, it’s suggested that
    your key contains the unique name of your application and is at least 36 random
    characters long. Password generator tools (search `online password generator`
    on Google) are a great way to get a pseudo-random mix of alphanumeric and special
    characters to compose your remember-me key. For applications that exist in multiple
    environments (such as development, test, and production), the remember-me cookie
    value should include this fact as well. This will prevent remember-me cookies
    from inadvertently being used in the wrong environment during testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'An example key value in a production application might be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `tokenValiditySeconds` method is used to set the number of seconds after
    which the remember-me token will not be accepted for the automatic login function,
    even if it is otherwise a valid token. The same attribute is also used to set
    the maximum lifetime of the remember-me cookie on the user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of the remember-me session cookies
  prefs: []
  type: TYPE_NORMAL
- en: If `tokenValiditySeconds` is set to `-1`, the login cookie will be set to a
    session cookie, which does not persist after the browser is closed by the user.
    The token will be valid (assuming the user doesn’t close the browser) for a non-configurable
    length of two weeks. Don’t confuse this with the cookie that stores your user’s
    session ID—they’re two different things with similar names!
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we listed very few attributes. Don’t worry, we will
    spend time covering some of the other configuration attributes throughout this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Is remember-me secure?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any feature related to security that has been added for user convenience has
    the potential to expose our carefully protected site to a security risk. The remember-me
    feature, in its default form, runs the risk of the user’s cookie being intercepted
    and reused by a malicious user. The following diagram illustrates how this might
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 –Remember-me session cookie replay attack](img/B21757_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 –Remember-me session cookie replay attack
  prefs: []
  type: TYPE_NORMAL
- en: The use of **Secure Sockets Layer** (**SSL**) (covered in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material*) and other network security techniques can mitigate
    this type of attack, but be aware that there are other techniques, such as **Cross-Site
    Scripting** (**XSS**), that can steal or compromise a remembered user session.
    While convenient for the user, we don’t want to risk financial or other personal
    information being inadvertently changed or possibly stolen if the remembered session
    is misused.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Although we don’t cover malicious user behavior in detail in this book, when
    implementing any secured system, it is important to understand the techniques
    employed by users who may be trying to hack your customers or employees. XSS is
    one such technique, but many others exist. It’s highly recommended that you review
    the *OWASP Top Ten* article ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/))
    for a good list, and also pick up a web application security reference book in
    which many of the techniques demonstrated are illustrated to apply to any technology.
  prefs: []
  type: TYPE_NORMAL
- en: One common approach for maintaining the balance between convenience and security
    is identifying the functional locations on the site where personal or sensitive
    information could be present. You can then use the `fullyAuthenticated` expression
    to ensure these locations are protected using an authorization that checks not
    just the user’s role, but that they have been authenticated with a full username
    and password. We will explore this feature in greater detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization rules for remember-me
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll fully explore the advanced authorization techniques later in [*Chapter
    11*](B21757_11.xhtml#_idTextAnchor332), *Fine-Grained Access Control*, however,
    it’s important to realize that it’s possible to differentiate access rules based
    on whether or not an authenticated session was remembered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we want to limit users trying to access the `H2 admin` console
    to administrators who have been authenticated using a username and password. This
    is similar to the behavior found in other major consumer-focused commerce sites,
    which restrict access to the elevated portions of the site until a password is
    entered. Keep in mind that every site is different, so don’t blindly apply such
    rules to your secure site. For our sample application, we’ll concentrate on protecting
    the H2 database console. Update the `SecurityConfig.java` file to use the `fullyAuthenticated`
    keyword, which ensures that remembered users who try to access the H2 database
    are denied access. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The existing rules remain unchanged. We’ve added a rule that requires requests
    for account information to have the appropriate `GrantedAuthority` of `ROLE_ADMIN`,
    and that the user is fully authenticated; that is, during this authenticated session,
    they have presented a username and password or other suitable credentials. Note
    the syntax of the `AND`, `OR`, and `NOT` are used for logical operators in `SpEL`.
    This was thoughtful of the `SpEL` designers, as the `&&` operator would be awkward
    to represent in XML, even though the preceding example uses Java-based configuration!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and log in with the username `admin1@example.com` and the password
    `admin1`, ensuring you select the remember-me feature. Access the H2 database
    console and you will see that the access is granted. Now, delete the `JSESSIONID`
    cookie (or close the tab and then all of the browser instances), and ensure that
    access is still granted to the **All** **Events** page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, navigate to the H2 console and observe that the access is denied.
  prefs: []
  type: TYPE_NORMAL
- en: This approach combines the usability enhancements of the remember-me feature
    with an additional level of security by requiring a user to present a full set
    of credentials to access sensitive information. Throughout the rest of the chapter,
    we will explore other ways of making the remember-me feature more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent remember-me
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Security provides the capability to alter the method for validating the
    remember-me cookie by leveraging different implementations of the `RememberMeServices`
    interface. In this section, we will discuss how we can use persistent remember-me
    tokens using a database, and how this can increase the security of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the persistent-based remember-me feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modifying our remember-me configuration at this point to persist to the database
    is surprisingly trivial. The Spring Security configuration parser will recognize
    a new `tokenRepository` method on the `rememberMe` method, and simply switch implementation
    classes for `RememberMeServices`. Let’s now review the steps required to accomplish
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding SQL to create the remember-me schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have placed the SQL file containing the expected schema in our `src/main/resources`
    folder in the same place we did in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068),
    *Custom Authentication*. You can view the schema definition in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the data source with the remember-me schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring Data will automatically initialize the embedded database with `schema.sql`,
    as described in the preceding section. Note, however, that with `data.sql` file
    used to seed the database, we must ensure data source initialization is deferred
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After reviewing the persistent-based remember-me functionality, specifically
    using a database, the next section will cover the configuration of this feature
    with JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the persistent-based remember-me feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we’ll need to make some brief configuration changes to the `rememberMe`
    declaration to point it to the data source we’re using, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to do to switch over to using persistent-based remember-me
    authentication. Go ahead and start up the application and give it a try. From
    a user standpoint, we do not notice any differences, but we know that the implementation
    backing this feature has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: How does the persistent-based remember-me feature work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of validating a signature present in the cookie, the persistent-based
    remember-me service validates if the token exists in a database. Each persistent
    remember-me cookie consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series identifier**: This identifies the initial login of a user and remains
    consistent each time the user is automatically logged in to the original session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token value**: A unique value that changes each time a user is authenticated
    using the remember-me feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Exploring the persistent-based remember-me feature](img/B21757_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Exploring the persistent-based remember-me feature
  prefs: []
  type: TYPE_NORMAL
- en: When the remember-me cookie is submitted, Spring Security will use an `o.s.s.web.authentication.rememberme.PersistentTokenRepository`
    implementation to look up the expected token value and expiration using the submitted
    series identifier. It will then compare the token value in the cookie to the expected
    token value. If the token is not expired and the two tokens match, the user is
    considered authenticated. A new remember-me cookie with the same series identifier,
    a new token value, and an updated expiration date will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: If the series token submitted is found in the database, but the tokens do not
    match, it can be assumed that someone stole the remember-me cookie. In this case,
    Spring Security will terminate this series of remember-me tokens and warn the
    user that their login has been compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The persisted tokens can be found in the database and viewed with the H2 console,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Getting the persisted token from the database](img/B21757_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Getting the persisted token from the database
  prefs: []
  type: TYPE_NORMAL
- en: After gaining an understanding of how the persistent-based remember-me feature
    operates in this chapter, we will delve into the JPA-based `PersistentTokenRepository`
    in the subsequent section.
  prefs: []
  type: TYPE_NORMAL
- en: JPA-based PersistentTokenRepository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen in the earlier chapters, using a Spring Data project for our
    database mapping can greatly simplify our work. So, to keep things consistent,
    we are going to refactor our `PersistentTokenRepository` interface, which uses
    `JdbcTokenRepositoryImpl`, to one that is JPA-based. We will do so by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a domain object to hold the persistent logins, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create an `o.s.d.jpa.repository.JpaRepository` repository
    instance, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create a custom `PersistentTokenRepository` interface to replace
    the `Jdbc` implementation. We have four methods we must override, but the code
    should look fairly familiar as we will be using JPA for all of the operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to make a few changes in the `SecurityConfig.java` file to declare
    the new `PersistentTokenTokenRepository` interface, but the rest of the configuration
    from the last section does not change, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is all we need to do to switch JDBC to JPA persistent-based remember-me
    authentication. Go ahead and start up the application and give it a try. From
    a user standpoint, we do not notice any differences, but we know that the implementation
    backing this feature has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom RememberMeServices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have used a fairly simple implementation of `PersistentTokenRepository`.
    We have used a JDBC-backed and JPA-backed implementation. This provided limited
    control over the cookie persistence; if we want more control, we wrap our `PersistentTokenRepository`
    interface in `RememberMeServices`. Spring Security has a slightly modified version,
    as previously described, called `PersistentTokenBasedRememberMeServices`, which
    we can wrap our custom `PersistentTokenRepository` interface in and use in our
    remember-me service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following section, we are going to wrap our existing `PersistentTokenRepository`
    interface with `PersistentTokenBasedRememberMeServices` and use the `rememberMeServices`
    method to wire it into our remember-me declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Are database-backed persistent tokens more secure?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like `TokenBasedRememberMeServices`, persistent tokens may be compromised
    by cookie theft or other man-in-the-middle techniques. The use of SSL, as covered
    in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference Material*
    can circumvent man-in-the-middle techniques. If you are using a `HttpOnly`, which
    will help to mitigate against the cookie being stolen in the event of an XSS vulnerability
    in the application. To learn more about the `HttpOnly` attribute, refer to the
    external resource on cookies provided earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using the persistent-based remember-me feature is that
    we can detect whether the cookie is compromised. If the correct series token and
    an incorrect token are presented, we know that any remember-me feature using that
    series token should be considered compromised, and we should terminate any sessions
    associated with it. Since the validation is stateful, we can also terminate the
    specific remember-me feature without needing to change the user’s password.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the expired remember-me sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The downside of using the persistent-based remember-me feature is that there
    is no built-in support for cleaning up the expired sessions. To do this, we need
    to implement a background process that cleans up the expired sessions. We have
    included code in the chapter’s sample code to perform the cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: 'For conciseness, we display a version that does not do validation or error
    handling in the following code snippet. You can view the full version in the sample
    code of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample code for this chapter also includes a simple Spring configuration
    that will execute the cleaner every ten minutes. If you are unfamiliar with Spring’s
    task abstraction and want to learn it, then you may want to read more about it
    at [https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml](https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml).
    You can find the relevant configuration in the following code snippet. For clarity,
    we are putting this scheduler in the `JavaConfig.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this configuration is not cluster aware. Therefore, if this
    is deployed to a cluster, the cleaner will execute once for every **Java Virtual
    Machine (JVM)** that the application is deployed to.
  prefs: []
  type: TYPE_NORMAL
- en: Start up the application and give the updates a try. The configuration that
    was provided will ensure that the cleaner is executed every ten minutes. You may
    want to change the cleaner task to run more frequently and clean up the more recently
    used remember-me tokens by modifying the `@Scheduled` declaration. You can then
    create a few remember-me tokens and see that they get deleted by querying for
    them in the H2 database console.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.06-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: The remember-me architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone over the basic architecture of both `TokenBasedRememberMeServices`
    and `PersistentTokenBasedRememberMeServices`, but we have not described the overall
    architecture. Let’s see how all of the remember-me pieces fit together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the different components involved in the
    process of validating a token-based `remember-me` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The remember-me architecture](img/B21757_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The remember-me architecture
  prefs: []
  type: TYPE_NORMAL
- en: As with any of the Spring Security filters, `RememberMeAuthenticationFilter`
    is invoked from within `FilterChainProxy`. The job of `RememberMeAuthenticationFilter`
    is to inspect the request, and if it is of interest, an action is taken. The `RememberMeAuthenticationFilter`
    interface will use the `RememberMeServices` implementation to determine whether
    the user is already logged in. The `RememberMeServices` interface does this by
    inspecting the HTTP request for a remember-me cookie that is then validated using
    either the token-based validation or the persistent-based validation we previously
    discussed. If the token checks out, the user will be logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Remember-me and the user life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of `RememberMeServices` is invoked at several points in
    the user life cycle (the life cycle of an authenticated user’s session). To assist
    you in your understanding of the remember-me functionality, it can be helpful
    to be aware of the points in time when remember-me services are informed of life
    cycle functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **What** **should happen?** | **The RememberMeServices** **method
    invoked** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Successful login | The implementation sets a remember-me cookie (if the `form`
    parameter has been sent) | `loginSuccess` |'
  prefs: []
  type: TYPE_TB
- en: '| Failed login | The implementation should cancel the cookie if it’s present
    | `loginFailed` |'
  prefs: []
  type: TYPE_TB
- en: '| User logout | The implementation should cancel the cookie if it’s present
    | `Logout` |'
  prefs: []
  type: TYPE_TB
- en: Table 7.8 – Remember-me life cycle events
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `logout` method is not present on the `RememberMeServices` interface. Instead,
    each `RememberMeServices` implementation also implements the `LogoutHandler` interface,
    which contains the `logout` method. By implementing the `LogoutHandler` interface,
    each `RememberMeServices` implementation can perform the necessary cleanup when
    the user logs out.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing where and how `RememberMeServices` ties into the user’s life cycle will
    be important when we begin to create custom authentication handlers because we
    need to ensure that any authentication processor treats `RememberMeServices` consistently
    to preserve the usefulness and security of this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting the remember-me feature to an IP address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s put our understanding of the remember-me architecture to use. A common
    requirement is that any remember-me token should be tied to the IP address of
    the user who created it. This adds additional security to the remember-me feature.
    To do this, we only need to implement a custom `PersistentTokenRepository` interface.
    The configuration changes that we will make will illustrate how to configure a
    custom `RememberMeServices`. Throughout this section, we will take a look at `IpAwarePersistentTokenRepository`,
    which is included in the chapter’s source code. The `IpAwarePersistenTokenRepository`
    interface ensures that the series identifier is internally combined with the current
    user’s IP address, and the series identifier includes only the identifier externally.
    This means that whenever a token is looked up or saved, the current IP address
    is used to look up or persist the token. In the following code snippets, you can
    see how `IpAwarePersistentTokenRepository` works. If you want to dig in even deeper,
    we encourage you to view the source code included in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick to looking up the IP address is using `RequestContextHolder` of Spring
    Security. The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that to use `RequestContextHolder`, you need to ensure you
    have set up your `web.xml` file to use `RequestContextListener`. We have already
    performed this setup for our sample code. However, this can be useful when utilizing
    the example code in an external application. Refer to the Javadoc of `IpAwarePersistentTokenRepository`
    for details on how to set this up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build on this method to force tokens that are saved to include the IP
    address in the series identifier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we first created a new series with the IP address concatenated
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: The `tokenWithSeries` method is just a helper that creates a new token with
    all of the same values, except a new series. We then submit the new token with
    a series identifier, which includes the IP address, to `delegateRepository`, which
    is the original implementation of `PersistentTokenRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever the tokens are looked up, we require that the current user’s IP address
    is appended to the series identifier. This means that there is no way for a user
    to obtain a token for a user with a different IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The remainder of the code is quite similar. Internally, we construct the series
    identifier to be appended to the IP address, and externally, we present only the
    original series identifier. By doing this, we enforce the constraint that only
    the user who created the remember-me token can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the Spring configuration included in this chapter’s sample code
    for `IpAwarePersistent` **TokenRepository**. In the following code snippet, we
    first create the `IpAwarePersistent` **TokenRepository** declaration that wraps
    a new `JpaPersistentTokenRepository` declaration. We then initialize a `RequestContextFilter`
    class by instantiating an `OrderedRequestContextFilter` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, go ahead and start up the application. You can use the second computer
    along with a plugin, such as Firebug, to manipulate your remember-me cookie. If
    you try to use the remember-me cookie from one computer on another computer, Spring
    Security will now ignore the remember-me request and delete the associated cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.07-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the IP-based remember-me tokens may behave unexpectedly if the user
    is behind a shared or load-balanced network infrastructure, such as a multi **Wide-Area
    Network (WAN)** corporate environment. In most scenarios, however, the addition
    of an IP address to the remember-me function provides an additional, welcome layer
    of security to a helpful user feature.
  prefs: []
  type: TYPE_NORMAL
- en: Custom cookie and HTTP parameter names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Curious users may wonder whether the expected value of the remember-me form
    field checkbox to be remember-me, or the cookie name to be remember-me, can be
    changed to obscure the use of Spring Security. This change can be made in one
    of two locations. Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply define more properties to change the checkbox and cookie names
    in `RememberMeServices` `bean`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don’t forget to change the `login.xhtml` page to set the name of the `checkbox
    form field` and to match the parameter value we declared. Go ahead and make the
    updates to `login.xhtml`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’d encourage you to experiment here to ensure you understand how these settings
    are related. Go ahead and start up the application and give it a try.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter07.08-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained and demonstrated the use of the remember-me feature in
    Spring Security. We started with the most basic setup and learned how to gradually
    make the feature more secure. Specifically, we learned about a token-based remember-me
    service and how to configure it. We also explore how persistent-based remember-me
    services can provide additional security, how they work, and the additional considerations
    necessary when using them.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the creation of a custom remember-me implementation that restricts
    the remember-me token to a specific IP address. We saw various other ways to make
    the remember-me feature more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Up next is **certificate-based authentication**, and we will discuss how to
    use trusted client-side certificates to perform authentication.
  prefs: []
  type: TYPE_NORMAL
