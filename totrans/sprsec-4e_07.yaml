- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Remember-me Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “记住我”服务
- en: 'In this chapter, we’ll add the ability for an application to remember a user
    even after their session has expired and the browser is closed. The following
    topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加一个功能，使应用程序能够在会话过期和浏览器关闭后仍然记住用户。本章将涵盖以下主题：
- en: Discussing what **remember-me** is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论什么是“记住我”
- en: Learning how to use the token-based remember-me feature
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用基于令牌的“记住我”功能
- en: Discussing how secure remember-me is, and various ways of making it more secure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论如何确保“记住我”的安全性，以及各种提高其安全性的方法
- en: Enabling the persistent-based remember-me feature, and how to handle additional
    considerations for using it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用基于持久的“记住我”功能，以及如何处理使用它时的额外考虑因素
- en: Presenting the overall remember-me architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示“记住我”的整体架构
- en: Learning how to create a custom remember-me implementation that is restricted
    to the user’s IP address
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建一个仅限于用户IP地址的定制“记住我”实现
- en: 'This chapter’s code in action link is here: [https://packt.link/WEEx2](https://packt.link/WEEx2).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例链接在此：[https://packt.link/WEEx2](https://packt.link/WEEx2)。
- en: What is remember-me?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是“记住我”？
- en: A convenient feature to offer frequent users of a website is the remember-me
    feature. This feature allows a user to elect to be remembered even after their
    browser is closed. In Spring Security, this is implemented through the use of
    a remember-me **cookie** that is stored in the user’s browser. If Spring Security
    recognizes that the user is presenting a remember-me cookie, then the user will
    automatically be logged into the application, and will not need to enter a username
    or password.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个方便的功能，让网站的常客能够选择在浏览器关闭后仍然被记住。在Spring Security中，这是通过在用户的浏览器中存储一个“记住我”**cookie**来实现的。如果Spring
    Security识别出用户正在展示一个“记住我”cookie，那么用户将自动登录到应用程序，并且不需要输入用户名或密码。
- en: What is a cookie?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是cookie？
- en: A cookie is a way for a client (that is, a web browser) to persist the state.
    For more information about cookies, refer to additional online resources, such
    as Wikipedia ([https://en.wikipedia.org/wiki/HTTP_cookie](https://en.wikipedia.org/wiki/HTTP_cookie)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie是一种客户端（即，网页浏览器）持久化状态的方式。有关Cookie的更多信息，请参阅其他在线资源，例如维基百科([https://en.wikipedia.org/wiki/HTTP_cookie](https://en.wikipedia.org/wiki/HTTP_cookie))。
- en: 'Spring Security provides the following two different strategies that we will
    discuss in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了以下两种不同的策略，我们将在本章中讨论：
- en: The first is the token-based remember-me feature, which relies on a cryptographic
    signature
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是基于令牌的“记住我”功能，它依赖于加密签名
- en: The second method, the `persistent-based remember-me` feature, requires a datastore
    (a database)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是`基于持久的记住我`功能，它需要一个数据存储（数据库）
- en: As we previously mentioned, we will discuss these strategies in much greater
    detail throughout this chapter. The remember-me feature must be explicitly configured
    in order to enable it. Let’s start by trying the token-based remember-me feature
    and see how it affects the flow of the login experience.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们将在本章中更详细地讨论这些策略。要启用“记住我”功能，必须显式配置。让我们先尝试基于令牌的“记住我”功能，看看它如何影响登录体验的流程。
- en: Dependencies
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The token-based remember-me section does not need any additional dependencies
    other than the basic setup from [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. However, you will want to ensure you include
    the following additional dependencies in your `build.gradle` file if you are leveraging
    the persistent-based remember-me feature. We have already included these dependencies
    in the chapter’s sample, so there is no need to update the sample application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的“记住我”部分不需要除基本设置外任何额外的依赖项，基本设置来自[*第2章*](B21757_02.xhtml#_idTextAnchor043)，*Spring
    Security入门*。然而，如果您正在利用基于持久的“记住我”功能，您可能需要在您的`build.gradle`文件中包含以下额外的依赖项。我们已经在章节的示例中包含了这些依赖项，因此无需更新示例应用程序：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The token-based remember-me feature
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于令牌的“记住我”功能
- en: Spring Security provides two different implementations of the remember-me feature.
    We will start by exploring how to set up token-based remember-me services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了两种不同的“记住我”功能的实现。我们将首先探讨如何设置基于令牌的“记住我”服务。
- en: Configuring the token-based remember-me feature
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置基于令牌的“记住我”功能
- en: 'Completing this exercise will allow us to provide a simple and secure method
    to keep users logged in for extended periods of time. To start, perform the following
    steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习将使我们能够提供一个简单且安全的方法，以延长用户登录时间。首先，执行以下步骤：
- en: Modify the `SecurityConfig.java` configuration file and add the `rememberMe`
    method.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`SecurityConfig.java`配置文件并添加`rememberMe`方法。
- en: 'Take a look at the following code snippet:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.00-calendar`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter07.00-calendar`的源代码开始。
- en: 'If we try running the application now, we’ll see nothing different in the flow.
    This is because we also need to add a field to the login form that allows the
    user to opt for this functionality. Edit the `login.xhtml` file and add a checkbox,
    as shown in the following code snippet:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行应用程序，我们会看到流程中没有不同之处。这是因为我们还需要在登录表单中添加一个字段，允许用户选择此功能。编辑`login.xhtml`文件并添加一个复选框，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.01-calendar`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter07.01-calendar`的源代码开始。
- en: When we next log in, if the remember-me box is selected, a remember-me cookie
    is set in the user’s browser.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们下次登录时，如果选中了“记住我”复选框，将在用户的浏览器中设置一个“记住我”cookie。
- en: Spring Security understands that it should remember the user by inspecting the
    `remember-me` HTTP parameter.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Spring Security 通过检查`remember-me` HTTP参数来理解它应该通过记住用户。
- en: Important note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In Spring Security 4.x and after, the default remember-me form field is `remember-me`.
    This can be overridden with the `rememberMeParameter` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security 4.x及以后版本中，默认的“记住我”表单字段是`remember-me`。这可以通过`rememberMeParameter`方法来覆盖。
- en: If the user then closes their browser and reopens it to an authenticated page
    on the JBCP calendar website, they won’t be presented with the login page a second
    time. Try it yourself now—log in with the remember-me option selected, bookmark
    the home page, then restart the browser and access the home page. You’ll see that
    you’re immediately logged in successfully without needing to supply your login
    credentials again. If this appears to be happening to you, it means that your
    browser or a browser plugin is restoring the session.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户关闭浏览器并重新打开到JBCP日历网站的认证页面，他们不会再次被提示登录页面。现在就试试看——选择“记住我”选项登录，将主页添加到书签，然后重新启动浏览器并访问主页。您会看到您立即成功登录，无需再次提供登录凭证。如果这种情况发生在您身上，这意味着您的浏览器或浏览器插件正在恢复会话。
- en: Tip
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try closing the tab first and then close the browser.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试先关闭标签页，然后再关闭浏览器。
- en: One more effective solution is to use Chrome developer tools to remove the `JSESSIONID`
    cookie. This can often save time and annoyance during the development and verification
    of this type of feature on your site.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有效的解决方案是使用Chrome开发者工具来删除`JSESSIONID`cookie。这通常可以在您网站上开发验证此类功能时节省时间和烦恼。
- en: '![Figure 7.1 – Exploring the remember-me cookie](img/B21757_07_1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 探索“记住我”cookie](img/B21757_07_1.jpg)'
- en: Figure 7.1 – Exploring the remember-me cookie
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 探索“记住我”cookie
- en: After logging in and selecting `remember-me`, you should see two cookies have
    been set, `JSESSIONID` and `remember-me`, as shown in the screenshot.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 登录并选择“记住我”后，您应该看到已经设置了两个cookie，`JSESSIONID`和`remember-me`，如截图所示。
- en: How the token-based remember-me feature works
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于令牌的“记住我”功能是如何工作的
- en: 'The remember-me feature sets a cookie in the user’s browser containing a Base64-encoded
    string with the following pieces:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: “记住我”功能在用户的浏览器中设置一个包含以下内容的Base64编码字符串的cookie：
- en: The username
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: An expiration date/time
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过期日期/时间
- en: An SHA-256 hash value of the `expiration` date/time, `username`, `password`,
    and the `key` attribute of the `rememberMe` method
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expiration`日期/时间的SHA-256哈希值，`username`，`password`，以及`rememberMe`方法的`key`属性'
- en: 'These are combined into a single cookie value that is stored in the browser
    for later use. The cookie is composed as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容合并为一个单一的cookie值，存储在浏览器中以供后续使用。cookie的组成如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the upcoming section, we’ll explore the SHA-256 algorithm in conjunction
    with Spring Security.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将结合Spring Security来探讨SHA-256算法。
- en: SHA-256 Algorithm
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SHA-256 算法
- en: 'By default, this implementation uses the SHA-256 algorithm to encode the token
    signature. To verify the token signature, the algorithm retrieved from `algorithmName`
    is parsed and used. If `algorithmName` is not present, the default matching algorithm
    will be used, which is `SHA-256`. You can specify different algorithms for signature
    encoding and for signature matching; this allows users to safely upgrade to a
    different encoding algorithm while still being able to verify old ones if `algorithmName`
    is not present. To do that, you can specify your customized `TokenBasedRememberMeServices`
    as a bean and use it in the configuration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此实现使用SHA-256算法对令牌签名进行编码。为了验证令牌签名，从`algorithmName`检索到的算法将被解析并使用。如果`algorithmName`不存在，将使用默认匹配算法，即`SHA-256`。您可以为签名编码和签名匹配指定不同的算法；这允许用户在仍然能够验证旧版本的情况下安全地升级到不同的编码算法。为此，您可以指定您定制的`TokenBasedRememberMeServices`作为bean并在配置中使用它：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To recap, we’ve covered the SHA-256 algorithm, and in the next section, we’ll
    delve into the remember-me signature.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，我们已经涵盖了SHA-256算法，在下一节中，我们将深入探讨记住我签名。
- en: Remember-me signature
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住我签名
- en: We can see how `SHA-256` can ensure that we have downloaded the correct file,
    but how does this apply to Spring Security’s remember-me service? Much like the
    file we downloaded, the cookie is untrusted, but we can trust it if we can validate
    the signature that originated from our application. When a request comes in with
    the remember-me cookie, its contents are extracted, and the expected signature
    is compared to the signature found in the cookie.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`SHA-256`如何确保我们下载了正确的文件，但这是如何应用于Spring Security的记住我服务呢？与下载的文件类似，cookie是不可信的，但如果我们能够验证来自我们应用程序的签名，我们就可以信任它。当一个带有记住我cookie的请求到来时，其内容将被提取，预期的签名将与cookie中找到的签名进行比较。
- en: 'The steps in calculating the expected signature are illustrated in the following
    diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 计算预期签名的步骤在以下图中展示：
- en: '![Figure 7.2 – SHA-256 Hash-Based Token Approach](img/B21757_07_2.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 基于SHA-256散列的令牌方法](img/B21757_07_2.jpg)'
- en: Figure 7.2 – SHA-256 Hash-Based Token Approach
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 基于SHA-256散列的令牌方法
- en: The remember-me cookie contains the `username`, `expiration`, and `signature`.
    Spring Security will extract the `username` and `expiration` from the cookie.
    It will then utilize the `username` from the cookie to look up the `password`
    using `UserDetailsService`. The `key` is already known because it was provided
    using the `rememberMe` method. Now that all of the arguments are known, Spring
    Security can calculate the expected signature using the `username`, `expiration`,
    `password`, and `key`. It then compares the `expected` `signature` against the
    cookie’s `signature`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我cookie包含`用户名`、`过期时间`和`签名`。Spring Security将从cookie中提取`用户名`和`过期时间`。然后，它将使用`UserDetailsService`通过`用户名`查找`密码`。`密钥`已经已知，因为它是在使用`rememberMe`方法时提供的。现在，所有参数都已知晓，Spring
    Security可以使用`用户名`、`过期时间`、`密码`和`密钥`来计算预期的签名。然后，它将比较预期的`签名`与cookie中的`签名`。
- en: If the two signatures match, we can trust that the `username` and `expiration`
    date are valid. Forging a `signature` is next to impossible without knowing the
    remember-me key (which only the application knows) and the user’s password (which
    only this user knows). This means that if the signatures match and the token is
    not expired, the user can be logged in.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个签名匹配，我们可以相信`用户名`和`过期时间`是有效的。在没有知道记住我密钥（只有应用程序知道）和用户的密码（只有这个用户知道）的情况下伪造签名几乎是不可能的。这意味着如果签名匹配且令牌未过期，用户可以登录。
- en: Important note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You have anticipated that if the user changes their username or password, any
    remember-me token set will no longer be valid. Make sure that you provide appropriate
    messaging to users if you allow them to change these bits of their account. Later
    in this chapter, we will look at an alternative remember-me implementation that
    is reliant only on the username and not on the password.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经预见到，如果用户更改他们的用户名或密码，任何设置的记住我令牌将不再有效。如果您允许用户更改他们账户的这些信息，请确保您向用户提供适当的消息。在本章的后面部分，我们将探讨一种仅依赖于用户名而不是密码的替代记住我实现。
- en: Note that it is still possible to differentiate between users who have been
    authenticated with a remember-me cookie and users who have presented the username
    and password (or equivalent) credentials. We’ll experiment with this shortly when
    we investigate the security of the remember-me feature.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仍然可以区分使用记住我cookie进行身份验证的用户和提交了用户名和密码（或等效）凭据的用户。我们将在稍后当我们调查记住我功能的安全性时进行实验。
- en: Token-based remember-me configuration directives
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于token的记住我配置指令
- en: 'The following two configuration changes are commonly made to alter the default
    behavior of the remember-me functionality:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常对以下两个配置更改进行更改，以改变记住我功能的默认行为：
- en: '| **Attribute** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `key` | This defines a unique key used when producing the remember-me cookie’s
    signature. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 这定义了在生成记住我cookie签名时使用的唯一密钥。|'
- en: '| `tokenValiditySeconds` | This defines the length of time (in seconds). The
    remember-me cookie will be considered valid for authentication. It is also used
    to set the cookie expiration timestamp. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `tokenValiditySeconds` | 这定义了时间长度（以秒为单位）。记住我cookie将被视为有效的身份验证。它也用于设置cookie过期时间戳。|'
- en: Table 7.3 – The main configuration of the remember-me cookie
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3 – 记住我cookie的主要配置
- en: As you may infer from the discussion of how the cookie contents are hashed,
    the `key` attribute is critical for the security of the remember-me feature. Make
    sure that the key you choose is likely to be unique to your application and long
    enough so that it can’t be easily guessed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从对cookie内容哈希处理的讨论中，你可以推断出`key`属性对于记住我功能的安全性至关重要。请确保你选择的密钥对你的应用程序来说是唯一的，并且足够长，以至于不容易被猜到。
- en: Keeping in mind the purpose of this book, we’ve kept the `key` values relatively
    simple, but if you’re using remember-me in your application, it’s suggested that
    your key contains the unique name of your application and is at least 36 random
    characters long. Password generator tools (search `online password generator`
    on Google) are a great way to get a pseudo-random mix of alphanumeric and special
    characters to compose your remember-me key. For applications that exist in multiple
    environments (such as development, test, and production), the remember-me cookie
    value should include this fact as well. This will prevent remember-me cookies
    from inadvertently being used in the wrong environment during testing!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到本书的目的，我们保持了`key`值的相对简单，但如果你在应用程序中使用记住我功能，建议你的密钥包含你应用程序的唯一名称，并且至少包含36个随机字符。密码生成工具（在谷歌上搜索`在线密码生成器`）是获取用于组成记住我密钥的伪随机字母数字和特殊字符混合的好方法。对于存在于多个环境（如开发、测试和生产）中的应用程序，记住我cookie值应包含这一事实。这将防止在测试期间意外地在错误的环境中使用了记住我cookie！
- en: 'An example key value in a production application might be similar to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用中，一个示例密钥值可能类似于以下内容：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `tokenValiditySeconds` method is used to set the number of seconds after
    which the remember-me token will not be accepted for the automatic login function,
    even if it is otherwise a valid token. The same attribute is also used to set
    the maximum lifetime of the remember-me cookie on the user’s browser.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenValiditySeconds`方法用于设置记住我token在自动登录功能中不被接受的时间（以秒为单位），即使它是一个有效的token。相同的属性也用于设置用户浏览器上记住我cookie的最大生命周期。'
- en: Configuration of the remember-me session cookies
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我会话cookie的配置
- en: If `tokenValiditySeconds` is set to `-1`, the login cookie will be set to a
    session cookie, which does not persist after the browser is closed by the user.
    The token will be valid (assuming the user doesn’t close the browser) for a non-configurable
    length of two weeks. Don’t confuse this with the cookie that stores your user’s
    session ID—they’re two different things with similar names!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`tokenValiditySeconds`设置为`-1`，登录cookie将被设置为会话cookie，用户关闭浏览器后不会持久保存。假设用户没有关闭浏览器，token将有效（非配置长度为两周）。不要将此与存储用户会话ID的cookie混淆——它们是两个具有相似名称的不同事物！
- en: You may have noticed that we listed very few attributes. Don’t worry, we will
    spend time covering some of the other configuration attributes throughout this
    chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们列出的属性非常少。不用担心，我们将在本章中花费时间介绍一些其他配置属性。
- en: Is remember-me secure?
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我是安全的吗？
- en: 'Any feature related to security that has been added for user convenience has
    the potential to expose our carefully protected site to a security risk. The remember-me
    feature, in its default form, runs the risk of the user’s cookie being intercepted
    and reused by a malicious user. The following diagram illustrates how this might
    happen:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任何为了用户便利性而添加的安全相关功能都有可能使我们的精心保护网站面临安全风险。记住我功能在其默认形式下，存在用户cookie被恶意用户拦截和重用的风险。以下图表说明了这种情况可能发生的方式：
- en: '![Figure 7.3 –Remember-me session cookie replay attack](img/B21757_07_3.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 记住我会话cookie重放攻击](img/B21757_07_3.jpg)'
- en: Figure 7.3 –Remember-me session cookie replay attack
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 记住我会话cookie重放攻击
- en: The use of **Secure Sockets Layer** (**SSL**) (covered in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material*) and other network security techniques can mitigate
    this type of attack, but be aware that there are other techniques, such as **Cross-Site
    Scripting** (**XSS**), that can steal or compromise a remembered user session.
    While convenient for the user, we don’t want to risk financial or other personal
    information being inadvertently changed or possibly stolen if the remembered session
    is misused.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**安全套接字层**（**SSL**）（在[*附录*](B21757_20.xhtml#_idTextAnchor642)“附加参考资料”中介绍）和其他网络安全技术可以减轻此类攻击，但请注意，还有其他技术，如**跨站脚本**（**XSS**），可以窃取或破坏记住的用户会话。虽然这对用户来说很方便，但我们不希望因误用记住的会话而导致财务或其他个人信息意外更改或被盗。
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although we don’t cover malicious user behavior in detail in this book, when
    implementing any secured system, it is important to understand the techniques
    employed by users who may be trying to hack your customers or employees. XSS is
    one such technique, but many others exist. It’s highly recommended that you review
    the *OWASP Top Ten* article ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/))
    for a good list, and also pick up a web application security reference book in
    which many of the techniques demonstrated are illustrated to apply to any technology.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这本书中没有详细讨论恶意用户行为，但在实施任何安全系统时，了解可能试图黑客攻击你的客户或员工的用户所采用的技术是很重要的。XSS就是这样一种技术，但还有许多其他技术。强烈建议您查看*OWASP
    Top Ten*文章([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/))以获取一份良好的列表，并挑选一本关于Web应用安全性的参考书籍，其中许多展示的技术可以应用于任何技术。
- en: One common approach for maintaining the balance between convenience and security
    is identifying the functional locations on the site where personal or sensitive
    information could be present. You can then use the `fullyAuthenticated` expression
    to ensure these locations are protected using an authorization that checks not
    just the user’s role, but that they have been authenticated with a full username
    and password. We will explore this feature in greater detail in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持便利性和安全性平衡的常见方法中，是确定网站上可能存在个人或敏感信息的功能位置。然后，你可以使用`fullyAuthenticated`表达式来确保这些位置通过授权得到保护，这种授权不仅检查用户的角色，而且还检查他们是否使用完整的用户名和密码进行了认证。我们将在下一节中更详细地探讨这个功能。
- en: Authorization rules for remember-me
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住我授权规则
- en: We’ll fully explore the advanced authorization techniques later in [*Chapter
    11*](B21757_11.xhtml#_idTextAnchor332), *Fine-Grained Access Control*, however,
    it’s important to realize that it’s possible to differentiate access rules based
    on whether or not an authenticated session was remembered.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第11章*](B21757_11.xhtml#_idTextAnchor332)“细粒度访问控制”中全面探讨高级授权技术，然而，重要的是要认识到可以根据是否记住认证会话来区分访问规则。
- en: 'Let’s assume we want to limit users trying to access the `H2 admin` console
    to administrators who have been authenticated using a username and password. This
    is similar to the behavior found in other major consumer-focused commerce sites,
    which restrict access to the elevated portions of the site until a password is
    entered. Keep in mind that every site is different, so don’t blindly apply such
    rules to your secure site. For our sample application, we’ll concentrate on protecting
    the H2 database console. Update the `SecurityConfig.java` file to use the `fullyAuthenticated`
    keyword, which ensures that remembered users who try to access the H2 database
    are denied access. This is shown in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要限制尝试访问 `H2 管理员` 控制台的用户仅限于使用用户名和密码进行认证的管理员。这与在其他主要面向消费者的商业网站上找到的行为类似，这些网站在输入密码之前会限制对网站高级部分的访问。请记住，每个网站都是不同的，所以不要盲目地将此类规则应用到您的安全网站上。对于我们的示例应用程序，我们将专注于保护
    H2 数据库控制台。更新 `SecurityConfig.java` 文件以使用 `fullyAuthenticated` 关键字，这确保了尝试访问 H2
    数据库的已记住用户将被拒绝访问。这在上面的代码片段中显示：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The existing rules remain unchanged. We’ve added a rule that requires requests
    for account information to have the appropriate `GrantedAuthority` of `ROLE_ADMIN`,
    and that the user is fully authenticated; that is, during this authenticated session,
    they have presented a username and password or other suitable credentials. Note
    the syntax of the `AND`, `OR`, and `NOT` are used for logical operators in `SpEL`.
    This was thoughtful of the `SpEL` designers, as the `&&` operator would be awkward
    to represent in XML, even though the preceding example uses Java-based configuration!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的规则保持不变。我们添加了一条规则，要求请求账户信息必须具有适当的 `GrantedAuthority` 为 `ROLE_ADMIN`，并且用户是完全认证的；也就是说，在此认证会话期间，他们已出示用户名和密码或其他合适的凭据。注意
    `AND`、`OR` 和 `NOT` 的语法在 `SpEL` 中用作逻辑运算符。这是 `SpEL` 设计者深思熟虑的结果，因为 `&&` 运算符在 XML
    中表示起来会很尴尬，尽管前面的示例使用了基于 Java 的配置！
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.02-calendar`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从 `chapter07.02-calendar` 的源代码开始。
- en: Go ahead and log in with the username `admin1@example.com` and the password
    `admin1`, ensuring you select the remember-me feature. Access the H2 database
    console and you will see that the access is granted. Now, delete the `JSESSIONID`
    cookie (or close the tab and then all of the browser instances), and ensure that
    access is still granted to the **All** **Events** page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用用户名 `admin1@example.com` 和密码 `admin1` 登录，确保您选中了记住我功能。访问 H2 数据库控制台，您会发现访问权限已被授予。现在，删除
    `JSESSIONID` Cookie（或关闭标签页然后关闭所有浏览器实例），并确保对 **所有事件** 页面的访问权限仍然被授予。
- en: Now, navigate to the H2 console and observe that the access is denied.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导航到 H2 控制台并观察访问已被拒绝。
- en: This approach combines the usability enhancements of the remember-me feature
    with an additional level of security by requiring a user to present a full set
    of credentials to access sensitive information. Throughout the rest of the chapter,
    we will explore other ways of making the remember-me feature more secure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法结合了记住我功能的可用性增强，并通过要求用户出示完整的凭据来访问敏感信息，增加了一个额外的安全层。在本章的其余部分，我们将探讨其他使记住我功能更加安全的方法。
- en: Persistent remember-me
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化记住我
- en: Spring Security provides the capability to alter the method for validating the
    remember-me cookie by leveraging different implementations of the `RememberMeServices`
    interface. In this section, we will discuss how we can use persistent remember-me
    tokens using a database, and how this can increase the security of our application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 提供了通过利用 `RememberMeServices` 接口的不同实现来更改验证记住我 Cookie 方法的功能。在本节中，我们将讨论如何使用数据库持久化记住我令牌，以及这如何提高我们应用程序的安全性。
- en: Using the persistent-based remember-me feature
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基于持久化的记住我功能
- en: Modifying our remember-me configuration at this point to persist to the database
    is surprisingly trivial. The Spring Security configuration parser will recognize
    a new `tokenRepository` method on the `rememberMe` method, and simply switch implementation
    classes for `RememberMeServices`. Let’s now review the steps required to accomplish
    this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段修改我们的记住我配置以持久化到数据库是出奇地简单。Spring Security 配置解析器将识别 `rememberMe` 方法上的新 `tokenRepository`
    方法，并简单地切换 `RememberMeServices` 的实现类。现在，让我们回顾一下完成此操作所需的步骤。
- en: Adding SQL to create the remember-me schema
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 SQL 创建记住我架构
- en: 'We have placed the SQL file containing the expected schema in our `src/main/resources`
    folder in the same place we did in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068),
    *Custom Authentication*. You can view the schema definition in the following code
    snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包含预期模式的SQL文件放置在`src/main/resources`文件夹中，与我们在[*第3章*](B21757_03.xhtml#_idTextAnchor068)“自定义身份验证”中放置的位置相同。您可以在以下代码片段中查看模式定义：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Initializing the data source with the remember-me schema
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用记住我模式初始化数据源
- en: 'Spring Data will automatically initialize the embedded database with `schema.sql`,
    as described in the preceding section. Note, however, that with `data.sql` file
    used to seed the database, we must ensure data source initialization is deferred
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data将自动使用`schema.sql`初始化嵌入式数据库，如前所述。然而，请注意，使用用于初始化数据库的`data.sql`文件时，我们必须确保数据源初始化延迟如下：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After reviewing the persistent-based remember-me functionality, specifically
    using a database, the next section will cover the configuration of this feature
    with JPA.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了基于持久化的记住我功能，特别是使用数据库之后，下一节将介绍使用JPA配置此功能。
- en: Configuring the persistent-based remember-me feature
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基于持久化的记住我功能
- en: 'Finally, we’ll need to make some brief configuration changes to the `rememberMe`
    declaration to point it to the data source we’re using, as shown in the following
    code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对`rememberMe`声明进行一些简短的配置更改，以便将其指向我们正在使用的数据源，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is all we need to do to switch over to using persistent-based remember-me
    authentication. Go ahead and start up the application and give it a try. From
    a user standpoint, we do not notice any differences, but we know that the implementation
    backing this feature has changed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们切换到使用基于持久化的记住我身份验证所需做的所有事情。启动应用程序并尝试一下。从用户的角度来看，我们没有注意到任何差异，但我们知道支持此功能的实现已更改。
- en: Important note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.03-calendar`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter07.03-calendar`的源开始。
- en: How does the persistent-based remember-me feature work?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于持久化的记住我功能是如何工作的？
- en: 'Instead of validating a signature present in the cookie, the persistent-based
    remember-me service validates if the token exists in a database. Each persistent
    remember-me cookie consists of the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于持久化的记住我服务不是验证cookie中存在的签名，而是验证令牌是否存在于数据库中。每个基于持久化的记住我cookie包含以下内容：
- en: '**Series identifier**: This identifies the initial login of a user and remains
    consistent each time the user is automatically logged in to the original session'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系列标识符**：这标识了用户的初始登录，每次用户自动登录到原始会话时都保持一致'
- en: '**Token value**: A unique value that changes each time a user is authenticated
    using the remember-me feature'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌值**：每次用户使用记住我功能进行身份验证时都会更改的唯一值'
- en: 'Take a look at the following diagram:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表：
- en: '![Figure 7.4 – Exploring the persistent-based remember-me feature](img/B21757_07_4.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 探索基于持久化的记住我功能](img/B21757_07_4.jpg)'
- en: Figure 7.4 – Exploring the persistent-based remember-me feature
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 探索基于持久化的记住我功能
- en: When the remember-me cookie is submitted, Spring Security will use an `o.s.s.web.authentication.rememberme.PersistentTokenRepository`
    implementation to look up the expected token value and expiration using the submitted
    series identifier. It will then compare the token value in the cookie to the expected
    token value. If the token is not expired and the two tokens match, the user is
    considered authenticated. A new remember-me cookie with the same series identifier,
    a new token value, and an updated expiration date will be generated.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交记住我cookie时，Spring Security将使用`o.s.s.web.authentication.rememberme.PersistentTokenRepository`实现来查找预期的令牌值和过期时间，使用提交的系列标识符。然后，它将比较cookie中的令牌值与预期的令牌值。如果令牌未过期且两个令牌匹配，则认为用户已通过身份验证。将生成一个新的记住我cookie，具有相同的系列标识符、新的令牌值和更新的过期日期。
- en: If the series token submitted is found in the database, but the tokens do not
    match, it can be assumed that someone stole the remember-me cookie. In this case,
    Spring Security will terminate this series of remember-me tokens and warn the
    user that their login has been compromised.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提交的系列令牌在数据库中找到，但令牌不匹配，则可以假设有人偷走了记住我cookie。在这种情况下，Spring Security将终止这一系列的记住我令牌，并警告用户他们的登录已被破坏。
- en: 'The persisted tokens can be found in the database and viewed with the H2 console,
    as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化的令牌可以在数据库中找到，并使用以下屏幕截图查看：
- en: '![Figure 7.5 – Getting the persisted token from the database](img/B21757_07_5.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 从数据库获取持久化令牌](img/B21757_07_5.jpg)'
- en: Figure 7.5 – Getting the persisted token from the database
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 从数据库获取持久化令牌
- en: After gaining an understanding of how the persistent-based remember-me feature
    operates in this chapter, we will delve into the JPA-based `PersistentTokenRepository`
    in the subsequent section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中了解了基于持久化的 remember-me 功能的工作原理之后，我们将在下一节深入探讨基于 JPA 的 `PersistentTokenRepository`。
- en: JPA-based PersistentTokenRepository
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于JPA的 PersistentTokenRepository
- en: 'As we have seen in the earlier chapters, using a Spring Data project for our
    database mapping can greatly simplify our work. So, to keep things consistent,
    we are going to refactor our `PersistentTokenRepository` interface, which uses
    `JdbcTokenRepositoryImpl`, to one that is JPA-based. We will do so by performing
    the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，使用 Spring Data 项目进行我们的数据库映射可以大大简化我们的工作。因此，为了保持一致性，我们将重构我们的 `PersistentTokenRepository`
    接口，该接口使用 `JdbcTokenRepositoryImpl`，改为基于 JPA 的。我们将通过以下步骤来完成：
- en: 'First, let’s create a domain object to hold the persistent logins, as shown
    in the following code snippet:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个域对象来保存持久化登录信息，如下代码片段所示：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to create an `o.s.d.jpa.repository.JpaRepository` repository
    instance, as shown in the following code snippet:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 `o.s.d.jpa.repository.JpaRepository` 存储库实例，如下代码片段所示：
- en: '[PRE11]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we need to create a custom `PersistentTokenRepository` interface to replace
    the `Jdbc` implementation. We have four methods we must override, but the code
    should look fairly familiar as we will be using JPA for all of the operations:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个自定义的 `PersistentTokenRepository` 接口来替换 `Jdbc` 实现。我们必须重写四个方法，但代码看起来相当熟悉，因为我们将对所有操作使用
    JPA：
- en: '[PRE12]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we need to make a few changes in the `SecurityConfig.java` file to declare
    the new `PersistentTokenTokenRepository` interface, but the rest of the configuration
    from the last section does not change, as shown in the following code snippet:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `SecurityConfig.java` 文件中做一些修改，以声明新的 `PersistentTokenTokenRepository`
    接口，但上一节中的其余配置没有变化，如下代码片段所示：
- en: '[PRE13]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is all we need to do to switch JDBC to JPA persistent-based remember-me
    authentication. Go ahead and start up the application and give it a try. From
    a user standpoint, we do not notice any differences, but we know that the implementation
    backing this feature has changed.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们切换 JDBC 到 JPA 持久化 remember-me 认证的所需全部操作。启动应用程序并尝试一下。从用户的角度来看，我们没有注意到任何差异，但我们知道支持此功能的实现已经更改。
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.04-calendar`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从 `chapter07.04-calendar` 的源代码开始。
- en: Custom RememberMeServices
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 RememberMeServices
- en: Up to this point, we have used a fairly simple implementation of `PersistentTokenRepository`.
    We have used a JDBC-backed and JPA-backed implementation. This provided limited
    control over the cookie persistence; if we want more control, we wrap our `PersistentTokenRepository`
    interface in `RememberMeServices`. Spring Security has a slightly modified version,
    as previously described, called `PersistentTokenBasedRememberMeServices`, which
    we can wrap our custom `PersistentTokenRepository` interface in and use in our
    remember-me service.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了一个相当简单的 `PersistentTokenRepository` 实现。我们使用了基于 JDBC 和 JPA 的实现。这提供了对
    cookie 持久性的有限控制；如果我们想要更多的控制，我们将我们的 `PersistentTokenRepository` 接口包装在 `RememberMeServices`
    中。Spring Security 有一个稍微修改过的版本，如前所述，称为 `PersistentTokenBasedRememberMeServices`，我们可以将其包装在我们的自定义
    `PersistentTokenRepository` 接口中，并在我们的 remember-me 服务中使用。
- en: 'In the following section, we are going to wrap our existing `PersistentTokenRepository`
    interface with `PersistentTokenBasedRememberMeServices` and use the `rememberMeServices`
    method to wire it into our remember-me declaration:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将使用 `PersistentTokenBasedRememberMeServices` 包装我们的现有 `PersistentTokenRepository`
    接口，并使用 `rememberMeServices` 方法将其连接到我们的 remember-me 声明中：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Important note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.05-calendar`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从 `chapter07.05-calendar` 的源代码开始。
- en: Are database-backed persistent tokens more secure?
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库支持的持久化令牌是否更安全？
- en: Just like `TokenBasedRememberMeServices`, persistent tokens may be compromised
    by cookie theft or other man-in-the-middle techniques. The use of SSL, as covered
    in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference Material*
    can circumvent man-in-the-middle techniques. If you are using a `HttpOnly`, which
    will help to mitigate against the cookie being stolen in the event of an XSS vulnerability
    in the application. To learn more about the `HttpOnly` attribute, refer to the
    external resource on cookies provided earlier in the chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`TokenBasedRememberMeServices`一样，持久令牌可能会因为cookie被盗或中间人技术而被篡改。正如在[*附录*](B21757_20.xhtml#_idTextAnchor642)中所述，使用SSL（安全套接字层）可以绕过中间人技术。如果您使用的是`HttpOnly`，这有助于减轻应用程序中XSS漏洞导致cookie被盗的风险。要了解更多关于`HttpOnly`属性的信息，请参阅本章前面提供的关于cookie的外部资源。
- en: One of the advantages of using the persistent-based remember-me feature is that
    we can detect whether the cookie is compromised. If the correct series token and
    an incorrect token are presented, we know that any remember-me feature using that
    series token should be considered compromised, and we should terminate any sessions
    associated with it. Since the validation is stateful, we can also terminate the
    specific remember-me feature without needing to change the user’s password.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于持久化的记住我功能的优点之一是我们能够检测cookie是否被篡改。如果提供了正确的系列令牌和错误的令牌，我们知道使用该系列令牌的任何记住我功能都应该被视为被篡改，并且我们应该终止与其相关的任何会话。由于验证是状态性的，我们也可以在不更改用户密码的情况下终止特定的记住我功能。
- en: Cleaning up the expired remember-me sessions
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理过期的记住我会话
- en: The downside of using the persistent-based remember-me feature is that there
    is no built-in support for cleaning up the expired sessions. To do this, we need
    to implement a background process that cleans up the expired sessions. We have
    included code in the chapter’s sample code to perform the cleanup.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于持久化的记住我功能的缺点是，没有内置的支持来清理过期的会话。为此，我们需要实现一个后台进程来清理过期的会话。我们在本章的示例代码中包含了执行清理的代码。
- en: 'For conciseness, we display a version that does not do validation or error
    handling in the following code snippet. You can view the full version in the sample
    code of this chapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们在下面的代码片段中显示了一个不进行验证或错误处理的版本。您可以在本章的示例代码中查看完整版本：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The sample code for this chapter also includes a simple Spring configuration
    that will execute the cleaner every ten minutes. If you are unfamiliar with Spring’s
    task abstraction and want to learn it, then you may want to read more about it
    at [https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml](https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml).
    You can find the relevant configuration in the following code snippet. For clarity,
    we are putting this scheduler in the `JavaConfig.java` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码还包括一个简单的Spring配置，该配置将每十分钟执行一次清理器。如果您不熟悉Spring的任务抽象并且想了解更多，那么您可能想阅读更多关于它的内容，请参阅[https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml](https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml)。您可以在以下代码片段中找到相关配置。为了清晰起见，我们将此调度器放在`JavaConfig.java`文件中：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Important note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Keep in mind that this configuration is not cluster aware. Therefore, if this
    is deployed to a cluster, the cleaner will execute once for every **Java Virtual
    Machine (JVM)** that the application is deployed to.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此配置不是集群感知的。因此，如果将其部署到集群中，清理器将为应用程序部署到的每个**Java虚拟机（JVM）**执行一次。
- en: Start up the application and give the updates a try. The configuration that
    was provided will ensure that the cleaner is executed every ten minutes. You may
    want to change the cleaner task to run more frequently and clean up the more recently
    used remember-me tokens by modifying the `@Scheduled` declaration. You can then
    create a few remember-me tokens and see that they get deleted by querying for
    them in the H2 database console.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试更新。提供的配置将确保清理器每十分钟执行一次。您可能希望将清理任务改为更频繁地运行，并通过修改`@Scheduled`声明来清理最近使用的记住我令牌。然后您可以创建一些记住我令牌，并查看它们在H2数据库控制台中查询时被删除。
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.06-calendar`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter07.06-calendar`的源文件开始。
- en: The remember-me architecture
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我架构
- en: We have gone over the basic architecture of both `TokenBasedRememberMeServices`
    and `PersistentTokenBasedRememberMeServices`, but we have not described the overall
    architecture. Let’s see how all of the remember-me pieces fit together.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the different components involved in the
    process of validating a token-based `remember-me` token:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The remember-me architecture](img/B21757_07_6.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The remember-me architecture
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: As with any of the Spring Security filters, `RememberMeAuthenticationFilter`
    is invoked from within `FilterChainProxy`. The job of `RememberMeAuthenticationFilter`
    is to inspect the request, and if it is of interest, an action is taken. The `RememberMeAuthenticationFilter`
    interface will use the `RememberMeServices` implementation to determine whether
    the user is already logged in. The `RememberMeServices` interface does this by
    inspecting the HTTP request for a remember-me cookie that is then validated using
    either the token-based validation or the persistent-based validation we previously
    discussed. If the token checks out, the user will be logged in.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Remember-me and the user life cycle
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of `RememberMeServices` is invoked at several points in
    the user life cycle (the life cycle of an authenticated user’s session). To assist
    you in your understanding of the remember-me functionality, it can be helpful
    to be aware of the points in time when remember-me services are informed of life
    cycle functions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **What** **should happen?** | **The RememberMeServices** **method
    invoked** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| Successful login | The implementation sets a remember-me cookie (if the `form`
    parameter has been sent) | `loginSuccess` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| Failed login | The implementation should cancel the cookie if it’s present
    | `loginFailed` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| User logout | The implementation should cancel the cookie if it’s present
    | `Logout` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: Table 7.8 – Remember-me life cycle events
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The `logout` method is not present on the `RememberMeServices` interface. Instead,
    each `RememberMeServices` implementation also implements the `LogoutHandler` interface,
    which contains the `logout` method. By implementing the `LogoutHandler` interface,
    each `RememberMeServices` implementation can perform the necessary cleanup when
    the user logs out.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Knowing where and how `RememberMeServices` ties into the user’s life cycle will
    be important when we begin to create custom authentication handlers because we
    need to ensure that any authentication processor treats `RememberMeServices` consistently
    to preserve the usefulness and security of this functionality.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Restricting the remember-me feature to an IP address
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s put our understanding of the remember-me architecture to use. A common
    requirement is that any remember-me token should be tied to the IP address of
    the user who created it. This adds additional security to the remember-me feature.
    To do this, we only need to implement a custom `PersistentTokenRepository` interface.
    The configuration changes that we will make will illustrate how to configure a
    custom `RememberMeServices`. Throughout this section, we will take a look at `IpAwarePersistentTokenRepository`,
    which is included in the chapter’s source code. The `IpAwarePersistenTokenRepository`
    interface ensures that the series identifier is internally combined with the current
    user’s IP address, and the series identifier includes only the identifier externally.
    This means that whenever a token is looked up or saved, the current IP address
    is used to look up or persist the token. In the following code snippets, you can
    see how `IpAwarePersistentTokenRepository` works. If you want to dig in even deeper,
    we encourage you to view the source code included in the chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们对记住我架构的理解付诸实践。一个常见的要求是任何记住我令牌都应该与创建它的用户的IP地址相关联。这为记住我功能增加了额外的安全性。为此，我们只需要实现一个自定义的`PersistentTokenRepository`接口。我们将做出的配置更改将说明如何配置自定义的`RememberMeServices`。在本节中，我们将查看包含在本章源代码中的`IpAwarePersistentTokenRepository`。`IpAwarePersistenTokenRepository`接口确保序列标识符在内部与当前用户的IP地址结合，而序列标识符在外部只包含标识符。这意味着每当查找或保存令牌时，都会使用当前IP地址来查找或持久化令牌。在下面的代码片段中，你可以看到`IpAwarePersistentTokenRepository`是如何工作的。如果你想要更深入地了解，我们鼓励你查看章节中包含的源代码。
- en: 'The trick to looking up the IP address is using `RequestContextHolder` of Spring
    Security. The relevant code is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 查找IP地址的技巧是使用Spring Security的`RequestContextHolder`。相关代码如下：
- en: Important note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It should be noted that to use `RequestContextHolder`, you need to ensure you
    have set up your `web.xml` file to use `RequestContextListener`. We have already
    performed this setup for our sample code. However, this can be useful when utilizing
    the example code in an external application. Refer to the Javadoc of `IpAwarePersistentTokenRepository`
    for details on how to set this up.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，要使用`RequestContextHolder`，你需要确保你已经设置了你的`web.xml`文件以使用`RequestContextListener`。我们已经为我们的示例代码完成了这个设置。然而，当在外部应用程序中利用示例代码时，这可能很有用。有关如何设置此内容的详细信息，请参阅`IpAwarePersistentTokenRepository`的Javadoc。
- en: 'Take a look at the following code snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can build on this method to force tokens that are saved to include the IP
    address in the series identifier, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在此基础上构建方法，强制保存的令牌包含IP地址在序列标识符中，如下所示：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see that we first created a new series with the IP address concatenated
    to it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们首先创建了一个新的序列，其中包含了附加的IP地址。
- en: The `tokenWithSeries` method is just a helper that creates a new token with
    all of the same values, except a new series. We then submit the new token with
    a series identifier, which includes the IP address, to `delegateRepository`, which
    is the original implementation of `PersistentTokenRepository`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenWithSeries`方法只是一个辅助方法，它创建了一个具有所有相同值的新令牌，除了一个新的序列。然后我们将带有序列标识符的新令牌提交给`delegateRepository`，这是`PersistentTokenRepository`的原始实现。'
- en: 'Whenever the tokens are looked up, we require that the current user’s IP address
    is appended to the series identifier. This means that there is no way for a user
    to obtain a token for a user with a different IP address:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每当查找令牌时，我们要求将当前用户的IP地址附加到序列标识符中。这意味着用户无法获取具有不同IP地址的用户的令牌：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The remainder of the code is quite similar. Internally, we construct the series
    identifier to be appended to the IP address, and externally, we present only the
    original series identifier. By doing this, we enforce the constraint that only
    the user who created the remember-me token can use it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分相当相似。内部，我们构建序列标识符以附加到IP地址，外部，我们只展示原始序列标识符。通过这种方式，我们强制执行约束，只有创建记住我令牌的用户才能使用它。
- en: 'Let’s review the Spring configuration included in this chapter’s sample code
    for `IpAwarePersistent` **TokenRepository**. In the following code snippet, we
    first create the `IpAwarePersistent` **TokenRepository** declaration that wraps
    a new `JpaPersistentTokenRepository` declaration. We then initialize a `RequestContextFilter`
    class by instantiating an `OrderedRequestContextFilter` interface:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章示例代码中包含的Spring配置，用于`IpAwarePersistent` **令牌存储库**。在以下代码片段中，我们首先创建了一个`IpAwarePersistent`
    **令牌存储库**声明，该声明包装了一个新的`JpaPersistentTokenRepository`声明。然后我们通过实例化一个`OrderedRequestContextFilter`接口来初始化一个`RequestContextFilter`类：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, go ahead and start up the application. You can use the second computer
    along with a plugin, such as Firebug, to manipulate your remember-me cookie. If
    you try to use the remember-me cookie from one computer on another computer, Spring
    Security will now ignore the remember-me request and delete the associated cookie.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请启动应用程序。您可以使用第二台计算机以及一个插件，如Firebug，来操纵您的“记住我”cookie。如果您尝试在另一台计算机上使用来自一台计算机的“记住我”cookie，Spring
    Security现在将忽略“记住我”请求并删除相关的cookie。
- en: Important note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.07-calendar`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter07.07-calendar`的源代码开始。
- en: Note that the IP-based remember-me tokens may behave unexpectedly if the user
    is behind a shared or load-balanced network infrastructure, such as a multi **Wide-Area
    Network (WAN)** corporate environment. In most scenarios, however, the addition
    of an IP address to the remember-me function provides an additional, welcome layer
    of security to a helpful user feature.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果用户位于共享或负载均衡的网络基础设施之后，如多**广域网（WAN）**企业环境，基于IP的“记住我”令牌可能会出现意外的行为。然而，在大多数情况下，向“记住我”功能添加IP地址为有用的用户功能提供了额外的、受欢迎的安全层。
- en: Custom cookie and HTTP parameter names
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义cookie和HTTP参数名称
- en: 'Curious users may wonder whether the expected value of the remember-me form
    field checkbox to be remember-me, or the cookie name to be remember-me, can be
    changed to obscure the use of Spring Security. This change can be made in one
    of two locations. Take a look at the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的用户可能会想知道，是否可以将“记住我”表单字段复选框的预期值或cookie名称更改为“记住我”，以隐藏Spring Security的使用。这种更改可以在两个位置之一进行。请查看以下步骤：
- en: 'We can simply define more properties to change the checkbox and cookie names
    in `RememberMeServices` `bean`, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`RememberMeServices` `bean`中简单地定义更多属性来更改复选框和cookie的名称，如下所示：
- en: '[PRE21]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Don’t forget to change the `login.xhtml` page to set the name of the `checkbox
    form field` and to match the parameter value we declared. Go ahead and make the
    updates to `login.xhtml`, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记将`login.xhtml`页面更改为设置`checkbox表单字段`的名称，并匹配我们声明的参数值。请继续更新`login.xhtml`，如下所示：
- en: '[PRE22]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’d encourage you to experiment here to ensure you understand how these settings
    are related. Go ahead and start up the application and give it a try.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们鼓励您在这里进行实验，以确保您理解这些设置之间的关系。请继续启动应用程序并尝试一下。
- en: Important note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the source from `chapter07.08-calendar`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter07.08-calendar`的源代码开始。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained and demonstrated the use of the remember-me feature in
    Spring Security. We started with the most basic setup and learned how to gradually
    make the feature more secure. Specifically, we learned about a token-based remember-me
    service and how to configure it. We also explore how persistent-based remember-me
    services can provide additional security, how they work, and the additional considerations
    necessary when using them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释并演示了在Spring Security中使用“记住我”功能。我们从最基本的设置开始，学习了如何逐步使该功能更安全。具体来说，我们学习了基于令牌的“记住我”服务及其配置方法。我们还探讨了基于持久化的“记住我”服务如何提供额外的安全性，它们的工作原理以及在使用它们时必要的额外考虑。
- en: We also covered the creation of a custom remember-me implementation that restricts
    the remember-me token to a specific IP address. We saw various other ways to make
    the remember-me feature more secure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了创建一个自定义的“记住我”实现，该实现将“记住我”令牌限制在特定的IP地址上。我们看到了使“记住我”功能更安全的各种其他方法。
- en: Up next is **certificate-based authentication**, and we will discuss how to
    use trusted client-side certificates to perform authentication.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**基于证书的认证**，我们将讨论如何使用受信任的客户端证书进行认证。
