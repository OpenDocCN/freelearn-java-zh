<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Understanding the Scala Ecosystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Understanding the Scala Ecosystem</h1></div></div></div><p>Learning a new language also means getting acquainted with a new ecosystem of frameworks and tools. The good news is, in Scala, we can largely inherit the very rich and mature set of available tools and libraries from Java. In this chapter, we are going to cover the major novelties and additions to the existing ecosystem that we, as Java developers, are already familiar with.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Code editing environments—also known as IDEs</li><li class="listitem" style="list-style-type: disc">SBT—a tool specific to Scala to build, test, and execute code</li><li class="listitem" style="list-style-type: disc">Utilities as plugins to SBT to integrate with the Java ecosystem</li><li class="listitem" style="list-style-type: disc">Scala Worksheets—a novel approach to interactive programming</li><li class="listitem" style="list-style-type: disc">Working with HTTP and interacting with external web-based services, including the introduction of "for comprehensions"—a useful Scala construct</li><li class="listitem" style="list-style-type: disc">Typesafe Activator—a convenient tool to bootstrap projects quickly</li><li class="listitem" style="list-style-type: disc">Using Scala for scripting</li></ul></div><div class="section" title="Inheriting Java Integrated Development Environments (IDEs)"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Inheriting Java Integrated Development Environments (IDEs)</h1></div></div></div><p>Scala is supported on all the three major Java IDEs: <a id="id139" class="indexterm"/>Eclipse-based (including all the different versions of Eclipse, Typesafe's own bundled version known as Scala IDE as well as more commercial IDEs such as SpringSourceSTS), IntelliJ IDEA, and NetBeans. This means that you can just keep working as you used to with Java, for instance, running Scala JUnit tests inside the IDE, directly debugging or remote debugging. The extended Scala support on all of these platforms will provide you with the very useful autocompletion feature and instant feedback on the various types that are inferred by the compiler. In <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration</em></span>, we used NetBeans mostly because it had a convenient, small, and ready-to-use database and embedded tools to reverse engineer this database into a RESTful API in Java. As the usage of Eclipse targets a larger audience and is also the reference IDE that Typesafe provides support to, we are going to use it for the following chapters as our main development environment.</p><p>From the <a class="ulink" href="http://scala-ide.org">scala-ide.org</a> website, you can download and install the Scala IDE for Eclipse either as the bundled version that supports Scala or the Scala plugin through the use of update sites (as you would do in Java for installing any other Eclipse plugin into an existing environment). All instructions to install either the bundled or the plugin versions are very well explained on this site, so we won't <a id="id140" class="indexterm"/>spend much time here repeating this process. Instructions to install IDEA and NetBeans are available from <a class="ulink" href="http://www.jetbrains.com/">http://www.jetbrains.com/</a> and <a class="ulink" href="http://www.netbeans.org/">http://www.netbeans.org/</a>, respectively.</p></div></div>
<div class="section" title="Building with Simple Build Tool (SBT)"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Building with Simple Build Tool (SBT)</h1></div></div></div><p>A major addition to the Java <a id="id141" class="indexterm"/>ecosystem when dealing with Scala is <span class="strong"><strong>Simple Build Tool</strong></span> (<span class="strong"><strong>SBT</strong></span>), a flexible build system written in Scala that also powers both Typesafe Activator, which we used in the previous chapters, and the Play framework that we will cover later on in this book. In contrast to the existing XML formats used by Ant and Maven in Java environments, SBT build definitions are written in Scala in <a id="id142" class="indexterm"/>the form of a <span class="strong"><strong>Domain Specific Language</strong></span> (<span class="strong"><strong>DSL</strong></span>), having the benefit of compile-time checking. As we will see in this section, SBT provides a number of additional convenient features. In addition to its dependency management ability based on Ivy and supporting Maven-format repositories, SBT offers both incremental compilation and an interactive shell (that is, the REPL we were using earlier). It also supports continuous testing and deployment, and integrates with many Scala test frameworks, making it the de facto build tool for the Scala community.</p><div class="section" title="Getting started with SBT"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Getting started with SBT</h2></div></div></div><p>SBT consists of a single <code class="literal">.jar</code> archive as well as a very small start script. Therefore, it can be installed and run on any platform that supports JVM. Installation instructions are available at <a class="ulink" href="http://www.scala-sbt.org/">http://www.scala-sbt.org/</a>.</p><div class="section" title="Creating a sample project"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Creating a sample project</h3></div></div></div><p>Once SBT is in your path (we used Version 0.13.0 at the time of writing this book), create a directory called <code class="literal">SampleProject</code> anywhere in your filesystem by entering the following commands in a <a id="id143" class="indexterm"/>terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd &lt;your_filesystem_dir&gt; (e.g. /Users/Thomas/projects/)</strong></span>
<span class="strong"><strong>&gt; mkdir SampleProject</strong></span>
<span class="strong"><strong>&gt; cd SampleProject</strong></span>
<span class="strong"><strong>&gt; sbt</strong></span>
<span class="strong"><strong>[info] Set current project to sampleproject</strong></span>
<span class="strong"><strong>&gt; set name := "SampleProject"</strong></span>
<span class="strong"><strong>[info] Defining *:name</strong></span>
<span class="strong"><strong>[info] ...</strong></span>
<span class="strong"><strong>&gt; session save</strong></span>
</pre></div><p>To end the SBT session, enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; exit (or press CTRL-D)</strong></span>
</pre></div><p>This will create a <code class="literal">build.sbt</code> file under the project root. This file gathers information about the project, that is, the equivalent of the Maven's <code class="literal">.pom</code> file in the Java world except that <code class="literal">build.sbt</code> compiles to Scala rather than being XML. The whole file structure of the project is illustrated in a diagram later <a id="id144" class="indexterm"/>on, once we have added some library dependencies.</p><p>Open and edit <code class="literal">build.sbt</code> to fill out the basic information as follows:</p><div class="informalexample"><pre class="programlisting">name := "SampleProject"

version := "1.0"

scalaVersion := "2.10.3"</pre></div><p>Note that the extra line between each statement is important. The <code class="literal">.sbt</code> files are not Scala programs; they are a list of Scala expressions, where a blank line is the delimiter between these expressions.</p><p>We are now going to import our empty project into our IDE before we start writing some code.</p></div><div class="section" title="Importing the project in Eclipse, IntelliJ IDEA, and NetBeans"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec11"/>Importing the project in Eclipse, IntelliJ IDEA, and NetBeans</h3></div></div></div><p>The <code class="literal">sbteclipse</code> plugin is <a id="id145" class="indexterm"/>available to adapt a pure SBT project to an Eclipse <a id="id146" class="indexterm"/>project. You just need to create a <code class="literal">plugins.sbt</code> file under the <code class="literal">project/</code> directory and type the following line into it to import the <code class="literal">sbteclipse</code> plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "2.4.0")</strong></span>
</pre></div><p>The preceding given string is a way in SBT to express a dependency to a Maven library; it is the equivalent to what you would normally write into a <code class="literal">pom</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;groupId&gt;com.typesafe.sbteclipse&lt;/groupId&gt;
&lt;artifactId&gt;sbteclipse-plugin&lt;/artifactId&gt;
&lt;version&gt;2.4.0&lt;/version&gt;</pre></div><p>You see, downloading libraries and their dependencies in SBT is pretty much the same as working with Maven; they will be fetched from Maven repositories (Maven central and some other common repositories are already referenced by default in SBT; this is why you do not have to write them explicitly).</p><p>Note that eventually you should use a different version number as this plugin evolves from time to time. The current version is available together with the plugin documentation at <a class="ulink" href="https://github.com/typesafehub/sbteclipse">https://github.com/typesafehub/sbteclipse</a>.</p><p>Once <code class="literal">SampleProject/project/plugins.sbt</code> is present in your project, you can simply execute the following command to generate an Eclipse compliant project (still from the root of the project):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; sbt eclipse</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>[info] Successfully created Eclipse project files for project(s):</strong></span>
<span class="strong"><strong>[info] SampleProject</strong></span>
</pre></div><p>Now just start your Eclipse IDE if you haven't already done so, then select <span class="strong"><strong>File</strong></span> |<span class="strong"><strong>Import...</strong></span>. Navigate to <span class="strong"><strong>General</strong></span> | <span class="strong"><strong>Existing Projects into Workspace</strong></span>. Browse to the root directory of your project as you would do in Java and click on <span class="strong"><strong>OK</strong></span>. Then, click on <span class="strong"><strong>Finish</strong></span> to complete the import of the project, which will appear in the <span class="strong"><strong>Project Explorer</strong></span> window.</p><p>
<span class="strong"><strong>IntelliJ</strong></span> also has its plugin, <a id="id147" class="indexterm"/>which <a id="id148" class="indexterm"/>is available at <a class="ulink" href="https://github.com/mpeltonen/sbt-idea">https://github.com/mpeltonen/sbt-idea</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Note that for the various IDEs, there are two plugin concepts: <span class="strong"><strong>SBT plugins</strong></span> for particular IDEs and <span class="strong"><strong>IDE plugins</strong></span> for SBT.</p><p>The sbteclipse, <a id="id149" class="indexterm"/>sbt-idea, and nbsbt (<a class="ulink" href="https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans">https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans</a>) plugins are all <a id="id150" class="indexterm"/>SBT plugins that require modifications to your <code class="literal">plugins.sbt</code> file. When you run the appropriate SBT command, they generate project files to be used by Eclipse, IntelliJ, or NetBeans. When you update your SBT files, you may need to rerun the plugin in order to update your IDE configuration.</p><p>However, if an IntelliJ user browses the available IntelliJ plugins, then they will see a different Scala plugin there (<a class="ulink" href="http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA">http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA</a>). This is an add-on for IntelliJ, rather than an add-on for SBT. It helps IntelliJ to configure itself around an SBT project automatically, without the need for any modification to your SBT files or extra commands. This approach is arguably more popular in the IntelliJ community.</p><p>If you use Maven and Eclipse in the Java world, then this is pretty much the same story as the m2eclipse Eclipse plugin versus the eclipse: eclipse Maven plugin.</p></div></div><p>Similar to Eclipse, you should edit a <code class="literal">plugins.sbt</code> file under <code class="literal">project/</code> and place the dependency to the <code class="literal">sbt-idea</code> plugin as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>addSbtPlugin("com.github.mpeltonen" % "sbt-idea" % "1.5.2")</strong></span>
</pre></div><p>The command to create an IntelliJ-compliant project is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; sbt gen-idea</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>It is worth noting that as of IntelliJ IDEA 13, the IDEA Scala plugin natively supports SBT and doesn't require the external plugin to work. Refer to the IntelliJ documentation on how to import an SBT project into the IDE.</p></div></div><p>Sometimes newer versions of the plugin that are not present (yet) in the default Maven repositories exist. In this case, you have to add such a repository for SBT to be able to upload the plugin/library. You can do this by having an extra line as follows:</p><div class="informalexample"><pre class="programlisting">resolvers += "Sonatype snapshots" at "http://oss.sonatype.org/content/repositories/snapshots/"

addSbtPlugin("com.github.mpeltonen" % "sbt-idea" % "1.6.0-SNAPSHOT")</pre></div><p>Since Scala Version 2.10+, NetBeans also has its plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>addSbtPlugin("org.netbeans.nbsbt" % "nbsbt-plugin" % "1.0.2")</strong></span>
</pre></div><p>The plugin itself can be downloaded and built from a GitHub repository as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; git clone git@github.com:dcaoyuan/nbsbt.git</strong></span>
<span class="strong"><strong>&gt; cd nbsbt</strong></span>
<span class="strong"><strong>&gt; sbt clean compile publish-local</strong></span>
</pre></div><p>The <code class="literal">publish-local</code> command <a id="id151" class="indexterm"/>will deploy it locally on your filesystem. Then, creating the files for your project is done using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; sbt netbeans</strong></span>
</pre></div><p>We are going to continue the chapter adopting Eclipse as our IDE, but most of the tools should also work under the other IDEs. Moreover, if you need additional integration with other editors such as ENSIME and Sublime Text, browse the documentation at <a class="ulink" href="http://www.scala-sbt.org">http://www.scala-sbt.org</a>.</p><p>Once the project is imported into <a id="id152" class="indexterm"/>Eclipse, you will notice that the file structure is the same as for Maven projects; source files have the default directories <code class="literal">src/main/scala</code> and <code class="literal">src/test/scala</code>, and this is the same structure for Java too.</p></div><div class="section" title="Creating a web application that runs on a servlet container"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec12"/>Creating a web application that runs on a servlet container</h3></div></div></div><p>Among the growing list of <a id="id153" class="indexterm"/>available SBT plugins is the xsbt-web-plugin (available at <a class="ulink" href="https://github.com/JamesEarlDouglas/xsbt-web-plugin">https://github.com/JamesEarlDouglas/xsbt-web-plugin</a>), a useful plugin to create traditional web apps that runs on a servlet container (such as Jetty). As for the plugins we've <a id="id154" class="indexterm"/>previously seen, installation consists of adding single line to the <code class="literal">plugins.sbt</code> file as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>addSbtPlugin("com.earldouglas" % "xsbt-web-plugin" % "0.4.2")</strong></span>
</pre></div><p>Then, add the following line to the <code class="literal">build.sbt</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>seq(webSettings :_*)</strong></span>
</pre></div><p>We also need to include Jetty in the container classpath as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>libraryDependencies += "org.mortbay.jetty" % "jetty" % "6.1.22" % "container"</strong></span>
</pre></div><p>The whole minimal <code class="literal">build.sbt</code> file is given as a summary, as follows:</p><div class="informalexample"><pre class="programlisting">name := "SampleProject"

organization := "com.samples"

version := "1.0"

scalaVersion := "2.10.3"

seq(webSettings :_*)

libraryDependencies += "org.mortbay.jetty" % "jetty" % "6.1.22" % "container"

libraryDependencies += "javax.servlet" % "servlet-api" % "2.5" % "provided"</pre></div><p>As we have updated our build file with new dependencies, we need to rerun <code class="literal">sbteclipse</code> to update the Eclipse files for our project. This operation can be achieved by re-entering from the SBT command prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; eclipse</strong></span>
</pre></div><p>Let's now write a tiny servlet in Scala in the IDE to exhibit our small sample logic, which mimics the Java syntax. Right-click on the <a id="id155" class="indexterm"/>root of the project in the <span class="strong"><strong>Package Explorer</strong></span> window, and select <span class="strong"><strong>Refresh</strong></span> to make <a id="id156" class="indexterm"/>sure the new dependencies are picked up. The whole structure of the project is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_03_05.jpg" alt="Creating a web application that runs on a servlet container"/></div><p>We can now start editing a new Scala file under <code class="literal">src/main/scala</code> (in a new <code class="literal">com.samples</code> package) as follows:</p><div class="informalexample"><pre class="programlisting">package com.samples
import scala.xml.NodeSeq
import javax.servlet.http._

class SimpleServlet extends HttpServlet {
  override def doGet(request: HttpServletRequest, response: HttpServletResponse) {

    response.setContentType("text/html")
    response.setCharacterEncoding("UTF-8")

    val responseBody: NodeSeq =
      &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;

    response.getWriter.write(responseBody.toString)
  }
}</pre></div><p>Finally, we need to add a <code class="literal">web.xml</code> file as <a id="id157" class="indexterm"/>we would normally do in Java to configure the servlet deployment (to be put under the <code class="literal">src/main/webapp/WEB-INF</code> directory) as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app


xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
version="2.5"&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;simpleservlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.samples.SimpleServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;simpleservlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><p>From the root of the project, in our command prompt, we are now ready to deploy and execute our little example in the Jetty container by invoking <code class="literal">sbt</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; sbt</strong></span>
<span class="strong"><strong>&gt; container:start</strong></span>
<span class="strong"><strong>2014-03-15 14:33:18.880:INFO::Logging to STDERR via org.mortbay.log.StdErrLog</strong></span>
<span class="strong"><strong>[info] jetty-6.1.22</strong></span>
<span class="strong"><strong>[info] NO JSP Support for /, did not find org.apache.jasper.servlet.JspServlet</strong></span>
<span class="strong"><strong>[info] Started SelectChannelConnector@0.0.0.0:8080</strong></span>
<span class="strong"><strong>[success] Total time: 20 s, completed Mar 15, 2014 2:33:19 PM</strong></span>
<span class="strong"><strong>&gt;</strong></span>
</pre></div><p>By default, the container will listen on localhost at port 8080.</p><p>You can now open <code class="literal">http://localhost:8080/</code> on a web browser and verify whether we get the Hello, world! message as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_03_06.jpg" alt="Creating a web application that runs on a servlet container"/></div><p>You may also run the <code class="literal">package</code> command <a id="id158" class="indexterm"/>from SBT that will assemble a <code class="literal">.war</code> archive <a id="id159" class="indexterm"/>and put it under <code class="literal">target/scala-2.10/sampleproject_2.10-1.0.war</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; package</strong></span>
</pre></div></div></div><div class="section" title="Using sbt-assembly to build a single .jar archive"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Using sbt-assembly to build a single .jar archive</h2></div></div></div><p>The sbt-assembly <a id="id160" class="indexterm"/>plugin can gather all your project code and its <a id="id161" class="indexterm"/>dependencies into a single <code class="literal">.jar</code> file that can be published into a repository or <a id="id162" class="indexterm"/>deployed on other environments.</p><p>Installing the plugin consists of adding sbt-assembly as a dependency in <code class="literal">project/assembly.sbt</code> (from SBT 0.13), as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.11.2")</strong></span>
</pre></div><p>To be able to run the assembly command within SBT, you just need to create an <code class="literal">assembly.sbt</code> file in the project root directory as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">import AssemblyKeys._ // put this at the top of the file

assemblySettings
// your assembly settings here</pre></div><p>Assembly settings are documented at <a class="ulink" href="https://github.com/sbt/sbt-assembly">https://github.com/sbt/sbt-assembly</a>. They enable you to modify, for example, the <a id="id163" class="indexterm"/>
<code class="literal">jarName</code> or the <code class="literal">outputPath</code>, variables as well as skipping tests during the assembly <a id="id164" class="indexterm"/>phase or setting a main class explicitly if you wish to create a runnable <code class="literal">.jar</code> file.</p></div><div class="section" title="Formatting code with Scalariform"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Formatting code with Scalariform</h2></div></div></div><p>Automatic code <a id="id165" class="indexterm"/>formatting is a useful feature not only for its ability to apply the same formatting rules to code written by various individuals but also to <a id="id166" class="indexterm"/>make the differences appear more consistently in a source management tool.</p><p>The Scala IDE for Eclipse uses Scalariform as its code formatter, which is also available as an sbt-plugin that can be added to the <code class="literal">plugins.sbt</code> file as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>addSbtPlugin("com.typesafe.sbt" % "sbt-scalariform" % "1.2.0")</strong></span>
</pre></div><p>Once you have it in place, Scalariform will format your source code automatically whenever you run <code class="literal">compile</code> or <code class="literal">test:compile</code> in SBT.</p><p>In Eclipse, formatting code is performed the same way as with Java, that is, right-clicking in the editor and then navigating to <span class="strong"><strong>Source</strong></span> | <span class="strong"><strong>Format</strong></span> (or <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F</em></span>).</p></div></div>
<div class="section" title="Experimenting with Scala Worksheets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Experimenting with Scala Worksheets</h1></div></div></div><p>In the previous chapters, we had run the <a id="id167" class="indexterm"/>REPL as an interactive environment to experiment and get immediate feedback when entering the Scala syntax. This allowed us to very quickly write some small algorithms and get the right syntax to make things work. Although the SBT console provides programmers with a <code class="literal">:replay</code> command to rerun what has already been written in the session, wouldn't it be nice to be able to save our experiments for later use, as part of our project ? This is exactly what <span class="strong"><strong>Scala Worksheets</strong></span> are all about.</p><p>Scala Worksheet is an innovative feature of the Scala support for Eclipse that brings an interactive environment, that is, a REPL in the context of a project. This feature is also now available on the Scala support for IntelliJ.</p><p>Let's go to our small servlet sample in Eclipse to try it out.</p><p>To start a worksheet, right-click on any package or source file and navigate to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Scala Worksheet</strong></span> (or if not present in the drop-down list, navigate to <span class="strong"><strong>Other...</strong></span> | <span class="strong"><strong>Scala Wizards</strong></span> | <span class="strong"><strong>Scala Worksheet</strong></span>), as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_03_07.jpg" alt="Experimenting with Scala Worksheets"/></div><p>We will choose, for example, the current <code class="literal">com.samples</code> package. Click on <span class="strong"><strong>Next</strong></span> and enter a name for your worksheet: <code class="literal">experiment</code>.</p><p>This will create a file named <code class="literal">experiment.sc</code> that is saved within the source code but as it is not a <code class="literal">.scala</code> file, it will not be in conflict with the rest of our current code base nor be present in the deployed <code class="literal">.jar</code> archive.</p><p>The default page looks like the <a id="id168" class="indexterm"/>following code snippet:</p><div class="informalexample"><pre class="programlisting">packagecom.samples

object experiment {
  println("Welcome to the Scala worksheet")       &gt; Welcome to the Scala worksheet
}</pre></div><p>Everything after the <code class="literal">&gt;</code> sign on each statement is the result of the evaluation that gets (re)evaluated as soon as you save the Worksheet file. You may try out a few statements, for instance, by replacing the <code class="literal">println</code> statement with a few lines, as follows:</p><div class="informalexample"><pre class="programlisting">object experiment {

  val number = 1 + 2

  List(1,2,3,3,3,4) filter (x =&gt; x &lt; 4) distinct

  case class Customer(name:String)

  Customer("Helen")

  new SimpleServlet() 
}</pre></div><p>As soon as you save it (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>S</em></span>), the style <a id="id169" class="indexterm"/>sheet will display statement evaluations on the right-hand side as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_03_08.jpg" alt="Experimenting with Scala Worksheets"/></div></div>
<div class="section" title="Working with HTTP"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Working with HTTP</h1></div></div></div><p>As Scala can import and invoke <a id="id170" class="indexterm"/>Java classes as well as extend them, many of the Scala libraries available as part of the Scala ecosystem are only a thin layer on top of robust and mature Java libraries, to either provide additional features or simplify their usage by adding some syntactic sugar.</p><p>One such example is the Scala <a id="id171" class="indexterm"/>dispatch library (available at <a class="ulink" href="http://dispatch.databinder.net/Dispatch.html">http://dispatch.databinder.net/Dispatch.html</a>), a useful library to achieve HTTP interaction based on Apache's robust HttpClient. Let's run a little dispatch session in the REPL.</p><p>As dispatch is an external library; we first need to import it into our SBT project to be able to use it from the REPL console. Add the dispatch dependency to the <code class="literal">build.sbt</code> file of the <code class="literal">SampleProject</code> so that it looks like the following code snippet (make sure to have a blank line between statements in <code class="literal">build.sbt</code>):</p><div class="informalexample"><pre class="programlisting">name := "SampleProject"
…

libraryDependencies += "net.databinder.dispatch" %% "dispatch-core" % "0.11.0"</pre></div><p>Restart the REPL to make the libraries available, and import them into the session as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import dispatch._, Defaults._</strong></span>
<span class="strong"><strong>import dispatch._</strong></span>
<span class="strong"><strong>import Defaults._</strong></span>
</pre></div><p>Let's make a basic request to an online geolocation service, where the REST API is a simple <code class="literal">GET</code> request to the <code class="literal">freegeoip.net/{format}/{ip_or_hostname}</code> URL as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val request = url("http://freegeoip.net/xml/www.google.com")</strong></span>
<span class="strong"><strong>request: dispatch.Req = Req(&lt;function1&gt;)</strong></span>
</pre></div><p>Now, we will send the <code class="literal">GET</code> request through HTTP and take the response as a string (wrapping XML as this is what we ask as response format from the service):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val result = Http( request OK as.String)</strong></span>
<span class="strong"><strong>result: dispatch.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@22aeb07c</strong></span>
</pre></div><p>Notice the result type of <code class="literal">dispatch.Future[String]</code> returned by the interpreter. The previous versions of dispatch were synchronous (and still available under the library name, <code class="literal">dispatch-classic</code>) but the latest <a id="id172" class="indexterm"/>versions such as the one we are using cope with modern development practices, namely asynchrony. We will study the asynchronous Scala code later in <a class="link" href="ch08.html" title="Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency">Chapter 8</a>, <span class="emphasis"><em>Essential Properties of Modern Applications – Asynchrony and Concurrency</em></span>, but similar to Java, <code class="literal">Future</code> acts as a placeholder for a computation that does not block. This means that we can continue the flow of the program without waiting for the variable to be populated, which is convenient when invoking potentially long-running method calls (such as a REST service). Note, however, that here <code class="literal">dispatch.Future</code> is a different implementation than <code class="literal">java.util.concurrent.Future</code>, which is found in the standard Java library.</p><p>To read and display the result of our HTTP request, we can just type the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val resultAsString = result()</strong></span>
<span class="strong"><strong>resultAsString: String = </strong></span>
<span class="strong"><strong>"&lt;?xml version="1.0" encoding="UTF-8"?&gt;</strong></span>
<span class="strong"><strong> &lt;Response&gt;</strong></span>
<span class="strong"><strong> &lt;Ip&gt;74.125.225.114&lt;/Ip&gt;</strong></span>
<span class="strong"><strong> &lt;CountryCode&gt;US&lt;/CountryCode&gt;</strong></span>
<span class="strong"><strong> &lt;CountryName&gt;United States&lt;/CountryName&gt;</strong></span>
<span class="strong"><strong> &lt;RegionCode&gt;CA&lt;/RegionCode&gt;</strong></span>
<span class="strong"><strong> &lt;RegionName&gt;California&lt;/RegionName&gt;</strong></span>
<span class="strong"><strong> &lt;City&gt;Mountain View&lt;/City&gt;</strong></span>
<span class="strong"><strong> &lt;ZipCode&gt;94043&lt;/ZipCode&gt;</strong></span>
<span class="strong"><strong> &lt;Latitude&gt;37.4192&lt;/Latitude&gt;</strong></span>
<span class="strong"><strong> &lt;Longitude&gt;-122.0574&lt;/Longitude&gt;</strong></span>
<span class="strong"><strong> &lt;MetroCode&gt;807&lt;/MetroCode&gt;</strong></span>
<span class="strong"><strong> &lt;AreaCode&gt;650&lt;/AreaCode&gt;</strong></span>
<span class="strong"><strong>&lt;/Response&gt;</strong></span>
<span class="strong"><strong>"</strong></span>
</pre></div><p>Calling <code class="literal">result()</code> here is the syntactic sugar for actually calling the <code class="literal">result.apply()</code> method, a convenient way to make code look elegant in many situations.</p><p>Dispatch provides a lot of ways to handle both the request, such as adding headers and parameters, and the processing of the response such as handling the response as XML or JSON, splitting into two different handlers or dealing with streams. To exhibit these behaviors, we are going to call <a id="id173" class="indexterm"/>another online service as an example, the <span class="strong"><strong>Groupon</strong></span> service. Groupon is a service that offers discount coupons when you buy a product or service such as holidays, beauty products, and so on in a variety of categories. The Groupon API can be queried to gather offerings within a geographic location determined by either city or coordinates (latitude and longitude).</p><p>To be able to experiment with the API, <a id="id174" class="indexterm"/>upon registration to the <a class="ulink" href="http://www.groupon.com/pages/api">http://www.groupon.com/pages/api</a> URL, you should obtain a unique <code class="literal">client_id</code> key that authenticates you and that you have to pass along whenever you call the API. Let's illustrate this in the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val grouponCitiesURL = url("http://api.groupon.com/v2/divisions.xml?client_id=&lt;your own client_key&gt;")</strong></span>
<span class="strong"><strong>grouponCitiesURL: dispatch.Req = Req(&lt;function1&gt;)</strong></span>
<span class="strong"><strong>scala&gt; val citiesAsText = Http(grouponCitiesURL OK as.String)</strong></span>
<span class="strong"><strong>citiesAsText: dispatch.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@4ad28057</strong></span>
<span class="strong"><strong>scala&gt; citiesAsText()</strong></span>
<span class="strong"><strong>res0: String = &lt;response&gt;&lt;divisions&gt;&lt;division&gt;&lt;id&gt;abbotsford&lt;/id&gt;&lt;name&gt;Abbotsford&lt;/name&gt;&lt;country&gt;Canada&lt;/country&gt;&lt;timezone&gt;Pacific Time (US &amp;amp; Canada)&lt;/timezone&gt;...</strong></span>
</pre></div><p>The REPL limits the amount of output for better readability. Instead of getting the response as a string, let's handle it as XML:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val citiesAsXML = Http(grouponCitiesURL OK as.xml.Elem)</strong></span>
<span class="strong"><strong>citiesAsXML: dispatch.Future[scala.xml.Elem] = scala.concurrent.impl.Promise$DefaultPromise@27ac41a3</strong></span>
<span class="strong"><strong>scala&gt; citiesAsXML()</strong></span>
<span class="strong"><strong>res1: scala.xml.Elem = &lt;response&gt;&lt;divisions&gt;&lt;division&gt;&lt;id&gt;abbotsford&lt;/id&gt;&lt;name&gt;Abbotsford&lt;/name&gt;&lt;country&gt;Canada&lt;/country&gt;&lt;timezone&gt;Pacific Time (US &amp;amp; Canada)&lt;/timezone&gt;...</strong></span>
</pre></div><p>This time our result is more structured as it is represented as an XML tree. We can print it in a better format by applying a <code class="literal">PrettyPrinter</code> object that will make the output fit within a width of 90 characters with an indentation of 2:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def printer = new scala.xml.PrettyPrinter(90, 2)</strong></span>
<span class="strong"><strong>printer: scala.xml.PrettyPrinter</strong></span>
<span class="strong"><strong>scala&gt; for (xml &lt;- citiesAsXML)</strong></span>
<span class="strong"><strong>         println(printer.format(xml))</strong></span>
<span class="strong"><strong>scala&gt; &lt;response&gt;</strong></span>
<span class="strong"><strong>  &lt;divisions&gt;</strong></span>
<span class="strong"><strong>    &lt;division&gt;</strong></span>
<span class="strong"><strong>      &lt;id&gt;abbotsford&lt;/id&gt;</strong></span>
<span class="strong"><strong>      &lt;name&gt;Abbotsford&lt;/name&gt;</strong></span>
<span class="strong"><strong>      &lt;country&gt;Canada&lt;/country&gt;</strong></span>
<span class="strong"><strong>      &lt;timezone&gt;Pacific Time (US &amp;amp; Canada)&lt;/timezone&gt;</strong></span>
<span class="strong"><strong>      &lt;timezoneOffsetInSeconds&gt;-25200&lt;/timezoneOffsetInSeconds&gt;</strong></span>
<span class="strong"><strong>      &lt;timezoneIdentifier&gt;America/Los_Angeles&lt;/timezoneIdentifier&gt;</strong></span>
<span class="strong"><strong>      &lt;lat&gt;49.0568&lt;/lat&gt;</strong></span>
<span class="strong"><strong>      &lt;lng&gt;-122.285&lt;/lng&gt;</strong></span>
<span class="strong"><strong>      ...</strong></span>
<span class="strong"><strong>    &lt;/division&gt;</strong></span>
<span class="strong"><strong>    &lt;division&gt;</strong></span>
<span class="strong"><strong>      &lt;id&gt;abilene&lt;/id&gt;</strong></span>
<span class="strong"><strong>      &lt;name&gt;Abilene, TX&lt;/name&gt;</strong></span>
<span class="strong"><strong>      &lt;country&gt;USA&lt;/country&gt;</strong></span>
<span class="strong"><strong>      &lt;timezone&gt;Central Time (US &amp;amp; Canada)&lt;/timezone&gt;...</strong></span>
</pre></div><p>Extracting partial information from our XML structure can be achieved by applying the <code class="literal">map</code> transformations including XPath <a id="id175" class="indexterm"/>expressions. XPath expressions are useful to navigate through XML elements to retain only the relevant parts. We can progressively extract pieces of XML and return them as collections such as <code class="literal">Lists</code> or <code class="literal">Seqs</code> (sequences), as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val cityDivisions = citiesAsXML() map ( city =&gt; city \\ "division")</strong></span>
<span class="strong"><strong>cityDivisions: scala.collection.immutable.Seq[scala.xml.NodeSeq] = List(NodeSeq(&lt;division&gt;&lt;id&gt;abbotsford&lt;/id&gt;&lt;name&gt;Abbotsford&lt;/name&gt;&lt;country&gt;Canada&lt;/country&gt;...</strong></span>
<span class="strong"><strong>scala&gt; val cityNames = </strong></span>
<span class="strong"><strong>         cityDivisions map ( div =&gt; (div \ "name").text)</strong></span>
<span class="strong"><strong>cityNames: scala.collection.immutable.Seq[String] = List(AbbotsfordAbilene, TXAkron / CantonAlbany / Capital RegionAlbuquerqueAllentown...</strong></span>
</pre></div><p>Here, we got back a sequence of city <a id="id176" class="indexterm"/>names for which there are coupons available.</p><div class="section" title="Scala's for comprehension"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Scala's for comprehension</h2></div></div></div><p>Instead of applying successive <code class="literal">map</code> <a id="id177" class="indexterm"/>transformations to extract XML, in Scala, we can use a powerful construct that represents the silver bullet of iterations called <code class="literal">for comprehension</code> or <code class="literal">for expression</code>. Unlike the <code class="literal">for</code> loops found in Java and used for iterating, <code class="literal">for comprehension</code> returns a result. They are specified as follows:</p><div class="informalexample"><pre class="programlisting">for (sequence) yield expression</pre></div><p>In the preceding code, <code class="literal">sequence</code> can contain the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Generators</strong></span>: They drive the iteration and are written in the following form:<div class="informalexample"><pre class="programlisting">element &lt;- collection</pre></div><p>As for Java loops, <code class="literal">element</code> represents a local variable bound to the current element of the iteration whereas <code class="literal">collection</code> represents the data to be iterated. Moreover, the first generator (there needs to be at least one) determines the type of the result. For example, if the input collection is a <code class="literal">List</code> or a <code class="literal">Vector</code>, the <code class="literal">for comprehension</code> will yield a <code class="literal">List</code> or a <code class="literal">Vector</code>, respectively.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Filters</strong></span>: They control the iteration and are written in the following form:<div class="informalexample"><pre class="programlisting">if expression</pre></div><p>The preceding expression must evaluate to a Boolean value. Filters can be defined either on the same line as generators or separately.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Definitions</strong></span>: They are local variable definitions and are written in the following form:<div class="informalexample"><pre class="programlisting">variable = expression</pre></div><p>They are intermediate values that can contribute to compute the result.</p></li></ul></div><p>A <code class="literal">for comprehension </code>construct is <a id="id178" class="indexterm"/>much easier to visualize with a few concrete examples:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; for {</strong></span>
<span class="strong"><strong>         elem &lt;- List(1,2,3,4,5)</strong></span>
<span class="strong"><strong>       } yield "T" + elem</strong></span>
<span class="strong"><strong>res3: List[String] = List(T1, T2, T3, T4, T5)</strong></span>
</pre></div><p>We have transformed <code class="literal">List[Int]</code> into <code class="literal">List[String]</code> using only one generator. Using two generators is illustrated in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; for {</strong></span>
<span class="strong"><strong>         word &lt;- List("Hello","Scala")</strong></span>
<span class="strong"><strong>         char &lt;- word</strong></span>
<span class="strong"><strong>       } yield char.isLower</strong></span>
<span class="strong"><strong>res4: List[Boolean] = List(false, true, true, true, true, false, true, true, true, true)</strong></span>
</pre></div><p>We can add a filter on any generator. For instance, if we want to retain only the uppercase characters of every word, we can write as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; for {</strong></span>
<span class="strong"><strong>         word &lt;- List("Hello","Scala")</strong></span>
<span class="strong"><strong>         char &lt;- word if char.isUpper</strong></span>
<span class="strong"><strong>       } yield char</strong></span>
<span class="strong"><strong>res5: List[Char] = List(H, S)</strong></span>
</pre></div><p>In the following example, we illustrate how to add a local variable definition:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; for {</strong></span>
<span class="strong"><strong>         word &lt;- List("Hello","Scala")</strong></span>
<span class="strong"><strong>         char &lt;- word</strong></span>
<span class="strong"><strong>         lowerChar = char.toLower</strong></span>
<span class="strong"><strong>       } yield lowerChar</strong></span>
<span class="strong"><strong>res6: List[Char] = List(h, e, l, l, o, s, c, a, l, a)</strong></span>
</pre></div><p>Going back to our HTTP Groupon service, <a id="id179" class="indexterm"/>we can now extract names of cities using <code class="literal">for comprehension</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def extractCityNames(xml: scala.xml.Elem) = </strong></span>
<span class="strong"><strong>         for {</strong></span>
<span class="strong"><strong>           elem &lt;- xml \\ "division"</strong></span>
<span class="strong"><strong>           name &lt;- elem \ "name"</strong></span>
<span class="strong"><strong>         } yield name.text</strong></span>
<span class="strong"><strong>extractCityNames: (xml: scala.xml.Elem)scala.collection.immutable.Seq[String]</strong></span>
<span class="strong"><strong>scala&gt; val cityNames = extractCityNames(citiesAsXML())</strong></span>
<span class="strong"><strong>cityNames: scala.collection.immutable.Seq[String] = List(Abbotsford, Abilene, TX, Akron / Canton, Albany / Capital Region, Albuquerque, Allentown / Reading, Amarillo, Anchorage...</strong></span>
</pre></div><p>To be able to query the second part of the API to retrieve special discount deals for a specific area, we also need the latitude and longitude information from the queried cities. Let's do that by returning a tuple including <a id="id180" class="indexterm"/>three elements, the first one being the name, the <a id="id181" class="indexterm"/>second being the latitude, and the third being the longitude:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def extractCityLocations(xml: scala.xml.Elem) = </strong></span>
<span class="strong"><strong>         for {</strong></span>
<span class="strong"><strong>           elem&lt;- xml \\ "division"</strong></span>
<span class="strong"><strong>           name &lt;- elem \ "name"</strong></span>
<span class="strong"><strong>           latitude &lt;- elem \ "lat"</strong></span>
<span class="strong"><strong>           longitude &lt;- elem \ "lng"</strong></span>
<span class="strong"><strong>         } yield (name.text,latitude.text,longitude.text)</strong></span>
<span class="strong"><strong>extractCityLocations: (xml: scala.xml.Elem)scala.collection.immutable.Seq[(String, String, String)]</strong></span>
<span class="strong"><strong>scala&gt; val cityLocations = extractCityLocations(citiesAsXML())</strong></span>
<span class="strong"><strong>cityLocations: scala.collection.immutable.Seq[(String, String, String)] = List((Abbotsford,49.0568,-122.285), (Abilene, TX,32.4487,-99.7331), (Akron / Canton,41.0814,-81.519), (Albany / Capital Region,42.6526,-73.7562)...</strong></span>
</pre></div><p>Out of the list of returned cities, we might be interested in just one for now. Let's retrieve only the location for Honolulu using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val (honolulu,lat,lng) = cityLocations find (_._1 == "Honolulu") getOrElse("Honolulu","21","-157")</strong></span>
<span class="strong"><strong>honolulu: String = Honolulu</strong></span>
<span class="strong"><strong>lat: String = 21.3069</strong></span>
<span class="strong"><strong>lng: String = -157.858</strong></span>
</pre></div><p>The <code class="literal">find</code> method in the preceding code takes a predicate as a parameter. As its return type is an <code class="literal">Option </code>value, we can retrieve its content by invoking <code class="literal">getOrElse</code> where we can write a default value in case the <code class="literal">find</code> method does not return any match.</p><p>An alternative representation could be done using pattern matching, briefly described in <a class="link" href="ch01.html" title="Chapter 1. Programming Interactively within Your Project">Chapter 1</a>, <span class="emphasis"><em>Programming Interactively within Your Project</em></span>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val honolulu =</strong></span>
<span class="strong"><strong>         cityLocations find { case( city, _, _ ) =&gt; </strong></span>
<span class="strong"><strong>           city == "Honolulu"</strong></span>
<span class="strong"><strong>         }</strong></span>
<span class="strong"><strong>honolulu: Option[(String, String, String)] = Some((Honolulu,21.3069,-157.858))</strong></span>
</pre></div><p>The regular syntax of pattern matching normally uses the <code class="literal">match</code> keyword before all the <code class="literal">case</code> alternatives, so here it is a simplified notation where the <code class="literal">match</code> keyword is implicit. The underscore (<code class="literal">_</code>) as well as the <code class="literal">city</code> variable given in <code class="literal">case</code> are wildcards in the pattern matching. We could have given these underscores variable names but it is not necessary as we are not using them in the predicate (that is, <code class="literal">city == "Honolulu"</code>).</p><p>Let's now create a request to query for all the deals that match a particular geographic area:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val dealsByGeoArea =   url("http://api.groupon.com/v2/deals.xml?client_id=&lt;your client_id&gt;")</strong></span>
<span class="strong"><strong>dealsByGeoArea: dispatch.Req = Req(&lt;function1&gt;)</strong></span>
</pre></div><p>An alternative to handle data as tuples is to <a id="id182" class="indexterm"/>define case classes to encapsulate elements in a convenient and reusable way. We can, therefore, define a <code class="literal">Deal</code> class and rewrite our previous <code class="literal">for comprehension</code> statement returning the <code class="literal">Deal</code> instances instead of tuples:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; case class Deal(title:String = "",dealUrl:String = "", tag:String = "")</strong></span>
<span class="strong"><strong>defined class Deal</strong></span>

<span class="strong"><strong>scala&gt; def extractDeals(xml: scala.xml.Elem) = </strong></span>
<span class="strong"><strong>         for {</strong></span>
<span class="strong"><strong>           deal &lt;- xml \\ "deal"</strong></span>
<span class="strong"><strong>           title = (deal \\ "title").text</strong></span>
<span class="strong"><strong>           dealUrl = (deal \\ "dealUrl").text</strong></span>
<span class="strong"><strong>           tag = (deal \\ "tag" \ "name").text</strong></span>
<span class="strong"><strong>         } yield Deal(title, dealUrl, tag)</strong></span>
<span class="strong"><strong>extractDeals: (xml: scala.xml.Elem)scala.collection.immutable.Seq[Deal]</strong></span>
</pre></div><p>As we did previously for retrieving cities, we can now retrieve deals via HTTP GET and parse XML this time for the particular city of Honolulu, knowing its latitude and longitude, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val dealsInHonolulu = </strong></span>
<span class="strong"><strong>  Http(dealsByGeoArea &lt;&lt;? Map("lat"-&gt;lat,"lng"-&gt;lng) OK as.xml.Elem)</strong></span>
<span class="strong"><strong>dealsInHonolulu: dispatch.Future[scala.xml.Elem] = scala.concurrent.impl.Promise$DefaultPromise@a1f0cb1</strong></span>
</pre></div><p>The <code class="literal">&lt;&lt;?</code> operator means that we attach input parameters of a <code class="literal">GET</code> method to the <code class="literal">dealsByGeoArea</code> request. The <code class="literal">Map</code> object contains the parameters. It is equivalent to the normal representation of HTTP GET where we put the input parameters as key/value pairs in the URL (that is, <code class="literal">request_url?param1=value1;param2=value2</code>). This is in contrast with the <code class="literal">&lt;&lt;</code> operator, which would have specified a <code class="literal">POST</code> request. Creating a structured sequence of <code class="literal">Deal</code> instances out of the raw XML produced by the <code class="literal">dealsInHonolulu()</code> service call can be written as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val deals = extractDeals(dealsInHonolulu())</strong></span>
<span class="strong"><strong>deals: scala.collection.immutable.Seq[Deal] = List(Deal(Laundry Folding StylesExam with Posture Analysis and One or Three Adjustments at Cassandra Peterson Chiropractic (Up to 85% Off)One initial consultation, one exam, one posture analysis, and one adjustmentOne initial consultation, one exam, one posture analysis, and three adjustments,http://www.groupon.com/deals/cassandra-peterson-chiropractic,Beauty &amp; Spas), Deal(Laundry Folding Styles1.5-Hour Whale-Watching SunsetÂ ï»¿Tour for an Adult or Child from Island Water Sports Hawaii (50% Off) A 1.5-hour whale watching sunset tour for one childA 1.5-hour whale watching sunset tour for one adult,http://www.groupon.com/deals/island-water-sports-hawaii-18,Arts and EntertainmentOutdoor Pursuits), Deal(Dog or Horse?$25 for Take-Home Teeth-Whit...</strong></span>
</pre></div><p>Sorting the list of deals by their <a id="id183" class="indexterm"/>category is <a id="id184" class="indexterm"/>only a matter of applying a <code class="literal">groupBy</code> method on the collection as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sortedDeals = deals groupBy(_.tag)</strong></span>
<span class="strong"><strong>sortedDeals: scala.collection.immutable.Map[String,scala.collection.immutable.Seq[Deal]] = Map("" -&gt; List(Deal(SkeleCopSix Bottles of 3 Wine Men 2009 Merlot with Shipping Included6 Bottles of Premium Red Wine,http://www.groupon.com/deals/gg-3-wine-men-2009-merlot-package,), Deal(Famous...</strong></span>
</pre></div><p>Notice how the <code class="literal">groupBy</code> method is a very convenient way of applying the <code class="literal">Map</code> part of a <span class="strong"><strong>MapReduce</strong></span> job operating on a collection, in our case creating a <code class="literal">Map</code> object where keys are the tags or categories of the Groupon deals and values are a list of the deals that belong to the specific category. A <a id="id185" class="indexterm"/>possible tiny <code class="literal">Reduce</code> operation on the <code class="literal">Map</code> object can, for example, consist of counting the number of deals for each category, using the <code class="literal">mapValues</code> method that transforms the values of this (key,value) store:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val nbOfDealsPerTag = sortedDeals mapValues(_.size)</strong></span>
<span class="strong"><strong>nbOfDealsPerTag: scala.collection.immutable.Map[String,Int] = Map("" -&gt; 2, Arts and EntertainmentOutdoor Pursuits -&gt; 1, Beauty &amp; Spas -&gt;3, Food &amp; DrinkCandy Stores -&gt; 1, ShoppingGifts &amp; Giving -&gt; 1, ShoppingFraming -&gt; 1, EducationSpecialty Schools -&gt; 1, Tickets -&gt; 1, Services -&gt; 1, TravelTravel AgenciesEurope, Asia, Africa, &amp; Oceania -&gt; 1)</strong></span>
</pre></div><p>The example we went through only explores the surface of what we can do with HTTP tools such as dispatch and much more is described in their documentation. The direct interaction with the REPL greatly enhances the learning curve of such APIs.</p><p>There are several excellent alternatives of <a id="id186" class="indexterm"/>lightweight frameworks for dealing with HTTP interaction, and in the case of dispatch, we have only looked at the client side of things. Lightweight REST APIs can, therefore, be constructed by frameworks such as Unfiltered, Finagle, Scalatra, or Spray to name a few. Spray is currently being architected again to become the HTTP layer of the Play framework (on top of Akka); technologies we are going to cover later on in this book.</p></div></div>
<div class="section" title="Taking advantage of Typesafe Activator"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Taking advantage of Typesafe Activator</h1></div></div></div><p>To be able to run an interactive programming session in the previous chapters, we have downloaded and installed a tool named <a id="id187" class="indexterm"/>
<span class="strong"><strong>Typesafe Activator</strong></span>. Running either as a command-line tool or through a web browser, the activator lets us create and execute a sample project out of a template, in this case, a minimal <code class="literal">hello-scala</code> project. From it, we have accessed the SBT console, which acts as a REPL.</p><p>Typesafe Activator can be seen as a lightweight IDE powered by SBT. It provides many project templates that programmers can reuse as a starting point in their new development project.</p><div class="section" title="Creating an application based on activator templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Creating an application based on activator templates</h2></div></div></div><p>Open a <a id="id188" class="indexterm"/>command terminal window and go to the directory where you extracted the activator, then enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ./activator new</strong></span>
<span class="strong"><strong>Enter an application name</strong></span>
<span class="strong"><strong>&gt;</strong></span>
</pre></div><p>You need to enter a name for your new project as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; javasample</strong></span>
<span class="strong"><strong>Fetching the latest list of templates...</strong></span>
<span class="strong"><strong>Enter a template name, or hit tab to see a list of possible templates</strong></span>
<span class="strong"><strong>&gt; [Hit TAB]</strong></span>
<span class="strong"><strong>activator-akka-cassandra                  activator-akka-spray</strong></span>
<span class="strong"><strong>activator-play-autosource-reactivemongo   activator-scalding</strong></span>
<span class="strong"><strong>activator-spray-twitter                   akka-callcenter</strong></span>
<span class="strong"><strong>akka-cluster-sharding-scalaakka-clustering</strong></span>
<span class="strong"><strong>akka-distributed-workers     akka-distributed-workers-java</strong></span>
<span class="strong"><strong>akka-java-spring                          akka-sample-camel-java</strong></span>
<span class="strong"><strong>akka-sample-camel-scalaakka-sample-cluster-java</strong></span>
<span class="strong"><strong>akka-sample-cluster-scalaakka-sample-fsm-java-lambda</strong></span>
<span class="strong"><strong>akka-sample-fsm-scalaakka-sample-main-java</strong></span>
<span class="strong"><strong>akka-sample-main-scalaakka-sample-multi-node-scala</strong></span>
<span class="strong"><strong>akka-sample-persistence-java   akka-sample-persistence-scala</strong></span>
<span class="strong"><strong>akka-sample-remote-java                   akka-sample-remote-scala</strong></span>
<span class="strong"><strong>akka-scala-spring                         akka-supervision</strong></span>
<span class="strong"><strong>angular-seed-play                         atomic-scala-examples</strong></span>
<span class="strong"><strong>dart-akka-spray                           eventual</strong></span>
<span class="strong"><strong>hello-akka                                hello-play</strong></span>
<span class="strong"><strong>hello-play-backbone                       hello-play-java</strong></span>
<span class="strong"><strong>hello-play-scala                          hello-sbt</strong></span>
<span class="strong"><strong>hello-scala                               hello-scala-eclipse</strong></span>
<span class="strong"><strong>hello-scaloid                             hello-slick</strong></span>
<span class="strong"><strong>just-play-scalamacwire-activator</strong></span>
<span class="strong"><strong>matthiasn-sse-chat-template               modern-web-template</strong></span>
<span class="strong"><strong>play-akka-angular-websocket               play-angularjs-webapp-seed</strong></span>
<span class="strong"><strong>play-cake                                 play-example-form</strong></span>
<span class="strong"><strong>play-guice                                play-hbase</strong></span>
<span class="strong"><strong>play-java-spring                          play-mongo-knockout</strong></span>
<span class="strong"><strong>play-scalatest-subcut                     play-slick</strong></span>
<span class="strong"><strong>play-slick-advanced                       play-spring-data-jpa</strong></span>
<span class="strong"><strong>play-sqlite                               play-with-angular-requirejs</strong></span>
<span class="strong"><strong>play-yeoman                               play2-crud-activator</strong></span>
<span class="strong"><strong>reactive-maps                             reactive-stocks</strong></span>
<span class="strong"><strong>realtime-search                           scala-phantom-types</strong></span>
<span class="strong"><strong>scaldi-play-example                    scalikejdbc-activator-template</strong></span>
<span class="strong"><strong>six-minute-apps                           slick-android-example</strong></span>
<span class="strong"><strong>slick-codegen-customization-example       slick-codegen-example</strong></span>
<span class="strong"><strong>slick-plainsql                            spray-actor-per-request</strong></span>
<span class="strong"><strong>tcp-async                                 template-template</strong></span>
<span class="strong"><strong>test-patterns-scala                       tweetmap-workshop</strong></span>
</pre></div><p>Version 1.0.13 that we are using already contains 76 templates combining diverse technologies and frameworks together to make some interesting demo projects, but this list is increasing quickly (from 38 to 76 between Version 1.0.0 and 1.0.13, which are only a few months apart).</p><p>For now, let's take a look at the <code class="literal">play-java-spring</code> template, a project sample in Java, so that we can feel comfortable <a id="id189" class="indexterm"/>with the code it contains. Therefore, enter its name when prompted for the name of the template to be used:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play-java-spring</strong></span>
<span class="strong"><strong>OK, application "javasample" is being created using the "play-java-spring" template.</strong></span>

<span class="strong"><strong>To run "javasample" from the command-line, run:</strong></span>
<span class="strong"><strong>/Users/thomas/scala/activator-1.0.13/javasample/activator run</strong></span>

<span class="strong"><strong>To run the test for "javasample" from the command-line, run:</strong></span>
<span class="strong"><strong>/Users/thomas/scala/activator-1.0.13/javasample/activator test</strong></span>

<span class="strong"><strong>To run the Activator UI for "javasample" from the command-line, run:</strong></span>
<span class="strong"><strong>/Users/thomas/scala/activator-1.0.13/javasample/activator ui</strong></span>
</pre></div><p>The activator creates a SBT project, meaning you can edit <code class="literal">build.sbt</code> or <code class="literal">plugins.sbt</code> to add dependencies, repositories (that is, resolvers) as well as SBT plugins. We can, for example, reuse the <code class="literal">addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "2.4.0") </code>line in <code class="literal">plugins.sbt</code> that we stated earlier to be able to create Eclipse project files and import the project into our Scala IDE.</p><p>First, let's execute the program to see what it does:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd javasample</strong></span>
<span class="strong"><strong>&gt; ./activator run</strong></span>
</pre></div><p>As the sample is based on the Play framework (that we will cover in later chapters), the following is displayed to indicate that the web application is deployed on localhost at port 9000:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>--- (Running the application from SBT, auto-reloading is enabled) ---</strong></span>
<span class="strong"><strong>[info] play - Listening for HTTP on /0:0:0:0:0:0:0:0:9000</strong></span>
<span class="strong"><strong>(Server started, use CTRL +D to stop and go back to the console...)</strong></span>
</pre></div><p>Open a browser at localhost:9000 to visualize the very basic web form of the sample and submit a couple of entries to be stored in the tiny database, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_03_01.jpg" alt="Creating an application based on activator templates"/></div><p>This web application takes an input from a simple HTML form and saves <code class="literal">Bar</code> objects into a small database through JPA.</p><p>To take a look at the code that is part of this template; we can run it through the activator by first pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span> <a id="id190" class="indexterm"/>in the command window to interrupt the current execution, and then, enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ./activator ui</strong></span>
</pre></div><p>After a few seconds, a browser page should open at <code class="literal">http://localhost:8888/app/javasample/</code> displaying the activator user interface specifically targeted to this application. Click on the <span class="strong"><strong>Code view &amp; Open in IDE</strong></span> item and navigate to the <code class="literal">app/models/Bar.java</code> file by double-clicking on the items on the left-hand side panel, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_03_02.jpg" alt="Creating an application based on activator templates"/></div><p>The browser displays a JPA-annotated entity as we are used to working with typically in the Eclipse IDE with colored and formatted syntax. The panel on the right-hand side leaves room for a tutorial, a precious feature to quickly understand the code and start modifying it. The top menu enables <a id="id191" class="indexterm"/>you to compile, run, or test the application from within the browser. You can open some of the other source files to identify the structure of the code, although we will cover play web applications in detail later on.</p><p>In summary, Typesafe Activator is a way to get you started in just minutes and is very flexible as you can run activator projects directly as SBT projects, therefore, having the possibility to generate IDE-specific files to continue working in Eclipse, IDEA, or NetBeans if you wish to.</p></div></div>
<div class="section" title="The REPL as a scripting engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>The REPL as a scripting engine</h1></div></div></div><p>To deal with interoperability with <a id="id192" class="indexterm"/>programs written in scripting languages, the Java community process has defined <span class="emphasis"><em>JSR-223</em></span>, <span class="emphasis"><em>Scripting for the JavaTM Platform</em></span>, a Java specification request that makes it possible to execute scripts written in other languages (such as Groovy, JavaScript, Ruby, or Jython to name of few) from within a Java program. For instance, we can write a Java program embedding a basic JavaScript snippet as follows:</p><div class="informalexample"><pre class="programlisting">package com.demo;
import javax.script.*;

public class JSR223Sample { 

  public static void main(String[] args) throws Exception {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("JavaScript");

    // expose object as variable to script
    engine.put("n", 5);

    // evaluate a script string. 
    engine.eval("for(i=1; i&lt;= n; i++) println(i)");
  }
}</pre></div><p>We will get the following output from the IDE:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>run:</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>3</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>5</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL (total time: 0 seconds)</strong></span>
</pre></div><p>Starting from Scala's upcoming Version 2.11, this very convenient functionality will let you interpret scripts written in <a id="id193" class="indexterm"/>Scala as well. The following is an example that we can just run directly in the REPL (taken from the <a class="ulink" href="http://scala-lang.org">scala-lang.org</a> documentation):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import javax.script.ScriptEngineManager</strong></span>
<span class="strong"><strong>importjavax.script.ScriptEngineManager</strong></span>
<span class="strong"><strong>scala&gt; val engine = </strong></span>
<span class="strong"><strong>         new ScriptEngineManager().getEngineByName("scala")</strong></span>
<span class="strong"><strong>engine: javax.script.ScriptEngine = scala.tools.nsc.interpreter.IMain@7debe95d</strong></span>
<span class="strong"><strong>scala&gt; engine.put("n", 5)</strong></span>
<span class="strong"><strong>n: Object = 5</strong></span>
<span class="strong"><strong>scala&gt; engine.eval("1 to n.asInstanceOf[Int] foreachprintln")</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>3</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>5</strong></span>
<span class="strong"><strong>res4: Object = null</strong></span>
</pre></div><p>The engine context can bind the <code class="literal">n</code> variable to the integer value <code class="literal">5</code>, which can be invoked in the one-liner script which consists of a <code class="literal">foreach</code> lambda expression. The script, in this case, is only a side effect and does not <a id="id194" class="indexterm"/>return any interesting value.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Summary</h1></div></div></div><p>In this chapter, we have covered some of the major differences between the Java and Scala ecosystems, and it is noticed that apart from SBT and REPL, which are not found in the Java world, we are able to reuse all the Java libraries, tools, and frameworks. We have seen that this <code class="literal">group % artifact % version</code> format used to load dependencies in SBT is the same as that of Java's Maven, and in fact, SBT, by default, is similar to most of the Maven repositories (for example, Maven Central). We can, therefore, feel confident that the vast majority of our Java skills are reusable, and they make the transition easier at least as long as the ecosystem is concerned. We voluntarily omitted talking about the testing ecosystem as this is the main topic of our next chapter.</p></div></body></html>