<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Testing</h1></div></div></div><p>Testing is the <a id="id318" class="indexterm"/>process of cross-checking the implementation of an application/process. It brings its shortcomings out into the open. It can be extremely handy when you are upgrading/downgrading one or more dependencies. Tests can be classified into various categories based on different programming practices, but in this chapter, we will only discuss two types of tests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unit tests</strong></span>: These are <a id="id319" class="indexterm"/>tests that check the functionality of a specific section of code</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functional tests</strong></span>: These are <a id="id320" class="indexterm"/>tests that check a specific action, mostly written to verify working code with regard to a use case or scenario</li></ul></div><p>In the following sections, we will see the different ways in which we can test a Play application using <span class="strong"><strong>Specs2</strong></span> and <span class="strong"><strong>ScalaTest</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The tests using either of the Specs2 and ScalaTest libraries are similar. The major difference is in the keywords, syntax, and style. Since different developers can have different preferences, in this chapter, tests are defined using both libraries and for convenience. Most of the tests written using Specs2 have names ending with <code class="literal">'Spec'</code>, while those using ScalaTest end with <code class="literal">'Test'</code>.</p></div></div><div class="section" title="The setup for writing tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec60"/>The setup for writing tests</h1></div></div></div><p>Play is packaged <a id="id321" class="indexterm"/>with <code class="literal">Specs2</code>, since this is the library used internally for testing it. It provides support to test applications using Specs2 by default, that is, no additional library dependency is required.</p><p>Using <code class="literal">ScalaTest</code> earlier was difficult but now, Play also provides helpers for using ScalaTest. Although it is picked up from transitive dependencies, we need to add a library dependency to use the helper methods:</p><div class="informalexample"><pre class="programlisting">val appDependencies = Seq(
  "org.scalatestplus" %% "play" % "1.1.0" % "test"
)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The 1.1.0 version of <code class="literal">org.scalatestplus.play</code> is compatible with Play 2.3.x. It is better to check the compatibility when working with another version of Play at <a class="ulink" href="http://www.scalatest.org/plus/play/versions">http://www.scalatest.org/plus/play/versions</a>.</p></div></div></div></div>
<div class="section" title="Unit testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Unit testing</h1></div></div></div><p>Unit tests can be <a id="id322" class="indexterm"/>written as in any Scala project. For example, suppose we have a utility method <code class="literal">isNumberInRange</code> that takes a string and checks if it's a number in the range [0,3600]. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">def isNumberInRange(x:String):Boolean = {
    val mayBeNumber = Try{x.toDouble}
    mayBeNumber match{
      case Success(n) =&gt; if(n&gt;=0 &amp;&amp; n&lt;=3600) true else false
      case Failure(e) =&gt; false
    }
  }</pre></div><p>Let's write a unit test to check this function using <code class="literal">Specs2</code>:</p><div class="informalexample"><pre class="programlisting">class UtilSpec extends Specification {

    "range method" should {

    "fail for Character String" in {
      Util.isNumberInRange("xyz") should beFalse
    }

    "fail for Java null" in {
      Util.isNumberInRange(null) should beFalse
    }

    "fail for Negative numbers" in {
      Util.isNumberInRange("-2") should beFalse
    }

    "pass for valid number" in {
      Util.isNumberInRange("1247") should beTrue
    }

    "pass for 0" in {
      Util.isNumberInRange("0") should beTrue
    }

    "pass for 3600" in {
      Util.isNumberInRange("3600") should beTrue
    }
    
  }
}</pre></div><p>These scenarios can <a id="id323" class="indexterm"/>also be written using <code class="literal">ScalaTest</code> with slight modifications:</p><div class="informalexample"><pre class="programlisting">class UtilTest extends FlatSpec with Matchers {

  "Character String" should "not be in range" in {
    Util.isNumberInRange("xyz") should be(false)
  }

  "Java null" should "not be in range" in {
    Util.isNumberInRange(null) should be(false)
  }

  "Negative numbers" should "not be in range" in {
    Util.isNumberInRange("-2") should be(false)
  }

  "valid number" should "be in range" in {
    Util.isNumberInRange("1247") should be(true)
  }

  "0" should "be in range" in {
    Util.isNumberInRange("0") should be(true)
  }

  "3600" should "be in range" in {
    Util.isNumberInRange("3600") should be(true)
  }
}</pre></div><p>Unit tests that need to <a id="id324" class="indexterm"/>rely on external dependencies and data service layers should be defined using <span class="strong"><strong>mocks</strong></span>. Mocking is the process of simulating actual behavior. <span class="strong"><strong>Mockito</strong></span>, <span class="strong"><strong>ScalaMock</strong></span>, <span class="strong"><strong>EasyMock</strong></span>, and <span class="strong"><strong>jMock</strong></span> are some of the libraries that facilitate mocking.</p></div>
<div class="section" title="Dissecting PlaySpecification"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Dissecting PlaySpecification</h1></div></div></div><p>The tests written <a id="id325" class="indexterm"/>using Specs2 can also be written as follows:</p><div class="informalexample"><pre class="programlisting">class UtilSpec extends PlaySpecification {...}</pre></div><p>
<code class="literal">PlaySpecification</code> is a trait that provides the required helper methods to test a Play application using Specs2. It is defined as:</p><div class="informalexample"><pre class="programlisting">trait PlaySpecification extends Specification
    with NoTimeConversions
    with PlayRunners
    with HeaderNames
    with Status
    with HttpProtocol
    with DefaultAwaitTimeout
    with ResultExtractors
    with Writeables
    with RouteInvokers
    with FutureAwaits {
}</pre></div><p>Let's scan through the API exposed by each of these traits to understand its significance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Specification</code> and <code class="literal">NoTimeConversions</code> are traits of Specs2. <code class="literal">NoTimeConversions</code> can be used to deactivate the time conversions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PlayRunners</code> provides helper methods to execute a block of code in a running application or server with or without specifying the browser.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HeaderNames</code> and <code class="literal">Status</code> define constants for all the standard HTTP headers and HTTP status codes, respectively, with their relevant names, as shown here:<div class="informalexample"><pre class="programlisting">HeaderNames.ACCEPT_CHARSET = "Accept-Charset"
Status.FORBIDDEN = 403</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">HttpProtocol</code> defines the constants related to the HTTP protocol:<div class="informalexample"><pre class="programlisting">object HttpProtocol extends HttpProtocol
trait HttpProtocol {
  // Versions
  val HTTP_1_0 = "HTTP/1.0"

  val HTTP_1_1 = "HTTP/1.1"

  // Other HTTP protocol values
  val CHUNKED = "chunked"
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ResultExtractors</code> provides methods to extract data from the HTTP response, which is of the <code class="literal">Future[Result]</code> type. These methods are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">charset(of: Future[Result])(implicit timeout: Timeout): Option[String]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">contentAsBytes(of: Future[Result])(implicit timeout: Timeout): Array[Byte]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">contentAsJson(of: Future[Result])(implicit timeout: Timeout): JsValue</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">contentAsString(of: Future[Result])(implicit timeout: Timeout): String</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">contentType(of: Future[Result])(implicit timeout: Timeout): Option[String]</code></li><li class="listitem" style="list-style-type: disc"> <code class="literal">cookies(of: Future[Result])(implicit timeout: Timeout): Cookies</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">flash(of: Future[Result])(implicit timeout: Timeout): Flash</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">header(header: String, of: Future[Result])(implicit timeout: Timeout): Option[String]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">headers(of: Future[Result])(implicit timeout: Timeout): Map[String, String]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">redirectLocation(of: Future[Result])(implicit timeout: Timeout): Option[String]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">session(of: Future[Result])(implicit timeout: Timeout): Session</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">status(of: Future[Result])(implicit timeout: Timeout): Int</code></li></ul></div></li></ul></div><p>The <code class="literal">implicit Timeout</code> in these method calls is provided by the <code class="literal">DefaultAwaitTimeout</code> trait and the default timeout is set to 20 seconds. This <a id="id326" class="indexterm"/>can be overridden by providing an implicit timeout in the scope of the scenario.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">RouteInvokers</code> provides the methods to call a corresponding <code class="literal">Action</code> for a given request using <code class="literal">Router</code>. These methods are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">route[T](app: Application, req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">route[T](app: Application, rh: RequestHeader, body: T)(implicit w: Writeable[T]): Option[Future[Result]]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">route[T](req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">route[T](rh: RequestHeader, body: T)(implicit w: Writeable[T]): Option[Future[Result]]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">call[T](action: EssentialAction, rh: RequestHeader, body: T)(implicit w: Writeable[T]): Future[Result]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">call[T](action: EssentialAction, req: FakeRequest[T])(implicit w: Writeable[T]): Future[Result]</code></li></ul></div><p>The <code class="literal">implicit Writable</code> in these method calls is provided by the <code class="literal">Writeables</code> trait. The <code class="literal">call</code> methods are inherited from <code class="literal">EssentialActionCaller</code>.</p></li><li class="listitem" style="list-style-type: disc">The <code class="literal">FutureAwaits</code> <a id="id327" class="indexterm"/>trait provides methods to wait on a request with or without specifying the waiting time.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Although the library that supports ScalaTest for a Play application has an <code class="literal">PlaySpec</code> abstract class, there is no equivalent to <code class="literal">PlaySpecification</code> for ScalaTest. Instead, there's a helper object, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">object Helpers extends PlayRunners
  with HeaderNames
  with Status
  with HttpProtocol
  with DefaultAwaitTimeout
  with ResultExtractors
  with Writeables
  with EssentialActionCaller
  with RouteInvokers
  with FutureAwaits</pre></div><p>
<code class="literal">PlaySpec</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">abstract class PlaySpec extends WordSpec with MustMatchers with OptionValues with WsScalaTestClient</pre></div><p>Hence, importing <code class="literal">play.api.test.Helpers</code> is also sufficient to use only the helper methods.</p></div></div><p>For the following sections, with regard to tests using Specs2, we will extend PlaySpecification, and for ScalaTest, we will assume that <code class="literal">play.api.test.Helpers</code> is imported and the test extends to <code class="literal">PlaySpec</code>.</p></div>
<div class="section" title="Unit testing a controller"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Unit testing a controller</h1></div></div></div><p>We might have a simple <a id="id328" class="indexterm"/>project with a <code class="literal">User</code> model and <code class="literal">UserRepo</code>, defined as <a id="id329" class="indexterm"/>follows:</p><div class="informalexample"><pre class="programlisting">case class User(id: Option[Long], loginId: String, name: Option[String],
  contactNo: Option[String], dob: Option[Long], address: Option[String])
 
object User{
  implicit val userWrites = Json.writes[User]
}

trait UserRepo {
  def authenticate(loginId: String, password: String): Boolean

  def create(u: User, host: String, password: String): Option[Long]

  def update(u: User): Boolean

  def findByLogin(loginId: String): Option[User]

  def delete(userId: Long): Boolean

  def find(userId: Long): Option[User]

  def getAll: Seq[User]

  def updateStatus(userId: Long, isActive: Boolean): Int

  def updatePassword(userId: Long, password: String): Int
}</pre></div><p>In this project, we need to test a <code class="literal">getUser</code> method of <code class="literal">UserController</code>—a controller that is defined to access user details, which are handled by the user model, where <code class="literal">UserController</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">object UserController extends Controller {

  /* GET a specific user's details */
  def getUser(userId: Long) = Action {
    val u = AnormUserRepo.find(userId)
    if (u.isEmpty) {
      NoContent
    }
 else {
      Ok(Json.toJson(u))
    }
  }
....
}</pre></div><p>
<code class="literal">AnormUserRepo</code> is an implementation of <code class="literal">UserRepo</code>, which uses Anorm for DB transactions. The methods in <code class="literal">UserController</code> are mapped in the routes file as follows:</p><div class="informalexample"><pre class="programlisting">GET        /api/user/:userId        controllers.UserController.getUser(userId:Long)</pre></div><p>Since mocking Scala objects for tests is not yet fully supported by a testing library, there are different approaches to unit <a id="id330" class="indexterm"/>test a controller. These are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Defining all the controller's methods in a trait and then this trait can be extended by an object, while the trait is tested for functionality</li><li class="listitem">Defining controllers as classes and wiring up other required services using dependency injection</li></ol></div><p>Both these approaches require us to modify our application code. We can choose the one that suits our coding practices the best. Let's see what these changes are and how to write the corresponding tests in the following sections.</p><div class="section" title="Using traits for controllers"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec32"/>Using traits for controllers</h2></div></div></div><p>In this approach, we <a id="id331" class="indexterm"/>define all the controller's methods in a trait and define the controller by extending this trait. For example, <code class="literal">UserController</code> should be defined as follows:</p><div class="informalexample"><pre class="programlisting">trait BaseUserController extends Controller {
this: Controller =&gt;

  val userRepo:UserRepo

  /* GET a specific user's details */
  def getUser(userId: Long) = Action {
    val u = userRepo.find(userId)
    if (u.isEmpty) {
      NoContent
    } else {
      Ok(Json.toJson(u))
    }
  }

}

object UserController extends BaseUserController{
  val userRepo = AnormUserRepo
}</pre></div><p>Now, we can write tests <a id="id332" class="indexterm"/>for the <code class="literal">BaseUserController</code> trait—<code class="literal">UserControllerSpec</code> using Specs2 as follows:</p><div class="informalexample"><pre class="programlisting">class UserControllerSpec extends Specification with Mockito {

  "UserController#getUser" should {
    "be valid" in {
      val userRepository = mock[UserRepo]
      val defaultUser = User(Some(1), "loginId", Some("name"), Some("contact_no"), Some(20L), Some("address"))
      userRepository.find(1) returns Option(defaultUser)

      class TestController extends Controller with BaseUserController{
        val userRepo = userRepository
      }

      val controller = new TestController
      val result: Future[Result] = controller.getUser(1L).apply(FakeRequest())
      val userJson: JsValue = contentAsJson(result)

      userJson should be equalTo(Json.toJson(defaultUser))
    }
  }
}</pre></div><p>
<code class="literal">FakeRequest</code> is a helper that generates fake HTTP requests while testing.</p><p>Here, we mock <code class="literal">UserRepo</code> and use this mock to generate a new instance of <code class="literal">TestController</code>. ScalaTest provides integration with Mockito via its <code class="literal">MockitoSugar</code> trait, so there will be small changes in the code for mocking.</p><p>Using ScalaTest, the <code class="literal">UserControllerTest</code> test will be as follows:</p><div class="informalexample"><pre class="programlisting">class UserControllerTest extends PlaySpec with Results with MockitoSugar {

  "UserController#getUser" should {
    "be valid" in {
      val userRepository = mock[UserRepo]
      val defaultUser = User(Some(1), "loginId", Some("name"), Some("contact_no"), Some(20L), Some("address"))
      when(userRepository.find(1)) thenReturn Option(defaultUser)

      class TestController extends Controller with BaseUserController{
        val userRepo = userRepository
      }

      val controller = new TestController
      val result: Future[Result] = controller.getUser(1L).apply(FakeRequest())
      
      val userJson: JsValue = contentAsJson(result)
      userJson mustBe Json.toJson(defaultUser)
    }
  }
}</pre></div></div><div class="section" title="Using dependency injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec33"/>Using dependency injection</h2></div></div></div><p>We can make <a id="id333" class="indexterm"/>our controller depend on specific <a id="id334" class="indexterm"/>services, and all of this is configurable through the global object's <code class="literal">getControllerInstance</code> method by using a dependency injection library.</p><p>In this example, we have used <span class="strong"><strong>Guice</strong></span> by adding it as a dependency for our project:</p><div class="informalexample"><pre class="programlisting">val appDependencies = Seq(
    ...
    "com.google.inject" % "guice" % "3.0",
    "javax.inject" % "javax.inject" % "1"
  )</pre></div><p>Now, let's update the <code class="literal">getControllerInstance</code> method in the <code class="literal">Global</code> object:</p><div class="informalexample"><pre class="programlisting">object Global extends GlobalSettings {

  val injector = Guice.createInjector(new AbstractModule {
    protected def configure() {
      bind(classOf[UserRepo]).to(classOf[AnormUserRepo])
    }
  })

  override def getControllerInstance[A](controllerClass: Class[A]): A = injector.getInstance(controllerClass)
}</pre></div><p>We now define <code class="literal">UserController</code> as a singleton that extends <code class="literal">play.api.mvc.Controller</code> and uses <code class="literal">UserRepo</code>, which is injected:</p><div class="informalexample"><pre class="programlisting">@Singleton
class UserController @Inject()(userRepo: UserRepo) extends Controller {

  implicit val userWrites = Json.writes[User]

  /* GET a specific user's details */
  def getUser(userId: Long) = Action {
    val u = userRepo.find(userId)
    if (u.isEmpty) {
      NoContent
    }
    else {
      Ok(Json.toJson(u))
    }
  }

}</pre></div><p>We will also need to modify the routes file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GET        /api/user/:userId        @controllers.UserController.getUser(userId:Long)</strong></span>
</pre></div><p>The <code class="literal">@</code> symbol at the <a id="id335" class="indexterm"/>beginning of the method call <a id="id336" class="indexterm"/>indicates that the global object's <code class="literal">getControllerInstance</code> method should be used.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>If we do not add the <code class="literal">@</code> suffix to the method name, it will search for an object with the <code class="literal">UserController</code> name and throw errors during compilation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>object UserController is not a member of package controllers</strong></span>
<span class="strong"><strong>[error] Note: class UserController exists, but it has no companion object.</strong></span>
<span class="strong"><strong>[error] GET        /api/user/:userId        controllers.UserController.getUser(userId:Long)</strong></span>
</pre></div></div></div><p>Finally, we can write a unit test using Specs2 as follows:</p><div class="informalexample"><pre class="programlisting">class UserControllerSpec extends Specification with Mockito {

  "UserController#getUser" should {
    "be valid" in {
      val userRepository = mock[AnormUserRepo]
      val defaultUser = User(Some(1), "loginId", Some("name"), Some("contact_no"), Some(20L), Some("address"))
      userRepository.find(1) returns Option(defaultUser)

      val controller = new UserController(userRepository)
      val result: Future[Result] = controller.getUser(1L).apply(FakeRequest())
      val userJson: JsValue = contentAsJson(result)
      
      userJson should be equalTo(Json.toJson(defaultUser))
    }
  }
}</pre></div><p>Here, we mock <code class="literal">AnormUserRepo</code> and use this mock to generate a new instance of <code class="literal">UserController</code>.</p><p>The same test using ScalaTest will be as follows:</p><div class="informalexample"><pre class="programlisting">class UserControllerTest extends PlaySpec with Results with MockitoSugar {

  "UserController#getUser" should {
    "be valid" in {
      val userRepository = mock[AnormUserRepo]
      val defaultUser = User(Some(1), "loginId", Some("name"), Some("contact_no"), Some(20L), Some("address"))
      when(userRepository.find(1)) thenReturn Option(defaultUser)

      val controller = new UserController(userRepository)
      val result: Future[Result] = controller.getUser(1L).apply(FakeRequest())
      val userJson: JsValue = contentAsJson(result)
       
      userJson mustBe Json.toJson(defaultUser)
    }
  }
}</pre></div><p>The following table <a id="id337" class="indexterm"/>summarizes the key <a id="id338" class="indexterm"/>differences in both these approaches, so that it's easier to decide which one suits your requirement in the best way:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Using traits for controllers</p>
</th><th style="text-align: left" valign="bottom">
<p>Using dependency injection</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>It requires defining and not just declaring all the methods to be supported by a controller in a trait.</p>
</td><td style="text-align: left" valign="top">
<p>It requires a controller to be defined as a singleton class and provides implementations for the global object's <code class="literal">getControllerInstance</code> method.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>It does not require additional libraries.</p>
</td><td style="text-align: left" valign="top">
<p>It requires using a dependency injection library and provides flexibility to plug-in different classes in different application modes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>It requires defining an additional class for a controller, which extends a trait for testing.</p>
</td><td style="text-align: left" valign="top">
<p>It does not require any additional class definitions to test a controller, since a new instance can be instantiated from a singleton.</p>
</td></tr></tbody></table></div><p>For more examples on <a id="id339" class="indexterm"/>dependency injection, refer to <a class="ulink" href="https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection">https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection</a>.</p></div></div>
<div class="section" title="Functional testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Functional testing</h1></div></div></div><p>Let's look at some of <a id="id340" class="indexterm"/>Play's test cases to see how to use the helper methods. For example, consider the <code class="literal">DevErrorPageSpec</code> test, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">object DevErrorPageSpec extends PlaySpecification{

  "devError.scala.html" should {

    val testExceptionSource = new play.api.PlayException.ExceptionSource("test", "making sure the link shows up") {
      ...
    }
    ….
    "show prod error page in prod mode" in {
      val fakeApplication = new FakeApplication() {
        override val mode = play.api.Mode.Prod
      }
      running(fakeApplication) {
        val result = DefaultGlobal.onError(FakeRequest(), testExceptionSource)
        Helpers.contentAsString(result) must contain("Oops, an error occurred")
      }
    }
  }
}</pre></div><p>This test starts <code class="literal">FakeApplication</code> with the Prod mode and checks the response when <code class="literal">FakeRequest</code> encounters an exception.</p><p>
<code class="literal">FakeApplication</code> extends an application and is defined as follows:</p><div class="informalexample"><pre class="programlisting">case class FakeApplication(config: Map[String, Any] = Map(),
                           path: File = new File("."),
                           sources: Option[SourceMapper] = None,
                           mode: Mode.Mode = Mode.Test,
                           global: GlobalSettings = DefaultGlobal,
                           plugins: Seq[Plugin] = Nil) extends Application {
  val classloader = Thread.currentThread.getContextClassLoader
  lazy val configuration = Configuration.from(config)
}</pre></div><p>The method that is <a id="id341" class="indexterm"/>running is part of PlayRunners and executes a block of code in the context of a given application. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">def running[T](app: Application)(block: =&gt; T): T = {
    synchronized {
      try {
        Play.start(app)
        block
      } finally {
        Play.stop()
      }
    }
  }</pre></div><p>PlayRunners has a few more definitions of how to run, these are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">running[T](testServer: TestServer)(block: =&gt; T)</code><code class="literal">: T</code>: This can be used to execute a block of code in a running server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">running[T](testServer: TestServer, webDriver: WebDriver)(block: TestBrowser =&gt; T): T</code>: This can be used to execute a block of code in a running server with a test browser.</li><li class="listitem" style="list-style-type: disc"><code class="literal">running[T, WEBDRIVER &lt;: WebDriver](testServer: TestServer, webDriver: Class[WEBDRIVER])(block: TestBrowser =&gt; T): T</code>: This can also be used to execute a block of code in a running server with a test browser using Selenium WebDriver. This method uses the previous method internally.</li></ul></div><p>Instead of using the <code class="literal">running</code> method directly, as an alternative, we could define our tests using the wrapper classes, which make use of the running. There are different helpers for Specs2 and ScalaTest.</p><div class="section" title="Using Specs2"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec34"/>Using Specs2</h2></div></div></div><p>First, let's <a id="id342" class="indexterm"/>look at the ones available when using Specs2. They <a id="id343" class="indexterm"/>are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">WithApplication</code>: It is used to execute a test within the context of a running application. For example, consider a situation where we want to write functional tests for <code class="literal">CountController</code>, which is responsible for getting a count of distinct data grouped by a perspective. We can write the test as follows:<div class="informalexample"><pre class="programlisting">class CountControllerSpec extends PlaySpecification with BeforeExample {

  override def before: Any = {
    TestHelper.clearDB
  }

  """Counter query""" should {
    """fetch count of visits grouped by browser names""" in new WithApplication {
      TestHelper.postSampleData

      val queryString = """applicationId=39&amp;perspective=browser&amp;from=1389949200000&amp;till=1399145400000""".stripMargin

      val request = FakeRequest(GET, "/query/count?" + queryString)
      val response = route(request)
      val result = response.get
      status(result) must equalTo(OK)
      contentAsJson(result) must equalTo(TestHelper.browserCount)
    }
  }</pre></div><p>Here, assume that <code class="literal">TestHelper</code> is a helper object specifically defined for simplifying <a id="id344" class="indexterm"/>the code of test cases (extracting common processes as methods).</p><p>If we need to <a id="id345" class="indexterm"/>specify <code class="literal">FakeApplication</code>, we can do so by passing it as an argument to the <code class="literal">WithApplication</code> constructor:</p><div class="informalexample"><pre class="programlisting"> val app = FakeApplication()
    """fetch count of visits grouped by browser names""" in new WithApplication(app) {</pre></div><p>This comes in handy when we want to change the default application configurations, GlobalSettings, and so on for the tests.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">WithServer</code>: It is used to execute tests within the context of a running application on a new <code class="literal">TestServer</code>. This is quite useful when we need to start our <code class="literal">FakeApplication</code> on a new <code class="literal">TestServer</code> at a specific port. After slightly modifying the previous example:<div class="informalexample"><pre class="programlisting">    """fetch count of visits grouped by browser names""" in new WithServer(app = app, port = testPort) {
 {
      ...
 }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">WithBrowser</code>: It is used to test an application's functionality by performing certain actions in <a id="id346" class="indexterm"/>browsers. For example, consider a dummy application where the page title changes on the click of a <a id="id347" class="indexterm"/>button. We can test it as follows:<div class="informalexample"><pre class="programlisting">class AppSpec extends PlaySpecification {
  val app: FakeApplication =
    FakeApplication(
      withRoutes = TestRoute
    )

    "run in firefox" in new WithBrowser(webDriver = WebDriverFactory(FIREFOX), app = app) {
     browser.goTo("/testing")
     browser.$("#title").getTexts().get(0) must equalTo("Test Page")

     browser.$("b").click()

     browser.$("#title").getTexts().get(0) must equalTo("testing")
    }}</pre></div><p>We are assuming <code class="literal">TestRoute</code> is a partial function that maps to some of the routes which can then be used in tests.</p></li></ul></div></div><div class="section" title="Using ScalaTest"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec35"/>Using ScalaTest</h2></div></div></div><p>Now, lets see what <a id="id348" class="indexterm"/>
<span class="strong"><strong>ScalaTestPlus-Play</strong></span>, the library with helper methods that are used for testing with the help of ScalaTest, has to offer. In this section, we <a id="id349" class="indexterm"/>will see examples from <code class="literal">ScalatestPlus-Play</code> wherever applicable. The helpers for ScalaTest are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OneAppPerSuite</code>: It starts <code class="literal">FakeApplication</code> using <code class="literal">Play.start</code> before running any tests in a suite and then stops it once they are completed. The application is <a id="id350" class="indexterm"/>exposed through the variable app and can be overridden if required. From <code class="literal">ExampleSpec.scala</code>:<div class="informalexample"><pre class="programlisting">class ExampleSpec extends PlaySpec with OneAppPerSuite {

  // Override app if you need a FakeApplication with other than non-default parameters.
  implicit override lazy val app: FakeApplication =
    FakeApplication(additionalConfiguration = Map("ehcacheplugin" -&gt; "disabled"))

  "The OneAppPerSuite trait" must {
    "provide a FakeApplication" in {
      app.configuration.getString("ehcacheplugin") mustBe Some("disabled")
    }
    "make the FakeApplication available implicitly" in {
      def getConfig(key: String)(implicit app: Application) = app.configuration.getString(key)
      getConfig("ehcacheplugin") mustBe Some("disabled")
    }
    "start the FakeApplication" in {
      Play.maybeApplication mustBe Some(app)
    }
  }
}</pre></div><p>If we wish to use the same application for all or multiple suites, we can define a nested suite. For such an example, we can refer to <code class="literal">NestedExampleSpec.scala</code> from the library.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">OneAppPerTest</code>: It <a id="id351" class="indexterm"/>starts a new <code class="literal">FakeApplication</code> for each test defined in the suite. The application is exposed through the <a id="id352" class="indexterm"/><code class="literal">newAppForTest</code> method and can be overridden if required. For example, consider the <a id="id353" class="indexterm"/><code class="literal">OneAppTest</code> test, where each test uses a different <code class="literal">FakeApplication</code> obtained through <code class="literal">newAppForTest</code>:<div class="informalexample"><pre class="programlisting">class DiffAppTest extends UnitSpec with OneAppPerTest {

  private val colors = Seq("red", "blue", "yellow")

  private var colorCode = 0

  override def newAppForTest(testData: TestData): FakeApplication = {
    val currentCode = colorCode
    colorCode+=1
    FakeApplication(additionalConfiguration = Map("foo" -&gt; "bar",
      "ehcacheplugin" -&gt; "disabled",
      "color" -&gt; colors(currentCode)
    ))
  }

  def getConfig(key: String)(implicit app: Application) = app.configuration.getString(key)

  "The OneAppPerTest trait" must {
    "provide a FakeApplication" in {
      app.configuration.getString("color") mustBe Some("red")
    }
    "make another FakeApplication available implicitly" in {
      getConfig("color") mustBe Some("blue")
    }
    "make the third FakeApplication available implicitly" in {
      getConfig("color") mustBe Some("yellow")
    }
  }
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OneServerPerSuite</code>: It starts a new <code class="literal">FakeApplication</code> and a new <code class="literal">TestServer</code> for the suite. The application is exposed through the variable app and can be overridden if required. The server's port is set from the variable port and <a id="id354" class="indexterm"/>can be changed/modified if <a id="id355" class="indexterm"/>required. This has been <a id="id356" class="indexterm"/>demonstrated in the example for <code class="literal">OneServerPerSuite</code> (<code class="literal">ExampleSpec2.scala</code>):<div class="informalexample"><pre class="programlisting">class ExampleSpec extends PlaySpec with OneServerPerSuite {

  // Override app if you need a FakeApplication with other than non-default parameters.
  implicit override lazy val app: FakeApplication =
    FakeApplication(additionalConfiguration = Map("ehcacheplugin" -&gt; "disabled"))

  "The OneServerPerSuite trait" must {
    "provide a FakeApplication" in {
      app.configuration.getString("ehcacheplugin") mustBe Some("disabled")
    }
    "make the FakeApplication available implicitly" in {
      def getConfig(key: String)(implicit app: Application) = app.configuration.getString(key)
      getConfig("ehcacheplugin") mustBe Some("disabled")
    }
    "start the FakeApplication" in {
      Play.maybeApplication mustBe Some(app)
    }
    "provide the port number" in {
      port mustBe Helpers.testServerPort
    }
    "provide an actual running server" in {
      import java.net._
      val url = new URL("http://localhost:" + port + "/boum")
      val con = url.openConnection().asInstanceOf[HttpURLConnection]
      try con.getResponseCode mustBe 404
      finally con.disconnect()
    }
  }
}</pre></div><p>When we require <a id="id357" class="indexterm"/>multiple suites to use the same FakeApplication and TestServer, we can define tests using a nested suite similar to <code class="literal">NestedExampleSpec2.scala</code>.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">OneServerPerTest</code>: It starts a new <code class="literal">FakeApplication</code> and <code class="literal">TestServer</code> for each test defined in the suite. The application is exposed through the <code class="literal">newAppForTest</code> <a id="id358" class="indexterm"/>method and can be overridden if <a id="id359" class="indexterm"/>required. For example, consider <a id="id360" class="indexterm"/>the <code class="literal">DiffServerTest</code> test, where each test uses a different <code class="literal">FakeApplication</code> obtained through <code class="literal">newAppForTest</code> and the <code class="literal">TestServer</code> port is overridden:<div class="informalexample"><pre class="programlisting">class DiffServerTest extends PlaySpec with OneServerPerTest {

  private val colors = Seq("red", "blue", "yellow")

  private var code = 0

  override def newAppForTest(testData: TestData): FakeApplication = {
    val currentCode = code
    code += 1
    FakeApplication(additionalConfiguration = Map("foo" -&gt; "bar",
      "ehcacheplugin" -&gt; "disabled",
      "color" -&gt; colors(currentCode)
    ))
  }

  override lazy val port = 1234

  def getConfig(key: String)(implicit app: Application) = app.configuration.getString(key)

  "The OneServerPerTest trait" must {
    "provide a FakeApplication" in {
      app.configuration.getString("color") mustBe Some("red")
    }
    "make another FakeApplication available implicitly" in {
      getConfig("color") mustBe Some("blue")
    }
    "start server at specified port" in {
      port mustBe 1234
    }
  }
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OneBrowserPerSuite</code>: It provides a new Selenium WebDriver instance per suite. For example, assume that we wish to test the clicking of a button by opening the <a id="id361" class="indexterm"/>application in Firefox, the test can be <a id="id362" class="indexterm"/>written in the same way as <a id="id363" class="indexterm"/><code class="literal">ExampleSpec3.scala</code>:<div class="informalexample"><pre class="programlisting">@FirefoxBrowser
class ExampleSpec extends PlaySpec with OneServerPerSuite with OneBrowserPerSuite with FirefoxFactory {

  // Override app if you need a FakeApplication with other than non-default parameters.
  implicit override lazy val app: FakeApplication =
    FakeApplication(
      additionalConfiguration = Map("ehcacheplugin" -&gt; "disabled"),
      withRoutes = TestRoute
    )

  "The OneBrowserPerSuite trait" must {
    "provide a FakeApplication" in {
      app.configuration.getString("ehcacheplugin") mustBe Some("disabled")
    }
    "make the FakeApplication available implicitly" in {
      def getConfig(key: String)(implicit app: Application) = app.configuration.getString(key)
      getConfig("ehcacheplugin") mustBe Some("disabled")
    }
    "provide a web driver" in {
      go to ("http://localhost:" + port + "/testing")
      pageTitle mustBe "Test Page"
      click on find(name("b")).value
      eventually { pageTitle mustBe "scalatest" }
    }
  }
}</pre></div><p>We are assuming <code class="literal">TestRoute</code> is a partial function that maps to some of the routes, which can then be used in tests.</p><p>The same trait can be used to test the application within multiple browsers, as <a id="id364" class="indexterm"/>demonstrated in <code class="literal">MultiBrowserExampleSpec.scala</code>. To execute tests in all the browsers, we <a id="id365" class="indexterm"/>should use <code class="literal">AllBrowsersPerSuite</code>, as follows:</p><div class="informalexample"><pre class="programlisting">class AllBrowsersPerSuiteTest extends PlaySpec with OneServerPerSuite with AllBrowsersPerSuite {

  // Override newAppForTest if you need a FakeApplication with other than non-default parameters.
  override lazy val app: FakeApplication =
    FakeApplication(
      withRoutes = TestRoute
    )

  // Place tests you want run in different browsers in the `sharedTests` method:
  def sharedTests(browser: BrowserInfo) = {

      "navigate to testing "+browser.name in {
        go to ("http://localhost:" + port + "/testing")
        pageTitle mustBe "Test Page"
        click on find(name("b")).value
        eventually { pageTitle mustBe "testing" }
      }

      "navigate to hello in a new window"+browser.name in {
        go to ("http://localhost:" + port + "/hello")
        pageTitle mustBe "Hello"
        click on find(name("b")).value
        eventually { pageTitle mustBe "helloUser" }
      }
  }

  // Place tests you want run just once outside the `sharedTests` method
  // in the constructor, the usual place for tests in a `PlaySpec`

  "The test" must {
    "start the FakeApplication" in {
      Play.maybeApplication mustBe Some(app)
    }
  }</pre></div><p>The trait <code class="literal">OneBrowserPerSuite</code> can also be used with nested tests. Refer  to <code class="literal">NestedExampleSpec3.scala</code>.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">OneBrowserPerTest</code>: It starts a new browser session for each test in the suite. This can be <a id="id366" class="indexterm"/>noticed by running the <a id="id367" class="indexterm"/><code class="literal">ExampleSpec4.scala</code> test. It's similar to <code class="literal">ExampleSpec3.scala</code>, but <code class="literal">OneServerPerSuite</code> <a id="id368" class="indexterm"/>and <code class="literal">OneBrowserPerSuite</code> have been replaced with <code class="literal">OneServerPerTest</code> and <code class="literal">OneBrowserPerTest</code>, respectively, as shown here:<div class="informalexample"><pre class="programlisting">@FirefoxBrowser
class ExampleSpec extends PlaySpec with OneServerPerTest with OneBrowserPerTest with FirefoxFactory {
  ...
}</pre></div><p>We've also replaced the overridden app variable with the <code class="literal">newAppForTest</code> <a id="id369" class="indexterm"/>overridden method. Try writing a test that uses the <code class="literal">AllBrowsersPerTest</code> trait.</p></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>You can run into an InvalidActorNameException when running multiple functional tests simultaneously <a id="id370" class="indexterm"/>on an application, which defines custom actors. We can avoid this by defining a nested test where multiple tests use the same <code class="literal">FakeApplication</code>.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Summary</h1></div></div></div><p>In this chapter, we saw how a Play application can be tested using Specs2 or ScalaTest. We have also come across the different helper methods available to simplify testing a Play application. In the unit testing section, we discussed the different approaches that can be taken while designing models and controller based on the preferred testing process using traits with defined methods or dependency injection. We also discussed the functional testing of a Play application within the context of an application with a test server and within a browser using Selenium WebDrivers.</p><p>In the next chapter, we will discuss debugging and logging in to your Play application.</p></div></body></html>