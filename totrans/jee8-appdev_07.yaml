- en: WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, web applications have been developed using the request/response
    model followed by the HTTP protocol. In this traditional request/response model,
    the request is always initiated by the client, then the server sends a response
    back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: There has never been a way for the server to send data to the client independently,
    that is, without having to wait for a request, until now. The WebSocket protocol
    allows fully duplex, two-way communication between the client (browser) and the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE 7 introduced the Java API for WebSocket, which allows us to develop
    WebSocket endpoints in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing WebSocket server endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing WebSocket clients in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing WebSocket clients in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a WebSocket server endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways we can implement a WebSocket server endpoint via the Java
    API for WebSocket. We can either develop an endpoint programmatically, in which
    case we need to extend the `javax.websocket.Endpoint` class, or by decorating
    **Plain Old Java Objects** (**POJOs**) with WebSocket specific annotations. These
    two approaches are very similar, therefore, we will only be discussing the annotation
    approach in detail, and will briefly explain how to develop WebSocket server endpoints
    programmatically later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop a simple web-based chat application, taking
    full advantage of the Java API for WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an annotated WebSocket server endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following Java class illustrates how we can develop a WebSocket server
    endpoint by annotating a Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The class level `@ServerEndpoint` annotation indicates that the class is a WebSocket
    server endpoint. The **URI** (**Uniform Resource Identifier**) of the server endpoint
    is the value specified between the parenthesis following the annotation (`"/websocketchat"`,
    in this example). WebSocket clients will use this URI to communicate with our
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The `@OnOpen` annotation is used to decorate a method that needs to be executed
    whenever a WebSocket connection is opened from any of the clients. In our example,
    we are simply sending some output to the server log, but of course any valid server-side
    Java code can be placed here.
  prefs: []
  type: TYPE_NORMAL
- en: Any method annotated with the `@OnMessage` annotation will be invoked whenever
    our server endpoint receives a message from any of the clients. Since we are developing
    a chat application, our code simply broadcasts the message it receives to all
    connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the `processMessage()` method is annotated with `@OnMessage`,
    and it takes two parameters: an instance of a class implementing the `javax.websocket.Session`
    interface, and a `String` containing the message that was received. Since we are
    developing a chat application, our WebSocket server endpoint simply broadcasts
    the received message to all connected clients.'
  prefs: []
  type: TYPE_NORMAL
- en: The `getOpenSessions()` method of the `Session` interface returns a set of `Session`
    objects representing all open sessions. We iterate through this set to broadcast
    the received message back to all connected clients by invoking the `getBasicRemote()`
    method on each `Session` instance, then invoking the `sendText()` method on the
    resulting `RemoteEndpoint.Basic` implementation returned by this call.
  prefs: []
  type: TYPE_NORMAL
- en: The `getOpenSessions()` method on the `Session` interface returns all the open
    sessions at the time the method was invoked. It is possible for one or more of
    the sessions to have closed after the method was invoked, therefore, it is recommended
    to invoke the `isOpen()` method on a `Session` implementation before attempting
    to send data back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to decorate a method with the `@OnClose` annotation if we need
    to handle the event when a client disconnects from the server endpoint. In our
    example, we simply log a message to the server log.
  prefs: []
  type: TYPE_NORMAL
- en: There is one additional annotation that we didn't use in our example. The `@OnError`
    annotation is used to decorate a method that needs to be invoked in the event
    of an error in sending or receiving data to or from the client.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, developing an annotated WebSocket server endpoint is straightforward;
    we simply need to add a few annotations and the application server will invoke
    our annotated methods as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to develop a WebSocket server endpoint programmatically, we need
    to write a Java class that extends `javax.websocket.Endpoint`. This class has
    `onOpen()`, `onClose()`, and `onError()` methods, which are called at appropriate
    times during the endpoint's lifecycle. There is no method equivalent to the `@OnMessage`
    annotation to handle incoming messages from clients; the `addMessageHandler()`
    method needs to be invoked in the `Session`, passing an instance of a class implementing
    the `javax.websocket.MessageHandler` interface (or one of its subinterfaces) as
    its sole parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is easier and more straightforward to develop annotated WebSocket
    endpoints, as opposed to their programmatic counterparts, therefore, we recommend
    the annotated approach whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Developing WebSocket clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most WebSocket clients are implemented as web pages taking advantage of the
    JavaScript WebSocket API. We will cover how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Java API for WebSocket provides a client API that allows us to develop WebSocket
    clients as standalone Java applications. We will be covering this capability later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing JavaScript client-side WebSocket code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover how to develop client-side JavasScript code to
    interact with the WebSocket endpoint we developed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The client page for our WebSocket example is implemented as a JSF page using
    HTML5 friendly markup (as explained in [Chapter 2](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml),
    *JavaServer Faces*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our client page consists of a text area, where we can see what users of our
    application are saying (it is, after all, a chat application), and an input text
    we can use to send a message to other users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e0e17e7-5c52-416c-8398-0baee4327a32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The markup for our client page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The last line of our JavaScript code (`window.addEventListener("load", init);`)
    sets our JavaScript `init()` function to be executed as soon as the page loads.
  prefs: []
  type: TYPE_NORMAL
- en: In the `init()` function, we initialize a new JavaScript WebSocket object, passing
    the URI of our server endpoint as a parameter. This lets our JavaScript code know
    the location of our server endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript WebSocket object has a number of function types, used to handle
    different events, such as opening the connection, receiving a message, and handling
    errors. We need to set these types to our own JavaScript functions so that we
    can handle these events, which is what we do in our `init()` function, right after
    invoking the constructor for the JavaScript WebSocket object. In our example,
    the functions we assigned to the WebSocket object simply delegate their functionality
    to standalone JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: Our `websocketOpen()` function is called whenever the WebSocket connection is
    opened. In our example, we simply send a message to the browser's JavaScript console.
  prefs: []
  type: TYPE_NORMAL
- en: Our `webSocketMessage()` function is invoked whenever the browser receives a
    web socket message from our WebSocket endpoint. In our example, we update the
    contents of the text area with the ID `chatWindow` with the contents of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Our `websocketError()` function is called whenever there is a WebSocket related
    error. In our example, we simply send a message to the browser's JavaScript console.
  prefs: []
  type: TYPE_NORMAL
- en: Our JavaScript `sendMessage()` function sends a message to the WebSocket server
    endpoint, containing both the username and the contents of the text input with
    the ID `chatinput`. This function is called when the user clicks on the button
    with the ID `sendBtn`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `closeConnection()` JavaScript function closes the connection to our WebSocket
    server endpoint. This function is called when the user clicks on the button with
    the ID `exitBtn`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this example, writing client-side JavaScript code to interact
    with WebSocket endpoints is fairly straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Developing WebSocket clients in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although developing web-based WebSocket clients is currently the most common
    way of developing WebSocket clients, the Java API for WebSocket provides a client
    API we can use to develop WebSocket clients in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be developing a simple WebSocket client using the
    client API of the Java API for WebSocket. The final product looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6ded8e6-c2a0-4abb-bbc9-6ca41962c06a.png)'
  prefs: []
  type: TYPE_IMG
- en: However, we won't be covering the GUI code (developed using the Swing framework),
    since it is not relevant to the discussion. The complete code for the example,
    including the GUI code, can be downloaded from the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with WebSocket server endpoints, Java WebSocket clients can be developed
    either programmatically or by using annotations. Once again, we will cover only
    the annotation approach; developing a programmatic client is very similar to the
    way programmatic server endpoints are developed, which is to say, programmatic
    clients must extend `javax.websocket.Endpoint` and override the appropriate methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, here is the code for our Java WebSocket client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The class-level `@ClientEndPoint` annotation denotes our class as a WebSocket
    client; all Java WebSocket clients must be annotated with this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The code to establish a connection to the WebSocket server endpoint is in our
    class constructor. First, we need to invoke `ContainerProvider.getWebSocketContainer()`
    to obtain an instance of `javax.websocket.WebSocketContainer`. We then establish
    the connection by invoking the `connectToServer()` method on our `WebSocketContainer`
    instance, passing a class annotated with `@ClientEndpoint` as the first parameter
    (in our example, we use this because the connection code is inside our WebSocket
    Java client code), and a URI object containing the WebSocket server endpoint URI
    as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: After the connection is established, we are ready to respond to WebSocket events.
    Alert readers may have noticed that the exact same annotations we used to develop
    our server endpoint are used again in our client code.
  prefs: []
  type: TYPE_NORMAL
- en: Any method annotated with the `@OnOpen` annotation will be invoked automatically
    when the connection to the WebSocket server endpoint is established. The method
    must return void and can have an optional parameter of type `javax.websocket.Session`.
    In our example, we send some output to the console and initialize a class variable
    with the `Session` instance we received as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Methods annotated with the `@OnClose` annotation are invoked whenever the WebSocket
    session is closed. The annotated method can have an optional `javax.websocket.Session`
    parameter and an optional `CloseReason`parameter. In our example, we chose to
    use only the `CloseReason` optional parameter, since this class has a handy `getReasonPhrase()`
    method that provides a short explanation of why the session was closed.
  prefs: []
  type: TYPE_NORMAL
- en: The `@OnError` annotation is used to decorate any methods that will be called
    when an error occurs. Methods annotated with `@OnError` must have a `java.lang.Throwable`
    parameter (the parent class of `java.lang.Exception`), and can have an optional
    `type session` parameter. In our example, we simply send the stack trace of the
    `Throwable` parameter to `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods annotated with `@OnMessage` are invoked whenever an incoming WebSocket
    message is received. `@OnMessage` methods can have different parameters depending
    on the type of message received and how we wish to handle it. In our example,
    we used the most common case, receiving a text message. In this particular case,
    we need a `String` parameter, which will hold the contents of the message, and
    an optional `Session` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the JavaDoc documentation for `@OnMessage` at [http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html](https://javaee.github.io/javaee-spec/javadocs/javax/websocket/OnMessage.html)
    for information on how to handle other types of messages.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we simply update the Chat Window text area, appending the received
    message to its contents.
  prefs: []
  type: TYPE_NORMAL
- en: To send a WebSocket message, we invoke the `getBasicRemote()` method on our
    `Session` instance, then invoke the `sendText()` method on the resulting `R.emoteEndpoint`.
    A basic implementation is returned by this call (if this looks familiar, it is
    because we did the exact same thing in the WebSocket server endpoint code). In
    our example, we do this in the `sendMessage()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information about the Java API for WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the bulk of the functionality provided by the Java
    API for WebSocket. For additional information, refer to the user guide for Tyrus,
    the Java API for WebSocket reference implementation, at [https://tyrus.java.net/documentation/1.3.1/user-guide.html](https://tyrus.java.net/documentation/1.3.1/user-guide.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Java API for WebSocket, a Java EE API for developing
    WebSocket server endpoints and clients. We first saw how to develop WebSocket
    server endpoints by taking advantage of the Java API for WebSocket. Then, we covered
    how to develop web-based WebSocket clients using JavaScript. Finally, we explained
    how to develop WebSocket client applications in Java.
  prefs: []
  type: TYPE_NORMAL
