<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Serverless Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In recent years, the concept of microservices, which we've already looked at, has swept across the industry, quickly displacing the battle-tested application server with something smaller and leaner. Right on the heels of microservices comes a new concept--Functions as a Service, more commonly called <strong class="calibre8">serverless</strong>. In this chapter, you'll learn more about this new deployment model and build an application to demonstrate how to use it.</p>
<p class="mce-root">The application will be a simple notification system using the following technologies:</p>
<ul class="calibre13">
<li class="calibre14">Amazon Web Services
<ul class="calibre13">
<li class="calibre14">Amazon Lambda</li>
<li class="calibre14">Amazon <strong class="calibre3">Identity and Access Management</strong> (<strong class="calibre3">IAM</strong>)</li>
<li class="calibre14">Amazon <strong class="calibre3">Simple Notification System</strong> (<strong class="calibre3">SNS</strong>)</li>
<li class="calibre14">Amazon <strong class="calibre3">Simple Email System</strong> (<strong class="calibre3">SES</strong>)</li>
<li class="calibre14">Amazon DynamoDB</li>
</ul>
</li>
<li class="calibre14">JavaFX</li>
<li class="calibre14">The options offered by cloud providers can be quite vast, and Amazon Web Services is no exception. In this chapter, we will attempt to use just enough of what AWS has to offer to help us build a compelling application as we wade into cloud-native application development.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we get to our application, we should spend some time getting a better understanding of the term <strong class="calibre8">Function as a Service</strong> (<strong class="calibre8">FaaS</strong>). The term itself is a continuation of the <strong class="calibre8">blank</strong> as a service trend we've seen for a few years now. There is a host of such terms and offerings, but the big three are <strong class="calibre8">Infrastructure as a Service</strong> (<strong class="calibre8">IaaS</strong>), <strong class="calibre8">Platform as a Service</strong> (<strong class="calibre8">PaaS</strong>), and <strong class="calibre8">Software as a Service</strong> (<strong class="calibre8">SaaS</strong>). Oftentimes, these three build on each other as seen in the following diagram:</p>
<div class="mce-root1"><img class="image-border64" src="Images/7dafe91e-0a22-4aba-a7da-1d12003dd8f9.png" width="340" height="300"/></div>
<p class="mce-root">The lowest level of the cloud computing offerings, Infrastructure as a Service providers, offers infrastructure-related assets <strong class="calibre8">in the cloud</strong>. Typically, this can be as simple as file storage, but usually means virtual machines. By using an Infrastructure as a Service provider, clients need not worry about buying, maintaining, or replacing hardware, as that is handled by the provider. Clients are billed, instead, only on resources used.</p>
<p class="mce-root">Moving up the stack, Platform as a Service providers offer cloud-hosted application execution environments. This may include things such as an application server, a database server, a web server, and so on. The details of the physical environment are abstracted away, with customers specifying storage and RAM requirements. Some providers also allow the customer to choose the operating system, as this can have implications on the application stack, support tools, and more.</p>
<p class="mce-root">Software as a Service is a higher-level abstraction that doesn't focus on the hardware at all but, instead, offers hosted software that customers subscribe to, typically per user, and typically on a monthly or yearly basis. This is often seen in complicated business software, such as financial systems or human resource applications, but it is also seen with simpler systems, such as blogging software. The user simply subscribes and uses the software, leaving the installation and maintenance, including upgrades, to the provider. While this can reduce flexibility for the user (for example, it is often not possible to customize the software), it also reduces operational costs by pushing maintenance costs to the provider as well as guaranteeing, in most cases, access to the latest version of the software.</p>
<p class="mce-root">There are several other variations on this type of service, such as <strong class="calibre8">Mobile Backend as a Service</strong> (<strong class="calibre8">MBaas</strong>) and <strong class="calibre8">Database as a Service</strong> (<strong class="calibre8">DBaaS</strong>). As the market continues to gain confidence in cloud computing, and as the internet speeds up while the prices go down, we are likely to see more and more of these types of systems developed, which brings us to our topic in this chapter.</p>
<p class="mce-root">Function as a Service, or <strong class="calibre8">serverless</strong> computing, is the deployment of a small piece of code, very literally a function, that can be called from other applications, usually via some sort of trigger. Use cases include things such as image conversion, log analysis, and, as we will build in this chapter, notification systems.</p>
<p class="mce-root">Despite what the name <strong class="calibre8">serverless</strong> implies, there is actually a server involved, which only stands to reason; however, you, as an application developer, need not think about the server too deeply. In fact, as we'll see in this chapter, the only thing we need to worry about is how much memory our function will need. Everything else about the server is completely handled by the Function as a Service provider--the operating system, storage, networking, even starting and stopping the virtual machine are all handled for us by the provider.</p>
<p class="mce-root">With that basic understanding of serverless, we need to pick a provider. As can be expected, there are a number of options--Amazon, Oracle, IBM, Red Hat, and more. Unfortunately, currently, there is no standardized means by which we can write a serverless system and deploy it to an arbitrary provider, so that means our solution will be necessarily tied to a specific provider, which will be <strong class="calibre8">Amazon Web Services</strong> (<strong class="calibre8">AWS</strong>), the dominant provider of cloud computing services. As mentioned in the introduction to this chapter, we use a number of AWS offerings, but the centerpiece will be AWS Lambda, Amazon's serverless computing offering.</p>
<p class="mce-root">Let's jump in.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Planning the application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The application we will build is a very simple <strong class="calibre8">cloud notification</strong> service. In a nutshell, our function will <strong class="calibre8">listen</strong> for messages, then forward those messages to email addresses and phone numbers registered in the system. While our system will be somewhat contrived and certainly very simple, hopefully the more practical use cases are clear:</p>
<ul class="calibre13">
<li class="calibre14">Our system reminds students and/or parents about upcoming events</li>
<li class="calibre14">Parents are notified when children enter or leave certain geographic boundaries</li>
<li class="calibre14">Systems administrators are notified of certain events as they occur</li>
</ul>
<p class="mce-root">The possibilities are quite vast. For our purposes here, we'll develop not only the cloud-based system, but also a simple desktop application to simulate these types of scenarios. We'll start where the fun is: in the cloud.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building your first function</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The heart of Functions as a Service is, of course, the function. In Amazon Web Services, these are deployed using the service AWS Lambda. That's not the only AWS feature we'll use, as we've already mentioned. Once we have a function, we need a way to execute it. This is done via one or more triggers, and the function itself has tasks it needs to perform, so we'll demonstrate more service usage via API calls when we finally write the function.</p>
<p class="mce-root">It might be helpful at this point, given that our application is structured significantly differently than anything else we've looked at, to look at a system diagram:</p>
<div class="mce-root1"><img class="image-border65" src="Images/fabef02c-4c32-4279-88bb-dc6065892082.png"/></div>
<p class="mce-root">Here's the rough flow:</p>
<ul class="calibre13">
<li class="calibre14">A message is published to a topic in the Simple Notification System</li>
<li class="calibre14">Once the permissions of the caller have been verified, the message is delivered</li>
<li class="calibre14">Upon message delivery, a trigger is fired, delivering the message from the topic to our function</li>
<li class="calibre14">Inside the function, we'll query Amazon's <strong class="calibre3">DynamoDB</strong> to get the list of recipients that have signed up, providing either an email address, cell phone number, or both</li>
<li class="calibre14">All of the cell phone numbers will be sent a text message via <strong class="calibre3">Simple Notification System</strong></li>
<li class="calibre14">All the email addresses will be sent an email via <strong class="calibre3">Simple Email Service</strong></li>
</ul>
<p class="mce-root">To start building the function, we need to create a Java project. Like many of our other projects, this will be a multi-module Maven project. In NetBeans, click on <span class="calibre7">File</span> | <span class="calibre7">New Project</span> | <span class="calibre7">Maven</span> | <span class="calibre7">POM Project</span>. We'll call the <kbd class="calibre16">CloudNotice</kbd> project.</p>
<p class="mce-root">The project will have three modules--one for the function, one for a test/demo client, and one for a shared API. To create the function module, right-click on the <kbd class="calibre16">Modules</kbd> node in the project explorer and select <span class="calibre7">Create new module</span>. In the window, select <span class="calibre7">Maven</span> | <span class="calibre7">Java Application</span>, click on <span class="calibre7">Next</span>, and set the project name to <kbd class="calibre16">function</kbd>. Repeat those steps and create a module called <kbd class="calibre16">api</kbd>.</p>
<p class="mce-root">Before we go any further, we have to address the fact that, at the time of writing, AWS does not support Java 9. We must, therefore, target Java 8 (or earlier) for anything we will ship to Lambda. To do that, we need to modify our <kbd class="calibre16">pom.xml</kbd> file like this:</p>
<pre class="calibre21">    &lt;properties&gt; 
      &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; 
      &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; 
    &lt;/properties&gt; </pre>
<p class="mce-root">Modify the POM for both <kbd class="calibre16">api</kbd> and <kbd class="calibre16">function</kbd>. Hopefully, AWS will support Java 9 as quickly as possible after its release. Until then, we'll just have to target JDK 8.</p>
<p class="mce-root">With our project configured, we're ready to write our function. AWS Lambdas are implemented as <kbd class="calibre16">RequestHandler</kbd> instances:</p>
<pre class="calibre21">    public class SnsEventHandler  
      implements RequestHandler&lt;SNSEvent, Object&gt; { 
        @Override 
        public Object handleRequest 
         (SNSEvent request, Context context) { 
           LambdaLogger logger = context.getLogger(); 
           final String message = request.getRecords().get(0) 
            .getSNS().getMessage(); 
           logger.log("Handle message '" + message + "'"); 
           return null; 
    } </pre>
<p class="mce-root">Ultimately, we want our function to be triggered when a message is delivered to an SNS topic, so we specify <kbd class="calibre16">SNSEvent</kbd> as the input type. We also specify <kbd class="calibre16">Context</kbd>. There are several things we can get from the <kbd class="calibre16">Context</kbd>, such as the request ID, memory limit, and others, but all we're interested in is getting a <kbd class="calibre16">LambdaLogger</kbd> instance. We could just write to standard out and standard error, and those messages would be saved in Amazon CloudWatch, but <kbd class="calibre16">LambdaLogger</kbd> allows us to respect system permissions and the container configuration.</p>
<p class="mce-root">To make this compile, we need to add some dependencies to our application, so we add the following lines to <kbd class="calibre16">pom.xml</kbd>:</p>
<pre class="calibre21">    &lt;properties&gt; 
      &lt;aws.java.sdk.version&gt;[1.11, 2.0.0)&lt;/aws.java.sdk.version&gt; 
    &lt;/properties&gt; 
    &lt;dependencies&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; 
        &lt;artifactId&gt;aws-java-sdk-sns&lt;/artifactId&gt; 
        &lt;version&gt;${aws.java.sdk.version}&lt;/version&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; 
        &lt;artifactId&gt;aws-lambda-java-core&lt;/artifactId&gt; 
        &lt;version&gt;1.1.0&lt;/version&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; 
        &lt;artifactId&gt;aws-lambda-java-events&lt;/artifactId&gt; 
        &lt;version&gt;1.3.0&lt;/version&gt; 
      &lt;/dependency&gt; 
    &lt;/dependencies&gt; </pre>
<p class="mce-root">We can now start implementing the method as follows:</p>
<pre class="calibre21">    final List&lt;Recipient&gt; recipients =  new CloudNoticeDAO(false) 
      .getRecipients(); 
    final List&lt;String&gt; emailAddresses = recipients.stream() 
      .filter(r -&gt; "email".equalsIgnoreCase(r.getType())) 
      .map(r -&gt; r.getAddress()) 
      .collect(Collectors.toList()); 
    final List&lt;String&gt; phoneNumbers = recipients.stream() 
      .filter(r -&gt; "sms".equalsIgnoreCase(r.getType())) 
      .map(r -&gt; r.getAddress()) 
      .collect(Collectors.toList()); </pre>
<p class="mce-root">We have a couple of new classes to look at, but to recap this code first, we will get a list of <kbd class="calibre16">Recipient</kbd> instances, which represents the numbers and email addresses that have been subscribed to our service. We then create a stream from the list, filtering for each recipient type, <kbd class="calibre16">SMS</kbd> or <kbd class="calibre16">Email</kbd>, extracting the value via <kbd class="calibre16">map()</kbd>, then collecting them in a <kbd class="calibre16">List</kbd>.</p>
<p class="mce-root">We will get to <kbd class="calibre16">CloudNoticeDAO</kbd> and <kbd class="calibre16">Recipient</kbd> in a moment, but let's finish up with our function first. Once we have our lists, we can then send the messages as follows:</p>
<pre class="calibre21">    final SesClient sesClient = new SesClient(); 
    final SnsClient snsClient = new SnsClient(); 
 
    sesClient.sendEmails(emailAddresses, "j9bp@steeplesoft.com", 
     "Cloud Notification", message); 
    snsClient.sendTextMessages(phoneNumbers, message); 
    sesClient.shutdown(); 
    snsClient.shutdown(); </pre>
<p class="mce-root">We have encapsulated two more AWS APIs behind our own client classes, <kbd class="calibre16">SesClient</kbd> and <kbd class="calibre16">SnsClient</kbd>. This may seem a bit excessive, but these types of things tend to grow, and this approach puts us in a good position to manage that.</p>
<p class="mce-root">That leaves us with three APIs to look at: DynamoDB, Simple Email Service, and Simple Notification Service. We'll take them in order.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">DynamoDB</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Amazon DynamoDB is a NoSQL database, very much like MongoDB, which we looked at in <a href="0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 25</a>, <em class="calibre20">Taking Notes with Monumentum</em>, though DynamDB supports both document and key-value store models. A thorough comparison of the two, as well as a recommendation as to which to choose, is well outside the scope of our work here. We chose DynamoDB here, since it is already provisioned in the Amazon Web Service, and, thus, easily configured for our application.</p>
<p class="mce-root">To get started with the DynamoDB API, we need to add some dependencies to our application. In the <kbd class="calibre16">api</kbd> module, add this to the <kbd class="calibre16">pom.xml</kbd> file:</p>
<pre class="calibre21">    &lt;properties&gt; 
      &lt;sqlite4java.version&gt;1.0.392&lt;/sqlite4java.version&gt; 
    &lt;/properties&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; 
      &lt;artifactId&gt;aws-java-sdk-dynamodb&lt;/artifactId&gt; 
      &lt;version&gt;${aws.java.sdk.version}&lt;/version&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; 
      &lt;artifactId&gt;DynamoDBLocal&lt;/artifactId&gt; 
      &lt;version&gt;${aws.java.sdk.version}&lt;/version&gt; 
      &lt;optional&gt;true&lt;/optional&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;com.almworks.sqlite4java&lt;/groupId&gt; 
      &lt;artifactId&gt;sqlite4java&lt;/artifactId&gt; 
      &lt;version&gt;${sqlite4java.version}&lt;/version&gt; 
      &lt;optional&gt;true&lt;/optional&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">Before we start writing our DAO class, let's define our simple model. The DynamoDB API provides an object-relational mapping facility, much like the Java Persistence API or Hibernate, which will require a POJO and just a few annotations as we see here:</p>
<pre class="calibre21">    public class Recipient { 
      private String id; 
      private String type = "SMS"; 
      private String address = ""; 
 
      // Constructors... 
 
      @DynamoDBHashKey(attributeName = "_id") 
      public String getId() { 
        return id; 
      } 
     
      @DynamoDBAttribute(attributeName = "type") 
      public String getType() { 
        return type; 
      } 
 
      @DynamoDBAttribute(attributeName="address") 
      public String getAddress() { 
        return address; 
      } 
      // Setters omitted to save space 
    } </pre>
<p class="mce-root">In our POJO, we declared three properties, <kbd class="calibre16">id</kbd>, <kbd class="calibre16">type</kbd>, and <kbd class="calibre16">address</kbd>, then annotated the getters with <kbd class="calibre16">@DyanoDBAttribute</kbd> to help the library understand how to map the object.</p>
<div class="packt_infobox">Note that, while most of the property names match the field names in the table, you can override the property-to-field name mapping as we did with <kbd class="calibre39">id</kbd>.</div>
<p class="mce-root">Before we can do anything with our data, we need to declare our table. Remember that DynamoDB is a NoSQL database, and we will use it as a document store just as we did with MongoDB. However, before we can store any data, we have to define <strong class="calibre8">where</strong> to put it. In MongoDB, we would create a collection. DynamoDB, though, still refers to this as a table, and, while it is technically schemaless, we do need to define a primary key, which is made up of a partition key and an optional sort key.</p>
<p class="mce-root">We create the table through the console. Once you've logged on to the AWS DynamoDB console, you will click on the <span class="calibre7">Create Table</span> button, which will bring you to a screen like this:</p>
<div class="mce-root1"><img class="image-border66" src="Images/125e9135-0d20-42e4-8941-6c0a0e13ef46.png"/></div>
<p class="mce-root">We will name our table <kbd class="calibre16">recipients</kbd>, and specify <kbd class="calibre16">_id</kbd> as the partition key. Click on the <span class="calibre7">Create Table</span> button and give AWS time to create the table.</p>
<p class="mce-root">We are now ready to start writing our DAO. In the API module, create a class called <kbd class="calibre16">CloudNoticeDAO</kbd>, to which we'll add this constructor:</p>
<pre class="calibre21">    protected final AmazonDynamoDB ddb; 
    protected final DynamoDBMapper mapper; 
    public CloudNoticeDAO(boolean local) { 
      ddb = local ? DynamoDBEmbedded.create().amazonDynamoDB() 
       : AmazonDynamoDBClientBuilder.defaultClient(); 
      verifyTables(); 
      mapper = new DynamoDBMapper(ddb); 
    } </pre>
<p class="mce-root">The local property is used to determine whether or not to use a local DynamoDB instance. This is here to support testing (as is the call to <kbd class="calibre16">verifyTables</kbd>), which we will explore in a moment. In production, our code will call <kbd class="calibre16">AmazonDynamoDBClientBuilder.defaultClient()</kbd> to acquire an instance of <kbd class="calibre16">AmazonDynamoDB</kbd>, which talks to the Amazon-hosted instance. Finally, we create an instance of <kbd class="calibre16">DynamoDBMapper</kbd>, which we'll use for our object mapping.</p>
<p class="mce-root">To facilitate creating a new <kbd class="calibre16">Recipient</kbd>, we will add this method:</p>
<pre class="calibre21">    public void saveRecipient(Recipient recip) { 
      if (recip.getId() == null) { 
        recip.setId(UUID.randomUUID().toString()); 
      } 
      mapper.save(recip); 
    } </pre>
<p class="mce-root">This method will either create a new entry in the database, or update an existing one if the primary key already exists. In some scenarios, it might make sense to have separate save and update methods, but our use case is so simple that we don't need to worry about that. All we need to do is create the key value if it's missing. We do so by creating a random UUID, which helps us avoid key collisions should there be more than one process or application writing to the database.</p>
<p class="mce-root">Deleting a <kbd class="calibre16">Recipient</kbd> instance or getting a list of all of the <kbd class="calibre16">Recipient</kbd> instances in the database is just as simple:</p>
<pre class="calibre21">    public List&lt;Recipient&gt; getRecipients() { 
      return mapper.scan(Recipient.class,  
       new DynamoDBScanExpression()); 
    } 
 
    public void deleteRecipient(Recipient recip) { 
      mapper.delete(recip); 
    } </pre>
<p class="mce-root">Before we leave our DAO, let's take a quick look at how we can test it. Earlier, we noted the <kbd class="calibre16">local</kbd> parameter and the <kbd class="calibre16">verifyTables()</kbd> method, which exist for testing.</p>
<div class="packt_tip">Generally speaking, most people will frown, and rightfully so, on adding methods to production classes just for testing. There's a difference between writing a class that is testable, and adding test methods to a class. I would agree that adding methods to a class just for testing is something that should be avoided, but I am violating that principle a little here for the sake of simplicity and brevity.</div>
<p class="mce-root">The <kbd class="calibre16">verifyTables()</kbd> method checks to see if the table exists; if the table doesn't, we call another method that will create it for us. While we manually created the production table using the preceding console, we could also let this method create that table for us. What approach you use is completely up to you. Be aware that there will be performance and permissions issues that will need to be addressed. That said, that method looks something like this:</p>
<pre class="calibre21">    private void verifyTables() { 
      try { 
        ddb.describeTable(TABLE_NAME); 
      } catch (ResourceNotFoundException rnfe) { 
          createRecipientTable(); 
      } 
    } 
 
    private void createRecipientTable() { 
      CreateTableRequest request = new CreateTableRequest() 
       .withTableName(TABLE_NAME) 
       .withAttributeDefinitions( 
         new AttributeDefinition("_id", ScalarAttributeType.S)) 
       .withKeySchema( 
         new KeySchemaElement("_id", KeyType.HASH)) 
       .withProvisionedThroughput(new  
         ProvisionedThroughput(10L, 10L)); 
 
      ddb.createTable(request); 
      try { 
        TableUtils.waitUntilActive(ddb, TABLE_NAME); 
      } catch (InterruptedException  e) { 
        throw new RuntimeException(e); 
      } 
    } </pre>
<p class="mce-root">With the call to the <kbd class="calibre16">describeTable()</kbd> method, we can check to see if the table exists. In our test, this will fail every time, which will cause the table to be created. In production, should you use this method to create the table, this call will fail only on the first invocation. In <kbd class="calibre16">createRecipientTable()</kbd>, we can see how a table is created programmatically. We also wait until the table is active to make sure our reads and writes won't fail while the table is being created.</p>
<p class="mce-root">Our tests, then, are very simple. For example, consider the following code snippet:</p>
<pre class="calibre21">    private final CloudNoticeDAO dao = new CloudNoticeDAO(true); 
    @Test 
    public void addRecipient() { 
      Recipient recip = new Recipient("SMS", "test@example.com"); 
      dao.saveRecipient(recip); 
      List&lt;Recipient&gt; recipients = dao.getRecipients(); 
      Assert.assertEquals(1, recipients.size()); 
    } </pre>
<p class="mce-root">This test helps us verify that our model mapping is correct, and that our DAO methods function as expected. You can see additional testing in the <kbd class="calibre16">CloudNoticeDaoTest</kbd> class, in the source bundle.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Simple Email Service</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To send emails, we will use the Amazon Simple Email Service, or SES, which we will wrap in the <kbd class="calibre16">SesClient</kbd> class in the <kbd class="calibre16">api</kbd> module.</p>
<div class="packt_tip"><strong class="calibre3">IMPORTANT</strong>: Before you can send an email, you have to verify either your sending/from address or domain. The verification process is fairly simple, but how to do that is probably best left to Amazon's documentation, which you can read here: <a href="http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1"><span class="calibre5">http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html</span></a>.</div>
<p class="mce-root">The Simple Email Service API is quite simple. We need to create a <kbd class="calibre16">Destination</kbd>, which tells the system to whom to send the emails; a <kbd class="calibre16">Message</kbd> that describes the message itself, including subject, body, and recipients; and a <kbd class="calibre16">SendEmailRequest</kbd> that ties everything together:</p>
<pre class="calibre21">    private final AmazonSimpleEmailService client =  
      AmazonSimpleEmailServiceClientBuilder.defaultClient(); 
    public void sendEmails(List&lt;String&gt; emailAddresses, 
      String from, 
      String subject, 
      String emailBody) { 
        Message message = new Message() 
         .withSubject(new Content().withData(subject)) 
         .withBody(new Body().withText( 
           new Content().withData(emailBody))); 
        <strong class="calibre3">getChunkedEmailList(emailAddresses)</strong> 
         .forEach(group -&gt; 
           client.sendEmail(new SendEmailRequest() 
            .withSource(from) 
            .withDestination( 
              new Destination().withBccAddresses(group)) 
               .withMessage(message))); 
        shutdown(); 
    } 
 
    public void shutdown() { 
      client.shutdown(); 
    } </pre>
<p class="mce-root">There is an important caveat though, which is in the preceding bolded code. SES limits the number of recipients per message to 50, so we need to take our list of email addresses and process them 50 at a time. We will do that using the <kbd class="calibre16">getChunkedEmailList()</kbd> method:</p>
<pre class="calibre21">    private List&lt;List&lt;String&gt;&gt; getChunkedEmailList( 
      List&lt;String&gt; emailAddresses) { 
        final int numGroups = (int) Math.round(emailAddresses.size() / 
         (MAX_GROUP_SIZE * 1.0) + 0.5); 
        return IntStream.range(0, numGroups) 
          .mapToObj(group -&gt;  
            emailAddresses.subList(MAX_GROUP_SIZE * group, 
            Math.min(MAX_GROUP_SIZE * group + MAX_GROUP_SIZE, 
            emailAddresses.size()))) 
             .collect(Collectors.toList()); 
    } </pre>
<p class="mce-root">To find the number of groups, we divide the number of addresses by 50 and round up (for example, 254 addresses would get us 6 groups--5 of 50 and 1 of 4). Then, using an <kbd class="calibre16">IntStream</kbd> to count from 0 to the number of groups (exclusive), we extract sublists from the original list. Each of these lists is then collected into yet another <kbd class="calibre16">List</kbd>, giving us the nested <kbd class="calibre16">Collection</kbd> instances we see in the method signature.</p>
<div class="packt_tip"><strong class="calibre3">Design note</strong>: Many developers will avoid using nested <kbd class="calibre39">Collection</kbd> instances like this, as it can quickly become difficult to understand what exactly the variable represents. It is considered by many to be a best practice in situations like this to create a new type to hold the nested data. For example, if we were to follow that advice here, we could create, perhaps, a new <kbd class="calibre39">Group</kbd> class that had a <kbd class="calibre39">List&lt;String&gt;</kbd> property to hold the group's email addresses. We have not done so for the sake of brevity, but that would definitely be a good enhancement to this code.</div>
<p class="mce-root">Once we've <strong class="calibre8">chunked</strong> our list, we can send the same <kbd class="calibre16">Message</kbd> to each group, and thus fulfill the API contract.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Simple Notification Service</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We've already seen the Simple Notification System at work, at least in theory, as that is what delivers the outbound message to our function: a client of some sort publishes a message in a specific SNS topic. We have a subscription to that topic (I'll show you how to create that later) that calls our method with the message for us to deliver. We will use the SNS API now to send text (or SMS) messages to the users who have subscribed a phone number to the system.</p>
<p class="mce-root">With SNS, to send a message to more than one phone number you must do so through a topic to which each number is subscribed. What we'll do then is follow these steps:</p>
<ol class="calibre18">
<li class="chapter">Create a topic.</li>
<li class="chapter">Subscribe all of the phone numbers.</li>
<li class="chapter">Publish the message to the topic.</li>
<li class="chapter">Delete the topic.</li>
</ol>
<p class="mce-root">If we use a persistent topic, we will likely get unpredictable results if we have more than one instance of the function running simultaneously. The method that orchestrates all of this work looks like this:</p>
<pre class="calibre21">    public void sendTextMessages(List&lt;String&gt; phoneNumbers,  
      String message) { 
        String arn = createTopic(UUID.randomUUID().toString()); 
        phoneNumbers.forEach(phoneNumber -&gt;  
          subscribeToTopic(arn, "sms", phoneNumber)); 
        sendMessage(arn, message); 
        deleteTopic(arn); 
    } </pre>
<p class="mce-root">To create a topic, we have the following method:</p>
<pre class="calibre21">    private String createTopic(String arn) { 
      return snsClient.createTopic( 
        new CreateTopicRequest(arn)).getTopicArn(); 
    } </pre>
<p class="mce-root">To subscribe the numbers to the topic, we have this method:</p>
<pre class="calibre21">    private SubscribeResult subscribeToTopic(String arn, 
      String protocol, String endpoint) { 
        return snsClient.subscribe( 
          new SubscribeRequest(arn, protocol, endpoint)); 
    } </pre>
<p class="mce-root">Publishing a message is equally simple, as we see here:</p>
<pre class="calibre21">    public void sendMessage(String topic, String message) { 
      snsClient.publish(topic, message); 
    } </pre>
<p class="mce-root">And finally, you can delete the topic with this simple method:</p>
<pre class="calibre21">    private DeleteTopicResult deleteTopic(String arn) { 
      return snsClient.deleteTopic(arn); 
    } </pre>
<p class="mce-root">All of these methods are clearly very simple, so the calls to the SNS API could be made directly inline in the calling code, but this wrapper does provide us with a way to hide the details of the API from our business code. This is more important, for example, in <kbd class="calibre16">createTopic()</kbd>, where extra classes are needed, but, to be consistent, we'll encapsulate everything behind our own facade.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deploying the function</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We have now completed our function and we're almost ready to deploy it. To do that, we need to package it. AWS allows us to upload either a ZIP or a JAR file. We'll use the latter. However, we have some external dependencies, so we'll use the <strong class="calibre8">Maven Shade</strong> plugin to build a fat jar with our function and all of its dependencies. In the <kbd class="calibre16">function</kbd> module, add the following piece of code to the <kbd class="calibre16">pom.xml</kbd> file:</p>
<pre class="calibre21">    &lt;plugin&gt; 
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 
      &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; 
      &lt;version&gt;3.0.0&lt;/version&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
            &lt;phase&gt;package&lt;/phase&gt; 
            &lt;goals&gt; 
                &lt;goal&gt;shade&lt;/goal&gt; 
            &lt;/goals&gt; 
            &lt;configuration&gt; 
                &lt;finalName&gt; 
                    cloudnotice-function-${project.version} 
                &lt;/finalName&gt; 
            &lt;/configuration&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt; </pre>
<p class="mce-root">Now, when we build the project, we'll get a large file (about 9MB) in the target directory. It is this file that we will upload.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating a role</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we can upload the function, we need to prepare our AWS environment by creating the appropriate role. Log on to AWS and navigate to the <span class="calibre7">Identity and Access Management Console</span> (<a href="https://console.aws.amazon.com/iam" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://console.aws.amazon.com/iam</span></a>). In the navigation pane on the left, click on <span class="calibre7">Roles</span>, then click on <span class="calibre7">Create new role</span>:</p>
<div class="mce-root1"><img class="image-border67" src="Images/e5630954-edea-4a15-a810-c91f79bb900e.png"/></div>
<p class="mce-root">When prompted to select a role, we want to select AWS Lambda. On the next page, we will attach the policies:</p>
<div class="mce-root1"><img class="image-border68" src="Images/9f50368b-364c-473c-8427-beddb0ba370e.png"/></div>
<p class="mce-root">Click on <span class="calibre7">Next</span>, set the name to <kbd class="calibre16">j9bp</kbd>, and click on <span class="calibre7">Create role</span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating a topic</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To make creating the function and the associated trigger simpler, we will create our topic first. Navigate to the SNS console. Given that not all AWS functionality is always available in every region, we need to choose a specific region. We can do that in the upper-left corner of the web page. If the region does not say N. Virginia, select it--<span class="calibre7">US East (N. Virginia)</span>--from the drop-down menu before continuing.</p>
<p class="mce-root">Once the region is set correctly, click on <span class="calibre7">Topics</span> in the left navigation bar, then click on <span class="calibre7">Create new topic</span> and specify the name as <kbd class="calibre16">cloud-notice</kbd>:</p>
<div class="mce-root1"><img class="image-border69" src="Images/65ae9024-d65d-4a49-842d-c7bced165265.png"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deploying the function</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We can now navigate to the Lambda console and deploy our function. We will start by clicking on the <span class="calibre7">Create a lambda</span> function button. We'll be asked to select a blueprint. The only option suitable for a Java-based function is <span class="calibre7">Blank Function</span>. Once we click on that option, we are presented with the <span class="calibre7">Configure Triggers</span> screen. When you click on the empty square, you will be presented with a drop-down menu, as seen in this screenshot from the AWS console:</p>
<div class="mce-root1"><img class="image-border70" src="Images/e85d040d-260a-419d-9981-d51fa4541eba.png"/></div>
<p class="mce-root">You can either scroll down to find <span class="calibre7">SNS</span>, or enter <kbd class="calibre16">SNS</kbd> in the filter box as in the preceding screenshot. Either way, when you click on <span class="calibre7">SNS</span> in the list, you will be asked to select the topic to which you want to subscribe:</p>
<div class="mce-root1"><img class="image-border71" src="Images/961a6d80-9ecf-49cf-a606-3fff8103ee53.png"/></div>
<p class="mce-root">Click on <span class="calibre7">Next</span>. We now need to specify the details of our function:</p>
<div class="mce-root1"><img class="image-border72" src="Images/38ae6c28-8a7b-4fca-8faf-7425e87a128b.png"/></div>
<p class="mce-root">Scrolling down the page, we also need to specify the Lambda function handler and role. The <span class="calibre7">Handler</span> is the fully-qualified class name, followed by two colons, and the method name:</p>
<div class="mce-root1"><img class="image-border73" src="Images/39f51cb5-e805-421a-a9be-17fed0b46cde.png"/></div>
<p class="mce-root">We now need to select the function archive by clicking on the upload button and selecting the jar file created by our Maven build. Click on <span class="calibre7">Next</span>, verify the details of the function, and then click on <span class="calibre7">Create function</span>.</p>
<p class="mce-root">We now have a usable AWS Lambda function. We can test it using the Lambda Console, but instead we'll build a small JavaFX application to do that, which will simultaneously test all of the service integrations, as well as demonstrate how a production application would interact with the function.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Testing the function</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To help test and demonstrate the system, we'll create a new module, called <kbd class="calibre16">manager</kbd>, in the <kbd class="calibre16">CloudNotice</kbd> project. To do that, click on the <span class="calibre7">modules</span> node in the NetBeans project explorer, then click on <span class="calibre7">Create New Module...</span> | <span class="calibre7">Maven</span> | <span class="calibre7">JavaFX Application</span>. Call the project <kbd class="calibre16">Manager</kbd> and click on <span class="calibre7">Finish</span>.</p>
<div class="packt_tip">I have renamed <kbd class="calibre39">MainApp</kbd> to <kbd class="calibre39">CloudNoticeManager</kbd>, <kbd class="calibre39">FXMLController</kbd> to <kbd class="calibre39">CloudNoticeManagerController</kbd>, and <kbd class="calibre39">Scene.fxml</kbd> to <kbd class="calibre39">manager.fxml</kbd>.</div>
<p class="mce-root">Our <kbd class="calibre16">Application</kbd> class will look a little different than in previous JavaFX applications. Some of the AWS client APIs require that they be shut down explicitly when you are finished with them. Failure to do so means that our application won't fully quit, leaving behind <strong class="calibre8">zombie</strong> processes that must be killed. To make sure we properly shut down our AWS clients, we need to add a cleanup method to our controller, which we'll call from the <kbd class="calibre16">stop()</kbd> method in our application:</p>
<pre class="calibre21">    private FXMLLoader fxmlLoader; 
    @Override 
    public void start(final Stage stage) throws Exception { 
      fxmlLoader = new FXMLLoader(getClass() 
       .getResource("/fxml/manager.fxml")); 
      Parent root = fxmlLoader.load(); 
      // ... 
    } 
 
    @Override 
    public void stop() throws Exception { 
      CloudNoticeManagerController controller =  
        (CloudNoticeManagerController) fxmlLoader.getController(); 
      controller.cleanup(); 
      super.stop();  
    } </pre>
<p class="mce-root">Now, regardless of whether the user clicks on <span class="calibre7">File</span> | <span class="calibre7">Exit</span> or clicks on the <span class="calibre7">Close</span> button on the window, our AWS clients can be cleaned up correctly.</p>
<p class="mce-root">In terms of layout, there's nothing new to discuss, so we'll not dwell on that aspect here. This is what our manager app will look like:</p>
<div class="mce-root1"><img class="image-border74" src="Images/32338e18-d903-4abe-956b-1475793a3c80.png" width="826" height="385"/></div>
<p class="mce-root">We have a list of the subscribed recipients on the left, an area for adding and editing a recipient at the top right, and an area for sending a test message at the bottom right. We do have some interesting bindings, so let's take a look at this.</p>
<p class="mce-root">First, in <kbd class="calibre16">CloudNoticeManagerController</kbd>, we need to declare some containers for our data, so we declare a number of <kbd class="calibre16">ObservableList</kbd> instances:</p>
<pre class="calibre21">    private final ObservableList&lt;Recipient&gt; recips =  
      FXCollections.observableArrayList(); 
    private final ObservableList&lt;String&gt; types =  
      FXCollections.observableArrayList("SMS", "Email"); 
    private final ObservableList&lt;String&gt; topics =  
      FXCollections.observableArrayList(); </pre>
<p class="mce-root">These three <kbd class="calibre16">ObservableList</kbd> instances will back the UI controls matching their names. We will populate two of those lists (<kbd class="calibre16">type</kbd> is hardcoded) in <kbd class="calibre16">initalize()</kbd> as follows:</p>
<pre class="calibre21">    public void initialize(URL url, ResourceBundle rb) { 
      recips.setAll(dao.getRecipients()); 
      topics.setAll(sns.getTopics()); 
 
      type.setItems(types); 
      recipList.setItems(recips); 
      topicCombo.setItems(topics); </pre>
<p class="mce-root">Using our DAO and SES client, we fetch any already subscribed recipients, as well as any topics configured in the account. This will get <em class="calibre20">every</em> topic, so if you have a lot, this may be a problem, but this is just a demonstration application, so that should be fine here. Once we have these two lists, we add them to the <kbd class="calibre16">ObservableList</kbd> instances we created earlier, then associate the <kbd class="calibre16">List</kbd> with the appropriate UI controls.</p>
<p class="mce-root">To make sure the <kbd class="calibre16">Recipient</kbd> list displays correctly, we need to create a <kbd class="calibre16">CellFactory</kbd> as follows:</p>
<pre class="calibre21">    recipList.setCellFactory(p -&gt; new ListCell&lt;Recipient&gt;() { 
      @Override 
      public void updateItem(Recipient recip, boolean empty) { 
        super.updateItem(recip, empty); 
        if (!empty) { 
          setText(String.format("%s - %s", recip.getType(),  
            recip.getAddress())); 
          } else { 
              setText(null); 
          } 
        } 
    }); </pre>
<p class="mce-root">Remember that, if the cell is empty, we need to set the text to null to clear out any previous value. Failure to do that will result, at some point, in a <kbd class="calibre16">ListView</kbd> with <strong class="calibre8">phantom</strong> entries.</p>
<p class="mce-root">Next, we need to update the edit controls when the user clicks on a <kbd class="calibre16">Recipient</kbd> in the list. We do this by adding a listener to the <kbd class="calibre16">selectedItemProperty</kbd>, which is run every time the selected item changes:</p>
<pre class="calibre21">    recipList.getSelectionModel().selectedItemProperty() 
            .addListener((obs, oldRecipient, newRecipient) -&gt; { 
        type.valueProperty().setValue(newRecipient != null ?  
            newRecipient.getType() : ""); 
        address.setText(newRecipient != null ?  
            newRecipient.getAddress() : ""); 
    }); </pre>
<p class="mce-root">If <kbd class="calibre16">newRecipient</kbd> is not null, we set the value of the controls to the appropriate value. Otherwise, we clear the values.</p>
<p class="mce-root">We now need to add handlers for the various buttons--the <span class="calibre7">Add</span> and <span class="calibre7">Remove</span> buttons above the <kbd class="calibre16">Recipient</kbd> list, and the <kbd class="calibre16">Save</kbd> and <kbd class="calibre16">Cancel</kbd> buttons in the two <strong class="calibre8">form</strong> areas on the right.</p>
<p class="mce-root">The UI control's <kbd class="calibre16">onAction</kbd> property can be bound to the method in the class by editing the FXML directly, as shown here:</p>
<pre class="calibre21">    &lt;Button mnemonicParsing="false"  
      onAction="#addRecipient" text="+" /&gt; 
    &lt;Button mnemonicParsing="false"  
      onAction="#removeRecipient" text="-" /&gt; </pre>
<p class="mce-root">It can also be bound to the method by editing the property in Scene Builder, as shown in the following screenshot:</p>
<div class="mce-root1"><img class="image-border75" src="Images/2d472bcc-4ee9-44d6-b382-e29fc81abe6d.png" width="1149" height="468"/></div>
<p class="mce-root">Either way, the method will look like this:</p>
<pre class="calibre21">    @FXML 
    public void addRecipient(ActionEvent event) { 
      final Recipient recipient = new Recipient(); 
      recips.add(recipient); 
      recipList.getSelectionModel().select(recipient); 
      type.requestFocus(); 
    } </pre>
<p class="mce-root">We're adding a <kbd class="calibre16">Recipient</kbd>, so we create a new one, add it to our <kbd class="calibre16">ObservableList</kbd>, then tell the <kbd class="calibre16">ListView</kbd> to select this entry. Finally, we ask the <kbd class="calibre16">type</kbd> control to request focus so the user can easily change the value with the keyboard, if so desired. The new Recipient isn't saved to DynamoDB until the user clicks on Save, which we will look at in a moment.</p>
<p class="mce-root">When we delete a <kbd class="calibre16">Recipient</kbd>, we need to remove it from the UI as well as from DynamoDB:</p>
<pre class="calibre21">    @FXML 
    public void removeRecipient(ActionEvent event) { 
      final Recipient recipient = recipList.getSelectionModel() 
       .getSelectedItem(); 
      dao.deleteRecipient(recipient); 
      recips.remove(recipient); 
    } </pre>
<p class="mce-root">Saving is a bit more complicated, but not much:</p>
<pre class="calibre21">    @FXML 
    public void saveChanges(ActionEvent event) { 
      final Recipient recipient =  
        recipList.getSelectionModel().getSelectedItem(); 
      recipient.setType(type.getValue()); 
      recipient.setAddress(address.getText()); 
      dao.saveRecipient(recipient); 
      recipList.refresh(); 
    } </pre>
<p class="mce-root">Since we're not binding the values of the edit controls to the selected item in the list, we need to get the reference to the item, then copy the values from the controls to the model. Once that's done, we save it to the database via our DAO, then ask <kbd class="calibre16">ListView</kbd> to refresh itself so that any model changes are reflected in the list.</p>
<div class="packt_tip">We aren't binding the controls to the item in the list as that leads to a slightly confusing user experience. If we did bind, as the user made changes to the model <kbd class="calibre39">ListView</kbd> would reflect those changes. It is conceivable that the user would then assume that the changes are being saved to the database when, in fact, they are not. That doesn't happen until the user clicks on <span class="calibre5">Save</span>. To avoid this confusion, and the loss of data, we have <em class="calibre22">not</em> bound the controls and manage the data manually.</div>
<p class="mce-root">To cancel the change, all we need to do is get a reference to the unchanged model from <kbd class="calibre16">ListView</kbd>, and copy its values over those in the edit controls:</p>
<pre class="calibre21">    @FXML 
    public void cancelChanges(ActionEvent event) { 
      final Recipient recipient = recipList.getSelectionModel() 
        .getSelectedItem(); 
      type.setValue(recipient.getType()); 
      address.setText(recipient.getAddress()); 
    } </pre>
<p class="mce-root">That leaves us with the <strong class="calibre8">send a message</strong> section of the UI. Thanks to our SNS wrapper API, these methods are very simple:</p>
<pre class="calibre21">    @FXML 
    public void sendMessage(ActionEvent event) { 
      sns.sendMessage(topicCombo.getSelectionModel() 
        .getSelectedItem(), messageText.getText()); 
      messageText.clear(); 
    } 
 
    @FXML 
    public void cancelMessage(ActionEvent event) { 
      messageText.clear(); 
    } </pre>
<p class="mce-root">From our desktop application, we can now add, edit, and remove recipients, as well as send test messages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Configuring your AWS credentials</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Those paying very close attention may be asking a very important question--How do the AWS client libraries know how to log on to our account? Clearly, we need to tell them, and we have a few options.</p>
<p class="mce-root">The AWS SDK, when run locally, will check three places for the credentials--environment variables (<kbd class="calibre16">AWS_ACCESS_KEY_ID</kbd> and <kbd class="calibre16">AWS_SECRET_ACCESS_KEY</kbd>), system properties (<kbd class="calibre16">aws.accessKeyId</kbd> and <kbd class="calibre16">aws.secretKey</kbd>), and the default credentials profiles file (<kbd class="calibre16">$HOME/.aws/credentials</kbd>). What credentials you use is up to you, but I will show you here how to configure the profiles file.</p>
<p class="mce-root">Just like a Unix or Windows system, your AWS account has a <kbd class="calibre16">root</kbd> user that has complete access to your system. It would be extremely imprudent to run any client code connected as this user. To avoid that, we need to create a user, which we can do on the <span class="calibre7">Identity and Access Management</span> console (<a href="https://console.aws.amazon.com/iam" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://console.aws.amazon.com/iam</span></a>).</p>
<p class="mce-root">Once you've logged on, click on <span class="calibre7">Users</span> on the left, then <span class="calibre7">Add user</span> at the top, the result of which is shown in the following screenshot:</p>
<div class="mce-root1"><img class="image-border76" src="Images/c16ba08c-f738-4383-aa4d-76a98f2eb58f.png" width="975" height="827"/></div>
<p class="mce-root">Click on <span class="calibre7">Next: Permissions</span> and check the entry in the <span class="calibre7">Group</span> list for our role, <kbd class="calibre16">j9bp</kbd>. Click on <span class="calibre7">Next: Review</span>, then <span class="calibre7">Create User</span>. This will take you to the <span class="calibre7">Add user</span> screen, which should have a success message box. The important part is the user information listed toward the bottom of the screen. On the right side of this table, you should see the columns <span class="calibre7">Access key ID</span> and <span class="calibre7">Secret access key</span>. Click on <span class="calibre7">Show</span> on the access key to reveal the value. Make a note of both of these, as there is no way to retrieve the access key once you leave this page. If you lose it, you will have to generate a new set of keys, which will break any other application using the old credentials.</p>
<div class="mce-root1"><img class="image-border77" src="Images/e2754894-8149-4c86-b987-6e010b3f5909.png"/></div>
<p class="mce-root">In a text editor, we need to create the <kbd class="calibre16">~/.aws/credentials</kbd> file. On a Unix system, that may be <kbd class="calibre16">/home/jdlee/.aws</kbd>, and on a Windows machine that will be something like <kbd class="calibre16">C:Usersjdleeaws</kbd>. The credentials file should look something like this:</p>
<pre class="calibre21">    [default] 
    aws_access_key_id = AKIAISQVOILE6KCNQ7EQ 
    aws_secret_access_key = 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 </pre>
<p class="mce-root">In the same directory, we need to create another file called <kbd class="calibre16">config</kbd>. We'll use this file to tell the SDK which region we want to work in:</p>
<pre class="calibre21">    [default] 
    region = us-east-1 </pre>
<p class="mce-root">When the AWS clients start up now, they will default to connecting as the <kbd class="calibre16">j9bp</kbd> user in the <kbd class="calibre16">us-east-1</kbd> region. Should you need to override that, you can either edit this file or set the environment variables or system properties noted above in the section, <em class="calibre20">Configuring your AWS Credentials</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We've done it! We've created, many of us, our very first AWS Lambda function, and it really wasn't all that difficult. It is a simple application, of course, but I hope you can see how this type of application could be very useful. Using this as a starting point, you can write systems, with the help of a mobile application, to help keep track of your family's location. Using embedded devices such as Raspberry PI, for example, you can build devices to track inventory as it is shipped across the country, reporting location, speed, environmental conditions, sudden drops or impacts, and so on. A piece of software running on a server could constantly report various metrics about the system, such as CPU temperature, free disk space, memory allocated, system load, and so on. Your options are limited only by your imagination.</p>
<p class="mce-root">To wrap up, let's take a quick look back at what we've learned. We learned about some of the various <strong class="calibre8">... as a service</strong> systems that are being offered today, and what <strong class="calibre8">serverless</strong> really means and why it may appeal to us as application developers. We learned how to configure various Amazon Web Services offerings, including Identity and Access Management, Simple Notification System, Simple Email Service, and, of course Lambda, and we learned how to write an AWS Lambda function in Java and how to deploy it to the service. And finally, we learned how to configure triggers that would tie an SNS publish/subscribe topic to our Lambda function.</p>
<p class="mce-root">There's no denying that our application is somewhat simple, and there's no way in the space of a single chapter to make you an expert in all that Amazon Web Services or any other cloud provider has to offer. Hopefully, you have enough to get you going--and get you excited--about writing cloud-based applications using Java. For those wanting to go deeper, there are a number of great books, web pages, and so on to help you delve deeper into this rapidly changing and expanding area. In our next chapter, we'll return from the cloud and turn our attention to another great space for Java developers--your mobile phone.</p>


            </article>

            
        </section>
    </div>



  </body></html>