- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Garbage Collection and Memory Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the intricate dance of **Java Virtual Machine** (**JVM**) internals, where
    bytecode is compiled and programs are executed within the confines of register
    memory, an indispensable aspect emerges the artful orchestration of memory resources.
    After traversing the realms of bytecode compilation and program execution, it
    is paramount to delve into the nuanced domain of memory management within the
    JVM. This chapter embarks on a comprehensive exploration of **garbage collectors**
    (**GCs**), unraveling the intricate tapestry governing Java programs’ sustenance.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey through the inner workings of the JVM reaches a crucial juncture
    as we unravel the mysteries of memory allocation, heap structures, and the ever-pivotal
    garbage collection mechanisms. By comprehending the nuances of memory management,
    including distinctions between heap and stack, and mastering the intricacies of
    garbage collection, you will enhance your understanding of JVM internals and acquire
    the skills to wield precise control over memory usage. Join us as we navigate
    the intricate terrain of GCs, unlocking the keys to optimizing memory efficiency
    in Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: GC overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM tuning and ergonomics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GC overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the intricate landscape of JVM internals, the GC role stands as a critical
    component, influencing the efficiency and reliability of Java applications. Our
    exploration delves into the fundamental concept of garbage collection and its
    pivotal role in managing memory within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, the purpose of the GC is to automatically reclaim memory occupied
    by objects no longer in use by the program. In languages such as Java, which employ
    automatic memory management, developers are spared the burden of explicitly deallocating
    memory, enhancing productivity and reducing the likelihood of memory-related errors.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where each dynamically allocated object had to be manually
    deallocated by the programmer. Not only does this introduce a considerable cognitive
    load, but it also opens the door to memory leaks and inefficiencies. In the absence
    of a GC, the responsibility of memory management falls entirely on the developer’s
    shoulders, increasing the likelihood of bugs and hindering the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Java, with its *Write Once, Run Anywhere* philosophy, utilizes garbage collection
    to provide a seamless and robust memory management system. The JVM’s GC identifies
    and reclaims unreachable objects, preventing memory leaks and ensuring optimal
    resource utilization. The Java approach allows developers to focus on application
    logic rather than micromanaging memory, contributing to the language’s popularity
    in enterprise-level applications.
  prefs: []
  type: TYPE_NORMAL
- en: While Java champions automatic memory management through its GC, other programming
    languages have embraced various memory management strategies. For instance, languages
    such as C and C++ frequently depend on manual memory management, granting developers
    explicit control but also leaving them susceptible to potential pitfalls. Conversely,
    languages such as Python and C# implement their own garbage collection mechanisms,
    each meticulously crafted to address the unique requirements of their respective
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Even among languages with garbage collection, the implementations can differ
    significantly. Java’s GC is known for its generational approach, dividing the
    heap into different generations (young and old) and applying different collection
    algorithms to each. Within the JVM itself, multiple GCs exist, each with its strategies
    and trade-offs. This contrasts with, for instance, Python’s reference counting
    mechanism or the GCs used in languages such as Go or C#.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leaks often result from programming errors, such as failing to release
    dynamically allocated memory or inadvertently maintaining references to objects
    beyond their useful lifespan. Common scenarios include neglecting to free memory
    in languages that require manual memory management, such as C or C++, or unintentionally
    creating circular references in languages with automatic memory management, such
    as Java.
  prefs: []
  type: TYPE_NORMAL
- en: The GC plays a pivotal role in mitigating the risk of memory leaks in languages
    that employ automatic memory management. Its primary function is to identify and
    reclaim memory occupied by objects no longer reachable or in use by the program.
    By automating the memory deallocation process, the GC significantly reduces the
    likelihood of memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In automatic memory management, the GC acts as a vigilant defender, crucially
    mitigating the risk of memory leaks. Automating the identification and reclamation
    of unused memory in languages such as Java streamlines the development process
    and enhances system stability. With a generational approach that swiftly handles
    short-lived objects and smart memory management adapting to dynamic applications,
    the GC stands as a pivotal chapter in fortifying software integrity against the
    subtle menace of memory leaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated memory management**: In languages such as Java, where automatic
    memory management is integral, the GC regularly scans the heap to identify objects
    with no reachable references. Once identified, these unreferenced objects are
    marked for collection and deallocated, freeing up memory for new allocations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generational approach**: Java’s GC often employs a generational approach,
    categorizing objects into different generations based on their age. Younger objects,
    which are more likely to become unreachable quickly, are collected more frequently,
    while older objects undergo less frequent, more comprehensive garbage collection.
    It helps quickly identify and collect short-lived objects, reducing the chances
    of memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart memory management**: Modern GCs are designed to be intelligent and
    adaptive. They utilize algorithms and heuristics to optimize memory management
    based on the application’s behavior. This adaptability ensures efficient garbage
    collection and minimizes the risk of memory leaks, even in complex and dynamic
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the intricate tapestry of JVM internals, the *Mark and Sweep* GC algorithm
    emerges as a cornerstone in managing memory efficiently. This fundamental process
    operates in two key phases: the mark phase, where the GC discerns the utilization
    status of memory, marking objects as either reachable or unreachable, and the
    subsequent sweep phase, where the collector liberates the heap by reclaiming memory
    occupied by objects marked as unreachable. The advantages of this approach are
    profound, offering automatic memory management, mitigating dangling pointer issues,
    and significantly contributing to memory leak management, as the following diagram
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Mark and Sweep steps of the GC](img/B22030_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Mark and Sweep steps of the GC'
  prefs: []
  type: TYPE_NORMAL
- en: As we delve into the nuances of Mark and Sweep, we navigate the benefits and
    challenges inherent in this automatic memory management paradigm. While it liberates
    developers from the intricacies of manual memory handling, it introduces considerations
    such as increased CPU power consumption and relinquishing control over object
    cleanup scheduling. Join us on this exploration into the heart of JVM internals,
    where the Mark and Sweep algorithm plays a pivotal role in shaping the reliability
    and efficiency of Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our exploration, we’ve uncovered the automatic process of Mark and Sweep:
    its ability to effortlessly handle memory allocation and deallocation, its role
    in mitigating dangling pointers, and its significant contribution to managing
    memory leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: However, no architectural marvel comes without its trade-offs. In the case of
    Mark and Sweep, a prominent consideration emerges in the form of memory fragmentation.
    As we unravel this aspect, we delve into the intricacies of how the algorithm,
    while adept at reclaiming memory, can leave behind fragmented pockets in the memory
    space. These fragments, akin to scattered puzzle pieces, introduce challenges
    to the efficient allocation of contiguous memory blocks, impacting the overall
    efficiency of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Our narrative thus far has illuminated the delicate balancing act between the
    advantages of automatic memory management and the potential drawbacks, emphasizing
    the need for a nuanced approach. The trade-off between seamless automation and
    the specter of fragmentation prompts developers to weigh the benefits against
    the efficiency requirements of their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Within the intricate realm of JVM internals, the choice of GC can profoundly
    impact the performance of Java applications. **Serial GC**, a simple and single-threaded
    collector, suits applications with modest memory requirements, offering a straightforward
    approach to garbage collection. Conversely, **Parallel GC** steps up for throughput-centric
    scenarios, leveraging multiple threads to expedite garbage collection tasks and
    enhance overall system efficiency. Java’s default collector since version 9, **Garbage-First
    (G1) GC**, strikes a balance between low latency and high throughput, making it
    a versatile choice for various applications. Introducing a new paradigm, the **Z
    GC** (**ZGC**) in Java 11 promises minimal pause times and enhanced scalability,
    catering to the demands of modern, resource-intensive applications. As we embark
    on a journey through the intricacies of each collector, a nuanced understanding
    will empower developers to make informed decisions, optimizing garbage collection
    strategies to align with the specific needs of their Java projects.
  prefs: []
  type: TYPE_NORMAL
- en: Serial GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within the tapestry of JVM internals, Serial GC is a fundamental player in garbage
    collection strategies. We will dissect the essence of Serial GC, a collector distinguished
    by its simplicity and singular-threaded approach to memory management. As we delve
    into the intricacies of its operation, we explore why such a straightforward design
    is essential and the scenarios in which Serial GC shines. Unveiling its advantages
    and limitations, we navigate the landscape to understand the optimal scenarios
    where this minimalist collector becomes a strategic choice for Java developers.
    We will explore Serial GC, where the pursuit of simplicity intertwines with efficiency
    in the orchestration of memory within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Serial GC is characterized by its sequential, **stop-the-world** approach to
    garbage collection. It halts the application’s execution during the collection
    process, ensuring that no parallel threads interfere with identifying and reclaiming
    unreachable objects. This simplicity allows Serial GC to streamline memory management
    without the complexity of concurrent operations.
  prefs: []
  type: TYPE_NORMAL
- en: The elegance of Serial GC comes with trade-offs, notably in the realm of throughput
    and responsiveness. Given its single-threaded nature, there may be more efficient
    choices for applications with large heaps or those requiring low pause times.
    Stop-the-world pauses, while brief, can impact the user experience, making Serial
    GC better suited for scenarios where these pauses are acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serial GC seamlessly integrates with the Mark and Sweep algorithm. It identifies
    reachable and unreachable objects during the mark phase, marking them accordingly.
    In the subsequent sweep phase, it clears memory occupied by unreachable objects.
    The sequential nature of Serial GC ensures a straightforward execution of these
    phases, simplifying the coordination between marking and sweeping, as the following
    diagram shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Serial GC working](img/B22030_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Serial GC working'
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of Serial GC shines in scenarios where the memory footprint is
    modest and the application’s performance is not overly sensitive to brief pauses.
    It is well suited for client applications or environments with limited resources,
    where the straightforward, stop-the-world approach aligns seamlessly with the
    system’s demands.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we immerse ourselves in the orchestration of memory within the JVM, a crucial
    aspect unfolds through the configuration options tailored for Serial GC. The following
    table presents a harmonious ensemble of commands, each holding the power to influence
    and optimize the behavior of Serial GC. From enabling or disabling the use of
    Serial GC to fine-tuning ratios, sizes, and thresholds, these commands offer a
    conductor’s wand to shape the memory management symphony. Join us in deciphering
    the significance of each command, providing developers and administrators with
    the means to sculpt an optimal performance for their Java applications by adjusting
    the parameters that govern the workings of Serial GC:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:+UseSerialGC` | Enables the use of Serial GC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:-UseSerialGC` | Disables Serial GC (default for server-class machines).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:NewRatio=<value>` | Sets the ratio of the young generation to the
    old generation. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:NewSize=<size>` | Sets the initial size of the young generation. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:MaxNewSize=<size>` | Sets the maximum size of the young generation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:SurvivorRatio=<value>` | Sets the ratio of Eden space to survivor
    space. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:MaxTenuringThreshold=<value>` | Sets the maximum tenuring threshold
    for objects in the young generation. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:TargetSurvivorRatio=<value>` | Sets the desired survivor space size
    as a percentage of the young generation size. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:PretenureSizeThreshold=<size>` | Sets the threshold for object allocation
    in the old generation. Objects larger than this size go directly to the old generation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:MaxHeapSize=<size>` | Sets the maximum heap size. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Serial GC commands'
  prefs: []
  type: TYPE_NORMAL
- en: These options allow developers and administrators to configure aspects of Serial
    GC, such as the size of the young generation, the ratio of survivor spaces, and
    overall heap size. Adjusting these parameters enables fine-tuning of memory management
    for specific application requirements and hardware characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: The harmonious coordination of memory management orchestrated by Serial GC has
    illuminated its advantages, trade-offs, and strategic scenarios in which its singular
    approach excels. As we transition to our next section, the stage is set for a
    parallel performance as we delve into Parallel GC. The evolution from singular
    to parallel threads promises an exploration of efficiency at scale and enhanced
    throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we embark on the next movement in our exploration of JVM internals, the spotlight
    now shifts to Parallel GC. In this section, we dive into the world of parallelism,
    where the efficiency of memory management takes center stage. Parallel GC, with
    its multithreaded prowess, orchestrates a symphony of garbage collection, promising
    enhanced throughput and optimized performance for Java applications. Through a
    nuanced lens, we unravel the complexities of Parallel GC—its characteristics,
    advantages, and scenarios where its parallel threads harmonize seamlessly with
    the demands of large-scale, data-intensive environments. Join us in this section
    as we traverse the parallel rhythms of JVM internals, uncovering parallel threads
    that propel memory management to new heights.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel GC’s hallmark lies in its multithreaded approach, making it particularly
    adept at handling more enormous heaps and achieving higher throughput compared
    to its single-threaded counterparts. It divides the heap into sections, employing
    parallel threads to perform garbage collection tasks concurrently, resulting in
    faster execution and reduced pause times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel GC orchestrates a synchronized dance of efficiency within the JVM,
    seamlessly integrating with the Mark and Sweep algorithm. In the intricate garbage
    collection process, Parallel GC leverages the power of multiple threads to execute
    the crucial steps of marking and sweeping concurrently. During the mark phase,
    each thread traverses a designated heap section, identifying and marking objects
    as reachable or unreachable. This simultaneous marking across threads ensures
    a swift and parallel assessment of the memory space. As the mark phase concludes,
    the collective effort of threads harmonizes in the sweep phase, where Parallel
    GC efficiently reclaims memory by discarding unreachable objects identified during
    marking. The parallelism embedded in the Mark and Sweep process under Parallel
    GC optimizes throughput. It showcases the synchronized brilliance of multiple
    threads working in unison to choreograph a performance that elegantly balances
    responsiveness and efficiency in memory management, as the following diagram shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Parallel GC working](img/B22030_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Parallel GC working'
  prefs: []
  type: TYPE_NORMAL
- en: While Parallel GC excels in throughput, its reliance on parallelism introduces
    trade-offs, notably in responsiveness. Stop-the-world pauses, while minimized,
    can still impact the application’s responsiveness, making it less suitable for
    scenarios where low latency is paramount. Additionally, the increased CPU usage
    due to parallelism might be a consideration for resource-constrained environments.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel GC shines brightest in scenarios where large heaps and data-intensive
    applications are the norm. It is well suited for batch processing, scientific
    computing, and scenarios where maximizing throughput is crucial. However, its
    trade-offs make it a strategic choice for applications that can tolerate brief
    pauses in exchange for optimized overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: As we unravel the intricacies of Parallel GC, we explore how its parallel threads
    choreograph a performance that balances the demands of large-scale memory management.
    Join us in this section as we navigate the landscape of parallel garbage collection,
    understanding when its parallel prowess becomes a strategic choice for optimizing
    memory orchestration within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our exploration of Parallel GC within the intricacies of JVM internals,
    the ability to finely tune its behavior becomes paramount. The following table
    offers a comprehensive ensemble of commands, each a key to unlocking the potential
    of Parallel GC’s efficiency and throughput. From turning its use on or off to
    configuring the number of threads, setting pause-time goals, and employing adaptive
    sizing policies, these options empower developers and administrators to shape
    the orchestration of memory management within the JVM. As we delve into the nuances
    of each command, this ensemble becomes a conductor’s guide, enabling the crafting
    of a performance optimized to meet the unique demands of Java applications. Join
    us in deciphering the significance of these commands, providing a symphony of
    possibilities for molding Parallel GC to harmonize seamlessly with the diverse
    landscapes of JVM environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:+UseParallelGC` | Enables the use of Parallel GC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:-UseParallelGC` | Disables Parallel GC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ParallelGCThreads=<value>` | Sets the number of threads for garbage
    collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:MaxGCPauseMillis=<value>` | Sets the maximum desired pause-time goal
    for garbage collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:GCTimeRatio=<value>` | Sets the target ratio of garbage collection
    time to application time. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:UseAdaptiveSizePolicy` | Enables adaptive sizing policies for heap
    and survivor spaces. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:AdaptiveSizeThroughPutPolicy` | Configures the adaptive sizing policy
    for throughput-oriented garbage collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:AdaptiveSizePolicyOutputInterval=<n>` | Sets the interval, in the
    number of collections, for adaptive sizing policy output. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ParallelGCVerbose` | Enables verbose output from Parallel GC. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: Parallel GC commands'
  prefs: []
  type: TYPE_NORMAL
- en: These options provide a means to configure and fine-tune the behavior of Parallel
    GC, allowing developers and administrators to optimize garbage collection for
    specific application requirements and hardware characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude our exploration into the Parallel GC world, we find ourselves
    enriched with insights into the parallel threads that orchestrate a harmonious
    performance within the JVM. The multithreaded efficiency of Parallel GC, showcased
    through its configuration options, provides a powerful toolkit for developers
    and administrators seeking to optimize memory management in diverse JVM environments.
    Our journey through the parallel rhythms has set the stage for the next act—G1
    GC. Join us in the upcoming section as we delve into the nuances of G1, unraveling
    its characteristics, advantages, and intricacies that position it as a pivotal
    player in the symphony of garbage collection strategies within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: G1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we continue our exploration of JVM internals, our spotlight now turns to
    G1 GC. Positioned as a modern successor to its predecessors, G1 introduces a paradigm
    shift in garbage collection strategies. In this section, we delve into the intricacies
    of G1, unraveling its characteristics, operational nuances, and the innovative
    approaches it brings to the forefront of memory management. G1’s meticulous focus
    on achieving low latency, predictable pause times, and efficient heap utilization
    marks it as a key player in the symphony of garbage collection within the JVM.
    Join us in this section as we explore the evolution of garbage collection strategies,
    dissect the principles that underpin G1, and unveil the symphonic efficiency it
    brings to the dynamic landscape of JVM internals.
  prefs: []
  type: TYPE_NORMAL
- en: G1 GC is designed to address the challenges posed by traditional garbage collection
    strategies. It introduces a region-based approach, dividing the Java heap into
    smaller, uniformly sized regions. This departure from the monolithic heap structure
    allows G1 to manage memory more flexibly and precisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'G1 divides the heap into regions and categorizes them into three main types:
    Eden, survivor, and old. The size and configuration of these regions are dynamic,
    allowing G1 to adapt to the memory needs of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of the liveness space is central to G1’s efficiency. The liveness
    space comprises regions with live objects—objects still actively referenced by
    the application. G1 identifies and prioritizes regions with the least live data
    for garbage collection. This strategic approach optimizes the collection process
    by targeting areas where reclaimable memory is most concentrated, reducing both
    the frequency and duration of garbage collection pauses, as the following diagram
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: G1 process and liveness space working](img/B22030_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: G1 process and liveness space working'
  prefs: []
  type: TYPE_NORMAL
- en: G1’s primary goal is to achieve low latency and predictable pause times. By
    prioritizing regions with the least live data, G1 minimizes the impact on application
    responsiveness. It makes G1 particularly well suited for scenarios where maintaining
    consistent and low pause times is critical, such as in interactive and real-time
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: G1 employs adaptive collection strategies to adjust its approach based on the
    application’s dynamic behavior. It can dynamically resize regions, alter the garbage
    collection frequency, and adapt its overall strategy to align with the evolving
    demands of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, G1 GC’s utilization of liveness spaces, along with its region-based
    approach, positions it as a sophisticated and efficient solution for memory management
    in modern Java applications. The focus on predictability and adaptability makes
    G1 valuable in the landscape of garbage collection strategies within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our journey through the orchestration of memory within the JVM, the following
    table unfolds as a conductor’s guide to G1\. Each command within this ensemble
    provides a key to unlocking the precision and efficiency that G1 brings to garbage
    collection. From turning G1 on or off to fine-tuning parameters such as heap region
    size, pause-time goals, and adaptive strategies, these options empower developers
    and administrators to sculpt the symphony of memory management within the JVM.
    As we delve into the significance of each command, we navigate the intricacies
    that define G1’s performance, crafting a balance between predictability and adaptability.
    Join us in deciphering this symphony of configurations, where each note resonates
    with the nuanced precision that G1 introduces to the dynamic landscape of JVM
    internals:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:+UseG1GC` | Enables the use of G1 GC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:-UseG1GC` | Disables G1 GC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:G1HeapRegionSize=<value>` | Sets the size of G1 garbage collection
    regions. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:MaxGCPauseMillis=<value>` | Sets the maximum desired pause-time goal
    for G1 garbage collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:InitiatingHeapOccupancyPercent=<value>` | Sets the percentage of heap
    occupancy to start a G1 garbage collection cycle. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:G1NewSizePercent=<value>` | Sets the percentage of heap size to use
    as the minimum for the young generation in G1. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:G1MaxNewSizePercent=<value>` | Sets the maximum percentage of heap
    size to use as the maximum for the young generation in G1. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ParallelGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for G1. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ConcGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for the concurrent phase in G1. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:G1ReservePercent=<value>` | Sets the target percentage of heap to
    reserve as space for future garbage collection cycles. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:G1TargetSurvivorOccupancy=<value>` | Sets the target occupancy of
    survivor space within each G1 region. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:G1HeapWastePercent=<value>` | Sets the target percentage of wasted
    space within a G1 region before a region is considered for reclamation. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.3: G1 commands'
  prefs: []
  type: TYPE_NORMAL
- en: These options provide a means to configure and fine-tune the behavior of G1
    GC, allowing developers and administrators to optimize garbage collection for
    specific application requirements and hardware characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: On our exploration into the intricacies of G1 GC, we stand enriched with insights
    into the precision and adaptability that define its symphony of memory management
    within the JVM. The meticulous configuration options presented in our ensemble
    guide offer a conductor’s wand, shaping G1’s performance to align seamlessly with
    the diverse demands of Java applications. As we set our sights on the next section,
    the stage is set for a crescendo as we unravel the innovative nuances of ZGC.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our continued exploration of JVM internals, our focus shifts to the forefront
    of innovation by introducing ZGC. Positioned as a game-changer in garbage collection
    strategies, ZGC emerges as a beacon of efficiency and low-latency performance.
    This section serves as our gateway into the world of ZGC, unraveling its cutting-edge
    features, adaptive techniques, and commitment to minimizing pause times. With
    the pursuit of responsiveness at its core, ZGC redefines the dynamics of garbage
    collection, offering a solution tailored for modern, dynamic applications. Join
    us in this section as we delve into the revolutionary advancements that ZGC brings
    to the JVM, marking a pivotal milestone in the evolution of garbage collection
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC stands at the forefront of modern garbage collection strategies, introducing
    groundbreaking features that redefine the dynamics of memory management within
    the JVM. At its core, ZGC prioritizes low latency and responsiveness, aiming to
    minimize pause times for applications with stringent performance requirements.
    One of ZGC’s key innovations is its concurrent approach to garbage collection.
    Unlike traditional collectors that halt the application during certain phases,
    ZGC performs major garbage collection tasks concurrently with the application
    threads, ensuring that pause times are kept to a minimum. This concurrent model
    is particularly advantageous for applications where responsiveness is critical,
    such as in real-time systems, interactive applications, or services where downtime
    must be minimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In computer memory, multi-mapping refers to a technique in which specific addresses
    in the virtual memory space point to the same ones in physical memory. It means
    that multiple virtual addresses correspond to the same physical location. Applications
    interact with data through virtual memory, and they remain oblivious to the underlying
    multi-mapping mechanism. This abstraction is crucial for the applications, allowing
    them to access data without being aware of the complexities involved in mapping
    virtual to physical memory, as the following diagram shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: ZGC process mapping](img/B22030_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: ZGC process mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic memory allocation, a common practice in programming, contributes to
    memory fragmentation over time. When objects are allocated and deallocated, free
    space gaps can emerge in the memory layout. Over time, these gaps accumulate,
    leading to **fragmentation**, wherein the memory resembles a chessboard with alternating
    areas of free and used space. To address this, there are two main strategies.
  prefs: []
  type: TYPE_NORMAL
- en: One approach involves scanning the memory for free space large enough to accommodate
    the desired object. This method, while feasible, is resource-intensive, especially
    if performed frequently. Additionally, it does not entirely eliminate fragmentation,
    as finding an exact match for the required space size can be challenging, leaving
    gaps between objects.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative strategy is to periodically relocate objects from fragmented
    memory areas to free spacein a more compact format. It involves dividing the memory
    space into blocks and relocating entire blocks of objects simultaneously. By doing
    so, the allocation of memory becomes faster, as known empty blocks are available.
    This strategy helps manage memory fragmentation more efficiently, balancing the
    need for dynamic allocation and the desire for a more contiguous and organized
    memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs are inherent in any garbage collection strategy, and ZGC is no exception.
    While it excels in reducing pause times, it may not achieve the same throughput
    as collectors optimized for throughput at the expense of latency. Additionally,
    ZGC might not be optimal for applications with extremely large heaps, as its concurrent
    approach may introduce some overhead. However, for scenarios where low latency
    is paramount, and the application’s responsiveness takes precedence over maximum
    throughput, ZGC emerges as a powerful solution.
  prefs: []
  type: TYPE_NORMAL
- en: Another notable feature of ZGC is its ability to resize the heap dynamically.
    ZGC adapts the heap size to the application’s demand, allowing it to manage memory
    in response to changing workloads efficiently. This adaptability is particularly
    beneficial in environments where workloads vary, providing an agile and responsive
    memory management solution.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, ZGC represents a paradigm shift in garbage collection, offering
    a sophisticated solution for applications demanding low latency and responsiveness
    without compromising memory management efficiency. Its innovative features and
    concurrent design make it a compelling choice for modern Java applications operating
    in dynamic and resource-intensive scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dynamic realm of JVM internals, ZGC takes center stage as a cutting-edge
    solution, prioritizing low-latency performance and responsiveness. This table
    serves as a compass in navigating the configuration landscape of ZGC, providing
    developers and administrators with a curated set of commands to sculpt its behavior.
    From turning ZGC on or off to fine-tuning parameters such as pause times, thread
    counts, and memory uncommit policies, these options empower users to tailor ZGC
    to the specific demands of their Java applications. As we delve into the significance
    of each command, this guide becomes an essential resource for optimizing ZGC performance,
    ensuring a harmonious balance between efficiency and adaptability. Join us in
    unlocking the potential of ZGC, where each command becomes a note in the symphony
    of precision that defines the future of garbage collection strategies within the
    JVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:+UseZGC` | Enables the use of ZGC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:-UseZGC` | Disables ZGC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:MaxGCPauseMillis=<value>` | Sets the maximum desired pause time goal
    for ZGC garbage collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:GCPauseIntervalMillis=<value>` | Sets the maximum interval between
    ZGC pauses. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ConcGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for ZGC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ParallelGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for the parallel phase of ZGC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ConcGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for the concurrent phase of ZGC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ZUncommitDelay=<value>` | Sets the delay for uncommitting memory after
    a region is no longer needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ZUncommitDelayMax=<value>` | Sets the maximum delay for uncommitting
    memory after a region is no longer needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ZUncommitDelayPolicy=<adaptive\&#124;fixed>` | Sets the uncommit delay
    policy for ZGC. Options include **adaptive** and **fixed**. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:SoftMaxHeap=<value>` | Sets the soft maximum heap size for ZGC. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``XX:ZHeapSize=<value>` | Sets the ZGC heap size. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.4: ZGC commands'
  prefs: []
  type: TYPE_NORMAL
- en: These options provide a means to configure and fine-tune the behavior of ZGC,
    allowing developers and administrators to optimize garbage collection for specific
    application requirements and hardware characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: As we wrap up our exploration into the intricacies of ZGC, we find ourselves
    immersed in the world of precision performance and low-latency responsiveness.
    The table of ZGC commands presented here serves as a guide, unlocking the potential
    for users to fine-tune and optimize ZGC for their Java applications. This section
    has laid the foundation for understanding how ZGC reshapes the landscape of garbage
    collection strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey doesn’t end here but gracefully transitions into the next act—ergonomics
    and tuning. In the forthcoming chapters, we will delve into the art of optimizing
    Java applications, exploring strategies to fine-tune the performance of the JVM
    to meet the nuanced demands of diverse workloads. Join us as we navigate the realm
    of JVM tuning, where each adjustment becomes a brushstroke in the canvas of crafting
    optimal Java application performance.
  prefs: []
  type: TYPE_NORMAL
- en: JVM tuning and ergonomics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the dynamic landscape of Java application development, the twin pillars of
    ergonomics and profiling emerge as crucial elements in achieving optimal performance.
    This section marks our journey into fine-tuning Java applications, exploring the
    principles of ergonomics to adapt the JVM automatically to varying workloads.
    Simultaneously, we delve into profiling, a powerful tool for gaining insights
    into the runtime behavior of applications. As we navigate the nuances of optimizing
    Java performance, ergonomics and profiling become our guiding lights, offering
    strategies to sculpt applications for responsiveness and efficiency. Join us in
    this section as we uncover the synergy between adaptive tuning and insightful
    profiling, unlocking the potential to elevate Java applications to new levels
    of performance and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Ergonomics in the context of Java refers to the adaptive tuning capabilities
    embedded within the JVM to adjust its configuration automatically based on the
    characteristics of the underlying hardware and the application’s behavior. The
    primary goal of ergonomics is to enhance the performance and responsiveness of
    Java applications without requiring manual intervention from developers. By dynamically
    adjusting parameters such as garbage collection algorithms, heap sizes, and thread
    counts, ergonomics aims to strike an optimal balance for a given runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: However, the default configuration set by ergonomics is often considered a form
    of premature optimization. It is because the default settings are determined at
    JVM startup, relying on heuristics and assumptions about the environment. While
    these defaults may work reasonably well for a broad range of applications and
    hardware, they might not be the most efficient configuration for specific use
    cases. Premature optimization occurs when the JVM makes assumptions about application
    behavior without sufficient runtime information, potentially leading to suboptimal
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Ergonomics can choose between Serial GC and G1 based on the system’s capabilities.
    Serial GC is typically chosen as the default, especially for single-processor
    systems or when memory is limited. On the other hand, G1 may be selected when
    there are more than two processors and a sufficient amount of memory (1792 MB
    or more) available.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, ergonomics adjusts the default maximum heap size based on the available
    memory. The default maximum heap size can be set to 50%, 25%, or 1/64 of the available
    memory, providing flexibility to accommodate different application requirements
    and system constraints. In essence, ergonomics acts as an intelligent conductor,
    dynamically tailoring the JVM’s configuration to orchestrate a performance symphony
    that aligns with the unique characteristics of each runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: The recommendation to *always set the configuration of GC and avoid the ergonomic*
    stems from the idea that manually configuring GC parameters gives developers more
    control and predictability over the JVM’s behavior. While ergonomic settings are
    designed to adjust the JVM configuration based on heuristics and runtime characteristics,
    this automated approach may not always produce the most optimized performance
    for specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: When developers manually configure the GC, they can tailor the JVM settings
    according to the application’s unique requirements, workload characteristics,
    and the underlying infrastructure. This manual tuning allows more fine-grained
    control over parameters such as heap size, thread counts, and garbage collection
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding ergonomic settings becomes especially relevant when applications have
    specific performance goals, stringent latency requirements, or when the default
    configurations generated by the ergonomic tuning may not align with the application’s
    optimal needs. Manual tuning allows developers to experiment with, analyze, and
    adjust JVM parameters to achieve the desired performance outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s crucial to note that while manual tuning provides greater control,
    it also requires a deep understanding of the application’s behavior, garbage collection
    algorithms, and JVM internals. Developers must carefully assess the impact of
    their configurations and regularly monitor the application’s performance to ensure
    that the chosen settings align with evolving application demands.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the recommendation to manually set the configuration of the GC and
    avoid relying solely on ergonomic settings reflects a desire for more precise
    control over JVM behavior, particularly in scenarios where tailored performance
    optimization is crucial for the application’s success.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bruno Borges’ insightful *Secrets of Performance Tuning Java on Kubernetes*
    presentation, he shared invaluable recommendations for optimizing Java applications
    running on Kubernetes. Borges discussed the performance implications associated
    with different garbage collection algorithms, namely Serial, Parallel, G1, and
    Z, considering key factors such as the number of cores, multithreaded environments,
    Java heap size, pause times, overhead, and tail-latency effects. Each garbage
    collection strategy was dissected in the context of its suitability for specific
    scenarios. Whether an application benefits from the simplicity of Serial, the
    parallel processing of Parallel, the adaptability of G1, or the low-latency focus
    of Z, Borges provided nuanced insights into choosing the most effective garbage
    collection approach. The recommendations presented by Borges offer a comprehensive
    guide for Java developers navigating the complexities of performance tuning in
    Kubernetes environments, shedding light on the intricate dance between application
    demands and garbage collection strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Serial** | **Parallel** | **G1** | **Z** |'
  prefs: []
  type: TYPE_TB
- en: '| Number of cores | 1 | +2 | +2 | +2 |'
  prefs: []
  type: TYPE_TB
- en: '| Multithreaded | No | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Java heap size | > 4 GB | < 4 GB | > 4 GB | > 4 GB |'
  prefs: []
  type: TYPE_TB
- en: '| Pause | Yes | Yes | Yes | Yes (> 1 ms) |'
  prefs: []
  type: TYPE_TB
- en: '| Overhead | Minimal | Minimal | Moderate | Moderate |'
  prefs: []
  type: TYPE_TB
- en: '| Tail-latency effect | High | High | High | Low |'
  prefs: []
  type: TYPE_TB
- en: '| Best for | Single-core small heaps | Multi-core small heaps. Batch jobs,
    with any heap size. | Responsive in medium-to-large heaps (request-     response/DB interactions) | Responsive in medium-to-large heaps (request-     response |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.5: Comparing all GCs’ aspects'
  prefs: []
  type: TYPE_NORMAL
- en: In our exploration of JVM tuning, we’ve delved into the realms of ergonomics,
    profiling, and the delicate balance between automated adaptation and manual precision.
    Ergonomics dynamically tunes the JVM configuration for varying workloads, yet
    the recommendation emerges to configure the GC for greater control manually. A
    distilled summary awaits as we approach the conclusion, crystallizing the wisdom
    gained in navigating JVM tuning intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we draw the curtain on our exploration into the intricate GC world, we’ve
    navigated diverse strategies, nuances, and configurations that shape the memory
    management landscape within the JVM. From the adaptive finesse of ergonomics to
    the precision of Serial, Parallel, G1, and ZGC GCs, our journey has been a symphony
    of choices, each tuned to orchestrate optimal performance based on distinct application
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: However, our expedition through JVM internals doesn’t pause here. The next chapter
    awaits, inviting us into the avant-garde realm of GraalVM. Beyond the confines
    of traditional Java, GraalVM emerges as a revolutionary platform, blurring the
    boundaries between languages and unleashing new possibilities for performance,
    polyglot capabilities, and efficient execution. Join us in the forthcoming chapters
    as we delve into the paradigm-shifting landscape of GraalVM, where the symphony
    of languages converges in harmony, marking a dynamic evolution in the ever-evolving
    tapestry of JVM technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the primary goal of ergonomics in JVM tuning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minimizing code compilation time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically adjusting JVM configuration based on runtime characteristics
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximizing heap size for all applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Disabling garbage collection for enhanced performance
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which GC is often chosen by ergonomics as the default for single-processor systems
    or when memory is limited?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serial GC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parallel GC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: G1 GC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ZGC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the context of garbage collection, what does “multi-mapping” refer to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple mapping of virtual memory addresses to physical memory
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The use of multiple garbage collection algorithms simultaneously
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Multithreading during garbage collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocating memory in multiple regions simultaneously
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might developers prefer manual GC configuration over ergonomics?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual tuning is more cost-effective
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ergonomics is not compatible with modern JVM versions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Developers have better control over performance parameters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual configuration reduces the need for garbage collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which GC is known for its focus on low latency and responsiveness, making it
    suitable for real-time systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serial GC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parallel GC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: G1 GC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ZGC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: B. Automatically adjusting JVM configuration based on runtime characteristics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Serial GC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Multiple mapping of virtual memory addresses to physical memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C. Developers have better control over performance parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D. ZGC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
