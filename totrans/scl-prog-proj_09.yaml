- en: Interactive Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the actor model by extending our shopping
    project. The extension will consist of a notification, provided to anyone connected
    to the website, about who is adding/removing a product to/from the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, each time someone acts on the cart, a message will be broadcast to all
    of the connected browsers, and it will include the name of the user, the action
    (add or remove), and the product name.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow will be as follows. When someone is connected to the website, a
    web socket will be opened between the browser and the server; a reference to that
    web socket will be kept at the server level, inside of an Actor.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as an action is performed on the cart, a message with the username,
    action, and product name will be sent to the server through the web socket; the
    server will receive this message, transform it in to an alarm message, and broadcast
    it to all of the connected browsers. Each browser will then show the alarm as
    a notification. As soon as the browser disconnects (or the web socket timeout
    is reached), the web socket reference will be removed from the server.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, the term Actor was used in the preceding workflow.
    The theory of the actor model originated in 1973 ([https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask](https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask)), and
    multiple implementations have been created since, in many languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are going to use the Akka framework. It was written by Jonas
    Bonér in 2009 and is based on the Scala Actor implementation created by Philipp
    Haller. We will only scratch the surface of the framework by providing an introduction
    to it. This framework would require an entire book to explain all of its features
    and possible patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain how to communicate between the client and the
    server using a web socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Actor models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The objectives of this chapter are to establish asynchronous communication
    between the browser and the server using a web socket and to use Actors to handle
    the communication at the server level. You will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create asynchronous communication between the client and the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we define the term  Actor? In our first attempt, we considered explaining
    it technically, using a threading model, concurrency, call stacks, a mailbox,
    and so on. Then, we realized that a technical description doesn't reflect the
    essence of a solution based on Actors.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, every time we have to design a solution based on Actors, we can see
    the Actor as a human working in a company; this person has a name, and maybe an
    email address (**Actor reference**). The first important fact is that he is not
    alone; he is going to interact with others (**messaging**), receiving messages
    from his hierarchy and transmitting other messages to colleagues or subordinates
    (**supervisors**).
  prefs: []
  type: TYPE_NORMAL
- en: The imaginary company is structured using a hierarchy; a supervisor (**user
    guardian**) is looking at the health of its subordinate, and, when a problem is
    raised, if the supervisor can handle it, they will perform actions to fix it.
    If the error is unmanageable, the supervisor will escalate it to their own superior
    (**supervisor strategy**), and so on, until it reaches the director (**root guardian**).
  prefs: []
  type: TYPE_NORMAL
- en: Another similarity to communication between humans is that when you ask a colleague
    to do something and they do not answer. After a certain amount of time (a **timeout**),
    you might decide to ask again. If you still do not receive an answer, you might
    think that they are too busy and ask someone else. All of this protocol is performed
    asynchronously and is based on how long you are prepared to wait (**latency**).
  prefs: []
  type: TYPE_NORMAL
- en: Now, with these concepts in mind, technically, we could define an Actor as a
    lightweight unit of a process running on only one thread and handling messages
    one after the other; the Actor receives messages, processes them, and perhaps
    changes their internal states, based on the message. It then sends another message
    to the initial sender or any other Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform all of this workflow, the Actor needs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A reference, to be reached from within the same room (JVM) or remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mailbox, to queue incoming messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A state, to save its private state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A behavior, to act based on the received messages and current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A child Actor, as each Actor could potentially be a supervisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of this book is not to make you an expert on the Akka framework;
    instead, this book should provide you with the basic knowledge to feel comfortable
    with the fundamental concepts. The concepts that you will learn will allow you
    to build an application, and, if you wish, to go deeper into other components
    of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: As a reference, the complete Akka documentation can be found directly on the
    website of the Akka project at [https://doc.akka.io/docs/akka/current/general/index.html](https://doc.akka.io/docs/akka/current/general/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get straight to work and look at how this can be implemented in the real
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up our project, we will need the Akka library, in order to create Actors
    on the server, and Notify.js. Notify.js is a JavaScript library used to pop up
    notifications on the browser; we picked this library because it does not have
    any dependencies on other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add this JavaScript library, just add the following to `build.sbt`, under `jsDependencies` in
    the `client` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is for the configuration of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the server level, we need to open a communication channel between the server
    and the browser; once the communication is open, we need to implement the message
    reception and broadcast it to all of the connected browsers using Actors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the web socket route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the route, the `conf/routes` file needs to be modified by adding
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the route is defined in the same way as a regular web service call;
    so, the `GET` call on `/v1/cart/events` is routed to the `cartEventWS` method
    of the `controllers.WebSockets` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create the `WebSockets` class in the `controllers` package
    of the server module, and add the `cartEventsWS` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are not many lines of code, but a lot is happening in this snippet.
  prefs: []
  type: TYPE_NORMAL
- en: On the class constructor, Google Guice (the dependency injection used in Play)
    is going to inject `ActorSystem`. `ActorSystem` is the root guardian of the system;
    this is the top level in the hierarchy of Actors and is unique for every JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Play uses Akka-stream underneath; a materializer is needed. First, let us explain
    these new terms. Akka-stream is an Akka component used to nicely handle streams,
    and it is exactly what we need to take care of our stream between the server and
    the browser. Akka-stream is well engineered; there is a clear separation between
    the definitions in the stream, such as where the data should be taken, how to
    process it and where to move it, and the stream runtime. To define the stream,
    a **Domain-Specific Language** (**DSL**) is available, and the materializer is
    the runtime of the stream. That is why we need to provide `Materializer` in our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The upstream is created with `ActorFlow.actorRef { out => }`, where `out` is
    an Actor representing the browser. This function should return an Actor handling
    messages from the browser. We will come back to the implementation later.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, at this point, our server opens a new route on `/v1/cart/events`.
    At that entry point, a web socket connection is expected, and for each new connection,
    a new communication stream is started.
  prefs: []
  type: TYPE_NORMAL
- en: Well, it is time to code the communication handling; but what do we want to
    do?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing BrowserManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each time a new connection is accepted (representing a new browser), we would
    like to keep a reference to that connection, so that events can be sent to it
    later. This connection container is handled by an Actor. This Actor will need
    an internal state with the list of connected browsers; we should add a new browser,
    and remove it once it is disconnected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an Actor, we use the `Props` class from Akka, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This Actor is created from the guardian root Actor; in our case, it is named
    `actorSystem`. From the system Actor, the `actorOf` method is called; this method
    expects `Props` as the first parameter, representing our Actor factory, and the
    name of the Actor as the second parameter. `BrowserManagerActor` is composed of
    a class and its companion object. The companion object is used to create an instance
    of the Actor, and it is a good practice to also define the messages related to
    that Actor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We define the `props()` method used to create the Actor instance. There is nothing
    special here; the factory is defined on the companion object and is the best pattern
    to create an Actor. In this class, we also define the specific messages of this
    Actor; in this case, we only have one, named `AddBrowser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BrowserManagerActor` class implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To become an Actor, the class needs to extend the `Actor` class; we also extend `ActorLogging`.
    This will provide a `log` object in our class, which can be used to log interesting
    information.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, we would like to keep the list of browsers connected to the
    server. For that purpose, we use the `browsers` variable, with `ListBuffer[ActorRef]`
    as the type.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are using a mutable collection to define this list; this is completely
    fine in this context, as it is only accessible by this Actor and is guaranteed
    to be thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to avoid this mutable variable by using another component from
    the Akka framework. This component is named **Final State Machine** (**FSM**).
    The full details of the FSM implementation are out of the scope of this book.
    If you are interested, the link to the full documentation can be found at [https://doc.akka.io/docs/akka/current/fsm.html](https://doc.akka.io/docs/akka/current/fsm.html).
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we mentioned that an Actor receives messages; this is the purpose of
    the `receive` method. It is a partial function, with `Any -> Unit` as a signature. To
    implement this function, we define the cases that we would like to handle; putting
    it in a different way, we define the messages that the Actor is handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our manager Actor handles three messages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`case AddBrowser(b)`: Here, a new connection is created, and `b` represents
    the browser Actor. First, by performing `context.watch(b)`, we ask the Akka framework
    to watch the `b` Actor and inform us when it dies by sending a terminated message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case CartEvent(user, product, action)`: Here, a message comes from a browser,
    namely, `CartEvent`. We would like to inform all of the connected browsers about
    this event. This is done by sending an alarm message to all of the browsers in
    our browser list. Notice that we convert the message to a JSON format using Circe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case Terminate(b)`: This message is received because we are supervising the
    browser Actor. The `b` Actor dies, and the only thing to do is remove it from
    our list of browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are almost done. With this Actor, we keep track of the connected browsers
    and send an alarm when any of them emits an event.
  prefs: []
  type: TYPE_NORMAL
- en: But wait; something looks suspicious. Indeed, we never sent the `AddBrowser`
    and `CartEvent` messages to our manager. Who should send them? The answer is in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to the `Websockets` class, and, more specifically, to the `cartEventWS`
    method, we can finish the implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After logging, we send the `AddBrowser` message  to the manager by using the `!` command
    (pronounced bang); this is syntactic sugar, and we could also use the `.tell()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '`ActorFlow.actorRef` needs `ActorRef` to handle the upstream of the web socket;
    for that purpose, we create `BrowserActor` by using the `props` function of the
    `BrowserActor` companion object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`BrowserActor` references the manager; indeed, the manager has the responsibility
    of sending the message to all of the browsers. The `BrowserActor` class implementation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This implementation gets all of the messages coming from the socket in string
    format, converts them into `CartEvent` using Circe, and forwards them to the browser
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the message flow can become more complicated; that is why
    it is a good idea to create a diagram of the system of Actors.
  prefs: []
  type: TYPE_NORMAL
- en: A diagram of Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes necessary to represent the Actor flow using a diagram. The more
    Actors there are in your system, the more difficult it is to picture the entire
    workflow, especially if you do not work on the code for a while and then come
    back to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a diagram of our project, illustrating the workflow when a
    new browser is connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/118a6e42-ea30-4374-b0af-39334cb6520a.png)'
  prefs: []
  type: TYPE_IMG
- en: With this kind of diagram, you can clearly understand who is creating the Actors,
    and can also understand the sequences of messages between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a message being sent from the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efd7d5c8-f33b-475d-8733-db94eeae5bee.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the start of the third message indicates that the alarm is sent
    to multiple instances of the web socket.
  prefs: []
  type: TYPE_NORMAL
- en: For OmniGraffle users, you can find a stencil to create these diagrams at Diagramming
    Reactive Systems | Graffletopia ([https://www.graffletopia.com/stencils/1540](https://www.graffletopia.com/stencils/1540)).
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished looking at Actors; we are missing many features, but the
    aim was to provide you with enough knowledge to understand the basics of this
    beautiful framework.
  prefs: []
  type: TYPE_NORMAL
- en: The server is now completely implemented, and we can safely move to the client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will look at the client side. On the client side,
    we have to initiate the web socket connection with the server, send a `CartEvent`
    when a product is added or removed from the cart, and show alerts when other browsers
    make changes to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create the connection with the server using a web socket.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the web socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the web socket to the client, we are going to use the `UIManager` object,
    which is the entry point of the client. In Scala.js, `WebSocket` is part of the
    framework; edit the `UIManager` and add the web socket property to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some configuration is needed to create the `WebSocket`. We encapsulate all
    of the initializations into a function named `getWebSocket`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a `WebSocket`, we first need to give the URL of the server and then
    handle all of the events happening in the socket. To get the URL of the server,
    we use a utility function named `getWebsocketUri`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function just checks the protocol and defines the `WebSocket` protocol
    as `wss` if encrypted or `ws` if not encrypted. Then, the full URL is built by
    using string interpolation. In production, we usually use SSL, but when developing,
    we do not use encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the URL is defined, we define all of the socket event handlers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onopen`: When a new connection is created, we just log it and mark the event
    as canceled, so it will not be taken into consideration if another handler receives
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onerror`: Just log the error in the error pipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onmessage`: When a message is received, we use Circe to decode it and check
    whether it is an alarm message. If that is the case, we call `notify(alarm)`,
    otherwise, we just log the fact that we received an unknown message. The `notify(alarm)`
    will be explained later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onclose`: Again, we just log this event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we have defined the socket and it is ready to be used; if this code is
    run, a connection to the server will be created as soon as the page is browsed.
    But before that, we need to define the notification system.
  prefs: []
  type: TYPE_NORMAL
- en: Notifying the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To notify the user, we picked a JavaScript library called Notify.js. Notify.js
    is a jQuery plugin without any dependencies, and it has a simple interface. We
    will implement only one method: `$.notify(string, options)`.
  prefs: []
  type: TYPE_NORMAL
- en: As Notify.js is a jQuery plugin, we need to extend jQuery with this function.
  prefs: []
  type: TYPE_NORMAL
- en: Extending jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending jQuery using Scala.js is done by extending the famous jQuery `$` symbol.
    We can create a file named `Notify.scala` in the `io.fscala.shopping.client` package,
    in the client project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, we can first define the extension with the following piece of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: An object named `NotifyJS` is defined, extending the Scala.js object named `js.Object`.
    It is necessary to inform the compiler that we are creating a facade of an existing
    JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: The first annotation is `@js.native`; this annotation tells the compiler that
    the implementation is completely done in JavaScript. The second annotation is
    `@JSGlobal("$") `; this is to express the fact that the API we are extending is
    a JavaScript class, and this class is named `$`. The last thing is to define the
    signature of the function that we would like to call and to use `js.native` as
    implementation; again, the compiler is going to make the bridge between our code
    and the JavaScript implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of the function are `String` (for the first one) and `Options`
    (for the second). `Options` need to be defined, as this is part of the facade.
  prefs: []
  type: TYPE_NORMAL
- en: By reading the Notify.js documentation ([https://notifyjs.jpillora.com/](https://notifyjs.jpillora.com/)),
    you can see that there are a lot of options available, such as the positioning
    of the notification and the animation of the notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Notify.js documentation, we can get the definitions of all of the
    options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create an `Options` class in Scala, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `@ScalaJSDefined` annotation tells the compiler that this is a type defined
    in Scala, and not in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Then, for each property, we check the type candidate in the documentation and
    define it using `js.UndefOr[Int]`; this type acts like a bridge between the `undefinedJavaScript`
    and `Options` types in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is now defined for our facade; we can use this facade and implement
    the missing `notify(alarm)` function of the `UIManager` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we check the type of action to set the class name of the notification,
    and then we use the `notify` native call by passing the message and the notification's
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are all done. Now, if the server is running, each time you add or remove
    a product in the cart, a notification will be sent to all of the connected browsers,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24ff428f-867b-498e-a8d4-908fa9102bb8.png)'
  prefs: []
  type: TYPE_IMG
- en: The shopping page with the notification for cart updates
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a WebSocket communication between
    the server and the browser. At the server level, we kept a reference to all the
    browsers connected, so that events could be dispatched to all the browsers. An
    important piece of the system is the actor model, defined at the server level.
    We learned that the actor model programming paradigm is adequate as soon as we
    have an interaction between asynchronous systems.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that a diagram of the interactions between Actors can be helpful
    as your system is growing. It is particularly useful when someone needs to go
    back to the code after being away for a while. As we are not calling methods but
    sending messages to `ActorRef`, the navigation in the IDE is not easy, so it is
    difficult to understand the flow just by reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: Once the first steps in this framework are made, development is natural and
    close to real-world interaction.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced Akka. Akka is a complete framework, separated into different
    modules. We strongly encourage you to take a spin in the Akka website at [https://akka.io/](https://akka.io/).
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, thanks to Scala.js, the integration of a framework is completed
    with only a few lines of code; once defined in Scala, we can use all of the knowledge
    learned from a backend system and apply it to the front. This is especially true
    when we are sharing the code between the backend and frontend.
  prefs: []
  type: TYPE_NORMAL
- en: This ends the chapter. At this point, you should have the necessary information
    to build your own client-server program. In the next chapters, we will introduce
    you to how to use Scala to process and analyze large amounts of data, using Apache
    Spark, Kafka and Zeppelin.
  prefs: []
  type: TYPE_NORMAL
