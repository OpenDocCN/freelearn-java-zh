- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: BigDecimal and Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigDecimal 和单元测试
- en: We begin this chapter by addressing the problem with floating point representation
    that is found in most languages. The problem revolves around the inability to
    represent every decimal fraction as a binary fraction, as pointed out in [*Chapter
    4*](B19088_04.xhtml#_idTextAnchor086), *Language Fundamentals – Data Types and
    Variables*. In most situations, it can be accurate enough. But what happens if
    you must guarantee accuracy and precision? You must abandon floating point primitives
    and use the `BigDecimal` class.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章开始，解决大多数语言中存在的浮点表示问题。这个问题围绕着无法将每个十进制分数表示为二进制分数，正如在[*第 4 章*](B19088_04.xhtml#_idTextAnchor086)中指出的，*语言基础
    – 数据类型和变量*。在大多数情况下，它已经足够准确。但如果你必须保证准确性和精度呢？你必须放弃浮点原语，并使用 `BigDecimal` 类。
- en: How do you know that the code you have just written works? The compiler can
    spot syntax errors. An error-free compilation only tells you that the compiler
    is happy. But does it work? How does your code handle invalid input, lost connections
    to a database, or edge cases? Always be aware that for most projects you work
    on, the most unreliable component of the systems you code for is the end users.
    You cannot fix them, but you need to design and implement your code to handle
    the unexpected. Unit testing is one technique for validating your code while you
    write it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道你刚刚编写的代码是否工作？编译器可以检测语法错误。无错误的编译只能告诉你编译器很高兴。但它真的工作吗？你的代码如何处理无效输入、数据库连接丢失或边缘情况？始终意识到，对于你工作的大多数项目，你编写的系统中最不可靠的组件是最终用户。你不能修复他们，但你需要设计和实现你的代码来处理意外情况。单元测试是在编写代码时验证代码的一种技术。
- en: Unit testing is not the same as **quality assurance** (**QA**). This is a process
    carried out to ensure that the program is meeting the specifications it was coded
    for. QA is about programs that run. Unit testing is about the performance of individual
    methods. Sometimes objects and methods that work together must be tested, which
    is called integration testing, but the testing techniques are similar. This testing
    is the responsibility of the programmer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试与**质量保证**（**QA**）不同。这是一个执行的过程，以确保程序符合其编码时的规格。QA 是关于运行的程序。单元测试是关于单个方法的性能。有时必须测试一起工作的对象和方法，这被称为集成测试，但测试技术是相似的。这种测试是程序员的职责。
- en: 'In this chapter, we will look at how we write unit tests using the JUnit 5
    framework. What is significant about this framework is that you can test any method
    in your code without the need for a main method. We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用 JUnit 5 框架编写单元测试。这个框架的显著之处在于，你可以测试代码中的任何方法，而无需主方法。我们将涵盖以下主题：
- en: Using `BigDecimal`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `BigDecimal`
- en: What is JUnit 5?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 JUnit 5？
- en: Testing with JUnit 5
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JUnit 5 进行测试
- en: Performing parametrized testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行参数化测试
- en: In the advanced Java courses that I have taught, unit testing was mandatory.
    If a student could not demonstrate that the code they wrote passed unit tests,
    then I could not be bothered to even look at the code. A submission was expected
    to run its tests before the program itself was executed. If there were no tests,
    then it was an automatic failure. I may have been harsh, but the result was that
    I had confidence that what they coded could work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我教授的高级 Java 课程中，单元测试是强制性的。如果一个学生不能证明他们编写的代码通过了单元测试，那么我就没有兴趣去查看代码。提交的代码在程序执行之前必须运行其测试。如果没有测试，则自动失败。我可能很严厉，但结果是，我对他们编写的代码能否工作有信心。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中运行示例所需的工具如下：
- en: Java 17
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: A text editor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Maven 3.8.6 或更高版本
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12)找到。
- en: Using BigDecimal
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BigDecimal
- en: The `BigDecimal` class, which is a member of the `java.math` library, is a fixed-precision
    representation of floating point numbers. This means that values represented as
    `BigDecimal` do not suffer from the problem of approximation that can and does
    occur when calculations are carried out by the hardware **floating point unit**
    (**FPU**) of most CPUs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigDecimal` 类是 `java.math` 库的一个成员，它是对浮点数的固定精度表示。这意味着以 `BigDecimal` 表示的值不会受到大多数
    CPU 的硬件浮点单元（**FPU**）在执行计算时可能发生的近似问题的困扰。'
- en: The `BigDecimal` class shares an important characteristic with a string. They
    are both immutable. This means that when a value becomes a `BigDecimal` object,
    it cannot be changed. Any operation on a `BigDecimal` object returns a new `BigDecimal`
    object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigDecimal` 类与字符串共享一个重要的特性。它们都是不可变的。这意味着当一个值成为 `BigDecimal` 对象后，它就不能再改变了。对
    `BigDecimal` 对象的任何操作都会返回一个新的 `BigDecimal` 对象。'
- en: 'Let us look at an application that can calculate loan payments for money borrowed.
    The formula for this calculation is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个可以计算借款还款额的应用程序。这个计算的公式如下：
- en: '![](img/B19088_12_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19088_12_001.jpg)'
- en: 'Here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里：
- en: '*rate* = the interest rate per period'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*rate* = 每期的利率'
- en: '*n* = the number of periods'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* = 期数数量'
- en: '*PV* = present value (amount of loan)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PV* = 现值（贷款金额）'
- en: '*PMT* = payment (the monthly payment)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PMT* = 付款（每月付款）'
- en: 'If we use doubles for all the values, the Java bean data object will look as
    follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用双精度浮点数（doubles）来表示所有值，Java Bean 数据对象将如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Object` superclass has a method named `toString` that will return the
    address at which the object is stored as a string. We override it to display the
    values in all the fields. This can be quite useful in debugging, so I advise you
    to always have a `toString` method in any data class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 超类有一个名为 `toString` 的方法，它将返回对象存储位置的字符串表示。我们重写了它以显示所有字段的值。这在调试中非常有用，所以我建议你在任何数据类中始终包含一个
    `toString` 方法：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The formula to calculate the result is as follows. It has been broken up to
    reflect each part of the final calculation, although it could be written as a
    single line as done in the `CompoundInterest` examples. The comments describe
    each part of the formula:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果的公式如下。它被拆分成几个部分，以反映最终计算的每个部分，尽管它也可以像 `CompoundInterest` 示例中那样写成一行。注释描述了公式的每个部分：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we borrowed $5,000 at 5% annual interest for 60 months, the answer will
    be $94.35616822005495\. So, the result should be $94.36\. The issue here is that
    all calculations are being done to 14 decimal places when they should only be
    done with values that have two decimal places except for the monthly interest
    rate. Interest rates may have more than two decimal places. Dividing the annual
    interest rate by 12, for 12 payments a year, results in a value where the first
    two decimal places are 0\. In most cases, the result will be accurate, but not
    always. This is a serious issue if you are writing what is referred to as an accounting
    problem. The solution is to use `BigDecimal`. Here is the data object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以 5% 的年利率借了 5000 美元，期限为 60 个月，答案将是 94.35616822005495 美元。所以，结果应该是 94.36 美元。这里的问题是所有计算都是到
    14 位小数，而它们应该只使用具有两位小数的值，除了每月的利率。利率可能有多于两位小数。将年利率除以 12，对于一年 12 次付款，得到一个值，其前两位小数是
    0。在大多数情况下，结果将是准确的，但并不总是如此。如果你在编写所谓的会计问题，这是一个严重的问题。解决方案是使用 `BigDecimal`。以下是数据对象：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are convenience objects in `BigDecimal`, one of which is `BigDecimal.ZERO`,
    which returns a `BigDecimal` object initialized to 0:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BigDecimal` 中有一些便利的对象，其中之一是 `BigDecimal.ZERO`，它返回一个初始化为 0 的 `BigDecimal`
    对象：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The default constructor is using this non-default constructor and passes it
    three `BigDecimal` objects initialized to 0:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数使用这个非默认构造函数，并传递三个初始化为 0 的 `BigDecimal` 对象：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Calculation` class using `BigDecimal` now looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BigDecimal` 的 `Calculation` 类现在看起来如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Division is an operation that could result in an infinitely repeating sequence.
    If this is detected, then an exception is thrown. To prevent this exception, we
    limit the number of decimal places with `MathContext.DECIMAL64`. This will limit
    the number to 16 decimal places:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除法是一个可能产生无限循环小数序列的操作。如果检测到这种情况，则会抛出异常。为了防止这种异常，我们使用 `MathContext.DECIMAL64`
    限制小数位数。这将限制数字到 16 位小数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we use `setScale` to restrict the output to two decimal places. We also
    define how rounding should occur. Many of you will have been taught that 1 to
    4 round down and 5 to 9 round up. This is not how it is done in accounting. Banks
    use `HALF_EVEN`. For example, 27.555 will round to 27.56\. If the value is 27.565,
    it will round to 27.56\. If the value of the last requested decimal place is an
    even number and the value that follows is exactly 5, then it rounds down. If it
    is an odd number, it rounds up. Over time, you and the bank will break even. Without
    `HALF_EVEN`, you will probably lose money to the bank:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`setScale`将输出限制为两位小数。我们还定义了如何进行舍入。你们中许多人可能被教导1到4向下舍入，5到9向上舍入。在会计中并不是这样做的。银行使用`HALF_EVEN`。例如，27.555将舍入为27.56。如果值是27.565，它将舍入为27.56。如果最后请求的小数位上的值是偶数，并且随后的值正好是5，则向下舍入。如果是奇数，则向上舍入。随着时间的推移，你和银行将收支平衡。如果没有`HALF_EVEN`，你可能会损失给银行的钱：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Some financial calculations return a negative answer. This tells you which
    way the money flows, to you or to the bank. I am using the `BigDecimal` absolute
    method to eliminate the sign:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些财务计算会返回一个负数。这告诉你资金的流向，是流向你还是银行。我正在使用`BigDecimal`的绝对值方法来消除符号：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The question now is how we can test this code to ensure it is giving us the
    right answer. We could write code in the `main` method to test it, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何测试这段代码以确保它给出了正确的答案。我们可以在`main`方法中编写代码来测试它，如下所示：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As already noted in [*Chapter 8*](B19088_08.xhtml#_idTextAnchor172), *Arrays,
    Collections, Generics, Functions, and Streams*, you cannot use operators such
    as +, >, and ==, with objects. Instead, you use methods such as `equals`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[*第8章*](B19088_08.xhtml#_idTextAnchor172)，“数组、集合、泛型、函数和流”中已经提到的，你不能使用+、>和==等运算符与对象一起使用。相反，你使用`equals`等方法：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What if you want to test many values? The `loanCalculation` method shows that
    it could throw `ArithmeticException`. How can you test that this exception is
    thrown when appropriate? The answer is unit testing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试许多值怎么办？`loanCalculation`方法表明它可能会抛出`ArithmeticException`。我们如何测试在适当的时候抛出这个异常？答案是单元测试。
- en: What is JUnit 5?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是JUnit 5？
- en: JUnit 5 is an open source library and not part of the Java Development Kit library.
    It is licensed using the Eclipse Public License v2.0\. This simply means that
    you are free to use this library and distribute it with your work for either open
    source or commercial software without having to make any payments. So, what does
    it do?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5是一个开源库，不是Java开发工具包库的一部分。它使用Eclipse Public License v2.0进行许可。这仅仅意味着你可以自由地使用这个库，并在开源或商业软件中与你的工作一起分发，而无需支付任何费用。那么，它做什么呢？
- en: This unit testing framework allows you to instantiate any class in your project
    and call upon any non-private method. These non-private methods, such as `public`
    and `package`, can be executed from within what is called a test class. These
    are classes that are instantiated by the JUnit framework. A test class contains
    methods that can instantiate any class in the project and call upon a method in
    the class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试框架允许你实例化项目中的任何类并调用任何非私有方法。这些非私有方法，如`public`和`package`，可以在所谓的测试类中执行。这些是由JUnit框架实例化的类。测试类包含可以实例化项目中的任何类并调用类中方法的函数。
- en: Testing with JUnit 5
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JUnit 5进行测试
- en: Test classes are not part of the usual source code folder, `src/main/java`.
    Instead, they are placed in `src/test/java`. They can and should be organized
    into packages. You can also have resources that are just used by the test classes,
    such as `logging.properties` or `log4j2.xml`. They will be placed in `src/test/resources`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类不是通常的源代码文件夹`src/main/java`的一部分，而是放在`src/test/java`中。它们可以也应该组织成包。你也可以有仅由测试类使用的资源，例如`logging.properties`或`log4j2.xml`。它们将被放在`src/test/resources`。
- en: 'We will need to add new components to our Maven `pom.xml` file. The first is
    the dependency for JUnit 5\. The first addition is the `dependencyManagement`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的Maven `pom.xml`文件中添加新组件。第一个是JUnit 5的依赖项。第一个添加的是`dependencyManagement`：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All dependencies and plugins in a Maven-based project require a version value.
    One way you can ensure that the version value for all dependencies of a given
    library is correct is to use, if available, a BOM. Now, it is no longer necessary
    to include version values for each library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Maven的项目中的所有依赖项和插件都需要一个版本值。你可以确保给定库的所有依赖项的版本值正确的一种方法是在可用的情况下使用BOM。现在，不再需要为每个库包含版本值。
- en: 'Next is the dependency specifically for JUnit 5\. This dependency supports
    both single test methods and parameterized tests. Notice also that the scope of
    these dependencies is `test`, which means that they are not included in the final
    packaging of the code. The test classes are also not included in the final packaging
    of your code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是针对JUnit 5的特定依赖项。此依赖项支持单测试方法和参数化测试。请注意，这些依赖项的范围是`test`，这意味着它们不包括在代码的最终打包中。测试类也不包括在代码的最终打包中：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next change is to add the Maven `surefire` plugin. This plugin will run
    all unit tests. The results of the test will appear in the console, a text file,
    and an XML file. These files can be found in `target/surefire-reports`. This folder
    will be created for you when you run the tests. Existing test reports will be
    overwritten when the tests are rerun:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更改是添加Maven的`surefire`插件。此插件将运行所有单元测试。测试结果将显示在控制台、文本文件和XML文件中。这些文件可以在`target/surefire-reports`中找到。当你运行测试时，此文件夹会为你创建。当重新运行测试时，现有的测试报告将被覆盖：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The example code does not have a `main` method as it represents a project in
    progress. It cannot be run but it can be unit tested. To just run the tests when
    you use `mvn`, set `defaultGoal` in the `build` section:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码没有`main`方法，因为它代表一个正在进行中的项目。它不能运行，但它可以进行单元测试。要使用`mvn`仅运行测试，请在`build`部分设置`defaultGoal`：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s create a basic unit test. The first thing you will need is to add the
    `test/java` and `test/resources` folders to the Maven project you are writing
    unit tests for. This is what the folder structure looks like for my example project.
    I have also added a package called `com.kenfogel.calculationtest` to `test/java`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的单元测试。你需要做的第一件事是将`test/java`和`test/resources`文件夹添加到你要为单元测试编写的Maven项目中。这是我示例项目的文件夹结构。我还添加了一个名为`com.kenfogel.calculationtest`的包到`test/java`中。
- en: '![Figure 12.1 – Folder structure for unit tests](img/B19088_12_01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 单元测试的文件夹结构](img/B19088_12_01.jpg)'
- en: Figure 12.1 – Folder structure for unit tests
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 单元测试的文件夹结构
- en: 'Now, let us look at our test class. The code examples in the book up to this
    point have not shown the required imports. They can be found in the code samples
    in the GitHub repo for the book. These examples will look at imports. Here is
    the `SimpleTest.java` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的测试类。到目前为止，书中提供的代码示例没有显示所需的导入。它们可以在GitHub仓库中找到该书的代码示例。以下示例将查看导入。以下是`SimpleTest.java`类：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These two imports make the `Calculation` and `FinancialData` classes available
    to this class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个导入使`Calculation`和`FinancialData`类可用于此类：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are the imports for what we will use from JUnit 5:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了我们将从JUnit 5中使用的导入：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This last `static` import allows us to use `assertEquals` without needing to
    show the whole package structure seen here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个`static`导入允许我们使用`assertEquals`而不需要显示这里看到的整个包结构：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we have the import for `BigDecimal`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`BigDecimal`的导入：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `@BeforeEach` annotation is used to define methods that must be run before
    each test method. It has a companion `@AfterEach` annotation. There are also `@BeforeAll`
    and `@AfterAll`, which are methods run once before all testing begins or after
    all testing ends. The best practice in testing is to always instantiate the objects
    you will use for testing for each test. Avoid reusing an object that was used
    in a previous test as it can result in unexpected errors in tests that depend
    upon it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`@BeforeEach`注解用于定义必须在每个测试方法之前运行的方法。它有一个配套的`@AfterEach`注解。还有`@BeforeAll`和`@AfterAll`，它们是在所有测试开始之前或所有测试结束后运行的方法。在测试中，最佳实践是始终为测试实例化你将使用的对象。避免重复使用在先前的测试中使用过的对象，因为这可能导致依赖于它的测试中出现意外的错误：'
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is the test annotated with `@Test`. It sets the three variables in `FinancialData`
    and calls upon the `Calculation` class to calculate the loan payment. It ends
    with `assertEquals` to compare the result with the known answer:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有`@Test`注解的测试。它设置了`FinancialData`中的三个变量，并调用`Calculation`类来计算贷款支付。它以`assertEquals`结束，以将结果与已知答案进行比较：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run the test with the default goal set to `test`, you just need to run `mvn`
    at the command line in the root folder of the project. Here is the output of the
    test in the console:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行默认目标设置为`test`的测试，你只需在项目的根目录下命令行中运行`mvn`。以下是控制台中的测试输出：
- en: '![Figure 12.2 – The test result](img/B19088_12_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 测试结果](img/B19088_12_02.jpg)'
- en: Figure 12.2 – The test result
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 测试结果
- en: You can also test that an expected exception is thrown. Here is the method rewritten
    but with `term` set to `0`. This should result in `ArithmeticException` with a
    message of `Division by zero`. Asserting on the message is important as there
    are two possible reasons for `ArithmeticException`. The first is division by zero.
    The second occurs when a calculation using `BigDecimal` has an infinitely repeating
    sequence.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以测试是否抛出了预期的异常。以下是重写的方法，但将`term`设置为`0`。这将导致带有消息`Division by zero`的`ArithmeticException`。断言消息很重要，因为`ArithmeticException`有两个可能的原因。第一个是除以零。第二个发生在使用`BigDecimal`进行计算时出现无限循环序列。
- en: 'First, we need another `import` statement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要另一个`import`语句：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can write the test:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写测试：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we are calling the method we expect to throw an exception in `assertThrowsExactly`.
    This method begins with the name of the exception class we are expecting followed
    by a lambda expression to invoke the method we expect to throw `ArithmeticException`.
    The `assertThrowsExactly` method returns the exception object that was thrown,
    and we assign it to an `ArithmeticException` object. We can now use the `assertEquals`
    method to determine whether division by zero was the cause of this exception.
    If no exception is thrown or a different message is found, then the test will
    fail:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在调用我们期望在`assertThrowsExactly`中抛出异常的方法。这个方法以我们期望的异常类名开头，后面跟着一个lambda表达式来调用我们期望抛出`ArithmeticException`的方法。`assertThrowsExactly`方法返回抛出的异常对象，我们将其赋值给一个`ArithmeticException`对象。现在我们可以使用`assertEquals`方法来确定除以零是否是此异常的原因。如果没有抛出异常或找到不同的消息，则测试将失败：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This concludes our look at basic unit testing where each test runs just once.
    Ideally, a unit test should be run with a range of values and not just one. This
    is what we will look at next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对基本单元测试的探讨，其中每个测试只运行一次。理想情况下，单元测试应该使用一系列值运行，而不仅仅是单个值。这就是我们接下来要探讨的内容。
- en: Performing parameterized testing
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行参数化测试
- en: 'This leaves one more type of testing to look at, a parameterized test. As you
    may have realized, if you want to run a test to determine whether the result is
    accurate for several values, then you will need one method per set of values.
    JUnit 5 simplifies this task by allowing you to create a list of values. Let’s
    see how this works. Here is the new parameterized test class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这还留下了一种需要查看的测试类型，即参数化测试。正如你可能已经意识到的，如果你想运行一个测试来确定结果是否对多个值准确，那么你需要为每组值创建一个方法。JUnit
    5通过允许你创建一个值列表来简化这项任务。让我们看看这是如何工作的。以下是新的参数化测试类：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will not instantiate the `FinancialData` object here as we did in the previous
    example. It will be created by a private helper method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会像上一个例子那样实例化`FinancialData`对象。它将由一个私有辅助方法创建：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first annotation declares that this will be a parameterized test. This
    means that this method will be run once for every row of data listed as part of
    `@CsvSource`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个注解声明这将是一个参数化测试。这意味着这个方法将为`@CsvSource`中列出的每一行数据运行一次：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `ArgumentsAccessor` parameter will contain the current row of data to test.
    This method will be called for every row in `@CsvSource`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentsAccessor`参数将包含要测试的当前数据行。这个方法将为`@CsvSource`中的每一行调用：'
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our data class wants `BigDecimal` values. To accomplish this, we have a private
    method called `buildBean` that receives an object of type `ArgumentsAccessor`
    and then converts that into a `FinancialData` object:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据类需要`BigDecimal`值。为了实现这一点，我们有一个名为`buildBean`的私有方法，它接收一个类型为`ArgumentsAccessor`的对象，并将其转换为`FinancialData`对象：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Each row of CSV data has the answer as the last element. We are comparing the
    result stored in `monthlyPayment` with the last parameter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CSV数据中的每一行都以答案作为最后一个元素。我们正在比较存储在`monthlyPayment`中的结果与最后一个参数：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our helper method constructs a `FinancialData` object from the first three
    items in the `ArgumentsAccessor` object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的辅助方法从`ArgumentsAccessor`对象的前三个元素中构建一个`FinancialData`对象：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is still more to learn about unit testing. If a test depends on a specific
    object supplying a specific value to the test method but is not considered to
    be a point of failure, you can fake it. This is called mocking an object. You
    create the mock and what its method must return. See the *Further reading* section
    for a link to one of the widely used mocking libraries, called Mockito.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单元测试，还有更多东西要学习。如果一个测试依赖于特定对象向测试方法提供特定值，但又不被视为失败点，你可以伪造它。这被称为模拟对象。你创建模拟并指定其方法必须返回的内容。请参阅*进一步阅读*部分，以获取到广泛使用的模拟库之一，名为Mockito的链接。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The first topic we covered in this chapter was the `BigDecimal` class. Floating
    point values as processed by modern FPUs have issues when moving from decimal
    to binary and back again. This can be critical in the field of accounting where
    every penny must balance. As a class, `BigDecimal` objects are not as easy to
    use as primitives, but it is the need for absolute accuracy that mandates their
    use.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们首先介绍了 `BigDecimal` 类。现代 FPUs 处理的浮点值在从十进制到二进制以及反向转换时存在问题。这在会计领域尤为重要，因为每一分钱都必须平衡。作为一个类，`BigDecimal`
    对象不像原语那样容易使用，但绝对精确的需求决定了它们的使用。
- en: As I stated at the start of this chapter, testing is a critical task that every
    programmer should be doing. You should be delivering code that works as expected
    in almost every situation it is used for. Unit tests do not prove that the program’s
    logic is necessarily correct. This is usually tested by the QA team who are testing
    the execution of the program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头所述，测试是一项程序员应该做的关键任务。你应该交付几乎在所有使用情况下都能按预期工作的代码。单元测试并不能证明程序的逻辑必然是正确的。这通常由
    QA 团队通过测试程序的执行来验证。
- en: While writing this book, I came across a research paper that looked at unit
    testing. You can find the link in the *Further reading* section. It focused on
    Java and C# developers who used integrated development environments such as Visual
    Studio or IntelliJ. What the paper discovered is that less than half the developers
    in the study did any kind of software testing despite the ease with which it can
    be written in an IDE. Please do not be in the wrong half.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这本书的过程中，我遇到了一篇关于单元测试的研究论文。你可以在*进一步阅读*部分找到链接。该论文专注于使用集成开发环境（如 Visual Studio
    或 IntelliJ）的 Java 和 C# 开发者。论文发现，在研究中，不到一半的开发者进行了任何形式的软件测试，尽管在 IDE 中编写软件测试非常容易。请不要成为错误的一半。
- en: In this chapter, we looked at two separate concepts. The first was how we can
    perform calculations, such as in accounting, that must be accurate to a specific
    number of decimal places. We accomplish this by using the `BigDecimal` class to
    represent floating point numbers rather than `float` or `double`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两个不同的概念。第一个是如何进行计算，例如在会计中，必须精确到特定的十进制位数。我们通过使用 `BigDecimal` 类来表示浮点数而不是
    `float` 或 `double` 来实现这一点。
- en: The second concept introduced software testing using unit tests. As a programmer,
    you need to be able to show that the public methods you write perform as expected.
    This is what unit testing is about. I wrote in the previous chapter that commenting
    and logging were mandatory. I add unit testing to the list of mandatory tasks
    a programmer is expected to perform.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个概念介绍了使用单元测试进行软件测试。作为一名程序员，你需要能够证明你编写的公共方法按预期执行。这就是单元测试的内容。我在上一章中提到，注释和日志是强制性的。我将单元测试添加到程序员应执行的任务列表中。
- en: Next, let us move on and look at the **user experience**, also referred to as
    **UX**. Up until now, sample code used a console UX akin to the output of a typewriter.
    In the coming chapter, we will look at the graphical user interface UX that Java
    has available for us.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续前进，看看**用户体验**，也称为**UX**。到目前为止，示例代码使用了类似打字机输出的控制台 UX。在下一章中，我们将探讨 Java
    为我们提供的图形用户界面 UX。
- en: Further reading
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'JUnit 5: [https://junit.org/junit5/](https://junit.org/junit5/)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5：[https://junit.org/junit5/](https://junit.org/junit5/)
- en: '*Developer Testing in The IDE – Patterns, Beliefs, And Behavior*: [https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download](https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download)
    (this is a PDF file and not a web page)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 IDE 中进行开发者测试 – 模式、信念和行为*：[https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download](https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download)（这是一个
    PDF 文件，而不是网页）'
- en: 'Mokito – Tasty mocking framework for unit tests in Java: [https://site.mockito.org/](https://site.mockito.org/)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mokito – Java 单元测试的诱人模拟框架：[https://site.mockito.org/](https://site.mockito.org/)
- en: Part 3:GUI and Web Coding in Java
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：Java 的 GUI 和网络编码
- en: With the fundamentals out of the way, it is time to look at a Java application.
    In this part, we see how a business process used in the previous section can be
    used in programs that share the logic but that use a different GUI library from
    desktop application to web application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识已经掌握，现在是时候看看一个 Java 应用程序了。在本部分，我们将看到上一节中使用的业务流程如何被用于逻辑相同但使用不同 GUI 库的程序中，从桌面应用程序到网络应用程序。
- en: 'This part contains the following chapters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 13*](B19088_13.xhtml#_idTextAnchor254), *Desktop Graphical User Interface
    Coding with Swing and JavaFX*'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19088_13.xhtml#_idTextAnchor254), *使用Swing和JavaFX进行桌面图形用户界面编码*'
- en: '[*Chapter 14*](B19088_14.xhtml#_idTextAnchor281), *Server-Side Coding with
    Jakarta*'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19088_14.xhtml#_idTextAnchor281), *使用Jakarta进行服务器端编码*'
- en: '[*Chapter 15*](B19088_15.xhtml#_idTextAnchor301), *Jakarta Faces Application*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19088_15.xhtml#_idTextAnchor301), *Jakarta Faces应用程序*'
