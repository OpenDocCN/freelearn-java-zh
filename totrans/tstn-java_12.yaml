- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BigDecimal and Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin this chapter by addressing the problem with floating point representation
    that is found in most languages. The problem revolves around the inability to
    represent every decimal fraction as a binary fraction, as pointed out in [*Chapter
    4*](B19088_04.xhtml#_idTextAnchor086), *Language Fundamentals – Data Types and
    Variables*. In most situations, it can be accurate enough. But what happens if
    you must guarantee accuracy and precision? You must abandon floating point primitives
    and use the `BigDecimal` class.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know that the code you have just written works? The compiler can
    spot syntax errors. An error-free compilation only tells you that the compiler
    is happy. But does it work? How does your code handle invalid input, lost connections
    to a database, or edge cases? Always be aware that for most projects you work
    on, the most unreliable component of the systems you code for is the end users.
    You cannot fix them, but you need to design and implement your code to handle
    the unexpected. Unit testing is one technique for validating your code while you
    write it.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is not the same as **quality assurance** (**QA**). This is a process
    carried out to ensure that the program is meeting the specifications it was coded
    for. QA is about programs that run. Unit testing is about the performance of individual
    methods. Sometimes objects and methods that work together must be tested, which
    is called integration testing, but the testing techniques are similar. This testing
    is the responsibility of the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at how we write unit tests using the JUnit 5
    framework. What is significant about this framework is that you can test any method
    in your code without the need for a main method. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `BigDecimal`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is JUnit 5?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with JUnit 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing parametrized testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the advanced Java courses that I have taught, unit testing was mandatory.
    If a student could not demonstrate that the code they wrote passed unit tests,
    then I could not be bothered to even look at the code. A submission was expected
    to run its tests before the program itself was executed. If there were no tests,
    then it was an automatic failure. I may have been harsh, but the result was that
    I had confidence that what they coded could work.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Using BigDecimal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BigDecimal` class, which is a member of the `java.math` library, is a fixed-precision
    representation of floating point numbers. This means that values represented as
    `BigDecimal` do not suffer from the problem of approximation that can and does
    occur when calculations are carried out by the hardware **floating point unit**
    (**FPU**) of most CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: The `BigDecimal` class shares an important characteristic with a string. They
    are both immutable. This means that when a value becomes a `BigDecimal` object,
    it cannot be changed. Any operation on a `BigDecimal` object returns a new `BigDecimal`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an application that can calculate loan payments for money borrowed.
    The formula for this calculation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19088_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*rate* = the interest rate per period'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* = the number of periods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PV* = present value (amount of loan)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PMT* = payment (the monthly payment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we use doubles for all the values, the Java bean data object will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Object` superclass has a method named `toString` that will return the
    address at which the object is stored as a string. We override it to display the
    values in all the fields. This can be quite useful in debugging, so I advise you
    to always have a `toString` method in any data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The formula to calculate the result is as follows. It has been broken up to
    reflect each part of the final calculation, although it could be written as a
    single line as done in the `CompoundInterest` examples. The comments describe
    each part of the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we borrowed $5,000 at 5% annual interest for 60 months, the answer will
    be $94.35616822005495\. So, the result should be $94.36\. The issue here is that
    all calculations are being done to 14 decimal places when they should only be
    done with values that have two decimal places except for the monthly interest
    rate. Interest rates may have more than two decimal places. Dividing the annual
    interest rate by 12, for 12 payments a year, results in a value where the first
    two decimal places are 0\. In most cases, the result will be accurate, but not
    always. This is a serious issue if you are writing what is referred to as an accounting
    problem. The solution is to use `BigDecimal`. Here is the data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are convenience objects in `BigDecimal`, one of which is `BigDecimal.ZERO`,
    which returns a `BigDecimal` object initialized to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor is using this non-default constructor and passes it
    three `BigDecimal` objects initialized to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Calculation` class using `BigDecimal` now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Division is an operation that could result in an infinitely repeating sequence.
    If this is detected, then an exception is thrown. To prevent this exception, we
    limit the number of decimal places with `MathContext.DECIMAL64`. This will limit
    the number to 16 decimal places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `setScale` to restrict the output to two decimal places. We also
    define how rounding should occur. Many of you will have been taught that 1 to
    4 round down and 5 to 9 round up. This is not how it is done in accounting. Banks
    use `HALF_EVEN`. For example, 27.555 will round to 27.56\. If the value is 27.565,
    it will round to 27.56\. If the value of the last requested decimal place is an
    even number and the value that follows is exactly 5, then it rounds down. If it
    is an odd number, it rounds up. Over time, you and the bank will break even. Without
    `HALF_EVEN`, you will probably lose money to the bank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Some financial calculations return a negative answer. This tells you which
    way the money flows, to you or to the bank. I am using the `BigDecimal` absolute
    method to eliminate the sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The question now is how we can test this code to ensure it is giving us the
    right answer. We could write code in the `main` method to test it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As already noted in [*Chapter 8*](B19088_08.xhtml#_idTextAnchor172), *Arrays,
    Collections, Generics, Functions, and Streams*, you cannot use operators such
    as +, >, and ==, with objects. Instead, you use methods such as `equals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What if you want to test many values? The `loanCalculation` method shows that
    it could throw `ArithmeticException`. How can you test that this exception is
    thrown when appropriate? The answer is unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: What is JUnit 5?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JUnit 5 is an open source library and not part of the Java Development Kit library.
    It is licensed using the Eclipse Public License v2.0\. This simply means that
    you are free to use this library and distribute it with your work for either open
    source or commercial software without having to make any payments. So, what does
    it do?
  prefs: []
  type: TYPE_NORMAL
- en: This unit testing framework allows you to instantiate any class in your project
    and call upon any non-private method. These non-private methods, such as `public`
    and `package`, can be executed from within what is called a test class. These
    are classes that are instantiated by the JUnit framework. A test class contains
    methods that can instantiate any class in the project and call upon a method in
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with JUnit 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test classes are not part of the usual source code folder, `src/main/java`.
    Instead, they are placed in `src/test/java`. They can and should be organized
    into packages. You can also have resources that are just used by the test classes,
    such as `logging.properties` or `log4j2.xml`. They will be placed in `src/test/resources`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to add new components to our Maven `pom.xml` file. The first is
    the dependency for JUnit 5\. The first addition is the `dependencyManagement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All dependencies and plugins in a Maven-based project require a version value.
    One way you can ensure that the version value for all dependencies of a given
    library is correct is to use, if available, a BOM. Now, it is no longer necessary
    to include version values for each library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the dependency specifically for JUnit 5\. This dependency supports
    both single test methods and parameterized tests. Notice also that the scope of
    these dependencies is `test`, which means that they are not included in the final
    packaging of the code. The test classes are also not included in the final packaging
    of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next change is to add the Maven `surefire` plugin. This plugin will run
    all unit tests. The results of the test will appear in the console, a text file,
    and an XML file. These files can be found in `target/surefire-reports`. This folder
    will be created for you when you run the tests. Existing test reports will be
    overwritten when the tests are rerun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The example code does not have a `main` method as it represents a project in
    progress. It cannot be run but it can be unit tested. To just run the tests when
    you use `mvn`, set `defaultGoal` in the `build` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s create a basic unit test. The first thing you will need is to add the
    `test/java` and `test/resources` folders to the Maven project you are writing
    unit tests for. This is what the folder structure looks like for my example project.
    I have also added a package called `com.kenfogel.calculationtest` to `test/java`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Folder structure for unit tests](img/B19088_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Folder structure for unit tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us look at our test class. The code examples in the book up to this
    point have not shown the required imports. They can be found in the code samples
    in the GitHub repo for the book. These examples will look at imports. Here is
    the `SimpleTest.java` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These two imports make the `Calculation` and `FinancialData` classes available
    to this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the imports for what we will use from JUnit 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This last `static` import allows us to use `assertEquals` without needing to
    show the whole package structure seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the import for `BigDecimal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@BeforeEach` annotation is used to define methods that must be run before
    each test method. It has a companion `@AfterEach` annotation. There are also `@BeforeAll`
    and `@AfterAll`, which are methods run once before all testing begins or after
    all testing ends. The best practice in testing is to always instantiate the objects
    you will use for testing for each test. Avoid reusing an object that was used
    in a previous test as it can result in unexpected errors in tests that depend
    upon it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the test annotated with `@Test`. It sets the three variables in `FinancialData`
    and calls upon the `Calculation` class to calculate the loan payment. It ends
    with `assertEquals` to compare the result with the known answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the test with the default goal set to `test`, you just need to run `mvn`
    at the command line in the root folder of the project. Here is the output of the
    test in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The test result](img/B19088_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – The test result
  prefs: []
  type: TYPE_NORMAL
- en: You can also test that an expected exception is thrown. Here is the method rewritten
    but with `term` set to `0`. This should result in `ArithmeticException` with a
    message of `Division by zero`. Asserting on the message is important as there
    are two possible reasons for `ArithmeticException`. The first is division by zero.
    The second occurs when a calculation using `BigDecimal` has an infinitely repeating
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need another `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are calling the method we expect to throw an exception in `assertThrowsExactly`.
    This method begins with the name of the exception class we are expecting followed
    by a lambda expression to invoke the method we expect to throw `ArithmeticException`.
    The `assertThrowsExactly` method returns the exception object that was thrown,
    and we assign it to an `ArithmeticException` object. We can now use the `assertEquals`
    method to determine whether division by zero was the cause of this exception.
    If no exception is thrown or a different message is found, then the test will
    fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our look at basic unit testing where each test runs just once.
    Ideally, a unit test should be run with a range of values and not just one. This
    is what we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Performing parameterized testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This leaves one more type of testing to look at, a parameterized test. As you
    may have realized, if you want to run a test to determine whether the result is
    accurate for several values, then you will need one method per set of values.
    JUnit 5 simplifies this task by allowing you to create a list of values. Let’s
    see how this works. Here is the new parameterized test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not instantiate the `FinancialData` object here as we did in the previous
    example. It will be created by a private helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first annotation declares that this will be a parameterized test. This
    means that this method will be run once for every row of data listed as part of
    `@CsvSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ArgumentsAccessor` parameter will contain the current row of data to test.
    This method will be called for every row in `@CsvSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our data class wants `BigDecimal` values. To accomplish this, we have a private
    method called `buildBean` that receives an object of type `ArgumentsAccessor`
    and then converts that into a `FinancialData` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Each row of CSV data has the answer as the last element. We are comparing the
    result stored in `monthlyPayment` with the last parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our helper method constructs a `FinancialData` object from the first three
    items in the `ArgumentsAccessor` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There is still more to learn about unit testing. If a test depends on a specific
    object supplying a specific value to the test method but is not considered to
    be a point of failure, you can fake it. This is called mocking an object. You
    create the mock and what its method must return. See the *Further reading* section
    for a link to one of the widely used mocking libraries, called Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first topic we covered in this chapter was the `BigDecimal` class. Floating
    point values as processed by modern FPUs have issues when moving from decimal
    to binary and back again. This can be critical in the field of accounting where
    every penny must balance. As a class, `BigDecimal` objects are not as easy to
    use as primitives, but it is the need for absolute accuracy that mandates their
    use.
  prefs: []
  type: TYPE_NORMAL
- en: As I stated at the start of this chapter, testing is a critical task that every
    programmer should be doing. You should be delivering code that works as expected
    in almost every situation it is used for. Unit tests do not prove that the program’s
    logic is necessarily correct. This is usually tested by the QA team who are testing
    the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: While writing this book, I came across a research paper that looked at unit
    testing. You can find the link in the *Further reading* section. It focused on
    Java and C# developers who used integrated development environments such as Visual
    Studio or IntelliJ. What the paper discovered is that less than half the developers
    in the study did any kind of software testing despite the ease with which it can
    be written in an IDE. Please do not be in the wrong half.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at two separate concepts. The first was how we can
    perform calculations, such as in accounting, that must be accurate to a specific
    number of decimal places. We accomplish this by using the `BigDecimal` class to
    represent floating point numbers rather than `float` or `double`.
  prefs: []
  type: TYPE_NORMAL
- en: The second concept introduced software testing using unit tests. As a programmer,
    you need to be able to show that the public methods you write perform as expected.
    This is what unit testing is about. I wrote in the previous chapter that commenting
    and logging were mandatory. I add unit testing to the list of mandatory tasks
    a programmer is expected to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us move on and look at the **user experience**, also referred to as
    **UX**. Up until now, sample code used a console UX akin to the output of a typewriter.
    In the coming chapter, we will look at the graphical user interface UX that Java
    has available for us.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUnit 5: [https://junit.org/junit5/](https://junit.org/junit5/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Developer Testing in The IDE – Patterns, Beliefs, And Behavior*: [https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download](https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download)
    (this is a PDF file and not a web page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mokito – Tasty mocking framework for unit tests in Java: [https://site.mockito.org/](https://site.mockito.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3:GUI and Web Coding in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the fundamentals out of the way, it is time to look at a Java application.
    In this part, we see how a business process used in the previous section can be
    used in programs that share the logic but that use a different GUI library from
    desktop application to web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19088_13.xhtml#_idTextAnchor254), *Desktop Graphical User Interface
    Coding with Swing and JavaFX*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19088_14.xhtml#_idTextAnchor281), *Server-Side Coding with
    Jakarta*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19088_15.xhtml#_idTextAnchor301), *Jakarta Faces Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
