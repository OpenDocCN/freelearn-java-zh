- en: Basic Type Classes and Their Usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型类及其用法
- en: In the previous chapter, we discussed the idea of the type class and how type
    classes are a methodology for decoupling data from behavior. We have also seen
    how type classes can be treated as toolboxes that abstract away certain behavior.
    In essence, to a functional programmer, they are what a workshop is to a carpenter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了类型类的概念以及类型类是如何作为解耦数据与行为的方法论的。我们还看到了类型类如何被当作工具箱来抽象某些行为。本质上，对于一个函数式程序员来说，它们就像是木匠的工作室。
- en: In the previous chapters, we also saw how type classes are motivated based on
    the practical needs that arise during functional programming. In this chapter,
    we will see how an entire library of classes for functional programming arise
    from practical needs. We'll take a look at one such library, and we will see how
    typical libraries are structured and how they can be used in practice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们也看到了类型类是如何基于函数式编程中出现的实际需求来激发的。在这一章中，我们将看到整个函数式编程类库是如何从实际需求中产生的。我们将查看这样一个库，并了解典型库的结构以及它们在实际中的应用。
- en: 'The following are the topics that we will be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: A motivation for organizing type classes into systems and libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型类组织成系统和库的动机
- en: The `Cats` library for purely functional programming and its structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数式编程的`Cats`库及其结构
- en: Type classes `Cats` defines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cats`类型类定义'
- en: A motivation for organizing type classes into systems and libraries
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类型类组织成系统和库的动机
- en: The basic principle of engineering is abstracting away what repeats. In the
    previous chapters, we saw how functional programming deals with effect types extensively
    and encapsulates side effects into them. This is because working with them directly
    can be tedious. It is pretty hard to analyze these data structures in an ad hoc
    using only the services provided to you by your programming language of choice.
    Hence, patterns of working with effect types get abstracted away into type classes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 工程学的基本原则是抽象掉重复的部分。在之前的章节中，我们看到了函数式编程如何广泛地处理效果类型并将副作用封装到它们中。这是因为直接处理它们可能会很繁琐。仅使用你选择的编程语言提供的服务来分析这些数据结构是非常困难的。因此，处理效果类型的模式被抽象到类型类中。
- en: So far, we have only seen a small amount of type classes. However, the most
    important thing to realize is the principle behind their creation, that is, realizing
    how the type classes get created and what the motivation is for their existence.
    The motivation for creating new type classes is precisely dealing with the complexity
    that side effects impose on the programmer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了一小部分类型类。然而，最重要的是要认识到它们背后的原则，即认识到类型类是如何被创建的以及它们存在的动机。创建新类型类的动机正是处理副作用给程序员带来的复杂性。
- en: We have also learned that the type class pattern consists of at least two parts.
    The first part is a declaration of the methods that are supported by the type
    class, and the second part is the implementation of the type class for the effect
    types you are going to work with. Certain effect types are embedded into the language's
    core. For example, in Scala, types such as `Future`, `Option`, and `Either` are
    present in the language core library by default. This means that you are going
    to be dealing with them frequently, and this, in turn, means that you will need
    the implementation of the type classes whenever you deal with these effect types.
    Basically, this means that you are going to redefine our implantation of type
    classes for these types every time you need them in different projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，类型类模式至少由两部分组成。第一部分是声明类型类支持的方法，第二部分是为你将要工作的效果类型实现类型类。某些效果类型被嵌入到语言的核心中。例如，在Scala中，`Future`、`Option`和`Either`等类型默认存在于语言核心库中。这意味着你将频繁地处理它们，这也意味着每次你处理这些效果类型时，都需要类型类的实现。基本上，这意味着每次你在不同的项目中需要这些类型时，你都将重新定义我们对这些类型的类型类实现。
- en: Whenever some functionality repeats from project to project, it makes sense
    to encapsulate it into a separate library. So, the preceding discussion shows
    that here, we have the situation where you have functionality that repeats from
    project to project. The first one is the type classes themselves that we use in
    multiple projects. For example, Monad deals with sequential composition, and sequential
    composition is frequent in both the functional and non-functional worlds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Another item that repeats from project to project is the implementation of the
    type classes for frequently repeating effect types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The preceding argument can be extended a little bit to the effect types themselves.
    Previously, we mentioned that the core libraries of functional languages usually
    include support for frequently encountered effect types. However, it is possible
    to imagine a situation where you're going to want to define the effect types yourself.
    For example, you may be dealing with some new effects that you want to encapsulate,
    or maybe you are going to define something that is specific to your own use case,
    and your own project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: With that, you'll notice that certain side effects that are not members of the
    core library start repeating from project to project. In this case, it would be
    wise to encapsulate them into a separate library, too. Of course, if you are frequently
    dealing with the same effect types that are not present in the language core,
    it is also a good idea to define the type class implementations for them in the
    library as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: This is because whenever you need these effect types, you will also need the
    type classes to work with them. So, if you are going to encapsulate the effect
    types into a separate library, you will also need to encapsulate the type class
    implementations in that library as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the preceding argument, we need to encapsulate three things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The type class definitions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type class implementations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frequently encountered effect types that are not present in the language
    core and the type class implementations for them
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such libraries for purely functional programming have been implemented for various
    programming languages. Now, let's take a look at what such a library may look
    like and how you can use it in practice. We will use a library called `Cats`,
    which comes from Scala.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The Cats library for purely functional programming
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce the library that we will be using for purely
    functional programming in Scala. It encapsulates frequently encountered type classes,
    implementations of them for frequently encountered effect types, and some effect
    types as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will dive deeper into the structure of the library, and
    we will see how you can use it in practice. We will be following an example of
    a `Monad` type class that we discussed in the previous chapters. We will see how
    this type class is defined in this library and how it is implemented for its data
    types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the library
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The library consists of the top-level package and its subpackages. The top-level
    package is called `cats` and is a location where basic type classes are defined:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57e96392-216e-4c9e-8d27-bde045a1f7c9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Apart from that, there are several subpackages present in the top-level package.
    The most important ones are `instances`, `data`, and `syntax`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The `instances` package contains the implementations of the type classes for
    basic data types that are present in the language core and the ones defined by
    the `Cats` library. Finally, data types that are frequently encountered and absent
    from the language core are defined under the `data` package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a look at each of these structural pieces in detail. We will
    start from the top level package, that is, `cats`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Core
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core package, `cats`, of the library exposes the following API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89caab0d-1699-4481-89fd-58c3aa51e29a.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: The core package contains a list of all the type classes that are defined by
    the library. The type classes pattern in the `Cats` implementation usually consists
    of a trait and its companion object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an example of `Monad` to take a look at what a typical type class
    looks like in the context of the library:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c0d41ca-1195-4e93-9f52-67a917eca5ca.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Let us now take a closer look at how the type classes in the type class hierarchy
    of `Cats` are structured.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Type class hierarchy
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to notice here is that the type classes are defined in the format
    that we saw in the previous chapter. Another thing to notice is the hierarchy
    of type classes in the `Cats` library. So, for example, the `Monad` class extends
    the `FlatMap` and `Applicative` type classes, and if you take a look at the linear
    super types of the type class, you will see that the ancestors are far more numerous.
    Also, if you have a look at the subclasses, you will notice that a number of type
    classes also extend the `Monad` type class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this hierarchy is that the `Cats` library is quite fine-grained.
    We previously discussed that type classes can be treated as containers for methods
    that you're going to use. Type classes such as `Monad` may define several methods
    at once. Therefore, it may be reasonable to have a separate type class for each
    of the method. Let us now discuss the abstract methods that `Monad` defines.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Abstract methods
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the *value member* section of the Scaladoc documentation
    of the `Monad` implementation by `Cats`. The abstract members section is the most
    important section of any type cause definition. A type class is a declaration
    of certain tools, and its concrete instances must support these tools. They are
    declared, but not implemented in the type class trait. So, the abstract methods
    defined by a type class constitute a definition of this type class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, in the case of Monad, we have three abstract methods, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: There is a `flatMap` method, which we are already familiar with.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pure method is able to lift any value into an effect type of `F`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯方法能够将任何值提升到 `F` 的效果类型。
- en: There is a `tailRecM` and type class. It is a tail recursive Monadic loop. The
    intuition for this method is as follows. Monad's `flatMap` defines a sequential
    composition of effectful computations. Where there is a sequence, a loop may also
    be desirable. A loop is a sequence of instructions that repeat over and over.
    Therefore, a loop is built on top of the sequential composition. If you define
    the sequential composition, you can use it to also define the loop. The role of
    `tailRecM` is to provide such a loop for the functional programming under effect
    types. You can think of it as a `while` loop of pure functional programming. We
    will discuss this method in more detail later on in the chapter.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个 `tailRecM` 和类型类。它是一个尾递归的 Monadic 循环。这个方法的直觉如下。Monad 的 `flatMap` 定义了效果计算的可序列组合。在有序列的情况下，也可能需要循环。循环是一系列重复执行的指令。因此，循环建立在序列组合之上。如果你定义了序列组合，你可以用它来定义循环。`tailRecM`
    的作用是为效果类型下的函数式编程提供一个这样的循环。你可以把它看作是纯函数式编程的 `while` 循环。我们将在本章后面更详细地讨论这个方法。
- en: Concrete methods
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体方法
- en: Besides abstract methods, the `Monad` type class provides a bunch of predefined
    concrete value members. These are implemented by default in the type class, so
    when you define the type class instance, you do not need to provide the implementation
    of these value members. Their definitions are based on the abstract value members
    that we saw previously. This means that every method that you encounter under
    concrete value members can be defined in terms of the abstract value members we
    saw previously.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了抽象方法之外，`Monad` 类型类提供了一组预定义的具体值成员。这些成员默认在类型类中实现，因此当你定义类型类实例时，不需要提供这些值成员的实现。它们的定义基于我们之前看到的抽象值成员。这意味着你可以用之前看到的抽象值成员来定义在具体值成员下遇到的每个方法。
- en: 'It is very common for concrete value members to contain methods that are abstract
    value members in a superclass of the type class in question. Take, for example,
    the `map` method, which we are already familiar with. Technically, it comes as
    an abstract member of the `Functor` type class. However, it is possible to define
    a type class in terms of only `flatMap` and pure functions. These two functions
    are abstract members of the `Monad` class, and hence we can override the inherited
    `map` function with a concrete implementation of it, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 具体值成员通常包含在类型类的超类中的抽象值成员的方法是很常见的。以我们已熟悉的 `map` 方法为例。技术上，它作为 `Functor` 类型类的抽象成员。然而，可以仅用
    `flatMap` 和纯函数来定义类型类。这两个函数是 `Monad` 类的抽象成员，因此我们可以用具体的实现来覆盖继承的 `map` 函数，如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, you can see how exactly that function can be
    implemented when you have `flatMap` and `pure` functions. A word of caution, that
    this kind of implementation based on the `flatMap` and `pure` functions is not
    always desirable. There are situations where you will want to have a custom implementation
    of the functions that can be implemented in terms of the abstract methods. In
    some scenarios, reusing the functionality that you already have is not always
    the best solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到当你有 `flatMap` 和 `pure` 函数时，这个函数是如何实现的。提醒一下，基于 `flatMap` 和 `pure`
    函数的这种实现并不总是可取的。有些情况下，你可能希望有一个自定义的函数实现，这些函数可以用抽象方法来实现。在某些场景中，重用你已有的功能并不总是最佳解决方案。
- en: The intuition for this logic is as follows. We have already discussed that sequential
    composition in pure functional programming is facilitated by Monad. Later in this
    chapter, we will see a type class that has been designed for parallel composition.
    The operator to compose two computationals in parallel can be implemented in two
    ways. One way is what you would expect from real parallelism. It performs computations
    independently. For example, if one computation fails, the other computation will
    still continue and will still produce a value. However, it is possible to implement
    the parallel composition operator with the help of sequential composition. You
    may have an implementation of such a composition that just composes two computations
    sequentially, although you will have it named as a parallel composition operator.
    So, if you have a sequential composition operator such as `flatMap`, a naive parallel
    composition operator will be defined as a sequential composition of the computations
    using this sequential composition operator.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种逻辑的直觉如下。我们已经讨论过，在纯函数式编程中，序列组合是由 Monad 促成的。在本章的后面，我们将看到一个为并行组合设计的类型类。并行组合两个计算的操作符可以有两种实现方式。一种方式是你从真正的并行性中期望的方式。它独立执行计算。例如，如果一个计算失败，另一个计算仍然会继续，并且仍然会产生一个值。然而，可以使用序列组合来帮助实现并行组合操作符。你可能有一个这样的组合实现，它只是顺序地组合两个计算，尽管你可能会将其命名为并行组合操作符。所以，如果你有一个如`flatMap`这样的序列组合操作符，一个简单的并行组合操作符将被定义为使用这个序列组合操作符对计算进行序列组合。
- en: The reason we are having this discussion is that Monad inherits from the Applicative
    type class. The Applicative type class was designed for parallel computation.
    It contains a method called `ap` that is designed to compose computations in parallel.
    However, when we discussed the `Monad` type class in the past, we did not see
    this method among the abstract members. This is because it is a concrete member
    of the `Monad` type class, which means that it was implemented using the methods
    defined by Monad—the `flatMap` and the `pure` functions. In practice, it means
    that if you want to perform a parallel composition, you may be able to, depending
    on either the Monad or Applicative type class. However, if you depend on Monad,
    you may not get true parallelism, since its parallelism operator may be implemented
    in terms of sequential composition. So, it is very important to understand the
    mechanics of type classes and not to treat them as something magical because you
    might be in for an unexpected error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行这次讨论的原因是，Monoid 继承自 Applicative 类型类。Applicative 类型类是为并行计算设计的。它包含一个名为`ap`的方法，该方法旨在并行组合计算。然而，当我们过去讨论`Monad`类型类时，我们没有看到这个方法在抽象成员中。这是因为它是`Monad`类型类的具体成员，这意味着它是使用由
    Monad 定义的`flatMap`和`pure`函数实现的。在实践中，这意味着如果你想要执行并行组合，你可能能够做到，这取决于 Monad 或 Applicative
    类型类。然而，如果你依赖于 Monad，你可能不会得到真正的并行性，因为它的并行操作符可能是以序列组合的形式实现的。因此，理解类型类的机制非常重要，不要将它们视为某种神奇的东西，因为你可能会遇到意外的错误。
- en: Type classes have a solid mathematical foundation in the form of Category Theory.
    We will not be discussing the theory in this pragmatic guide to functional programming.
    However, in the next section, we will touch upon the mathematical nature of type
    classes and discuss which mathematical laws they must obey.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类在形式上有一个坚实的数学基础，即范畴论。我们不会在这个关于函数式编程的实用指南中讨论这个理论。然而，在下一节中，我们将触及类型类的数学性质，并讨论它们必须遵守的数学定律。
- en: Laws
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法则
- en: Type classes are defined in terms of the methods they support. When defining
    a type class, you do not have an idea of how exactly the methods will be implemented
    for every given data type. However, you do have a rough idea of what these methods
    will do. For example, we have a rough idea that `flatMap` is responsible for sequential
    composition, and pure corresponds to lifting a value into an effect type without
    doing anything else.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类是通过它们支持的方法来定义的。在定义一个类型类时，你并没有一个确切的想法知道对于每一个给定的数据类型，这些方法将如何具体实现。然而，你确实有一个大致的概念，了解这些方法将做什么。例如，我们有一个大致的概念，认为`flatMap`负责序列组合，而纯函数对应于将一个值提升到效果类型而不做其他任何事情。
- en: This kind of information regarding how the methods should behave can be encapsulated
    in terms of the mathematical laws that the type class must obey. In fact, the
    majority of type classes can be viewed from a mathematical perspective, and so
    there are certain laws that they must obey.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the laws that Monads must obey. There are three of them,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Left identity**: `pure(a).flatMap(f) == f(a)`. This means that if you have
    a raw value, `a`, and a function, `f`, which takes that value as an input and
    computes an effect type out of it, the effect of applying this function directly
    on `a` should be the same as if you first used the `pure` function on `a` and
    flatMapped the result with `f`.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Right identity**: `m.flatMap(pure) == m`. This means that a pure function
    must lift a value into the effect type without performing any other action. The
    effect of this function is nil. This also means that if you are using the `flatMap`
    function on pure, pure must behave as an identity, meaning the effect type you
    flatMapped will be equal to the result of flatMapping.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Associativity**: `m.flatMap(f).flatMap(g) == m.flatMap(a => f(a).flatMap(g))`.
    Basically, this law states that the precedence of the `flatMap` application do
    not matter. Think of the associativity in the context of the `+` operator—`(a
    + b) + c == a + (b + c)`.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the majority of type classes out there, you should expect some mathematical
    laws to be defined. The meaning of them is that they provide certain guarantees
    that you can rely on when programming your software. For every concrete implementation
    of the `Monad` type class, the preceding mathematical laws must hold true. For
    any other type class, all of its implementations must obey its own laws.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Since there is a requirement for every type class implementation to obey certain
    laws, it is reasonable to expect that all of your implementations must be tested
    with respect to these laws. Since the laws are not dependent on a particular implementation
    of a type class and should hold true for every implementation of the type class,
    it is also reasonable to have the tests defined in the same library that defines
    the type classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: We do this so that we do not need to redefine these tests every time. Indeed,
    these tests are defined in a separate module of the `Cats` library—`cats-laws`.
    The module defines the laws for every cats type class and provides an integration
    with the majority of popular test frameworks so that once you define your own
    implementation of a type class, you do not need to define the tests to check this
    implementation against the mathematical laws.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is how tests for Monad are defined:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, let us discuss how to use methods defined by `Monad` conveniently from
    the Scala code with `Cats`. Let us have a look at what infrastructure `Cats` provides
    to expose methods on effect types.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should mention here that the requirement to use the implicit mechanism with
    a *Rich Wrapper* pattern is a requirement that's specific to Scala. Scala is a
    language that mixes object-oriented and purely functional styles. This is why
    certain functional programming features such as type classes are not a part of
    the language and are implemented in a more generic way instead. This means that
    in Scala, method injection and the type class pattern are not first-class citizens.
    They are not defined at the language level. Instead, they leverage a more general
    mechanism that is defined on the class level—the implicit mechanism. Hence, in
    order to seamlessly use type classes in a Scala project, you need to use this
    mechanism so that they take effect manually.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: A note should be taken that this may not be true for other functional languages.
    For example, Haskell has language-level support for the type class style of programming.
    This is why you don't need to bother with method injection. This is because the
    language itself does all of the necessary work for you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: However, languages such as Scala that do not have first-class citizen support
    for style may require you to use such a mechanism. The exact approaches to type
    class programming may vary from language to language. In this section, we will
    take a look at how this works for Scala.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'We previously discussed that method injection in Scala happens with the help
    of the implicit mechanism and the *Rich Wrapper* pattern. Since this kind of mechanism
    to inject methods is defined for every type class, it makes sense to define the
    required Rich Wrappers in the `Cats` library together with all of the type classes.
    This is indeed done in the `Cats` library, in the `syntax` package, like following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a746d62-f06f-4c52-90e1-b2f9fd93c7fb.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: The package contains a set of classes and traits. What you need to notice are
    the naming conventions they follow. You will see that lots of the traits and classes
    end in `Ops` and `Syntax`, for example, `MonadOps` or `MonadSyntax`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Besides classes and traits, you will also notice a set of singleton objects
    are present in this package. The names of these objects mimic the names of the
    type classes they are defined for.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this mechanism works for the `Monad` type class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73859f8e-f26d-4159-a9de-a7e3e4a1a574.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: First, let's take a look at the `MonadOps` class. This is a Rich Wrapper that
    is supposed to be used for `Monad` method injection. It injects the methods provided
    by the `Monad` type class into an effect type, `f`. One thing to notice about
    the methods it injects is that all of them have an implicit `Monad` argument.
    They delegate their implementation to this type class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `MonadOps` class is not an implicit class—it is an ordinary class.
    We learned previously that for the *Rich Wrapper* pattern, we need an implicit
    conversion from an effect type to the Rich Wrapper. So, where is this conversion
    defined, and how is it brought into scope? To find out, let''s take a look at
    the `MonadSyntax` trait:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/074e0741-687d-457e-a8e2-14cc3aefbf88.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `MonadSyntax` contains implicit methods. These are supposed
    to convert any object, `F[A]`, into `MonadOps[F[A]]`. However, how do you bring
    the methods into scope?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, let''s take a look at the Monad singleton:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1332acf1-bb04-4a99-b52a-3a0bcec796c2.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, the singleton extends the `MonadSyntax`
    trait. So basically, this is a concrete implementation of the `MonadSyntax` trait.
    You can import all of the contents of this object, and you will have the Rich
    Wrapper for `MonadOps`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Why is it implemented as a combination of a singleton and a trait? Would it
    not be more convenient to implement the Rich Wrapper as one singleton object that
    contains all of the required methods?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: This can be understood if you take a look at the sheer amount of singleton objects
    present in the `syntax` package. If you are using a lot of type classes in a single
    Scala file, all of the imports for each type class can be tedious to write and
    track. Hence, you might want to just bring in scope the syntax for all available
    type classes at once, even though you will never use the majority of them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Precisely for this reason, there is an `all` singleton object, as shown in
    the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51ef1905-4d96-45f3-a975-db8a94c2971a.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: If you take a look at this object and its supertypes, you'll see that its ancestors
    constitute a massive list. They include all of the syntax traits defined in the
    package. This means that this singleton object contains all of the implicit conversion
    from effect types to Rich Wrappers that inject methods defined in the type classes
    into the effect types in question. You can import all of the contents of this
    object into your project and have all of these implicit conversions in scope.
    This is exactly why we define implicit conversions inside the trait and not inside
    singleton objects. If you define these implicit conversions as part of singleton
    objects, you will not be able to combine these singleton objects into one object,
    because you cannot inherit from a singleton object. However, you can inherit from
    multiple traits in Scala. Therefore, the reason for having traits is modularity
    and composability.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the `Cats` library contains two major components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: It contains the Rich Wrapper classes that wrap effect types and inject methods
    defined by the type classes into these effect types
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains implicit conversions from these effect types to the Rich Wrapper
    classes
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this chapter, we will see examples of how to use these capabilities
    in practice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at the structure and the purpose of the `instances`
    package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Instances
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `instances` package exposes the following API:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af1ffeec-e2b4-40b3-91b0-7abca12e0880.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, the `instances` package contains
    quite a lot of entities. As in the case of the `syntax` package, the main thing
    to notice here is the naming convention of these entities. First, we have a set
    of traits and classes. They are named as follows—the first part of the name is
    the name of the type for which the instances are defined, and then there's the
    `Instances` suffix.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: There are also singleton objects, which are named after the types for which
    the instances are defined.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what one of the instances traits looks like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8398a71f-5910-43e2-9d41-37fd43946f58.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see the structure of the `FutureInstances`
    trait. All of the methods are defined as `implicit` methods, which means they
    will be brought into the implicit scope whenever the members of this trait are
    imported. Another important thing to notice is the result types of the methods.
    These result types are all some kind of type class. It is the meaning of these
    methods to provide the implicit implementations of various type classes for a
    given effect type. Also notice that the trait contains a lot of methods for various
    type classes, but all of them are parametrized by the `Future` type. All of the
    type classes are implemented for this effect type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the case of the `syntax` package, the traits are then used to
    create singleton objects. For example, let''s take a look at the `future` singleton:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bb931b8-754c-4440-a36a-c97d9c48bf18.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'The `future` singleton object extends the `FutureInstances` trait, and the
    same pattern repeats for all of the other singleton objects present in the `instances`
    package. The reason for having the singletons extending the traits is similar
    to the situation with the `syntax` package:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc1a769f-6656-47ae-a76d-d46b9d0b40ee.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: The package also defines an `all` singleton object, which extends all of the
    other traits present in the package. The value of this strategy is that in order
    to bring the standard implementations of type classes in scope, all you need to
    do is import the contents of the `all` object. You do not need to import the implementation
    separately for every type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's take a look at the last essential part of the `Cats` library,
    that is, the `data` package.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Data
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us now discuss the `data` package, which is another package you will use
    a lot in daily functional programming with `Cats`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ba84616-5235-4e68-87b5-0701bae792c6.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Previously, we discussed that the main utility of having a library such as `cat`
    is to abstract away the common type classes for functional programming. We have
    also seen that not only do the type classes get abstracted, but also all of the
    various kinds of supporting stuff to use them in practice efficiently. This supporting
    stuff includes the mechanism for syntax injection and the default implementations
    for commonly encountered effect types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: A final piece of the supporting infrastructure that cats provides is a set of
    common effect types. These are encapsulated under the `data` package. Under this
    package, you will encounter various data types that you can use to express your
    side effects in a purely functional way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: For example, there are data types such as `Reader`, `Writer`, and others. The
    effect types are often not related one to another, and you can really use each
    of them independently.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure synergy
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we have seen how cats defines its type classes and how it can
    be used in functional programming. The main points to understand about the `Cats`
    library are regarding the supporting infrastructure that it provides to you as
    a functional programmer, and how exactly to use it in practice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The supporting infrastructure in questions provides a set of the type classes,
    their implementations for the commonly encountered data types, and a mechanism
    to inject their methods into your effect types. Also, cats provides a set of commonly
    encountered effect types.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The library is very modular, and you can use various parts of it independently
    from the rest of the library. So, it is a good strategy for beginner programmers
    so that they can simply start with one or two basic type classes and use the library
    to bring them in scope. As you gradually progress as a functional programmer,
    you will start to pick up and familiarize yourself with more and more type classes
    and chunks of this library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have familiarized ourselves with the general structure of
    the `Cats` library. In the rest of this chapter, we will familiarize ourselves
    with certain commonly encountered type classes. We will see how to use them in
    practice. We will also have a look at some of the mechanics for how the type classes
    are implemented.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Type classes
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have performed a bird's-eye overview of the `Cats` library and its
    structure. In this section, we'll have a look at some individual type classes
    from the `Cats` library that are frequently used in real-world projects. For every
    such type class, will take a look at the motivation as to why it exists. We will
    discuss their methods and behavior in detail. We will also take a look at examples
    of the usage of the type class. Finally, we will take a look at the implementation
    of the type class for various effect types, and take a look at how the class is
    implemented for popular types so that you have an idea of what an implementation
    of the type class might look like.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Monad
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us have a look at how you can use type classes from the `Cats` library on
    an example of `Monad`, the type class we are already familiar with.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, in order to use a `Monad` type class, we defined it
    as ad hoc. However, the `Cats` library provides all of the abstractions we need
    so that we don't need to define this type class and its syntax ourselves.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you use the `Monad` type class in the context of the logging example
    from [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The Idea of the
    Type Classes*? As you may recall, in that chapter, we took a look at an example
    of logging capabilities and discussed that it is a good example of the sequential
    composition that can be handled by Monad. So, let''s take a look at how this can
    be done with `cats`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First of all, we no longer need to define the trait of Monad ourselves as well
    as its companion object where we normally defined the syntax for it. All we need
    to do is perform some imports from cats. In the preceding code, you can see that
    first of all we perform an import of the `Monad` type from the `cats` package,
    and then we import the syntax for the Monad. We have already discussed how this
    mechanism works in the previous section of this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can define the method  from [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The
    Idea of the Type Classes*, for adding two integers and writing to the login process,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the definition looks exactly the same as the one from [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml),
    *The Idea of the Type Classes*. However, the semantics is a bit different. The
    Monad type comes from the `cats` package and is not defined as ad hoc.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in order to use the type class with the `SimpleWriter` effect type that
    we defined in [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The Idea
    of the Type Classes*, we still need to add an implementation of the Monad for
    this data type. We can do so as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Actually, `cats` already provides a type similar to our `SimpleWriter` effect
    type that is intended precisely for logging. Let us now discuss how to get rid
    of `SimpleWriter` in favor of the capabilities `cats` provides.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Writer effect type
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Writer effect type provides us with a bit more of a generic type class than
    the `SimpleWriter` implementation. However, if we use it, we do not need to define
    the `SimplerWriter` type, as well as an implementation of the type classes for
    it. Since cats provides the implementation of its type classes for its data types,
    we don't need to worry about doing this ourselves.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, our `SimpleWriter` object is essentially a pair. The first
    element of the pair is a list of strings which represents all of the logging messages
    that were logged by a computation. The other object of a pair is a value that
    was computed by the computation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The cats implementation of the `Writer` object is essentially very similar to
    our simpler Writer implementation, except the first element of a pair is not a
    list of strings but an arbitrary type. This has a certain utility, because now
    you have the ability to use it for logging data structures other than lists of
    strings.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SimpleWriter` that we are using can be expressed in terms of the cats
    Writer if we explicitly specify the type in which the log messages are stored:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/556bd98d-0ac0-445e-b5ec-8628c4b34067.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see the documentation of the Writer singleton
    object from the `data` package. This object can be used to write log messages
    into a Writer effect type. The two most important methods over here are `tell`
    and `value`. The `tell` method writes a message into the log and the `value` method
    lifts an arbitrary value into the Writer data structure with an empty log message.
    The Writer data type has a `Monad` instance that defines how to sequentially compose
    two Writers. During the sequential composition, the logs of two effect types are
    combined into one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you look through the `data` package of `cats`, you will discover that
    there is no trait or class called Writer. The real name of the Writer data type
    is `WriterT`. One thing to remember about `cats` is that it aims to provide highly
    generic and abstract tools that can be used in a wide range of different scenarios.
    So, in this particular situation, the technique of Monad Transformers is used,
    hence why is has the strange name of `WriterT`. For the time being, you don't
    need to worry about the Monad Transformers, and you can use the Writer type, which
    is defined in `cats` in terms of `WriterT`. The Writer singleton provides a convenient
    set of methods to deal with it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Since the Writer data type is a standard data type of `cats`, we can replace
    our custom `SimpleWriter` with the Writer that comes from `cats`, and we can also
    remove the Logging type class from our application altogether. The reason we do
    this is to standardize on the `Cats` library. This standardization makes the code
    more compact, eliminates redundancy, and increases reliability. We do this because
    we are using standard tools instead of reinventing them ad hoc.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: In the code snippet, you can see an implementation of an addition method from [Chapter
    7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The Idea of the Type Classes,* using
    the capabilities from `cats` that we discussed previously.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The tailRecM method
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously in this section, we touched on the `tailRecM` method briefly. It
    is pretty useful in certain situations, because it allows you to define loops
    in the context of an effect type. In this subsection, let''s take a more detailed
    look at its signature and at how this method works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77354c52-e187-496e-944b-788b880e01d4.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the arguments of this method. First of all, let's take
    a look at the second argument of this method, the `f` function. The function takes
    a raw value of type `A`, and the result of this function is an effect type, which
    is `F[Either[A, B]]`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about what we can do with this computation to make a loop out of
    it. Suppose that we start from some value, `A`. Suppose that we run the computation
    `f` on this value. Then, our result is of the type `F[Either[A, B]]`. There are
    two possibilities of what exactly this type will be—either `F[Left[A]]` or `F[Right[B]]`.
    If it is `F[Left[A]]`, then we are able to use `flatMap` on `F[Left[A]]`; after
    that, we can extract `A` from `Left`, and then we can run the computation `f`
    again on that `A`. If it is the `F[Right[B]]`, there is nothing left to do but
    return the result of the computation, that is, `F[B]`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: So, the function passed to `tailRecM` will run on argument `A` while it produces
    the results of type `F[Left[A]]`. Once it produces `F[Right[B]]`, this result
    is counted as the final result and is returned from the loop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Basically, if we have the ability to perform a `flatMap` on the effect type
    `F`, we are also able to define a loop based on `flatMap`. However, why is it
    an abstract method? If all it takes to make a loop is the ability to perform `flatMap`,
    then why can we not define it as a concrete method implemented in terms of `flatMap`?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we might want to try and do that. Consider the implementation of the
    Monad for our `SimpleWriter` example, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we have a `tailRecM` in terms of `flatMap`. What happens
    if we try an infinite loop?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code results in a `StackOverflowError`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This error occurs most frequently in the scenario of a recursive call where
    we run out of stack frames of memory that are allocated for us by the JVM.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Every time you perform a method call, a specific memory fragment is allocated
    by the JVM for all of the variables and parameters of that method call. This memory
    fragment is called a stack frame. So, if you are calling a method recursively,
    you will have the number of stack frames growing proportionally to the depths
    of your recursion. The memory you can use for the stack frames is set on the JVM
    level and is usually up to 1 MB, and it is fairly easy to run into its limit with
    a deep enough recursion.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: However, there are situations when you do not need to create additional stack
    frames in cases of recursion. Here, we are talking about tail recursion. Basically,
    you are able to drop the previous stack frame of recursion if it is no longer
    needed. This situation arises if there is nothing else to do in the method owning
    the stack frame, and the result of this method is fully dependent on the result
    of the subsequent calls of the recursion.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the following example of a factorial computation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, the `factorial` function is defined recursively. So,
    in order to compute a factorial of a number `n`, you first need to compute a factorial
    of `n-1`, and then multiply it by `n`. When we call the factorial method recursively,
    we can ask a question as to whether we need to do anything else in this method
    after the recursive call is done, or if its results are dependent only on the
    method that we are calling recursively. More precisely, we are talking about whether
    we need to do anything else after the factorial call inside the `factorial` function.
    The answer is that we need to perform one more step to complete the computation.
    This step is the multiplication of the result of the factorial call by the number
    `n`. So, until this step is completed, we are not able to drop the frame of the
    current call. However, consider the `factorial` method, which is defined as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, when we are calling the `factorial` method, we can
    ask ourselves the following question—do we have anything else to do in the method
    in order to complete its computation after the call to the `factorial` method?
    Or is the result of this method fully dependent on the result of the `factorial`
    method we are calling in this place? The answer is that we do not need to do anything
    else here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The Scala compiler can recognize such situations and perform optimization in
    places where recursion can reuse the stack frames of the previous reclusive calls.
    This situation is called **tail recursion.** In general, such calls are much more
    efficient than ordinary recursion because you cannot get a Stack Overflow with
    them, and in general their speed is comparable to the speed of an ordinary `while`
    loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you can explicitly make a requirement on a method so that it''s tail
    recursive in Scala, like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, the first method will not compile because it is not
    tail recursive while annotated with `@tailrec`. The Scala compiler will perform
    a check for all the methods annotated with `@tailrec` so see whether they're tail
    recursive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit our case of `tailRecM`. From the name, you can now guess that
    this method is supposed to be tail recursive. Now, let's recall our naive implementation
    of this method for `SimpleWriter`. Its execution resulted in a stack overflow
    exception. This is because, here, the recursion is split into several methods.
    So if you take a look at the stack trace output, you can see that the output is
    periodic. There are two methods repeating in this output—`flatMap` and `tailRecM`.
    The Scala compiler is not able to prove that the method is tail recursive in such
    a periodic recursion situation. In principle, you can think of a way to optimize
    recursion even in this, but Scala compiler cannot do that.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, let''s see what happens if you try to declare the `tailRecM` method with
    the `@tailrec` annotation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see that the code stops compiling because the method is not recognized
    as tail recursive:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The point of having this method as an abstract method is precisely because
    you must implement it, not in terms of `flatMap` (which would inevitably lead
    to periodic recursion), but in terms of a single tail recursive method. For example,
    in the context of `SimpleWriter`, we can come up with such an implementation such
    as the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code snippet, as you can see, we have an implementation of
    `tailRecM` in a tail recursive manner. Notice that we are still using techniques
    similar to the ones that we are using in the `flatMap` function. However, these
    techniques are wrapped in a single method which is tail recursive.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'One remark should be made, and that is that not every Monad implementation
    has an implementation of `tailRecM`. Frequently, you will find scenarios where
    `tailRecM` just throws a `NotImplementedError`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `???` syntax is used in Scala to conveniently throw such an error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed a `flatMap` in the context of composition of side
    effecting computations. Now, let's take a look at an example of the composition
    of a side effecting computation with a non-side effecting computation. Let's take
    a look at Functor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another frequently encountered type class in functional programming is Functor.
    Functor is all about the map function in its essence. As you may recall from the
    previous chapters, the `map` function is very similar to `flatMap` function; however,
    it takes a non-side effecting computation as its argument. It is used to transform
    a value within the context of a effect type when this transformation is not side
    effecting itself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: You might want to use a Functor if you want to do something with the result
    of a side effecting computation without extracting it from its effect type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, we used an intuition of sequential composition in the case
    of the `flatMap` of a Monad. This intuition may not be the best one for Functor.
    In the case of `map`, we can use another intuition of function, changing a value
    under the effect type. The operation that is abstracted away in this case is one
    of extracting the value from an effect type. The `map` method asks you only about
    what you want to do with the result of a side-effecting computation, without demanding
    from you and information about how exactly to extract this result from the effect
    type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of the `Monad` type class, we have already discussed the `map`
    method in detail in the previous sections, so we will not be stopping on this
    type class for long. All we will do is take a look at how you might want to use
    it with the `Cats` library.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the classes defined by the `Cats` library for Functor:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/def275eb-529e-48ac-a367-c3b7ad143bc1.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see the documentation and the definition
    of the Functor type class. Now, let''s take a look at what its implementation
    may look like for our `SimpleWriter` type. First of all, let''s recall the definition
    of the `SimpleWriter` data type:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to provide an implementation of the Functor type class from the
    `Cats` library. We will do some imports from the `Cats` library:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we are performing an import of the Functor type from
    the `cats` package (by importing `cats._`). After that, we must import the syntax
    for this type class (by importing `cats.implicits._` imports all the syntax and
    instances for all the type classes). So, whenever we have an implementation of
    the type class in scope, we will also have the syntax for it injected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s provide the implementation of the Functor type class for `SimpleWriter`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, you can see a simple implementation of the Functor type
    class for `SimpleWriter`. As you can see, all we need to do is implement the `map`
    method of this type class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, once we have created some very simple instances of the effect type,
    we are able to call the `map` method on it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, the `map` method gets injected into our effect type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: One question you might be asking is, what is the point is this? If Functor and
    Monad both define the `map` method, why have Functor at all? Why not have the
    Monad implementation for every type class where we need the `map` method and not
    bother with the Functor class at all? The answer is that not every effect type
    has the `flatMap` method implementation for it. So, an effect type might have
    an implementation of `map`, but it may be impossible to define a `flatMap` on
    it. Hence, the `Cats` library provides a fine-grained structure of its type class
    hierarchy so that you can use it according to your own needs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed type classes for sequential composition. Now, let's
    take a look at the case of parallel composition and how the Applicative type class
    handles it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Applicative
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing how to compose computations in sequence is a basic skill that enables
    procedural programming to take place. This is something that we rely upon by default
    when we use imperative programming languages. When we write two statements in
    sequence, we implicitly mean that these two statements are supposed to be executed
    one after another.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: However, sequential programming is not capable of describing all the programming
    situations, especially if you're working in the context of an application that
    is supposed to run in parallel. There may be lots of situations where you may
    want computations composed in parallel. This is exactly where the Applicative
    type class comes into play.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider that we have two independent computations. Suppose we have two computations
    that evaluate mathematical expressions, and then we need to combine their results.
    Also, suppose that their computation is performed under the `Either` effect type.
    So, the main idea is that either of the two computations can fail, and if one
    of them fails, it is the result of interpretation being left with an error, and
    if it succeeds, the result is  `Right` of some result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, you can see how you can combine two such computations
    sequentially using the `Monad` type class. Here, we are using for comprehensions
    to compute the result of the first computation, and then the second computation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a scenario where one of these computations goes wrong:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can see two situations and two outputs. The first one is where the first
    computation goes wrong and the second one is where the second computation goes
    from. So basically, the result of the combined computation will be `Left` if either
    both of the two computations fail.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: What happens if both of these computations fail?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see an output of the situation where both of these computations fail.
    An error the first computation only gets an output. This is because they are composed
    sequentially, and the sequence is terminated on the first error. The behavior
    of the Monad for `Either` is to terminate sequential composition if `Left` is
    encountered.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This kind of scenario may not always be desirable, especially in large applications
    that consist of a large amount of various modules that can fail. In such an application,
    for debugging purposes, you would like to collect as much information about the
    errors that have occurred as possible. If you're only collecting one error at
    a time, and you have dozens of independent computations that fail, you will have
    to debug them one at a time because you will not have access to the entire set
    of errors that have occurred. This is because only the first error encountered
    will be reported, even though the computations are independent on one another.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The reason why this scenarios happens is because of the very nature of the way
    we have composed our computations. They are composed sequentially. The nature
    of sequential composition is to run computations one after another, even if they
    are not dependent on one another's results. Since these computations run one after
    another, it is only natural to interrupt an entire sequence if an error has occurred
    in one of the links of the chain.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This solution to the preceding scenario would be to compose independent computations
    in parallel instead of in sequence. So, they should all be run independently one
    from another, and their results should be combined in some manner after they finish.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Applicative type class
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would like to define a new primitive for the preceding scenario. We can
    call this method `zip`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The method will take two computations as its arguments, and it will output a
    combined result of two of its supplied inputs as a tuple under their common effect
    type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we are dealing with specific cases of `Left` being a list of
    strings. This is to combine multiple error strings for multiple failed computations
    into one error report.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The way it works is that if both compilations are successful, their results
    are combined into a pair. Otherwise, if either of these computations fails, their
    errors are collected in a combined list.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the new method, `zip`, we can express the preceding example as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that here we're making the use of `zip` to create combined versions of
    two independent computations, and addressing the fact that we are using the `map`
    method to do something with the result of this computation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we can express the `zip` function in terms of a more generic `ap`
    (short for `apply`) function. It is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is how we can express the `zip` function in terms of the `ap` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The actual meaning of the `ap` function is a more generic way to express the
    combination of two independent computations running together. The trick is that
    the first computation results in some function, `F[A => B]`, and the second computation
    is raw computation, `F[A]`. The point about this function and why it is different
    from the `zip` function in a qualitative way is as follows. Intervention is composition
    plus execution. It composes some value lifted into effect type `F`, together with
    a computation, `A => B`, that works on this value, which is also lifted into the
    context `F`. Since at composition time we already deal with effect types, we already
    have the independent computations finished. Compare that to the case of `flatMap`,
    where one of the arguments is a function, `A => F[B]`, that outputs an effect
    type. So, in the case of `flatMap`, one of the competitions is a function that
    is going to be executed. It is the responsibility of `flatMap` to execute it and
    obtain the result `F[B]`. This cannot be said about `ap`, which already has access
    to the results that the effect types computed—`F[A => B]` and `F[A]`. Hence, there
    is independence of computations. Since one of the values of the computed effect
    types is a function, `A => B`, it is not only a composition in terms of zipping
    into a pair, but also an execution that's similar to mapping.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the `ap` function comes from the `Apply` type class, which is an
    ancestor of Applicative:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5db63dd-576a-4fe0-b27c-adac657fbae9.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: However, you will encounter Applicative versions of the type class that extend
    the `Apply` type class more frequently. The only difference between these type
    classes is that Applicative also has the `pure` function, which is used to lift
    a raw value, `a`, into the same effect type, `F`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Applicative also has a bunch of useful concrete methods defined in terms of
    `ap`. There is also some nice syntactic sugar support that `cats` provides for
    you so that you can use Applicative in your projects in an intuitive way. For
    example, you can perform a `map` on two values at once, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can use the syntactic sugar that `cats` injects in tuples in order to easily
    work with such kind of cases of parallel computation. So, you can just unite two
    effect types under a tuple and map them with the Applicative type class in scope.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the type class
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at how the type class can be implemented for a data type.
    For example, let''s look at `Either`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can see how the type class can be implemented for `Either` with `Left` being
    `List[String]`. So, as you can see, if two computations are successful, that is,
    they are `Right`, we simply combine them. However, if at least one of them is
    `Left`, we combine the `Left` side of both computations into a single `Left[List[String]]`.
    This is done specifically in mind for the cases where several independent computations
    may produce errors that you might want to combine under a single data structure.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that we are using a pretty specific case of `Either`—the
    one where `Left` is always a `List[String]`. We have done this because we need
    a way to combine the `Left` sides of two computations into one, and we are not
    able to combine generic types. The preceding example can be generalized further
    to the arbitrary version of the type of `Left`, `Either[L, A]`. This can be done
    with the help of the `Monoid` type class, which we will learn about next. So,
    let's take a look at this type class and see where it can be useful.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Monoid
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monoid is another popular type class that you will frequently encounter in practice.
    Basically, it defines how to combine two data types.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: As an example of Monoid, let's take a look at the implementation of an Applicative
    type class for the `Either` data type. In the previous section, we were forced
    to use a specific version of `Either`, the one with `Left` set to a list of strings.
    This was done precisely because we know how to combine two lists of strings, but
    we do not know how to combine any two generic types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'If we define the signature of this preceding Applicative as follows, then we
    will not be able to provide a decent implementation of this function because we
    will not be able to combine two generic types:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you tried to write an implementation of this function, it would look something
    like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are using a special operator, `|+|`, in order to describe the operation of
    combining two data types we know nothing about. However, since we know nothing
    about the data types we are trying to combine, the code will not compile. We cannot
    simply combine two arbitrary data types because the compiler does not know how
    to do that.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'This situation can be changed if we make the Applicative type class implicitly
    depend on another type class that does know how to implicitly combine these two
    data types. Meet Monoid:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b8f98c4-c89d-4aa5-a17b-682bf0a1179b.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'The Monoid type class extends `Semigroup`. `Semigroup` is a mathematical structure
    of from. It is a type class that is defined as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a1fd818-e5ee-4247-8abd-0f0260f0c9ff.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Basically, `Semigroup` is defined in the context of abstract algebra and Set
    Theory. Given a set, a `Semigroup` is a structure on this set that defines an
    operator that can combine two arbitrary elements of a set to produce another element
    of the same set. So, for any two elements of a set, you are able to combine them
    using this operator to produce another element that also belongs to this set.
    In the language of programming, `Semigroup` is a type class that can be defined,
    as shown in the preceding screenshot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that `Semigroup` defines a single method
    called `combined`. It takes two arguments of type `A` and returns another value
    of type `A`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'An intuitive way to understand `Semigroup` is to have a look at the addition
    operation on integers:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In addition operation on integers, `+` is an operator that can be used to combine
    any two arbitrary integers to obtain another integer. Hence, the operation of
    addition forms a `Semigroup` on the set of all possible integers. The `Semigroup`
    type class in `cats` generalizes this idea to any arbitrary type, `A`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at our Monoid example, we can see that it extends a `Semigroup`
    and adds another method to it, which is called `empty`. Monoid must obey certain
    laws. One of these laws is that the `empty` element must be an identity with respect
    to the `combined` operation. This means that the following equalities must hold
    true:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So basically, if you try to combine an empty identity element with any other
    element of set `A`, you will get that same element as a result.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'An intuitive way to understand this point is to have a look at the operation
    of the addition of integers:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see an implementation of the Monoid for integers. If we take the operation
    to be an addition, then `0` is an empty element. Indeed, if you add `0` to any
    other integer, you will get this integer as a result. `0` is an identity element
    with respect to the addition operation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'This remark, *with respect to the addition operation*, is really important
    to notice. For example, `0` is not an identity element with respect to multiplication.
    In fact, if you multiply `0` by any other element, you will get `0` and not that
    other element. Speaking of multiplication, we can define a Monoid for integers
    with the operation of multiplication and the identity element being one, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Actually, `cats` defines some nice syntactic sugar for Monoids. Given the preceding
    definition of that Monoid for integers for the multiplication operation, we can
    use it as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can see how you can use an infix operator, `|+|`, in Scala to combine two
    elements. The preceding code is equivalent to the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a common practice in `cats` in order to define such kinds of symbolic
    operators for frequently encountered operators. Let us have a look at how `Applicative`
    can be implemented for `Either` with `Monoid` as its dependency.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Another library for functional programming, ScalaZ, is more aggressive than
    `cats` with respect to operator usage, and hence it can be more difficult to understand
    for a beginner. `cats` is more friendly in this respect. The reason symbolic operators
    are less friendly is because their meaning is not immediately obvious from the
    name. For example, the preceding operator, `|+|`, can be pretty ambiguous for
    somebody who is looking at it for the first time. However, the `combine` method
    gives you a very solid idea of what it does.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Implementation for Either
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with Monoid and had a look at how it
    is used in the context of simple types such as integer, let's take a look at our
    previous example, the example of `Either` with a generic type of `Left`—`Either[L,
    A]`. How can we define the Applicative instance for a generic `Left` type? Previously,
    we saw that the body of the `ap` function for a generic `Left` type is not very
    different from the body of this function for the list. The only problem was that
    we didn't know how to combine two arbitrary types.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'This combination sounds like exactly the task for Monoid. So, if we bring the
    implicit dependency on Monoid into scope, we can define the `ap` and Applicative
    type class for the `Either` type as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see an implicit implementation of the Applicative type class that is
    also dependent on an implicit implementation of the `Monoid` type class for the
    `Left` type of `Either`. So, what happens is that the Applicative type class will
    be implicitly resolved, but only if it's possible to implicitly resolve the Monoid
    for the `Left` type's value. If there is no implicit implementation of Monoid
    for `Left` in scope, we will not be able to generate Applicative. This makes sense,
    because the body of Applicative depends on the functionality provided by Monoid
    in order to define its own functionality.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The only thing to notice about the body of the `ap` function is that it now
    uses the `|+|` operator in order to combine the left elements if both computations
    result in an error.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: One peculiarity to notice about Monoid is that it is said it is defined not
    for an effective, but for an ordinary type. So, if you look at the signature of
    Monoid again, it is of the kind `Monoid[A]`, not the kind of `Monoid[F[A]]`. So
    far, we have only encountered the type classes that work on effect types, that
    is, the types of the kind `F[A]`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: What is the reason for the existence of type classes that work on raw types
    and not effect types? To answer this question, let's remember what the motivation
    for the existence of ordinary type classes that we are familiar with so far was.
    The main motivation for their existence was that certain operations with effect
    types were not convenient to accomplish. We had the need to abstract certain operations
    with effect types. We needed an abstraction to define tools that work on the effect
    types.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Effect types are usually data structures, and it is pretty hard to work with
    them ad hoc. You are not usually able to work with them using the capabilities
    built into your language conveniently. Hence, we encountered difficulties working
    with these data types on every corner if we did not have a toolset defined for
    them. Hence, the need for type classes manifests itself mostly for effect types.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Ordinary types like `A` are usually not as hard to work with as data structures.
    Hence, the need for tools and for abstractions over these data types is less obvious
    than for the effect types. However, as we saw previously, there are situations
    where type classes can be useful for raw types as well. The reason we had to define
    a separate type class Monoid for a raw type is in the fact that we needed to generalize
    the feature that the type must be composable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we can hardly do that using any other technique than type classes.
    An ordinary approach of object-oriented programming to the problem of making sure
    a datatype exposes certain functionality is interfaces. Interfaces must be declared
    at definition time of the class implementing them. So, for example, there is no
    single interface to specify that lists, integers, and strings are composable with
    another with the same method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The only way to specify such an exposure of certain functionality is to define
    an interface as ad hoc. But ordinary object-oriented programming does not provide
    you with the capability to inject interfaces into already implemented classes.
    This cannot be said about type classes. With type classes, whenever you want to
    capture that a type exposes a certain functionality, you can define a type class
    as ad hoc. You can also define in which way exactly a class exhibits this functionality
    by defining and implementing this type class for this particular class. Notice
    exactly when it is done. This operation can be done in any part of the program.
    So, whenever you need to make it explicit that a type exhibits certain functionality
    and has this functionality in common with other types, you are able to do so by
    defining a type class that captures this functionality.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: This kind of extensibility provides you with a greater level of flexibility
    that is hard to achieve with ordinary object-oriented programming techniques such
    as, for example, those in Java. In fact, it can be argued that it is sufficient
    for the programmer to drop the object-oriented style of interfaces altogether
    and resort to only using the type classes. In the style of programming Haskell
    is based on, there is a strict separation of data and behavior.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: MonoidK
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we saw the version of Monoid that works on all types. A version
    of Monoid also exists that operates on effect types, that is, on the types of
    the kind of `F[A]`. This type class is called `MonoidK`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9518c592-e97f-40ca-89fe-c850a3020a58.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: So, as you can see, the method is defined for an effect type, and instead of
    the `combined` method that works on two types, `A`, `MonoidK` defines a method
    called `combineK`, which works on values of type `F[A]`. Also notice that this
    method is parametrized by the type `A` on the method level and not on the level
    of the type class itself, which means that you can have the single type class
    defined for some effect type, `F[_]`, and you can use it for arbitrary `A` in
    the context of `F[A]`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'This example can be useful when combining lists. While it is not really an
    effect type, because a `List` is a data structure that does not encapsulate any
    side effects, it is still a type of the form `F[A]`. We can imagine an implementation
    of `combinedK` for it as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, in the preceding code, we are able to implement the method in a manner that
    is independent of type `A` because the behavior of the combination of two lists
    is independent of the type of the elements that are contained in them. This combination
    is just a concatenation of the elements of one list with the elements of another
    list to form one combined list.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Also notice the `algebra` method here. This method can be used to obtain a `Monoid`
    instance from the `MonoidK` instance. This can be useful in cases where you need
    a `Monoid` instance, but you only have `MonoidK`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Traverse
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we learned about the Applicative type class. We argued that the
    main utility of the Applicative type class is that it allows us to combine two
    independent computations in parallel. No longer are we bound by the `flatMap`
    function that performs sequential composition, so that if one computation fails
    then no other computation is ever performed. In the Applicative scenario, all
    of the computations are performed, despite the fact that some of them can fail.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: However, Applicative is only able to combine two independent computations. There
    are also methods to combine up to 22 computations into tuples. However, what if
    we need to combine an arbitrary amount of computations? The usual generalization
    for multiplicity is collections. Tuples are just special cases of collections.
    So, if there is a type class for combining independent computations into tuples,
    there must be a type class for combining independent computations into collections.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this scenario, consider our example we we're working with in Applicative
    case. What if we have an arbitrary list of mathematical expressions computed under
    the parallel operator, and we have a function that is supposed to combine them
    by summing them up? What might such a function look like?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, the preceding function takes a list of the results of the computations,
    and its job is to produce a combined result of all of the computations. This result
    will be of the type `Either[List[String], List[Double]]` type, which means that
    we also need to aggregate all of the errors that happened in all of the computationals
    we are trying to combine. How would we go about it in the case of Applicative?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is take the first element of the list, combine it with the
    second element of the list using the `ap` function, add the results together to
    obtain an `Either` as a result, and combine this result with the third element,
    and so on.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, there is a type class to perform just that. Meet the `Traverse` type
    class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca9ec1bf-e863-4365-a00a-36b5c5eb9a10.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'The main point of interest of the `Traverse` type class is the `traverse` method.
    Let''s take a look at its signature:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The signature of this method is very abstract. So, let's give all the types
    involved a little bit more context. In the preceding signature, consider that
    type `F` is a collection type. Consider that type `G` is an effect type.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: This means that traverse takes a collection as its first argument—a collection
    of some arbitrary raw elements, `A`. The second argument is similar to what we
    saw in `flatMap`. It is a side effecting computation that works on the elements
    of the collection we saw as the first argument. So, the idea is that you have
    a collection of some elements, `A`, and a computation that you can run on these
    elements, `A`. However, this computation is side effecting. The side effects from
    this computation are wrapped into the effect type `G`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if you ran such a computation on every element of the collection?
    What would happen if you map collection `F` with the help of this operation?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The result type that you would expect to get is this: `F[G[B]]`. So, you will
    get a collection of effect types that are the results of the computation that
    you've run on every element of the original collection.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our example of `Either` that we need to combine together, we would
    get the following result:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, we are not looking for this. We are looking to obtain a list of all
    the results of our computation under the effect type `Either`. In the case of
    Applicative, the `ap` method was taking the results of side effecting computations
    and combining them under their common effect type. So, in the case of `ap` and
    `zip` based on it, we had the following results:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, in our generalized case, the role of tuple is replaced by `List`. Therefore,
    we are aiming for the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let's return to our `traverse` function. Let's take a look at its result
    type. The result of this function is `G[F[B]]`. `G` is an effect type. `F` is
    a collection type. So, all of the results of the computations are combined into
    a single collection under an effect type, `G`. This is precisely what we were
    aiming at in the case of `Either`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: So, this makes `Traverse` a more generic case of Applicative that can be used
    for situations where you do not know how many computations you are going to combine
    ahead of time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution here. We have also discussed that the type `F` is a collection
    type and that the type `G` is an effect type. You should remember that this constraint
    is not encoded into a type class itself. We have imposed this constraint in order
    to be able to develop an intuition for the type class. So, potentially, you might
    come up with some more advanced uses of the `Traverse` type class that go beyond
    this collection. However, in your projects, you will be using it in the context
    of collections the most frequently.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what our example might look like with the help of `Traverse`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can further enhance this example if we use the `combineAll` method from
    the `Traverse` type class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The examples are introduced in the context of the following type classes that
    are defined:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`combinedAll` works on some collection, `F[A]`, and produces the result `A`
    out of this collection, given `Monoid[A]` in scope. The Monoid defines how to
    combine two elements, `A`, into one element, `A`. `F[A]` is a collection of elements, `A`.
    So, given a collection of elements, `A`, `combineAll` is capable of combining
    all of the elements and computing a single result, `A`, with the help of the Monoid
    in scope that defines a binary composition operation.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice here is that the type classes of `cats` form an ecosystem
    and frequently depend one on another. In order to obtain an instance of a certain
    type class for a certain type, you might discover that it is implicitly dependent
    on an instance of another type class. For other type classes, you can discover
    that some of its methods are dependent on some other type class implicitly, just
    like in the case of `combineAll` depending on Monoid.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: This connection can be used to the advantage of a learner of purely functional
    programming. This kind of ecosystem means that you can start very small. You can
    start by using one or two type classes that you understand. Since the `Cats` library
    forms an ecosystem of dependent type classes, you will encounter situations where
    your familiar type classes will depend on type classes that you still do not know.
    Therefore, you will need to learn about the other type classes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Other things that we need to notice about the type classes that we have learned
    about so far is that they are pretty generic and language independent. What it
    encodes is the relationships and the transformations between types. This can be
    encoded in any language of your choosing. For example, in Haskell, the language
    is built around the idea of type classes. So, if you look at Haskell, you will
    find that it also contain the type classes that we have covered in this chapter.
    As a matter of fact, there is an entire mathematical theory that deals with these
    concepts and defines the type classes that we have covered, called the **category
    theory**. That means that we could have discussed type classes from a mathematical
    perspective without touching programming at all. Therefore, the concepts of the
    type classes are language independent and have a solid mathematical foundation.
    We have extensively covered a library that is specific to Scala, but the concepts
    that we have covered are language independent. In one form or another, they are
    implemented in all of the languages that support purely functional styles.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had an in-depth look at the system of type classes used
    in purely functional programming. We take a look at the library, that is, a standard
    library for purely functional programming. We had our first look at the structure
    of the library and we found out that it is composed of separate models for the
    type classes, the syntax, and the effect types.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Then, we had an in-depth look at some type classes that are defined by the library.
    We saw the motivation for their existence, as well as their implementation and
    usage details. One thing to remember about all of the type classes is that they
    are not Scala specific. In fact, there is an entire mathematical theory that deals
    with them in a manner that is independent from any programming language at all.
    This is called category theory. So, if you know the concepts from one programming
    language, we are able to use them in any programming language that supports the
    functional style.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Cats provides us with effective functional programming tools. However, we need
    higher-level libraries to write industrial-grade software such as web application
    backends. In the next chapter, we will see more advanced functional libraries
    that build on the basic ones.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the motivation to organize type classes into libraries?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What methods does Traverse define?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which real-world scenario would we use Traverse in?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What methods does Monad define?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which real-world scenario would we use Monad in?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the structure of the Cats library?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
