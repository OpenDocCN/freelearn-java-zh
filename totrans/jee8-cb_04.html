<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Web- and Client-Server Communication</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Web development is one of the greatest ways to use Java EE. Actually, since before J2EE times, we could use JSP and servlets, and that's how web development using Java began.</p>
<p class="mce-root">This chapter will show some advanced features for web development that will make your application faster and better—for you and for your client!</p>
<p class="mce-root">This chapter covers the following recipes:</p>
<ul class="calibre13">
<li class="calibre14">Using servlet for request and response management</li>
<li class="calibre14">Building UI with template features using JSF</li>
<li class="calibre14">Improving response performance with Server Push</li>
</ul>
<p class="mce-root"> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using servlets for request and response management</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Servlets are the core place to deal with requests and responses using Java EE. If you are still not familiar with it, know that even a JSP is nothing more than a way to build a servlet once the page is called.</p>
<p class="mce-root">This recipe will show you three features you can use when using servlets:</p>
<ul class="calibre13">
<li class="calibre14">Load on startup</li>
<li class="calibre14">Parameterized servlets</li>
<li class="calibre14">Asynchronous servlets</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Start by adding the dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The load on startup servlet</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's start with our servlet that will load on the server's start up:</p>
<pre class="calibre21">@WebServlet(name = "LoadOnStartupServlet", urlPatterns = {"/LoadOnStartupServlet"}, <br class="calibre2"/>loadOnStartup = 1)<br class="calibre2"/>public class LoadOnStartupServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void init() throws ServletException {<br class="calibre2"/>        System.out.println("*******SERVLET LOADED <br class="calibre2"/>                           WITH SERVER's STARTUP*******");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A servlet with init params</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now we add a servlet with some parameters for its own initialization:</p>
<pre class="calibre21">@WebServlet(name = "InitConfigServlet", urlPatterns = {"/InitConfigServlet"}, <br class="calibre2"/>        initParams = {<br class="calibre2"/>                @WebInitParam(name = "key1", value = "value1"),<br class="calibre2"/>                @WebInitParam(name = "key2", value = "value2"),<br class="calibre2"/>                @WebInitParam(name = "key3", value = "value3"),<br class="calibre2"/>                @WebInitParam(name = "key4", value = "value4"),<br class="calibre2"/>                @WebInitParam(name = "key5", value = "value5")<br class="calibre2"/>        }<br class="calibre2"/>)<br class="calibre2"/>public class InitConfigServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    Map&lt;String, String&gt; param = new HashMap&lt;&gt;();<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doPost(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp)   <br class="calibre2"/>    throws ServletException, IOException {<br class="calibre2"/>        doProcess(req, resp);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp) <br class="calibre2"/>    throws ServletException, IOException {<br class="calibre2"/>        doProcess(req, resp);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    private void doProcess(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp) <br class="calibre2"/>    throws IOException{<br class="calibre2"/>        resp.setContentType("text/html");<br class="calibre2"/>        PrintWriter out = resp.getWriter();<br class="calibre2"/>        <br class="calibre2"/>        if (param.isEmpty()){<br class="calibre2"/>            out.println("No params to show");<br class="calibre2"/>        } else{<br class="calibre2"/>            param.forEach((k,v) -&gt; out.println("param: " + k + ", <br class="calibre2"/>                                        value: " + v + "&lt;br /&gt;"));<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void init(ServletConfig config) throws ServletException {<br class="calibre2"/>        System.out.println("init");<br class="calibre2"/>        List&lt;String&gt; list = <br class="calibre2"/>        Collections.list(config.getInitParameterNames());<br class="calibre2"/>        list.forEach((key) -&gt; {<br class="calibre2"/>            param.put(key, config.getInitParameter(key));<br class="calibre2"/>        });<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The asynchronous servlet</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">And then we implement our asynchronous servlet:</p>
<pre class="calibre21">@WebServlet(urlPatterns = "/AsyncServlet", asyncSupported = true)<br class="calibre2"/>public class AsyncServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    private static final long serialVersionUID = 1L;<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest request,<br class="calibre2"/>            HttpServletResponse response) throws ServletException, <br class="calibre2"/>            IOException {<br class="calibre2"/>        <br class="calibre2"/>        long startTime = System.currentTimeMillis();<br class="calibre2"/>        System.out.println("AsyncServlet Begin, Name="<br class="calibre2"/>                + Thread.currentThread().getName() + ", ID="<br class="calibre2"/>                + Thread.currentThread().getId());<br class="calibre2"/><br class="calibre2"/>        String time = request.getParameter("timestamp");<br class="calibre2"/>        AsyncContext asyncCtx = request.startAsync();<br class="calibre2"/><br class="calibre2"/>        asyncCtx.start(() -&gt; {<br class="calibre2"/>            try {<br class="calibre2"/>                Thread.sleep(Long.valueOf(time));<br class="calibre2"/>                long endTime = System.currentTimeMillis();<br class="calibre2"/>                long timeElapsed = endTime - startTime;<br class="calibre2"/>                System.out.println("AsyncServlet Finish, Name="<br class="calibre2"/>                        + Thread.currentThread().getName() + ", ID="<br class="calibre2"/>                        + Thread.currentThread().getId() + ", Duration="<br class="calibre2"/>                        + timeElapsed + " milliseconds.");<br class="calibre2"/><br class="calibre2"/>                asyncCtx.getResponse().getWriter().write<br class="calibre2"/>                ("Async process time: " + timeElapsed + " milliseconds");<br class="calibre2"/>                asyncCtx.complete();<br class="calibre2"/>            } catch (InterruptedException | IOException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        });<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">And finally, we need a simple web page to try all those servlets:</p>
<pre class="calibre21">&lt;body&gt;<br class="calibre2"/>    &lt;a href="${pageContext.request.contextPath}/InitConfigServlet"&gt;<br class="calibre2"/>    InitConfigServlet&lt;/a&gt;<br class="calibre2"/>    &lt;br /&gt;<br class="calibre2"/>    &lt;br /&gt;<br class="calibre2"/>    &lt;form action="${pageContext.request.contextPath}/AsyncServlet" <br class="calibre2"/>     method="GET"&gt;<br class="calibre2"/>        &lt;h2&gt;AsyncServlet&lt;/h2&gt;<br class="calibre2"/>        Milliseconds<br class="calibre2"/>        &lt;br /&gt;<br class="calibre2"/>        &lt;input type="number" id="timestamp" name="timestamp" <br class="calibre2"/>        style="width: 200px" value="5000"/&gt;<br class="calibre2"/>        &lt;button type="submit"&gt;Submit&lt;/button&gt;<br class="calibre2"/>    &lt;/form&gt;<br class="calibre2"/><br class="calibre2"/>&lt;/body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The load on startup servlet</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If you want your servlet to be initialized when the server starts, then this is what you need. Usually you will use it to load some cache, start a background process, log some information, or whatever you need to do when the server has just started and can't wait until somebody calls the servlet.</p>
<p class="mce-root">The key points of this kind of servlet are:</p>
<ul class="calibre13">
<li class="calibre14">The <kbd class="calibre16">loadOnStartup</kbd> param: Accepts any number of servlets. This number defines the order used by the server to run all the servlets that will run in the startup. So if you have more than one servlet running this way, remember to define the right order (if there is any). If there's no number defined or a negative one, the server will choose the default order.</li>
<li class="calibre14">The <kbd class="calibre16">init</kbd> method: Remember to override the <kbd class="calibre16">init</kbd> method with the operation you would like to do at the start up time, otherwise your servlet will do nothing.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A servlet with init params</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Sometimes you need to define some parameters for your servlet that goes beyond local variables – <kbd class="calibre16">initParams</kbd> is the place to do it:</p>
<pre class="calibre21">@WebServlet(name = "InitConfigServlet", urlPatterns = <br class="calibre2"/>{"/InitConfigServlet"}, <br class="calibre2"/>        initParams = {<br class="calibre2"/>                @WebInitParam(name = "key1", value = "value1"),<br class="calibre2"/>                @WebInitParam(name = "key2", value = "value2"),<br class="calibre2"/>                @WebInitParam(name = "key3", value = "value3"),<br class="calibre2"/>                @WebInitParam(name = "key4", value = "value4"),<br class="calibre2"/>                @WebInitParam(name = "key5", value = "value5")<br class="calibre2"/>        }<br class="calibre2"/>)</pre>
<p class="mce-root">The <kbd class="calibre16">@WebInitParam</kbd> annotation will handle them for you and those parameters will be available for the server through the <kbd class="calibre16">ServletConfig</kbd> object.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Asynchronous servlet</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's split our <kbd class="calibre16">AsyncServlet</kbd> class into pieces so we can understand it:</p>
<pre class="calibre21">@WebServlet(urlPatterns = "/AsyncServlet", asyncSupported = true)</pre>
<p class="mce-root">Here, we defined our servlet for accepting async behavior by using the <kbd class="calibre16">asyncSupported</kbd> param:</p>
<pre class="calibre21">AsyncContext asyncCtx = request.startAsync();</pre>
<p class="mce-root">We used the request being processed to start a new async context.</p>
<p class="mce-root">Then we start our async process:</p>
<pre class="calibre21">asyncCtx.start(() -&gt; {...</pre>
<p class="mce-root">And here we print our output to see the response and finish the async process:</p>
<pre class="calibre21">                asyncCtx.getResponse().getWriter().write("Async <br class="calibre2"/>                process time: " <br class="calibre2"/>                + timeElapsed + " milliseconds");<br class="calibre2"/>                asyncCtx.complete();</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">To get the full source code of this recipe, check <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-servlet" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-servlet</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building UI with template's features using JSF</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <strong class="calibre7"><span class="calibre8">JavaServer Faces</span></strong> (<strong class="calibre7"><span class="calibre8">JSF</span></strong>) is a powerful Java EE API for building outstanding UIs, using both client and server features.</p>
<p class="mce-root">It goes much further than when you are using JSP, as you are not only using Java code inside HTML code, but actually really referencing code injected in the server context.</p>
<p class="mce-root">This recipe will show you how to use the Facelet's template feature to get more flexibility and reusability from your layout template.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Start by adding the dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's first create our page layout with a header, content section, and footer:</li>
</ol>
<pre class="mce-root2">&lt;h:body&gt;<br class="calibre2"/>    &lt;div id="layout"&gt;<br class="calibre2"/>        &lt;div id="header"&gt;<br class="calibre2"/>            &lt;ui:insert name="header" &gt;<br class="calibre2"/>                &lt;ui:include src="header.xhtml" /&gt;<br class="calibre2"/>            &lt;/ui:insert&gt;<br class="calibre2"/>        &lt;/div&gt;<br class="calibre2"/>        &lt;div id="content"&gt;<br class="calibre2"/>            &lt;ui:insert name="content" &gt;<br class="calibre2"/>                &lt;ui:include src="content.xhtml" /&gt;<br class="calibre2"/>            &lt;/ui:insert&gt;<br class="calibre2"/>        &lt;/div&gt;<br class="calibre2"/>        &lt;div id="footer"&gt;<br class="calibre2"/>            &lt;ui:insert name="footer" &gt;<br class="calibre2"/>                &lt;ui:include src="footer.xhtml" /&gt;<br class="calibre2"/>            &lt;/ui:insert&gt;<br class="calibre2"/>        &lt;/div&gt;<br class="calibre2"/>    &lt;/div&gt;<br class="calibre2"/>&lt;/h:body&gt;</pre>
<ol start="2" class="calibre19">
<li class="chapter">Define the default header section:</li>
</ol>
<pre class="mce-root2">&lt;body&gt;<br class="calibre2"/>    &lt;h1&gt;Template header&lt;/h1&gt;<br class="calibre2"/>&lt;/body&gt;</pre>
<ol start="3" class="calibre19">
<li class="chapter">The default content section:</li>
</ol>
<pre class="mce-root2">&lt;body&gt;<br class="calibre2"/>   &lt;h1&gt;Template content&lt;/h1&gt;<br class="calibre2"/>&lt;/body&gt;</pre>
<ol start="4" class="calibre19">
<li class="chapter">The default footer section:</li>
</ol>
<pre class="mce-root2">&lt;body&gt;<br class="calibre2"/>   &lt;h1&gt;Template content&lt;/h1&gt;<br class="calibre2"/>&lt;/body&gt;</pre>
<ol start="5" class="calibre19">
<li class="chapter">And then a simple page using our default template:</li>
</ol>
<pre class="mce-root2">&lt;h:body&gt;<br class="calibre2"/>    &lt;ui:composition template="WEB-INF/template/layout.xhtml"&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;/ui:composition&gt;<br class="calibre2"/>&lt;/h:body&gt;</pre>
<ol start="6" class="calibre19">
<li class="chapter">Now, let's create another page and override just the content section:</li>
</ol>
<pre class="mce-root2">&lt;h:body&gt;<br class="calibre2"/>    &lt;ui:composition template="/template/layout.xhtml"&gt;<br class="calibre2"/>        &lt;ui:define name="content"&gt;<br class="calibre2"/>            &lt;h1&gt;&lt;p style="color:red"&gt;User content. Timestamp: #<br class="calibre2"/>            {userBean.timestamp}&lt;/p&gt;&lt;/h1&gt;<br class="calibre2"/>        &lt;/ui:define&gt;<br class="calibre2"/>    &lt;/ui:composition&gt;<br class="calibre2"/>&lt;/h:body&gt;</pre>
<ol start="7" class="calibre19">
<li class="chapter">As this code is calling <kbd class="calibre16">UserBean</kbd>, let's define it:</li>
</ol>
<pre class="mce-root2">@Named<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class UserBean implements Serializable{<br class="calibre2"/><br class="calibre2"/>    public Long getTimestamp(){<br class="calibre2"/>        return new Date().getTime();<br class="calibre2"/>    }<br class="calibre2"/>  <br class="calibre2"/>}</pre>
<ol start="8" class="calibre19">
<li class="chapter">Also, don't forget to include the <kbd class="calibre16">beans.xml</kbd> file inside the <kbd class="calibre16">WEB-INF</kbd> folder; otherwise, this bean will not work as expected:</li>
</ol>
<pre class="mce-root2">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="calibre2"/>&lt;beans <br class="calibre2"/>       <br class="calibre2"/>       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee <br class="calibre2"/>       http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd"<br class="calibre2"/>       bean-discovery-mode="all"&gt;<br class="calibre2"/>&lt;/beans&gt;</pre>
<p class="mce-root">If you want to try this code, run it in a Java EE compatible server and access the following URLs:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">http://localhost:8080/ch04-jsf/</kbd></li>
<li class="calibre14"><kbd class="calibre16">http://localhost:8080/ch04-jsf/user.xhtml</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The explanation is as simple as possible: the <kbd class="calibre16">layout.xhtml</kbd> is our template. As long as you name each section (in our case its header, content, and footer), whatever JSF page that uses it will inherit its layout.</p>
<p class="mce-root">Any page using this layout and wanting to customize some of those defined sections, should just describe the desired section like we did in the <kbd class="calibre16">user.xhtml</kbd> file:</p>
<pre class="calibre21">&lt;ui:composition template="/template/layout.xhtml"&gt;<br class="calibre2"/>    &lt;ui:define name="content"&gt;<br class="calibre2"/>        &lt;h1&gt;&lt;font color="red"&gt;User content. Timestamp: #<br class="calibre2"/>            {userBean.timestamp}<br class="calibre2"/>        &lt;/font&gt;&lt;/h1&gt;<br class="calibre2"/>    &lt;/ui:define&gt;<br class="calibre2"/>&lt;/ui:composition&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">To get the full source code of this recipe, check <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-jsf" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-jsf</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improving the response performance with Server Push</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the main features of HTTP/2.0 is the Server Push. When it is available, that means, being supported by the protocol, the server, and the browser client—it lets the server send ("push") data to the client before it asks for it.</p>
<p class="mce-root">It is one of the most wanted features in JSF 2.3 and probably the one that demands less effort to use if your application is based on JSF—just migrate to a Java EE 8 compatible server and then you are done.</p>
<p class="mce-root">This recipe will show you how to use it in your application and will even let you compare the performance between HTTP/1.0 and HTTP/2.0 in the same scenario.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Start by adding the dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This recipe has only this single servlet:</p>
<pre class="calibre21">@WebServlet(name = "ServerPushServlet", urlPatterns = <br class="calibre2"/>{"/ServerPushServlet"})<br class="calibre2"/>public class ServerPushServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest request, <br class="calibre2"/>    HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        doRequest(request, response);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    private void doRequest(HttpServletRequest request,<br class="calibre2"/>    HttpServletResponse response) throws IOException{<br class="calibre2"/>        String usePush = request.getParameter("usePush");<br class="calibre2"/>        <br class="calibre2"/>        if ("true".equalsIgnoreCase(usePush)){<br class="calibre2"/>            PushBuilder pb = request.newPushBuilder();<br class="calibre2"/>            if (pb != null) {<br class="calibre2"/>                for(int row=0; row &lt; 5; row++){<br class="calibre2"/>                    for(int col=0; col &lt; 8; col++){<br class="calibre2"/>                        pb.path("image/keyboard_buttons/keyboard_buttons-" <br class="calibre2"/>                                + row + "-" + col + ".jpeg")<br class="calibre2"/>                          .addHeader("content-type", "image/jpeg")<br class="calibre2"/>                          .push();<br class="calibre2"/>                    }<br class="calibre2"/>                }<br class="calibre2"/>            }<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        try (PrintWriter writer = response.getWriter()) {<br class="calibre2"/>            StringBuilder html = new StringBuilder();<br class="calibre2"/>            html.append("&lt;html&gt;");<br class="calibre2"/>            html.append("&lt;center&gt;");         <br class="calibre2"/>            html.append("&lt;table cellspacing='0' cellpadding='0'<br class="calibre2"/>                         border='0'&gt;");<br class="calibre2"/><br class="calibre2"/>            for(int row=0; row &lt; 5; row++){<br class="calibre2"/>                html.append(" &lt;tr&gt;");<br class="calibre2"/>                for(int col=0; col &lt; 8; col++){<br class="calibre2"/>                    html.append(" &lt;td&gt;");<br class="calibre2"/>                    html.append("&lt;img <br class="calibre2"/>                    src='image/keyboard_buttons/keyboard_buttons-" +<br class="calibre2"/>                         row + "-" + col + ".jpeg' style='width:100px;   <br class="calibre2"/>                         height:106.25px;'&gt;"); <br class="calibre2"/>                    html.append(" &lt;/td&gt;"); <br class="calibre2"/>                }<br class="calibre2"/>                html.append(" &lt;/tr&gt;"); <br class="calibre2"/>            }<br class="calibre2"/>            <br class="calibre2"/>            html.append("&lt;/table&gt;");            <br class="calibre2"/>            html.append("&lt;br&gt;");<br class="calibre2"/>            <br class="calibre2"/>            if ("true".equalsIgnoreCase(usePush)){<br class="calibre2"/>                html.append("&lt;h2&gt;Image pushed by ServerPush&lt;/h2&gt;");<br class="calibre2"/>            } else{<br class="calibre2"/>                html.append("&lt;h2&gt;Image loaded using HTTP/1.0&lt;/h2&gt;");<br class="calibre2"/>            }<br class="calibre2"/>            <br class="calibre2"/>            html.append("&lt;/center&gt;");<br class="calibre2"/>            html.append("&lt;/html&gt;");<br class="calibre2"/>            writer.write(html.toString());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">And we creat a simple page to call both HTTP/1.0 and HTTP/2.0 cases:</p>
<pre class="calibre21">&lt;body&gt;<br class="calibre2"/>    &lt;a href="ServerPushServlet?usePush=true"&gt;Use HTTP/2.0 (ServerPush)&lt;/a&gt;<br class="calibre2"/>    &lt;br /&gt;<br class="calibre2"/>    &lt;a href="ServerPushServlet?usePush=false"&gt;Use HTTP/1.0&lt;/a&gt;<br class="calibre2"/>&lt;/body&gt;</pre>
<p class="mce-root">And try it on a Java EE 8 compatible server using this URL:</p>
<p class="mce-root"><kbd class="calibre16">https://localhost:8181/ch04-serverpush</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The image loaded in this recipe was shared in 25 pieces. When there's no HTTP/2.0 available, the server will wait for 25 requests made by <kbd class="calibre16">img src</kbd> (from HTML) and then reply to each one of them with the proper image.</p>
<p class="mce-root">With HTTP/2.0, the server can push them all beforehand. The "magic" is done here:</p>
<pre class="calibre21">            PushBuilder pb = request.newPushBuilder();<br class="calibre2"/>            if (pb != null) {<br class="calibre2"/>                for(int row=0; row &lt; 5; row++){<br class="calibre2"/>                    for(int col=0; col &lt; 8; col++){<br class="calibre2"/>                        pb.path("image/keyboard_buttons/keyboard_buttons-" <br class="calibre2"/>                                + row + "-" + col + ".jpeg")<br class="calibre2"/>                          .addHeader("content-type", "image/jpeg")<br class="calibre2"/>                          .push();<br class="calibre2"/>                    }<br class="calibre2"/>                }<br class="calibre2"/>            }</pre>
<p class="mce-root">To check if your images are loaded using Server Push or not, open the developer console of your browser, go to network monitoring, and then load the page. One of the pieces of information about each image should be who sent it to the browser. If there's something like <span class="calibre8">Push</span> or <span class="calibre8">ServerPush</span>, you are using it!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Server Push will only work under SSL. In other words, if you are using GlassFish 5 and try to run this recipe, your URL should be something like this:</p>
<p class="mce-root"><kbd class="calibre16">https://localhost:8181/ch04-serverpush</kbd></p>
<p class="mce-root">If you miss it, the code will still work, but using HTTP/1.0. means that when the code asks for <kbd class="calibre16">newPushBuilder,</kbd> it will return null (not available):</p>
<pre class="calibre21">if (pb != null) {<br class="calibre2"/>   ...<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">To get the full source code of this recipe, check <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-serverpush" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-serverpush</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>