- en: Chapter 6. Communicating with External Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to add the possibility to communicate with different
    systems in our application. Technically, we will resolve a systems integration
    problem. System integration problems include several cases: two applications that
    exchange data synchronously or asynchronously, an application that accesses information
    provided by another, an application that executes processes implemented in another,
    and so on. Given the number of solutions that exist today, it is necessary to
    know which one to choose depending on the problem, hence the importance of this
    chapter. At the end of this chapter, you will be able to choose an integration
    solution and have an overview of the changes made in the following APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaMail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java EE connector architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java message service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JAX-RS: Java API for RESTful Web Services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaMail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaMail 1.5 Specification was developed under JSR 919\. This section just
    gives you an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html).
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The expansion of the Internet has greatly facilitated communication across the
    world through electronic messages (e-mail). Today, people at the ends of the earth
    can exchange information in a very short time. In order for this to be done, there
    must be a mail server for storage of data exchanged and clients (for example,
    Outlook) for sending and retrieving data. Communication between these elements
    requires different types of protocols, for example, **SMTP** (**Simple Mail Transport
    Protocol**) for sending mails, **POP** **3** (**Post Office Protocol**) for receiving
    mails, **IMAP** (**Internet Message Access Protocol**) for receiving e-mails.
    This multitude of protocols can pose a problem to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Given the multitude of protocols and the difficulties of low-level programming,
    the Java language provides the **JavaMail** API in order to simplify sending and
    retrieving e-mails regardless of the underlying protocols. But the JavaMail API
    is not enough; because it was designed to handle the transmission aspect of the
    message (connection parameter, source, destination, subject, and so on), the body
    of the message is managed by **JavaBeans Activation Framework** (**JAF framework**).
    That is why, in addition to the `mail.jar` library, you have to import the `activation.jar`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Sending an e-mail via the SMTP protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sending an e-mail using JavaMail is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain the `session` object. This object encapsulates various information such
    as the address of the mail server. The following code shows how to get an object
    of type `Session`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct the message. To send an e-mail, it is necessary to define some parameters
    such as the content of the e-mail, the sender, and destination. In addition to
    these settings, you may need to specify the subject of your e-mail and its header.
    All this is made possible through the `MimeMessage` class that offers several
    methods to construct a message for a given session. The following code shows how
    to get an object of type `MimeMessage` and build a mail to send:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the message. We send a message in one line with the `Transport` class.
    The following code shows how to send the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following code shows how to send the results of preregistration for individual
    candidates from a Gmail account. As you can see, the Gmail sender account and
    its password are passed as a parameter to the `send` method. This allows the application
    to be authenticated by the server when sending the message. To test the sending
    code associated with this chapter, you need to have a Gmail account and replace
    `username` with the username of your account and `user_password` with the password
    of this account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of sending an e-mail via Gmail SMTP server
    by using JavaMail API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the JavaMail API provides the ability to retrieve messages, attach
    documents to your messages, write messages in HTML format, and do lots of other
    things.
  prefs: []
  type: TYPE_NORMAL
- en: The latest improvements in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although it is affected by a maintenance release, the JavaMail 1.5 Specification
    has undergone many changes. The most important can be grouped into three categories,
    which are: addition of annotations, addition of methods, and changing of some
    access modifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: The added annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all, JavaMail 1.5 introduced two new annotations (`@MailSessionDefinition`
    and `@MailSessionDefinitions`) to configure JavaMail session resources in a Java
    EE 7 application server.
  prefs: []
  type: TYPE_NORMAL
- en: The `@MailSessionDefinition` annotation contains several parameters (see the
    `Java` class in the following code) with the goal of offering the possibility
    to define a Mail Session that will be registered in any valid Java EE namespace
    and accessed by other components through the **JNDI**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code highlights the attributes of `@MailSessionDefinition` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this annotation, we can now define and use objects of `Session` type as
    in the case of the following code which is an example to show how to use `@MailSessionDefinition`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `@MailSessionDefinition` annotation allows us to define `MailSession`,
    `@MailSessionDefinitions` annotation allows us to configure many `MailSession`
    instances. The following code shows how to define two `MailSession` using instances
    `@MailSessionDefinitions` at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The added methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to ease the developer''s work, JavaMail 1.5 added new methods that
    provide really interesting shortcuts. For example, the addition of the `Transport.send(msg,
    username, password)` method avoids creating additional objects for authentication
    parameters when sending the message. Before this, authentication parameters were
    defined at the `session` object and as you can see with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As another example of an added method, you have the `Message.getSession()` method,
    which allows you to access the `session` type object that was used to create the
    message. This may prevent you from having to drag the session throughout your
    treatment. The last added method that we will talk about is the `MimeMessage.reply(replyToAll,
    setAnswered)` method, which, due to the second parameter, allows you to automatically
    add a `Re` prefix to the subject line when you respond, for example, to a message.
  prefs: []
  type: TYPE_NORMAL
- en: The changing of some access modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Concerning access modifiers, the JavaMail 1.5 Specification has put an emphasis
    on good practice in some classes and facilitated the extension of others.
  prefs: []
  type: TYPE_NORMAL
- en: You will see, for example, that the access modifiers of the protected fields
    in the final classes of the `javax.mail.search` package have been changed to private.
    In fact, it is not important that the final class contains protected fields with
    public `getter`/`setter` method. So it is better to make them private and let
    `getter`/`setter` be public so that we can access/edit their values from outside.
  prefs: []
  type: TYPE_NORMAL
- en: Still, in the changing of access modifier, JavaMail 1.5 has transformed the
    fields `cachedContent` (of classes `MimeBodyPart` and `MimeMessage`) and `MimeMultipart`
    class's fields from private to protected in order to facilitate the extension
    of the relevant classes.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE Connector Architecture (JCA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java EE Connector Architecture 1.7 Specification was developed under JSR
    322\. This section just gives you an overview of improvements in the API. The
    complete document specification (for more information) can be downloaded from
    [http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is JCA?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generally, **Enterprise Information** **Systems** (**EIS**s) of large companies
    are composed of a number of tools such as **Enterprise** **Resource Planning**
    applications (**ERP**, that is **SAP**), **Customer Relationship Management**
    applications (**CRM**, that is [salesforce.com](http://salesforce.com)), mainframe
    Transaction Processing applications, legacy applications and Database Systems
    (such as Oracle). In such an environment, the development of a new solution may
    require access to one or more of these tools to retrieve information or perform
    processing: we then talk of an **Enterprise Application Integration** (**EAI**).
    In the absence of a standard solution, this integration will be costly to both
    vendors and developers. Vendors will develop APIs to manage communication between
    different kinds of servers and developers will address EISs case by case and will
    implement the technical features (connection polling, transaction security mechanism,
    and so on) required by the application. Hence the need for JCA.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java EE Connector Architecture (JCA) is a specification that aims to standardize
    access to heterogeneous existing EISs from Java EE platforms. To this end, it
    defines a set of contracts that enable developers to access the different EISs
    seamlessly from a common interface called the **Common Client Interface** (**CCI**).
    For those who have already been working with **JDBC**, understanding of the functioning
    of JCA is a little easier. A JCA connector consists of two main elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Client Interface** (**CCI**): This API is to EISs as JDBC is to databases.
    In other words, the CCI defines a standard client API that allows components to
    access EISs and perform processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Adapter**: This is a specific implementation of the CCI for a given
    EIS. It is provided by the vendor, which guarantees the execution of the features
    of its EIS through the JCA. The Resource Adapter, is packaged in a `.rar` archive
    called `Resource Adapter Module`, and it must obey some contracts (system level
    contracts) in order to be integrated into a Java EE platform and take advantage
    of services such as Connection, Transaction, and Security Management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, you can consider using JCA when you want to access an EIS that offers
    a Resource Adapter.
  prefs: []
  type: TYPE_NORMAL
- en: JCA in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Failing to take a concrete example that shows you how to access the list of
    employees managed by SAP with a connector (which would be very long), to allow
    you to understand the essential features), the following code shows you just an
    overview of the use of the JCA API. These include the general principle of the
    connection, the possibility of data manipulation, and disconnection.
  prefs: []
  type: TYPE_NORMAL
- en: For those who wish to go further, GlassFish offers a complete example of implementing
    a connector to access a mail server, and the tutorial available at [http://www.ibm.com/developerworks/java/tutorials/j-jca/index.html](http://www.ibm.com/developerworks/java/tutorials/j-jca/index.html),
    provides you additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a overview of interactions with a resource adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Latest improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Talking about novelty, the Java EE Connector Architecture 1.7 was slightly
    improved. Indeed, in this specification, it is more a matter of clarification
    and requirements statements. That said, JCA 1.7 has introduced the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: It insists on the availability of the the application component environment
    namespace of the endpoint to the resource adapter when the `endpointActivation`
    and `endpointDeactivation` methods are called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds `ConnectionFactoryDefinition` and `AdministeredObjectDefinition` annotations
    for defining and configuring the resource adapter's resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It clarifies the behavior of the dependency injection when Managed JavaBeans
    are used as CDI-managed Beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Message Service (JMS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Message Service 2.0 Specification was developed under JSR 343\. This
    section just gives you an overview of improvements in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr343/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: When to use JMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JMS is a Java API for interacting with **Message Oriented Middleware** (**MOM**).
    This type of middleware is born from the need to solve observed limits in synchronous
    connections. This is because synchronous connections are susceptible to network
    failures and require that the connected systems are available at the same time.
    Hence, the MOMs offer an integration system based on the exchange of messages
    that can be treated synchronously or asynchronously depending on the availability
    of the integrated systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows an architecture in which systems communicate through
    MOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When to use JMS](img/9235OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the foregoing, we conclude that JMS can be used in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction processing large amount of data (for example, synchronization of
    databases) through an unstable network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between systems that are not always available simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending of data to multiple systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To finish with this point, you should notice that the establishment of an integration
    system based on JMS requires that all components that need to be integrated be
    under your control. Hence, JMS would be better for the integration of internal
    solutions of a company.
  prefs: []
  type: TYPE_NORMAL
- en: The latest improvements in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Released in March 2002, the JMS 1.1 Specification was getting old and heavy
    compared to other APIs of the Java EE platform that have been simplified through
    the evolution of the platform. Based on this observation, you will understand
    why one of the main goals of JMS 2.0 API was to update the API so that it can
    be as simple as the other APIs of the platform and can integrate easily with them.
    To make this possible, several areas have been reviewed; these include the reduction
    of **boilerplate** code, removing redundant items, adding new features, and integration
    of the novelties of the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: New features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the JMS 2.0 Specification, three new features are highlighted: sending of
    messages asynchronously, delivery delay, and modification of the `JMSXDeliveryCount`
    message property.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages asynchronously
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In synchronous processing, if a method A invokes a method B, method A will remain
    blocked until the method B has completed. This can induce a waste of time. To
    overcome this problem, JMS 2.0 provides a set of methods to send messages asynchronously
    without losing sight of the progress of the operation. The following code demonstrates
    how to send messages asynchronously. The method `setAsync()` takes a listener
    as a parameter, which allows you to be informed at the end of the process or when
    an exception is thrown. If the listener is not null, the message will be sent
    asynchronously (the process will be performed by another thread different from
    the caller's thread). Otherwise, the message will be sent synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Delivery delay
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the possibility of sending messages asynchronously, JMS now permits
    us to defer the time of delivery of a message already in the **broker**, which
    is a MOM server. After sending, the message will be stored at the broker, but
    it will stay unknown to the receiver until the time fixed by the sender. The message
    of the following code will be delivered to the recipient at least one hour after
    sending.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Handling of the JMSXDeliveryCount message property
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since Version 1.1, the JMS Specification has defined an optional `JMSXDeliveryCount`
    message property, which can be used to determine the messages that were delivered
    more than once and apply an action when the number of deliveries exceeds the maximum
    value. But, because the management of this property was optional, all providers
    had no obligation to increment it, which had the effect of making applications
    that used it non portable. The JMS 2.0 Specification has introduced this as standard,
    to allow us to customize the management of **poisonous messages** in a portable
    way. A poisonous message is a JMS message that has exceeded the maximum number
    of deliveries for a given receiver. The following code shows how to retrieve the
    `JMSXDeliveryCount` message property and specify the action to be taken when one
    message has been delivered more that five time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Simplification of the API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JMS 2.0 Specification introduces three new interfaces (`JMSContext`, `JMSProducer`,
    and `JMSConsumer`) which contribute to the elimination of boilerplate code and
    simplifying the API. It is important to note that these interfaces (which constitute
    the simplified API) co-exist with the old interfaces to provide an alternative.
    So `JMSContext` replaces the `Connection` and `Session` objects, `JMSProducer`
    replaces the `MessageProducer` object, and `JMSConsumer` replaces the `MessageConsumer`
    object in the old version. As you can see in the following code, the difference
    between the two approaches is very clear. In the sending method based on JMS API
    1.1 (`sendMessageJMSWithOldAPI`), we note: an excessive object creation, a mandatory
    throw of an exception, and a need to explicitly close connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas, in the sending method based on JMS API 2.0 (`sendMessageJMSWithNewdAPI`),
    we have: the try-with-resources statement that saves the developer from having
    to explicitly close the connection and a send code reduced to the essentials that
    would fit on one line if we had injected `JMSContext` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Java API for RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java API for RESTful Web Services 2.0 Specification was developed under
    JSR 339\. This section just gives you an overview of improvements in the API.
    The complete document specification (for more information) can be downloaded from
    [http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: When to use Web Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Web Service is a software system based on open standards (such as HTTP, XML,
    and URI) and designed to allow exchanges between applications across the network.
    By using these open standards, it has everything required to be the most suitable
    solution for integrating heterogeneous systems. However, as we saw when we were
    talking about JMS, the choice of an integration solution should be made after
    a series of questions: Is the network connection good? Are the processes transactional?
    Is the amount of data to be processed huge? Must processing be synchronous? and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If after investigation, your choice is Web Services, you must now select the
    type of web service to implement : the **SOAP** Web Services based on SOAP (**Simple
    Object Access Protocol**) and XML, or RESTful Web Services that are focused on
    resource sharing and thus their functioning is modeled on the Web. In this book,
    we will only discuss RESTful Web Services.'
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful Web Services are a variant of Web Services in which any concepts that
    can be addressed (functionality or data) are considered as resources and therefore
    can be accessed through **Uniform Resource Identifiers** (**URI**s). Once located,
    the representation or state of the resource is transferred in the form of an XML
    or a JSON document. In the case of our online preregistration application, the
    resources may be the list of selected students and the representation will be
    in a JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS is the Java API to implement RESTful Web Services. The following code
    demonstrates how to write a REST service that returns a list of all students who
    were selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The latest improvements in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JAX-RS 2.0 not only simplified the implementation of RESTful Web Services, but
    also introduced new features in the API, among which we have client API, asynchronous
    processing, filters, and interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: The Client API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Version 1.0, the JAX-RS Specification did not define client APIs to interact
    with a RESTful service. So, each implementation provided a proprietary API, which
    had the effect of limiting the portability of applications. JAX-RS 2.0 fills this
    gap by providing a standard client API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the implementation of a client that will access
    the list of selected students through the REST service exposed in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the standardization of the client API, JAX-RS 2.0 has integrated
    a feature already present in many of the APIs of the Java EE platform, which is
    asynchronous processing. It is now possible for a JAX-RS client to send requests
    or process responses asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates how a JAX-RS client can perform a get request
    asynchronously and wait for the response passively. As shown in the code, the
    execution of a JAX-RS request asynchronously requires a call to the `async()`
    method. This method returns an object of type `AsyncInvoker` whose get, post,
    delete, and put methods allow us to obtain the object type `Future` that will
    be used for further processing of the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of the execution of a asynchronous process
    in a JAX-RS client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the processing is executed asynchronously, we have defined a
    break of 20 seconds in the `getListOfAllStudentsAs` method before executing the
    JPQL queries. The following code,which is a simulation of a slow processing, shows
    the contents of the method executed by the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the JAX-RS servers are able to run processes asynchronously. The
    method that contains the instructions to perform the task asynchronously must
    inject an object of type `AsyncResponse` as a method parameter with the `@Suspended`
    annotation. However, you should know that the asynchronous mode of the server
    differs from the asynchronous mode of the client; the former consists of suspending
    the client connection from which the request was send during the processing of
    the request before resuming it later through the `resume()` method of the object
    `AsyncResponse`. The method itself will not run asynchronously. To make it asynchronous,
    you must either delegate the process to a thread (that is what we did in the `getListOfAllStudentsAs2`
    method of the following example), or decorate it with the `@Asynchronous` annotation.
    The following code demonstrates how to perform asynchronous processing at the
    server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of the execution of a process asynchronously
    in a JAX-RS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Filters and entity interceptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another big ticket of the JAX-RS 2.0 Specification is the introduction of two
    mechanisms for interception: filters and interceptors. These new features bring
    to the specification a standard way to intercept processing in order to seamlessly
    manage security, compression, encoding, logging, editing, and auditing of exchanges
    between a JAX-RS server and the different clients that will access the server
    resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the two concepts are very similar (as they all relate to interception),
    we must say that the filter is often used for the processing of the headers of
    requests or responses. Whereas, interceptors are generally set up to manipulate
    the content of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JAX-RS 2.0 specification defines four types of filters: two types of filters
    on each side (client and server). On the client side, one filter that must be
    run before sending the HTTP request implements the `ClientRequestFilter` interface
    and the other filter, which must be run immediately after the receipt of the response
    from the server, (but before the control is rendered to the application) implements
    the `ClientResponseFilter` interface. On the server side, the filter that will
    be executed before the access to a JAX-RS resource implements the `ContainerRequestFilter`
    interface and the filter that will run just before the response is sent to the
    client implements the `ContainerResponseFilter` interface. The following code
    shows an example of `ContainerRequestFilter` implementation that verifies the
    information that ensures a secure access to the resources available to external
    users of our online preregistration application. The `@Provider` annotation on
    top of the `MyJaxRsRequestFilter` class in the following code allows the filter
    to be automatically discovered by the container and applied to all resources of
    the server. Failing to use this annotation, you must manually registered the filter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of `ContainerRequestFilter` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Entity interceptors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the differences noted between filters and entity interceptors,
    JAX-RS provides two types of entity interceptors instead of four. There is a reader
    interceptor that implements the `ReaderInterceptor` interface and a writer interceptor,
    which implements the `WriterInterceptor` interface. Due to the elements that they
    are supposed to handle (message bodies), interceptors can be used to compress
    large content to optimize network utilization; they can also be used for some
    processing such as the generation and verification of digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the database of our online preregistration application will contain
    thousands of students, the following code demonstrates how we can take advantage
    of interceptors in the data exchange with the Ministry of Education in order to
    avoid network overloading when transmitting information about students.
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows the implementation of `WriterInterceptor` (on the server
    side) that will compress data to send to the JAX-RS client. The `@ZipResult` annotation
    allows us to bind the interceptor only to some JAX-RS resources. If we remove
    this annotation, all JAX-RS resources of our application will be automatically
    compressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a `WriterInterceptor` implemention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To bind the `MyGzipWriterJaxRsInterceptor` interceptor to a resource, we will
    only decorate the given resource with the `@ZipResult` annotation. The following
    code demonstrates how to bind `MyGzipWriterJaxRsInterceptor` interceptor to a
    resource so that its representation can be always compressed before being sent
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of of interceptor binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is an example of the declaration of `@ZipResult` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following code shows the implementation of the `ReaderInterceptor` interface
    (on the client side) that will decompress the data compressed by the server with
    the `MyGzipWriterJaxRsInterceptor` class:.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To bind the interceptor to a particular client, we will use the `register`
    method of the `Client` object. The following code demonstrates how to associate
    an interceptor or a filter to a JAX-RS Client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the analysis of the online preregistration application presented in the
    previous chapter, we realized that our system should communicate with other systems.
    This chapter has given us the knowledge to identify and implement the best way
    to exchange data with different kinds of heterogeneous systems. In the next chapter,
    we will revisit some concepts that we have used in a natural way so that you have
    a better understanding of them.
  prefs: []
  type: TYPE_NORMAL
