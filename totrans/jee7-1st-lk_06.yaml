- en: Chapter 6. Communicating with External Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 与外部系统通信
- en: 'In this chapter, we are going to add the possibility to communicate with different
    systems in our application. Technically, we will resolve a systems integration
    problem. System integration problems include several cases: two applications that
    exchange data synchronously or asynchronously, an application that accesses information
    provided by another, an application that executes processes implemented in another,
    and so on. Given the number of solutions that exist today, it is necessary to
    know which one to choose depending on the problem, hence the importance of this
    chapter. At the end of this chapter, you will be able to choose an integration
    solution and have an overview of the changes made in the following APIs:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加在应用程序中与不同系统通信的可能性。从技术上讲，我们将解决系统集成问题。系统集成问题包括几种情况：两个同步或异步交换数据的程序，一个访问由另一个程序提供的信息的应用程序，一个执行在另一个程序中实现的过程的应用程序，等等。鉴于今天存在的解决方案数量，了解根据问题选择哪种解决方案是必要的，因此本章的重要性。在本章结束时，你将能够选择一个集成解决方案，并对以下API所做的更改有一个概述：
- en: JavaMail
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaMail
- en: Java EE connector architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE连接器架构
- en: Java message service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java消息服务
- en: 'JAX-RS: Java API for RESTful Web Services'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS：Java API for RESTful Web Services
- en: JavaMail
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaMail
- en: The JavaMail 1.5 Specification was developed under JSR 919\. This section just
    gives you an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JavaMail 1.5规范是在JSR 919下开发的。本节仅为您概述API的改进。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html)下载。
- en: Sending e-mails in Java
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中发送电子邮件
- en: The expansion of the Internet has greatly facilitated communication across the
    world through electronic messages (e-mail). Today, people at the ends of the earth
    can exchange information in a very short time. In order for this to be done, there
    must be a mail server for storage of data exchanged and clients (for example,
    Outlook) for sending and retrieving data. Communication between these elements
    requires different types of protocols, for example, **SMTP** (**Simple Mail Transport
    Protocol**) for sending mails, **POP** **3** (**Post Office Protocol**) for receiving
    mails, **IMAP** (**Internet Message Access Protocol**) for receiving e-mails.
    This multitude of protocols can pose a problem to the developer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的扩展极大地促进了通过电子邮件（电子邮件）在全球范围内的通信。今天，地球上两端的人们可以在非常短的时间内交换信息。为了实现这一点，必须有用于存储交换数据的邮件服务器和客户端（例如，Outlook）用于发送和检索数据。这些元素之间的通信需要不同类型的协议，例如，**SMTP**（**简单邮件传输协议**）用于发送邮件，**POP**
    **3**（**邮局协议**）用于接收邮件，**IMAP**（**互联网消息访问协议**）用于接收电子邮件。这种协议的多样性可能会给开发者带来问题。
- en: Given the multitude of protocols and the difficulties of low-level programming,
    the Java language provides the **JavaMail** API in order to simplify sending and
    retrieving e-mails regardless of the underlying protocols. But the JavaMail API
    is not enough; because it was designed to handle the transmission aspect of the
    message (connection parameter, source, destination, subject, and so on), the body
    of the message is managed by **JavaBeans Activation Framework** (**JAF framework**).
    That is why, in addition to the `mail.jar` library, you have to import the `activation.jar`
    library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于协议众多和底层编程的困难，Java语言提供了**JavaMail** API，以便简化发送和检索电子邮件，无论底层协议如何。但JavaMail API并不足够；因为它被设计来处理消息的传输方面（连接参数、源、目标、主题等），消息体由**JavaBeans
    Activation Framework**（**JAF框架**）管理。这就是为什么，除了`mail.jar`库之外，你还需要导入`activation.jar`库。
- en: Sending an e-mail via the SMTP protocol
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过SMTP协议发送电子邮件
- en: 'Sending an e-mail using JavaMail is done as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaMail发送电子邮件的方法如下：
- en: 'Obtain the `session` object. This object encapsulates various information such
    as the address of the mail server. The following code shows how to get an object
    of type `Session`:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`session`对象。此对象封装了各种信息，例如邮件服务器的地址。以下代码展示了如何获取类型为`Session`的对象：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Construct the message. To send an e-mail, it is necessary to define some parameters
    such as the content of the e-mail, the sender, and destination. In addition to
    these settings, you may need to specify the subject of your e-mail and its header.
    All this is made possible through the `MimeMessage` class that offers several
    methods to construct a message for a given session. The following code shows how
    to get an object of type `MimeMessage` and build a mail to send:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建消息。要发送电子邮件，必须定义一些参数，例如电子邮件的内容、发件人和目的地。除了这些设置外，您可能还需要指定电子邮件的主题和其标题。所有这些都可以通过提供构建给定会话消息的几个方法的`MimeMessage`类来实现。以下代码展示了如何获取`MimeMessage`类型的对象并构建要发送的邮件：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Send the message. We send a message in one line with the `Transport` class.
    The following code shows how to send the message:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送消息。我们使用`Transport`类在一行中发送消息。以下代码展示了如何发送消息：
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following code shows how to send the results of preregistration for individual
    candidates from a Gmail account. As you can see, the Gmail sender account and
    its password are passed as a parameter to the `send` method. This allows the application
    to be authenticated by the server when sending the message. To test the sending
    code associated with this chapter, you need to have a Gmail account and replace
    `username` with the username of your account and `user_password` with the password
    of this account.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何从Gmail账户发送个别候选人的预注册结果。如您所见，Gmail发件人账户及其密码作为参数传递给`send`方法。这使得应用程序在发送消息时可以通过服务器进行认证。要测试与本章相关的发送代码，您需要有一个Gmail账户，并将`username`替换为您的账户用户名，将`user_password`替换为该账户的密码。
- en: 'The following code is an example of sending an e-mail via Gmail SMTP server
    by using JavaMail API:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用JavaMail API通过Gmail SMTP服务器发送电子邮件的示例：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, the JavaMail API provides the ability to retrieve messages, attach
    documents to your messages, write messages in HTML format, and do lots of other
    things.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，JavaMail API提供了检索消息、将文档附加到您的消息、以HTML格式编写消息以及执行许多其他操作的能力。
- en: The latest improvements in action
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最新改进在行动中
- en: 'Although it is affected by a maintenance release, the JavaMail 1.5 Specification
    has undergone many changes. The most important can be grouped into three categories,
    which are: addition of annotations, addition of methods, and changing of some
    access modifiers.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管受到维护版本的影响，JavaMail 1.5规范已经经历了许多变化。其中最重要的可以分为三类，即：添加注解、添加方法和更改某些访问修饰符。
- en: The added annotations
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加的注解
- en: In all, JavaMail 1.5 introduced two new annotations (`@MailSessionDefinition`
    and `@MailSessionDefinitions`) to configure JavaMail session resources in a Java
    EE 7 application server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，JavaMail 1.5引入了两个新的注解（`@MailSessionDefinition`和`@MailSessionDefinitions`），用于在Java
    EE 7应用程序服务器中配置JavaMail会话资源。
- en: The `@MailSessionDefinition` annotation contains several parameters (see the
    `Java` class in the following code) with the goal of offering the possibility
    to define a Mail Session that will be registered in any valid Java EE namespace
    and accessed by other components through the **JNDI**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`@MailSessionDefinition`注解包含几个参数（见以下代码中的`Java`类），目的是提供定义一个将被注册在任何有效的Java EE命名空间中并通过**JNDI**被其他组件访问的邮件会话的可能性。'
- en: 'The following code highlights the attributes of `@MailSessionDefinition` annotation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码突出了`@MailSessionDefinition`注解的属性：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this annotation, we can now define and use objects of `Session` type as
    in the case of the following code which is an example to show how to use `@MailSessionDefinition`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个注解，我们现在可以定义和使用`Session`类型的对象，就像以下代码示例所展示的那样，它展示了如何使用`@MailSessionDefinition`：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While the `@MailSessionDefinition` annotation allows us to define `MailSession`,
    `@MailSessionDefinitions` annotation allows us to configure many `MailSession`
    instances. The following code shows how to define two `MailSession` using instances
    `@MailSessionDefinitions` at a time:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`@MailSessionDefinition`注解允许我们定义`MailSession`，但`@MailSessionDefinitions`注解允许我们配置多个`MailSession`实例。以下代码展示了如何一次使用`@MailSessionDefinitions`实例定义两个`MailSession`：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The added methods
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加的方法
- en: 'In order to ease the developer''s work, JavaMail 1.5 added new methods that
    provide really interesting shortcuts. For example, the addition of the `Transport.send(msg,
    username, password)` method avoids creating additional objects for authentication
    parameters when sending the message. Before this, authentication parameters were
    defined at the `session` object and as you can see with the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻开发者的工作负担，JavaMail 1.5 添加了提供真正有趣快捷方式的新方法。例如，`Transport.send(msg, username,
    password)` 方法的添加，在发送消息时避免了为认证参数创建额外的对象。在此之前，认证参数是在 `session` 对象中定义的，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As another example of an added method, you have the `Message.getSession()` method,
    which allows you to access the `session` type object that was used to create the
    message. This may prevent you from having to drag the session throughout your
    treatment. The last added method that we will talk about is the `MimeMessage.reply(replyToAll,
    setAnswered)` method, which, due to the second parameter, allows you to automatically
    add a `Re` prefix to the subject line when you respond, for example, to a message.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为添加方法的一个另一个例子，您有 `Message.getSession()` 方法，它允许您访问用于创建消息的 `session` 类型的对象。这可能会防止您在处理过程中拖动会话。我们将讨论的最后一个添加的方法是
    `MimeMessage.reply(replyToAll, setAnswered)` 方法，由于第二个参数，当您响应，例如，一条消息时，它允许您自动将
    `Re` 前缀添加到主题行。
- en: The changing of some access modifiers
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些访问修饰符的变化
- en: Concerning access modifiers, the JavaMail 1.5 Specification has put an emphasis
    on good practice in some classes and facilitated the extension of others.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于访问修饰符，JavaMail 1.5 规范在一些类中强调了良好的实践，并促进了其他类的扩展。
- en: You will see, for example, that the access modifiers of the protected fields
    in the final classes of the `javax.mail.search` package have been changed to private.
    In fact, it is not important that the final class contains protected fields with
    public `getter`/`setter` method. So it is better to make them private and let
    `getter`/`setter` be public so that we can access/edit their values from outside.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到，例如，`javax.mail.search` 包中最终类的保护字段的访问修饰符已更改为私有。实际上，最终类包含具有公共 `getter`/`setter`
    方法的保护字段并不重要。因此，最好将它们设为私有，并让 `getter`/`setter` 保持为公共，这样我们就可以从外部访问/编辑它们的值。
- en: Still, in the changing of access modifier, JavaMail 1.5 has transformed the
    fields `cachedContent` (of classes `MimeBodyPart` and `MimeMessage`) and `MimeMultipart`
    class's fields from private to protected in order to facilitate the extension
    of the relevant classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在访问修饰符的变化中，JavaMail 1.5 已经将 `cachedContent` 字段（属于 `MimeBodyPart` 和 `MimeMessage`
    类）以及 `MimeMultipart` 类的字段从私有改为保护，以便于扩展相关类。
- en: Java EE Connector Architecture (JCA)
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 连接器架构 (JCA)
- en: The Java EE Connector Architecture 1.7 Specification was developed under JSR
    322\. This section just gives you an overview of improvements in the API. The
    complete document specification (for more information) can be downloaded from
    [http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 连接器架构 1.7 规范是在 JSR 322 下开发的。本节仅为您概述了 API 的改进。完整的文档规范（更多信息）可以从 [http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html)
    下载。
- en: What is JCA?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 JCA？
- en: 'Generally, **Enterprise Information** **Systems** (**EIS**s) of large companies
    are composed of a number of tools such as **Enterprise** **Resource Planning**
    applications (**ERP**, that is **SAP**), **Customer Relationship Management**
    applications (**CRM**, that is [salesforce.com](http://salesforce.com)), mainframe
    Transaction Processing applications, legacy applications and Database Systems
    (such as Oracle). In such an environment, the development of a new solution may
    require access to one or more of these tools to retrieve information or perform
    processing: we then talk of an **Enterprise Application Integration** (**EAI**).
    In the absence of a standard solution, this integration will be costly to both
    vendors and developers. Vendors will develop APIs to manage communication between
    different kinds of servers and developers will address EISs case by case and will
    implement the technical features (connection polling, transaction security mechanism,
    and so on) required by the application. Hence the need for JCA.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大型公司的**企业信息系统**（**EIS**s）由一系列工具组成，例如**企业资源计划**应用（**ERP**，即 **SAP**）、**客户关系管理**应用（**CRM**，即
    [salesforce.com](http://salesforce.com)）、主机事务处理应用、遗留应用和数据库系统（如 Oracle）。在这样的环境中，开发新的解决方案可能需要访问这些工具之一或多个以检索信息或执行处理：我们这时所说的就是**企业应用集成**（**EAI**）。在没有标准解决方案的情况下，这种集成对供应商和开发者来说都将非常昂贵。供应商将开发
    API 来管理不同类型服务器之间的通信，开发者将针对 EISs 逐个处理，并实现应用程序所需的技术特性（连接轮询、事务安全机制等）。因此，JCA 的需求就产生了。
- en: 'The Java EE Connector Architecture (JCA) is a specification that aims to standardize
    access to heterogeneous existing EISs from Java EE platforms. To this end, it
    defines a set of contracts that enable developers to access the different EISs
    seamlessly from a common interface called the **Common Client Interface** (**CCI**).
    For those who have already been working with **JDBC**, understanding of the functioning
    of JCA is a little easier. A JCA connector consists of two main elements:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 连接器架构（JCA）是一个旨在从 Java EE 平台标准化访问异构现有企业信息系统（EISs）的规范。为此，它定义了一系列合约，使开发者能够通过一个称为**通用客户端接口**（**CCI**）的通用接口无缝访问不同的
    EISs。对于那些已经使用过 **JDBC** 的人来说，理解 JCA 的功能要容易一些。JCA 连接器由两个主要元素组成：
- en: '**Common Client Interface** (**CCI**): This API is to EISs as JDBC is to databases.
    In other words, the CCI defines a standard client API that allows components to
    access EISs and perform processing.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用客户端接口**（**CCI**）：这个 API 对于 EISs 来说就像 JDBC 对于数据库一样。换句话说，CCI 定义了一个标准的客户端
    API，允许组件访问 EISs 并执行处理。'
- en: '**Resource Adapter**: This is a specific implementation of the CCI for a given
    EIS. It is provided by the vendor, which guarantees the execution of the features
    of its EIS through the JCA. The Resource Adapter, is packaged in a `.rar` archive
    called `Resource Adapter Module`, and it must obey some contracts (system level
    contracts) in order to be integrated into a Java EE platform and take advantage
    of services such as Connection, Transaction, and Security Management.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源适配器**：这是针对特定 EIS 的 CCI 的特定实现。它由供应商提供，并保证通过 JCA 执行其 EIS 的功能。资源适配器被打包在一个名为
    `Resource Adapter Module` 的 `.rar` 归档中，并且它必须遵守一些合约（系统级合约），以便集成到 Java EE 平台并利用连接、事务和安全管理等服务。'
- en: That said, you can consider using JCA when you want to access an EIS that offers
    a Resource Adapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，当您想访问提供资源适配器的 EIS 时，可以考虑使用 JCA。
- en: JCA in action
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JCA 应用实例
- en: Failing to take a concrete example that shows you how to access the list of
    employees managed by SAP with a connector (which would be very long), to allow
    you to understand the essential features), the following code shows you just an
    overview of the use of the JCA API. These include the general principle of the
    connection, the possibility of data manipulation, and disconnection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未能提供一个具体的示例来展示如何使用连接器访问由 SAP 管理的员工列表（这将非常长），以便您理解其基本功能），以下代码仅展示了 JCA API 的概述。这包括连接的一般原则、数据操作的可能性和断开连接。
- en: For those who wish to go further, GlassFish offers a complete example of implementing
    a connector to access a mail server, and the tutorial available at [http://www.ibm.com/developerworks/java/tutorials/j-jca/index.html](http://www.ibm.com/developerworks/java/tutorials/j-jca/index.html),
    provides you additional information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a overview of interactions with a resource adapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Latest improvements
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Talking about novelty, the Java EE Connector Architecture 1.7 was slightly
    improved. Indeed, in this specification, it is more a matter of clarification
    and requirements statements. That said, JCA 1.7 has introduced the following changes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: It insists on the availability of the the application component environment
    namespace of the endpoint to the resource adapter when the `endpointActivation`
    and `endpointDeactivation` methods are called
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds `ConnectionFactoryDefinition` and `AdministeredObjectDefinition` annotations
    for defining and configuring the resource adapter's resources
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It clarifies the behavior of the dependency injection when Managed JavaBeans
    are used as CDI-managed Beans
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Message Service (JMS)
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Message Service 2.0 Specification was developed under JSR 343\. This
    section just gives you an overview of improvements in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr343/index.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: When to use JMS
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JMS is a Java API for interacting with **Message Oriented Middleware** (**MOM**).
    This type of middleware is born from the need to solve observed limits in synchronous
    connections. This is because synchronous connections are susceptible to network
    failures and require that the connected systems are available at the same time.
    Hence, the MOMs offer an integration system based on the exchange of messages
    that can be treated synchronously or asynchronously depending on the availability
    of the integrated systems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows an architecture in which systems communicate through
    MOM:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![When to use JMS](img/9235OT_06_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Based on the foregoing, we conclude that JMS can be used in the following cases:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Transaction processing large amount of data (for example, synchronization of
    databases) through an unstable network
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between systems that are not always available simultaneously
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending of data to multiple systems
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To finish with this point, you should notice that the establishment of an integration
    system based on JMS requires that all components that need to be integrated be
    under your control. Hence, JMS would be better for the integration of internal
    solutions of a company.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The latest improvements in action
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Released in March 2002, the JMS 1.1 Specification was getting old and heavy
    compared to other APIs of the Java EE platform that have been simplified through
    the evolution of the platform. Based on this observation, you will understand
    why one of the main goals of JMS 2.0 API was to update the API so that it can
    be as simple as the other APIs of the platform and can integrate easily with them.
    To make this possible, several areas have been reviewed; these include the reduction
    of **boilerplate** code, removing redundant items, adding new features, and integration
    of the novelties of the Java language.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 2002年3月发布的 JMS 1.1 规范与其他经过平台演变而简化的 Java EE 平台 API 相比，显得有些过时和笨重。基于这一观察，你会理解为什么
    JMS 2.0 API 的一个主要目标就是更新 API，使其尽可能简单，并能轻松与其他平台 API 集成。为此，审查了几个领域；这些包括减少**样板**代码、移除冗余项、添加新功能和集成
    Java 语言的新特性。
- en: New features
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新特性
- en: 'In the JMS 2.0 Specification, three new features are highlighted: sending of
    messages asynchronously, delivery delay, and modification of the `JMSXDeliveryCount`
    message property.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JMS 2.0 规范中，强调了三个新特性：异步发送消息、投递延迟和修改 `JMSXDeliveryCount` 消息属性。
- en: Sending messages asynchronously
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异步发送消息
- en: In synchronous processing, if a method A invokes a method B, method A will remain
    blocked until the method B has completed. This can induce a waste of time. To
    overcome this problem, JMS 2.0 provides a set of methods to send messages asynchronously
    without losing sight of the progress of the operation. The following code demonstrates
    how to send messages asynchronously. The method `setAsync()` takes a listener
    as a parameter, which allows you to be informed at the end of the process or when
    an exception is thrown. If the listener is not null, the message will be sent
    asynchronously (the process will be performed by another thread different from
    the caller's thread). Otherwise, the message will be sent synchronously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步处理中，如果方法 A 调用方法 B，方法 A 将保持阻塞状态，直到方法 B 完成。这可能导致时间的浪费。为了克服这个问题，JMS 2.0 提供了一套方法，可以在不失去操作进度的情况下异步发送消息。以下代码演示了如何异步发送消息。`setAsync()`
    方法接受一个监听器作为参数，允许你在过程结束时或当抛出异常时得到通知。如果监听器不为空，消息将异步发送（过程将由与调用者线程不同的另一个线程执行）。否则，消息将同步发送。
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Delivery delay
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 投递延迟
- en: In addition to the possibility of sending messages asynchronously, JMS now permits
    us to defer the time of delivery of a message already in the **broker**, which
    is a MOM server. After sending, the message will be stored at the broker, but
    it will stay unknown to the receiver until the time fixed by the sender. The message
    of the following code will be delivered to the recipient at least one hour after
    sending.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以异步发送消息之外，JMS 现在还允许我们延迟已发送到**代理**（即 MOM 服务器）的消息的投递时间。发送后，消息将被存储在代理上，但直到发送者设定的时间，它对接收者来说是未知的。以下代码中的消息将在发送后至少一小时后发送给接收者。
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Handling of the JMSXDeliveryCount message property
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理 JMSXDeliveryCount 消息属性
- en: 'Since Version 1.1, the JMS Specification has defined an optional `JMSXDeliveryCount`
    message property, which can be used to determine the messages that were delivered
    more than once and apply an action when the number of deliveries exceeds the maximum
    value. But, because the management of this property was optional, all providers
    had no obligation to increment it, which had the effect of making applications
    that used it non portable. The JMS 2.0 Specification has introduced this as standard,
    to allow us to customize the management of **poisonous messages** in a portable
    way. A poisonous message is a JMS message that has exceeded the maximum number
    of deliveries for a given receiver. The following code shows how to retrieve the
    `JMSXDeliveryCount` message property and specify the action to be taken when one
    message has been delivered more that five time:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.1 版本以来，JMS 规范定义了一个可选的 `JMSXDeliveryCount` 消息属性，可用于确定被投递多次的消息，并在投递次数超过最大值时执行操作。但是，由于对这个属性的管理是可选的，所有提供者都没有义务增加它，这导致使用它的应用程序不可移植。JMS
    2.0 规范将此作为标准引入，以便我们可以以可移植的方式自定义**毒消息**的管理。毒消息是指一个 JMS 消息，它已经超过了给定接收者的最大投递次数。以下代码展示了如何检索
    `JMSXDeliveryCount` 消息属性并指定当一条消息被投递超过五次时采取的操作：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Simplification of the API
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API 简化
- en: 'The JMS 2.0 Specification introduces three new interfaces (`JMSContext`, `JMSProducer`,
    and `JMSConsumer`) which contribute to the elimination of boilerplate code and
    simplifying the API. It is important to note that these interfaces (which constitute
    the simplified API) co-exist with the old interfaces to provide an alternative.
    So `JMSContext` replaces the `Connection` and `Session` objects, `JMSProducer`
    replaces the `MessageProducer` object, and `JMSConsumer` replaces the `MessageConsumer`
    object in the old version. As you can see in the following code, the difference
    between the two approaches is very clear. In the sending method based on JMS API
    1.1 (`sendMessageJMSWithOldAPI`), we note: an excessive object creation, a mandatory
    throw of an exception, and a need to explicitly close connections.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JMS 2.0规范引入了三个新的接口（`JMSContext`、`JMSProducer`和`JMSConsumer`），这些接口有助于消除样板代码并简化API。重要的是要注意，这些接口（构成了简化API）与旧接口共存，以提供替代方案。因此，`JMSContext`取代了`Connection`和`Session`对象，`JMSProducer`取代了`MessageProducer`对象，`JMSConsumer`取代了旧版本中的`MessageConsumer`对象。正如您在以下代码中所见，两种方法之间的差异非常明显。在基于JMS
    API 1.1的发送方法（`sendMessageJMSWithOldAPI`）中，我们注意到：过多的对象创建、强制抛出异常以及需要显式关闭连接。
- en: 'Whereas, in the sending method based on JMS API 2.0 (`sendMessageJMSWithNewdAPI`),
    we have: the try-with-resources statement that saves the developer from having
    to explicitly close the connection and a send code reduced to the essentials that
    would fit on one line if we had injected `JMSContext` object.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在基于JMS API 2.0的发送方法（`sendMessageJMSWithNewdAPI`）中，我们有：try-with-resources语句，它使开发者免于显式关闭连接，以及将发送代码简化到仅包含一个`JMSContext`对象的基本要素。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Java API for RESTful Web Services
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java API for RESTful Web Services
- en: The Java API for RESTful Web Services 2.0 Specification was developed under
    JSR 339\. This section just gives you an overview of improvements in the API.
    The complete document specification (for more information) can be downloaded from
    [http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java API for RESTful Web Services 2.0规范是在JSR 339下开发的。本节仅为您概述API的改进。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html)下载。
- en: When to use Web Services
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用Web服务
- en: 'A Web Service is a software system based on open standards (such as HTTP, XML,
    and URI) and designed to allow exchanges between applications across the network.
    By using these open standards, it has everything required to be the most suitable
    solution for integrating heterogeneous systems. However, as we saw when we were
    talking about JMS, the choice of an integration solution should be made after
    a series of questions: Is the network connection good? Are the processes transactional?
    Is the amount of data to be processed huge? Must processing be synchronous? and
    so on.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是一种基于开放标准（如HTTP、XML和URI）的软件系统，旨在允许网络中应用程序之间的交换。通过使用这些开放标准，它具备了成为集成异构系统最合适解决方案所需的一切。然而，正如我们在讨论JMS时所看到的，选择集成解决方案应在一系列问题之后进行：网络连接是否良好？进程是否是事务性的？要处理的数据量是否巨大？处理必须是同步的吗？等等。
- en: 'If after investigation, your choice is Web Services, you must now select the
    type of web service to implement : the **SOAP** Web Services based on SOAP (**Simple
    Object Access Protocol**) and XML, or RESTful Web Services that are focused on
    resource sharing and thus their functioning is modeled on the Web. In this book,
    we will only discuss RESTful Web Services.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经过调查，您的选择是Web服务，那么您现在必须选择要实现的Web服务类型：基于SOAP（**简单对象访问协议**）和XML的**SOAP** Web服务，或者专注于资源共享并因此其功能基于Web的RESTful
    Web服务。在这本书中，我们只讨论RESTful Web服务。
- en: JAX-RS in action
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JAX-RS实践
- en: RESTful Web Services are a variant of Web Services in which any concepts that
    can be addressed (functionality or data) are considered as resources and therefore
    can be accessed through **Uniform Resource Identifiers** (**URI**s). Once located,
    the representation or state of the resource is transferred in the form of an XML
    or a JSON document. In the case of our online preregistration application, the
    resources may be the list of selected students and the representation will be
    in a JSON document.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web服务是Web服务的一种变体，其中任何可以寻址的概念（功能或数据）都被视为资源，因此可以通过**统一资源标识符**（**URI**s）访问。一旦定位到资源，其表示或状态将以XML或JSON文档的形式传输。在我们的在线预注册应用程序中，资源可能是选定的学生列表，表示将以JSON文档的形式出现。
- en: 'JAX-RS is the Java API to implement RESTful Web Services. The following code
    demonstrates how to write a REST service that returns a list of all students who
    were selected:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS是实现RESTful Web服务的Java API。以下代码演示了如何编写一个返回所有被选学生列表的REST服务：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The latest improvements in action
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最新改进措施
- en: JAX-RS 2.0 not only simplified the implementation of RESTful Web Services, but
    also introduced new features in the API, among which we have client API, asynchronous
    processing, filters, and interceptors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.0不仅简化了RESTful Web服务的实现，还在API中引入了新功能，其中包括客户端API、异步处理、过滤器以及拦截器。
- en: The Client API
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端API
- en: Since Version 1.0, the JAX-RS Specification did not define client APIs to interact
    with a RESTful service. So, each implementation provided a proprietary API, which
    had the effect of limiting the portability of applications. JAX-RS 2.0 fills this
    gap by providing a standard client API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1.0版本以来，JAX-RS规范没有定义客户端API来与RESTful服务交互。因此，每个实现都提供了一个专有的API，这限制了应用程序的可移植性。JAX-RS
    2.0通过提供一个标准的客户端API来填补这一空白。
- en: 'The following code demonstrates the implementation of a client that will access
    the list of selected students through the REST service exposed in the preceding
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了客户端的实现，该客户端将通过前面代码中公开的REST服务访问选定的学生列表：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Asynchronous processing
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步处理
- en: In addition to the standardization of the client API, JAX-RS 2.0 has integrated
    a feature already present in many of the APIs of the Java EE platform, which is
    asynchronous processing. It is now possible for a JAX-RS client to send requests
    or process responses asynchronously.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了客户端API的标准化外，JAX-RS 2.0还集成了Java EE平台许多API中已经存在的功能，即异步处理。现在，JAX-RS客户端可以异步发送请求或处理响应。
- en: The following code demonstrates how a JAX-RS client can perform a get request
    asynchronously and wait for the response passively. As shown in the code, the
    execution of a JAX-RS request asynchronously requires a call to the `async()`
    method. This method returns an object of type `AsyncInvoker` whose get, post,
    delete, and put methods allow us to obtain the object type `Future` that will
    be used for further processing of the response.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了JAX-RS客户端如何异步执行GET请求并被动等待响应。如代码所示，JAX-RS请求的异步执行需要调用`async()`方法。此方法返回一个类型为`AsyncInvoker`的对象，其get、post、delete和put方法允许我们获得用于进一步处理响应的对象类型`Future`。
- en: 'The following code is an example of the execution of a asynchronous process
    in a JAX-RS client:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是JAX-RS客户端中异步过程执行的一个示例：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To ensure that the processing is executed asynchronously, we have defined a
    break of 20 seconds in the `getListOfAllStudentsAs` method before executing the
    JPQL queries. The following code,which is a simulation of a slow processing, shows
    the contents of the method executed by the client:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保处理是异步执行的，我们在`getListOfAllStudentsAs`方法中定义了一个20秒的暂停，在执行JPQL查询之前。以下代码，这是一个慢速处理的模拟，显示了客户端执行的方法的内容：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similarly, the JAX-RS servers are able to run processes asynchronously. The
    method that contains the instructions to perform the task asynchronously must
    inject an object of type `AsyncResponse` as a method parameter with the `@Suspended`
    annotation. However, you should know that the asynchronous mode of the server
    differs from the asynchronous mode of the client; the former consists of suspending
    the client connection from which the request was send during the processing of
    the request before resuming it later through the `resume()` method of the object
    `AsyncResponse`. The method itself will not run asynchronously. To make it asynchronous,
    you must either delegate the process to a thread (that is what we did in the `getListOfAllStudentsAs2`
    method of the following example), or decorate it with the `@Asynchronous` annotation.
    The following code demonstrates how to perform asynchronous processing at the
    server side.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of the execution of a process asynchronously
    in a JAX-RS server:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Filters and entity interceptors
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another big ticket of the JAX-RS 2.0 Specification is the introduction of two
    mechanisms for interception: filters and interceptors. These new features bring
    to the specification a standard way to intercept processing in order to seamlessly
    manage security, compression, encoding, logging, editing, and auditing of exchanges
    between a JAX-RS server and the different clients that will access the server
    resources.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Although the two concepts are very similar (as they all relate to interception),
    we must say that the filter is often used for the processing of the headers of
    requests or responses. Whereas, interceptors are generally set up to manipulate
    the content of messages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JAX-RS 2.0 specification defines four types of filters: two types of filters
    on each side (client and server). On the client side, one filter that must be
    run before sending the HTTP request implements the `ClientRequestFilter` interface
    and the other filter, which must be run immediately after the receipt of the response
    from the server, (but before the control is rendered to the application) implements
    the `ClientResponseFilter` interface. On the server side, the filter that will
    be executed before the access to a JAX-RS resource implements the `ContainerRequestFilter`
    interface and the filter that will run just before the response is sent to the
    client implements the `ContainerResponseFilter` interface. The following code
    shows an example of `ContainerRequestFilter` implementation that verifies the
    information that ensures a secure access to the resources available to external
    users of our online preregistration application. The `@Provider` annotation on
    top of the `MyJaxRsRequestFilter` class in the following code allows the filter
    to be automatically discovered by the container and applied to all resources of
    the server. Failing to use this annotation, you must manually registered the filter.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of `ContainerRequestFilter` implementation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Entity interceptors
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the differences noted between filters and entity interceptors,
    JAX-RS provides two types of entity interceptors instead of four. There is a reader
    interceptor that implements the `ReaderInterceptor` interface and a writer interceptor,
    which implements the `WriterInterceptor` interface. Due to the elements that they
    are supposed to handle (message bodies), interceptors can be used to compress
    large content to optimize network utilization; they can also be used for some
    processing such as the generation and verification of digital signatures.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Given that the database of our online preregistration application will contain
    thousands of students, the following code demonstrates how we can take advantage
    of interceptors in the data exchange with the Ministry of Education in order to
    avoid network overloading when transmitting information about students.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows the implementation of `WriterInterceptor` (on the server
    side) that will compress data to send to the JAX-RS client. The `@ZipResult` annotation
    allows us to bind the interceptor only to some JAX-RS resources. If we remove
    this annotation, all JAX-RS resources of our application will be automatically
    compressed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a `WriterInterceptor` implemention:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To bind the `MyGzipWriterJaxRsInterceptor` interceptor to a resource, we will
    only decorate the given resource with the `@ZipResult` annotation. The following
    code demonstrates how to bind `MyGzipWriterJaxRsInterceptor` interceptor to a
    resource so that its representation can be always compressed before being sent
    to the client.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of of interceptor binding:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code is an example of the declaration of `@ZipResult` annotation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following code shows the implementation of the `ReaderInterceptor` interface
    (on the client side) that will decompress the data compressed by the server with
    the `MyGzipWriterJaxRsInterceptor` class:.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To bind the interceptor to a particular client, we will use the `register`
    method of the `Client` object. The following code demonstrates how to associate
    an interceptor or a filter to a JAX-RS Client:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the analysis of the online preregistration application presented in the
    previous chapter, we realized that our system should communicate with other systems.
    This chapter has given us the knowledge to identify and implement the best way
    to exchange data with different kinds of heterogeneous systems. In the next chapter,
    we will revisit some concepts that we have used in a natural way so that you have
    a better understanding of them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
