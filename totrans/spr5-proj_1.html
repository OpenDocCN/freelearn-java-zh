<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating an Application to List World Countries with their GDP</h1>
                </header>
            
            <article>
                
<p class="mce-root">Spring is an ecosystem that facilitates the development of JVM-based enterprise applications. And this is achieved using various modules provided by Spring. One of them, called Spring-core, is the heart of the framework in the Spring ecosystem, which provides support for dependency injection, web application, data access, transaction management, testing, and others.  </p>
<p class="mce-root">In this chapter, we will start from scratch and use Spring Framework to develop a simple application. Familiarity with Spring Framework is not required and we will see to it that by the end of the chapter you should be confident enough to use Spring Framework. </p>
<p>The following are the topics covered in this chapter:</p>
<ul>
<li>Introduction to the application</li>
<li>Understanding the database structure</li>
<li>Understanding the World Bank API</li>
<li>Designing the wireframes</li>
<li>Creating an empty application</li>
<li>Defining the model classes</li>
<li>Defining the data access layer</li>
<li>Defining the API controllers</li>
<li>Deploying to Tomcat</li>
<li>Defining the view controllers</li>
<li>Defining the views</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01</a>. The code can be executed on any operating system, although it has only been tested on Windows.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to the application</h1>
                </header>
            
            <article>
                
<p>We will develop an application to show the GDP information of various countries. We will make use of the sample World DB (<a href="https://dev.mysql.com/doc/world-setup/en/world-setup-installation.html">https://dev.mysql.com/doc/world-setup/en/world-setup-installation.html</a>) available with MySQL to list the countries and get a detailed view to display the country information and its GDP information obtained from the World Bank API (<a href="https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries">https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries</a>). </p>
<p>The listing will make use of the countries data available in the World DB. In the detail view, we will make use of data available in the World DB to list cities and languages, and make use of the World Bank API to get additional information and the GDP information about the country.</p>
<p>We will also support editing basic details of the country entry, adding and deleting cities from the country <span>entry</span>, and adding and deleting languages from the country <span>entry</span>. We will use the following tools and technologies in this application:</p>
<ul>
<li>Spring MVC framework for implementing the MVC pattern</li>
<li>The interaction with the MySQL DB will be done using the Spring JDBC template</li>
<li>The interaction with the World Bank API will be done using RestTemplate</li>
<li>The views will be created using a templating framework called Thymeleaf </li>
<li>The frontend will be driven by jQuery and Bootstrap</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the database structure</h1>
                </header>
            
            <article>
                
<p>If you don't have MySQL installed, head over to the MySQL link (<a href="https://dev.mysql.com/downloads/installer">https://dev.mysql.com/downloads/installer</a>) to install it and populate it with the world database, if it is not already available. The appendix will also guide you on how to run the queries using MySQL Workbench and <span>MySQL</span> command-line tool. </p>
<p>The world database schema is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3c6b1066-91ef-4e5c-9435-cedc3d0bcfa7.png"/></div>
<p>The database schema is simple, containing three tables as follows:</p>
<ul>
<li><strong>city</strong>: List of cities mapped to the three character country coded in the country table.</li>
<li><strong>country</strong>: List of countries where the primary key is the three character country code. There is a column that has the ISO country code.</li>
<li><strong>countrylanguage</strong>: List of languages mapped to the country with one of the languages of the country marked as official.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the World Bank API</h1>
                </header>
            
            <article>
                
<p>There are a lot of APIs exposed by the World Bank (<a href="http://www.worldbank.org/">http://www.worldbank.org/</a>) and the API documentation can be found here (<a href="https://datahelpdesk.worldbank.org/knowledgebase/articles/889386-developer-information-overview">https://datahelpdesk.worldbank.org/knowledgebase/articles/889386-developer-information-overview</a>). Out of the available APIs, we will use the Indicator APIs (<a href="https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries">https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries</a>), which represent information such as total population, GDP, GNI, energy use, and much more.</p>
<p>Using the Indicator API, we will fetch the GDP information for the countries available in the database for the last 10 years. Let's look at the API's REST URL and the data returned by the API, as follows:</p>
<pre><strong>GET http://api.worldbank.org/countries/BR/indicators/NY.GDP.MKTP.CD?format=json&amp;date=2007:2017</strong></pre>
<p>The <kbd>BR</kbd> is a country code (<em>Brazil</em>) in this URL. The <kbd>NY.GDP.MKTP.CD</kbd> is the flag used by the Word Bank API internally to call Indicator API. The request parameter, <kbd>date</kbd>, indicates the duration of which the GDP information is required.</p>
<p>The excerpt from the response you will get for the preceding API is as follows:</p>
<pre>[<br/>    {<br/>        "page": 1,<br/>        "pages": 1,<br/>        "per_page": "50",<br/>        "total": 11<br/>    },<br/>    [<br/>       ....// Other country data <br/>        {<br/>            "indicator": {<br/>                "id": "NY.GDP.MKTP.CD",<br/>                "value": "GDP (current US$)"<br/>            },<br/>            "country": {<br/>                "id": "BR",<br/>                "value": "Brazil"<br/>            },<br/>            "value": "1796186586414.45",<br/>            "decimal": "0",<br/>            "date": "2016"<br/>        }<br/>    ]<br/>]</pre>
<p>The preceding response shows the GDP indicator in US$ for Brazil for the year 2016. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the wireframes of application screens</h1>
                </header>
            
            <article>
                
<p>A wireframe is the basic skeleton of an application or website. It gives an idea about how the final application looks. It basically helps to decide navigation flows, understand functionality, design the user interface, and helps in setting the expectation before the application even exists. This process greatly helps developers, designers, product owners, and clients to work in a synchronous manner to avoid any gap in between. We will follow the same model and we will design various wireframes of the application as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Country listing page</h1>
                </header>
            
            <article>
                
<p class="mce-root">We will make it simple. The home page shows the country list with pagination, and allow <span>searching by country name and filtering by continent/region. The following would be the home page of our application:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/821768fe-363a-4c5f-9274-460a06f4bd32.png" style="width:30.92em;height:32.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Country detail page</h1>
                </header>
            
            <article>
                
<p>This screen will show details of the country such as cities, languages, and the GDP information obtained from the World Bank API. The GDP data will be visible in a graphical view. The page looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b435b5fd-2731-4946-b34f-89bd0aabe494.png" style="width:33.17em;height:35.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Country edit page</h1>
                </header>
            
            <article>
                
<p>In country listing page, there will be one button called <strong>Edit</strong>. On clicking it, the system will show the country in edit mode, enabling the update of the basic details of the country. The following is the view structure for editing the basic detail of a country:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6d68ffe7-8d04-41c3-b543-c63c78a0a226.png" style="width:31.92em;height:33.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Add a new city and language</h1>
                </header>
            
            <article>
                
<p>In the country detail page, t<span>wo modal views, one for adding a new city and another for adding a new language, are available by clicking on the <span class="packt_screen">New</span> button. </span><span>The following is the view for the two modal dialogs used to add a new country and</span> language.<span> They will be opened individually:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b9a78694-069d-4b01-b51f-b21327824eb4.png" style="width:61.17em;height:25.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an empty application</h1>
                </header>
            
            <article>
                
<p>We will use Maven to generate an empty application with the structure required for Java-based web applications. <span>If you do not have Maven installed, please follow the instructions here (</span><a href="https://maven.apache.org/install.html">https://maven.apache.org/install.html</a><span>) to install Maven. Once installed, r</span><span>un the following command to create an empty application:</span></p>
<pre><strong>mvn archetype:generate -DgroupId=com.nilangpatel.worldgdp -DartifactId=worldgdp -Dversion=0.0.1-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp</strong></pre>
<p>Running the preceding command will show the command-line argument values for confirmation as shown in the following screenshot: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f914bc77-a56b-4996-afb2-e033aff461e2.png"/></div>
<p>You would have to type in <kbd>Y</kbd> in the Command Prompt shown in the previous screenshot to complete the empty project creation. <span>Now you can import this project into an IDE of your choice and continue with the development activity. For the sake of simplicity, we will use Eclipse, as it is among the most popular IDEs used by the Java community today. </span></p>
<p>On successful creation of the application, you will see the folder structure, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c3b3a0ad-e578-412c-bd23-13511439466a.png" style="width:28.25em;height:20.42em;"/></p>
<div class="packt_infobox">You will see <kbd>index.jsp</kbd> added by default while creating the default project structure. You must delete it as, in this application, we will use Thymeleaf—another template engine to develop the landing page.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the model classes</h1>
                </header>
            
            <article>
                
<p>Now, let's create Java classes to model the data in the database and also the data coming from the World Bank API. Our approach is simple. We will have one Java class for each table in our database and the columns of the <span>database </span>will become the properties of the Java class. </p>
<p>In the generated application, the <kbd>java</kbd> folder is missing under the <kbd>main</kbd> directory. We will manually create the <kbd>java</kbd> folder and package the  <kbd>com.nilangpatel.worldgdp</kbd>, which will be the root package for the application. Let's go ahead and implement the approach we decided on. But before that, let's see an interesting project called <strong>Project Lombok</strong>. </p>
<p><span>Project Lombok provides annotations for generating your getters, setters, default, and overloaded constructors, and other boilerplate code. More details on how to integrate with your IDE can be found on their project website (</span><a href="https://projectlombok.org/">https://projectlombok.org/</a><span>).</span></p>
<p>We need to update our <kbd>pom.xml</kbd> to include a dependency on Project Lombok. The following are the parts of <kbd>pom.xml</kbd> you need to copy and add to relevant locations in the XML:</p>
<pre>&lt;properties&gt;<br/>    &lt;java.version&gt;1.8&lt;/java.version&gt;<br/>    &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;<br/>&lt;/properties&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>    &lt;optional&gt;true&lt;/optional&gt;<br/>    &lt;version&gt;${lombok.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>All the model classes that we are going to create next belong to the <kbd>com.nilangpatel.worldgdp.model</kbd> <span>package. </span>The model class to represent <kbd>Country</kbd> data is given in the following code:</p>
<pre>@Data<br/>@Setter<br/>@Getter<br/>public class Country {<br/>    private String code;<br/>    private String name;<br/>    private String continent;<br/>    private String region;<br/>    private Double surfaceArea;<br/>    private Short indepYear;<br/>    private Long population;<br/>    private Double lifeExpectancy;<br/>    private Double gnp;<br/>    private String localName;<br/>    private String governmentForm;<br/>    private String headOfState;<br/>    private City capital;<br/>    private String code2;<br/>}</pre>
<p>The <kbd>City</kbd> class is not created yet, let's go ahead and create it as follows: </p>
<pre>@Data<br/>@Setter<br/>@Getter<br/>public class City {<br/>    private Long id;<br/>    private String name;<br/>    private Country country;<br/>    private String district;<br/>    private Long population;<br/>}</pre>
<p>Next is to model the <kbd>CountryLanguage</kbd> class, which is the language spoken in a country, as follows:</p>
<pre>@Data<br/>@Setter<br/>@Getter<br/>public class CountryLanguage {<br/>    private Country country;<br/>    private String language;<br/>    private String isOfficial;<br/>    private Double percentage;<br/>}</pre>
<p>We also need a model class to map the GDP information obtained from the World Bank API. Let's go ahead and create a <kbd>CountryGDP</kbd> <span>class </span>as shown in the following code:</p>
<pre>@Data<br/>@Setter<br/>@Getter<br/>public class CountryGDP { <br/>    private Short year;<br/>    private Double value;<br/>}</pre>
<p>At this moment, everything works perfectly fine. But when you start calling getter and setter of these model classes into some other class, you may get a compilation error. This is because we need to do one more step to configure Lombok. After you defined the Maven dependency, you will see the JAR reference from IDE. Just right-click on it and select the <span class="packt_screen">Run As</span><em> |</em> <span class="packt_screen">Java Application</span> option. Alternatively, you can execute the following command from terminal at the location where the Lombok JAR file is kept, as follows:</p>
<pre><strong>java -jar lombok-1.16.18.jar</strong> </pre>
<p>Here, <kbd>lombok-1.16.18.jar</kbd> is the name of JAR file. You will see a separate window pop up as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d796b115-b20e-4fb2-b9b5-25beb17e150a.png"/></p>
<p>Select the location of your IDE by clicking on the <span class="packt_screen">Specify location...</span> button. Once selected, click on the <span class="packt_screen">Install / Update</span> button to install it. You will get a success message. Just restart the IDE and rebuild the project and you will see that just by defining <kbd>@Setter</kbd> and <kbd>@Getter</kbd>, the actual setters and getters are available to other classes. You are no longer required to add them explicitly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Hibernate Validator to add validations</h1>
                </header>
            
            <article>
                
<p>There are a few checks we need to add to our model classes so that the data being sent from the UI is not invalid. For this, we will make use of Hibernate Validator. You are required to add the Hibernate dependency as follows:</p>
<pre>    &lt;properties&gt;<br/>        &lt;java.version&gt;1.8&lt;/java.version&gt;<br/>        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;<br/>        &lt;hibernate.validator.version&gt;6.0.2.Final&lt;/hibernate.validator.version&gt;<br/>    &lt;/properties&gt;    <br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;<br/>        &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;<br/>        &lt;version&gt;${hibernate.validator.version}&lt;/version&gt;<br/>    &lt;/dependency&gt;</pre>
<p>Now go back to<span> </span><kbd>com.nilangpatel.worldgdp.model.Country</kbd> and update it with the following:</p>
<pre>@Data public class Country {<br/><br/>  @NotNull @Size(max = 3, min = 3) private String code;<br/>  @NotNull @Size(max = 52) private String name;<br/>  @NotNull private String continent;<br/>  @NotNull @Size(max = 26) private String region;<br/>  @NotNull private Double surfaceArea;<br/>  private Short indepYear;<br/>  @NotNull private Long population;<br/>  private Double lifeExpectancy;<br/>  private Double gnp;<br/>  @NotNull private String localName;<br/>  @NotNull private String governmentForm;<br/>  private String headOfState;<br/>  private City capital;<br/>  @NotNull private String code2;<br/>}</pre>
<p>Next is to update the<span> </span><kbd>com.nilangpatel.worldgdp.model.City</kbd> class in a similar way, as follows:</p>
<pre>@Data public class City {<br/>  @NotNull private Long id;<br/>  @NotNull @Size(max = 35) private String name;<br/>  @NotNull @Size(max = 3, min = 3) private String countryCode;<br/>  private Country country;<br/>  @NotNull @Size(max = 20) private String district;<br/>  @NotNull private Long population;<br/>}</pre>
<p>And finally, update<span> </span><kbd>com.nilangpatel.worldgdp.model.CountryLanguage</kbd> class as well, as follows:</p>
<pre>@Data<br/>public class CountryLanguage {<br/>  private Country country;<br/>  @NotNull private String countryCode;<br/>  @NotNull @Size(max = 30) private String language;<br/>  @NotNull @Size(max = 1, min = 1) private String isOfficial;<br/>  @NotNull private Double percentage;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the data access layer – Spring JDBC Template</h1>
                </header>
            
            <article>
                
<p>We have the model classes that reflect the structure of the data in the database that we obtained from the World Bank API. Now we need to develop a data access layer that interacts with our MySQL and populates the data stored in the database into instances of the model classes. We will <span>use the </span>Spring JDBC Template to achieve the required interaction with the database.</p>
<p>First, we need the JDBC driver to connect any Java application with MySQL. This can be obtained by adding the following dependency and version property to our <kbd>pom.xml</kbd>:</p>
<pre><span>    &lt;properties&gt;<br/>        &lt;java.version&gt;1.8&lt;/java.version&gt;<br/>        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;<br/>        &lt;hibernate.validator.version&gt;6.0.2.Final&lt;/hibernate.validator.version&gt;    <br/></span><span>        &lt;mysql.jdbc.driver.version&gt;5.1.44&lt;/mysql.jdbc.driver.version&gt;</span><span><br/>    &lt;/properties&gt; <br/></span>    &lt;dependency&gt;<br/>      &lt;groupId&gt;mysql&lt;/groupId&gt;<br/>      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br/>      &lt;version&gt;${mysql.jdbc.driver.version}&lt;/version&gt;<br/>    &lt;/dependency&gt;</pre>
<div class="packt_tip">Wherever you see <kbd>&lt;something.version&gt;1.5.6&lt;/something.version&gt;</kbd>, it should go within the <kbd>&lt;properties&gt;&lt;/properties&gt;</kbd> tag. Will not mention this repeatedly. This is for keeping the versions of libraries used in one place, making it easy to maintain and look up.<br/>
<br/>
Anything that comes as <kbd>&lt;dependency&gt;&lt;/dependency&gt;</kbd> goes within the <kbd>&lt;dependencies&gt;&lt;/dependencies&gt;</kbd> list.</div>
<p>Now we need to add a dependency to the Spring core APIs, as well as the Spring JDBC APIs (which contain the JDBC Template) to our <kbd>pom.xml</kbd>. A brief intro about these two dependencies is as follows:</p>
<ol>
<li><strong>Spring core APIs:</strong> It provides us with core Spring features such as dependency injection and configuration model</li>
<li><strong>Spring JDBC APIs:</strong> It provides us with the APIs required to create the <kbd>DataSource</kbd> instance and interact with the database</li>
</ol>
<div class="mce-root packt_tip">Since this is a sample application, we aren't using Hibernate or other ORM libraries because they provide lots of functionalities apart from basic CRUD operations. Instead, we will write SQL queries and use them with JDBC Template to make things simpler. </div>
<p class="mce-root"><span> The following code shows the <kbd>dependency</kbd> information for the two libraries</span>:</p>
<pre class="mce-root">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;<br/>   &lt;version&gt;${spring.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;<br/>   &lt;version&gt;${spring.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>Along with the preceding two dependencies, we need to add a few more Spring dependencies to assist us in setting up Java-based configurations using annotations (such as <kbd>@bean</kbd>,  <kbd>@Service</kbd>, <kbd>@Configuration</kbd>, <kbd>@ComponentScan</kbd>, and so on) and dependency injection using annotations (<kbd>@Autowired</kbd>). For this, we will be adding further dependencies as follows:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the JDBC connection properties</h1>
                </header>
            
            <article>
                
<p>We will define the JDBC connection properties in an <kbd>application.properties</kbd> file and place it in <kbd>src/main/resources</kbd>. The properties we define are as follows:</p>
<pre>dataSourceClassName=com.mysql.jdbc.Driver<br/>jdbcUrl=jdbc:mysql://localhost:3306/worldgdp<br/>dataSource.user=root<br/>dataSource.password=test</pre>
<p>The preceding properties are with the assumptions that <span>MySQL is running on port <kbd>3306</kbd> and the d</span><span>atabase username and password are <kbd>root</kbd> and <kbd>test</kbd> respectively. You can change these properties as per your local configuration. The next</span> step is to define a properties resolver that will be able to resolve the properties when used from within the code. We will use the <kbd>@PropertySource</kbd> annotation, along with an instance of  <kbd>PropertySourcesPlaceholderConfigurer</kbd>, as shown in the following code:</p>
<pre>@Configuration<br/>@PropertySource("classpath:application.properties")<br/>public class PropertiesWithJavaConfig {<br/> <br/>   @Bean<br/>   public static PropertySourcesPlaceholderConfigurer<br/>     propertySourcesPlaceholderConfigurer() {<br/>      return new PropertySourcesPlaceholderConfigurer();<br/>   }<br/>}</pre>
<div class="packt_tip">We will follow the convention of placing all our configuration classes in <kbd>com.nilangpatel.worldgdp.config</kbd> and any root configuration will go in the <kbd>com.nilangpatel.worldgdp</kbd> package. </div>
<p>This class reads all the properties from the <kbd>application.properties</kbd> file stored in classpath (<kbd>src/main/resources</kbd>). Next up is to configure a <kbd>javax.sql.DataSource</kbd> object that will connect to the database using the properties defined in the <kbd>application.properties</kbd> file. We will use the HikariCP connection pooling library for creating our <kbd>DataSource</kbd> instance. This <kbd>DataSource</kbd> instance is then used to instantiate <kbd>NamedParameterJdbcTemplate</kbd>. We will use <kbd>NamedParameterJdbcTemplate</kbd> to execute all our SQL queries. At this point, we need to add a necessary dependency for the HikariCP library as follows:</p>
<pre>    &lt;dependency&gt;<br/>        &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;<br/>        &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;<br/>        &lt;version&gt;${hikari.version}&lt;/version&gt;<br/>    &lt;/dependency&gt;</pre>
<p>The <kbd>DBConfiguration</kbd> <span>data source </span><span>configuration class </span>should look as follows:</p>
<pre>@Configuration<br/>public class DBConfiguration {<br/>  @Value("${jdbcUrl}") String jdbcUrl;<br/>  @Value("${dataSource.user}") String username;<br/>  @Value("${dataSource.password}") String password;<br/>  @Value("${dataSourceClassName}") String className;<br/>  <br/>  @Bean<br/>  public DataSource getDataSource() {<br/>    HikariDataSource ds = new HikariDataSource();<br/>    ds.setJdbcUrl(jdbcUrl);<br/>    ds.setUsername(username);<br/>    ds.setPassword(password);<br/>    ds.setDriverClassName(className);<br/>    return ds;<br/>  }<br/>  <br/>  @Bean<br/>  public NamedParameterJdbcTemplate namedParamJdbcTemplate() {<br/>    NamedParameterJdbcTemplate namedParamJdbcTemplate = <br/>        new NamedParameterJdbcTemplate(getDataSource());<br/>    return namedParamJdbcTemplate;<br/>  }<br/>}</pre>
<p>Let's have a quick introduction to a few new things used in this code:</p>
<ul>
<li><strong><kbd>@Configuration</kbd><span>:</span></strong> This is to indicate to Spring Framework that this class creates Java objects that contain some configuration</li>
<li><strong><kbd>@Bean</kbd><span>:</span></strong> This is method-level annotation, used to indicate to Spring Framework that the method returns Java objects whose life cycle is managed by Spring Framework and injected into places where its dependency is declared</li>
<li><strong><kbd>@Value</kbd>:</strong> This is used to refer to the properties defined in the <kbd>application.properties</kbd>, which are resolved by the <kbd>PropertySourcesPlaceholderConfigurer</kbd> bean defined in the <kbd>PropertiesWithJavaConfig</kbd> class</li>
</ul>
<p>It is always good practice to write unit test cases in JUnit. We will write test cases for our application. For that, we need to create the corresponding configuration classes for running our JUnit tests. In the next section, we will look at setting up the test environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the test environment</h1>
                </header>
            
            <article>
                
<p>Let's adopt a test first approach here. So, before going into writing the queries and DAO classes, let's set up the environment for our unit testing. If you don't find the <kbd>src/test/java</kbd> and <kbd>src/test/resources</kbd> folders, then please go ahead and create them either from your IDE or from your OS file explorer.</p>
<p>The <kbd>src/test/java</kbd> folder will contain all the Java code and <kbd>src/test/resources</kbd> will contain the required property files and other resources required <span>for test cases</span>. After creating the required folders, the project structure looks something like that shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4f495b7e-63f6-40f6-adc4-4b26af1833a5.png" style="width:31.58em;height:17.50em;"/></p>
<p>We will use the H2 database as a <span>source of data for our</span> testing environment. For that, we will update our Maven dependencies to add H2 and JUnit dependencies. H2 is one of the most popular embedded databases. The following is the dependency information that you need to add in your <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring.version}&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;junit&lt;/groupId&gt;<br/>    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>    &lt;version&gt;${junit.version}&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.assertj&lt;/groupId&gt;<br/>    &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;<br/>    &lt;version&gt;${assertj.version}&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>    &lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>    &lt;version&gt;${h2.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>We already have a property for <kbd>spring.version</kbd>, but we need version properties for the other two, as given in the following code:</p>
<pre>&lt;junit.version&gt;4.12&lt;/junit.version&gt;<br/>&lt;assertj.version&gt;3.12.0&lt;/assertj.version&gt;<br/>&lt;h2.version&gt;1.4.198&lt;/h2.version&gt;</pre>
<p>The World DB schema available in MySQL will not be compatible to run with H2, but don't worry. The compatible World DB schema for H2 is available in the source code of this chapter, you can download from GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01</a>). It is kept in the <kbd>src/test/resources</kbd> folder in the project. The file name is <kbd>h2_world.sql</kbd>. We will use this file to bootstrap our H2 database with the required tables and data that will then be available in our tests.</p>
<p>Next up is to configure H2 and one of the things we configure is the name of the SQL script file that contains the schema and data. This SQL script file should be available on the classpath. The following is the configuration class created in the <kbd>com.nilangpatel.worldgdp.test.config</kbd> <span>package </span>under <kbd>src/test/java</kbd> folder:</p>
<pre>@Configuration<br/>public class TestDBConfiguration {<br/>  <br/>  @Bean<br/>    public DataSource dataSource() {<br/>        return new EmbeddedDatabaseBuilder()<br/>            .generateUniqueName(true)<br/>            .setType(EmbeddedDatabaseType.H2)<br/>            .setScriptEncoding("UTF-8")<br/>            .ignoreFailedDrops(true)<br/>            .addScript("h2_world.sql")<br/>            .build();<br/>    }<br/>  <br/>  @Bean("testTemplate")<br/>  public NamedParameterJdbcTemplate namedParamJdbcTemplate() {<br/>    NamedParameterJdbcTemplate namedParamJdbcTemplate = <br/>        new NamedParameterJdbcTemplate(dataSource());<br/>    return namedParamJdbcTemplate;<br/>  }<br/>}</pre>
<p>Along with the H2 configuration, we are initializing <kbd>NamedParameterJdbcTemplate</kbd> by providing it with the H2 datasource built in the other method. </p>
<div class="packt_infobox">We have added few other dependencies specific to JUnit. You can refer to them by downloading the source code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the RowMapper</h1>
                </header>
            
            <article>
                
<p>As we are using the JDBC Template, we need a way to map the rows of data from a database to a Java object. This can be achieved by implementing a <kbd>RowMapper</kbd> interface. We will define mapper classes for all the three entities. For <kbd>Country</kbd>, the raw mapper class looks as follows:</p>
<pre>public class CountryRowMapper implements RowMapper&lt;Country&gt;{<br/><br/>  public Country mapRow(ResultSet rs, int rowNum) <br/>                            throws SQLException {<br/>    Country country = new Country();<br/>    country.setCode(rs.getString("code"));<br/>    country.setName(rs.getString("name"));<br/>    country.setContinent(rs.getString("continent"));<br/>    country.setRegion(rs.getString("region"));<br/>    country.setSurfaceArea(rs.getDouble("surface_area"));<br/>    country.setIndepYear(rs.getShort("indep_year"));<br/>    country.setPopulation(rs.getLong("population"));<br/>    country.setLifeExpectancy(rs.getDouble("life_expectancy"));<br/>    country.setGnp(rs.getDouble("gnp"));<br/>    country.setLocalName(rs.getString("local_name"));<br/>    country.setGovernmentForm(rs.getString("government_form"));<br/>    country.setHeadOfState(rs.getString("head_of_state"));<br/>    country.setCode2(rs.getString("code2"));<br/>    if ( Long.valueOf(rs.getLong("capital")) != null ) {<br/>      City city = new City();<br/>      city.setId(rs.getLong("capital"));<br/>      city.setName(rs.getString("capital_name"));<br/>      country.setCapital(city);<br/>    }<br/>    return country;<br/>  }<br/>}</pre>
<p>Then we define the mapper class for <kbd>City</kbd> as follows:</p>
<pre>public class CityRowMapper implements RowMapper&lt;City&gt;{<br/>  public City mapRow(ResultSet rs, int rowNum) <br/>                    throws SQLException {<br/>    City city = new City();<br/>    city.setCountryCode(rs.getString("country_code"));<br/>    city.setDistrict(rs.getString("district"));<br/>    city.setId(rs.getLong("id"));<br/>    city.setName(rs.getString("name"));<br/>    city.setPopulation(rs.getLong("population"));<br/>    return city;<br/>  }<br/>}</pre>
<p>And finally, we define <kbd>CountryLanguage</kbd> as follows:</p>
<pre>public class CountryLanguageRowMapper implements <br/>                       RowMapper&lt;CountryLanguage&gt; {<br/>  public CountryLanguage mapRow(ResultSet rs, int rowNum) <br/>                                 throws SQLException {<br/>    CountryLanguage countryLng = new CountryLanguage();<br/>    countryLng.setCountryCode(rs.getString("countrycode"));<br/>    countryLng.setIsOfficial(rs.getString("isofficial"));<br/>    countryLng.setLanguage(rs.getString("language"));<br/>    countryLng.setPercentage(rs.getDouble("percentage"));<br/>    return countryLng;<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the CountryDAO </h1>
                </header>
            
            <article>
                
<p>Let's go ahead and define the<span> </span><kbd>CountryDAO</kbd><span> </span>class in the <kbd>com.nilangpatel.worldgdp.dao</kbd><span> package </span>along with the required methods, starting with the<span> </span><kbd>getCountries</kbd> method. This method will fetch the details of countries to show them in the listing page. This method is also called while filtering the country list. Based on listing, filtering, and paginating, we have broken up the query used in this method into the following parts:</p>
<ol>
<li>Select clause:</li>
</ol>
<pre style="padding-left: 60px">private static final String SELECT_CLAUSE = "SELECT "<br/>      + " c.Code, "<br/>      + " c.Name, "<br/>      + " c.Continent, "<br/>      + " c.region, "<br/>      + " c.SurfaceArea surface_area, "<br/>      + " c.IndepYear indep_year, "<br/>      + " c.Population, "<br/>      + " c.LifeExpectancy life_expectancy, "<br/>      + " c.GNP, "<br/>      + " c.LocalName local_name, "<br/>      + " c.GovernmentForm government_form, "<br/>      + " c.HeadOfState head_of_state, "<br/>      + " c.code2 ,"<br/>      + " c.capital ,"<br/>      + " cy.name capital_name "<br/>      + " FROM country c"<br/>      + " LEFT OUTER JOIN city cy ON cy.id = c.capital ";</pre>
<ol start="2">
<li>Search where clause:</li>
</ol>
<pre style="padding-left: 60px">private static final String SEARCH_WHERE_CLAUSE = " AND ( LOWER(c.name) "<br/>      + " LIKE CONCAT('%', LOWER(:search), '%') ) ";</pre>
<ol start="3">
<li>Continent filter where clause:</li>
</ol>
<pre style="padding-left: 60px">private static final String CONTINENT_WHERE_CLAUSE = <br/>      " AND c.continent = :continent ";</pre>
<ol start="4">
<li>Region filter where clause:</li>
</ol>
<pre style="padding-left: 60px">private static final String REGION_WHERE_CLAUSE = <br/>      " AND c.region = :region ";</pre>
<ol start="5">
<li class="mce-root">Pagination clause:</li>
</ol>
<pre style="padding-left: 60px">private static final String PAGINATION_CLAUSE = " ORDER BY c.code "<br/>      + " LIMIT :size OFFSET :offset ";</pre>
<p>The placeholders defined by<span> </span><kbd>:&lt;&lt;variableName&gt;&gt;</kbd><span> </span>are replaced by the values provided in the<span> </span><kbd>Map</kbd><span> </span>to the <kbd>NamedParameterJdbcTemplate</kbd>. This way we can avoid concatenating the values into the SQL query, thereby avoiding chances of SQL injection. The<span> </span><kbd>getCountries()</kbd><span> </span>definition would now be as follows:</p>
<pre>public List&lt;Country&gt; getCountries(Map&lt;String, Object&gt; params){<br/>    int pageNo = 1;<br/>    if ( params.containsKey("pageNo") ) {<br/>      pageNo = Integer.parseInt(params.get("pageNo").toString());<br/>    }<br/>    Integer offset = (pageNo - 1) * PAGE_SIZE;<br/>    params.put("offset", offset);<br/>    params.put("size", PAGE_SIZE);<br/>    return namedParamJdbcTemplate.query(SELECT_CLAUSE<br/>        + " WHERE 1 = 1 "<br/>        + (!StringUtils.isEmpty((String)params.get("search")) <br/>            ? SEARCH_WHERE_CLAUSE : "")<br/>        + (!StringUtils.isEmpty((String)params.get("continent")) <br/>            ? CONTINENT_WHERE_CLAUSE : "")<br/>        + (!StringUtils.isEmpty((String)params.get("region")) <br/>            ? REGION_WHERE_CLAUSE : "")<br/>        + PAGINATION_CLAUSE,<br/>        params, new CountryRowMapper());<br/>  }</pre>
<p>Next is to implement the <kbd>getCountriesCount</kbd><span> </span>method, which is similar to<span> </span><kbd>getCountries</kbd>, except that it returns the count of entries matching the<span> </span><kbd>WHERE</kbd><span> </span>clause without the pagination applied. The implementation is as shown in the following code:</p>
<pre>public int getCountriesCount(Map&lt;String, Object&gt; params) {<br/>  return namedParamJdbcTemplate.queryForObject(<br/>          "SELECT COUNT(*) FROM country c" <br/>        + " WHERE 1 = 1 "<br/>        + (!StringUtils.isEmpty((String)params.get("search")) <br/>            ? SEARCH_WHERE_CLAUSE : "")<br/>        + (!StringUtils.isEmpty((String)params.get("continent")) <br/>            ? CONTINENT_WHERE_CLAUSE : "")<br/>        + (!StringUtils.isEmpty((String)params.get("region")) <br/>            ? REGION_WHERE_CLAUSE : ""),<br/>        params, Integer.class);<br/>  }</pre>
<p>Then we implement the <kbd>getCountryDetail</kbd><span> method </span>to get the detail of the country, given its code, as follows:</p>
<pre>public Country getCountryDetail(String code) {<br/>  Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();<br/>  params.put("code", code);<br/>    <br/>  return namedParamJdbcTemplate.queryForObject(SELECT_CLAUSE <br/>      +" WHERE c.code = :code", params, <br/>      new CountryRowMapper());<br/>}</pre>
<div class="packt_infobox">In all of the previous DAO method implementations, we have made use of the<span> </span><kbd>CountryRowMapper</kbd><span> </span>we defined in the <em>Defining the RowMapper</em> section.</div>
<p>Finally, we define the method to allow editing the country information, as shown in the following code:</p>
<pre>public void editCountryDetail(String code, Country country) {<br/>    namedParamJdbcTemplate.update(" UPDATE country SET "<br/>        + " name = :name, "<br/>        + " localname = :localName, "<br/>        + " capital = :capital, "<br/>        + " continent = :continent, "<br/>        + " region = :region, "<br/>        + " HeadOfState = :headOfState, "<br/>        + " GovernmentForm = :governmentForm, "<br/>        + " IndepYear = :indepYear, "<br/>        + " SurfaceArea = :surfaceArea, "<br/>        + " population = :population, "<br/>        + " LifeExpectancy = :lifeExpectancy "<br/>        + "WHERE Code = :code ", <br/>        getCountryAsMap(code, country));<br/>  }</pre>
<p>The previous method uses a helper method that builds a<span> </span><kbd>Map</kbd> object, by using the data present in the<span> </span><kbd>Country</kbd><span> </span>object. We need the map, as we'll be using it as a parameter source for our<span> </span><kbd>namedParamJdbcTemplate</kbd>.</p>
<p>The helper method has a simple implementation, as shown in the following code:</p>
<pre>private Map&lt;String, Object&gt; getCountryAsMap(String code, Country country){<br/>    Map&lt;String, Object&gt; countryMap = new HashMap&lt;String, Object&gt;();<br/>    countryMap.put("name", country.getName());<br/>    countryMap.put("localName", country.getLocalName());<br/>    countryMap.put("capital", country.getCapital().getId());<br/>    countryMap.put("continent", country.getContinent());<br/>    countryMap.put("region", country.getRegion());<br/>    countryMap.put("headOfState", country.getHeadOfState());<br/>    countryMap.put("governmentForm", country.getGovernmentForm());<br/>    countryMap.put("indepYear", country.getIndepYear());<br/>    countryMap.put("surfaceArea", country.getSurfaceArea());<br/>    countryMap.put("population", country.getPopulation());<br/>    countryMap.put("lifeExpectancy", country.getLifeExpectancy());<br/>    countryMap.put("code", code);<br/>    return countryMap;<br/>}</pre>
<p>Let's write our JUnit test for the <kbd>CountryDAO</kbd> class, which we haven't created yet. Create <kbd>CountryDAOTest</kbd> <span>class into the </span><kbd>com.nilangpatel.worldgdp.test.dao</kbd> package as follows: </p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringJUnitConfig( classes = {<br/>      TestDBConfiguration.class, CountryDAO.class})<br/>public class CountryDAOTest {<br/><br/>  @Autowired CountryDAO countryDao;<br/>  <br/>  @Autowired @Qualifier("testTemplate")<br/>  NamedParameterJdbcTemplate namedParamJdbcTemplate;<br/>  <br/>  @Before<br/>  public void setup() {<br/>    countryDao.setNamedParamJdbcTemplate(namedParamJdbcTemplate);<br/>  }<br/>  <br/>  @Test<br/>  public void testGetCountries() {<br/>    List&lt;Country&gt; countries = countryDao.getCountries(new HashMap&lt;&gt;());<br/>    //AssertJ assertions<br/>    //Paginated List, so should have 20 entries<br/>    assertThat(countries).hasSize(20);<br/>  }<br/>  <br/>  @Test<br/>  public void testGetCountries_searchByName() {<br/>    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br/>    params.put("search", "Aruba");<br/>    List&lt;Country&gt; countries = countryDao.getCountries(params);<br/>    assertThat(countries).hasSize(1);<br/>  }<br/>  <br/>  <br/>  @Test<br/>  public void testGetCountries_searchByContinent() {<br/>    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br/>    params.put("continent", "Asia");<br/>    List&lt;Country&gt; countries = countryDao.getCountries(params);<br/>    <br/>    assertThat(countries).hasSize(20);<br/>  }<br/>  <br/>  @Test<br/>  public void testGetCountryDetail() {<br/>    Country c = countryDao.getCountryDetail("IND");<br/>    assertThat(c).isNotNull();<br/>    assertThat(c.toString()).isEqualTo("Country(code=IND, name=India, "<br/>        + "continent=Asia, region=Southern and Central Asia, "<br/>        + "surfaceArea=3287263.0, indepYear=1947, population=1013662000, "<br/>        + "lifeExpectancy=62.5, gnp=447114.0, localName=Bharat/India, "<br/>        + "governmentForm=Federal Republic, headOfState=Kocheril Raman Narayanan, "<br/>        + "capital=City(id=1109, name=New Delhi, countryCode=null, "<br/>        + "country=null, district=null, population=null), code2=IN)");<br/>  }<br/>  <br/>  @Test public void testEditCountryDetail() {<br/>    Country c = countryDao.getCountryDetail("IND");<br/>    c.setHeadOfState("Ram Nath Kovind");<br/>    c.setPopulation(1324171354l);<br/>    countryDao.editCountryDetail("IND", c);<br/>    <br/>    c = countryDao.getCountryDetail("IND");<br/>    assertThat(c.getHeadOfState()).isEqualTo("Ram Nath Kovind");<br/>    assertThat(c.getPopulation()).isEqualTo(1324171354l);<br/>  }<br/>  <br/>  @Test public void testGetCountriesCount() {<br/>    Integer count = countryDao.getCountriesCount(Collections.EMPTY_MAP);<br/>    assertThat(count).isEqualTo(239);<br/>  }<br/>}</pre>
<p>There are a few things to note about configuring JUnit tests using the Spring test framework from the following test, including the following:</p>
<ul>
<li><kbd>@RunWith</kbd> is used to replace the JUnit's test runner with a custom test runner, which in this case, is Spring's <span><kbd>SpringRunner</kbd>. Spring's test runner helps in integrating JUnit with the Spring test framework.</span></li>
<li><span><span><kbd>@SpringJUnitConfig</kbd> is used to provide the list of classes that contain the required configuration to satisfy the dependencies for running the test.</span></span></li>
</ul>
<div class="packt_tip">Many people who choose ORM frameworks may feel that writing complicated SQL queries like this is awkward. However, from the next chapter onward, we'll start using the Spring Data framework to make an interaction with various data sources; the database is one of those accessed with the Spring Data JPA. Here, we wanted to show how the Spring JDBC offering interacts with the database.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the CityDAO</h1>
                </header>
            
            <article>
                
<p>The following are some of the important operations to be supported by <kbd>com.nilangpatel.worldgdp.dao.CityDAO</kbd> class:</p>
<ul>
<li>Get cities for a country</li>
<li>Get city details for given ID</li>
<li>Add a new city to a country</li>
<li>Delete the given city from the country</li>
</ul>
<p>Let's go ahead and implement each one of these functionalities starting with the <kbd>getCities</kbd>, as follows:</p>
<pre>public List&lt;City&gt; getCities(String countryCode, Integer pageNo){<br/>  Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();<br/>  params.put("code", countryCode);<br/>  if ( pageNo != null ) {<br/>    Integer offset = (pageNo - 1) * PAGE_SIZE;<br/>    params.put("offset", offset);<br/>    params.put("size", PAGE_SIZE);<br/>  }<br/>  <br/>  return namedParamJdbcTemplate.query("SELECT "<br/>      + " id, name, countrycode country_code, district, population "<br/>      + " FROM city WHERE countrycode = :code"<br/>      + " ORDER BY Population DESC"<br/>      + ((pageNo != null) ? " LIMIT :offset , :size " : ""),<br/>      params, new CityRowMapper());<br/>}</pre>
<p>We are using a paginated query to get a list of cities for a country. We will also need another overloaded version of this method where we return all the cities of a country and we will use this query to fetch all the cities while editing the country to select its capital. The overloaded version is as follows:</p>
<pre>public List&lt;City&gt; getCities(String countryCode){<br/>  return getCities(countryCode, null);<br/>}</pre>
<p>Next is to implement the method to get the city details, as shown in the following code:</p>
<pre>public City getCityDetail(Long cityId) {<br/>  Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();<br/>  params.put("id", cityId);<br/>  return namedParamJdbcTemplate.queryForObject("SELECT id, "<br/>      + " name, countrycode country_code, "<br/>      + " district, population "<br/>      + " FROM city WHERE id = :id", <br/>      params, new CityRowMapper());<br/>}</pre>
<p>Then we implement the method to add a city as follows:</p>
<pre>public Long addCity(String countryCode, City city) {<br/>  <br/>  SqlParameterSource paramSource = new MapSqlParameterSource(<br/>      getMapForCity(countryCode, city));<br/>  KeyHolder keyHolder = new GeneratedKeyHolder();<br/>  namedParamJdbcTemplate.update("INSERT INTO city("<br/>      + " name, countrycode, "<br/>      + " district, population) "<br/>      + " VALUES (:name, :country_code, "<br/>      + " :district, :population )", <br/>      paramSource, keyHolder);<br/>  return keyHolder.getKey().longValue();<br/>}</pre>
<p>As we saw with adding a country, this will also make use of a helper method to return a<span> </span><kbd>Map</kbd><span> </span>from the<span> </span><kbd>City</kbd><span> </span>data, as follows:</p>
<pre>private Map&lt;String, Object&gt; getMapForCity(String countryCode, City city){<br/>  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();<br/>  map.put("name", city.getName());<br/>  map.put("country_code", countryCode);<br/>  map.put("district", city.getDistrict());<br/>  map.put("population", city.getPopulation());<br/>  return map;<br/>}</pre>
<p>An important thing to notice in<span> </span><kbd>addCity</kbd><span> </span>is the use of<span> </span><kbd>KeyHolder</kbd><span> </span>and<span> </span><kbd>GeneratedKeyHolder</kbd><span> </span>to return the generated (due to auto increment) primary key that is the<span> </span><kbd>cityId</kbd>, as follows:</p>
<pre> KeyHolder keyHolder = new GeneratedKeyHolder();<br/> //other code<br/> return keyHolder.getKey().longValue();</pre>
<p>And finally, we implement the method to delete a city from the country as shown in the following code:</p>
<pre>public void deleteCity(Long cityId) {<br/>  Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();<br/>  params.put("id", cityId);<br/>  namedParamJdbcTemplate.update("DELETE FROM city WHERE id = :id", params);<br/>}</pre>
<p>Now let's add a test for <kbd>CityDAO</kbd>. Add the <kbd>CityDAOTest</kbd> class in <kbd>com.nilangpatel.worldgdp.test.dao</kbd> <span>package </span>under <kbd>src/test/java</kbd> folder as follows:</p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringJUnitConfig( classes = {<br/>  TestDBConfiguration.class, CityDAO.class})<br/>public class CityDAOTest {<br/><br/>  @Autowired CityDAO cityDao;<br/>  <br/>  @Autowired @Qualifier("testTemplate")<br/>  NamedParameterJdbcTemplate namedParamJdbcTemplate;<br/>  <br/>  @Before<br/>  public void setup() {<br/>    cityDao.setNamedParamJdbcTemplate(namedParamJdbcTemplate);<br/>  }<br/>  <br/>  @Test public void testGetCities() {<br/>    List&lt;City&gt; cities = cityDao.getCities("IND", 1);<br/>    assertThat(cities).hasSize(10);<br/>  }<br/>  <br/>  @Test public void testGetCityDetail() {<br/>    Long cityId = 1024l;<br/>    City city = cityDao.getCityDetail(cityId);<br/>    assertThat(city.toString()).isEqualTo("City(id=1024, name=Mumbai (Bombay), "<br/>      + "countryCode=IND, country=null, district=Maharashtra, population=10500000)");<br/>  }<br/>  <br/>  @Test public void testAddCity() {<br/>    String countryCode = "IND";<br/>    City city = new City();<br/>    city.setCountryCode(countryCode);<br/>    city.setDistrict("District");<br/>    city.setName("City Name");<br/>    city.setPopulation(101010l);<br/>    <br/>    long cityId = cityDao.addCity(countryCode, city);<br/>    assertThat(cityId).isNotNull();<br/>    City cityFromDb = cityDao.getCityDetail(cityId);<br/>    assertThat(cityFromDb).isNotNull();<br/>    assertThat(cityFromDb.getName()).isEqualTo("City Name");<br/>  }<br/>  <br/>  @Test (expected = EmptyResultDataAccessException.class)<br/>  public void testDeleteCity() {<br/>    Long cityId = addCity();<br/>    cityDao.deleteCity(cityId);<br/>    City cityFromDb = cityDao.getCityDetail(cityId);<br/>    assertThat(cityFromDb).isNull();<br/>  }<br/>  <br/>  private Long addCity() {<br/>    String countryCode = "IND";<br/>    City city = new City();<br/>    city.setCountryCode(countryCode);<br/>    city.setDistrict("District");<br/>    city.setName("City Name");<br/>    city.setPopulation(101010l);<br/>    <br/>    return cityDao.addCity(countryCode, city);<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the CountryLanguageDAO</h1>
                </header>
            
            <article>
                
<p>We will need to expose the following APIs to interact with the <kbd>countrylanguage</kbd> table:</p>
<ul>
<li>Get list of languages for a given country code</li>
<li>Add a new language for a country by checking that the language doesn't already exist</li>
<li>Delete a language for a country</li>
</ul>
<p>For the sake of keeping it short, we will show the method implementations covering these three scenarios. The complete code can be found in the <kbd>com.nilangpatel.worldgdp.dao.CountryLanguageDAO</kbd> class available in the code downloaded for this book. The following is the code for these method implementations:</p>
<pre>public List&lt;CountryLanguage&gt; getLanguages(String countryCode, Integer pageNo){<br/>  Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();<br/>  params.put("code", countryCode);<br/>  <br/>  Integer offset = (pageNo - 1) * PAGE_SIZE;<br/>  params.put("offset", offset);<br/>  params.put("size", PAGE_SIZE);<br/>  <br/>  return namedParamJdbcTemplate.query("SELECT * FROM countrylanguage"<br/>      + " WHERE countrycode = :code"<br/>      + " ORDER BY percentage DESC "<br/>      + " LIMIT :size OFFSET :offset ", <br/>      params, new CountryLanguageRowMapper());<br/>}<br/><br/>public void addLanguage(String countryCode, CountryLanguage cl) {<br/>  namedParamJdbcTemplate.update("INSERT INTO countrylanguage ( "<br/>      + " countrycode, language, isofficial, percentage ) "<br/>      + " VALUES ( :country_code, :language, "<br/>      + " :is_official, :percentage ) ", <br/>      getAsMap(countryCode, cl));<br/>}<br/><br/>public boolean languageExists(String countryCode, String language) {<br/>  Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();<br/>  params.put("code", countryCode);<br/>  params.put("lang", language);<br/>  <br/>  Integer langCount = namedParamJdbcTemplate.queryForObject(<br/>    "SELECT COUNT(*) FROM countrylanguage"<br/>    + " WHERE countrycode = :code "<br/>    + " AND language = :lang", params, Integer.class);<br/>  return langCount &gt; 0;<br/>}<br/><br/>public void deleteLanguage (String countryCode, String language ) {<br/>  Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();<br/>  params.put("code", countryCode);<br/>  params.put("lang", language);<br/>  namedParamJdbcTemplate.update("DELETE FROM countrylanguage "<br/>      + " WHERE countrycode = :code AND "<br/>      + " language = :lang ", params);<br/>}<br/><br/>private Map&lt;String, Object&gt; getAsMap(String countryCode, CountryLanguage cl){<br/>  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();<br/>  map.put("country_code", countryCode);<br/>  map.put("language", cl.getLanguage());<br/>  map.put("is_official", cl.getIsOfficial());<br/>  map.put("percentage", cl.getPercentage());<br/>  return map;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the client for World Bank API</h1>
                </header>
            
            <article>
                
<p>We need to fetch the GDP data from WorldBank API. As we discussed, it is REST end point, where we have to send few parameters and will get the response. For this, we will use RestTemplate to make REST call. The following is the definition for the <kbd>com.packt.external.WorldBankApiClient</kbd> <span>class, </span>which is used to invoke the World Bank API and process its response to return <kbd>List&lt;CountryGDP&gt;</kbd>:</p>
<pre>@Service<br/>public class WorldBankApiClient {<br/><br/>  String GDP_URL = "http://api.worldbank.org/countries/%s/indicators/NY.GDP.MKTP.CD?"<br/>      + "format=json&amp;date=2008:2018";<br/>  <br/>  public List&lt;CountryGDP&gt; getGDP(String countryCode) throws ParseException {<br/>    RestTemplate worldBankRestTmplt = new RestTemplate();<br/>    ResponseEntity&lt;String&gt; response<br/>      = worldBankRestTmplt.getForEntity(String.format(GDP_URL, countryCode), String.class);<br/>    <br/>    //the second element is the actual data and its an array of object<br/>    JSONParser parser = new JSONParser();<br/>    JSONArray responseData = (JSONArray) parser.parse(response.getBody()); <br/>    JSONArray countryDataArr = (JSONArray) responseData.get(1);<br/>    <br/>    List&lt;CountryGDP&gt; data = new ArrayList&lt;CountryGDP&gt;();<br/>    JSONObject countryDataYearWise=null;<br/>    for (int index=0; index &lt; countryDataArr.size(); index++) {<br/>      countryDataYearWise = (JSONObject) countryDataArr.get(index);<br/>      <br/>      String valueStr = "0";<br/>      if(countryDataYearWise.get("value") !=null) {<br/>        valueStr = countryDataYearWise.get("value").toString();<br/>      }<br/>      String yearStr = countryDataYearWise.get("date").toString();<br/>      CountryGDP gdp = new CountryGDP();<br/>      gdp.setValue(valueStr != null ? Double.valueOf(valueStr) : null);<br/>      gdp.setYear(Short.valueOf(yearStr));<br/>      data.add(gdp);<br/>    }<br/>    return data;<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the API controllers</h1>
                </header>
            
            <article>
                
<p>So far, we have written code to interact with the DB. Next up is to work on the code for the controller. We will have both types of controller—one that returns the view name (Thymeleaf template in our case) with the data for the view populated in the model object, and the other that exposes the RESTful APIs. We will need to add the following dependency to <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<div class="packt_tip packt_infobox">Adding <kbd>spring-webmvc</kbd> to the dependency will automatically include <kbd>spring-core</kbd>, <kbd>spring-beans</kbd>, and <kbd>spring-context</kbd> dependencies. So we can remove them from the <kbd>pom.xml</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling Web MVC using @EnableWebMvc</h1>
                </header>
            
            <article>
                
<p>To be able to make use of the Spring MVC features, we need to have one class that has been annotated with <kbd>@Configuration</kbd>, to be annotated with <kbd>@EnableWebMvc</kbd>. The <kbd>@EnableWebMvc</kbd> annotation, imports the Spring MVC configuration from the <kbd>WebMvcConfigurationSupport</kbd> class present in the Spring MVC framework. If we need to override any of the default imported configuration, we would have to implement the <kbd>WebMvcConfigurer</kbd> interface present in the Spring MVC framework and override the required methods.</p>
<p>We will create an <kbd>AppConfiguration</kbd> class with the following definition:</p>
<pre>@EnableWebMvc<br/>@Configuration<br/>@ComponentScan(basePackages = "com.nilangpatel.worldgdp")<br/>public class AppConfiguration implements WebMvcConfigurer{<br/><br/>  @Override<br/>  public void addResourceHandlers(ResourceHandlerRegistry registry) {<br/>    registry.addResourceHandler("/static/**").addResourceLocations("/static/");<br/>  }<br/>}</pre>
<p>In the previous configuration, a few important things to note are as follows:</p>
<ul>
<li><kbd>@EnableWebMvc</kbd>: This imports the Spring MVC related configuration.</li>
<li><kbd>@ComponentScan</kbd>: This is used for declaring the packages that have to be scanned for Spring components (which can be <kbd>@Configuration</kbd>, <kbd>@Service</kbd>, <kbd>@Controller</kbd>, <kbd>@Component</kbd>, and so on). If no package is defined, then it scans starting from the package where the class is defined.</li>
<li><kbd>WebMvcConfigurer</kbd>: We are going to implement this interface to override some of the default Spring MVC configuration seen in the previous code.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration to deploy to Tomcat without web.xml</h1>
                </header>
            
            <article>
                
<p>As we will be deploying the application to Tomcat, we need to <span>provide </span>the servlet configuration to the application server. We will look at how to deploy to Tomcat in a separate section, but now we will look at the Java configuration, which is sufficient to deploy the application to Tomcat or any application server without the need for an additional <kbd>web.xml</kbd>. The Java class definition is given in the following:</p>
<pre>public class WorldApplicationInitializer extends<br/>  AbstractAnnotationConfigDispatcherServletInitializer {<br/><br/>  @Override<br/>  protected Class&lt;?&gt;[] getRootConfigClasses() {<br/>    return null;<br/>  }<br/>  @Override<br/>  protected Class&lt;?&gt;[] getServletConfigClasses() {<br/>    return new Class[] {AppConfiguration.class};<br/>  }<br/>  @Override<br/>  protected String[] getServletMappings() {<br/>    return new String[] { "/" };<br/>  }<br/>}</pre>
<p>The <kbd>AbstractAnnotationConfigDispatcherServletInitializer</kbd> <span>abstract class </span>is an implementation of the <kbd>WebApplicationInitializer</kbd> <span>interface </span>that is used to register Spring's <kbd>DispatcherServlet</kbd> instance and uses the other <kbd>@Configuration</kbd> classes to configure the <kbd>DispatcherServlet</kbd>.</p>
<p>We just need to override the <kbd>getRootConfigClasses()</kbd>, <kbd>getServletConfigClasses()</kbd>, and <kbd>getServletMappings()</kbd> methods. The first two methods point to the configuration classes that need to load into the servlet context, and the last method is used to provide the servlet mapping for <kbd>DispatcherServlet</kbd>.</p>
<p><kbd>DispatcherServlet</kbd> follows the front controller pattern, where there is a single servlet registered to handle all the web requests. This servlet uses the <kbd>RequestHandlerMapping</kbd> and invokes the corresponding implementation based on the URL mapped to the implementation.</p>
<p>We need to make a small update to the Maven WAR plugin so that it doesn't fail if there is no <kbd>web.xml</kbd> found. This can be done by updating the <kbd>&lt;plugins&gt;</kbd> tag in the <kbd>pom.xml</kbd> file, as shown in the following:</p>
<pre>&lt;build&gt;<br/>  &lt;finalName&gt;worldgdp&lt;/finalName&gt;<br/>  &lt;plugins&gt;<br/>    &lt;plugin&gt;<br/>      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/>      &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;<br/>      &lt;executions&gt;<br/>        &lt;execution&gt;<br/>          &lt;id&gt;default-war&lt;/id&gt;<br/>          &lt;phase&gt;prepare-package&lt;/phase&gt;<br/>          &lt;configuration&gt;<br/>            &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;<br/>          &lt;/configuration&gt;<br/>        &lt;/execution&gt;<br/>      &lt;/executions&gt;<br/>    &lt;/plugin&gt;<br/>  &lt;/plugins&gt;<br/>&lt;/build&gt;</pre>
<p>Now we are all set to implement our controllers. We will show you how to deploy to Tomcat once we have implemented all the RESTful API controllers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the RESTful API controller for country resource</h1>
                </header>
            
            <article>
                
<p>Let's define the RESTful API controller for the country resource. The following is the template for the controller:</p>
<pre>@RestController<br/>@RequestMapping("/api/countries")<br/>@Slf4j<br/>public class CountryAPIController {<br/>  <br/>  @Autowired CountryDAO countryDao;<br/>  @Autowired WorldBankApiClient worldBankApiClient;<br/>  <br/>  @GetMapping<br/>  public ResponseEntity&lt;?&gt; getCountries(<br/>    @RequestParam(name="search", required = false) String searchTerm,<br/>    @RequestParam(name="continent", required = false) String continent,<br/>    @RequestParam(name="region", required = false) String region,<br/>    @RequestParam(name="pageNo", required = false) Integer pageNo<br/>  ){<br/>    //logic to fetch contries from CountryDAO<br/>    return ResponseEntity.ok();<br/>  }<br/>  <br/>  @PostMapping(value = "/{countryCode}", <br/>      consumes = {MediaType.APPLICATION_JSON_VALUE})<br/>  public ResponseEntity&lt;?&gt; editCountry(<br/>    @PathVariable String countryCode, @Valid @RequestBody Country country ){<br/>    //logic to edit existing country <br/>    return ResponseEntity.ok();<br/>  }<br/>  <br/>  @GetMapping("/{countryCode}/gdp")<br/>  public ResponseEntity&lt;?&gt; getGDP(@PathVariable String countryCode){<br/>    //logic to get GDP by using external client<br/>    return ResponseEntity.ok();<br/>  }<br/>  <br/>}</pre>
<p>The following are a few things to note from the previous code:</p>
<ul>
<li><kbd>@RestController</kbd>: This is used to annotate a class as a controller with each of the RESTful methods returning the data in the response body. </li>
<li><kbd>@RequestMapping</kbd>: This is for assigning the root URL for accessing the resources. </li>
<li><kbd>@GetMapping</kbd> and <kbd>@PostMapping</kbd>: These are used to assign the HTTP verbs that will be used to invoke the resources. The URL for the resources are passed within the annotation, along with other request headers that consume and produce information. </li>
</ul>
<p>Let's implement each of the methods in order, starting with <kbd>getCountries()</kbd>, as shown in the following code:</p>
<pre>@GetMapping<br/>public ResponseEntity&lt;?&gt; getCountries(<br/>  @RequestParam(name="search", required = false) String searchTerm,<br/>  @RequestParam(name="continent", required = false) String continent,<br/>  @RequestParam(name="region", required = false) String region,<br/>  @RequestParam(name="pageNo", required = false) Integer pageNo<br/>){<br/>  try {<br/>    Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();<br/>    params.put("search", searchTerm);<br/>    params.put("continent", continent);<br/>    params.put("region", region);<br/>    if ( pageNo != null ) {<br/>      params.put("pageNo", pageNo.toString());<br/>    }<br/>    <br/>    List&lt;Country&gt; countries = countryDao.getCountries(params);<br/>    Map&lt;String, Object&gt; response = new HashMap&lt;String, Object&gt;();<br/>    response.put("list", countries);<br/>    response.put("count", countryDao.getCountriesCount(params));<br/>    return ResponseEntity.ok(response);<br/>  }catch(Exception ex) {<br/>    log.error("Error while getting countries", ex);<br/>    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)<br/>          .body("Error while getting countries");<br/>  }<br/>}</pre>
<p>The following are some of the things to note from the previous code:</p>
<ul>
<li><kbd>@RequestParam</kbd>: This annotation is used to declare request parameters accepted by the controller endpoint. The parameters can be provided with a default value and can also be made mandatory. </li>
<li><kbd>ResponseEntity</kbd>: This class is used to return the response body, along with other response parameters such as status, headers, and so on.</li>
</ul>
<p>Next up is the API for editing country details, as follows:</p>
<pre>@PostMapping("/{countryCode}")<br/>public ResponseEntity&lt;?&gt; editCountry(<br/>  @PathVariable String countryCode, @Valid @RequestBody Country country ){<br/>  try {<br/>    countryDao.editCountryDetail(countryCode, country);<br/>    Country countryFromDb = countryDao.getCountryDetail(countryCode);<br/>    return ResponseEntity.ok(countryFromDb);<br/>  }catch(Exception ex) {<br/>    log.error("Error while editing the country: {} with data: {}", <br/>       countryCode, country, ex);<br/>    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)<br/>        .body("Error while editing the country");<br/>  }<br/>}</pre>
<p>The following are a few things to note from the previous code implementation:</p>
<ul>
<li><kbd>@PathVariable</kbd>: This is used to declare any variable that needs to be part of the URL path of the controller endpoint. In our case, we want the country code to be part of the URL. So the URL will be of the <kbd>/api/countries/IND</kbd> form.</li>
<li><kbd>@Valid</kbd>: This triggers the Bean Validation API to check for the restrictions on each of the class properties. If the data from the client is not valid, it returns a <span class="packt_screen">400</span>.</li>
<li><kbd>@RequestBody</kbd>: This is used to capture the data sent in the request body and the <kbd>Jackson</kbd> library is used to convert the JSON data in the request body to the corresponding Java object.</li>
</ul>
<p>The rest of the API implementation can be found in the <kbd>CountryAPIController</kbd> class. The tests for the API controller can be found in the <kbd>CountryAPIControllerTest</kbd> <span>class, which is </span>available in<span> the source code of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the RESTful API controller for city resource</h1>
                </header>
            
            <article>
                
<p>For the city resource we would need the following APIs:</p>
<ul>
<li>Get cities for a given country</li>
<li>Add a new city to the country</li>
<li>Delete the city from the country</li>
</ul>
<p>The code for this controller can be found in the <kbd>CityAPIController</kbd> class and the tests for the API controller can be found in the <kbd>CityAPIControllerTest</kbd> class, <span>which is </span><span>available in</span><span> the source code of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the RESTful API controller for country language resource</h1>
                </header>
            
            <article>
                
<p>For the <kbd>CountryLanguage</kbd> resource we need the following APIs:</p>
<ul>
<li>Get languages for a country</li>
<li>Add a language for a country</li>
<li>Delete a language from the country</li>
</ul>
<p><span>The code for this controller can be found in the <kbd>CountryLanguageAPIController</kbd> class and the tests for the API controller can be found in the <kbd>CountryLanguageAPIControllerTest</kbd> class, which is available in the source code of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying to Tomcat</h1>
                </header>
            
            <article>
                
<p>Before we proceed with View and Controller for handling views, we will deploy the app developed so far to Tomcat. You can download Tomcat 8.5 from here (<a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a>). Installation is as simple as extracting the ZIP/TAR file onto your file system.</p>
<p>Let's create a user <kbd>admin</kbd> and <kbd>manager-gui</kbd> role in Tomcat. To do this, have to edit <span><kbd>apache-tomcat-8.5.23/conf/tomcat-users.xml</kbd> and add the following line:</span></p>
<pre>&lt;role rolename="manager-gui" /&gt;<br/>&lt;user username="admin" password="admin" roles="manager-gui" /&gt;</pre>
<p>Starting up Tomcat is simple, as follows: </p>
<ol>
<li>Navigate to <kbd>apache-tomcat-8.5.23/bin</kbd></li>
<li>Run <kbd>startup.bat</kbd></li>
</ol>
<p>Navigate to <kbd>http://localhost:8080/manager/html</kbd> and enter <kbd>admin</kbd>, and <kbd>admin</kbd> for username and password respectively, to be able to view Tomcat's manager console. The initial part of the page will list the applications deployed in the current instance, and toward the later part of the page you will find an option to upload a WAR file to deploy the application, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6c21e48b-e79b-4804-a73c-91ec6b6abaa9.png"/></div>
<p>We can either upload the WAR file generated after running <kbd>mvn package</kbd> or update the <kbd>server.xml</kbd> of the Tomcat instance to refer to the target directory of the project to be able to deploy automatically. The latter approach can be used for development, while the former that is WAR deployment can be used for production.</p>
<p>In a production system, you can have a continuous deployment server generate a WAR file and deploy to a remote Tomcat instance. In this scenario, we will use the latter approach of updating the Tomcat's configuration. You have to add the following line of code in the Tomcat's <kbd>server.xml</kbd> file, located at <kbd>TOMCAT_HOME/conf/server.xml</kbd>:</p>
<pre>&lt;Context path="/world" docBase="&lt;&lt;Directory path where you keep WAR file&gt;&gt;" <br/>          reloadable="true" /&gt;</pre>
<p>The preceding line has to be added between the <kbd>&lt;Host&gt;&lt;/Host&gt;</kbd> tags. Alternatively, you can configure Tomcat in your IDE (for example, Eclipse), which is more convenient for development purposes. We will build the project with Maven, but before that, please add following configuration to the <kbd>&lt;properties&gt;&lt;/properties&gt;</kbd> section of <kbd>pom.xml</kbd>:</p>
<pre>&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;<br/>&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</pre>
<p>This will make sure to choose the correct Java compiler version while building (packaging) the application with Maven from the command line. Next is to build the project using the <kbd>mvn package</kbd> and run Tomcat using <kbd>TOMCAT_HOME/bin/startup.bat</kbd>, and once the server is UP, you can visit the API <kbd>http://localhost:8080/worldgdp/api/countries</kbd> in the browser to see the following input:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/253a8a32-c15a-418a-8929-a9e7717d2c0e.png" style="width:32.67em;height:47.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the view controller</h1>
                </header>
            
            <article>
                
<p>We will have one view controller, <kbd>ViewController.java</kbd> defined in the <kbd>com.nilangpatel.worldgdp.controller.view</kbd>. The view controller will be responsible for populating the data required for the view templates and also mapping URLs to corresponding view templates. </p>
<p>We will be using Thymeleaf (<a href="https://www.thymeleaf.org/">www.thymeleaf.org</a>) as the server-side template engine and Mustache.js (<a href="https://github.com/janl/mustache.js">https://github.com/janl/mustache.js</a>) as our client-side template engine. The advantage of using a client-side template engine is that any data loaded asynchronously in the form of JSON can easily be added to the DOM by generating HTML using the client-side templates. We will explore more about Thymeleaf and Mustache.js in <a href="e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml">Chapter 3</a>, <em>Blogpress – A simple blog management system</em>.</p>
<p>There are much better ways to do this by using frameworks such as Vue.js, React.js, Angular.js, and so on. We will look at the view template in the next section. Let's continue our discussion about the view controller. The view controller should map the right view template and the data for the following scenarios:</p>
<ul>
<li>Listing of countries</li>
<li>Viewing country detail</li>
<li>Editing country detail</li>
</ul>
<p>Let's look at the following skeletal structural definition of the <kbd>ViewController</kbd> class:</p>
<pre>@Controller<br/>@RequestMapping("/")<br/>public class ViewController {<br/>  <br/>  @Autowired CountryDAO countryDao;<br/>  @Autowired LookupDAO lookupDao;<br/>  @Autowired CityDAO cityDao;<br/>  <br/>  @GetMapping({"/countries", "/"})<br/>  public String countries(Model model, <br/>    @RequestParam Map&lt;String, Object&gt; params<br/>  ) {<br/>    //logic to fetch country list<br/>    return "countries";<br/>  }<br/>  <br/>  @GetMapping("/countries/{code}")<br/>  public String countryDetail(@PathVariable String code, Model model) {<br/>    //Logic to Populate the country detail in model<br/>    return "country";<br/>  }<br/>  <br/>  @GetMapping("/countries/{code}/form")<br/>  public String editCountry(@PathVariable String code, <br/>    Model model) {<br/>    //Logic to call CountryDAO to update the country<br/>    return "country-form";<br/>  }<br/>}</pre>
<p>The following are a few important things from the previous code:</p>
<ul>
<li><kbd>@Controller</kbd>: This annotation is used to declare a controller that can return view template names to be able to render the view, as well as returning JSON/XML data in the response body. </li>
<li><kbd>@ResponseBody</kbd>: This annotation when present on the method of the controller indicates that the method is going to return the data in the response body, and hence, Spring will not use the view resolver to resolve the view to be rendered. The <kbd>@RestController</kbd> annotation by default adds this annotation to all its methods.</li>
<li><kbd>Model</kbd>: This instance is used to pass on the data required for building the view. </li>
</ul>
<p>In case of the listing of countries, the complete HTML is rendered at the server using the Thymeleaf template engine, so we need to obtain the request parameters, if any are present in the URL, and obtain a filtered and paginated list of the countries. We also need to populate the lookups that is the data for the <kbd>&lt;select&gt;</kbd> controls, which will be used for filtering the data. Let's look at its implementation as follows:</p>
<pre>@GetMapping({"/countries", "/"})<br/>public String countries(Model model, <br/>  @RequestParam Map&lt;String, Object&gt; params<br/>) {<br/>  model.addAttribute("continents", lookupDao.getContinents());<br/>  model.addAttribute("regions", lookupDao.getRegions());<br/>  model.addAttribute("countries", countryDao.getCountries(params));<br/>  model.addAttribute("count", countryDao.getCountriesCount(params));<br/>  <br/>  return "countries";<br/>}</pre>
<p>The previous code is pretty straightforward. We are making use of the DAO classes to populate the required data into the <kbd>Model</kbd> instance and then returning the view name, which in this case is <kbd>countries</kbd>. Similarly, the rest of the method implementation can be found in the <kbd>ViewController</kbd> <span>controller class.</span> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the view templates</h1>
                </header>
            
            <article>
                
<p>We will be using the Thymeleaf template engine for handling server-side templates. Thymeleaf provides various dialects and conditional blocks for rendering the dynamic content within the static HTML. Let's look at some simple syntactical element of Thymeleaf, as follows:</p>
<pre>&lt;!-- Dynamic content in HTML tag --&gt;<br/>&lt;div class="alert alert-info"&gt;[[${country.name}]]&lt;/div&gt;<br/><br/>&lt;!-- Dynamic attributes --&gt;<br/>&lt;span th:class="|alert ${error ? 'alert-danger': _}|"&gt;[[${errorMsg}]]&lt;/span&gt;<br/><br/>&lt;!-- Looping --&gt;<br/>&lt;ol&gt;<br/>  &lt;li th:each="c : ${countries}"&gt;<br/>     [[${c.name}]]<br/>  &lt;/li&gt;<br/>&lt;/ol&gt;<br/><br/>&lt;!-- Conditionals --&gt;<br/>&lt;div class="alert alert-warning" th:if="${count == 0}"&gt;No results found&lt;/div&gt;<br/><br/>&lt;!-- Custom attributes --&gt;<br/>&lt;div th:attr="data-count=${count}"&gt;&lt;/div&gt;<br/><br/>&lt;!-- Form element value --&gt;<br/>&lt;input type="text" th:value="${country.name}" name="name" /&gt;</pre>
<p class="mce-root">From the previous examples, we can observe that the items to be evaluated by Thymeleaf are prefixed with <kbd>th:</kbd> and any content to be rendered between the tags can be done either using <kbd>th:text</kbd> or <kbd>[[${variable}]]</kbd>. The latter syntax has been introduced in Thymeleaf 3. This was a very short primer, as going in to depth on Thymeleaf is out of the scope of this book. A beautiful guide explaining different parts of the template can be found at <a href="http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a Thymeleaf template engine</h1>
                </header>
            
            <article>
                
<p>In order to use the Thymeleaf template engine with Spring MVC, we need to do some configuration wherein we set up the Thymeleaf template engine and update Spring's view resolver to use the template engine to resolve any views. Before moving further, we need to define required dependencies in <kbd>pom.xml</kbd> as follows:</p>
<pre>    &lt;dependency&gt;<br/>      &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;<br/>      &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;<br/>      &lt;version&gt;${thymeleaf.version}&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>      &lt;groupId&gt;nz.net.ultraq.thymeleaf&lt;/groupId&gt;<br/>      &lt;artifactId&gt;thymeleaf-layout-dialect&lt;/artifactId&gt;<br/>      &lt;version&gt;${thymeleaf-layout-dialect.version}&lt;/version&gt;<br/>    &lt;/dependency&gt;</pre>
<p>Let's define the configuration view resolver in order, starting with setting up the template resolver as follows:</p>
<pre>@Bean<br/>public ClassLoaderTemplateResolver templateResolver() {<br/>  ClassLoaderTemplateResolver templateResolver <br/>     = new ClassLoaderTemplateResolver();<br/>  templateResolver.setPrefix("templates/");<br/>  templateResolver.setSuffix(".html");<br/>  templateResolver.setTemplateMode(TemplateMode.HTML);<br/>  templateResolver.setCacheable(false);<br/>  return templateResolver;<br/>}</pre>
<p>The previous configuration sets the template location that the template engine will use to resolve the template files. Next is to define the template engine, which will make use of <kbd>SpringTemplateEngine</kbd> and the template resolver defined earlier, as follows:</p>
<pre>@Bean<br/>public SpringTemplateEngine templateEngine() {<br/>  SpringTemplateEngine templateEngine = new SpringTemplateEngine();<br/>  templateEngine.setTemplateResolver(templateResolver());<br/>  templateEngine.addDialect(new LayoutDialect());<br/>  return templateEngine;<br/>}</pre>
<p>In the previous configuration, we make use of the Thymeleaf Layout Dialect (<a href="https://github.com/ultraq/thymeleaf-layout-dialect">https://github.com/ultraq/thymeleaf-layout-dialect</a>) created by <em>Emanuel Rabina</em>. This layout dialect helps us in creating a view decorator framework wherein all the templates will be decorated with a base template and the decorated templates just provide the necessary content to complete the page. So all the headers, footers, CSS, scripts, and other common HTML can be placed in the base template. This prevents redundancy to a great extent. In our sample app, the <kbd>base.html</kbd> file present in <kbd>worldgdp/src/main/resources/templates</kbd> is the base template that is used by other templates. </p>
<p>Next is to define a Thymeleaf view resolver that will override Spring's default view resolver, as follows:</p>
<pre>@Bean<br/>public ViewResolver viewResolver() {<br/>  ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();<br/>  viewResolver.setTemplateEngine(templateEngine());<br/>  viewResolver.setCharacterEncoding("UTF-8");<br/>  return viewResolver;<br/>}</pre>
<p>The previous configuration is available in the <kbd>com.packt.config.ViewConfiguration</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing static resources</h1>
                </header>
            
            <article>
                
<p>If you look back at the <kbd>com.nilangpatel.worldgdp.AppConfiguration</kbd> class, you will see that we have overridden the <kbd>addResourceHandlers</kbd> method of <kbd>WebMvcConfigurer</kbd> interface. In the method implementation shown in the following code, we have mapped the static resources prefix URL <kbd>/static/**</kbd> to the static resources location <kbd>/static/</kbd> in the <kbd>webapp</kbd> directory:</p>
<pre>@Override<br/>public void addResourceHandlers(ResourceHandlerRegistry registry) {<br/>  registry.addResourceHandler("/static/**")<br/>    .addResourceLocations("/static/");<br/>}</pre>
<div class="packt_infobox">We have added a few static resources (both CSS and JavaScript) in the <kbd>/src/main/webapp/static</kbd> folder of the project. Please download the code of this chapter and refer to them side by side.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the base template</h1>
                </header>
            
            <article>
                
<p>We mentioned before that we will be using the Thymeleaf Layout Dialect to create a base template and use the base template to decorate all other templates. The base template will contain all the CSS links, JavaScript source file links, the header, and the footer, as shown in the following code:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html <br/>   <br/>  &gt;<br/>  &lt;head&gt;<br/>      <br/>    &lt;title layout:title-pattern="$CONTENT_TITLE - $LAYOUT_TITLE"&gt;World In Numbers&lt;/title&gt;<br/>    &lt;meta name="description" content=""/&gt;<br/>    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;<br/>    &lt;!-- Include all the CSS links --&gt;<br/>  &lt;/head&gt;<br/>   <br/>  &lt;body&gt;<br/>    &lt;nav class="navbar navbar-expand-lg navbar-dark bg-primary"&gt;<br/>      &lt;a class="navbar-brand" href="#"&gt;WORLD IN NUMBERS&lt;/a&gt;<br/>      &lt;div class="collapse navbar-collapse" id="navbarColor01"&gt;<br/>          &lt;ul class="navbar-nav mr-auto"&gt;<br/>          &lt;li class="nav-item active"&gt;<br/>            &lt;a class="nav-link" th:href="@{/countries}"&gt;Countries&lt;/a&gt;<br/>          &lt;/li&gt;<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    &lt;/nav&gt;<br/>    &lt;div class="container"&gt;<br/>      &lt;div class="content"&gt;<br/>        &lt;div layout:fragment="page_content"&gt;<br/>          &lt;!-- Placeholder for content --&gt;<br/>        &lt;/div&gt;<br/>  <br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    <br/>    &lt;div class="modal" id="worldModal" &gt;<br/>    &lt;/div&gt;<br/>    &lt;footer id="footer"&gt;&lt;/footer&gt;<br/>    &lt;!-- /.container --&gt;<br/>    <br/>    &lt;!-- Include all the Javascript source files --&gt;<br/>    &lt;th:block layout:fragment="scripts"&gt;<br/>      &lt;!-- Placeholder for page related javascript --&gt;<br/>    &lt;/th:block&gt;<br/>  &lt;/body&gt;<br/>  <br/>&lt;/html&gt;<br/> </pre>
<p>The two main important parts of the following template are as follows:</p>
<ul>
<li><kbd>&lt;div layout:fragment="page_content"&gt;&lt;/div&gt;</kbd>: The other templates that use the base template as decorator provide their HTML within this section. Thymeleaf Layout Dialect at runtime decorates this HTML with the content from the base template.</li>
<li><kbd>&lt;th:block layout:fragment="scripts"&gt;&lt;/th:block&gt;</kbd>: Similar to the HTML previous content, any page-specific JavaScript or links to any specific JavaScript source files can be added within this section. This helps in isolating page-specific JavaScript in their own pages.</li>
</ul>
<p>Any template that wants to use the base template as the decorator will declare this attribute, <kbd>layout:decorate="~{base}"</kbd>, in the <kbd>&lt;html&gt;</kbd> tag. We will not go into the content of individual templates as it's mostly HTML. All the templates can be found at the location <kbd>worldgdp/src/main/resources/templates</kbd>. We have three templates:</p>
<ul>
<li><kbd>countries.html</kbd>: This is for showing the countries' list with filtering and pagination</li>
<li><kbd>country-form.html</kbd>: This is for editing a country's detail</li>
<li><kbd>country.html</kbd>: This is for showing a country's detail</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging configuration</h1>
                </header>
            
            <article>
                
<p>Before we jump into the rest of the steps to develop an application, it is good practice to define a log level and format. It is, however, optional but good practice to print the logs in a desired format, along with various logging levels. For this, add an XML file called <kbd>logback.xml</kbd> with following content in it:</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;configuration&gt;<br/>  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;<br/>    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;<br/>      &lt;Pattern&gt;<br/>        %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n<br/>      &lt;/Pattern&gt;<br/>    &lt;/layout&gt;<br/>  &lt;/appender&gt;<br/>  &lt;logger name="com.nilangpatel.worldgdp" level="debug" additivity="false"&gt;<br/>    &lt;appender-ref ref="STDOUT" /&gt;<br/>  &lt;/logger&gt;<br/>  &lt;root level="debug"&gt;<br/>    &lt;appender-ref ref="STDOUT" /&gt;<br/>  &lt;/root&gt;<br/>&lt;/configuration&gt;</pre>
<p>Logback was developed as a successor to the popular Log4j project, and is used as a logging framework for Java applications. This configuration defines the pattern, along with the logging level. To enable logback in your application, you need to add following dependencies to <kbd>pom.xml</kbd>:</p>
<pre>  &lt;dependency&gt;<br/>      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;<br/>      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;<br/>      &lt;version&gt;${logback.version}&lt;/version&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;<br/>      &lt;artifactId&gt;logback-core&lt;/artifactId&gt;<br/>      &lt;version&gt;${logback.version}&lt;/version&gt;<br/>  &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>As we have already configured the deployment to Tomcat, you should have the application running now. You can always download the source code for this book; find the source code under the <kbd>worldgdp</kbd> <span>folder</span><span>. </span>After downloading, you have to build it using Maven, as follows:</p>
<pre><strong>$ mvn package</strong> </pre>
<p>The preceding command will run the tests as well. The WAR file <kbd>worldgdp.war</kbd>, present in the <kbd>target</kbd>, can be uploaded to Tomcat through the Manager app or copied to the <kbd>TOMCAT_HOME/webapps</kbd> folder. Tomcat will then explode the archive and deploy the app. </p>
<p>The following are some of the screenshots of the application in action, starting with the listing page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea8a1112-6b0f-4c4e-b506-465aa9138f3c.png" style="width:70.58em;height:30.92em;"/></p>
<p>Next is the page that displays the country details:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f99e0a4f-5bf4-494c-928b-23fadf61b223.png" style="width:48.25em;height:31.50em;"/></p>
<p>The form that is used to edit the country details is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/945cadbf-de57-4099-8259-b4c044f59bc8.png" style="width:46.50em;height:25.58em;"/></p>
<p>Then we have popups that are used to add a new city to the country, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/00f915d1-38c2-428d-bec6-a22d2df2df8e.png" style="width:29.83em;height:23.50em;"/></p>
<p>Similarly, we have another popup to add a new country language, as shown in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/07f46f66-80d6-40ef-aff2-09fbf2303055.png" style="width:27.67em;height:19.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter is designed with the aim of kick-starting your work with the Spring Framework. We have covered various topics, starting from scratch to create a project structure and design the view templates. It comprises various technologies and tools to build web-based applications in Spring. </p>
<p>It is always good practice to do more hands-on exercises to understand the concepts in detail. Next, you can think of enhancing the application further by adopting a few other World Bank APIs and integrate them in to this application. In this chapter, we have configured most of the things with our own. </p>
<p>However, Spring provides a tool called <strong>Spring Boot</strong>, which really helps in doing most of the configuration in an automated manner, allowing you to focus on developing the application. In subsequent chapters, we will explore how to use Spring Boot for developing web applications in Spring in more detail.</p>
<p>In the next chapter, we will explore another great feature called Reactive Programming in Spring Framework using WebFlux. We will learn the basics of the Reactive paradigm, what are the benefits, and explore various Reactive libraries. Spring uses <kbd>Reactor</kbd>—a library that provides implementation of Reactive Stream to develop web-based applications. So, get ready to explore all those new and exciting topics in the second chapter.</p>


            </article>

            
        </section>
    </body></html>