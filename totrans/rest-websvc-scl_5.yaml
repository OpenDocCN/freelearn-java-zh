- en: Chapter 5. Defining a REST Service Using Akka HTTP DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the successor to one of the most popular REST
    frameworks available in the Scala space, called **Spray**. Spray has been around
    for a couple of years, and provides a very extensive **domain-specific language**
    (**DSL**), which you can use to define your REST services. Spray itself isn''t
    being actively developed and has merged into the Akka HTTP initiative provided
    by Typesafe. The DSL structure and way you create REST services, however, hasn''t
    changed that much. So in this chapter, we''ll explore the following features provided
    by Akka HTTP''s DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: The first DSL-based service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verb and path handling through directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validations and JSON support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we'll first look a bit deeper at what this DSL entails
    and the history of the Akka HTTP project.
  prefs: []
  type: TYPE_NORMAL
- en: What is Akka HTTP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka HTTP is part of the Akka set of libraries and framework. Akka itself is
    a very well-known actor framework, which is used to create highly scalable, distributed,
    and resilient applications. Akka HTTP is built on top of the Akka framework, and
    the 1.0 version was released in the summer of 2015\. You can work with Akka HTTP
    in two different manners. You can use the low-level API and directly work with
    reactive flows to process the raw HTTP information, or you can use the high-level
    API and use an advanced DSL to process your requests. In this chapter, we'll use
    the latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that Akka HTTP isn't a very mature framework since the 1.0 version
    was only recently released. This isn't the case. The Akka HTTP DSL is based on
    the well-known Spray framework, which has been around for a couple of years. Development
    of Spray has stopped, and has continued in the Akka HTTP DSL project. So, for
    those of you who have experience with Spray, the DSL will look pretty much the
    same, and you'll recognize all the standard constructs from Spray.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple DSL-based service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For each framework in this book, we create a simple getting started service.
    So for Akka HTTP, we did the same thing. Before we look at the code, let''s begin
    by starting the service and firing a request using Postman. To start the service,
    from the command line, run the `sbt runCH05-HelloAkka-DSL` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up Postman, and from the **Chapter 05** collection, run the `Hello Akka-DSL`
    command. The server will respond with a simple message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple DSL-based service](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create this example, we of course need to import the external dependencies.
    For this sample, the following `sbt` dependencies are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the dependencies still have the experimental tag in their name. This
    means that the implementation might change and, at this point, there isn''t any
    official support from Typesafe yet. So there might be some changes in the future,
    which aren''t binary-compatible. Typesafe itself defines it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"This module of Akka is marked as experimental, which means that it is in
    early access mode, which also means that it is not covered by commercial support.
    An experimental module doesn''t have to obey the rule of staying binary compatible
    between minor releases. Breaking API changes may be introduced in minor releases
    without notice as we refine and simplify based on your feedback. An experimental
    module may be dropped in major releases without prior deprecation."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So at this point, it might be wise to not yet convert all your existing Spray
    code to this codebase, but wait until they move out of the experimental phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these dependencies in place, we can create our simple service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do in this service is define two implicit values. The implicit
    `ActorSystem` is needed to define the actor system that will be used to run the
    various processing steps of a request asynchronously. Akka HTTP will convert the
    DSL we create into a flow definition (which is a construct of Akka Streams). This
    flow can be seen as a blueprint of the steps that a request takes from the beginning
    to the end. The implicit `ActorMaterializer` will convert this flow into a set
    of Akka actors so that multiple requests can be executed concurrently without
    interfering with each other, which runs on the implicitly defined `ActorSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the implicits defined, we can define the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each request is passed through this route and, when one matches, its inner
    route is executed. So in this case, the following steps are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the provided URL path is checked. In this case, if the path matches `hello`,
    the inner route of the path function (this is called a **directive**) is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next check Akka HTTP makes is to see whether the verb matches. In this example,
    we check for a `GET` verb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final inner route completes the request by calling complete. When complete
    is called, the result of the provided block is returned as response. In this example,
    we just return a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last piece of code in this hello world example shuts down the server when
    a key is pressed. Shutting down the server is done through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This might seem a complex way to shut down the server, but when you look at
    the types, it is actually really simple. We call `flatMap` on the `bindingFuture`
    instance (of the type `Future[ServerBinding]`), so when the `Future` is ready
    (the server is started successfully), we call unbind on the `ServerBinding` instance.
    This, in itself, also returns a `Future`, which is flattened since we called `flatMap`.
    When this last `Future` resolves, we close the Akka system to cleanly shut down
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same way to start and stop the service in other examples.
  prefs: []
  type: TYPE_NORMAL
- en: Working with paths and directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first example we''ll look at is the first simple implementation of our
    API. We won''t be returning real objects or JSON yet, but a couple of strings.
    The code for this step looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code doesn''t look that different from the previous example we saw. We
    define a route by using directives such as `path`, `get`, `post`, and `put` and
    return values by using the `complete` function. We do, however, use a couple of
    new concepts. Before we explain the code and the concepts provided by Akka HTTP,
    first let''s fire some requests. For this, start up the example for this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up Postman in your browser and firstly execute the **Step 01 - Update
    task with id** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with paths and directives](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we return a simple response, which shows what data was sent
    to the server. Another interesting example is where we send an invalid request—**Step
    01 - Invalid request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with paths and directives](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that we can easily provide the user with additional information
    on how to use our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look a bit closer at the second part of the code we saw at the beginning
    of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we once again see the familiar `path`, `get`, and `put` directives, and
    we also use additional directives to get extra information from the request. We
    use the `IntNumber` path matcher to convert part of the path to an integer and
    use the `entity(as[String])` extractor to extract the body of the request as a
    string (we'll see more of this directive at the end of this chapter when we use
    the same approach to handle JSON input). Let's start though by looking a bit closer
    at the `path` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we already used three different path matchers. We used a string
    value to match a part of the URL, the `/` matcher to indicate that we expected
    a forward slash, and the `IntNumber` path matcher to match and extract a number.
    Besides these, you can also use the matchers explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Path matchers | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"/hello"` | This matcher matches part of the URL and also consumes it. Nothing
    is extracted here. |'
  prefs: []
  type: TYPE_TB
- en: '| `"[a-b]"r` | You can also specify a regular expression with a maximum of
    one capture group with this matcher. The capture group is extracted. |'
  prefs: []
  type: TYPE_TB
- en: '| `Map[String, T]` | Using this matcher, you can extract a value, based on
    the path that matches `Map("path1" -> 1, "path2" -> 2, "path3" -> 3)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Slash (or /)` | This matcher matches a single forward slash. |'
  prefs: []
  type: TYPE_TB
- en: '| `Segment` | This matches if the path starts with a path segment (not a forward
    slash). The current path segment is extracted as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `PathEnd` | This matches the end of the path and extracts nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| `Rest` | This matches the rest of the path and returns it as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `RestPath` | This matches the rest of the path and returns it as a path.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IntNumber` | This matches a number of digits that can be converted to an
    integer. The matched integer is extracted. |'
  prefs: []
  type: TYPE_TB
- en: '| `LongNumber` | This matches a number of digits that can be converted to a
    long number and extracts the matched long number. |'
  prefs: []
  type: TYPE_TB
- en: '| `HexIntNumber` | This matches a number of hex-digits that can be converted
    to an integer and extracts the matched integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `HexLongNumber` | This matches a number of hex-digits that can be converted
    to a long number and extracts the matched long number. |'
  prefs: []
  type: TYPE_TB
- en: '| `DoubleNumber` | This matches a number of digits that can be converted to
    a double number and extracts the matched double number. |'
  prefs: []
  type: TYPE_TB
- en: '| `JavaUUID` | This matches and extracts the string representation of a `java.util.JavaUUID`
    object. The result is a `.java.util.JavaUUID` instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `Neutral` | This matches everything and doesn''t consume anything. |'
  prefs: []
  type: TYPE_TB
- en: '| `Segments` | This is the same as the `Segment` matcher but, this time, matches
    all the remaining segments and returns these as a `List[String]` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `separateOnSlashes` | This creates a matcher that interprets slashes as path
    segment separators. |'
  prefs: []
  type: TYPE_TB
- en: '| `provide` | This matcher always matches and extracts the provided tuple value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | This operator allows you to concatenate two matchers, for example `"hello"
    ~ "world"` is the same as `"helloworld"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | This combines two matchers together. The right-hand side one will
    only be evaluated when the left-hand side one fails to match. |'
  prefs: []
  type: TYPE_TB
- en: '| Postfix: `?` | The `?` postfix makes the matcher optional, and it will always
    match. The result of the extracted value will be an `Option[T]` object. |'
  prefs: []
  type: TYPE_TB
- en: '| Prefix: `!` | This prefix inverses the matcher. |'
  prefs: []
  type: TYPE_TB
- en: '| Postfix: `.repeat` | With `repeat`, you can make a matcher that repeats itself
    the specified amount of time. |'
  prefs: []
  type: TYPE_TB
- en: '| `transform, flatMap, map` | This allows you to customize the matcher and
    create your own custom logic. |'
  prefs: []
  type: TYPE_TB
- en: 'So even in the `path` directive, you can already extract a lot of information
    and apply multiple matchers. Besides the `path` directive, there are a lot of
    other directives. We''ve already seen the entity extracted in this example used
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use an extractor, the extracted value is passed as an argument to
    the inner route (`body` in this code fragment). Akka HTTP comes with a large number
    of extractors you can use to get values out of the request. The following table
    shows the most useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directive | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cookie("name")` | This extracts a cookie with the specified name and returns
    an `HttpCookiePair` instance. There is also an `Option` variant—`optionalCookie`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `entity(as[T])` | This unmarshals the request entity to the specified type
    (for more information, see the section on JSON). |'
  prefs: []
  type: TYPE_TB
- en: '| `extractClientIp` | This extracts the client''s IP from either the X-Forwarded-
    or Remote-Addressor X-Real-IP header as a `RemoteAddress`. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractCredentials` | This gets an `Option[HttpCredentials]` from the authorization
    header. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractExecutionContext` | This provides access to the Akka `ExecutionContext`
    instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractMaterializer` | This provides access to the Akka `Materializer`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `extractHost` | This gets the `hostname` part of the host request header
    value as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractMethod` | This extracts the request method as an `HttpMethod`. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractRequest` | This provides access to the current `HttpRequest`. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractScheme` | This returns the URI scheme (`http`, `https`, and others)
    from the request as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractUnmatchedPath` | This extracts the part of the path that is unmatched
    at this point as a `Uri.Path`. |'
  prefs: []
  type: TYPE_TB
- en: '| `extractUri` | This accesses the full URI of the request as a `Uri`. |'
  prefs: []
  type: TYPE_TB
- en: '| `formFields` | This extracts fields from a POST made in an HTML form. For
    more information, see the section on path matchers. |'
  prefs: []
  type: TYPE_TB
- en: '| `headerValueByName` | This extracts the value of the first HTTP request header
    with a given name and returns it as a string. You can also get an `Option[String]`
    by using `OptionalHeaderValueByName`. |'
  prefs: []
  type: TYPE_TB
- en: '| `headerValueByType [T]` | You can also extract a header and automatically
    convert it to a specific type with this directive. For this one, there is also
    an `Option` variant—`OptionalHeaderValueByType`. |'
  prefs: []
  type: TYPE_TB
- en: '| `parameterMap` | This gets all the parameters from the request as a `Map[String,
    String]`. If multiple parameters with the same name exist, only the last one will
    be returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `parameterMultiMap` | This gets all the parameters from the request as a
    `Map[String, List[String]]`. If multiple parameters with the same name exist,
    all will be returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `parameterSeq` | This extracts all the parameters in order as a `Seq[(String,
    String)]` of tuples. |'
  prefs: []
  type: TYPE_TB
- en: '| `provide("value")` | This injects the provided value into the inner route.
    There is also a `tprovide` function, which injects a tuple. |'
  prefs: []
  type: TYPE_TB
- en: 'Most of these extractors are pretty much self-explanatory. For instance, when
    you want to extract a specific HTTP header, you can write a route like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get back to our example and look again at a very simple part of
    our route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we''ve only seen a small number of Akka directives. We looked at the
    possible extractors in the previous table, and the simple directives to match
    parts of the path and the specific-HTTP verbs. Besides these, Akka HTTP provides
    a very large number of directives, much more than we can explain in this single
    chapter. In the following table, we''ll list the directives we feel are the most
    important and flexible for you to use in the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directive | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `conditional` | This provides support for conditional requests as specified
    in [http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26](http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `decodeRequest / encodeRequest` | This compresses and decompresses a request
    that is sent using gzip or deflate compression. |'
  prefs: []
  type: TYPE_TB
- en: '| `decodeRequestWith / encodeRequestWith` | This compresses and decompresses
    a request with the specified encoder and decoder. |'
  prefs: []
  type: TYPE_TB
- en: '| `get / delete / post / put / head / options / patch` | The inner route of
    this directive will be executed when the specified HTTP verb matches. |'
  prefs: []
  type: TYPE_TB
- en: '| `host` | This only runs the inner route if the host specified in this directive
    matches. You can use strings or a regex. |'
  prefs: []
  type: TYPE_TB
- en: '| `method(httpMethod)` | This checks whether the request matches the specified
    `HttpMethod`. |'
  prefs: []
  type: TYPE_TB
- en: '| `onComplete(future)` | This runs the inner route when the provided `Future`
    completes. |'
  prefs: []
  type: TYPE_TB
- en: '| `onSuccess` | This runs the inner route when the provided `Future` completes
    successfully. |'
  prefs: []
  type: TYPE_TB
- en: '| `overrideMethodWithParameter` | This changes the method (HTTP verb) of the
    incoming request to the provided `HttpMethod`. |'
  prefs: []
  type: TYPE_TB
- en: '| `pass` | This always passes the request to the inner route. |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | If the provided path matches, this passes the request to the inner
    route (you will get to know more about it in the next example). |'
  prefs: []
  type: TYPE_TB
- en: '| `pathEnd` | This only passes the request on if its complete path is matched.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pathEndOrSingleSlash` | This only passes the request on if it''s complete
    path is matched or only a single slash remains. |'
  prefs: []
  type: TYPE_TB
- en: '| `pathPrefix` | This matches first part of a path. A leading slash is automatically
    added. If you just want to test and not consume the path, use `pathPrefixTest`.
    If you don''t want a leading slash, you can use `rawPrefix` and `rawPrefixTest`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pathSingleSlash` | This only runs the inner route if the path contains a
    single slash. |'
  prefs: []
  type: TYPE_TB
- en: '| `pathSuffix` | This checks the end of the current path and, if it matches,
    runs the inner route. If you just want to test and not consume the path, use the
    `pathSuffixTest` directive. |'
  prefs: []
  type: TYPE_TB
- en: '| `requestEncodedWith` | This checks whether the request encoding matches the
    specified `HttpEncoding`. |'
  prefs: []
  type: TYPE_TB
- en: '| `requestEntityEmpty` | This matches if the request doesn''t contain a body.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `requestEntityPresent` | This matches if the request contains a body. |'
  prefs: []
  type: TYPE_TB
- en: '| `scheme("http")` | This checks the scheme of the request. If the scheme matches,
    the request is passed on to the inner route. |'
  prefs: []
  type: TYPE_TB
- en: '| `validate` | This allows you to test against an arbitrary condition. |'
  prefs: []
  type: TYPE_TB
- en: 'Before we move on to the next example, we''ll quickly look at one last inner
    route that we saw at the beginning of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this inner route, we inform Akka HTTP that the inner route rejects the
    request. In this case, we reject the request because the `HttpMethod` (the verb)
    didn't match anything we can process. When you reject a request, Akka HTTP will
    check whether there are any routes that might match and, if not, will convert
    the rejection in to an HTTP error message. Further, in this chapter, we'll look
    a bit closer at how Akka HTTP works with rejections and handles exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Processing request parameters and customizing the response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll dive a bit deeper into how we can extract query parameters
    from requests and how to customize the response you send back to the client. In
    this section, we''ll look a bit closer at how to implement the following requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a task**: We''ll use a set of query parameters to create a new task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get all tasks**: We will return all the tasks that have been created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get a task**: We will return a specific task based on the provided ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each of these requests, we''ll first show the call from Postman and then
    how it is implemented with Akka HTTP. First, start up the correct server with
    the `sbt runCH05-runCH05Step2` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open Postman and execute the **Step 02 - Create Task** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing request parameters and customizing the response](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the response, you can see that we return a string representation of the
    task that was added, and that the content of the task is based on the query parameters
    in the URL. To accomplish this, we implement the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this route, we first combine two directives, the `post` directive and the
    `parameters` directive by using the `&` symbol. This means that both directives
    should match before the inner route is executed. There is also a `|` symbol you
    can use, which means either the left or the right directive should match (`put`
    `|` `post`). The parameters, together with the body, are used to create a `Task`
    instance using the `TaskService` object. The resulting `Future[Task]` is then
    converted to a `Future[String]` and returned. We need to convert the `Task` to
    a string here manually since we haven''t told Akka HTTP how to deal with the `Task`
    class (you will get to know more about it later). If you look at the parameters
    directive, you''ll not only recognize the query parameters from the original request,
    but also see a number of modifiers. The following bullets explain how the parameters
    directive works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"title"`: This extracts the value of the parameter as a string. This marks
    this query parameter as required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"person".?`: By using the `.?` postfix, you make a value optional. This result
    is an `Option[String]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"status" ? "new"`: This retrieves the parameter and, if it can''t be found,
    uses the default value (`"new"` in this case). The result is a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"status" ! "new"`: This requires the query parameter with the name `"status"`
    to be `"new"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"number".as[Int]`: This tries to convert the parameter to the specified type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"title.*"`: This extracts multiple instances of the title parameter to an
    `Iterable[String]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"number".as[Int].*`: This is same as the previous function, but works on types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So for our sample, we require a `title` parameter, an optional `person` parameter,
    and an optional `status` parameter, which has a default value of `"new"`. With
    these constructs, it is very easy to extract the correct values from a request's
    query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look a bit closer at the response we send back from this example.
    We use the complete directive which we''ve seen earlier, and just return a `Future[String]`
    instance. Since it is a string, Akka HTTP knows how to marshal it to an HTTP response.
    We use the same approach for the get all tasks request. From Postman, after you''ve
    created a couple of tasks, make the **Step 02 - Get All** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing request parameters and customizing the response](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll see that you get back the list of tasks you''ve created. Once again,
    it''s very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We make a call to the `TaskService` object, which returns a `Future[List[Task]]`
    instance. Since we haven't told Akka HTTP yet how to handle this type, we manually
    convert it to the correct type and use `complete` to send back the response. So
    far, we've only seen the use of complete. In most cases, the default behavior
    provided by Akka HTTP is good enough, however, there are also different ways you
    can customize the response that is sent by Akka HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Postman again, use the **Step 02 - Create Task** option to create a number
    of tasks and this time execute the **Step 02 – Get Task Invalid** request to get
    a single request. This request will try to get the request with ID 100, which
    is invalid (unless you added 100 tasks). The result looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing request parameters and customizing the response](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, this time we get a **404** message, with a custom error message.
    If you make a request for a task which is available (use the Step **02 – Get Task**
    request), you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing request parameters and customizing the response](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the rest, there isn't too much special in these two requests. However, if
    you look at the **Cookies** and **Headers** tabs, you might notice that we get
    additional results there. If you open these tabs, you'll notice a custom hello
    cookie with `world` as the value, and in the **Headers** tab, we added a custom
    header called **helloheader**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we used a couple of standard Akka HTTP features. The following
    code fragment shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code fragment, we use a couple of directives provided by Akka HTTP that
    can be used to customize the response to a request. With the `setCookie` and `respndWithHeader`
    directives, we add the custom cookie and header. In the inner route of this directive,
    we use the `onComplete` directive to determine what to do with the response from
    the `TaskService.select` function. If the `Future` succeeds with `Some[Task]`,
    we respond with this `Task`. If no `Task` is found, we return with a `404` (the
    `NotFound` status code). Finally, if the `Future` fails to complete successfully,
    we respond with an `InternalServerError`. You might notice that this time, we
    didn't convert the `Task` to a string, but just returned it. This works in this
    case because we've also defined an implicit, `ToEntityMarshaller[Task]`. This
    marshaller allows Akka HTTP to convert the `Task` case class to an `HTTPEntity`
    instance, which Akka HTTP knows how to marshal to an `HttpResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the directives shown here, Akka HTTP provides a number of other directives
    and functions you can use to customize the responses. The following table shows
    the directives related to customizing the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directive | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `complete` | This completes the request with the provided arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `completeOrRecoverWith` | This returns the result of the provided `Future`
    object. If the `Future` fails the exception is extracted and the inner route is
    run. |'
  prefs: []
  type: TYPE_TB
- en: '| `completeWith` | This extracts a function that can be called to complete
    the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFromBrowseableDirectories` | This serves the content of the given directories
    as a file-system browser. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFromBrowseableDirectory` | This serves the content of the given directory
    as a file-system browser. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFromDirectory` | This matches a `GET` request and returns with the content
    of a file in a specific directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFromFile` | This matches a `GET` request and returns with the content
    of a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFromResource` | This matches a `GET` request and returns with the content
    of a classpath resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFromResourceDirectory` | This matches a `GET` request and returns with
    the content of a classpath resource in a specified classpath directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `listDirectoryContents` | This matches a `GET` request and returns with the
    content of a specific directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect` | This sends a redirection response. There are also more specific
    directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`redirectToNoTrailingSlashIfPresent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirectToTrailingSlashIfMissing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `respondWithHeader` | This sets a specific header on the response object.
    You can also add multiple headers at once using the `responseWithHeaders` directive.
    This directive overwrites the already set headers. If you don''t want to override
    the existing headers, use the following directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`respondWithDefaultHeaders`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`respondWithDefaultHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `setCookie, deleteCookie` | This adds or deletes a cookie. |'
  prefs: []
  type: TYPE_TB
- en: '| `overrideStatusCode` | This sets the HTTP status code of the response. Akka
    HTTP provides a `StatusCode` object, which you can use to access all the available
    response codes. |'
  prefs: []
  type: TYPE_TB
- en: 'If these directives aren''t enough, there is also the option to simply return
    an `HttpResponse` object. Akka HTTP provides an `HttpResponse` case class for
    that, which you can use like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So far in this chapter, we saw how to access and extract information from the
    request and ways to set and customize the response. In the last couple of pages
    from this chapter, we'll look at the different ways you can handle errors and
    exception situations from Akka HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling and rejections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at how Akka HTTP handles exceptions and rejections.
    Before we look at the code, we''ll once again use Postman to show what we want
    to accomplish. Let''s start with how rejections are handled. Rejections are functional
    errors that are either thrown by directives or which you can throw yourself. In
    this example, we add some validations to the create task request. So run `sbt
    runCH05-runCH05Step3`, open up Postman, and execute the request, **Step 03 - Rejection
    handling**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exception handling and rejections](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the response, the title of the task we want to create must
    be at least 10 characters. The code where we add this validation and also configure
    the rejection handler is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code we use the `validate` directive to check the incoming parameters.
    If one of the validations fails, the request will be rejected with a `ValidationRejection`
    result. We''ve wrapped this route with the `handleRejections` directive, so all
    the rejections from this route will be caught by this handler. The following code
    fragment shows what this handler looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When you want to create a rejection handler, it's easiest to use the `RejectionHandler.newBuilder`
    object. This object provides you with a couple of functions you can call to define
    this handler's behavior. The `handle` function we used here allows us to handle
    single rejections, and we used this to respond with a 400 bad request, when a
    `ValidationRejection` occurs. Any other rejections bubble up the route. Besides
    `handle`, you can also use `handleAll` to handle multiple instances of the same
    rejection at the same time. Finally, there is a specific `handleNotFound` function
    you can use to define behavior for when a resource isn't found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling exceptions works in pretty much the same way. Open up Postman again
    and use the **Step 03 - Exception handling** request to trigger an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exception handling and rejections](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we return an internal server error. The following code fragment
    shows how to do this with Akka HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using an exception handler is not that different from the rejection
    handler we discussed previously. This time, we define an `ExceptionHandler` and
    use the `handleExceptions` directive to connect it to a specific part of the route.
    For the `ExceptionHandler`, we only provide a partial function where we specify
    the exceptions to catch.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we explicitly used the `handleExceptions` and `handleRejections`
    functions to define which handler to use for part of the route. If you want to
    create a custom handler that matches the complete request, you can also define
    the handlers as implicits. This way, they will be used for all the rejections
    and exceptions produced by the route. Also, good to note is that you don't necessarily
    have to match all the rejections and exceptions. If you don't match a specific
    exception or rejection, it will bubble up to one higher in the route and, eventually,
    it will reach the Akka HTTP provided default handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sample, we''ve so far seen the `handleRejections` and `handleExceptions`
    directives; there are a couple of other directives and functions available that
    are related to rejections and exceptions. The following table lists all of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directive | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `handleRejection` | This handles the current set of rejections using the
    provided `RejectionHandler`. |'
  prefs: []
  type: TYPE_TB
- en: '| `handleException` | This handles exceptions thrown from the inner route using
    the provided `ExceptionHandler`. |'
  prefs: []
  type: TYPE_TB
- en: '| `cancelRejection` | This allows you to cancel a rejection coming from the
    inner route. You can also use the `cancelRejections` directive to cancel multiple
    ones. |'
  prefs: []
  type: TYPE_TB
- en: '| `failWith` | This directive raises the specified exception; this should be
    used instead of throwing exceptions. |'
  prefs: []
  type: TYPE_TB
- en: '| `recoverRejections` | This directive and `RecoverRejectionsWith` allow you
    to handle rejections and transform them in to a normal result. |'
  prefs: []
  type: TYPE_TB
- en: '| `reject` | This rejects the request with the specified rejections. |'
  prefs: []
  type: TYPE_TB
- en: With these directives, and the use of global rejection and exception handlers,
    you should be able to cleanly handle the fault situations in your REST service.
  prefs: []
  type: TYPE_NORMAL
- en: For the last subject in the discussion on Akka HTTP we'll quickly show you how
    to add JSON support to your service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JSON support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a final step, we''ll add JSON support to our Akka HTTP REST service. With
    this added, we''ll be able to send JSON to our service, and Akka HTTP will automatically
    convert it to the case classes we use. The first thing we need to do is add an
    additional SBT dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once added, we need to inform Akka HTTP which of our case classes should be
    marshaled to and from JSON. The common way to do this is by defining a specific
    trait, which contains the implicits needed by Akka HTTP. For our example, we define
    that trait like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is pretty self-explanatory. What we do here is define which case
    classes should be marshaled to and from JSON. Next, we need to make sure we import
    Akka HTTP''s JSON library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, make sure we extend this trait in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can remove the custom marshallers we defined earlier in this
    chapter, and make all our methods just return the `Task` instances instead of
    converting the `Task` instances into strings. For instance, to retrieve all the
    current stored tasks, we just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To also convert incoming JSON to a `Task` object, we need to use the `entity`
    directive. The code to add a `Task` object now becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With these steps taken, we can open up Postman and see whether it works. In
    Postman, open request, **04 - Create Task**, and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding JSON support](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that the JSON sent is being processed by the server and is
    successfully added. Now repeat this a couple of times and then use the **04 -
    Get all Tasks** request to see whether we can retrieve the list of all the tasks
    we''ve added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding JSON support](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored most of the features provided by Akka HTTP. You
    learned to use the available directives to match specific request properties and
    extract information from the headers, parameters, and body of the request. Besides
    directives to process incoming requests, Akka HTTP also provides directives to
    create and customize the response that is sent back to the client. If errors occur
    while processing the request, Akka HTTP provides standard exception and rejection
    handlers. You also learned how you can override the default behavior by adding
    custom handlers. Finally, this chapter also showed you how easy it is to add JSON
    support and automatically marshal your classes to and from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the final REST framework that we'll discuss
    in this book, **Play 2**.
  prefs: []
  type: TYPE_NORMAL
