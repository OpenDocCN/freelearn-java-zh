- en: Getting to Know Implicits and Type Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解隐式和类型类
- en: We are already familiar with two cornerstones of Scala—its type system and first-class
    functions. Implicits is the third one. Implicits enable elegant designs and probably
    no state-of-the-art Scala library is possible without them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉 Scala 的两个基石——其类型系统和一等函数。隐式是第三个。隐式使得优雅的设计成为可能，而且没有隐式，可能没有哪个 Scala 库能达到当前的技术水平。
- en: In this chapter, we will start with a systematic overview of different types
    of implicits and recap the implicit scope resolution rules. After taking a short
    look at context bounds, we'll move on to type classes, the central implementation
    mechanism that's utilized in modern functional programming libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从不同类型的隐式的系统概述开始，并回顾隐式作用域解析规则。在简要查看上下文边界后，我们将继续讨论类型类，这是现代函数式编程库中使用的核心实现机制。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Types of implicits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类型的种类
- en: Context bounds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文边界
- en: Type classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类
- en: Type classes and recursive resolution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类和递归解析
- en: Type class variance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类变异性
- en: Implicit scope resolution rules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式作用域解析规则
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保您已安装以下内容：
- en: JDK 1.8+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available under our GitHub repository at
    [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04)。
- en: Types of implicits
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式类型的种类
- en: In Scala, there are a couple of different mechanisms hidden behind the keyword
    `implicit`. This list contains implicit parameters, implicit conversions, and
    implicit classes. They have slightly different semantics and it is important to
    know in which situations which one is the best fit. Each of these three types
    deserves a brief overview.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，关键字 `implicit` 后面隐藏着几种不同的机制。这个列表包括隐式参数、隐式转换和隐式类。它们具有略微不同的语义，了解在哪些情况下哪种最适合非常重要。这三种类型每一种都值得简要概述。
- en: Implicit conversions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: 'The first type of implicit in our list is implicit conversion. They allow you
    automatically to convert values of one type into values of another type. This
    implicit conversion is defined as a one-argument method that''s marked with the `implicit`
    keyword. Implicit conversions are considered to be a somewhat controversial language
    feature (we will take a look at why in a moment), so we need to enable them explicitly with
    a compiler flag or by importing the corresponding language feature:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的第一种隐式类型是隐式转换。它们允许您自动将一种类型的值转换为另一种类型的值。这种隐式转换被定义为标记有 `implicit` 关键字的单参数方法。隐式转换被认为是一种有争议的语言特性（我们稍后会探讨原因），因此我们需要通过编译器标志或导入相应的语言特性来显式启用它们：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Predef` contains a number of implicit conversions for Java-specific classes
    and primitives. For example, this is how *autoboxing* and *autounboxing* is defined
    for Scala''s `Int` and Java''s `Integer`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predef` 包含了针对 Java 特定类和原语的一组隐式转换。例如，这是 Scala 的 `Int` 和 Java 的 `Integer` 中
    *自动装箱* 和 *自动拆箱* 的定义方式：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These two methods are used by the compiler in cases where a value of type `Int`
    is expected, but the value with the type `java.lang.Integer` is provided and vice
    versa. Assuming that we have a Java method returning a random `Integer`, we would
    have implicit conversion applied in the following scenario:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在编译器期望 `Int` 类型的值，但提供了 `java.lang.Integer` 类型的值（反之亦然）的情况下被使用。假设我们有一个返回随机
    `Integer` 的 Java 方法，我们将在以下场景中应用隐式转换：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`math.abs` expects `Int`, but an `Integer` is provided, so the compiler applies
    the implicit conversion `Integer2int`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.abs` 期望 `Int` 类型，但提供了 `Integer`，因此编译器应用了隐式转换 `Integer2int`。'
- en: 'Identical principles apply to the return types in the same way that they apply
    to the parameters. If the compiler finds a method call on a type that does not
    have this method, it will look for an implicit conversion so that the original
    return type can be converted to the type that suits this method. This allows you
    to implement a pattern called **extension methods**. A `String` type in Scala
    is a perfect example. It is defined as a type alias for Java''s `String`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的原则也适用于返回类型，就像它们适用于参数一样。如果编译器在一个没有此方法的类型上找到方法调用，它将寻找隐式转换，以便原始返回类型可以转换为适合此方法的数据类型。这允许你实现一个名为**扩展方法**的模式。Scala中的`String`类型是一个完美的例子。它被定义为Java的`String`类型的类型别名：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But it is possible to call methods such as `map`, `flatMap`, `append`, `prepend`,
    and many others, which are not defined in the original `String`. This is achieved
    by converting a `String` into `StringOps` every time such a method is called:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可以调用诸如`map`、`flatMap`、`append`、`prepend`以及许多其他未在原始`String`中定义的方法。这是通过每次调用此类方法时将`String`转换为`StringOps`来实现的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The implicit conversion can be type-parameterized, but cannot be nested or
    directly chained. The compiler will only apply one implicit conversion at a time:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换可以是类型参数化的，但不能嵌套或直接链式调用。编译器一次只会应用一个隐式转换：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The compiler will accept the call with `A` because of implicit conversion `t2B` being
    in scope, but will reject everything that is neither `A` nor `B`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隐式转换`t2B`在作用域内，编译器将接受带有`A`的调用，但会拒绝既不是`A`也不是`B`的所有内容：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Sometimes, it is possible to enforce one of the conversions so that the compiler
    can then apply the other. Here, we tell the compiler to apply a conversion from
    `String` to `A[String]` by providing a type ascription. The conversion from `A`
    to `B[A]` then happens like it did previously:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可以强制执行其中一个转换，以便编译器可以应用另一个。在这里，我们通过提供类型注解来告诉编译器应用从`String`到`A[String]`的转换。然后，从`A`到`B[A]`的转换就像之前一样发生：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Quite handy, isn't it?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 非常方便，不是吗？
- en: 'Why are implicit conversions considered disputable, then? Because sometimes
    they can be applied without the developer knowing that and can change semantics
    in unexpected ways. This can be especially bad in situations where conversions
    for two types exist for both directions (like in our Int/Integer example) or when
    pre-existing types are involved. This classical example is based on having some
    implicit conversions in scope and type coercions later:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么隐式转换被认为是可疑的呢？因为有时它们可以在开发者不知道的情况下应用，并以意想不到的方式改变语义。在存在两种类型转换（如我们的Int/Integer示例）或涉及现有类型的情况下，这可能会特别糟糕。这个经典例子是基于作用域内存在一些隐式转换和后续的类型强制转换：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we can see two examples of this behavior: one with a semantically similar
    `String` plus `Int` concatenation producing different results, and another crafted
    in the same way but for `String` and `Char`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这种行为的两个例子：一个是语义上相似的`String`加`Int`连接产生不同的结果，另一个是以相同的方式制作，但用于`String`和`Char`。
- en: The reason for strange results and `IndexOutOfBoundsException` is that `Map`
    and `List` both implement `PartialFunction`, and thus just `Function1`. In our
    case, it's `Int => String` for the `List` and `Char => String` for the `Map`.
    Both are defined as implicit, and at the moment one of both type conversions is
    required, the corresponding function is applied.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的结果和`IndexOutOfBoundsException`的原因是`Map`和`List`都实现了`PartialFunction`，因此只是`Function1`。在我们的例子中，对于`List`是`Int
    => String`，对于`Map`是`Char => String`。两者都被定义为隐式的，并且当需要其中一个类型转换时，相应的函数会被应用。
- en: Because of this unpredictability, the use of implicit conversions is discouraged
    in modern Scala, though they are not removed from the language or deprecated,
    because a lot of existing implementations depend on them. They are mostly used
    to add methods to the existing classes or to add trait implementations for the
    new traits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种不可预测性，现代Scala中不建议使用隐式转换，尽管它们没有被从语言中移除或弃用，因为许多现有实现依赖于它们。它们主要用于向现有类添加方法或为新特质添加特质实现。
- en: Implicit parameters
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式参数
- en: 'Implicit parameters use the same syntax as implicit conversions, but provide
    different functionality. They allow you to pass arguments into a function automatically .
    The definition of implicit parameters is done as a separate argument list in the
    definition of the function with a leading `implicit` keyword. Only one implicit
    argument list is allowed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数使用与隐式转换相同的语法，但提供不同的功能。它们允许你自动将参数传递到函数中。隐式参数的定义是在函数定义中作为单独的参数列表完成的，前面有一个`implicit`关键字。只允许一个隐式参数列表：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implicit arguments do not require any special imports or compiler options to
    be activated. The preceding example shows that they also can be type-parameterized.
    If there is no value for the implicit argument *visible* at the moment the method
    is called, the compiler will report an error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数不需要任何特殊的导入或编译器选项来激活。前面的例子显示，它们也可以是类型参数化的。如果在调用方法时没有为隐式参数提供值，编译器将报告错误：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This error can be fixed by providing the required implicit value:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误可以通过提供所需的隐式值来修复：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If there are multiple implicit values in scope, the compiler will return an
    error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作用域中有多个隐式值，编译器将返回错误：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The solution to this problem is to remove all but one of the ambiguous implicit
    values or make one of the values *more specific*. We will look at how this can
    be done in a moment. Yet another approach is to provide the implicit value explicitly:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是移除所有除一个之外的模糊隐式值，或者使其中一个值更具体。我们稍后会看看如何做到这一点。另一种方法是显式地提供隐式值：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The implicit parameter does not need to be a value—it can be defined as a method.
    Having impure implicit methods can lead to *random* behavior, especially in the
    case of the type of implicit parameter being somewhat general:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数不需要是一个值——它可以定义为一种方法。拥有不纯的隐式方法可能会导致*随机*行为，尤其是在隐式参数类型相对通用的情况下：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because of this, there is a general rule that implicit parameters must have
    possibly specific types. Following this rule also allows you to avoid confusing
    the compiler with recursive implicit parameters like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，有一个普遍的规则，即隐式参数必须具有可能的具体类型。遵循这个规则还可以帮助你避免使用像以下这样的递归隐式参数来混淆编译器：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Done right, implicit parameters can be very useful and can provide configuration
    parameters for the implementations. Usually, it is done top-down and affects all
    layers of the program:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果做得正确，隐式参数可以非常有用，可以为实现提供配置参数。通常，它是自顶向下进行的，并影响程序的各个层：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the configuration is defined once in the top layer and automatically
    passed down to the methods in the lowest layer. As a result, the calling of the
    function becomes more readable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，配置在顶层定义一次，并自动传递到最低层的函数中。因此，函数的调用变得更加易读。
- en: 'These configuration settings are just a special case of a more general use
    case—context passing. The context is usually stable compared to normal arguments
    and it is because of this that it makes sense to pass it implicitly. The classic
    example of this is an `ExecutionContext`, which is required for most of the `Future`
    methods (we''ll take a detailed look at this in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置设置只是更通用用例的一个特例——上下文传递。与普通参数相比，上下文通常更稳定，这就是为什么隐式传递它是有意义的。这个经典的例子是`ExecutionContext`，这对于大多数`Future`方法都是必需的（我们将在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，*探索内置效果*)中详细探讨）：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The execution context usually doesn't change as opposed to the filtering logic,
    and therefore is passed implicitly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上下文通常不会改变，与过滤逻辑相反，因此它是隐式传递的。
- en: Another use case is to verify types. We already saw an example of this in [Chapter
    2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml), *Understanding Types in Scala*
    when we discussed generalized type constraints.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是验证类型。我们已经在[第2章](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml)，*理解Scala中的类型*中看到了一个例子，当时我们讨论了泛化类型约束。
- en: Implicit classes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式类
- en: 'So far, we have discussed implicit conversions and the extension methods pattern.
    The implementation is usually done in such a way that the old type is wrapped
    in an instance of a new type, which then provides the additional methods. We looked
    at `StringOps` as an example, but let''s try to come up with a homegrown implementation
    of this pattern. We''ll have a type, `A`, and we want it to be able to do some
    operation, `b`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了隐式转换和扩展方法模式。实现通常是这样的，即旧类型被包装在一个新类型的实例中，然后提供额外的功能。我们以`StringOps`为例，但让我们尝试自己实现这个模式。我们将有一个类型`A`，我们希望它能够执行某些操作`b`：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can fix the compile error by defining a class, with the required operation,
    and by providing an implicit conversion from `A` to `B`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个包含所需操作的类，并提供从`A`到`B`的隐式转换来修复编译错误：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This approach is so common that Scala has a special syntax for that called
    **implicit classes**. It combines defining a class and an implicit conversion
    into one definition of the class. The extended type becomes an argument for the
    constructor of the new class just as, in the previous code and in the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法如此常见，以至于Scala为此提供了一个特殊的语法，称为**隐式类**。它将定义一个类和一个隐式转换合并为一个类的定义。扩展类型成为新类构造函数的参数，就像在前面的代码和以下示例中一样：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It's cleaner and it does not require a `scala.language.implicitConversions` import.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更简洁，并且不需要`scala.language.implicitConversions`导入。
- en: The reason for this is that there is a subtle but significant difference between
    plain implicit conversions and implicit classes. While an implicit conversion
    can represent any kind of change, including already existing and/or primitive
    types, an `implicit` class is something that is created with the typed conversion
    in mind. The fact that it accepts the initial type as a constructor parameter
    makes it parameterized by this type—in a sense. All in all, it is safer to use
    implicit classes than implicit conversions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的原因在于，普通隐式转换和隐式类之间存在微妙但重要的区别。虽然隐式转换可以表示任何类型的改变，包括已经存在的和/或原始类型，但隐式类是一种在考虑类型转换的情况下创建的东西。它接受初始类型作为构造函数参数的事实使得它以这种方式参数化——从某种意义上说。总的来说，使用隐式类比使用隐式转换更安全。
- en: View and context bounds
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图和上下文边界
- en: Implicit conversions and implicit parameters we discussed previously, and they
    are so ubiquitous that there is a special language syntax for them, that is, view
    and context bounds. View bounds have been deprecated since Scala 2.11, but we
    believe that knowing about them will help you understand context bounds, so we'll
    cover both, though in different degrees of details.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过的隐式转换和隐式参数，它们无处不在，以至于有专门的编程语言语法来表示它们，即视图和上下文边界。自从Scala 2.11以来，视图边界已经被弃用，但我们相信了解它们将有助于你理解上下文边界，因此我们将讨论两者，尽管详细程度不同。
- en: View bounds
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图边界
- en: 'The *view bound* is a syntactic sugar for the implicit parameter, which represents
    conversion between two types. It allows you to write a method signature with such
    implicit arguments in a slightly shorter form. We can see the difference between
    these two approaches by developing a method that will compare two unrelated types
    if there is a conversion to the third specific type for both of them:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图边界*是隐式参数的语法糖，它表示两种类型之间的转换。它允许你以略短的形式编写带有这种隐式参数的方法签名。我们可以通过开发一个方法来比较两种不相关的类型，如果两者都存在转换到第三个特定类型的话，来看到这两种方法之间的区别：'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The version with view bounds (similar to the upper bound and lower bound, which
    we discussed in [Chapter 2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml), *Understanding
    Types in Scala*) has a shorter definition:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 带有视图边界的版本（类似于我们在[第2章](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml)，*理解Scala中的类型*)中讨论的上界和下界，有一个更简短的定义：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The implicit method we are using here is a `helper` method, which is defined
    in Predef as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的隐式方法是`helper`方法，它在`Predef`中定义为以下内容：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This allows us to summon an implicit value of type `T`. We're not providing
    this implicit value explicitly, and so we need to help the compiler figure out
    the sequence of calls by using the apply method on the summoned conversion.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们召唤一个类型为`T`的隐式值。我们没有明确提供这个隐式值，因此我们需要通过在召唤的转换上使用`apply`方法来帮助编译器确定调用序列。
- en: 'If the implementation is more complex as compared to the original version,
    why would we want to use it? The answer is this—it becomes much better if the
    implicit parameters were just passed over to some internal function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现比原始版本更复杂，我们为什么要使用它呢？答案是——如果隐式参数只是传递给某个内部函数，它就会变得更好：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like we said previously, view bounds have been deprecated since Scala 2.11,
    so we won't go into further details. Instead, we'll give our attention to context
    bounds.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，自从 Scala 2.11 以来，视图边界已经被弃用，所以我们不会进一步讨论。相反，我们将关注上下文边界。
- en: Context bounds
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文边界
- en: 'There is a yet another special case with implicit parameters where they are
    parameterized with the types of normal parameters. In this case, our previous
    example could be rewritten as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐式参数以正常参数的类型进行参数化的另一个特殊情况下，我们之前的示例可以重写如下：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we have already mentioned, there is also some syntactic sugar for this case
    named *context bounds*. With context bounds, our example can be simplified as
    follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，为此情况提供了一些语法糖，称为 *上下文边界*。有了上下文边界，我们的示例可以简化如下：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As in the previous case, this syntax becomes concise in the case of the implicit
    parameters being passed over to the internal function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个例子，当隐式参数传递给内部函数时，这种语法变得简洁：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, this is short and readable!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这既简短又易于阅读！
- en: 'What is missing is the implementation of the implicit parameters for the different
    `CA` and `CB`. For `String`, it might be implemented as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的是为不同的 `CA` 和 `CB` 实现隐式参数。对于 `String` 类型，可能实现如下：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The implementation for `Int` is done in a very similar way. Using single abstract
    method syntax, we can replace the class definition with a function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int` 的实现以非常相似的方式进行。使用单抽象方法语法，我们可以用函数替换类定义：'
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can do this with even shorter code by using the identity in curried form:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用柯里化的恒等函数来用更短的代码实现这一点：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can use our implicit values to call functions with context bounds:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的隐式值来调用具有上下文边界的函数：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous snippet, the compiler resolves different implicits for different
    types of parameters, and these implicits are used to compare the arguments of
    the function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，编译器为不同类型的参数解析不同的隐式参数，这些隐式参数用于比较函数的参数。
- en: Type classes
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类
- en: 'The previous example demonstrated that we need three parts for context bounds
    to work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，为了使上下文边界工作，我们需要三个部分：
- en: A parameterized type, `T`, which is defined as an implicit parameter of the
    function we're going to call
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被定义为将要调用的函数的隐式参数的参数化类型 `T`
- en: One or more operations (methods) which are defined on `T`, and which will be
    available after the conversion
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `T` 上定义的一个或多个操作（方法），在转换后可用
- en: Implicit instances that implement `T`
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `T` 的隐式实例
- en: In the case of the type referred to of the method definition being an abstract
    one and the mentioned method being implemented in different ways in instances,
    we're talking about *ad-hoc polymorphism* (as opposed to parametric polymorphism
    for functions, and subtype polymorphism for subclasses). Here, we will explore
    how this concept is implemented with type classes, how the compiler finds suitable
    instances if needed, and how variance applies in ad hoc polymorphic cases.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法定义中引用的类型是抽象的，并且该方法在实例中以不同的方式实现，那么我们谈论的是 *特殊参数多态*（与函数的参数多态和子类多态相对）。在这里，我们将探讨如何使用类型类实现这个概念，如果需要，编译器如何找到合适的实例，以及如何在特殊参数多态的情况下应用变异性。
- en: Type classes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类
- en: Ad-hoc polymorphism is especially useful in languages that aren't object-oriented
    and thus can't have subtype polymorphism. One example of such a language is Haskell.
    The pattern we're discussing is named *type classes* in Haskell and this name
    also came over to Scala. Type classes are widely used in `stdlib` and open source
    libraries and are fundamental for functional programming in Scala.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 针对非面向对象的语言，特别是那些不能有子类型多态性的语言，如 Haskell，这种特殊的参数多态非常有用。我们讨论的模式在 Haskell 中被称为 *类型类*，这个名字也传到了
    Scala 中。类型类在 `stdlib` 和开源库中广泛使用，并且对于 Scala 的函数式编程至关重要。
- en: The name *type classes* sound very familiar for an object-oriented developer
    because of the notion of classes. Unfortunately, it has nothing to do with classes
    in the OO sense and is just confusing. It helped me to think about type classes
    as a *class of types* instead in order to rewire my brain for this pattern.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向对象开发者来说，由于类这个概念，*类型类*这个名字听起来非常熟悉。不幸的是，它与面向对象的类没有关系，反而让人困惑。为了重新调整我的大脑以适应这个模式，我帮助自己将类型类视为*类型的一个类*。
- en: 'Let''s compare it to the traditional object-oriented approach and a type class
    that is used to define a set of USB cables. With OO, we would have the following
    definition:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与传统面向对象方法以及用于定义一组 USB 电缆的类型类进行比较。在面向对象中，我们会得到以下定义：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Each of the subclasses implements the `connect` method by overriding the base
    traits'' method. The `connectCable` just delegates the call to the instance, and
    proper implementation is called using dynamic dispatch:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子类通过重写基特质的 `connect` 方法来实现 `connect` 方法。`connectCable` 只是将调用委托给实例，并通过动态分派调用适当的实现：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The type class version looks slightly different. The classes do not need to
    extend the `Cable` any more (and thus are free to be a part of a different class
    hierarchy). We''ve also made a `UsbC` type generic, just for fun:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类版本看起来略有不同。类不再需要扩展 `Cable`（因此可以成为不同类层次结构的一部分）。我们还为了好玩，将 `UsbC` 类型泛型化：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The connection logic has moved into the type class that''s been parameterized
    by the type of the cable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 连接逻辑已经移动到了由电缆类型参数化的类型类中：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It is implemented in the respective type class instances:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它是在相应的类型类实例中实现的：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or in the same approach using single abstract method syntax:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用相同的方法，使用单个抽象方法语法：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can''t just define an implicit instance for our recently parameterized `UsbC`
    as we can''t provide a generic implementation for *any* type parameter. The instance
    for the `UsbC[String]` (the same as in the OO version) can be easily implemented
    through the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能为最近参数化的 `UsbC` 定义一个隐式实例，因为我们不能为任何类型参数提供一个通用实现。`UsbC[String]` 的实例（与面向对象版本相同）可以通过以下方式轻松实现：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `connectCable` is implemented with the context bound and uses ad-hoc polymorphism
    to select a proper delegate method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectCable` 是通过上下文绑定实现的，并使用临时多态来选择合适的委托方法：'
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This method can be called in the same way we called its OO sibling:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以像调用它的面向对象兄弟一样调用：
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On the call side, we have the same syntax, but the implementation is different.
    It is completely decoupled—our case classes don't know anything about the connection
    logic. In fact, we could have implemented this logic for the classes defined in
    another, closed source library!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用端，语法相同，但实现不同。它是完全解耦的——我们的案例类对连接逻辑一无所知。实际上，我们可以在另一个封闭源代码库中为定义的类实现这个逻辑！
- en: Type class recursive resolution
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类递归解析
- en: In our previous example, we haven't implemented the connection functionality
    for the parameterized `UsbC` type, and our solution was only limited to `UsbC[String]`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们没有为参数化的 `UsbC` 类型实现连接功能，我们的解决方案仅限于 `UsbC[String]`。
- en: We could improve our solution by further delegating the connection logic. Say
    that we have an implicit function, `T => Boolean`, available—we could say that
    this is the logic the user of our library wants to use to describe the connection
    method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进一步委托连接逻辑来改进我们的解决方案。比如说，我们有一个隐式函数 `T => Boolean` 可用——我们可以说这是用户想要用来描述连接方法的逻辑。
- en: This is an example of a *bad* use of implicits. This does not only include *primitive* `Boolean` types;
    it is highly probable that it will refer to another predefined type at the moment
    the implicit conversion will be defined. We provide this example exactly as it
    is mentioned—as an illustration of the bad design to be avoided!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**不良**使用隐式的例子。这不仅包括**原始**的 `Boolean` 类型；在定义隐式转换的时刻，它很可能引用另一个预定义的类型。我们提供这个例子正是如它所提及的那样——作为一个避免不良设计的示例！
- en: 'This is what our delegate method could look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的委托方法可能的样子：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It literally reflects the intuition we had for the delegating function—the compiler
    will create an instance of `Cable[UsbC[T]]` if there is an implicit conversion
    of `T => Boolean` available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它直接反映了我们对委托函数的直觉——如果存在 `T => Boolean` 的隐式转换，编译器将创建一个 `Cable[UsbC[T]]` 的实例。
- en: 'This is how this could be used:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的用法：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'But then, we have to deal with all of the dangers of the implicit conversion
    we''re delegating to. For example, having the following unrelated conversions
    in scope:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后，我们必须处理我们委托的隐式转换的所有危险。例如，存在以下无关的转换：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Would suddenly allow us to connect cables in unexpected ways:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将突然允许我们以意想不到的方式连接电缆：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It might look like it is a dangerous approach to have an implicit definition
    that relies on the existence of another implicit in order to produce the required
    implicit value, but this is exactly what gives type classes their power.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一种危险的方法，即依赖于另一个隐式定义的存在来产生所需的隐式值，但这正是类型类获得其力量的原因。
- en: 'To demonstrate this, let''s imagine that we''d like to implement a USB adapter
    that should connect two USB devices with different standards. We could do this
    easily by representing our adapter as a pair of cable ends to connect, and delegating
    the real connection to the respective end of the cable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们想象我们想要实现一个USB适配器，该适配器应该连接具有不同标准的两个USB设备。我们可以通过将适配器表示为连接电缆的两个电缆端来轻松实现这一点，并将实际连接委托给电缆的相应端：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or, we could use context bounds and SAM syntax:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用上下文界限和SAM语法：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can use this implicit to call our existing `connectCable` method, but
    with the adapter logic:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个隐式定义来调用我们现有的`connectCable`方法，但带有适配器逻辑：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Impressive, isn't it? Just imagine how much effort would be needed to add this
    functionality to the OO version!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 非常令人印象深刻，不是吗？想象一下，要为OO版本添加这个功能需要多少努力！
- en: 'The fun does not stop here! Because of the recursive nature of the context
    bound resolution, we can now build a chain of any length and the compiler will
    recursively check if it is possible to build the required adapter at compile time:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 乐趣还没有结束！由于上下文界限解析的递归性质，我们现在可以构建任意长度的链，编译器将递归地检查在编译时是否可以构建所需的适配器：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can improve the error message a bit by applying a special annotation on
    our type class definition:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的类型类定义上应用特殊注解来稍微改进错误信息：
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, our last unsuccessful attempt will explain the reason for the failure
    a bit better:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的最后一次失败的尝试将更好地解释失败的原因：
- en: '[PRE50]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unfortunately, this is only as far as we can get in this case. The compiler
    can't currently figure out that the real reason for the failure is just `UsbC[Long]`
    and not the whole type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，在这个案例中我们只能做到这一步。编译器目前无法确定失败的真实原因仅仅是`UsbC[Long]`而不是整个类型。
- en: The compiler will always try to infer the most specific implicit value with
    respect to subtyping and variance. This is why it is possible to combine subtype
    polymorphism and ad-hoc polymorphism.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将始终尝试根据子类型和方差推断最具体的隐式值。这就是为什么可以结合子类型多态和特设多态。
- en: Type class variance
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类方差
- en: 'To see how this combination works, let''s imagine that our USB cables represent
    a hierarchy with a common ancestor:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这种组合是如何工作的，让我们想象我们的USB电缆代表一个具有共同祖先的层次结构：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How will this affect our type class definition? Well, of course, our previous
    version with every subtype implemented separately will work fine. But what if
    we would like to provide a generic type class instance for the whole `UsbConnector`
    hierarchy as shown in the following example?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将如何影响我们的类型类定义？当然，我们之前的每个子类型都单独实现的版本将正常工作。但如果我们想为整个`UsbConnector`层次结构提供一个泛型类型类实例，就像以下示例中所示，会怎样呢？
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We would not be able to connect our cables anymore:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将无法再连接我们的电缆：
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This happens because the definition of our type class is invariant—thus, we
    are expected to provide an instance of `Cable[T]` with `T <:< ``UsbC[String]`.
    Is the `usbCable` a good fit? It turns out that it is not because its return type
    is `Cable[UsbConnector]` and we're expected to provide a `UsbC[String]`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的类型类定义是不变的——因此，我们预计要提供一个`Cable[T]`的实例，其中`T <:< UsbC[String]`。`usbCable`是一个合适的匹配吗？结果证明它不是，因为它的返回类型是`Cable[UsbConnector]`，而我们期望提供一个`UsbC[String]`。
- en: We can fix this in two ways, depending upon whether we want our type class to
    work the same way for any class hierarchy or whether each class hierarchy that
    needs general treatment has to define it separately.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式解决这个问题，具体取决于我们是否希望我们的类型类对任何类层次结构都以相同的方式工作，或者是否每个需要一般处理的类层次结构都必须单独定义它。
- en: 'In the first case, we need to make sure that the compiler understands the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们需要确保编译器理解以下内容：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can check that this is currently not the case in the REPL:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在REPL中检查这目前不是这种情况：
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But we already know what we need to change in order to make it pass—our `Cable`
    should become contravariant:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们已经知道我们需要做什么才能让它通过——我们的`Cable`应该成为协变类型：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As soon as we have proper variation in the definition of the `Cable`, everything
    falls into place, and the compiler can resolve all required implicits:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`Cable`的定义中引入适当的变体，所有问题都会迎刃而解，编译器可以解决所有必需的隐式类型：
- en: '[PRE57]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Unfortunately, if we decide that we need a special handling just for some of
    the classes from our hierarchy, we won''t be able to reuse our implementation
    by defining a *more specific* type class instance:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们决定只为我们的类层次结构中的某些类进行特殊处理，我们就无法通过定义一个*更具体*的类型类实例来重用我们的实现：
- en: '[PRE58]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This test shows that the generic instance is still used and that the specific
    one is ignored.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试表明，泛型实例仍然被使用，而特定实例被忽略。
- en: 'Luckily, we have another option that is feasible in the case that we can afford
    that each hierarchy takes care of subtyping resolution on its own. In this case,
    we keep our type class invariant but change the type class instance to be of a
    specific type instead of a general one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们还有另一个选择，在我们可以承担每个层次结构自己处理子类型解析的情况下是可行的。在这种情况下，我们保持类型类的不变性，但将类型类实例改为特定类型而不是通用类型：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We need to change `val` to a `def` in order to be able to parameterize it.
    Our generalized constraint starts to fail again for the invariant type class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`val`改为`def`以便能够对其进行参数化。我们的泛化约束再次开始对不变类型类失效：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Nevertheless, we can connect the cable:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以连接电缆：
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, the compiler is able to choose the most specific instance available for
    our type class! If we bring the definition of `implicit val usbCCable` back into
    scope, we''ll see that the output changes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器能够为我们类型类选择最具体的可用实例！如果我们将`implicit val usbCCable`的定义重新引入作用域，我们会看到输出发生变化：
- en: '[PRE62]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This shows how *static overloading resolution* works. But this is only part
    of the picture. Let's clarify how and where the compiler looks for implicits if
    it needs them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了*静态重载解析*是如何工作的。但这只是部分情况。让我们澄清编译器在需要隐式类型时如何以及在哪里查找它们。
- en: Implicit scope resolution
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式作用域解析
- en: In order to put the implicits in the places where they are required, the compiler
    first has to find them. This process is called **implicit scope resolution** and
    has well-defined rules in order to guarantee that implicits are determined as
    expected by the language specification and the developer using them. Implicit
    scope resolution is a three-step process.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将隐式类型放在它们所需的位置，编译器首先必须找到它们。这个过程称为**隐式作用域解析**，并具有明确的规则，以确保隐式类型按照语言规范和开发者使用它们的方式被确定。隐式作用域解析是一个三步过程。
- en: Or four-step, if we count the case where the implicit parameter is provided
    explicitly as an argument to the method. We'll consider this case as number zero
    and won't take it into the account because it has the highest precedence and does
    not involve implicit lookup.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果我们把隐式参数作为方法参数显式提供的情况算作第四步。我们将考虑这种情况为“零”，因为它具有最高的优先级，并且不涉及隐式查找。
- en: 'We''ll provide a short overview of these steps so that we have them in one
    place for easy reference and then go into the details of each on the list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要概述这些步骤，以便我们有一个地方可以方便地参考，然后我们将详细介绍列表中的每个细节：
- en: 'The current invocation (or lexical) scope. It has precedence over the implicit
    scope and encloses implicits that are accessible directly by their names without
    prefix, such as the following:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前调用（或词法）作用域。它具有优先级，并包含可以直接通过其名称（无需前缀）访问的隐式类型，如下所示：
- en: Local declarations
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部声明
- en: Outer scope declarations
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部作用域声明
- en: Package objects
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包对象
- en: Inheritance chain
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承链
- en: Import statements
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'The implicit scope. It is looked up recursively and includes the following:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式作用域。它是递归查找的，包括以下内容：
- en: Companion object of the parameters
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的伴生对象
- en: Companion object of super types
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类型伴生对象
- en: Companion object of mixin types (supertraits)
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合类型（超特性）的伴生对象
- en: Companion object of the type
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的伴生对象
- en: Companion object of the type parameters
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型参数的伴生对象
- en: Companion object of the type constructor
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型构造器的伴生对象
- en: Static overloading rules in the case of multiple implicits being found on one
    of the scopes.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个作用域中找到多个隐式类型时的静态重载规则。
- en: Lexical scope
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法作用域
- en: Let's start with the *lexical scope*. The lexical scope defines how variables
    are resolved in nested language constructs such as methods, functions, and other
    structured blocks. In general, the definitions of outer blocks are visible from
    inside the inner block (unless they are shadowed).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*词法作用域*开始。词法作用域定义了如何在嵌套语言结构（如方法、函数和其他结构化块）中解析变量。一般来说，外部块的定义在内部块内部是可见的（除非它们被遮蔽）。
- en: 'The following listing shows all possible conflicts during implicit resolution
    in this scope:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了在此作用域中隐式解析期间的所有可能的冲突：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The possible conflicts are underlined. It is easy to see that implicit values
    in the package object, outer and inner scope, as well as those brought into the
    inner or outer scope, are of the same weight. The parameter to the class constructor
    (7) will lead to the conflict as well, if it is declared implicit.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的冲突已用下划线标出。很容易看出，包对象中的隐式值、外部和内部作用域，以及那些被引入内部或外部作用域的值，具有相同的权重。如果类构造函数的参数（7）被声明为隐式，它也会导致冲突。
- en: Implicit scope
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式作用域
- en: Now, let's move on to an example for the *implicit scope*, which has lower precedence
    than the lexical scope. The implicit scope usually includes (if applicable) the
    companion object of the type, the implicit scope of an argument's type, the implicit
    scope of type argument(s), and for nested types, outer objects.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个关于*隐式作用域*的例子，它的优先级低于词法作用域。隐式作用域通常包括（如果适用）类型的伴随对象、参数类型的隐式作用域、类型参数的隐式作用域，以及对于嵌套类型，外部对象。
- en: 'The following example demonstrates the first three cases in action:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了前三个情况的实际操作：
- en: '[PRE64]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we spread a few implicit conversions in a class hierarchy to show how
    the lookup goes over companion objects of the argument and its supertypes, including
    supertraits. The last two lines demonstrate how the implicit scope includes type
    parameters of both the constructor and parameter type of the `sorted` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在类层次结构中散布了一些隐式转换，以展示查找是如何在参数及其超类型（包括超特型）的伴随对象上进行的。最后两行演示了隐式作用域包括构造函数和`sorted`方法参数类型的类型参数。
- en: Unlike the first example, all implicits we defined in this one are unambiguous.
    If they aren't, the compiler would apply the static resolution rules to try to
    figure out the most specific implicit.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个例子不同，我们在这个例子中定义的所有隐式内容都是明确的。如果不是这样，编译器将应用静态解析规则来尝试确定最具体的隐式内容。
- en: Static overloading rules
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态重载规则
- en: The definition of static overloading rules is quite long and complicated (it
    can be found in the official documentation at [https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution](https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution)).
    It specifies a number of rules that the compiler uses to decide which alternative
    implicit is chosen. This decision is based on the relative weight of the alternatives.
    The higher weight means that the alternative `A` is more specific than `B`, and
    `A` wins.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 静态重载规则的定义相当长且复杂（可以在官方文档[https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution](https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution)中找到）。它指定了编译器用来决定选择哪个替代隐式内容的一组规则。这个决定基于替代方案的相对权重。权重越高意味着替代方案`A`比`B`更具体，`A`获胜。
- en: 'The relative weight of `A` over `B` is calculated as a sum of two numbers:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`相对于`B`的相对权重是两个数字的总和：'
- en: If `A` is defined in a class or object which is derived from the class or object
    defining `B` (simplified, `A` is derived from `B` if `A` is a subclass or companion
    object of a subclass of `B`, or `B` is a companion object of a superclass of `A`)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`A`定义在从定义`B`的类或对象派生的类或对象中（简化地说，如果`A`是`B`的子类或子类伴随对象，或者`B`是`A`的超类伴随对象`A`的子类`B`的伴随对象）
- en: If `A` is as specific as `B` (simplified, this means that if `A` is a method,
    it can be called with the same arguments as `B`; for polymorphic methods, this
    also means more specific type constraints)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`A`与`B`一样具体（简化地说，这意味着如果`A`是一个方法，它可以与`B`使用相同的参数调用；对于多态方法，这也意味着更具体的类型约束）
- en: These two rules allow you to calculate relative weights for two implicit conversions
    or parameters between 0 and 2 and to select the more suitable alternative in the
    case of the weights being different. If the weights are equal, the compiler will
    report ambiguous implicit values.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个规则允许你计算两个隐式转换或参数之间的相对权重，在权重不同的情况下选择更合适的替代方案。如果权重相等，编译器将报告模糊的隐式值。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have discussed three types of implicits in this chapter. These include implicit
    conversions, implicit classes, and implicit parameters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了三种类型的隐式表达式。这包括隐式转换、隐式类和隐式参数。
- en: We also discussed the syntactic sugar that's provided by the language in the
    form of view bounds and context bounds. We've seen how the former allows for defining
    implicit conversions in a somewhat concise way and that the latter does the same
    for type classes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了语言提供的语法糖，即视图边界和上下文边界。我们已经看到，前者以某种简洁的方式允许定义隐式转换，而后者对类型类做同样的事情。
- en: We compared object-oriented and type class based approaches in regards to polymorphic
    behavior. To depend on our knowledge of the topic, we worked through the recursive
    resolution of case classes and showed an example of type class variance.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较了面向对象和基于类型类的多态行为方法。根据我们对这个主题的了解，我们通过案例类的递归解析进行了工作，并展示了类型类变异性示例。
- en: In conclusion, we studied how the three levels of implicit scope resolution
    work. We've shown that all implicits in the lexical scope have the same precedence.
    The implicit scope is only looked at by the compiler if no suitable implicit can
    be found in the lexical scope. If there are multiple implicits in the scope, the
    static overloading rules are used to resolve possible conflicts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们研究了三个级别的隐式作用域解析的工作方式。我们已经表明，所有在词法作用域中的隐式表达式具有相同的优先级。只有当在词法作用域中找不到合适的隐式表达式时，编译器才会查看隐式作用域。如果作用域中有多个隐式表达式，则使用静态重载规则来解决可能的冲突。
- en: This chapter concludes part of the book dedicated to Scala language constructs.
    In the following chapters, we'll move over to more complex concepts. But before
    doing this, in the next chapter, we'll take a brief digression into property-based
    testing to learn about some of the techniques we'll use to validate assumptions
    about the code we'll write in the second part of this book.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了本书中关于Scala语言结构的部分。在接下来的章节中，我们将转向更复杂的概念。但在这样做之前，在下一章中，我们将简要地探讨基于属性的测试，以了解我们将用于验证本书第二部分所写代码假设的一些技术。
- en: Questions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe a case where an implicit parameter is also an implicit conversion.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一个隐式参数也是隐式转换的情况。
- en: 'Replace the following definition that uses view bounds with one using context
    bounds: `def compare[T <% Comparable[T]](x: T, y: T) = x < y`?'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下使用视图边界的定义替换为使用上下文边界的定义：`def compare[T <% Comparable[T]](x: T, y: T) = x
    < y`？'
- en: Why are type classes sometimes said to separate behavior and data?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么有时人们说类型类将行为和数据分开？
- en: It is easy to change the example of possible conflicts in lexical scope so that
    one of the implicits wins over others and so that all others can be uncommented
    without having conflicts anymore. Can you change this?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很容易改变词法作用域中可能冲突的示例，以便其中一个隐式表达式胜过其他所有隐式表达式，并且所有其他隐式表达式都可以在不产生冲突的情况下取消注释。你能改变这个吗？
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Mads Hartmann, Ruslan Shevchenko, *Professional Scala*: Writing concise and
    expressive, type-safe code in an environment that lets you build for the JVM,
    browser, and more.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mads Hartmann, Ruslan Shevchenko, *《专业Scala》*: 在一个让你为JVM、浏览器等更多环境构建的环境中使用简洁和表达性强的、类型安全的代码。'
- en: Vikash Sharma, *Learning Scala Programming*: Learn how to write scalable and
    concurrent programs in Scala, a language that grows with you.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'Vikash Sharma, *《学习Scala编程》*: 学习如何在Scala中编写可扩展和并发程序，这是一种随着你成长的语言。'
