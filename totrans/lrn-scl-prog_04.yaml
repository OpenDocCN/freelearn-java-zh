- en: Getting to Know Implicits and Type Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are already familiar with two cornerstones of Scala—its type system and first-class
    functions. Implicits is the third one. Implicits enable elegant designs and probably
    no state-of-the-art Scala library is possible without them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with a systematic overview of different types
    of implicits and recap the implicit scope resolution rules. After taking a short
    look at context bounds, we'll move on to type classes, the central implementation
    mechanism that's utilized in modern functional programming libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of implicits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type classes and recursive resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type class variance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit scope resolution rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available under our GitHub repository at
    [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Types of implicits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, there are a couple of different mechanisms hidden behind the keyword
    `implicit`. This list contains implicit parameters, implicit conversions, and
    implicit classes. They have slightly different semantics and it is important to
    know in which situations which one is the best fit. Each of these three types
    deserves a brief overview.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first type of implicit in our list is implicit conversion. They allow you
    automatically to convert values of one type into values of another type. This
    implicit conversion is defined as a one-argument method that''s marked with the `implicit`
    keyword. Implicit conversions are considered to be a somewhat controversial language
    feature (we will take a look at why in a moment), so we need to enable them explicitly with
    a compiler flag or by importing the corresponding language feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Predef` contains a number of implicit conversions for Java-specific classes
    and primitives. For example, this is how *autoboxing* and *autounboxing* is defined
    for Scala''s `Int` and Java''s `Integer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These two methods are used by the compiler in cases where a value of type `Int`
    is expected, but the value with the type `java.lang.Integer` is provided and vice
    versa. Assuming that we have a Java method returning a random `Integer`, we would
    have implicit conversion applied in the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`math.abs` expects `Int`, but an `Integer` is provided, so the compiler applies
    the implicit conversion `Integer2int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identical principles apply to the return types in the same way that they apply
    to the parameters. If the compiler finds a method call on a type that does not
    have this method, it will look for an implicit conversion so that the original
    return type can be converted to the type that suits this method. This allows you
    to implement a pattern called **extension methods**. A `String` type in Scala
    is a perfect example. It is defined as a type alias for Java''s `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is possible to call methods such as `map`, `flatMap`, `append`, `prepend`,
    and many others, which are not defined in the original `String`. This is achieved
    by converting a `String` into `StringOps` every time such a method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The implicit conversion can be type-parameterized, but cannot be nested or
    directly chained. The compiler will only apply one implicit conversion at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will accept the call with `A` because of implicit conversion `t2B` being
    in scope, but will reject everything that is neither `A` nor `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is possible to enforce one of the conversions so that the compiler
    can then apply the other. Here, we tell the compiler to apply a conversion from
    `String` to `A[String]` by providing a type ascription. The conversion from `A`
    to `B[A]` then happens like it did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Quite handy, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Why are implicit conversions considered disputable, then? Because sometimes
    they can be applied without the developer knowing that and can change semantics
    in unexpected ways. This can be especially bad in situations where conversions
    for two types exist for both directions (like in our Int/Integer example) or when
    pre-existing types are involved. This classical example is based on having some
    implicit conversions in scope and type coercions later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see two examples of this behavior: one with a semantically similar
    `String` plus `Int` concatenation producing different results, and another crafted
    in the same way but for `String` and `Char`.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for strange results and `IndexOutOfBoundsException` is that `Map`
    and `List` both implement `PartialFunction`, and thus just `Function1`. In our
    case, it's `Int => String` for the `List` and `Char => String` for the `Map`.
    Both are defined as implicit, and at the moment one of both type conversions is
    required, the corresponding function is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this unpredictability, the use of implicit conversions is discouraged
    in modern Scala, though they are not removed from the language or deprecated,
    because a lot of existing implementations depend on them. They are mostly used
    to add methods to the existing classes or to add trait implementations for the
    new traits.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implicit parameters use the same syntax as implicit conversions, but provide
    different functionality. They allow you to pass arguments into a function automatically .
    The definition of implicit parameters is done as a separate argument list in the
    definition of the function with a leading `implicit` keyword. Only one implicit
    argument list is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implicit arguments do not require any special imports or compiler options to
    be activated. The preceding example shows that they also can be type-parameterized.
    If there is no value for the implicit argument *visible* at the moment the method
    is called, the compiler will report an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This error can be fixed by providing the required implicit value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are multiple implicit values in scope, the compiler will return an
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution to this problem is to remove all but one of the ambiguous implicit
    values or make one of the values *more specific*. We will look at how this can
    be done in a moment. Yet another approach is to provide the implicit value explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The implicit parameter does not need to be a value—it can be defined as a method.
    Having impure implicit methods can lead to *random* behavior, especially in the
    case of the type of implicit parameter being somewhat general:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this, there is a general rule that implicit parameters must have
    possibly specific types. Following this rule also allows you to avoid confusing
    the compiler with recursive implicit parameters like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Done right, implicit parameters can be very useful and can provide configuration
    parameters for the implementations. Usually, it is done top-down and affects all
    layers of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the configuration is defined once in the top layer and automatically
    passed down to the methods in the lowest layer. As a result, the calling of the
    function becomes more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'These configuration settings are just a special case of a more general use
    case—context passing. The context is usually stable compared to normal arguments
    and it is because of this that it makes sense to pass it implicitly. The classic
    example of this is an `ExecutionContext`, which is required for most of the `Future`
    methods (we''ll take a detailed look at this in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The execution context usually doesn't change as opposed to the filtering logic,
    and therefore is passed implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is to verify types. We already saw an example of this in [Chapter
    2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml), *Understanding Types in Scala*
    when we discussed generalized type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have discussed implicit conversions and the extension methods pattern.
    The implementation is usually done in such a way that the old type is wrapped
    in an instance of a new type, which then provides the additional methods. We looked
    at `StringOps` as an example, but let''s try to come up with a homegrown implementation
    of this pattern. We''ll have a type, `A`, and we want it to be able to do some
    operation, `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix the compile error by defining a class, with the required operation,
    and by providing an implicit conversion from `A` to `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is so common that Scala has a special syntax for that called
    **implicit classes**. It combines defining a class and an implicit conversion
    into one definition of the class. The extended type becomes an argument for the
    constructor of the new class just as, in the previous code and in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It's cleaner and it does not require a `scala.language.implicitConversions` import.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that there is a subtle but significant difference between
    plain implicit conversions and implicit classes. While an implicit conversion
    can represent any kind of change, including already existing and/or primitive
    types, an `implicit` class is something that is created with the typed conversion
    in mind. The fact that it accepts the initial type as a constructor parameter
    makes it parameterized by this type—in a sense. All in all, it is safer to use
    implicit classes than implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: View and context bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicit conversions and implicit parameters we discussed previously, and they
    are so ubiquitous that there is a special language syntax for them, that is, view
    and context bounds. View bounds have been deprecated since Scala 2.11, but we
    believe that knowing about them will help you understand context bounds, so we'll
    cover both, though in different degrees of details.
  prefs: []
  type: TYPE_NORMAL
- en: View bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *view bound* is a syntactic sugar for the implicit parameter, which represents
    conversion between two types. It allows you to write a method signature with such
    implicit arguments in a slightly shorter form. We can see the difference between
    these two approaches by developing a method that will compare two unrelated types
    if there is a conversion to the third specific type for both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The version with view bounds (similar to the upper bound and lower bound, which
    we discussed in [Chapter 2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml), *Understanding
    Types in Scala*) has a shorter definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The implicit method we are using here is a `helper` method, which is defined
    in Predef as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to summon an implicit value of type `T`. We're not providing
    this implicit value explicitly, and so we need to help the compiler figure out
    the sequence of calls by using the apply method on the summoned conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the implementation is more complex as compared to the original version,
    why would we want to use it? The answer is this—it becomes much better if the
    implicit parameters were just passed over to some internal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Like we said previously, view bounds have been deprecated since Scala 2.11,
    so we won't go into further details. Instead, we'll give our attention to context
    bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Context bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a yet another special case with implicit parameters where they are
    parameterized with the types of normal parameters. In this case, our previous
    example could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already mentioned, there is also some syntactic sugar for this case
    named *context bounds*. With context bounds, our example can be simplified as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous case, this syntax becomes concise in the case of the implicit
    parameters being passed over to the internal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, this is short and readable!
  prefs: []
  type: TYPE_NORMAL
- en: 'What is missing is the implementation of the implicit parameters for the different
    `CA` and `CB`. For `String`, it might be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation for `Int` is done in a very similar way. Using single abstract
    method syntax, we can replace the class definition with a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do this with even shorter code by using the identity in curried form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use our implicit values to call functions with context bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, the compiler resolves different implicits for different
    types of parameters, and these implicits are used to compare the arguments of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous example demonstrated that we need three parts for context bounds
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: A parameterized type, `T`, which is defined as an implicit parameter of the
    function we're going to call
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more operations (methods) which are defined on `T`, and which will be
    available after the conversion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implicit instances that implement `T`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of the type referred to of the method definition being an abstract
    one and the mentioned method being implemented in different ways in instances,
    we're talking about *ad-hoc polymorphism* (as opposed to parametric polymorphism
    for functions, and subtype polymorphism for subclasses). Here, we will explore
    how this concept is implemented with type classes, how the compiler finds suitable
    instances if needed, and how variance applies in ad hoc polymorphic cases.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ad-hoc polymorphism is especially useful in languages that aren't object-oriented
    and thus can't have subtype polymorphism. One example of such a language is Haskell.
    The pattern we're discussing is named *type classes* in Haskell and this name
    also came over to Scala. Type classes are widely used in `stdlib` and open source
    libraries and are fundamental for functional programming in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: The name *type classes* sound very familiar for an object-oriented developer
    because of the notion of classes. Unfortunately, it has nothing to do with classes
    in the OO sense and is just confusing. It helped me to think about type classes
    as a *class of types* instead in order to rewire my brain for this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare it to the traditional object-oriented approach and a type class
    that is used to define a set of USB cables. With OO, we would have the following
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the subclasses implements the `connect` method by overriding the base
    traits'' method. The `connectCable` just delegates the call to the instance, and
    proper implementation is called using dynamic dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The type class version looks slightly different. The classes do not need to
    extend the `Cable` any more (and thus are free to be a part of a different class
    hierarchy). We''ve also made a `UsbC` type generic, just for fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection logic has moved into the type class that''s been parameterized
    by the type of the cable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It is implemented in the respective type class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in the same approach using single abstract method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t just define an implicit instance for our recently parameterized `UsbC`
    as we can''t provide a generic implementation for *any* type parameter. The instance
    for the `UsbC[String]` (the same as in the OO version) can be easily implemented
    through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `connectCable` is implemented with the context bound and uses ad-hoc polymorphism
    to select a proper delegate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This method can be called in the same way we called its OO sibling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: On the call side, we have the same syntax, but the implementation is different.
    It is completely decoupled—our case classes don't know anything about the connection
    logic. In fact, we could have implemented this logic for the classes defined in
    another, closed source library!
  prefs: []
  type: TYPE_NORMAL
- en: Type class recursive resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous example, we haven't implemented the connection functionality
    for the parameterized `UsbC` type, and our solution was only limited to `UsbC[String]`.
  prefs: []
  type: TYPE_NORMAL
- en: We could improve our solution by further delegating the connection logic. Say
    that we have an implicit function, `T => Boolean`, available—we could say that
    this is the logic the user of our library wants to use to describe the connection
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a *bad* use of implicits. This does not only include *primitive* `Boolean` types;
    it is highly probable that it will refer to another predefined type at the moment
    the implicit conversion will be defined. We provide this example exactly as it
    is mentioned—as an illustration of the bad design to be avoided!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our delegate method could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It literally reflects the intuition we had for the delegating function—the compiler
    will create an instance of `Cable[UsbC[T]]` if there is an implicit conversion
    of `T => Boolean` available.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how this could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'But then, we have to deal with all of the dangers of the implicit conversion
    we''re delegating to. For example, having the following unrelated conversions
    in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Would suddenly allow us to connect cables in unexpected ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It might look like it is a dangerous approach to have an implicit definition
    that relies on the existence of another implicit in order to produce the required
    implicit value, but this is exactly what gives type classes their power.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s imagine that we''d like to implement a USB adapter
    that should connect two USB devices with different standards. We could do this
    easily by representing our adapter as a pair of cable ends to connect, and delegating
    the real connection to the respective end of the cable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could use context bounds and SAM syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this implicit to call our existing `connectCable` method, but
    with the adapter logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Impressive, isn't it? Just imagine how much effort would be needed to add this
    functionality to the OO version!
  prefs: []
  type: TYPE_NORMAL
- en: 'The fun does not stop here! Because of the recursive nature of the context
    bound resolution, we can now build a chain of any length and the compiler will
    recursively check if it is possible to build the required adapter at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can improve the error message a bit by applying a special annotation on
    our type class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our last unsuccessful attempt will explain the reason for the failure
    a bit better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this is only as far as we can get in this case. The compiler
    can't currently figure out that the real reason for the failure is just `UsbC[Long]`
    and not the whole type.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will always try to infer the most specific implicit value with
    respect to subtyping and variance. This is why it is possible to combine subtype
    polymorphism and ad-hoc polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Type class variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see how this combination works, let''s imagine that our USB cables represent
    a hierarchy with a common ancestor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How will this affect our type class definition? Well, of course, our previous
    version with every subtype implemented separately will work fine. But what if
    we would like to provide a generic type class instance for the whole `UsbConnector`
    hierarchy as shown in the following example?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We would not be able to connect our cables anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This happens because the definition of our type class is invariant—thus, we
    are expected to provide an instance of `Cable[T]` with `T <:< ``UsbC[String]`.
    Is the `usbCable` a good fit? It turns out that it is not because its return type
    is `Cable[UsbConnector]` and we're expected to provide a `UsbC[String]`.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix this in two ways, depending upon whether we want our type class to
    work the same way for any class hierarchy or whether each class hierarchy that
    needs general treatment has to define it separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, we need to make sure that the compiler understands the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that this is currently not the case in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But we already know what we need to change in order to make it pass—our `Cable`
    should become contravariant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we have proper variation in the definition of the `Cable`, everything
    falls into place, and the compiler can resolve all required implicits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, if we decide that we need a special handling just for some of
    the classes from our hierarchy, we won''t be able to reuse our implementation
    by defining a *more specific* type class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This test shows that the generic instance is still used and that the specific
    one is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we have another option that is feasible in the case that we can afford
    that each hierarchy takes care of subtyping resolution on its own. In this case,
    we keep our type class invariant but change the type class instance to be of a
    specific type instead of a general one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change `val` to a `def` in order to be able to parameterize it.
    Our generalized constraint starts to fail again for the invariant type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, we can connect the cable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the compiler is able to choose the most specific instance available for
    our type class! If we bring the definition of `implicit val usbCCable` back into
    scope, we''ll see that the output changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This shows how *static overloading resolution* works. But this is only part
    of the picture. Let's clarify how and where the compiler looks for implicits if
    it needs them.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit scope resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to put the implicits in the places where they are required, the compiler
    first has to find them. This process is called **implicit scope resolution** and
    has well-defined rules in order to guarantee that implicits are determined as
    expected by the language specification and the developer using them. Implicit
    scope resolution is a three-step process.
  prefs: []
  type: TYPE_NORMAL
- en: Or four-step, if we count the case where the implicit parameter is provided
    explicitly as an argument to the method. We'll consider this case as number zero
    and won't take it into the account because it has the highest precedence and does
    not involve implicit lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll provide a short overview of these steps so that we have them in one
    place for easy reference and then go into the details of each on the list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current invocation (or lexical) scope. It has precedence over the implicit
    scope and encloses implicits that are accessible directly by their names without
    prefix, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local declarations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Outer scope declarations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Package objects
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance chain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import statements
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implicit scope. It is looked up recursively and includes the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion object of the parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion object of super types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion object of mixin types (supertraits)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion object of the type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion object of the type parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion object of the type constructor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Static overloading rules in the case of multiple implicits being found on one
    of the scopes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lexical scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the *lexical scope*. The lexical scope defines how variables
    are resolved in nested language constructs such as methods, functions, and other
    structured blocks. In general, the definitions of outer blocks are visible from
    inside the inner block (unless they are shadowed).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows all possible conflicts during implicit resolution
    in this scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The possible conflicts are underlined. It is easy to see that implicit values
    in the package object, outer and inner scope, as well as those brought into the
    inner or outer scope, are of the same weight. The parameter to the class constructor
    (7) will lead to the conflict as well, if it is declared implicit.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's move on to an example for the *implicit scope*, which has lower precedence
    than the lexical scope. The implicit scope usually includes (if applicable) the
    companion object of the type, the implicit scope of an argument's type, the implicit
    scope of type argument(s), and for nested types, outer objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the first three cases in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we spread a few implicit conversions in a class hierarchy to show how
    the lookup goes over companion objects of the argument and its supertypes, including
    supertraits. The last two lines demonstrate how the implicit scope includes type
    parameters of both the constructor and parameter type of the `sorted` method.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the first example, all implicits we defined in this one are unambiguous.
    If they aren't, the compiler would apply the static resolution rules to try to
    figure out the most specific implicit.
  prefs: []
  type: TYPE_NORMAL
- en: Static overloading rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of static overloading rules is quite long and complicated (it
    can be found in the official documentation at [https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution](https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution)).
    It specifies a number of rules that the compiler uses to decide which alternative
    implicit is chosen. This decision is based on the relative weight of the alternatives.
    The higher weight means that the alternative `A` is more specific than `B`, and
    `A` wins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relative weight of `A` over `B` is calculated as a sum of two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: If `A` is defined in a class or object which is derived from the class or object
    defining `B` (simplified, `A` is derived from `B` if `A` is a subclass or companion
    object of a subclass of `B`, or `B` is a companion object of a superclass of `A`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `A` is as specific as `B` (simplified, this means that if `A` is a method,
    it can be called with the same arguments as `B`; for polymorphic methods, this
    also means more specific type constraints)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two rules allow you to calculate relative weights for two implicit conversions
    or parameters between 0 and 2 and to select the more suitable alternative in the
    case of the weights being different. If the weights are equal, the compiler will
    report ambiguous implicit values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed three types of implicits in this chapter. These include implicit
    conversions, implicit classes, and implicit parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the syntactic sugar that's provided by the language in the
    form of view bounds and context bounds. We've seen how the former allows for defining
    implicit conversions in a somewhat concise way and that the latter does the same
    for type classes.
  prefs: []
  type: TYPE_NORMAL
- en: We compared object-oriented and type class based approaches in regards to polymorphic
    behavior. To depend on our knowledge of the topic, we worked through the recursive
    resolution of case classes and showed an example of type class variance.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we studied how the three levels of implicit scope resolution
    work. We've shown that all implicits in the lexical scope have the same precedence.
    The implicit scope is only looked at by the compiler if no suitable implicit can
    be found in the lexical scope. If there are multiple implicits in the scope, the
    static overloading rules are used to resolve possible conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes part of the book dedicated to Scala language constructs.
    In the following chapters, we'll move over to more complex concepts. But before
    doing this, in the next chapter, we'll take a brief digression into property-based
    testing to learn about some of the techniques we'll use to validate assumptions
    about the code we'll write in the second part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Describe a case where an implicit parameter is also an implicit conversion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following definition that uses view bounds with one using context
    bounds: `def compare[T <% Comparable[T]](x: T, y: T) = x < y`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are type classes sometimes said to separate behavior and data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is easy to change the example of possible conflicts in lexical scope so that
    one of the implicits wins over others and so that all others can be uncommented
    without having conflicts anymore. Can you change this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mads Hartmann, Ruslan Shevchenko, *Professional Scala*: Writing concise and
    expressive, type-safe code in an environment that lets you build for the JVM,
    browser, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Vikash Sharma, *Learning Scala Programming*: Learn how to write scalable and
    concurrent programs in Scala, a language that grows with you.
  prefs: []
  type: TYPE_NORMAL
