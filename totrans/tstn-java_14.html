<html><head></head><body>
		<div id="_idContainer081">
			<h1 id="_idParaDest-257" class="chapter-number"><a id="_idTextAnchor281"/>14<a id="_idTextAnchor282"/></h1>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor283"/>Server-Side Coding with Jakarta</h1>
			<p>While Javaâ€™s initial connection to the web was through applet development, it was only a few years after the language<a id="_idIndexMarker895"/> appeared that server-side Java, first called the <strong class="bold">Java 2 Enterprise Edition</strong>, or <strong class="bold">J2EE</strong>, and later called the <strong class="bold">Java Enterprise Edition</strong>, or <strong class="bold">JEE</strong>, was introduced. Unlike standalone<a id="_idIndexMarker896"/> applications that can run on your desktop, JEE applications run inside another family of Java programs called application servers. When Oracle decided to focus primarily on the core language, Java SE, the specifications and libraries were turned over to the Eclipse<a id="_idIndexMarker897"/> Foundation. These specifications and libraries were renamed <span class="No-Break"><strong class="bold">Jakarta EE</strong></span><span class="No-Break">.</span></p>
			<p>Server-side coding in any programming language typically involves software listening to an internet port, such as <strong class="source-inline">80</strong>. The passing of information from a browser to a server and back again follows the HTTP protocol. A browser delivers a request to a server. The request may be satisfied by returning a response that consists of HTML and JavaScript to the browser, which, in turn, renders a page. The HTTP protocol is language- and server-agnostic. This means that it is not tied to a specific language <span class="No-Break">or browser.</span></p>
			<p>In Java, we have a special type of class that runs in the application server waiting for a request, performs some action when the request is received, and then returns the response that the browser<a id="_idIndexMarker898"/> can render. This special class is a <strong class="bold">servlet</strong>. A servlet is called upon as if it were a regular web page. When a request arrives at the application server that must be fulfilled by a servlet, a thread to the servlet is created by the server. This means that should 100 users request the same servlet, each request gets a thread, rather than instantiating the entire object for each request. Threads are faster to create and have a smaller memory footprint than an ordinary object created with the <span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break"> keyword.</span></p>
			<p>A Jakarta EE application is packaged in a ZIP file with a <strong class="source-inline">.war</strong> extension. It does not include the JEE libraries. These libraries are part of the application server. This means that a web app is relatively small. These libraries are required to compile the code. Maven will bring down the libraries so that the Java compiler can validate your usage of Jakarta. When packaging an app into a <strong class="source-inline">.war</strong> file for the server, these libraries are not part of the <span class="No-Break">final package.</span></p>
			<p>The Jakarta EE<a id="_idIndexMarker899"/> specification describes<a id="_idIndexMarker900"/> two page-rendering libraries. The first is called <strong class="bold">Jakarta Server Pages</strong>, previously <strong class="bold">JavaServer Pages</strong>, or <strong class="bold">JSP</strong>. The second is called <strong class="bold">Jakarta Faces</strong>, previously known as <strong class="bold">JavaServer Faces</strong>, or <strong class="bold">JSF</strong>. This acronym is still used <a id="_idIndexMarker901"/>widely, rather than JF. Both libraries<a id="_idIndexMarker902"/> support the generation of HTML and JavaScript from Java code running in the application server. We will look at Jakarta Faces in the <span class="No-Break">next chapter.</span></p>
			<p>In this chapter, we will look at the <span class="No-Break">following <a id="_idTextAnchor284"/>topics:</span></p>
			<ul>
				<li>Understanding the role of the Java <span class="No-Break">application server</span></li>
				<li>Configuring a web project <span class="No-Break">wit<a id="_idTextAnchor285"/>h Maven</span></li>
				<li>Understanding what a servlet does and how it <span class="No-Break">is coded</span></li>
				<li>Configuring deployment with the <span class="No-Break"><strong class="source-inline">web.xml</strong></span><span class="No-Break"> file</span></li>
			</ul>
			<p>By the end of this chapter, you should be able to understand how a web application is constructed in Java based on HTML and how servlets <span class="No-Break">are coded.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor286"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li>A <span class="No-Break">text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
				<li>The GlassFish 7.0 <span class="No-Break">application server</span></li>
				<li>A <span class="No-Break">web browser</span></li>
			</ul>
			<p>The sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor287"/>Understanding the role of the Java application server</h1>
			<p>The center of the Jakarta EE 10 programming<a id="_idIndexMarker903"/> universe is the application server. These programs provide a range of services that your application can call upon. They also contain all the Jakarta 10 libraries that your application might need. This simply means that your application does not need to include all the required external libraries, such as what a desktop application must include in the final <span class="No-Break">JAR file.</span></p>
			<p>An application server<a id="_idIndexMarker904"/> can be designated in one of <span class="No-Break">three ways:</span></p>
			<ul>
				<li>The first is the platform. It provides the entire set of Jakarta EE <span class="No-Break">10 services.</span></li>
				<li>The second is the Web profile, which provides a subset of the <span class="No-Break">platform services.</span></li>
				<li>Finally, there is the Core profile. The smallest of the profiles, it is designed to provide the infrastructure <span class="No-Break">for microservices.</span></li>
			</ul>
			<p>The following table shows which Jakarta EE 10 libraries can be found in each profile. Libraries in the columns to the right of each profile, except for Core, are in that profile. The platform includes the Web profile and the Core profile, while the Web profile includes the Core profile. As Jakarta EE<a id="_idIndexMarker905"/> evolves, new features can be added and libraries <span class="No-Break">are updated.</span></p>
			<table id="table001-3" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Platform</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Web profile</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Core profile</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Authorization 2.1</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Expression </span><span class="No-Break" lang="en-US" xml:lang="en-US">Language 5.0</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">CDI </span><span class="No-Break" lang="en-US" xml:lang="en-US">Lite 4.0</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Activation 2.1</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Authentication 3.0</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">JSON </span><span class="No-Break" lang="en-US" xml:lang="en-US">Binding 3.0</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Batch 2.1</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Concurrency 3.0</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Annotations 2.1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Connectors 2.1</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Persistence 3.1</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Interceptors 2.1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Mail 2.1</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Faces 4.0</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">RESTful Web </span><span class="No-Break" lang="en-US" xml:lang="en-US">Services 3.1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Messaging 3.1</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Security 3.0</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">JSON </span><span class="No-Break" lang="en-US" xml:lang="en-US">Processing 2.1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Enterprise </span><span class="No-Break" lang="en-US" xml:lang="en-US">Beans 4.0</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Servlet 6.0</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Dependency </span><span class="No-Break" lang="en-US" xml:lang="en-US">Injection 2.0</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Standard Tag </span><span class="No-Break" lang="en-US" xml:lang="en-US">Libraries 3.0</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Server </span><span class="No-Break" lang="en-US" xml:lang="en-US">Pages 3.1</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">CDI 4.0</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">WebSocket 2.1</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Bean </span><span class="No-Break" lang="en-US" xml:lang="en-US">Validation 3.0</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Debugging </span><span class="No-Break" lang="en-US" xml:lang="en-US">Support 2.0</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Enterprise Beans </span><span class="No-Break" lang="en-US" xml:lang="en-US">Lite 4.0</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Managed </span><span class="No-Break" lang="en-US" xml:lang="en-US">Beans 2.0</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Transactions 2.0</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.1 â€“ Jakarta EE 10 libraries/services</p>
			<p>A platform server is expected to provide all the services listed in the previous table. A Web profile server provides Web profile and Core profile services. Finally, a Core profile server only supports what is in its column. We will only look at a few of these services in <span class="No-Break">this chapter.</span></p>
			<p>Application servers<a id="_idIndexMarker906"/> are available from several companies. These servers usually have a free community/open source edition, as well as versions with paid licensing. Paid licensing gets you support for the server. Community editions maintain mailing lists, on which you can ask questions and get a response from either the company or other users of the community editions. One specific server stands out, and that is open source. This is the<a id="_idIndexMarker907"/> Eclipse GlassFish server. This is the one we will use in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor288"/>GlassFish 7.0</h2>
			<p>The GlassFish server<a id="_idIndexMarker908"/> was initially developed by Sun Microsystems as the reference server for Java EE. This meant that any other server<a id="_idIndexMarker909"/> that wished to be identified as a Java EE server needed to pass the same <strong class="bold">Technical Compatibility Kit</strong> test suite, commonly called the <strong class="bold">TCK</strong>, <span class="No-Break">as GlassFish.</span></p>
			<p>When Oracle acquired Sun, they continued to maintain GlassFish. In 2017, Oracle decided to no longer develop Java EE. They designated the Eclipse Foundation as the new home for Java EE, who, in turn, renamed it Jakarta EE. The technology transfer included GlassFish. This also meant that Jakarta EE and GlassFish are <span class="No-Break">open source.</span></p>
			<h3>Downloading, installing, and running GlassFish</h3>
			<p>The GlassFish server<a id="_idIndexMarker910"/> can be downloaded from <a href="https://glassfish.org/">https://glassfish.org/</a>. There are two choices<a id="_idIndexMarker911"/> for a standalone server. These are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Eclipse GlassFish 7.0.0 and Jakarta EE <span class="No-Break">Platform 10</span></li>
				<li>Eclipse GlassFish 7.0.0 and Jakarta EE Web <span class="No-Break">Profile 10</span></li>
			</ul>
			<p>In addition, there are two embedded versions. An embedded version can be used as part of an application. There is just one download for each choice. These are not Linux, macOS, or Windows versions, as they all use nearly the same class files and libraries, and any specific components for a given OS are part of the single version. It is a ZIP file. Installation<a id="_idIndexMarker912"/> is quite simple. Here are <span class="No-Break">the steps:</span></p>
			<ol>
				<li><span class="No-Break">Download GlassFish.</span></li>
				<li>Set the environment or <strong class="source-inline">JAVA_HOME</strong> shell variable to the location of <span class="No-Break">your JVM.</span></li>
				<li>Unzip the file you downloaded. It should create a folder called <strong class="source-inline">glassfish7</strong> that you can now move to where you wish it <span class="No-Break">to be.</span></li>
				<li>Go to the <strong class="source-inline">bin</strong> folder in the <span class="No-Break"><strong class="source-inline">glassfish7</strong></span><span class="No-Break"> folder.</span></li>
				<li>Open a terminal or console window in the <span class="No-Break"><strong class="source-inline">bin</strong></span><span class="No-Break"> folder.</span></li>
				<li>Start the server for any OS by entering <span class="No-Break"><strong class="source-inline">asadmin start-domain</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>On Linux, ensure that the <strong class="source-inline">asadmin</strong> shell script is executable before you run it. On Windows, you will be running the <strong class="source-inline">asadmin.bat</strong> batch file. To stop a server, enter <strong class="source-inline">asadmin stop-domain</strong>. You should see messages in the console/terminal window, telling you that you are successful. If you are not, then please review the more detailed installation instructions on the <span class="No-Break">GlassFish website.</span></p>
			<ol>
				<li value="7">To test the installation, open<a id="_idIndexMarker913"/> your web browser and <span class="No-Break">enter </span><span class="No-Break"><strong class="source-inline">http://localhost:8080</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>The default ports that GlassFish listens to are <strong class="source-inline">8080</strong> for applications running on the server and <strong class="source-inline">4848</strong> for access to the admin console. If needed, both these ports can <span class="No-Break">be changed.</span></p>
			<p>You should see a web page that looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B19088_14_01.jpg" alt="Figure 14.1 â€“ The default port 8080 web page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 â€“ The default port 8080 web page</p>
			<ol>
				<li value="8">To access the admin console, <span class="No-Break">enter </span><span class="No-Break"><strong class="source-inline">http://localhost:4848</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>You should now see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B19088_14_02.jpg" alt="Figure 14.2 â€“ The port 4848 admin console"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 â€“ The port 4848 admin console</p>
			<p>You should use <strong class="bold">Change Administrator Password</strong> under <strong class="bold">Common Tasks</strong> to assign a password for the <strong class="source-inline">admin</strong> user, as you likely noticed<a id="_idIndexMarker914"/> that you were not asked for a password to access the admin console. For our purposes, there is nothing more to be done with GlassFish. When we wish to test our applications, we can use the <strong class="bold">Deploy an Application</strong> <span class="No-Break">common task.</span></p>
			<p>Explore GlassFish and read its documentation, which you will find on the download site. Its default configuration is all we need. Let us now create the necessary folder structure to build a web app <span class="No-Break">with <a id="_idTextAnchor289"/>Maven.</span></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor290"/>Configuring a web project with Maven</h1>
			<p>The first step to crafting a web app<a id="_idIndexMarker915"/> is to configure your project<a id="_idIndexMarker916"/> for Maven. First, we need to create the appropriate folder structure for any Jakarta EE application built with Maven. Here is what you need to set <span class="No-Break">it up:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B19088_14_03.jpg" alt="Figure 14.3 â€“ The required folders for a Jakarta EE app being built with Maven"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 â€“ The required folders for a Jakarta EE app being built with Maven</p>
			<p>The only difference between a Maven desktop setup and a web setup is the addition of the <strong class="source-inline">webapp</strong> folder in the <strong class="source-inline">main</strong> folder. In this folder is a <strong class="source-inline">WEB-INF</strong> folder and an optional <strong class="source-inline">styles</strong> folder. Here is a rundown of <span class="No-Break">the folder:</span></p>
			<ul>
				<li><strong class="source-inline">src/main/java</strong>: All Java source files are stored in subfolders/packages, just as we did in a <span class="No-Break">desktop app.</span></li>
				<li><strong class="source-inline">src/main/resources/</strong>: Language bundles and logger configuration files go here. Some bundles can be placed in subfolders while <span class="No-Break">others cannot.</span></li>
				<li><strong class="source-inline">src/main/webapp</strong>: This is the folder that will contain any static web pages, JavaServer pages, and JavaServer Faces pages. You can <span class="No-Break">create subfolders.</span></li>
				<li><strong class="source-inline">src/main/webapp/WEB-INF</strong>: This folder contains configuration files and private files. A private file can be anything that might just be in the <strong class="source-inline">WEB-INF</strong> folder. A URL cannot include this folder, and this is why they are considered private. The folder can be accessed by code running on <span class="No-Break">the server.</span></li>
				<li><strong class="source-inline">src/main/webapp/styles</strong>: This folder will hold any CSS files. This is not a standard folder, so you could place your CSS files in any folder, except <strong class="source-inline">WEB_INF</strong> in the <span class="No-Break"><strong class="source-inline">webapp</strong></span><span class="No-Break"> folder.</span></li>
				<li><strong class="source-inline">src/test</strong>: This is the home of any unit tests or other files used exclusively when running <span class="No-Break">unit tests.</span></li>
			</ul>
			<p>When your code is ready<a id="_idIndexMarker917"/> to be compiled, you only need to open<a id="_idIndexMarker918"/> a terminal/console window in the projectâ€™s root folder and enter the Maven command, <strong class="source-inline">mvn</strong>. If there were no errors, then you will have a new folder called <strong class="source-inline">target</strong> in your project, and in here, you will find the <strong class="source-inline">.war</strong> file. A <strong class="source-inline">.war</strong> file, like a <strong class="source-inline">.jar</strong> file, is a ZIP compressed file. The difference between them is how they are laid out in the file. Web servers expect an organization of files that is different from a <span class="No-Break">desktop program.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor291"/>Changes to the pom.xml file</h2>
			<p>A web application is packaged <a id="_idIndexMarker919"/>in a file with the <strong class="source-inline">war</strong> extension. The folder organization in this file is based on the standard for application servers. This means that the first change to the POM file will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Â Â Â Â &lt;packaging&gt;war&lt;/packaging&gt;</pre>
			<p>In our desktop pom file, we included dependencies for logging and unit testing. We will use <strong class="source-inline">java.util.logging</strong>, thus eliminating all the logging dependencies. Unit testing for web applications requires a special code runner, such as Arquillian from Red Hat. We will not be covering this and, therefore, can remove the unit testing dependencies and plugins. The new <strong class="source-inline">pom.xml</strong> file will now, starting with <strong class="source-inline">properties</strong>, contain <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Â Â Â Â &lt;properties&gt;
Â Â Â Â Â Â Â Â &lt;java.version&gt;17&lt;/java.version&gt;
Â Â Â Â Â Â Â Â &lt;project.build.sourceEncoding&gt;
Â Â Â Â Â Â Â Â Â Â Â Â UTF-8
Â Â Â Â Â Â Â Â &lt;/project.build.sourceEncoding&gt;
Â Â Â Â Â Â Â Â &lt;maven.compiler.release&gt;
Â Â Â Â Â Â Â Â Â Â Â Â ${java.version}
Â Â Â Â Â Â Â Â &lt;/maven.compiler.release&gt;
Â Â Â Â Â Â Â Â &lt;jakartaee&gt;10.0.0&lt;/jakartaee&gt;
Â Â Â Â &lt;/properties&gt;</pre>
			<p>In the <strong class="source-inline">dependencies</strong> section that follows, we show the Jakarta library dependency. Note that the <strong class="source-inline">scope</strong> setting is set to <strong class="source-inline">provided</strong>, which implies that the libraries do not get included in the <span class="No-Break">WAR file:</span></p>
			<pre class="source-code">
Â Â Â Â &lt;dependencies&gt;
Â Â Â Â Â Â Â Â &lt;dependency&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;artifactId&gt;jakarta.jakartaee-api&lt;/artifactId&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;version&gt;${jakartaee}&lt;/version&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;scope&gt;provided&lt;/scope&gt;
Â Â Â Â Â Â Â Â &lt;/dependency&gt;
Â Â Â Â &lt;/dependencies&gt;
Â Â Â Â &lt;build&gt;
Â Â Â Â Â Â Â Â &lt;finalName&gt;
Â Â Â Â Â Â Â Â Â Â Â Â ${project.artifactId}
Â Â Â Â Â Â Â Â &lt;/finalName&gt;</pre>
			<p>Unlike desktop applications, we cannot<a id="_idIndexMarker920"/> simply run a web app. It must be copied to the appropriate folder in GlassFish and then a browser opens the site. While there are Maven plugins that can do this for you, we will keep it simple. Maven will output a WAR file, and you can use the GlassFish admin console to <span class="No-Break">deploy it:</span></p>
			<pre class="source-code">
Â Â Â Â Â Â Â Â &lt;defaultGoal&gt;verify package&lt;/defaultGoal&gt;
Â Â Â Â Â Â Â Â &lt;plugins&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;plugin&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;version&gt;3.3.2&lt;/version&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;/plugin&gt;
Â Â Â Â Â Â Â Â &lt;/plugins&gt;
Â Â Â Â &lt;/build&gt;</pre>
			<p>There is another way to deploy an app. There is a folder in GlassFish <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">glassfish7\glassfish\domains\domain1\autodeploy</strong></span><span class="No-Break">.</span></p>
			<p>If you simply copy a WAR file<a id="_idIndexMarker921"/> to this folder, then the server will deploy <span class="No-Break">it automatically.</span></p>
			<p>Now, letâ€™s look at the heart of Java web programming, <span class="No-Break">the servlet.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor292"/>Understanding what a servlet does and how it is coded</h1>
			<p>In Java web programming, there is no main<a id="_idIndexMarker922"/> method. Instead, all applications must have at least<a id="_idIndexMarker923"/> one servlet. When we look at Jakarta Facesâ€™ client-side rendering, there is no servlet, as it is already part of the library. Letâ€™s look at <span class="No-Break">a servlet.</span></p>
			<p>The first line is an annotation that defines that this class is a servlet. The description is visible in the serverâ€™s admin console. The <strong class="source-inline">urlPattern</strong> attribute is the name you use in a URL. A servlet can be named anything and can have any extension, although the standard practice is to not have an extension. A servlet can have multiple patterns. Here is an example of <span class="No-Break">a servlet:</span></p>
			<pre class="source-code">
@WebServlet(description = "Basic Servlet",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â urlPatterns = {"/basicservlet"})</pre>
			<p>If we wished to refer to this servlet with more than one pattern, we could write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
@WebServlet(description = "Basic Servlet",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â urlPatterns = {"/basicservlet",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "/anotherservlet"})</pre>
			<p>A servlet in Java is a class that <span class="No-Break">extends </span><span class="No-Break"><strong class="source-inline">HttpServlet</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class BasicServlet extends HttpServlet {
Â Â Â Â private static final Logger LOG =
Â Â Â Â Â Â Â Â Â Â Logger.getLogger(BasicServlet.class.getName());</pre>
			<p>The constructor of a servlet class is rarely used because it cannot call upon any methods in the <strong class="source-inline">HttpServlet</strong> superclass. You can safely leave <span class="No-Break">it out:</span></p>
			<pre class="source-code">
Â Â Â Â public BasicServlet() {
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; Constructor &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>If you must prepare<a id="_idIndexMarker924"/> for or initialize something<a id="_idIndexMarker925"/> before the servlet receives its first request, then you can use the <strong class="source-inline">init</strong> method. It can access the superclass, but it does not get a <strong class="source-inline">request</strong> or <strong class="source-inline">response</strong> object. It is called when the servlet is run before the first <span class="No-Break">request arrives:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â public void init() throws ServletException {
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; init &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>The <strong class="source-inline">destroy</strong> method is akin to a destructor in C++. It is called by the server before it is unloaded to carry out any required <span class="No-Break">end-of-life tasks:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â public void destroy() {
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; destroy &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>The <strong class="source-inline">getServletInfo</strong> method allows you to prepare a string with information on <span class="No-Break">this servlet:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â public String getServletInfo() {
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; getServletInfo &lt;&lt;&lt;");
Â Â Â Â Â Â Â Â return "BasicServlet01 Version 2.0";
Â Â Â Â }</pre>
			<p>The <strong class="source-inline">service</strong> method is called<a id="_idIndexMarker926"/> by the server whenever a request is made to this servlet. The <strong class="source-inline">service</strong> method <a id="_idIndexMarker927"/>calls upon the <strong class="source-inline">HttpServletRequest</strong> objectâ€™s <strong class="source-inline">getMethod</strong> to determine the type of request and then calls the matching <strong class="source-inline">do</strong> method, such as <strong class="source-inline">doPost</strong> or <strong class="source-inline">doGet</strong>. The most common reason for overriding this is if you wish to perform a task regardless of the request type. In this example, we are just calling the <strong class="source-inline">service</strong> superclass method that you must do if you are not calling the appropriate method in the body of the overridden <span class="No-Break"><strong class="source-inline">service</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â protected void service(HttpServletRequest request,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â HttpServletResponse response)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â throws ServletException, IOException {
Â Â Â Â Â Â Â Â super.service(request, response);
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; service &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>There are eight different types of requests. These are the HTTP verbs that the servlet provides to support the protocol. They are <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">HEAD</strong>, <strong class="source-inline">OPTIONS</strong>, <strong class="source-inline">CONNECT</strong>, and <strong class="source-inline">TRACE</strong>. The first four are the most used, although only <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> can be used on an HTML page. To test requests that cannot be issued from an HTML page, you can use the <strong class="source-inline">curl</strong> utility. This tool allows you to send any type of request from the terminal/console of your computer. When you run this application, you will see instructions for downloading and <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â protected void doGet(HttpServletRequest request,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â HttpServletResponse response)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â throws ServletException, IOException {</pre>
			<p>There are different content types that can be returned to a browser in the <strong class="source-inline">response</strong> object. The type could be, among others, <strong class="source-inline">image/gif</strong> or <strong class="source-inline">application/pdf</strong>. Plain text <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">text/plain</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Â Â Â Â Â Â Â Â response.setContentType("text/html;charset=UTF-8");</pre>
			<p>For a servlet to return text<a id="_idIndexMarker928"/> to a browser, we use a <strong class="source-inline">PrintWriter</strong> object. It is instantiated<a id="_idIndexMarker929"/> by the <strong class="source-inline">response</strong> object such that the data you are writing will go to the URL found in the <span class="No-Break"><strong class="source-inline">response</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
Â Â Â Â Â Â Â Â try ( PrintWriter writer = response.getWriter()) {
Â Â Â Â Â Â Â Â Â Â Â Â writer.print(createHTMLString("GET"));
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; doGet &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>Here is the <strong class="source-inline">doPost</strong> method that will display the web page created by <strong class="source-inline">createHTMLString</strong> and show that a <strong class="source-inline">POST</strong> request <span class="No-Break">is issued:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â protected void doPost(HttpServletRequest request,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â HttpServletResponse response) throws
Â Â Â Â Â Â Â Â Â Â Â Â Â Â ServletException, IOException {
Â Â Â Â Â Â Â Â response.setContentType("text/html;charset=UTF-8");
Â Â Â Â Â Â Â Â try ( PrintWriter writer = response.getWriter()) {
Â Â Â Â <a id="_idTextAnchor293"/>Â Â Â Â Â Â Â Â writer.print(createHTMLString("POST"));
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; doPost &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>Here is the <strong class="source-inline">doPut</strong> method. As we can only issue <strong class="source-inline">PUT</strong> using <strong class="source-inline">curl</strong>, all it returns<a id="_idIndexMarker930"/> is a simple string that <strong class="source-inline">curl</strong> will display<a id="_idIndexMarker931"/> in <span class="No-Break">your terminal/console:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â protected void doPut(HttpServletRequest request,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â HttpServletResponse response)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â throws ServletException, IOException {
Â Â Â Â Â Â Â Â response.setContentType(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "text/plain;charset=UTF-8");
Â Â Â Â Â Â Â Â try ( PrintWriter writer = response.getWriter()) {
Â Â Â Â Â Â Â Â Â Â Â Â writer.print("You have called doPut");
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; doPut &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>Here is the <strong class="source-inline">doDelete</strong> method. Just as with <strong class="source-inline">PUT</strong>, you can only issue it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â protected void doDelete(HttpServletRequest request,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â HttpServletResponse response)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â throws ServletException, IOException {
Â Â Â Â Â Â Â Â response.setContentType(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "text/plain;charset=UTF-8");
Â Â Â Â Â Â Â Â try ( PrintWriter writer = response.getWriter()) {
Â Â Â Â Â Â Â Â Â Â Â Â writer.print("You have called doDelete");
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â LOG.info("&gt;&gt;&gt; doDelete &lt;&lt;&lt;");
Â Â Â Â }</pre>
			<p>This last method is a user<a id="_idIndexMarker932"/> method that is used to generate a string of HTML code, which can<a id="_idIndexMarker933"/> be returned to the userâ€™s browser. Note that the HTML page is enclosed in a text block using the three quotation marks. There is also a placeholder, <strong class="source-inline">%s</strong>, in the text that is replaced using the <strong class="source-inline">formatted</strong> <span class="No-Break">string method:</span></p>
			<pre class="source-code">
Â Â Â Â private String createHTMLString(String methodName) {
Â Â Â Â Â Â Â Â String htmlStr = """
Â Â Â Â Â Â Â Â Â Â Â &lt;html&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;head&gt;&lt;link rel='stylesheet'
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â href='styles/main.css'
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â type='text/css'/&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;title&gt;The Basic Servlet&lt;/title&gt;&lt;/head&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;body&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;h1&gt;%s method&lt;/h1&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;br/&gt;&lt;br/&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;form action='index.html'&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;label&gt;Return to Home page&lt;/label&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;br/&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;button class='button'&gt;Return&lt;/button&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;/form&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;/body&gt;
Â Â Â Â Â Â Â Â Â Â Â &lt;/html&gt;
Â Â Â Â Â Â Â Â Â Â Â """.formatted(methodName);
Â Â Â Â Â Â Â Â return htmlStr;
Â Â Â Â }
}</pre>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor294"/>What happens when a servlet is requested?</h2>
			<p>A servlet class is instantiated<a id="_idIndexMarker934"/> by the server either when the server begins or when the servlet is called for the first time. Once instantiated, it remains in the server until you explicitly ask the server to remove it. There is only one instance of <span class="No-Break">every servlet.</span></p>
			<p>Each request generates a thread of the servlet. Creating threads is faster than creating objects. The thread of the servlet is free to do almost anything it wants, such as instantiating other objects. Should a thread not receive a request within a user-defined time period, usually 30 minutes, it is stopped and the objects created by the thread go to <span class="No-Break">garbage collection.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor295"/>How does a servlet access the query string in a request?</h2>
			<p>Assume an HTML form that has three input fields named <strong class="source-inline">emailAddress</strong>, <strong class="source-inline">firstName</strong>, and <strong class="source-inline">lastName</strong>. Clicking on a button of the <strong class="source-inline">submit</strong> type will create a query string that will be appended to the URL if you are using a <strong class="source-inline">GET</strong> request, or added to the request body if you are using <strong class="source-inline">POST</strong>. In both cases, the data is in the <strong class="source-inline">key = value</strong> format. Here is such an <span class="No-Break">HTML page:</span></p>
			<pre class="source-code">
&lt;html&gt;
Â Â Â Â &lt;head&gt;
Â Â Â Â Â Â Â Â &lt;title&gt;Just Servlet Input&lt;/title&gt;
Â Â Â Â Â Â Â Â &lt;link rel="stylesheet" href="styles/main.css"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â type="text/css"/&gt;
Â Â Â Â &lt;/head&gt;
Â Â Â Â &lt;body&gt;
Â Â Â Â Â Â Â Â &lt;h1&gt;Join our email list&lt;/h1&gt;
Â Â Â Â Â Â Â Â &lt;p&gt;To join our email list, enter your name and
Â Â Â Â Â Â Â Â Â Â Â Â email address below.&lt;/p&gt;
Â Â Â Â Â Â Â Â &lt;form action="AddToEmailList" method="get"&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;label class="pad_top"&gt;Email:&lt;/label&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;input type="email" name="emailAddress"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â required&gt;&lt;br&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;label class="pad_top"&gt;First Name:&lt;/label&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;input type="text" name="firstName"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â required&gt;&lt;br&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;label class="pad_top"&gt;Last Name:&lt;/label&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;input type="text" name="lastName"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â required&gt;&lt;br&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;label&gt;&amp;nbsp;&lt;/label&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;input type="submit" value="Join Now"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â class="margin_left"&gt;
Â Â Â Â Â Â Â Â &lt;/form&gt;
Â Â Â Â &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>This HTML will produce the <span class="No-Break">following page:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B19088_14_04.jpg" alt="Figure 14.4 â€“ The browser rendering of the HTML"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 â€“ The browser rendering of the HTML</p>
			<p>In HTML, I use the <strong class="source-inline">method</strong> attribute to show that the type of request issued when the button is pressed is <strong class="source-inline">GET</strong>. As this form submits data to the server, it should use the <strong class="source-inline">POST</strong> method. I use <strong class="source-inline">GET</strong> here, as it shows the query string in the address bar, whereas <strong class="source-inline">POST</strong> transmits the query string in a separate component of a request and, therefore, is not visible. <strong class="source-inline">POST</strong> should also be preferred should you need to prevent the information in the query string from being sent as plain text and also shown in the <span class="No-Break">server logs.</span></p>
			<p>I have already filled out the form, and when I click on the button, the URL in the browser will be updated to show as a <span class="No-Break">single line:</span></p>
			<pre class="source-code">
http://localhost:8080/HTMLServlet/AddToEmailList?
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â emailAddress=moose%40moose.com&amp;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â firstName=Ken&amp;lastName=Fogel</pre>
			<p>The <strong class="source-inline">doGet</strong> method in the servlet<a id="_idIndexMarker935"/> can now read the three<a id="_idIndexMarker936"/> parameters. In my example, I am storing this data in a simple <span class="No-Break">JavaBean-style object:</span></p>
			<pre class="source-code">
Â Â Â Â @Override
Â Â Â Â protected void doGet(HttpServletRequest request,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â HttpServletResponse response)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â throws ServletException, IOException {</pre>
			<p>Using the names of the key values in the query string, we can retrieve the data and then assign them to the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
Â Â Â Â Â Â Â Â String firstName =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â request.getParameter("firstName");
Â Â Â Â Â Â Â Â String lastName = request.getParameter("lastName");
Â Â Â Â Â Â Â Â String emailAddress =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â request.getParameter("emailAddress");
Â Â Â Â Â Â Â Â User user =
Â Â Â Â Â Â Â Â Â Â Â Â Â new User(firstName, lastName, emailAddress);</pre>
			<p>Here, I am displaying a results page constructed in a method <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">displayConfirmation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Â Â Â Â Â Â Â Â response.setContentType("text/html;charset=UTF-8");
Â Â Â Â Â Â Â Â try (PrintWriter out = response.getWriter()) {
Â Â Â Â Â Â Â Â Â Â Â Â displayConfirmation(out, user);
Â Â Â Â Â Â Â Â }
Â Â Â Â }</pre>
			<p>The servletâ€™s output<a id="_idIndexMarker937"/> will be<a id="_idIndexMarker938"/> <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B19088_14_05.jpg" alt="Figure 14.5 â€“ Output from the servlet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 â€“ Output from the servlet</p>
			<p>Do not forget to review the source code for <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor296"/>How does a servlet remember my data?</h2>
			<p>Every time you call upon a servlet<a id="_idIndexMarker939"/> that is part of an application for the first time, you will receive an ID number that identifies an <strong class="source-inline">HttpSession</strong> object. This ID is sent as a cookie to your browser or, if you are blocking cookies, as a hidden field in the URL every time a request is made. If you already have the ID in a cookie, then that will be used. The server manages the ID; you do not need to do anything. The server uses this ID to manage the <strong class="source-inline">HttpSession</strong> object and ensure that your requests are the only ones that have access. You access the session object with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
HttpSession session = request.getSession();</pre>
			<p>If an <strong class="source-inline">HttpSession</strong> object associated with your ID exists, then it is returned. If it does not exist, then a new <strong class="source-inline">HttpSession</strong> object with its own ID is returned. We will use one of two methods in the <strong class="source-inline">HttpSession</strong> object, one for reading and one for writing. If you wanted to preserve the <strong class="source-inline">User</strong> object in this example so that it can be used in another servlet, you will code <span class="No-Break">the following:</span></p>
			<pre class="source-code">
HttpSession session = request.getSession();
session.setAttribute("myUser", user);</pre>
			<p>This <strong class="source-inline">HttpSession</strong> object will remain valid until the <strong class="source-inline">HttpSession</strong> timer, usually 30 minutes, ends or you call <strong class="source-inline">session.invalidate()</strong>. If we want to retrieve the <strong class="source-inline">User</strong> object in another servlet, then we can write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
HttpSession session = request.getSession();
String animal = (User) session.getAttribute("myUser");</pre>
			<p>You do not want to keep data<a id="_idIndexMarker940"/> around any longer than is necessary. Data stored in an <strong class="source-inline">HttpServletRequest</strong> object is lost after a response is given. In many cases, this is sufficient. However, if you were writing a shopping cart application, you would want to preserve whatever a client chooses as they move from page to page on the site. Here is where an <strong class="source-inline">HttpSession</strong> object <span class="No-Break">is used.</span></p>
			<p>Let us now look at a file that we can use to configure how a server dea<a id="_idTextAnchor297"/>ls with servlets, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">web.xml</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor298"/>Configuring deployment with the web.xml file</h1>
			<p>In the <strong class="source-inline">WEB-INF</strong> folder of a web<a id="_idIndexMarker941"/> project, there is usually a file named <strong class="source-inline">web.xml</strong>. It was mandatory before the <strong class="source-inline">@WebServlet</strong> annotation was introduced. With the annotation, the application server can determine on its own which files are servlets and which are not. There is more that you can do in this file than just list servlets. For this reason, I advise you to always have a <span class="No-Break"><strong class="source-inline">web.xml</strong></span><span class="No-Break"> file.</span></p>
			<p>Our descriptor will be <span class="No-Break">quite basic:</span></p>
			<pre class="source-code">
&lt;web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
Â Â Â Â Â xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
Â Â Â Â Â xsi:schemaLocation=
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "https://jakarta.ee/xml/ns/jakartaee
Â Â Â Â Â Â Â https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
Â Â Â Â Â Â Â version="5.0"&gt;
Â Â Â Â &lt;display-name&gt;BasicServlet&lt;/display-name&gt;
Â Â Â Â &lt;welcome-file-list&gt;
Â Â Â Â Â Â Â Â &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;
Â Â Â Â &lt;/welcome-file-list&gt;
&lt;/web-app&gt;</pre>
			<p>We have a display name that the application<a id="_idIndexMarker942"/> server can use in a report, followed by the welcome page. The welcome page is the name of the page to display if the URL does not include the page name. Letâ€™s say you type the following in <span class="No-Break">your browser:</span></p>
			<pre class="source-code">
http://localhost:8080/BasicServlet/index.html</pre>
			<p>Instead of writing that, you only need to write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
http://localhost:8080/BasicServlet</pre>
			<p>The HTTP protocol is stateless. This means that every time you make a request, the server behaves as if it is the first time you have visited the site. The application server can remember you by using an <strong class="source-inline">HttpSession</strong> object. This object has a default lifetime of 30 minutes since your last visit to the website. When the time is up, the object is invalidated, and the server will no longer remember you. You can change the length of time by adding this to the <span class="No-Break"><strong class="source-inline">web.xml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
Â Â Â Â &lt;session-config&gt;
Â Â Â Â Â Â Â Â &lt;session-timeout&gt;
Â Â Â Â Â Â Â Â Â Â Â Â 30
Â Â Â Â Â Â Â Â &lt;/session-timeout&gt;
Â Â Â Â &lt;/session-config&gt;</pre>
			<p>In some cases, you may have data, in the form of a string, which is common to every servlet in the application â€“ for example, the company email address that needs to appear on every page. We use <strong class="source-inline">context-param</strong> <span class="No-Break">for this:</span></p>
			<pre class="source-code">
Â Â Â Â &lt;context-param&gt;
Â Â Â Â Â Â Â Â &lt;param-name&gt;email&lt;/param-name&gt;
Â Â Â Â Â Â Â Â &lt;param-value&gt;me@me.com&lt;/param-value&gt;
Â Â Â Â &lt;/context-param&gt;</pre>
			<p>To access this in a servlet, we just need <span class="No-Break">the following:</span></p>
			<pre class="source-code">
String email =
Â Â Â Â Â Â Â Â Â Â getServletContext().getInitParameter("email");</pre>
			<p>You should now be able to get a web application<a id="_idIndexMarker943"/> based on a servlet up <span class="No-Break">and running.</span></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor299"/>Summary</h1>
			<p>In this chapter, we looked at the basics of a web application. The center of this universe is the servlet. There are many other frameworks, such as Spring, that provide an alternative set of libraries, yet all these frameworks sit on top of and depend upon the servlet specification, along with other <span class="No-Break">Jakarta libraries.</span></p>
			<p>Jakarta is standards-based. What this means is that by adhering to the HTTP protocols, it can provide services to any frontend, such as React.js, Bootstrap, and Angular. In the next chapter, we will look at one frontend programming library, Jakarta Faces, that is part of the <span class="No-Break">Jakarta framework.</span></p>
			<p>We used the GlassFish server in this chapter, but there are a number of other choices for a Java application server. For example, the Payara server is based on Glassfish, but as it is backed by the Payara company, it provides commercial support that is not available with Glassfish. There are also servers from Red Hat, IBM, and others. There is usually a community version that you can use without paying for a <span class="No-Break">commercial license.</span></p>
			<p>As we looked at server-side programming, we needed to make changes to our Maven <strong class="source-inline">pom.xml</strong> file. With these in place, we were able to create a <strong class="source-inline">.war</strong> file for use on the server as easily as we created desktop <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">jar</strong></span><span class="No-Break"> files.</span></p>
			<p>Next up, we will look deeper into Jakarta EE by examining an application that brings the Financial Calculator we saw in the previous chapter to <span class="No-Break">the web.</span></p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor300"/>Further reading</h1>
			<ul>
				<li>Jakarta <span class="No-Break">EE: </span><a href="https://jakarta.ee/&#13;"><span class="No-Break">https://jakarta.ee/</span></a></li>
				<li>HTTP <span class="No-Break">methods: </span><a href="https://www.tutorialspoint.com/http/http_methods.htm"><span class="No-Break">https://www.tutorialspoint.com/http/http_methods.htm</span></a></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer082" class="IMG---Figure">
			</div>
		</div>
	</body></html>