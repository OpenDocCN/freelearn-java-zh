<html><head></head><body>
<div id="_idContainer054">
<h1 class="chapter-number" id="_idParaDest-151"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-152"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.2.1">Spring Boot 3.0 Features for Containerization and Orchestration</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we are delving </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.4.1">into the realm of </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">containerization</span></strong><span class="koboSpan" id="kobo.6.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">orchestration</span></strong><span class="koboSpan" id="kobo.8.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">Spring Boot 3.0</span></strong><span class="koboSpan" id="kobo.10.1">, which is a crucial skill set for </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.11.1">contemporary developers. </span><span class="koboSpan" id="kobo.11.2">As you navigate through these pages, you will not acquire knowledge but also practical expertise that can be immediately </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.12.1">implemented in your projects. </span><span class="koboSpan" id="kobo.12.2">This journey holds significance for anyone seeking to maximize the capabilities of Spring Boot, in developing applications that are not just efficient and scalable but resilient and robust in today’s ever-evolving </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">digital world.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">Upon completing this chapter, you will possess the know-how to seamlessly containerize your Spring Boot applications, comprehend Docker intricacies as a container platform, and grasp the concepts of Kubernetes for orchestrating your containerized applications. </span><span class="koboSpan" id="kobo.14.2">These skills are pivotal in today’s software development landscape where the swiftness and reliability of application development, deployment, and management can greatly influence </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">project success.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In real-world scenarios, adaptability to environments, resource efficiency, and scalability according to demand are aspects of software development. </span><span class="koboSpan" id="kobo.16.2">This chapter addresses these requirements by highlighting the advantages of containerization and orchestration to enhance the portability, efficiency, and manageability of </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">your applications.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">In this chapter, we’ll cover </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Containerization and orchestration in </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Spring Boot</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Spring Boot </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">and Docker</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Optimizing Spring Boot apps </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">for Kubernetes</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Spring Boot Actuator with Prometheus </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">and Grafana</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">Let’s begin this journey to containerize your Spring Boot applications and make them easier </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">to manage!</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.30.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.31.1">For this chapter, we are going to need some settings in our </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">local machines:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.33.1">Java 17 Development Kit</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.35.1">JDK 17</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">A modern </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">integrated development environment</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">IDE</span></strong><span class="koboSpan" id="kobo.41.1">) – I recommend </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">IntelliJ IDEA</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">GitHub repository: You can clone all repositories related to </span><a href="B18400_07.xhtml#_idTextAnchor213"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.45.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">here: </span></span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/"><span class="No-Break"><span class="koboSpan" id="kobo.47.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.48.1">Docker Desktop</span></span></li>
</ul>
<h1 id="_idParaDest-154"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.49.1">Containerization and orchestration in Spring Boot</span></h1>
<p><span class="koboSpan" id="kobo.50.1">Welcome to the realm of containerization, where we prepare Spring Boot applications for deployment across any platform. </span><span class="koboSpan" id="kobo.50.2">If you’re curious about how container technology is revolutionizing </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.51.1">application development and deployment </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.52.1">processes, you’ve come to the right spot. </span><span class="koboSpan" id="kobo.52.2">This section will equip you with the insights to bundle your Spring Boot application into a container, ensuring flexibility, uniformity, and adaptability in environments. </span><span class="koboSpan" id="kobo.52.3">You’ll delve into </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.53.1">the reasons behind it and learn the techniques that </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.54.1">will reshape your approach to delivering applications. </span><span class="koboSpan" id="kobo.54.2">Together, we’ll embark on this journey to simplify your application </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">deployment process.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.56.1">Understanding containerization – your app in a box</span></h2>
<p><span class="koboSpan" id="kobo.57.1">Think of </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.58.1">containerization as a way to pack up your application. </span><span class="koboSpan" id="kobo.58.2">Picture getting ready for a trip and ensuring all your essentials fit into one suitcase. </span><span class="koboSpan" id="kobo.58.3">In the context of your application, think of the “suitcase” as a container that houses not your app but the necessary code, libraries, and configuration settings. </span><span class="koboSpan" id="kobo.58.4">This container is versatile – it functions seamlessly whether it’s on your computer, a friend’s device, or in </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the cloud.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Why is this beneficial for you? </span><span class="koboSpan" id="kobo.60.2">Imagine creating an app that you want to work for everyone. </span><span class="koboSpan" id="kobo.60.3">Without containers, it might run perfectly on your system, but can encounter issues elsewhere – that can be frustrating. </span><span class="koboSpan" id="kobo.60.4">With containerization, if it works well for you, it will work well for anyone else. </span><span class="koboSpan" id="kobo.60.5">It provides reliability and eliminates those irritating moments when someone says, “It doesn’t work </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">for me.”</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Containers act like </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.63.1">boxes that empower your app to travel effortlessly without any hassle. </span><span class="koboSpan" id="kobo.63.2">It’s like a trick that saves you time and headaches. </span><span class="koboSpan" id="kobo.63.3">By embracing this concept, you’re ensuring that your app is equipped to thrive regardless of where it needs to go or how much it needs </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">to expand.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">That’s the reason why knowing about containerization is crucial; it simplifies the developer’s life and enhances the flexibility of your app. </span><span class="koboSpan" id="kobo.65.2">Let’s now explore how to prepare your Spring Boot application for this </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">container journey.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.67.1">Reaping the benefits – lighter loads, quicker starts</span></h2>
<p><span class="koboSpan" id="kobo.68.1">Containers do more than just help your app move around easily. </span><span class="koboSpan" id="kobo.68.2">They are like the tech world’s backpacks. </span><span class="koboSpan" id="kobo.68.3">Instead of each app carrying its suitcase filled with everything it needs to run, containers share</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.69.1"> resources. </span><span class="koboSpan" id="kobo.69.2">This speeds up your apps’ launch time and saves space </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.70.1">and memory on your computer. </span><span class="koboSpan" id="kobo.70.2">The concept is similar to carpooling to work. </span><span class="koboSpan" id="kobo.70.3">When everyone drives together, you all reach the same destination faster and in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">eco-friendly manner.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Here’s why using containers is beneficial for you – when your app is in a container, it can start up instantly with a snap of your fingers. </span><span class="koboSpan" id="kobo.72.2">You won’t have to wait for it to get going. </span><span class="koboSpan" id="kobo.72.3">Additionally, since containers are lightweight, you can run apps on one machine without resource conflicts. </span><span class="koboSpan" id="kobo.72.4">Moreover, if your app becomes popular, creating containers to handle the traffic is simple – when activity slows down, stopping some containers </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">is effortless.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Using containers offers flexibility to the ability to attach cars to a train when there is high demand for rides and detach them when demand decreases. </span><span class="koboSpan" id="kobo.74.2">Opting for containers represents an efficient approach to managing your applications. </span><span class="koboSpan" id="kobo.74.3">It revolutionizes the way you create, test, and launch your apps, enhancing reliability and responsiveness. </span><span class="koboSpan" id="kobo.74.4">In the next section, we will explore how your Spring Boot application can take advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">these perks.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.76.1">Getting Spring Boot in the game – container-friendly from the start</span></h2>
<p><span class="koboSpan" id="kobo.77.1">Let’s prepare your Spring Boot application for the container environment. </span><span class="koboSpan" id="kobo.77.2">Spring Boot acts as a guide for your app, ensuring operation within containers. </span><span class="koboSpan" id="kobo.77.3">Right from the start, Spring Boot is tailored to work with containers. </span><span class="koboSpan" id="kobo.77.4">Why is this important? </span><span class="koboSpan" id="kobo.77.5">It’s akin to having a car all set and prepared for a road trip whenever you </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">need it.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Spring Boot </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.80.1">takes care of much of the lifting for you. </span><span class="koboSpan" id="kobo.80.2">It automatically adapts to your application requirements based on its deployment location, making it ideal for highly portable environments. </span><span class="koboSpan" id="kobo.80.3">With Spring Boot, you don’t need to micromanage every aspect – it intuitively grasps the container setup and adapts accordingly. </span><span class="koboSpan" id="kobo.80.4">It’s akin to having a companion who effortlessly knows what essentials to pack for </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">each journey.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Spring Boot also ensures that your application is ready to go – whether you’re running your application on your computer, a friend’s device, or in the cloud. </span><span class="koboSpan" id="kobo.82.2">This allows you to focus more on enhancing your application and less on dealing with the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">setup process.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">By ensuring that your Spring Boot application is container friendly, you’re not just following a trend; you’re opting for a path that reduces stress and enhances success. </span><span class="koboSpan" id="kobo.84.2">It’s all about simplifying your life as a developer and strengthening the resilience of your application. </span><span class="koboSpan" id="kobo.84.3">Now, let’s move on to transforming your Spring Boot application into </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">a container.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.86.1">Unleashing Spring Boot superpowers – portability, efficiency, and control</span></h2>
<p><span class="koboSpan" id="kobo.87.1">Let’s tap </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.88.1">into the capabilities that Spring Boot offers your application when it’s inside a container. </span><span class="koboSpan" id="kobo.88.2">These capabilities include portability, efficiency, and control. </span><span class="koboSpan" id="kobo.88.3">They are set to simplify your life as a developer. </span><span class="koboSpan" id="kobo.88.4">These capabilities are </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Portability</span></strong><span class="koboSpan" id="kobo.91.1">: This is akin </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.92.1">to having an adapter for your application. </span><span class="koboSpan" id="kobo.92.2">Wherever you plug it in, it just functions seamlessly. </span><span class="koboSpan" id="kobo.92.3">Whether you transfer your application from your computer to a testing environment or the cloud, it will operate consistently each time. </span><span class="koboSpan" id="kobo.92.4">This eliminates the issues that arise when an application works on one person’s device but </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">not another’s.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.94.1">Efficiency</span></strong><span class="koboSpan" id="kobo.95.1">: This entails achieving with less. </span><span class="koboSpan" id="kobo.95.2">Containers utilize resources by sharing them </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.96.1">where possible and minimizing wastage. </span><span class="koboSpan" id="kobo.96.2">Your application boots up quickly and operates smoothly, akin to a tuned machine. </span><span class="koboSpan" id="kobo.96.3">Consequently, your application can cater to many users simultaneously without requiring power or </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">numerous machines.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.98.1">Control</span></strong><span class="koboSpan" id="kobo.99.1">: This empowers </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.100.1">you to effortlessly oversee all aspects of your application. </span><span class="koboSpan" id="kobo.100.2">You can initiate it, halt it, scale it up during usage periods, or scale it down during quieter times. </span><span class="koboSpan" id="kobo.100.3">It’s similar to having a remote for your app, where you have buttons for every action you may need. </span><span class="koboSpan" id="kobo.100.4">Spring Boot makes it easy to access all these controls as it is designed in a </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">user-intuitive manner.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.102.1">When you package </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.103.1">your Spring Boot app in a container, you’re not just putting it in a box; you’re equipping it with tools that enhance its flexibility, strength, and intelligence. </span><span class="koboSpan" id="kobo.103.2">This prepares our application to meet the needs of users today and in the future. </span><span class="koboSpan" id="kobo.103.3">The best part? </span><span class="koboSpan" id="kobo.103.4">You’re setting it up in a way that allows you to focus on improving the app itself rather than worrying about how and where it operates. </span><span class="koboSpan" id="kobo.103.5">That’s the beauty of using containers, with Spring Boot – it empowers you to enhance your app’s capabilities while minimizing complexities. </span><span class="koboSpan" id="kobo.103.6">Let’s now move forward and implement these features as we containerize your Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Boot application.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.105.1">Spring Boot and Docker</span></h1>
<p><span class="koboSpan" id="kobo.106.1">After laying the foundation by understanding containerization and orchestration, as their overall advantages, it’s time to dive in and get hands on. </span><span class="koboSpan" id="kobo.106.2">This section will walk you through the </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.107.1">process of incorporating Docker into a sample Spring Boot application and making use of the features of Spring Boot 3.0. </span><span class="koboSpan" id="kobo.107.2">We’ll demonstrate how to convert your Spring Boot application into a set of containers that can be efficiently orchestrated </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">for scalability.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Let’s start this journey where we will put the concepts of containerization and orchestration into action with Spring Boot. </span><span class="koboSpan" id="kobo.109.2">Together, we’ll learn how to create Docker images that are not only functional but also tailored to enhance your workflow, paving the way for seamless integration with container </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">orchestration platforms.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.111.1">Crafting efficient Docker images with layered jars</span></h2>
<p><span class="koboSpan" id="kobo.112.1">Docker aims to simplify developers’ lives by emphasizing the importance of creating Docker images for results. </span><span class="koboSpan" id="kobo.112.2">The concept of jars, a feature of Spring Boot, has caught the attention </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.113.1">of developers. </span><span class="koboSpan" id="kobo.113.2">Picture baking a cake – instead of baking it as one unit, you bake individual layers separately. </span><span class="koboSpan" id="kobo.113.3">This method allows for the modification of layers without the need to reconstruct the entire cake. </span><span class="koboSpan" id="kobo.113.4">Similarly, layered jars in Docker enable you to segregate your application into layers that can be managed and updated independently </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">by Docker.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">This approach revolutionizes the development process by reducing build times and producing Docker images. </span><span class="koboSpan" id="kobo.115.2">By caching these layers, Docker only rebuilds the modified layers when changes are made to your application. </span><span class="koboSpan" id="kobo.115.3">For example, modifications to your application’s code do not necessitate rebuilding the components, such as the JVM layer that remains </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">largely unchanged.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Ready to get started? </span><span class="koboSpan" id="kobo.117.2">Here’s a step-by-step guide on setting up your Spring Boot project to take advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">layered jars:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.119.1">Create a new project</span></strong><span class="koboSpan" id="kobo.120.1">: Use Spring Initializr (</span><a href="https://start.spring.io/"><span class="koboSpan" id="kobo.121.1">https://start.spring.io/</span></a><span class="koboSpan" id="kobo.122.1">) to create a new Spring Boot project. </span><span class="koboSpan" id="kobo.122.2">Select </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Spring Boot version 3.2.1</span></strong><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">For dependencies, add </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Spring Web</span></strong><span class="koboSpan" id="kobo.126.1"> to create a simple web application. </span><span class="koboSpan" id="kobo.126.2">Please choose </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">Gradle</span></strong><span class="koboSpan" id="kobo.128.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">build tool.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Generate and download</span></strong><span class="koboSpan" id="kobo.131.1">: Once configured, click on </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Generate</span></strong><span class="koboSpan" id="kobo.133.1"> to download your </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">project skeleton.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">Create a controller class</span></strong><span class="koboSpan" id="kobo.136.1">: Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">`src/main/java/`</span></strong><span class="koboSpan" id="kobo.138.1"> in the appropriate package, create a new Java class </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">`HelloController`</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.142.1">Add a REST endpoint</span></strong><span class="koboSpan" id="kobo.143.1">: Implement a simple GET endpoint that returns </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">a greeting:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.145.1">
@RestController
public class HelloController {
    @GetMapping("/")
    public String hello() {
        return "Hello, Spring Boot 3!";
    }
}</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.146.1">Enable layering</span></strong><span class="koboSpan" id="kobo.147.1">: Begin by configuring your Spring Boot build plugin to recognize the layering feature. </span><span class="koboSpan" id="kobo.147.2">It’s a simple matter of including the right dependencies and configuration settings in your </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">build file.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.149.1">Use</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.150.1">`./gradlew build`</span></strong><strong class="bold"><span class="koboSpan" id="kobo.151.1"> for Gradle</span></strong><span class="koboSpan" id="kobo.152.1">: This will generate a layered jar in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">`</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">build/libs`</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1"> directory.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.156.1">Now, we have </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.157.1">a layered jar in our hands. </span><span class="koboSpan" id="kobo.157.2">Let’s see how we can check the layers inside </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">of it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
&gt; jar xf build/libs/demo-0.0.1-SNAPSHOT.jar BOOT-INF/layers.idx
&gt; cat BOOT-INF/layers.idx
- "dependencies":
  - "BOOT-INF/lib/"
- "spring-boot-loader":
  - "org/"
- "snapshot-dependencies":
- "application":
  - "BOOT-INF/classes/"
  - "BOOT-INF/classpath.idx"
  - "BOOT-INF/layers.idx"
  - "META-INF/"</span></pre> <p><span class="koboSpan" id="kobo.160.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">layers.idx</span></strong><span class="koboSpan" id="kobo.162.1"> file organizes the application into logical layers. </span><span class="koboSpan" id="kobo.162.2">Typical layers include </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">dependencies</span></strong><span class="koboSpan" id="kobo.165.1">: The external libraries your </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">application needs</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">spring-boot-loader</span></strong><span class="koboSpan" id="kobo.168.1">: The parts of Spring Boot that are responsible for launching </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">your application</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">snapshot-dependencies</span></strong><span class="koboSpan" id="kobo.171.1">: Any snapshot versions of dependencies, which are more likely to change than </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">regular dependencies</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">application</span></strong><span class="koboSpan" id="kobo.174.1">: Your application’s compiled classes </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">and resources</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.176.1">Each layer is </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.177.1">designed to optimize the build process for Docker. </span><span class="koboSpan" id="kobo.177.2">Layers less likely to change (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">dependencies</span></strong><span class="koboSpan" id="kobo.179.1">) are separated from more volatile layers (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">application</span></strong><span class="koboSpan" id="kobo.181.1">), allowing Docker to cache these layers independently. </span><span class="koboSpan" id="kobo.181.2">This reduces the time and bandwidth needed to rebuild and redeploy your application when only small changes </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">are made.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Having explored the efficiency of layered jars, next, we will look at how Spring Boot simplifies Docker image creation with Cloud Native Buildpacks. </span><span class="koboSpan" id="kobo.183.2">Prepare to see how even without deep Docker expertise, you can create and manage Docker images that are both robust and ready for </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">the cloud.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.185.1">Simplifying Dockerization with Cloud Native Buildpacks</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.186.1">Cloud Native Buildpacks</span></strong><span class="koboSpan" id="kobo.187.1"> mark an advancement in how we prepare applications for Docker – consider them as your assistant for Dockerizing. </span><span class="koboSpan" id="kobo.187.2">For creating a Dockerfile, where you </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.188.1">list out all the commands to build your Docker image, Buildpacks automate this process. </span><span class="koboSpan" id="kobo.188.2">They analyze your code figure out its requirements </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.189.1">and package it into a container image without you needing to write even a line of code in </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">a Dockerfile.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">This automation </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.192.1">is particularly beneficial for teams lacking expertise in Docker or the time to maintain Dockerfiles. </span><span class="koboSpan" id="kobo.192.2">It also promotes consistency and adherence to practices, ensuring that the images generated by Buildpacks meet standards, for security, efficiency, </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">and compatibility.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Here’s how you can harness the power of Cloud Native Buildpacks with </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">Spring Boot:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.196.1">In the terminal, navigate to the root folder of our Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">Boot application.</span></span></li>
<li><span class="koboSpan" id="kobo.198.1">Use the Spring Boot Gradle plugin, which comes with built-in support for Buildpacks. </span><span class="koboSpan" id="kobo.198.2">With a simple command, </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">./gradlew bootBuildImage --imageName=demoapp</span></strong><span class="koboSpan" id="kobo.200.1">, you trigger the Buildpack to spring into action. </span><span class="koboSpan" id="kobo.200.2">We also gave a name to our image – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">demoapp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.203.1">The Buildpack examines your application, recognizing it as a Spring Boot app. </span><span class="koboSpan" id="kobo.203.2">It then automatically selects a base image and layers your application code on top, along with </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">any dependencies.</span></span></li>
<li><span class="koboSpan" id="kobo.205.1">Next, the Buildpack optimizes your image for the cloud. </span><span class="koboSpan" id="kobo.205.2">This means trimming any fat to ensure your image is as lightweight and secure </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">as possible.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.207.1">Our Spring Boot application is now containerized and ready for deployment to any Docker environment, cloud or otherwise. </span><span class="koboSpan" id="kobo.207.2">You’ve got a robust, standardized Docker image with zero </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">Dockerfile drama.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.209.1">We can test </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.210.1">whether it is working as expected </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.211.1">with Docker. </span><span class="koboSpan" id="kobo.211.2">Please be sure Docker Desktop is up and running on your local machine. </span><span class="koboSpan" id="kobo.211.3">Later, we just need to run </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">this command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.213.1">docker run -p 8080:8080 demoapp:latest</span></strong></pre> <p><span class="koboSpan" id="kobo.214.1">This command runs our image on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">8080</span></strong><span class="koboSpan" id="kobo.216.1">. </span><span class="koboSpan" id="kobo.216.2">So, we can easily test the response, which should be </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">Hello, Spring Boot 3!</span></strong><span class="koboSpan" id="kobo.218.1">, by using this curl command: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">curl http://localhost:8080</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">With Docker images sorted, let’s turn our attention to ensuring our applications exit gracefully in a Docker environment. </span><span class="koboSpan" id="kobo.221.2">In the following section, we’ll dive into why a graceful shutdown is important and how Spring Boot’s enhanced support for this can safeguard your data and user experience during the inevitable shuffling of Docker containers in </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">production environments.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.223.1">Enhancing graceful shutdown capabilities</span></h2>
<p><span class="koboSpan" id="kobo.224.1">When it’s </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.225.1">time for your program to finish running, you’ll want it to exit smoothly, like how it started. </span><span class="koboSpan" id="kobo.225.2">This is what we call a shutdown – making sure that your containerized apps can properly handle termination signals, complete tasks, and not abruptly stop active processes. </span><span class="koboSpan" id="kobo.225.3">In Docker setups, where apps are frequently stopped and moved around due to scaling or updates, graceful shutdown isn’t a nicety; it’s crucial for preserving data integrity and providing a </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Spring Boot 3.0 </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.228.1">improves this process by ensuring that your apps can effectively respond to </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">Signal Terminate</span></strong><span class="koboSpan" id="kobo.230.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.231.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.232.1">) signals. </span><span class="koboSpan" id="kobo.232.2">The method is for instructing a process to stop. </span><span class="koboSpan" id="kobo.232.3">Let’s walk through how you can set up and verify that your </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.233.1">Spring Boot app gracefully </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">handles shutdowns:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.235.1">Configure graceful shutdown by adding the following </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">'application.properties'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=20s</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">20s</span></strong><span class="koboSpan" id="kobo.241.1"> represents the duration that the application waits before it </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">shuts down.</span></span></p></li> <li><span class="koboSpan" id="kobo.243.1">Let’s rebuild the image and run it </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">in Docker:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.245.1">
./gradlew bootBuildImage --imageName=demoapp
docker run –-name demoapp-container -p 8080:8080 demoapp:latest</span></pre></li> <li><span class="koboSpan" id="kobo.246.1">After starting your app, send a SIGTERM signal to your Docker container and observe the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">graceful shutdown.</span></span><pre class="source-code"><span class="koboSpan" id="kobo.248.1">
docker stop demoapp-container</span></pre></li> <li><span class="koboSpan" id="kobo.249.1">When you check out the logs of your Docker container, you will see </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">these logs:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
Commencing graceful shutdown. </span><span class="koboSpan" id="kobo.251.2">Waiting for active requests to complete
Graceful shutdown complete</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.252.1">As we conclude our exploration of Spring Boot’s containerization capabilities, let’s recap the points and explore how they can be implemented in your projects. </span><span class="koboSpan" id="kobo.252.2">You’ll find that whether you want to enhance build efficiency using jars streamline image creation with Buildpacks or ensure smooth shutdowns, Spring Boot 3.0 provides the tools to strengthen your </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.253.1">containerized applications for </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">cloud deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Now that we’ve discussed the way to end services gracefully, let’s delve into how Spring Boot 3.0 helps in managing application configurations within Docker and why it is important for containerized applications. </span><span class="koboSpan" id="kobo.255.2">We will also discover how Spring Boot applications thrive within the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">Kubernetes ecosystem.</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.257.1">Optimizing Spring Boot apps for Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.258.1">Picture a harbor where ships come and go non-stop. </span><span class="koboSpan" id="kobo.258.2">This harbor relies on a system to manage </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.259.1">the traffic smoothly to ensure each </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.260.1">ship is in the place at the right time. </span><span class="koboSpan" id="kobo.260.2">In the realm of containerized applications, Kubernetes plays the role of this master harbor system. </span><span class="koboSpan" id="kobo.260.3">While Docker handles packaging applications into containers, Kubernetes orchestrates which containers should run, scales them as needed, manages traffic flow, and ensures </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">their well-being.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">Kubernetes isn’t meant to replace Docker; rather, it complements Docker effectively. </span><span class="koboSpan" id="kobo.262.2">Docker excels at containerization and transforming applications into efficient units. </span><span class="koboSpan" id="kobo.262.3">On the other hand, Kubernetes takes these units and seamlessly integrates them within the intricate landscape of modern </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">cloud architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">By leveraging Kubernetes functionalities, developers can now oversee Spring Boot applications with an unprecedented level of efficiency and reliability. </span><span class="koboSpan" id="kobo.264.2">From deployments with no downtime to automated scaling capabilities, Kubernetes empowers your containerized applications to perform optimally under workloads </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">and scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Let’s dive in by exploring how Spring Boot’s integrated Kubernetes probes collaborate with Kubernetes health check mechanisms to enhance your application’s resilience </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">and uptime.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.268.1">Integrating Kubernetes probes for application health</span></h2>
<p><span class="koboSpan" id="kobo.269.1">In the dynamic realm of Kubernetes, it’s crucial to make sure your application is in shape and </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.270.1">prepared to handle requests. </span><span class="koboSpan" id="kobo.270.2">This is where readiness and liveness checks come in, serving as the protectors of your application’s health. </span><span class="koboSpan" id="kobo.270.3">Liveness checks inform Kubernetes about the status of your application – whether it is functioning or unresponsive, while readiness checks indicate when your app is set to receive traffic. </span><span class="koboSpan" id="kobo.270.4">These checks ensure that operational and ready-to-go instances of your application receive traffic and play a vital role in enhancing the robustness of </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">your deployments.</span></span></p>
<h3><span class="koboSpan" id="kobo.272.1">Understanding probes</span></h3>
<p><span class="koboSpan" id="kobo.273.1">Probes are </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.274.1">diagnostic tools used in Kubernetes. </span><span class="koboSpan" id="kobo.274.2">Kubernetes uses them to check the status of the </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">component periodically.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Let’s see what are </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">these probes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.278.1">Liveness probe</span></strong><span class="koboSpan" id="kobo.279.1">: This probe </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.280.1">checks whether your </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.281.1">application is alive. </span><span class="koboSpan" id="kobo.281.2">If it fails, Kubernetes restarts the container automatically, offering a </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">self-healing mechanism.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.283.1">Readiness probe</span></strong><span class="koboSpan" id="kobo.284.1">: This determines </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.285.1">whether your application is </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.286.1">ready to receive requests. </span><span class="koboSpan" id="kobo.286.2">A failing readiness probe means Kubernetes stops sending traffic to that pod until it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">ready again.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.288.1">Now, we will be activating probes in Spring Boot 3.0, which simplifies the integration of these probes, thanks to its </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">Actuator endpoints:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.290.1">Include Spring Boot Actuator</span></strong><span class="koboSpan" id="kobo.291.1">: Ensure the Spring Boot Actuator dependency is included in your project. </span><span class="koboSpan" id="kobo.291.2">It provides the necessary endpoints for </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">Kubernetes probes:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
implementation 'org.springframework.boot:spring-boot-starter-actuator'</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.294.1">Configure liveness and readiness probes</span></strong><span class="koboSpan" id="kobo.295.1">: Utilize the Actuator’s health groups to define what constitutes readiness and liveness in your application. </span><span class="koboSpan" id="kobo.295.2">In your </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">application.properties</span></strong><span class="koboSpan" id="kobo.297.1">, you can specify the criteria for </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">these probes:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.299.1">
management.endpoint.health.group.liveness.include=livenessState
   management.endpoint.health.group.readiness.include=readinessState</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.300.1">That’s all our application needs to be ready for Kubernetes. </span><span class="koboSpan" id="kobo.300.2">Let’s create our first Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">YAML file.</span></span></p>
<h3><span class="koboSpan" id="kobo.302.1">Creating Kubernetes YAML file</span></h3>
<p><span class="koboSpan" id="kobo.303.1">Our YAML file </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.304.1">includes two main sections. </span><span class="koboSpan" id="kobo.304.2">Each section defines a Kubernetes object. </span><span class="koboSpan" id="kobo.304.3">The following section is </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">Deployment resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-demo-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: spring-boot-demo-app
  template:
    metadata:
      labels:
        app: spring-boot-demo-app
    spec:
      containers:
        - name: spring-boot-demo-app
          image: demoapp:latest
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5</span></pre> <p><span class="koboSpan" id="kobo.307.1">Let’s break </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.308.1">down what we have introduced in this </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">Deployment resource:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">metadata.name: spring-boot-demo-app</span></strong><span class="koboSpan" id="kobo.311.1">: This is the unique name of the deployment within the Kubernetes cluster. </span><span class="koboSpan" id="kobo.311.2">It’s specific to the application being deployed, in this </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">case, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">spring-boot-demo-app</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">spec:template:metadata:labels:app: spring-boot-demo-app</span></strong><span class="koboSpan" id="kobo.316.1">: This label is crucial for defining which pods belong to this Deployment resource. </span><span class="koboSpan" id="kobo.316.2">It must match the selector defined in the Deployment resource and is used by </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Service</span></strong><span class="koboSpan" id="kobo.318.1"> to route traffic to </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the pods.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">spec:containers:name: spring-boot-demo-app</span></strong><span class="koboSpan" id="kobo.321.1">: The name of the container running in the pod. </span><span class="koboSpan" id="kobo.321.2">It’s more for identification and </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">logging purposes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">spec:containers:image: demoapp:latest</span></strong><span class="koboSpan" id="kobo.324.1">: This specifies the Docker image to use for the container, which is pivotal as it determines the version of the application to run. </span><span class="koboSpan" id="kobo.324.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">latest</span></strong><span class="koboSpan" id="kobo.326.1"> tag here can be replaced with a specific version tag to ensure consistent environments </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">through deployments.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">spec:containers:ports:containerPort: 8080</span></strong><span class="koboSpan" id="kobo.329.1">: This port number is essential because it must match the application’s configured port. </span><span class="koboSpan" id="kobo.329.2">For Spring Boot applications, the default is </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">8080</span></strong><span class="koboSpan" id="kobo.331.1">, but if your application uses a different port, it needs to be </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">reflected here.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">livenessProbe:</span></strong><span class="koboSpan" id="kobo.334.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">readinessProbe:</span></strong><span class="koboSpan" id="kobo.336.1"> are configured to check the application’s health and readiness at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">/actuator/health/liveness</span></strong><span class="koboSpan" id="kobo.338.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">/actuator/health/readiness</span></strong><span class="koboSpan" id="kobo.340.1"> endpoints, respectively. </span><span class="koboSpan" id="kobo.340.2">These paths are Spring Boot Actuator endpoints, which are specific to Spring Boot applications. </span><span class="koboSpan" id="kobo.340.3">Adjusting the probe configurations (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">initialDelaySeconds</span></strong><span class="koboSpan" id="kobo.342.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">periodSeconds</span></strong><span class="koboSpan" id="kobo.344.1">) may be necessary based on the startup time and behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">your application.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.346.1">Now, we will </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.347.1">add the load balancer part to our </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">YAML file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
---
apiVersion: v1
kind: Service
metadata:
  name: spring-boot-demo-app-service
spec:
  type: LoadBalancer
  ports:
    - port: 8080
      targetPort: 8080
  selector:
    app: spring-boot-demo-app</span></pre> <p><span class="koboSpan" id="kobo.350.1">In this part, we have defined the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">following parameters:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">metadata:name: spring-boot-demo-app-service</span></strong><span class="koboSpan" id="kobo.353.1">: This is the name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Service</span></strong><span class="koboSpan" id="kobo.355.1"> object, which is how you would refer to this service within the Kubernetes cluster. </span><span class="koboSpan" id="kobo.355.2">It should be descriptive of the service </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">it provides.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">spec:type: LoadBalancer</span></strong><span class="koboSpan" id="kobo.358.1">: This type makes </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Service</span></strong><span class="koboSpan" id="kobo.360.1"> accessible through an external IP provided by the cloud hosting the Kubernetes cluster. </span><span class="koboSpan" id="kobo.360.2">This detail is </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.361.1">crucial for applications that need to be accessible from outside the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">Kubernetes cluster.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">spec:ports:port: 8080</span></strong><span class="koboSpan" id="kobo.364.1">: This is the port on which </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">Service</span></strong><span class="koboSpan" id="kobo.366.1"> will listen, which must match </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">containerPort</span></strong><span class="koboSpan" id="kobo.368.1"> if you want external traffic to reach your application. </span><span class="koboSpan" id="kobo.368.2">It’s specifically tailored to the </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">application’s configuration.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">spec:selector:app: spring-boot-demo-app</span></strong><span class="koboSpan" id="kobo.371.1">: This selector must match the labels of the pods you want </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Service</span></strong><span class="koboSpan" id="kobo.373.1"> to route traffic to. </span><span class="koboSpan" id="kobo.373.2">It’s crucial for connecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">Service</span></strong><span class="koboSpan" id="kobo.375.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">appropriate pods.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.377.1">This file sets up a basic deployment of a Spring Boot application on Kubernetes, with a single replica, and exposes it externally via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.379.1"> service. </span><span class="koboSpan" id="kobo.379.2">It includes health checks to ensure traffic is only sent to </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">healthy instances.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Let’s now run our first Kubernetes cluster in </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">our local.</span></span></p>
<h3><span class="koboSpan" id="kobo.383.1">Running Kubernetes cluster</span></h3>
<p><span class="koboSpan" id="kobo.384.1">In this book, for everything related to Docker, we have used Docker Desktop. </span><span class="koboSpan" id="kobo.384.2">So, we need to </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.385.1">enable Kubernetes in our Docker Desktop app first. </span><span class="koboSpan" id="kobo.385.2">Please open </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">Preferences</span></strong><span class="koboSpan" id="kobo.387.1"> in Docker Desktop, navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.389.1">, check the enable box, and then finally click on the </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">Save and Restart</span></strong><span class="koboSpan" id="kobo.391.1"> button. </span><span class="koboSpan" id="kobo.391.2">That’s it! </span><span class="koboSpan" id="kobo.391.3">We have Kubernetes in our </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">local machines.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">In order to run our YAML file, we need to open a terminal and navigate to the folder where we saved our YAML file. </span><span class="koboSpan" id="kobo.393.2">Then, we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">following command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.395.1">kubectl apply -f spring-boot-app-deployment.yaml</span></strong></pre> <p><span class="koboSpan" id="kobo.396.1">After deploying your application, monitor the Kubernetes dashboard or use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">kubectl</span></strong><span class="koboSpan" id="kobo.398.1"> commands to observe the probes in action. </span><span class="koboSpan" id="kobo.398.2">This ensures they’re correctly configured and responding as expected. </span><span class="koboSpan" id="kobo.398.3">Also, you can make a GET request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">HelloController</span></strong><span class="koboSpan" id="kobo.400.1"> by the following </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">curl command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.402.1">Curl http://localhost:8080/</span></strong></pre> <p><span class="koboSpan" id="kobo.403.1">This is the response we </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">will get:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.405.1">Hello, Spring Boot 3!</span></strong></pre> <p><span class="koboSpan" id="kobo.406.1">This means our app is up and running and successfully communicated with readiness and liveness probs </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">with Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">With your </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.409.1">app’s health checks firmly in place, ensuring that Kubernetes knows exactly when your services are ready and able to perform, it’s time </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.410.1">to shift our focus. </span><span class="koboSpan" id="kobo.410.2">Next, we’ll dive into the realm of Kubernetes </span><strong class="bold"><span class="koboSpan" id="kobo.411.1">ConfigMaps</span></strong><span class="koboSpan" id="kobo.412.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">Secrets</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">This </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.415.1">move will show you how to adeptly handle application configuration and manage sensitive data, leveraging Kubernetes-native mechanisms to further enhance the operational efficiency and security of your Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">Boot applications.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.417.1">Managing configurations and Secrets with Kubernetes</span></h2>
<p><span class="koboSpan" id="kobo.418.1">In the world of Kubernetes, effective management of application configurations and sensitive </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.419.1">information is not just a best practice; it’s a </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.420.1">necessity for secure and scalable deployments. </span><span class="koboSpan" id="kobo.420.2">Kubernetes offers two powerful tools for </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">this purpose:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.422.1">ConfigMaps enable the separation of configuration artifacts from images </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">for portability</span></span></li>
<li><span class="koboSpan" id="kobo.424.1">Secrets securely store sensitive information such as passwords, OAuth tokens, and </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">SSH keys</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.426.1">ConfigMaps and</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.427.1"> Secrets can </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.428.1">revolutionize how you manage your application’s environment-specific configurations and sensitive data. </span><span class="koboSpan" id="kobo.428.2">Here’s how to leverage these Kubernetes-native tools in your Spring Boot application, using a new controller as an </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">illustrative example.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Imagine a simple Spring Boot controller that returns a message and an API key when specific endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">are accessed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.432.1">
@RestController
public class MessageController {
    @Value("${app.message:Hello from Spring Boot!}")
    private String message;
    @Value("${api.key:not very secure}")
    private String apiKey;
    @GetMapping("/message")
    public String getMessage() {
        return message;
    }
    @GetMapping("/apikey")
    public String getApiKey() {
        return apiKey;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.433.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">@Value</span></strong><span class="koboSpan" id="kobo.435.1"> annotations </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.436.1">pull configuration </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.437.1">values from the application’s environment, with default values provided for both the message and the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">API key.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Next, we’ll externalize the configuration using a ConfigMap and a Secret. </span><span class="koboSpan" id="kobo.439.2">The ConfigMap stores the custom message, and the Secret securely stores the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">API key.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">We will create a new YAML file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">app-configmap.yaml</span></strong><span class="koboSpan" id="kobo.443.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  app.message: 'Hello from ConfigMap!'</span></pre> <p><span class="koboSpan" id="kobo.446.1">As you can easily understand, this configuration will set a message for our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">app.message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Now, let’s create a secure key with </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">Kubernetes capability:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
kubectl create secret generic app-secret --from-literal=api.key=mysecretapikey</span></pre> <p><span class="koboSpan" id="kobo.452.1">Now, we need </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.453.1">to modify our application’s deployment </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.454.1">YAML file to inject the values from the ConfigMap and Secret into your Spring Boot </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">application’s environment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
containers:
  - name: spring-boot-demo-app
    image: demoapp:latest
    imagePullPolicy: IfNotPresent
    ports:
      - containerPort: 8080
    env:
      - name: APP_MESSAGE
        valueFrom:
          configMapKeyRef:
            name: app-config
            key: app.message
      - name: API_KEY
        valueFrom:
          secretKeyRef:
            name: app-secret
            key: api.key</span></pre> <p><span class="koboSpan" id="kobo.457.1">This configuration injects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">app.message</span></strong><span class="koboSpan" id="kobo.459.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.461.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">api.key</span></strong><span class="koboSpan" id="kobo.463.1"> from the Secret into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">APP_MESSAGE</span></strong><span class="koboSpan" id="kobo.465.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">API_KEY</span></strong><span class="koboSpan" id="kobo.467.1"> environment variables, respectively, which Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">Boot consumes.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">Now, we need to regenerate our image and restart the </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">Kubernetes cluster:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
./gradlew bootBuildImage --imageName=demoapp
kubectl rollout restart deployment/spring-boot-demo-app</span></pre> <p><span class="koboSpan" id="kobo.472.1">After applying </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.473.1">the updated deployment, your application </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.474.1">will now return the </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">Hello from ConfigMap!</span></strong><span class="koboSpan" id="kobo.476.1"> message when accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">/message</span></strong><span class="koboSpan" id="kobo.478.1"> endpoint, and the secure API key when accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">/apikey</span></strong><span class="koboSpan" id="kobo.480.1"> endpoint, demonstrating the successful externalization of configuration and </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">sensitive data.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Now that you have configured your application to keep its secrets safe and configurations dynamic, let’s explore the streamlined approach Spring Boot offers for profile-specific configurations in various Kubernetes environments. </span><span class="koboSpan" id="kobo.482.2">This next step will enhance your ability to manage application behavior dynamically based on the deployment environment, further tailoring your app’s functionality to meet different </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">operational requirements.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.484.1">Utilizing profile-specific configurations in Kubernetes</span></h2>
<p><span class="koboSpan" id="kobo.485.1">In the realm of application deployment, customizing your app to behave differently in settings, such as</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.486.1"> development, testing, and production, is not just helpful; it’s essential. </span><span class="koboSpan" id="kobo.486.2">Spring </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.487.1">Boot simplifies this process by offering profile configurations that let you set up configurations based on the profile. </span><span class="koboSpan" id="kobo.487.2">When used alongside Kubernetes, this functionality opens up a level of adaptability and versatility for </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">your deployments.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">With profile configurations in Spring Boot, you can organize your app properties into files specific to each environment. </span><span class="koboSpan" id="kobo.489.2">For example, you could have </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">application-prod.properties</span></strong><span class="koboSpan" id="kobo.491.1"> for production settings and </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">application-test.properties</span></strong><span class="koboSpan" id="kobo.493.1"> for test environment settings. </span><span class="koboSpan" id="kobo.493.2">This segregation allows you to manage environment configurations such as database URLs, external service endpoints, and feature toggles separately reducing the risk of configuration mix-ups </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">between environments.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">Let’s consider an example where your Spring Boot application needs to return a different message from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">/message</span></strong><span class="koboSpan" id="kobo.497.1"> endpoint based on whether it’s running in a test or </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">production environment:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.499.1">First off, let’s define our configurations for test and </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">prod environments:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">application-test.properties</span></strong><span class="koboSpan" id="kobo.502.1">: This is intended for the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">test environment:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.504.1">
app.message=Hello from the Test Environment!</span></pre></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">application-prod.properties</span></strong><span class="koboSpan" id="kobo.506.1">: This is intended for the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">production environment:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.508.1">app.message=Hello from the Production Environment!</span></pre></li></ul></li> <li><span class="koboSpan" id="kobo.509.1">To leverage these profiles within Kubernetes, you can set an environment variable </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.510.1">in your deployment </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.511.1">configuration that Spring Boot automatically recognizes to activate a </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">specific profile:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.513.1">
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: your-application
   spec:
     containers:
     - name: your-application
       image: your-application-image
       env:
         - name: SPRING_PROFILES_ACTIVE
           value: "prod" # Change this to "test" for test environment</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.514.1">By setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">SPRING_PROFILES_ACTIVE</span></strong><span class="koboSpan" id="kobo.516.1"> environment variable to either prod or test, you instruct Spring Boot to activate the corresponding profile and load its </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">associated properties.</span></span></p></li> <li><span class="koboSpan" id="kobo.518.1">Now, we need to regenerate our image and restart the </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">Kubernetes cluster:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.520.1">
./gradlew bootBuildImage --imageName=demoapp
kubectl rollout restart deployment/spring-boot-demo-app</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.521.1">Deploy </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.522.1">your application to </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.523.1">Kubernetes with the prod profile activated. </span><span class="koboSpan" id="kobo.523.2">Accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">/message</span></strong><span class="koboSpan" id="kobo.525.1"> endpoint should return </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">Hello from the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.527.1">Production Environment!</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.529.1">Change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">SPRING_PROFILES_ACTIVE</span></strong><span class="koboSpan" id="kobo.531.1"> value to test and redeploy, and the same endpoint should now return </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">Hello from the Test Environment!</span></strong><span class="koboSpan" id="kobo.533.1">, demonstrating the profile-specific behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">in action.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.535.1">After exploring the profile-based configurations, let’s take a moment to reflect on the journey we’ve been on and how these features aligned with Kubernetes can benefit you and your Spring Boot applications. </span><span class="koboSpan" id="kobo.535.2">This method not only simplifies the handling of environment settings but also boosts your application’s adaptability and reliability across different </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">deployment scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">In this section, we’ve discussed how the innovative features of Spring Boot 3.0 can seamlessly merge with Kubernetes to improve the deployment, configuration, and management of applications. </span><span class="koboSpan" id="kobo.537.2">We looked into utilizing Kubernetes probes for application health monitoring, managing configurations and secrets to protect data, and adapting to various environments effortlessly with profile-specific settings. </span><span class="koboSpan" id="kobo.537.3">These capabilities not only streamline deployment but also strengthen the resilience and flexibility of applications in the Kubernetes environment. </span><span class="koboSpan" id="kobo.537.4">With its native support for Kubernetes, Spring Boot 3.0 empowers developers to make use of container orchestration to ensure that applications can be deployed at scale while remaining maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">and secure.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">Now that your Spring Boot applications are primed for performance in Kubernetes, our upcoming section will focus on monitoring these applications. </span><span class="koboSpan" id="kobo.539.2">The integration is designed to be user friendly, offering assistance for keeping track of and analyzing data in Kubernetes settings. </span><span class="koboSpan" id="kobo.539.3">This ensures that you have the information to enhance performance </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">and dependability.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.541.1">Spring Boot Actuator with Prometheus and Grafana</span></h1>
<p><span class="koboSpan" id="kobo.542.1">In the realm of Kubernetes, where applications are dynamically handled across a group of containers, the significance of monitoring and metrics cannot be emphasized enough. </span><span class="koboSpan" id="kobo.542.2">These insights </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.543.1">act as the heartbeat for your applications, signaling their health, performance, and efficiency. </span><span class="koboSpan" id="kobo.543.2">Without them, you’re navigating </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.544.1">blindly through a maze of complexity, unable to detect or resolve issues that could impact your application’s reliability or </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.545.1">user experience. </span><span class="koboSpan" id="kobo.545.2">Monitoring and metrics </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.546.1">empower developers and operations teams with the visibility to ensure that applications are not just surviving but thriving in their </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">Kubernetes environment.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">Introducing </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">Spring Boot Actuator</span></strong><span class="koboSpan" id="kobo.550.1">, a tool in every developer’s arsenal for revealing a wealth of </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.551.1">details about your application. </span><span class="koboSpan" id="kobo.551.2">Actuator endpoints provide a peek into the workings of your application by offering real-time metrics, health checks, and more. </span><span class="koboSpan" id="kobo.551.3">These insights are priceless for maintaining an application state, identifying problems before they escalate, and optimizing performance to meet requirements. </span><span class="koboSpan" id="kobo.551.4">With Spring Boot Actuator at your disposal, you acquire an understanding of how your application behaves and its current status – for effective monitoring within </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">Kubernetes setups.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">Let’s explore how Spring Boot Actuator furnishes the required endpoints for Prometheus to gather data, paving the way for monitoring capabilities. </span><span class="koboSpan" id="kobo.553.2">This groundwork will help us unlock the capabilities of Prometheus and Grafana and develop a monitoring system that brings clarity to managing applications on </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">a scale.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.555.1">Integrating Prometheus for metrics collection</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.556.1">Prometheus</span></strong><span class="koboSpan" id="kobo.557.1"> plays a role </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.558.1">in monitoring within the Kubernetes ecosystem, serving </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.559.1">as a tool for keeping tabs on the well-being and efficiency</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.560.1"> of applications and infrastructure. </span><span class="koboSpan" id="kobo.560.2">Its capacity to gather and consolidate metrics is invaluable, particularly when combined with the Actuator endpoints of Spring Boot. </span><span class="koboSpan" id="kobo.560.3">These endpoints reveal information that Prometheus can gather to present a thorough overview of an application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">operational condition.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">To integrate Prometheus with a Spring Boot application, you need to configure Prometheus </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.563.1">to recognize and scrape the Actuator metrics endpoints. </span><span class="koboSpan" id="kobo.563.2">Here’s a practical guide to setting this up, utilizing Kubernetes ConfigMaps </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">and deployments:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.565.1">Firstly, we need to update our Spring Boot application. </span><span class="koboSpan" id="kobo.565.2">We will add a new library to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">gradle.build</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.567.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.568.1">
implementation 'io.micrometer:micrometer-registry-prometheus'</span></pre></li> <li><span class="koboSpan" id="kobo.569.1">Then, we need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">prometheus</span></strong><span class="koboSpan" id="kobo.571.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">web.exposure</span></strong><span class="koboSpan" id="kobo.573.1"> list to enable the Prometheus Actuator endpoint in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">application.properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.576.1">
management.endpoints.web.exposure.include=health,info,prometheus</span></pre></li> <li><span class="koboSpan" id="kobo.577.1">Start by defining a </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.579.1"> resource that contains your Prometheus configuration. </span><span class="koboSpan" id="kobo.579.2">This includes specifying the scrape interval and the targets from which Prometheus should collect metrics. </span><span class="koboSpan" id="kobo.579.3">Here’s how </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">prometheus-config.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1"> looks:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
   apiVersion: v1
   kind: ConfigMap
   metadata:
     name: prometheus-config
   data:
     prometheus.yml: |
       global:
         scrape_interval: 15s
       scrape_configs:
         - job_name: 'spring-boot'
           metrics_path: '/actuator/prometheus'
           static_configs:
             - targets: ['spring-boot-demo-app-service:8080']</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.583.1">This configuration instructs Prometheus to scrape metrics from your Spring Boot application’s Actuator Prometheus endpoint every </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">15 seconds.</span></span></p></li> <li><span class="koboSpan" id="kobo.585.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.587.1"> in place, deploy the Prometheus server using </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">prometheus-deployment.yaml</span></strong><span class="koboSpan" id="kobo.589.1">. </span><span class="koboSpan" id="kobo.589.2">This deployment specifies the Prometheus </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.590.1">server image, ports, and volume mounts, to use the</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.591.1"> previously created </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">ConfigMap</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.593.1">for configuration.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.594.1">First, we need to define the deployment part of this Kubernetes pod </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: prometheus-deployment
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: prometheus-server
     template:
       metadata:
         labels:
           app: prometheus-server
       spec:
         containers:
           - name: prometheus-server
             image: prom/prometheus:v2.20.1
             ports:
               - containerPort: 9090
             volumeMounts:
               - name: prometheus-config-volume
                 mountPath: /etc/prometheus/prometheus.yml
                 subPath: prometheus.yml
         volumes:
           - name: prometheus-config-volume
             configMap:
               name: prometheus-config</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.597.1">Now, we </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.598.1">can</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.599.1"> continue with the load balancer part of this pod </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.601.1">   apiVersion: v1
   kind: Service
   metadata:
     name: prometheus-service
   spec:
     type: LoadBalancer
     ports:
       - port: 9090
         targetPort: 9090
         protocol: TCP
     selector:
       app: prometheus-server</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.602.1">With this YAML file, we have defined a Kubernetes pod that can run Prometheus image in it, and serve it in </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">9090</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.606.1">Apply the </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.607.1">configuration to your Kubernetes cluster with the </span><a id="_idIndexMarker559"/><span class="No-Break"><span class="koboSpan" id="kobo.608.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.609.1">kubectl apply -f prometheus-config.yaml</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.610.1">kubectl apply -f prometheus-deployment.yaml</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.611.1">These commands create the necessary ConfigMap and deploy Prometheus within your cluster, setting it up to automatically scrape metrics from your Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">Boot application.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.613.1">Having Prometheus collect metrics is just the first step toward gaining actionable insights into your application’s performance. </span><span class="koboSpan" id="kobo.613.2">The real magic happens when we visualize this data, making it accessible and understandable. </span><span class="koboSpan" id="kobo.613.3">Next, we’ll explore how Grafana can be used to create compelling visualizations of the metrics collected by Prometheus, transforming raw data into valuable insights that drive decision making </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">and optimization.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.615.1">Visualizing metrics with Grafana</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.616.1">Grafana</span></strong><span class="koboSpan" id="kobo.617.1"> acts like </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.618.1">a beacon guiding us through the </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.619.1">ocean of metrics generated by today’s applications. </span><span class="koboSpan" id="kobo.619.2">It’s more than </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.620.1">a tool. </span><span class="koboSpan" id="kobo.620.2">It’s a platform that turns metrics data into valuable insights with its versatile dashboards. </span><span class="koboSpan" id="kobo.620.3">Grafana supports data sources, including Prometheus, and excels in creating queries, setting up alerts, and presenting data in diverse formats. </span><span class="koboSpan" id="kobo.620.4">Whether you’re tracking system health, user behavior, or app performance, Grafana offers the clarity and instant information needed for </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">making decisions.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">To leverage Grafana for monitoring your Spring Boot application metrics, you’ll start by deploying Grafana in your </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">Kubernetes cluster:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.624.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">grafana-deployment.yaml</span></strong><span class="koboSpan" id="kobo.626.1"> file that defines the Grafana deployment </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.627.1">and service in Kubernetes. </span><span class="koboSpan" id="kobo.627.2">This </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.628.1">deployment will run Grafana and expose it through </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.630.1">, making the Grafana </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">UI accessible:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: grafana-deployment
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: grafana
     template:
       metadata:
         labels:
           app: grafana
       spec:
         containers:
           - name: grafana
             image: grafana/grafana:7.2.0
             ports:
               - containerPort: 3000
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: grafana-service
   spec:
     type: LoadBalancer
     ports:
       - port: 3000
         targetPort: 3000
         protocol: TCP
     selector:
       app: grafana</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.633.1">This </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.634.1">configuration will help us to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">grafana</span></strong><span class="koboSpan" id="kobo.636.1"> instance and make it accessible over </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">3000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.640.1">Apply this </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.641.1">configuration with the </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.643.1">kubectl apply -f grafana-deployment.yaml.</span></strong></pre></li> <li><span class="koboSpan" id="kobo.644.1">Once Grafana is up and running, access the Grafana UI through the service’s external IP and log in (the default credentials are </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">usually </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.650.1">Navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">Configuration</span></strong><span class="koboSpan" id="kobo.652.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">Data Sources</span></strong><span class="koboSpan" id="kobo.654.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">Add data source</span></strong><span class="koboSpan" id="kobo.656.1">, select </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">Prometheus</span></strong><span class="koboSpan" id="kobo.658.1"> as the type, and configure it with the URL of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">http://prometheus-service:9090</span></strong><span class="koboSpan" id="kobo.660.1"> Prometheus service since Prometheus is deployed within the same Kubernetes cluster. </span><span class="koboSpan" id="kobo.660.2">Save and test the connection to ensure Grafana can communicate </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">with Prometheus.</span></span></li>
<li><span class="koboSpan" id="kobo.662.1">With Prometheus configured as a data source, you can now create dashboards in Grafana </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.663.1">to visualize your Spring Boot application metrics. </span><span class="koboSpan" id="kobo.663.2">Start by clicking </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">+</span></strong><span class="koboSpan" id="kobo.665.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">Dashboard</span></strong><span class="koboSpan" id="kobo.667.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.668.1">Import</span></strong><span class="koboSpan" id="kobo.669.1">. </span><span class="koboSpan" id="kobo.669.2">Then, type the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">12900</span></strong><span class="koboSpan" id="kobo.671.1"> ID for </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">SpringBoot APM Dashboard</span></strong><span class="koboSpan" id="kobo.673.1"> and select the data source you created </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.674.1">for Prometheus. </span><span class="koboSpan" id="kobo.674.2">That’s it! </span><span class="koboSpan" id="kobo.674.3">You have a wide range dashboard to monitor </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">your application.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.676.1"><img alt="Figure 7.1: Sample visualization that demonstrates how the dashboard will appear" src="image/B18400_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.677.1">Figure 7.1: Sample visualization that demonstrates how the dashboard will appear</span></p>
<p><span class="koboSpan" id="kobo.678.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.679.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.680.1">.1</span></em><span class="koboSpan" id="kobo.681.1">, the Grafana dashboard showcases the performance metrics of a Spring Boot application visually. </span><strong class="bold"><span class="koboSpan" id="kobo.682.1">SpringBoot APM Dashboard</span></strong><span class="koboSpan" id="kobo.683.1"> is designed with panels that are easy to understand, displaying information at a glance. </span><span class="koboSpan" id="kobo.683.2">At the top, you can view statistics, such as uptime and memory usage gauges, which offer a snapshot of system health. </span><span class="koboSpan" id="kobo.683.3">Below are graphs and charts that illustrate CPU usage and JVM memory statistics, providing insights into the application’s performance. </span><span class="koboSpan" id="kobo.683.4">The dashboard utilizes gauges, bar charts, and line graphs to present data in a user-friendly manner, enabling users to monitor and analyze the application’s behavior over time without </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">complexity overload.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">Having discussed collection and visualization techniques, let’s explore scenarios where these insights can enhance your application’s performance and reliability. </span><span class="koboSpan" id="kobo.685.2">By leveraging Grafana dashboards, we can shift from a reactive approach to a proactive approach in managing our Spring Boot apps to ensure optimal performance within </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">Kubernetes environments.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">During our exploration of application monitoring, we have emphasized the need to closely monitor our applications, especially when they are operating within the environment of Kubernetes. </span><span class="koboSpan" id="kobo.687.2">The Spring Boot Actuator has emerged as a tool that provides us </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.688.1">with a way to examine the signs of our applications. </span><span class="koboSpan" id="kobo.688.2">When combined with Prometheus, this duo acts as an observer collecting </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.689.1">metrics that offer a view of how our applications </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">are functioning.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">Integrating Grafana completes our monitoring trio by transforming the data gathered by Prometheus into stories that illustrate the performance and health of our applications. </span><span class="koboSpan" id="kobo.691.2">Through user dashboards, we not only have the ability to observe but also to interact with our metrics in depth, delving into patterns that inform our </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">proactive actions.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">As we consider the tools available to us, we realize that we are not just equipped for monitoring; we are empowered to predict, adjust, and ensure that our Kubernetes deployments operate optimally. </span><span class="koboSpan" id="kobo.693.2">The concrete advantages of this integrated monitoring strategy – such as improved visibility, quicker response times, and a deeper insight into application behavior – are assets in our efforts to deliver resilient and </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">reliable applications.</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.695.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.696.1">As we wrap up this chapter, on the Spring Boot 3.0 features for containerization and orchestration, we can say that it has been quite a journey of learning and honing skills. </span><span class="koboSpan" id="kobo.696.2">This chapter not only highlighted the role of containerization and orchestration in software development but also equipped you with the necessary tools and knowledge to effectively utilize </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">these technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">Let’s recap the valuable insights and skills </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">you’ve acquired:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.700.1">Understanding the essentials of containerization</span></strong><span class="koboSpan" id="kobo.701.1">: We began by delving into the concept of containerization and learned how to bundle our Spring Boot applications into containers for portability </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">and efficiency</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.703.1">Mastering Docker with Spring Boot</span></strong><span class="koboSpan" id="kobo.704.1">: We have discussed how to create and manage Docker images for our Spring Boot applications, making them ready for any environment while emphasizing the ease of deployment and lightweight nature </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">of containers</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.706.1">Orchestrating containers with Kubernetes</span></strong><span class="koboSpan" id="kobo.707.1">: We have learned how to deploy and manage our Dockerized Spring Boot applications using Kubernetes, highlighting the platform’s ability to scale and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">application health</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.709.1">Monitoring with Prometheus and Grafana</span></strong><span class="koboSpan" id="kobo.710.1">: Finally, we explored how to set up Prometheus for metrics collection and Grafana for visualization, ensuring you can monitor your applications’ performance and swiftly respond to </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">any issues</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.712.1">These abilities and expertise are extremely valuable in today’s tech landscape, allowing you to create applications that are not only robust and adaptable but also easy to maintain and efficient across different platforms. </span><span class="koboSpan" id="kobo.712.2">Having a grasp of containerization and orchestration principles lays the groundwork for developing cutting-edge </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">cloud-native applications.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">As we look forward to the next chapter, we’ll delve into the integration of Kafka with Spring Boot to build responsive, scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">event-driven systems.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">Transitioning from the realm of containerization and orchestration to event-driven design opens up opportunities for you to enhance your skill set, further tackling the challenges and advantages of software development. </span><span class="koboSpan" id="kobo.716.2">The next chapter is anticipated to be another stride in your journey toward mastering Spring Boot and </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">its ecosystem.</span></span></p>
</div>
</body></html>