- en: Connecting to SQL Databases Using ORM Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Vaadin Framework** is a *web frameworkâ€”a* library, if you wish, that helps
    with *web development*. You, as a developer, have the opportunity to integrate
    it with any other Java technology, and in particular, with any persistence technology.
    Since the most popular technology for persisting data is SQL, this chapter is
    dedicated to exploring several alternatives to connecting to SQL databases from
    Vaadin applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by studying the concept of o*bject-relational mapping*, a technique
    that allows developers to use an object-oriented programming language to consume
    and manipulate data in an otherwise incompatible system. We''ll then move on to
    explore three of the most popular Java frameworks used to connect to SQL databases:
    *JPA*, *MyBatis*, and *jOOQ*. These technologies are widely used in the industry,
    and it''s important that you understand at least the philosophy and fundamentals
    of each one in order to select the best options for your projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the sections in this chapter, we will develop very simple web UIs
    that list data from a database (using the `Grid` class), and present a simple
    form to add data to it. The purpose of the examples is to show you the very fundamentals
    of data binding with Vaadin. The next chapter will focus on more advanced data
    binding to develop sophisticated **CRUD** (**Create, Read, Update, and Delete**)
    user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-relational mapping** (**ORM**) frameworks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Persistence API** (**JPA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MyBatis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Object Oriented Querying** (**jOOQ**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/p1CGkr](https://goo.gl/p1CGkr)'
  prefs: []
  type: TYPE_NORMAL
- en: Using object-relational mapping frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a relational database, data is represented as *tables*. In a Java program,
    data is represented as *objects*. For example, if you have data related to customers,
    you can store this data in a `customers` table. Similarly, you can store this
    data in objects which are instances of the `Customer` class. *Object-relational
    mapping* frameworks allow you to convert the data between these two systems.
  prefs: []
  type: TYPE_NORMAL
- en: We already learned how to fetch data via JDBC and the `ResultSet` interface
    in the previous chapter. You could take an instance of this interface, iterate
    over the rows, and manually set the fields of a Java class such as `Customer`.
    When you do so, you are doing the job of an ORM framework. Why reinvent the wheel?
    The Java ecosystem offers several options to fix the *object-relational impedance
    mismatch*. In the following sections, we'll examine three of the most popular
    alternatives to solve this impedance mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: The Object Oriented paradigm is based on software engineering principles, while
    the Relational paradigm is based on mathematical principles. The *object-relational
    impedance mismatch* refers to the incompatibility between these two paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: The examples developed in the following sections use the H2 database instance
    we initialized during the introduction to JDBC in the previous chapter. Make sure
    that the H2 server is running and that the `messages` table exists (see the `packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization`
    class for details). You can use any other database if you want. If so, make sure
    your database server is running, create the `messages` table, and configure your
    application to point to your new database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to SQL databases using JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you need to know about the JPA is that it is a specification,
    not an implementation. There are several implementations, *Hibernate* and *EclipseLink*
    arguably being the most popular ones. In this book, we'll use Hibernate. The other
    things you need to learn about JPA are better learned by coding! Let's see how
    to create a simple Vaadin application that shows a `Grid` with the messages in
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you think is the first thing you need to do to start using JPA, or
    more specifically, Hibernate? It''s, of course, adding the dependencies. Create
    a Vaadin project and add the following dependencies to your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find all the code developed in this section in the `Data-centric-Applications-with-Vaadin-8/chapter-06/jpa-example`
    Maven project.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a persistence unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, JPA is ready in the classpath. What could be the next logical step? It
    makes sense to define a connection to the database next. The simplest way of doing
    this is by creating a `persistence.xml` file. JPA will automatically read this
    file in the `META-INF` directory in your classpath. In a Maven project, the location
    is `resources/META-INF/persistence.xml`. Inside this file, you can define one
    or more *persistence units* (database connections) and its connection properties.
    The following is an example of a minimal `persistence.xml` file you can use to
    connect to the H2 database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since you can define multiple persistence units (when your application needs
    to connect to multiple databases, for example), each persistence unit must have
    a name that identifies it. We have used `jpa-example-pu` for ours. Notice how
    we used the same connection properties (URL, user, password) we used previously
    with plain JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EntityManagerFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have *defined* a connection through a persistence unit, but the application
    is not actually *using* it yet. The way applications make use of JPA is through
    the `EntityManagerFactory`. You can think of the `EntityManagerFactory` as the
    *entry point to JPA*. An `EntityManagerFactory` allows you to interact with a
    specific persistence unit. It's almost, but not precisely, like the connection
    pool, if you like.
  prefs: []
  type: TYPE_NORMAL
- en: JPA implementations, like Hibernate or EclipseLink, offer built-in connection
    pooling mechanisms which are handled internally. You can usually adjust the pool
    configuration by using additional properties in the persistence unit definition.
    Consult the documentation of the JPA implementation you use for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, there''s only one persistence unit, `jpa-example-pu`, so it makes
    sense to have only one `EntityManagerFactory` instance per instance of the application.
    As with plain JDBC, we can use `ServletContextListener` to create the `EntityManagerFactory`,
    but once again, let''s delegate this to a different class to encapsulate JPA-related
    stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined the `init` and `close` methods to initialize and close the
    `EntityManagerFactory`, respectively. These methods can be used in a `ServletContextListener`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JPAService` method also exposes the `EntityManagerFactory` instance though
    the `getFactory` method. This is where things start to get more functional. With
    JPA, you use an `EntityManagerFactory` to create `EntityManager` instances. Think
    of an `EntityManager` as a *working unit*, a concrete interaction you need to
    perform with the database, for example, saving data or reading it. Some class
    could use the `JPAService.getFactory` method to, for example, get all the messages
    from the database. Omitting the code that actually queries the database and exception
    handling, the following is the *general infrastructure* code to interact with
    the database with JPA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code gets the `EntityManagerFactory` to create a new `EntityManager`. With
    it, a new database transaction can be started. After this, you can put the code
    that actually runs queries against the database, but before we unveil the `...
    run queries ...` code, we need to implement an important class we are missing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Entity classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JPA is an ORM framework. It *maps* SQL tables to Java objects. We already have
    the SQL table, `messages`, but what about the Java counterpart? We need to define
    a `Message` class. If you had a look at the code for the JDBC section, you probably
    saw the SQL code to create the messages table. If not, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We want that table to be represented on the Java side as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is going to be what JPA calls an Entity class, a **POJO** class
    (**Plain Old Java Object**) that is annotated to match an SQL table. You can use
    annotations to *tell* JPA how to *map* the objects to the tables. The code speaks
    by itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `@Entity` annotation to mark the class as an Entity. `@Table`
    tells JPA which SQL table to map to. `@Id` marks the property that corresponds
    to the primary key in the SQL table. How about the `auto_increment` definition
    for the `id` column in the messages table? We don''t want to worry about *counting*
    IDs to keep track of which value to use next, right? We can tell JPA that this
    column is generated by the database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your database, you may want to use a different strategy. For example,
    with PostgreSQL, you would most likely use `GenerationType.SEQUENCE` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `id` column in the messages table defines the *identity* of a row. It has
    to be the same as its Java counterpart. We can do this by overriding the `equals`
    method, and because of the `Object.hashCode` method contract, we also need to
    override the `hashCode` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the JavaDocs for the `Object.equals` method: "...it is generally
    necessary to override the `hashCode` method whenever this method is overridden,
    so as to maintain the general contract for the `hashCode` method, which states
    that equal objects must have equal hash codes". Most IDEs include a feature to
    generate this code for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Executing queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The connection properties are ready, the `EntityManagerFactory` is ready, and
    the Entity class is ready. Time to unveil the `... run queries ...` part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At first, you might think `select m from Message m` is SQL code. But it's not!
    First of all, there's no `Messages` table in the database (it's `messages`). Second
    of all, this query is a **Java Persistence Query Language** (**JPQL**) query.
  prefs: []
  type: TYPE_NORMAL
- en: JPQL is a platform-independent language similar to SQL. JPA converts JPQL queries
    to corresponding SQL queries that can be sent to the database. There's not enough
    space in this chapter to cover all the features of JPQL. There are plenty of resources
    online about it if you want to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code looks exactly like something you would encapsulate in a repository
    class. Let''s do so and implement a `MessageRepository` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot of boilerplate code. Repository classes like to have many methods,
    and most of them will need the same kind of infrastructure code to run a single
    query. Fortunately, we can use some Java constructs to encapsulate the logic for
    creating an `EntityManager`, opening and closing a transaction, and closing the
    `EntityManager`. The `JPAService` class looks like the perfect candidate for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `runInTransaction` method is a generic method that uses a Java `Function`
    which delegates the actual query logic to clients. Thanks to Java lambda expressions,
    we can clean up the code in the `MessagesService` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add a method to save new messages. With JPA, this is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `EntityManager.persist` method directly accepts an instance of
    the `Message` Entity class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the configuration and code examples in this chapter are valid in the
    context of web applications that use the Servlet specification only. When using
    the full Jakarta EE (previously Java EE) specification or Spring Framework, the
    configuration and code have subtle variations and practices. For example, you
    should use JNDI discoverable data sources configured in the server instead of
    specifying usernames and passwords for database connections with Jakarta EE. Also,
    transaction boundaries can be automatically managed with Jakarta EE and Spring
    Framework, which means that you don't need to implement and use the `runInTransaction`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Vaadin UI to list and save Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How can we use this from a Vaadin UI? Not a mystery at all, right? Just use
    Vaadin components and call the `MessageRepository` class when needed. Let''s see
    it in action! Start by implementing a basic UI that shows a `Grid`, a `TextField`,
    and a `Button`, something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd012df3-2e97-4e2e-b752-7107257bd394.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Feel free to implement a different layout for it. The following is the implementation
    corresponding to the previous screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous implementation shows a good practice: separating the code that
    builds up the UI from the code that adds behavior to it. The behavior, in this
    case, means adding a `ClickListener` that saves the message in the `TextField`
    and showing messages from the database in the grid. The following completes the
    implementation of the behavior for the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are directly using the `MessageRepository` class to invoke persistence-related
    logic. Notice how the *data binding* is done in the `saveCurrentMessage` method.
    This binding goes in only one direction: from the UI to the Entity. This is the
    most basic form of data binding you can use with Vaadin. In the case of the `Grid`,
    the data binding goes in the other direction: from the Entities to the UI. We''ll
    see more advanced data binding techniques in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: When should you use JPA? In general, JPA is good for RDBMS portability. JPA
    is widely used in the industry and there are many tools and resources available
    for it. JPA is an official Java specification with several vendors offering implementations
    (such as Hibernate and EclipseLink). JPA is not the only official Java specification
    for persistence. **Java Data Objects** (**JDO**) is another Java specification
    you may want to, at least, consider.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to SQL databases using MyBatis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MyBatis is a persistence framework that maps SQL to Java objects. The MyBatis
    learning curve is flatter than JPA's and leverages on SQL, which makes it a good
    match if you have good knowledge about SQL or have many complex SQL queries you
    want to reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you first need to add the dependency. Here is how to do it with Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can find the full implementation of the example developed in this section
    in the `Data-centric-Applications-with-Vaadin-8/chapter-06/mybatis-example` Maven
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a database connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With MyBatis, you can define a database connection using a Java API or a configuration
    XML file. The easiest way is to put an XML file in the classpath (the `resources`
    directory, when using Maven). The following is an example of such a configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can use any name for this file. The example for this section uses `mybatis-config.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we used the same connection properties we used for JDBC and
    JPA, but we added a `driver` property. Its value should correspond to the name
    of JDBC driver which you are going to use for the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use this file? Once again, we can use a `ServletContextListener`
    to initialize MyBatis. Moreover, the `ServletContextListener` can delegate to
    a service class like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `SqlSessionFactory` class is the *entry point* to MyBatis. The previous
    class provides the init method that can be called from a `ServletContextListener`,
    which creates one `SqlSessionFactory` per instance of the application, and exposes
    it through a getter. This is a pattern similar to the one we previously used with
    JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing mapper classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MyBatis uses *mapper classes* (actually, interfaces) to define the methods
    that will map SQL queries to Java objects. These are almost the equivalent of
    the repository classes we have developed so far. However, it makes sense to use
    MyBatis terminology when using it. Also, as we''ll see later, we need to add transaction
    or session management code around the calls to the mapper class, but let''s start
    with the mapper class. If you were observant, the `mybatis-config.xml` file defined
    a mapper class in the `mappers` section. Go back and have a look at it. The following
    is the definition of such a mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `MessageMapper` is an interface. You don''t have to implement
    this interface; MyBatis will provide the implementation for you at runtime. We
    have defined two methods: one to return a `List` of Messages, and another to save
    a `Message`. Notice the `@Select` and `@Insert` annotations. These are used to
    define the SQL that will run when these methods are called. Also, notice how you
    can pass values from the arguments to the SQL query. The save method accepts a
    `Message` instance. In the SQL query defined by the `@Insert` annotation, we use
    `#{content}` to *pass* the value of the `Message.content` property to the query.
    You could have passed a `String` with the value too. In that case, you can use
    the name of the parameter directly. However, we want MyBatis to set the value
    of the `id` property after the row has been inserted. This value is autogenerated
    in the database, so we have to use the `@Options` annotation to configure this
    behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a service class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, we need to add some transaction and session handling code
    in order to use mapper classes. This can be done in *service classes*. A service
    class is simply a class that performs some kind of business logic (in contrast,
    a mapper class performs persistence-only logic). The following is an example of
    a class that encapsulates session handling in order to avoid coupling the UI with
    MyBatis-related logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each persistence unit of work should be enclosed by an active session. Additionally,
    for insert or updates, we need to commit the transaction to the database.
  prefs: []
  type: TYPE_NORMAL
- en: MyBatis is a powerful and mature framework you should keep in mind when deciding
    on technologies. There are many other features, such as the possibility to map
    methods to SQL stored procedures or using XML files (or even the Apache Velocity
    scripting language) to define the SQL queries, which is useful when the queries
    require multiple lines or need to be formed dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to SQL databases using jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ is a persistence framework that allows you to define SQL queries using
    the Java Programming Language. It has many capabilities and this section, we will
    only show a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, you can start by adding the required dependencies to start using
    jOOQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can find all the code developed in this section in the `Data-centric-Applications-with-Vaadin-8/chapter-06/jooq-example`
    Maven project.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a database connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use jOOQ with any connection pool you prefer. The example for this
    section uses the same approach we used with plain JDBC, so the connection properties
    can be defined in a `datasource.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be familiar with how to use a `ServletContextListener`
    to initialize a database connection pool. Let's omit that part (see the section
    about JDBC for details) and jump directly to more specific topics.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse-engineering the database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say you have a database schema to manage books and authors. A possible
    SQL query for such a database could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ allows you to write this same SQL query, but in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax is quite close to actual SQL. You might be wondering
    where the `AUTHOR` object and its properties come from. They come from code generated
    by jOOQ. The code generation process can be automated with Maven. The following
    code shows how to configure the `jooq-codegen-maven` plugin in your `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You have to configure the connection properties so that the generator can scan
    the database schema. You also have to configure the database to use it (`H2`,
    in this example). Finally, you have to configure the package to be used for the
    generated code and the directory inside your project where this package is going
    to reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one small detail, though. We are using expressions (such as `${datasource.url}`)
    to specify the database connection properties. How can you use values coming from
    a `.properties` file inside the `pom.xml` file? By using the `properties-maven-plugin`
    Maven plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With the previous configuration, Maven will be able to read the properties in
    the `datasource.properties` file and replace the corresponding expressions in
    the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: After configuring this two Maven plugins, you can run `mvn clean package` to
    reverse-engineer the database schema and generate the corresponding code.
  prefs: []
  type: TYPE_NORMAL
- en: Running queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can run queries with jOOQ by creating a `DSLContext` instance. One way
    of getting this instance is with the `DSL.using` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, you can easily run queries using the fluent API offered by jOOQ.
    For example, to get all the rows in the messages table, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `MessagesRecord` class and `MESSAGES` instance are provided by the code
    generated by jOOQ. This makes the previous query type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, your database schema changes, you'll get a compilation
    error and will have the chance to fix the problem before deploying it to production.
    This is one of the strengths of jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can imagine how to implement a `MessageRepository` class using
    jOOQ. Here''s the solution to such a puzzle, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And the convenient `JooqService.runWithDslContext` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in jOOQ, you might want to evaluate *Ebean* ([http://ebean-orm.github.io](http://ebean-orm.github.io))
    and *Querydsl* ([http://www.querydsl.com](http://www.querydsl.com)), which are
    both ORM frameworks that also allow you to implement type-safe queries in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was full of new technologies! We discussed what an object-relational
    mapping framework is, and studied practical examples on how to use three popular
    persistence technologies for Java: JPA, MyBatis, and jOOQ. We saw how Vaadin Framework
    allows us to consume any kind of Java API directly, usually through custom abstractions
    that encapsulate details (such as service and repository classes). We learned
    the most basic form of data binding in Vaadin, which consists of setting and getting
    the values directly from domain objects to UI components. We also learned how
    to separate code that builds up the UI from the code, which adds behavior to it
    in order to improve its maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml), *Implementing CRUD
    User Interfaces*, we are going to see more Vaadin-related topics and discuss data
    binding in more depth.
  prefs: []
  type: TYPE_NORMAL
