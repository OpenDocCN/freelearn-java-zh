- en: Connecting to SQL Databases Using ORM Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ORM框架连接到SQL数据库
- en: The **Vaadin Framework** is a *web framework—a* library, if you wish, that helps
    with *web development*. You, as a developer, have the opportunity to integrate
    it with any other Java technology, and in particular, with any persistence technology.
    Since the most popular technology for persisting data is SQL, this chapter is
    dedicated to exploring several alternatives to connecting to SQL databases from
    Vaadin applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vaadin框架**是一个*Web框架——如果愿意的话，也可以是一个库，它有助于*Web开发*。作为开发者，你有机会将其与其他Java技术集成，特别是与任何持久化技术集成。由于最流行的数据持久化技术是SQL，因此本章致力于探讨从Vaadin应用程序连接到SQL数据库的几种替代方案。'
- en: 'We will start by studying the concept of o*bject-relational mapping*, a technique
    that allows developers to use an object-oriented programming language to consume
    and manipulate data in an otherwise incompatible system. We''ll then move on to
    explore three of the most popular Java frameworks used to connect to SQL databases:
    *JPA*, *MyBatis*, and *jOOQ*. These technologies are widely used in the industry,
    and it''s important that you understand at least the philosophy and fundamentals
    of each one in order to select the best options for your projects.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先研究*对象关系映射*的概念，这是一种允许开发者使用面向对象编程语言在否则不兼容的系统中消费和操作数据的技术。然后，我们将继续探讨用于连接到SQL数据库的三个最流行的Java框架：*JPA*、*MyBatis*和*jOOQ*。这些技术在行业中广泛使用，了解每个技术的哲学和基础对于选择最适合你项目的选项非常重要。
- en: Throughout the sections in this chapter, we will develop very simple web UIs
    that list data from a database (using the `Grid` class), and present a simple
    form to add data to it. The purpose of the examples is to show you the very fundamentals
    of data binding with Vaadin. The next chapter will focus on more advanced data
    binding to develop sophisticated **CRUD** (**Create, Read, Update, and Delete**)
    user interfaces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的各个部分中，我们将开发非常简单的Web UI，列出数据库中的数据（使用`Grid`类），并展示一个简单的表单来添加数据。这些示例的目的是向你展示使用Vaadin进行数据绑定的基本原理。下一章将专注于更高级的数据绑定，以开发复杂的**CRUD**（创建、读取、更新和删除）用户界面。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: '**Object-relational mapping** (**ORM**) frameworks'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象关系映射** (**ORM**)框架'
- en: '**Java Persistence API** (**JPA**)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java持久化API** (**JPA**)'
- en: MyBatis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MyBatis
- en: '**Java Object Oriented Querying** (**jOOQ**)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java面向对象查询** (**jOOQ**)'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要拥有Java SE开发工具包和Java EE SDK版本8或更高版本。你还需要Maven版本3或更高版本。建议使用具有Maven支持的Java IDE，如IntelliJ
    IDEA、Eclipse或NetBeans。最后，为了使用本书的Git仓库，你需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，以查看代码的实际运行情况：
- en: '[https://goo.gl/p1CGkr](https://goo.gl/p1CGkr)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/p1CGkr](https://goo.gl/p1CGkr)'
- en: Using object-relational mapping frameworks
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象关系映射框架
- en: In a relational database, data is represented as *tables*. In a Java program,
    data is represented as *objects*. For example, if you have data related to customers,
    you can store this data in a `customers` table. Similarly, you can store this
    data in objects which are instances of the `Customer` class. *Object-relational
    mapping* frameworks allow you to convert the data between these two systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，数据以*表*的形式表示。在Java程序中，数据以*对象*的形式表示。例如，如果你有与客户相关的数据，你可以将这些数据存储在`customers`表中。同样，你也可以将这些数据存储在`Customer`类的实例对象中。*对象关系映射*框架允许你在这两个系统之间转换数据。
- en: We already learned how to fetch data via JDBC and the `ResultSet` interface
    in the previous chapter. You could take an instance of this interface, iterate
    over the rows, and manually set the fields of a Java class such as `Customer`.
    When you do so, you are doing the job of an ORM framework. Why reinvent the wheel?
    The Java ecosystem offers several options to fix the *object-relational impedance
    mismatch*. In the following sections, we'll examine three of the most popular
    alternatives to solve this impedance mismatch.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章学习了如何通过JDBC和`ResultSet`接口获取数据。你可以获取这个接口的一个实例，遍历行，并手动设置Java类如`Customer`的字段。当你这样做的时候，你就是在做ORM框架的工作。为什么要重新发明轮子呢？Java生态系统提供了几个选项来解决*对象-关系阻抗不匹配*。在接下来的几节中，我们将检查三种最流行的替代方案来解决这种阻抗不匹配。
- en: The Object Oriented paradigm is based on software engineering principles, while
    the Relational paradigm is based on mathematical principles. The *object-relational
    impedance mismatch* refers to the incompatibility between these two paradigms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象范式基于软件工程原则，而关系范式基于数学原则。*对象-关系阻抗不匹配*指的是这两个范式之间的不兼容性。
- en: The examples developed in the following sections use the H2 database instance
    we initialized during the introduction to JDBC in the previous chapter. Make sure
    that the H2 server is running and that the `messages` table exists (see the `packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization`
    class for details). You can use any other database if you want. If so, make sure
    your database server is running, create the `messages` table, and configure your
    application to point to your new database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中开发的示例使用的是我们在上一章介绍JDBC时初始化的H2数据库实例。请确保H2服务器正在运行，并且`messages`表存在（有关详细信息，请参阅`packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization`类）。如果你想使用其他数据库，请确保你的数据库服务器正在运行，创建`messages`表，并配置你的应用程序以指向你的新数据库。
- en: Connecting to SQL databases using JPA
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA连接SQL数据库
- en: The first thing you need to know about the JPA is that it is a specification,
    not an implementation. There are several implementations, *Hibernate* and *EclipseLink*
    arguably being the most popular ones. In this book, we'll use Hibernate. The other
    things you need to learn about JPA are better learned by coding! Let's see how
    to create a simple Vaadin application that shows a `Grid` with the messages in
    the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JPA的第一件事你需要知道的是，它是一个规范，而不是一个实现。有几个实现，其中*Hibernate*和*EclipseLink*可能是最受欢迎的。在这本书中，我们将使用Hibernate。关于JPA的其他一些事情，通过编码学习会更好！让我们看看如何创建一个简单的Vaadin应用程序，该程序显示数据库中的`Grid`消息。
- en: 'What do you think is the first thing you need to do to start using JPA, or
    more specifically, Hibernate? It''s, of course, adding the dependencies. Create
    a Vaadin project and add the following dependencies to your `pom.xml` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为开始使用JPA，或者更具体地说，Hibernate的第一件事需要做什么？当然是添加依赖项。创建一个Vaadin项目，并将以下依赖项添加到你的`pom.xml`文件中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find all the code developed in this section in the `Data-centric-Applications-with-Vaadin-8/chapter-06/jpa-example`
    Maven project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本节的`Data-centric-Applications-with-Vaadin-8/chapter-06/jpa-example` Maven项目中找到所有开发的代码。
- en: Defining a persistence unit
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义持久化单元
- en: 'So, JPA is ready in the classpath. What could be the next logical step? It
    makes sense to define a connection to the database next. The simplest way of doing
    this is by creating a `persistence.xml` file. JPA will automatically read this
    file in the `META-INF` directory in your classpath. In a Maven project, the location
    is `resources/META-INF/persistence.xml`. Inside this file, you can define one
    or more *persistence units* (database connections) and its connection properties.
    The following is an example of a minimal `persistence.xml` file you can use to
    connect to the H2 database:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JPA已经包含在类路径中。下一步的逻辑步骤可能是什么？定义数据库连接是合理的。最简单的方法是创建一个`persistence.xml`文件。JPA将自动读取类路径中`META-INF`目录下的此文件。在Maven项目中，位置是`resources/META-INF/persistence.xml`。在这个文件中，你可以定义一个或多个*持久化单元*（数据库连接）及其连接属性。以下是一个你可以用来连接H2数据库的最小`persistence.xml`文件示例：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since you can define multiple persistence units (when your application needs
    to connect to multiple databases, for example), each persistence unit must have
    a name that identifies it. We have used `jpa-example-pu` for ours. Notice how
    we used the same connection properties (URL, user, password) we used previously
    with plain JDBC.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以定义多个持久化单元（例如，当你的应用程序需要连接到多个数据库时），每个持久化单元都必须有一个名称来标识它。我们为我们的持久化单元使用了`jpa-example-pu`。注意我们如何使用了之前与纯JDBC相同的连接属性（URL、用户、密码）。
- en: Creating an EntityManagerFactory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建EntityManagerFactory
- en: We have *defined* a connection through a persistence unit, but the application
    is not actually *using* it yet. The way applications make use of JPA is through
    the `EntityManagerFactory`. You can think of the `EntityManagerFactory` as the
    *entry point to JPA*. An `EntityManagerFactory` allows you to interact with a
    specific persistence unit. It's almost, but not precisely, like the connection
    pool, if you like.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过持久化单元定义了一个连接，但应用程序实际上还没有真正*使用*它。应用程序使用JPA的方式是通过`EntityManagerFactory`。你可以将`EntityManagerFactory`视为JPA的*入口点*。`EntityManagerFactory`允许你与特定的持久化单元进行交互。如果你喜欢，它几乎，但不完全像连接池。
- en: JPA implementations, like Hibernate or EclipseLink, offer built-in connection
    pooling mechanisms which are handled internally. You can usually adjust the pool
    configuration by using additional properties in the persistence unit definition.
    Consult the documentation of the JPA implementation you use for more details.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JPA实现，如Hibernate或EclipseLink，提供内置的连接池机制，这些机制由内部处理。你通常可以通过在持久化单元定义中使用额外的属性来调整池配置。有关详细信息，请参阅你使用的JPA实现的文档。
- en: 'In our case, there''s only one persistence unit, `jpa-example-pu`, so it makes
    sense to have only one `EntityManagerFactory` instance per instance of the application.
    As with plain JDBC, we can use `ServletContextListener` to create the `EntityManagerFactory`,
    but once again, let''s delegate this to a different class to encapsulate JPA-related
    stuff:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，只有一个持久化单元`jpa-example-pu`，因此对于每个应用程序实例只有一个`EntityManagerFactory`实例是有意义的。与纯JDBC一样，我们可以使用`ServletContextListener`来创建`EntityManagerFactory`，但再次，让我们将此委托给另一个类来封装与JPA相关的内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have defined the `init` and `close` methods to initialize and close the
    `EntityManagerFactory`, respectively. These methods can be used in a `ServletContextListener`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`init`和`close`方法，分别用于初始化和关闭`EntityManagerFactory`。这些方法可以在`ServletContextListener`中使用：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `JPAService` method also exposes the `EntityManagerFactory` instance though
    the `getFactory` method. This is where things start to get more functional. With
    JPA, you use an `EntityManagerFactory` to create `EntityManager` instances. Think
    of an `EntityManager` as a *working unit*, a concrete interaction you need to
    perform with the database, for example, saving data or reading it. Some class
    could use the `JPAService.getFactory` method to, for example, get all the messages
    from the database. Omitting the code that actually queries the database and exception
    handling, the following is the *general infrastructure* code to interact with
    the database with JPA:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`JPAService`方法还通过`getFactory`方法公开了`EntityManagerFactory`实例。从这里开始，事情开始变得更加功能化。使用JPA时，你使用`EntityManagerFactory`来创建`EntityManager`实例。将`EntityManager`视为一个*工作单元*，例如，你需要与数据库进行的具体交互，例如保存数据或读取数据。某个类可以使用`JPAService.getFactory`方法，例如，从数据库中获取所有消息。省略实际查询数据库和异常处理的代码，以下是与JPA交互的*通用基础设施*代码：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code gets the `EntityManagerFactory` to create a new `EntityManager`. With
    it, a new database transaction can be started. After this, you can put the code
    that actually runs queries against the database, but before we unveil the `...
    run queries ...` code, we need to implement an important class we are missing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码获取`EntityManagerFactory`以创建一个新的`EntityManager`。有了它，可以开始一个新的数据库事务。在此之后，你可以放置实际运行数据库查询的代码，但在我们揭示`...运行查询...`代码之前，我们需要实现一个我们缺少的重要类。
- en: Implementing Entity classes
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现实体类
- en: 'JPA is an ORM framework. It *maps* SQL tables to Java objects. We already have
    the SQL table, `messages`, but what about the Java counterpart? We need to define
    a `Message` class. If you had a look at the code for the JDBC section, you probably
    saw the SQL code to create the messages table. If not, here it is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JPA是一个ORM框架。它*映射*SQL表到Java对象。我们已经有SQL表`messages`，但Java对应的部分是什么？我们需要定义一个`Message`类。如果你看过JDBC部分的代码，你可能看到了创建消息表的SQL代码。如果没有，这里就是：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We want that table to be represented on the Java side as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个表在Java端表示如下：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This class is going to be what JPA calls an Entity class, a **POJO** class
    (**Plain Old Java Object**) that is annotated to match an SQL table. You can use
    annotations to *tell* JPA how to *map* the objects to the tables. The code speaks
    by itself:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将成为JPA所说的实体类，一个**POJO**（**Plain Old Java Object**）类，它被注解以匹配一个SQL表。你可以使用注解来*告诉*JPA如何*映射*对象到表。代码本身就能说明一切：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are using the `@Entity` annotation to mark the class as an Entity. `@Table`
    tells JPA which SQL table to map to. `@Id` marks the property that corresponds
    to the primary key in the SQL table. How about the `auto_increment` definition
    for the `id` column in the messages table? We don''t want to worry about *counting*
    IDs to keep track of which value to use next, right? We can tell JPA that this
    column is generated by the database as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@Entity`注解来标记类为一个实体。`@Table`告诉JPA映射到哪个SQL表。`@Id`标记与SQL表中的主键对应的属性。关于消息表中的`id`列的`auto_increment`定义如何？我们不想担心*计数*ID以跟踪下一个要使用的值，对吧？我们可以这样告诉JPA该列是由数据库生成的：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Depending on your database, you may want to use a different strategy. For example,
    with PostgreSQL, you would most likely use `GenerationType.SEQUENCE` instead.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的数据库，你可能想要使用不同的策略。例如，对于PostgreSQL，你很可能会使用`GenerationType.SEQUENCE`。
- en: 'The `id` column in the messages table defines the *identity* of a row. It has
    to be the same as its Java counterpart. We can do this by overriding the `equals`
    method, and because of the `Object.hashCode` method contract, we also need to
    override the `hashCode` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 消息表中的`id`列定义了行的*标识*。它必须与其Java对应项相同。我们可以通过重写`equals`方法来实现这一点，由于`Object.hashCode`方法的契约，我们还需要重写`hashCode`方法：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'According to the JavaDocs for the `Object.equals` method: "...it is generally
    necessary to override the `hashCode` method whenever this method is overridden,
    so as to maintain the general contract for the `hashCode` method, which states
    that equal objects must have equal hash codes". Most IDEs include a feature to
    generate this code for you.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JavaDocs中`Object.equals`方法的说明：“...通常在重写此方法时需要重写`hashCode`方法，以便维护`hashCode`方法的通用契约，该契约指出，相等的对象必须具有相等的哈希码”。大多数IDE都包含一个功能可以为你生成此代码。
- en: Executing queries
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行查询
- en: 'The connection properties are ready, the `EntityManagerFactory` is ready, and
    the Entity class is ready. Time to unveil the `... run queries ...` part:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 连接属性已准备就绪，`EntityManagerFactory`已准备就绪，实体类也已准备就绪。现在是时候揭露`... run queries ...`部分了：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At first, you might think `select m from Message m` is SQL code. But it's not!
    First of all, there's no `Messages` table in the database (it's `messages`). Second
    of all, this query is a **Java Persistence Query Language** (**JPQL**) query.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能会认为`select m from Message m`是SQL代码。但事实并非如此！首先，数据库中没有`Messages`表（它是`messages`）。其次，这个查询是一个**Java
    Persistence Query Language**（**JPQL**）查询。
- en: JPQL is a platform-independent language similar to SQL. JPA converts JPQL queries
    to corresponding SQL queries that can be sent to the database. There's not enough
    space in this chapter to cover all the features of JPQL. There are plenty of resources
    online about it if you want to learn more.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL是一种与SQL类似的平台无关的语言。JPA将JPQL查询转换为相应的SQL查询，这些查询可以发送到数据库。如果你想要了解更多关于JPQL的信息，网上有很多资源。
- en: 'The previous code looks exactly like something you would encapsulate in a repository
    class. Let''s do so and implement a `MessageRepository` class as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码看起来就像你会在仓库类中封装的东西。让我们这样做，并实现一个`MessageRepository`类，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There''s a lot of boilerplate code. Repository classes like to have many methods,
    and most of them will need the same kind of infrastructure code to run a single
    query. Fortunately, we can use some Java constructs to encapsulate the logic for
    creating an `EntityManager`, opening and closing a transaction, and closing the
    `EntityManager`. The `JPAService` class looks like the perfect candidate for this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多样板代码。仓库类喜欢有很多方法，其中大多数都需要相同类型的基础设施代码来运行单个查询。幸运的是，我们可以使用一些Java结构来封装创建`EntityManager`、打开和关闭事务以及关闭`EntityManager`的逻辑。`JPAService`类看起来是完美的候选者：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `runInTransaction` method is a generic method that uses a Java `Function`
    which delegates the actual query logic to clients. Thanks to Java lambda expressions,
    we can clean up the code in the `MessagesService` class as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`runInTransaction`方法是一个通用方法，它使用Java `Function`将实际的查询逻辑委托给客户端。得益于Java lambda表达式，我们可以按照以下方式清理`MessagesService`类的代码：'
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also add a method to save new messages. With JPA, this is pretty simple:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个保存新消息的方法。使用JPA，这很简单：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how the `EntityManager.persist` method directly accepts an instance of
    the `Message` Entity class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`EntityManager.persist`方法直接接受`Message`实体类的实例。
- en: Note that the configuration and code examples in this chapter are valid in the
    context of web applications that use the Servlet specification only. When using
    the full Jakarta EE (previously Java EE) specification or Spring Framework, the
    configuration and code have subtle variations and practices. For example, you
    should use JNDI discoverable data sources configured in the server instead of
    specifying usernames and passwords for database connections with Jakarta EE. Also,
    transaction boundaries can be automatically managed with Jakarta EE and Spring
    Framework, which means that you don't need to implement and use the `runInTransaction`
    method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的配置和代码示例仅在仅使用Servlet规范的网络应用程序的上下文中有效。当使用完整的Jakarta EE（之前称为Java EE）规范或Spring框架时，配置和代码有细微的差异和实践。例如，您应该使用服务器中配置的JNDI可发现的数据源，而不是使用Jakarta
    EE指定数据库连接的用户名和密码。此外，可以使用Jakarta EE和Spring框架自动管理事务边界，这意味着您不需要实现和使用`runInTransaction`方法。
- en: Implementing a Vaadin UI to list and save Entities
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个用于列出和保存实体的Vaadin UI
- en: 'How can we use this from a Vaadin UI? Not a mystery at all, right? Just use
    Vaadin components and call the `MessageRepository` class when needed. Let''s see
    it in action! Start by implementing a basic UI that shows a `Grid`, a `TextField`,
    and a `Button`, something like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从Vaadin UI中使用它？这根本不是什么秘密，对吧？只需使用Vaadin组件，并在需要时调用`MessageRepository`类。让我们看看它是如何工作的！首先实现一个基本的UI，显示一个`Grid`、一个`TextField`和一个`Button`，如下所示：
- en: '![](img/bd012df3-2e97-4e2e-b752-7107257bd394.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd012df3-2e97-4e2e-b752-7107257bd394.png)'
- en: 'Feel free to implement a different layout for it. The following is the implementation
    corresponding to the previous screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 随意实现不同的布局。以下是对应于上一张截图的实现：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous implementation shows a good practice: separating the code that
    builds up the UI from the code that adds behavior to it. The behavior, in this
    case, means adding a `ClickListener` that saves the message in the `TextField`
    and showing messages from the database in the grid. The following completes the
    implementation of the behavior for the UI:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实现展示了良好的实践：将构建UI的代码与添加到UI上的行为代码分离。在这个例子中，行为意味着添加一个`ClickListener`来保存`TextField`中的消息，并在网格中显示数据库中的消息。以下完成了UI行为实现的代码：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are directly using the `MessageRepository` class to invoke persistence-related
    logic. Notice how the *data binding* is done in the `saveCurrentMessage` method.
    This binding goes in only one direction: from the UI to the Entity. This is the
    most basic form of data binding you can use with Vaadin. In the case of the `Grid`,
    the data binding goes in the other direction: from the Entities to the UI. We''ll
    see more advanced data binding techniques in the next chapter.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接使用`MessageRepository`类来调用与持久性相关的逻辑。注意`saveCurrentMessage`方法中是如何进行数据绑定的。这种绑定是单向的：从UI到实体。这是您可以使用Vaadin的最为基本的数据绑定形式。在`Grid`的情况下，数据绑定方向相反：从实体到UI。我们将在下一章中看到更高级的数据绑定技术。
- en: When should you use JPA? In general, JPA is good for RDBMS portability. JPA
    is widely used in the industry and there are many tools and resources available
    for it. JPA is an official Java specification with several vendors offering implementations
    (such as Hibernate and EclipseLink). JPA is not the only official Java specification
    for persistence. **Java Data Objects** (**JDO**) is another Java specification
    you may want to, at least, consider.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 何时应该使用JPA？一般来说，JPA适合RDBMS的可移植性。JPA在业界得到广泛应用，并且有许多工具和资源可用。JPA是一个官方的Java规范，多个供应商提供实现（如Hibernate和EclipseLink）。JPA不是唯一的官方Java持久性规范。**Java数据对象**（**JDO**）是另一个您可能至少想要考虑的Java规范。
- en: Connecting to SQL databases using MyBatis
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MyBatis连接SQL数据库
- en: MyBatis is a persistence framework that maps SQL to Java objects. The MyBatis
    learning curve is flatter than JPA's and leverages on SQL, which makes it a good
    match if you have good knowledge about SQL or have many complex SQL queries you
    want to reuse.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MyBatis 是一个将 SQL 映射到 Java 对象的持久化框架。MyBatis 的学习曲线比 JPA 平坦，并且利用了 SQL，这使得如果你对 SQL
    有很好的了解或者有很多复杂的 SQL 查询需要重用，它是一个很好的选择。
- en: 'As usual, you first need to add the dependency. Here is how to do it with Maven:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，你首先需要添加依赖项。以下是如何使用 Maven 来做这件事的示例：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can find the full implementation of the example developed in this section
    in the `Data-centric-Applications-with-Vaadin-8/chapter-06/mybatis-example` Maven
    project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本节中开发的示例的完整实现，在 `Data-centric-Applications-with-Vaadin-8/chapter-06/mybatis-example`
    Maven 项目中找到。
- en: Defining a database connection
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据库连接
- en: 'With MyBatis, you can define a database connection using a Java API or a configuration
    XML file. The easiest way is to put an XML file in the classpath (the `resources`
    directory, when using Maven). The following is an example of such a configuration
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MyBatis，你可以使用 Java API 或配置 XML 文件来定义数据库连接。最简单的方法是将一个 XML 文件放在类路径中（当使用 Maven
    时，是 `resources` 目录）。以下是一个这样的配置文件的示例：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can use any name for this file. The example for this section uses `mybatis-config.xml`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为这个文件命名任何名称。本节的示例使用 `mybatis-config.xml`。
- en: As you can see, we used the same connection properties we used for JDBC and
    JPA, but we added a `driver` property. Its value should correspond to the name
    of JDBC driver which you are going to use for the database connection.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了与 JDBC 和 JPA 相同的连接属性，但添加了一个 `driver` 属性。它的值应该对应于你将要用于数据库连接的 JDBC 驱动程序的名称。
- en: 'How do we use this file? Once again, we can use a `ServletContextListener`
    to initialize MyBatis. Moreover, the `ServletContextListener` can delegate to
    a service class like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个文件？再一次，我们可以使用 `ServletContextListener` 来初始化 MyBatis。此外，`ServletContextListener`
    可以委托给一个像以下这样的服务类：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `SqlSessionFactory` class is the *entry point* to MyBatis. The previous
    class provides the init method that can be called from a `ServletContextListener`,
    which creates one `SqlSessionFactory` per instance of the application, and exposes
    it through a getter. This is a pattern similar to the one we previously used with
    JPA.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlSessionFactory` 类是 MyBatis 的 *入口点*。前面的类提供了一个可以从 `ServletContextListener`
    调用的初始化方法，它为应用程序的每个实例创建一个 `SqlSessionFactory`，并通过 getter 暴露它。这与我们之前与 JPA 一起使用的模式类似。'
- en: Implementing mapper classes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现映射类
- en: 'MyBatis uses *mapper classes* (actually, interfaces) to define the methods
    that will map SQL queries to Java objects. These are almost the equivalent of
    the repository classes we have developed so far. However, it makes sense to use
    MyBatis terminology when using it. Also, as we''ll see later, we need to add transaction
    or session management code around the calls to the mapper class, but let''s start
    with the mapper class. If you were observant, the `mybatis-config.xml` file defined
    a mapper class in the `mappers` section. Go back and have a look at it. The following
    is the definition of such a mapper:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MyBatis 使用 *映射类*（实际上，是接口）来定义将 SQL 查询映射到 Java 对象的方法。这些几乎等同于我们迄今为止开发的仓库类。然而，当使用
    MyBatis 时，使用 MyBatis 术语是有意义的。此外，正如我们稍后将要看到的，我们需要在调用映射类的方法周围添加事务或会话管理代码，但让我们先从映射类开始。如果你足够细心，`mybatis-config.xml`
    文件在 `mappers` 部分定义了一个映射类。回去看看它。以下是一个这样的映射类的定义：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, `MessageMapper` is an interface. You don''t have to implement
    this interface; MyBatis will provide the implementation for you at runtime. We
    have defined two methods: one to return a `List` of Messages, and another to save
    a `Message`. Notice the `@Select` and `@Insert` annotations. These are used to
    define the SQL that will run when these methods are called. Also, notice how you
    can pass values from the arguments to the SQL query. The save method accepts a
    `Message` instance. In the SQL query defined by the `@Insert` annotation, we use
    `#{content}` to *pass* the value of the `Message.content` property to the query.
    You could have passed a `String` with the value too. In that case, you can use
    the name of the parameter directly. However, we want MyBatis to set the value
    of the `id` property after the row has been inserted. This value is autogenerated
    in the database, so we have to use the `@Options` annotation to configure this
    behavior.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`MessageMapper` 是一个接口。您不必实现此接口；MyBatis 将在运行时为您提供实现。我们定义了两个方法：一个用于返回 `List`
    类型的消息，另一个用于保存消息。注意 `@Select` 和 `@Insert` 注解。这些注解用于定义当调用这些方法时将运行的 SQL。注意您如何将参数的值传递到
    SQL 查询中。保存方法接受一个 `Message` 实例。在由 `@Insert` 注解定义的 SQL 查询中，我们使用 `#{content}` 来 *传递*
    `Message.content` 属性的值到查询中。您也可以传递一个包含该值的 `String`。在这种情况下，您可以直接使用参数的名称。然而，我们希望
    MyBatis 在行插入后设置 `id` 属性的值。此值在数据库中是自动生成的，因此我们必须使用 `@Options` 注解来配置此行为。
- en: Implementing a service class
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务类
- en: 'As mentioned before, we need to add some transaction and session handling code
    in order to use mapper classes. This can be done in *service classes*. A service
    class is simply a class that performs some kind of business logic (in contrast,
    a mapper class performs persistence-only logic). The following is an example of
    a class that encapsulates session handling in order to avoid coupling the UI with
    MyBatis-related logic:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要添加一些事务和会话处理代码，以便使用映射类。这可以在 *服务类* 中完成。服务类是一个执行某种业务逻辑的类（相比之下，映射类仅执行持久化逻辑）。以下是一个封装会话处理以避免将
    UI 与 MyBatis 相关逻辑耦合的类的示例：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each persistence unit of work should be enclosed by an active session. Additionally,
    for insert or updates, we need to commit the transaction to the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作单元的持久化操作都应该被一个活跃的会话所包围。此外，对于插入或更新操作，我们需要将事务提交到数据库。
- en: MyBatis is a powerful and mature framework you should keep in mind when deciding
    on technologies. There are many other features, such as the possibility to map
    methods to SQL stored procedures or using XML files (or even the Apache Velocity
    scripting language) to define the SQL queries, which is useful when the queries
    require multiple lines or need to be formed dynamically.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: MyBatis 是一个强大且成熟的框架，在决定技术时您应该牢记。它有许多其他功能，例如将方法映射到 SQL 存储过程或使用 XML 文件（甚至 Apache
    Velocity 脚本语言）来定义 SQL 查询的可能性，这在查询需要多行或需要动态形成时非常有用。
- en: Connecting to SQL databases using jOOQ
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jOOQ 连接到 SQL 数据库
- en: jOOQ is a persistence framework that allows you to define SQL queries using
    the Java Programming Language. It has many capabilities and this section, we will
    only show a few of them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 是一个持久化框架，允许您使用 Java 编程语言定义 SQL 查询。它具有许多功能，在本节中，我们只展示其中的一些。
- en: 'As always, you can start by adding the required dependencies to start using
    jOOQ:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，您可以通过添加所需的依赖项来开始使用 jOOQ：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can find all the code developed in this section in the `Data-centric-Applications-with-Vaadin-8/chapter-06/jooq-example`
    Maven project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Data-centric-Applications-with-Vaadin-8/chapter-06/jooq-example` Maven
    项目中找到本节中开发的全部代码。
- en: Defining a database connection
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据库连接
- en: 'You can use jOOQ with any connection pool you prefer. The example for this
    section uses the same approach we used with plain JDBC, so the connection properties
    can be defined in a `datasource.properties` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您喜欢的任何连接池与 jOOQ 一起使用。本节的示例使用与我们使用纯 JDBC 相同的方法，因此连接属性可以在 `datasource.properties`
    文件中定义：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, you should be familiar with how to use a `ServletContextListener`
    to initialize a database connection pool. Let's omit that part (see the section
    about JDBC for details) and jump directly to more specific topics.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该熟悉如何使用 `ServletContextListener` 来初始化数据库连接池。让我们省略这部分（有关详细信息，请参阅关于 JDBC
    的部分）并直接跳到更具体的话题。
- en: Reverse-engineering the database schema
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向工程数据库模式
- en: 'Let''s say you have a database schema to manage books and authors. A possible
    SQL query for such a database could look like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个用于管理书籍和作者的数据库模式。这样一个数据库的可能 SQL 查询可能如下所示：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'jOOQ allows you to write this same SQL query, but in Java:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 允许您用 Java 编写相同的 SQL 查询：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, the syntax is quite close to actual SQL. You might be wondering
    where the `AUTHOR` object and its properties come from. They come from code generated
    by jOOQ. The code generation process can be automated with Maven. The following
    code shows how to configure the `jooq-codegen-maven` plugin in your `pom.xml`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，语法与实际的 SQL 非常接近。您可能想知道 `AUTHOR` 对象及其属性从何而来。它们来自 jOOQ 生成的代码。代码生成过程可以用 Maven
    自动化。以下代码展示了如何在 `pom.xml` 中配置 `jooq-codegen-maven` 插件：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You have to configure the connection properties so that the generator can scan
    the database schema. You also have to configure the database to use it (`H2`,
    in this example). Finally, you have to configure the package to be used for the
    generated code and the directory inside your project where this package is going
    to reside.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须配置连接属性，以便生成器可以扫描数据库模式。您还必须配置数据库以使用它（在这个例子中是 `H2`）。最后，您必须配置用于生成代码的包以及该项目中该包所在的目录。
- en: 'There''s one small detail, though. We are using expressions (such as `${datasource.url}`)
    to specify the database connection properties. How can you use values coming from
    a `.properties` file inside the `pom.xml` file? By using the `properties-maven-plugin`
    Maven plugin:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个小细节。我们使用表达式（如 `${datasource.url}`）来指定数据库连接属性。您如何在 `pom.xml` 文件中使用来自 `.properties`
    文件中的值？通过使用 `properties-maven-plugin` Maven 插件：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the previous configuration, Maven will be able to read the properties in
    the `datasource.properties` file and replace the corresponding expressions in
    the `pom.xml` file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置中，Maven 将能够读取 `datasource.properties` 文件中的属性，并替换 `pom.xml` 文件中相应的表达式。
- en: After configuring this two Maven plugins, you can run `mvn clean package` to
    reverse-engineer the database schema and generate the corresponding code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置这两个 Maven 插件之后，您可以通过运行 `mvn clean package` 来逆向工程数据库模式并生成相应的代码。
- en: Running queries
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行查询
- en: 'You can run queries with jOOQ by creating a `DSLContext` instance. One way
    of getting this instance is with the `DSL.using` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建一个 `DSLContext` 实例来使用 jOOQ 运行查询。获取此实例的一种方法是通过 `DSL.using` 方法：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this, you can easily run queries using the fluent API offered by jOOQ.
    For example, to get all the rows in the messages table, you can use the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以使用 jOOQ 提供的流畅 API 轻松运行查询。例如，要获取消息表中的所有行，您可以使用以下代码：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `MessagesRecord` class and `MESSAGES` instance are provided by the code
    generated by jOOQ. This makes the previous query type-safe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagesRecord` 类和 `MESSAGES` 实例是由 jOOQ 生成的代码提供的。这使得之前的查询具有类型安全性。'
- en: If, for some reason, your database schema changes, you'll get a compilation
    error and will have the chance to fix the problem before deploying it to production.
    This is one of the strengths of jOOQ.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，您的数据库模式发生变化，您将遇到编译错误，并在将其部署到生产之前有机会修复问题。这是 jOOQ 的一个优点。
- en: 'From here, you can imagine how to implement a `MessageRepository` class using
    jOOQ. Here''s the solution to such a puzzle, though:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以想象如何使用 jOOQ 实现一个 `MessageRepository` 类。以下是解决这个谜题的方案：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And the convenient `JooqService.runWithDslContext` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以及方便的 `JooqService.runWithDslContext` 方法：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you are interested in jOOQ, you might want to evaluate *Ebean* ([http://ebean-orm.github.io](http://ebean-orm.github.io))
    and *Querydsl* ([http://www.querydsl.com](http://www.querydsl.com)), which are
    both ORM frameworks that also allow you to implement type-safe queries in Java.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对 jOOQ 感兴趣，您可能想评估 *Ebean* ([http://ebean-orm.github.io](http://ebean-orm.github.io))
    和 *Querydsl* ([http://www.querydsl.com](http://www.querydsl.com))，这两个都是允许您在 Java
    中实现类型安全查询的 ORM 框架。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was full of new technologies! We discussed what an object-relational
    mapping framework is, and studied practical examples on how to use three popular
    persistence technologies for Java: JPA, MyBatis, and jOOQ. We saw how Vaadin Framework
    allows us to consume any kind of Java API directly, usually through custom abstractions
    that encapsulate details (such as service and repository classes). We learned
    the most basic form of data binding in Vaadin, which consists of setting and getting
    the values directly from domain objects to UI components. We also learned how
    to separate code that builds up the UI from the code, which adds behavior to it
    in order to improve its maintainability.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章充满了新技术！我们讨论了对象关系映射框架是什么，并研究了如何使用Java的三个流行持久化技术：JPA、MyBatis和jOOQ的实践示例。我们看到了Vaadin框架如何允许我们直接消费任何类型的Java
    API，通常是通过封装细节（如服务和仓库类）的自定义抽象来实现。我们还学习了Vaadin中最基本的数据绑定形式，它包括直接从领域对象设置和获取值到UI组件。我们还学习了如何将构建UI的代码与添加行为以改进其可维护性的代码分开。
- en: In [Chapter 7](8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml), *Implementing CRUD
    User Interfaces*, we are going to see more Vaadin-related topics and discuss data
    binding in more depth.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml)《实现CRUD用户界面》中，我们将探讨更多与Vaadin相关的主题，并更深入地讨论数据绑定。
