<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-97" class="chapter-number"><a id="_idTextAnchor106"/>5</h1>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor107"/>Language Fundamentals – Classes</h1>
			<p>An <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) program is based on the design of structures called classes that are used as the blueprint for objects. An object is the implementation of a class. This means that the first step in coding in <strong class="bold">OO programming</strong> (<strong class="bold">OOP</strong>) is to create classes. This chapter will examine how the features of OOP are implemented in Java. We begin by looking at how we define variables in a class followed by how we control access to members of a class and the class itself. From here, we will look at the class structure Java provides us for creating or working with classes <span class="No-Break">and objects.</span></p>
			<p>In this chapter, you will learn about <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Class fields</span></li>
				<li>Understanding <span class="No-Break">access control</span></li>
				<li><span class="No-Break">Understanding classes</span></li>
			</ul>
			<p>By the end of this chapter, you will be able to define classes, instantiate them into objects, and interact with other classes. Let’s begin by looking at access control. Before we begin, let’s look at the two categories of variables that you can declare in <span class="No-Break">a class.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor108"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Java <span class="No-Break">17 installed</span></li>
				<li><span class="No-Break">Text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
			</ul>
			<p>You can find the code from this chapter in the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor109"/>Class fields</h1>
			<p>Variables declared<a id="_idIndexMarker357"/> in a class and not in a method call are referred to as fields. They fall into <span class="No-Break">two </span><span class="No-Break"><a id="_idIndexMarker358"/></span><span class="No-Break">categories:</span></p>
			<ul>
				<li><span class="No-Break">Instance variables</span></li>
				<li><span class="No-Break">Class variables</span></li>
			</ul>
			<p><strong class="bold">Instance variables</strong> are unique<a id="_idIndexMarker359"/> to every instance of the class. They can be primitives or references. If we had an instance variable of type <strong class="source-inline">double</strong> in a class and we created 100 instances of the object, we would have <span class="No-Break">100 doubles.</span></p>
			<p>In Java, you can have a variable in a class that is shared by all objects created from the class. In other words, every object has a unique set of instance variables, but all share the <strong class="bold">class variables</strong>. This <a id="_idIndexMarker360"/>is accomplished by designating the variable as static. There is only one memory allocation for a static variable. In our 100 instances of an object, there is just one double if you declare the double <span class="No-Break">as static.</span></p>
			<p>Another characteristic of a static or class variable is that assuming it has public access control, you can access it without instantiating the object. For example, consider the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
 public class TestBed {
    public static String bob;</pre>
			<p>In this fragment, we can access the <strong class="source-inline">class</strong> variable <strong class="source-inline">bob</strong> by simply writing <strong class="source-inline">TestBed.bob</strong>. We don’t have to instantiate the object. If we do instantiate it, we can use the reference, though this <span class="No-Break">is rare.</span></p>
			<p>The fact that class variables are shared by all objects makes them an ideal tool for objects created from the same class to communicate with each other. If one object changes the value of a class variable, then even another object of the same class can see the <span class="No-Break">updated value.</span></p>
			<p>Before we move on to the next section on access control, let’s clarify one more term. We refer to all variables declared in a class as <strong class="bold">fields</strong>. This includes both class and <span class="No-Break">instance variabl<a id="_idTextAnchor110"/>es.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor111"/>Understanding access control</h1>
			<p>One significant and <a id="_idIndexMarker361"/>invaluable feature of OOP is <strong class="bold">access control</strong>. If you have already worked with an OO language, then you may be familiar with this concept; if not, let me explain what access <span class="No-Break">control means.</span></p>
			<p>Access control in Java concerns the visibility of classes, fields, and methods to other classes. You must have sufficient access to create objects and access fields and methods in <span class="No-Break">a class.</span></p>
			<p>Access control, in other languages, may imply a security mechanism that can ensure that a request for access to a method–for example–is coming from an authenticated user. This is not what Java does; in Java, it is about how objects can interact with <span class="No-Break">each other.</span></p>
			<p>Let’s look at the options for visibility; the first will be <span class="No-Break">Java packages.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor112"/>Packages</h2>
			<p>The first piece of the<a id="_idIndexMarker362"/> access control puzzle is the Java package<a id="_idIndexMarker363"/> and its corresponding <strong class="source-inline">import</strong> statement. In <a href="B19088_03.xhtml#_idTextAnchor062"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The Maven Build Tool</em>, we learned about Java packages and how they are simply a folder that contains Java code. Code in one package cannot access code in another package unless you give access by including an <strong class="source-inline">import</strong> statement. The class that imports can access code in what it imports. Without an <strong class="source-inline">import</strong> class, the <strong class="source-inline">statement</strong> classes in different packages cannot interact with <span class="No-Break">each other.</span></p>
			<p>Keep in mind that the interaction is one way. For example, class A has an <strong class="source-inline">import</strong> statement for class B. Class A can call or send messages to code in class B but not vice versa. You could add an <strong class="source-inline">import</strong> statement to class B for class A, and then they can each send a message to <span class="No-Break">the other.</span></p>
			<p>Using packages for access control is simplistic; it is a simple binary setting. You can either see an object of a class that you are importing or you cannot see the class at all if you did not import it. All classes in the same package have an implicit import for the other classes in the same package, and, in this case, there is no need to import fellow package <span class="No-Break">classes explicitly.</span></p>
			<p>Now, we are ready to look at the four access control specifiers available <span class="No-Break">to us.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor113"/>The public specifier</h2>
			<p>The <strong class="bold">public specifier</strong> in <a id="_idIndexMarker364"/>Java is the same as in C++ and C#. It defines how <a id="_idIndexMarker365"/>users can access fields and methods of a class. With the appropriate <strong class="source-inline">import</strong> statement, if required, any other object can create objects of that <span class="No-Break">public class.</span></p>
			<p>You can access a public class’s fields from any object that has a reference to a second object. We should always keep class fields private so that we cannot directly assign values to the field. To interact with a private variable, you will need methods in the same class that will be your proxy to read or write to the private variable. When writing to the field, you will be able to validate the new value before it is assigned to <span class="No-Break">the field.</span></p>
			<p>You can call class methods that are public from any other object that has a reference to the object containing the public method. We refer to the public methods of a class as its interface. We will look at interfaces in the <span class="No-Break">next chapter.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor114"/>The private specifier</h2>
			<p>The <strong class="bold">private specifier</strong> in Java<a id="_idIndexMarker366"/> is the same as in C++ and C#–you<a id="_idIndexMarker367"/> use this specifier to define access control for fields <span class="No-Break">and methods.</span></p>
			<p>As already mentioned, class fields should always be private. You will need to validate the data that you want to store in a private field. A common way to do this is with a mutator, commonly called a setter method. Here, you can add validation and reject invalid data by throwing <span class="No-Break">an exception.</span></p>
			<p>Methods designated as private can only be called upon by other methods in the same class. Using private methods allows us to break down complex tasks into smaller units. As they are private, they cannot be called upon from other objects, and this ensures that all the necessary steps of a complex task will be carried out in the <span class="No-Break">correct order.</span></p>
			<p>Java permits you to define a new class within another class. This is the only situation where a class may be private. A private non-inner class could not be instantiated. You cannot use a private inner class outside the class you declare it in. You can instantiate a private inner class in the class that declared it. As already mentioned, instance variables should always be private while methods may be any of the four <span class="No-Break">access designations.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor115"/>The protected specifier</h2>
			<p>The <strong class="bold">protected specifier</strong> in <a id="_idIndexMarker368"/>Java is similar to those in C++ and C#–you <a id="_idIndexMarker369"/>use this specifier to define access control for fields and methods. Protected, also referred to as <strong class="source-inline">protected/package</strong>, is only used when you are<a id="_idIndexMarker370"/> employing <strong class="bold">inheritance</strong>. In a non-inheritance situation, protected behaves the same as package access. In C++ and C#, the concept of package does not exist, so in a non-inheritance situation, these languages treat protected <span class="No-Break">as private.</span></p>
			<p>Inheritance, as we will see in the next chapter, is an arrangement between two classes where one class is <a id="_idIndexMarker371"/>a <strong class="bold">superclass</strong> and the<a id="_idIndexMarker372"/> other is a <strong class="bold">subclass</strong>. A subclass can access all the public members of its superclass, including the instance variable designated as protected in the superclass. Other objects with references to the superclass not involved with inheritance see protected members as private or–if these objects are defined in the same <span class="No-Break">package–as package.</span></p>
			<p>Methods and class variables that you designate as protected also possess package access, as described in the next section. You cannot have a <span class="No-Break">protected class.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor116"/>The package specifier</h2>
			<p>This final access<a id="_idIndexMarker373"/> specifier, package, has no equivalent<a id="_idIndexMarker374"/> in C++ or C#, although there is some similarity to the friend concept in these languages. It defines the visibility of classes, fields, and methods in other objects that are defined in the same package. There is no designator such as public, private, or protected. When not explicitly using a specifier on a class, field, or method, then the implicit access control <span class="No-Break">is package.</span></p>
			<p>An object that has a reference to another object defined in a different package or folder sees protected as private. The objects of two different classes in the same package can access protected elements as if they <span class="No-Break">were public.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">One last point before we move on–use protected and package specifiers sparingly. They exist for situations where the interaction between objects can be speeded up. The problem is that they expose fields and methods to objects that should not have access to them. I recommend that you only ever use public and private when you start designing and coding a program. Only if you can demonstrate that the system performance is suffering by only using public or private components should you consider protected <span class="No-Break">and package.</span></p>
			<p>One last point to reiterate–access control does not exist inside a class. This means that a public method can call a <strong class="source-inline">private</strong> method in the same class. Every method has access to every field no matter its access <span class="No-Break">control designation.</span></p>
			<p>Now, we are ready<a id="_idIndexMarker375"/> to look at how classes work. We will first <a id="_idIndexMarker376"/>look at the classes from the last chapter’s program, and then we will create an updated vers<a id="_idTextAnchor117"/>ion of <span class="No-Break">the program.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor118"/>Understanding classes</h1>
			<p>Java, as with other OO<a id="_idIndexMarker377"/> languages, uses a syntax that revolves around the source code structure called a <strong class="bold">class</strong>. But first, what is a class? The theorists who introduced the concept of objects envisioned a class as a custom data type. Think of the primitive integer type–it has a range of allowable values and a pre-defined set of operations such as addition, subtraction, and the other usual operators. Imagine a class as a custom primitive in which you decide which operations, in the form of methods, your type will perform. One goal of OOP is to focus on problem-solving by developing custom data types that combine data and actions as opposed to the structured programming approach where data and actions <span class="No-Break">are separate.</span></p>
			<p>This means that you develop a class by first listing all the fields of the class, either primitives or references to other classes. Next come the methods that conduct useful tasks that make use of these fields. These variables are visible to every method in a class regardless of the access <span class="No-Break">control level.</span></p>
			<p>Classes are not executable code, with one exception we will see shortly. Instead, a class is a blueprint that must be instantiated or created at runtime using the <strong class="source-inline">new</strong> keyword. When your program begins<a id="_idIndexMarker378"/> execution, the <strong class="bold">Java virtual machine</strong> (<strong class="bold">JVM</strong>) stores <a id="_idIndexMarker379"/>the class definition in a region of memory called the <span class="No-Break"><strong class="bold">class-method region</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">new</strong> operator conducts <span class="No-Break">two tasks:</span></p>
			<ul>
				<li>Allocates sufficient memory for all the instance variables in a class blueprint. We refer to this region of memory<a id="_idIndexMarker380"/> as the <strong class="bold">heap</strong>. Memory for class or static variables is allocated when the program begins and is found in the <span class="No-Break"><strong class="source-inline">Class-Method</strong></span><span class="No-Break"> region.</span></li>
				<li>Assigns the address of the allocated regions of memory to the appropriate reference variable. A reference variable is always just 4 bytes long. Accessing objects through a reference variable is called <span class="No-Break">indirect addressing.</span></li>
			</ul>
			<p>There is a third region of memory that comes into play called the stack. The JVM stores all local variables–variables declared in methods–in the stack data structure as required. The stack is a dynamic structure that can allocate space for variables and then deallocate them by just moving a pointer. If you are interested in memory management, see the <em class="italic">Further reading</em> section at the end of this chapter for <span class="No-Break">more information.</span></p>
			<p>Before we go any further, we <a id="_idIndexMarker381"/>need to understand the two methods that the JVM can invoke whenever we create <span class="No-Break">an object.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor119"/>constructor and finalize methods</h2>
			<p>There are two special methods found in most OO languages related to memory management. The <strong class="source-inline">constructor</strong> method runs as the last step in the creation of an object whereas the <strong class="source-inline">destructor</strong> method, called <strong class="source-inline">finalize</strong> in Java, runs as the first step when an object goes out of scope. How this happens in Java is different than in other languages such <span class="No-Break">as C++.</span></p>
			<h3>finalize</h3>
			<p>There can be<a id="_idIndexMarker382"/> only <a id="_idIndexMarker383"/>one <strong class="source-inline">finalize</strong> method in a class. You cannot overload it. Do not use it–Java 9 deprecated it. If you are a C++ developer, you may mistakenly believe that <strong class="source-inline">finalize</strong> is the Java equivalent of a C++ destructor. However, that’s not <span class="No-Break">true–here’s why.</span></p>
			<p>In C++, the <strong class="source-inline">delete</strong> operator runs the <strong class="source-inline">destructor</strong> method first. Once the <strong class="source-inline">destructor</strong> method runs, the <strong class="source-inline">delete</strong> operator releases the memory used by the object, which can now be reallocated. This works because when you execute the <strong class="source-inline">delete</strong> operator on a valid pointer to an object, the actions in the <strong class="source-inline">destructor</strong> function <span class="No-Break">execute immediately.</span></p>
			<p>In Java, there is no <strong class="source-inline">delete</strong> operator; instead, the JVM monitors all references to objects. When an object reference goes out of scope, the JVM enters it on a list of references that the JVM will release for you. However, for efficiency and performance, the JVM does not immediately release memory. Instead, it puts it off for as long as possible. This is due to the time necessary to release memory, which can impact the current programs running in the JVM. We call the release of<a id="_idIndexMarker384"/> memory <span class="No-Break"><strong class="bold">garbage collection</strong></span><span class="No-Break">.</span></p>
			<p>The JVM runs the <strong class="source-inline">finalize</strong> method just before garbage collection. This garbage collection could be occurring every few minutes or less, but that’s very unlikely. Given a great deal of RAM (my system has 32 GB), this can mean that garbage collection could happen every few hours or even days. Therefore, <strong class="source-inline">finalize</strong> is non-deterministic. It may want to effect changes or send messages to parts of your program for reasons no longer valid, or that part of the program has already been <span class="No-Break">garbage collected.</span></p>
			<p>For this and other reasons, the Java architects made the decision to deprecate <strong class="source-inline">finalize</strong>. So, do not use it. If you want a method called before an object goes out of scope, then you will have to explicitly call a method <span class="No-Break">you created.</span></p>
			<p>With the <strong class="source-inline">finalize</strong> method <a id="_idIndexMarker385"/>discussed and then assigned to the rubbish<a id="_idIndexMarker386"/> or deprecated bin, let’s look at <span class="No-Break">the constructor.</span></p>
			<h3>Constructor</h3>
			<p>The purpose of the<a id="_idIndexMarker387"/> constructor<a id="_idIndexMarker388"/> is to conduct any actions necessary as the last step in object creation. Typically, you use the constructor to initialize class instance variables. We have seen that we can initialize these variables right at the point of declaration in the class. Sometimes, the initialization requires more steps than just assigning a value, and this is where the constructor <span class="No-Break">is invaluable.</span></p>
			<p>You create an object by invoking the <strong class="source-inline">new</strong> operator. The <strong class="source-inline">new</strong> operator conducts tasks that result in the creation of an object. I am simplifying how this works, but it conveys what you need <span class="No-Break">to know:</span></p>
			<ol>
				<li>Memory is allocated in the heap region of memory for all instance variables, along with other required structures that the JVM requires. The address of this memory is what the <strong class="source-inline">this</strong> reference captures. Subsequently, every call to non-static methods in this class now has a first parameter, which is the invisible <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> parameter.</span></li>
			</ol>
			<p>Let’s code <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class MyClass() {
   public void doSomething(int value) { … }
   . . .
}</pre>
			<p>Then, we’ll instantiate it, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
var testClass = new MyClass();</pre>
			<p>The non-static methods become the following after <span class="No-Break">being compiled:</span></p>
			<pre class="source-code">
   public void doSomething(MyClass this, int value) { … }</pre>
			<p>You can never write the code this way. <strong class="source-inline">MyClass this</strong> is implied and so may not <span class="No-Break">be written.</span></p>
			<p>Now, we’ll call this method: </p>
			<pre class="source-code">
testClass.doSomething(42);</pre>
			<p>It then becomes the following: </p>
			<pre class="source-code">
testClass.doSomething(testClass, 42);</pre>
			<ol>
				<li value="2">Once<a id="_idIndexMarker389"/> memory <a id="_idIndexMarker390"/>is allocated, along with other housekeeping chores, the JVM calls the appropriate <strong class="source-inline">constructor</strong> method. It does not have a return type as it does not have a variable to return a result to. You must name them with the same name as the class they <span class="No-Break">belong to.</span></li>
			</ol>
			<p>Constructors fall into two categories: default <a id="_idIndexMarker391"/>and non-default. A <strong class="bold">default constructor</strong>, of which there can only be one, has no parameters. A <strong class="bold">non-default constructor</strong> is one<a id="_idIndexMarker392"/> with parameters. It is subject to overloading, so there can be more than one non-default constructor if the parameter types <span class="No-Break">are different.</span></p>
			<p>Java provides the capability of having one constructor call another constructor. The first constructor called is determined by the rules of overloading. The called constructor can then call upon one other constructor. This call must be the first line of code. Watch out for a possible <strong class="source-inline">recursive constructor invocation</strong> error where constructor A calls constructor B and constructor B calls <span class="No-Break">constructor A.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor120"/>Revising the compound interest program</h2>
			<p>We are now<a id="_idIndexMarker393"/> ready to review our compound interest program and apply what we have just covered to the classes in <span class="No-Break">this project.</span></p>
			<p>For this, let’s look in more depth at the <strong class="source-inline">CompoundInterest04</strong> program that we discussed in <a href="B19088_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Code, Compile, </em><span class="No-Break"><em class="italic">and Execute</em></span><span class="No-Break">.</span></p>
			<p>We will begin by declaring the package in the <strong class="source-inline">CompoundInterestCalculator04.java</strong> file. Packages, the folders we place our source code into, allow us to manage our code by functionality. The only time you might not want to use a package is if you are creating a single-file source-code or Linux <span class="No-Break">shebang application.</span></p>
			<p>Here is the package declaration. The file will be in a folder named <strong class="source-inline">business</strong>, which is in the <span class="No-Break"><strong class="source-inline">com/kenfogel/compoundinterest04</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
package com.kenfogel.compoundinterest04.business;</pre>
			<p>This program will be using the <strong class="source-inline">NumberFormat</strong> class. This class is part of Java’s standard library, and we know this because the first name in its package designation is <strong class="source-inline">java</strong>. To make use of this class, we must import it into our file, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
import java.text.NumberFormat;</pre>
			<p>The first line of the class declaration shows us <span class="No-Break">the following:</span></p>
			<ul>
				<li>This class is public and so can be instantiated in any other class that declares a reference <span class="No-Break">to it.</span></li>
				<li>The public class name, <strong class="source-inline">CompoundInterestCalculator04</strong>, must also be the name of the file. You can have more than one class structure in a file but only one of them may <span class="No-Break">be public.</span></li>
			</ul>
			<p>Here is the first line of <span class="No-Break">the declaration:</span></p>
			<pre class="source-code">
public class CompoundInterestCalculator04 {</pre>
			<p>Here are the fields in <span class="No-Break">the class:</span></p>
			<pre class="source-code">
    private final double principal = 100.0;
    private final double annualInterestRate = 0.05;
    private final double compoundPerTimeUnit = 12.0;
    private final double time = 5.0; // </pre>
			<p>We are declaring four instance variables of type <strong class="source-inline">double</strong>. The access control designation of <strong class="source-inline">private</strong> means that you cannot access these variables from any other class that may have a reference to this class. The <strong class="source-inline">final</strong> modifier defines these variables as immutable. In a class, access control does not apply but modifiers do. You must initialize a <strong class="source-inline">final</strong> variable where you declared it or in <span class="No-Break">the constructor.</span></p>
			<p>Next, we are declaring references to objects that we will use in <span class="No-Break">the code:</span></p>
			<pre class="source-code">
    private final NumberFormat currencyFormat;
    private final NumberFormat percentFormat;</pre>
			<p>We are declaring two instances of a <strong class="source-inline">NumberFormat</strong> class. You can see from the variable names that <a id="_idIndexMarker394"/>we planned each one for a different format. These are final, meaning we must initialize them with a value and they cannot be instantiated a second time. Rather than instantiate the <strong class="source-inline">NumberFormat</strong> references in their declaration, we can also instantiate them in a constructor, and that is what we <span class="No-Break">will do.</span></p>
			<p>The following method is <span class="No-Break">the constructor:</span></p>
			<pre class="source-code">
    public CompoundInterestCalculator04() {
        currencyFormat = 
              NumberFormat.getCurrencyInstance();
        percentFormat = NumberFormat.getPercentInstance();
        percentFormat.setMinimumFractionDigits(0);
        percentFormat.setMaximumFractionDigits(5);
    }</pre>
			<p>The constructor is easy to recognize as it must have the same name as the class. It does not return a value as the JVM calls the constructor as part of the <strong class="source-inline">new</strong> operation. There is nothing to assign a result from a <strong class="source-inline">return</strong> statement to. This is a default constructor as there are no arguments inside the parentheses. A class may have only one default constructor but may overload the constructor with constructors that take as arguments different <span class="No-Break">data types.</span></p>
			<p>The task that this constructor conducts is the initialization and configuration of the <strong class="source-inline">NumberFormat</strong> objects. Rather than just using the <strong class="source-inline">new</strong> operator, this class is instantiated by using a factory method. Factory methods conduct additional tasks before invoking <strong class="source-inline">new</strong>. Also, take note that we call the methods through the class name and not through an object name, very much like the <strong class="source-inline">Math</strong> library methods. This tells us that <strong class="source-inline">getCurrencyInstance</strong> and <strong class="source-inline">getPercentInstance</strong> are static methods that are available. We will discuss static methods later in <span class="No-Break">this section.</span></p>
			<p>Next up is the method we want to call after the object <span class="No-Break">is instantiated:</span></p>
			<pre class="source-code">
    public void perform() {</pre>
			<p>The name <strong class="source-inline">perform</strong> is just a name of my choosing. All that is important to remember is that, except for the constructor, all methods should be verbs. Keep in mind that class and variable identifiers should <span class="No-Break">be nouns.</span></p>
			<p>The first line of the <a id="_idIndexMarker395"/>method calls upon the <strong class="source-inline">calculateCompoundInterest</strong> method to perform the calculation and stores the result in the<a id="_idTextAnchor121"/> <span class="No-Break"><strong class="source-inline">result</strong></span><span class="No-Break"> variable:</span></p>
			<pre class="source-code">
        var result = calculateCompoundInterest();</pre>
			<p>This next line displays the result <span class="No-Break">formatted appropriately:</span></p>
			<pre class="source-code">
        System.out.printf(
            "If you deposit %s in a savings account "
            + "that pays %s annual interest compounded "     
            + "monthly%nyou will have after %1.0f "
            + "years %s%n", 
            currencyFormat.format(principal),
            percentFormat.format(annualInterestRate),
            time, currencyFormat.format(result));
    }</pre>
			<p>The plus symbols in the code mean concatenation. As the string is quite long, it has been broken up into multiple strings joined by the <span class="No-Break">plus operator.</span></p>
			<p>Here, we see the method that carries out the calculation of <span class="No-Break">the answer:</span></p>
			<pre class="source-code">
    private double calculateCompoundInterest() {
        var result = principal * 
          Math.pow(1 + annualInterestRate / 
          compoundPerTimeUnit, time * compoundPerTimeUnit);
        return result;
    }
}</pre>
			<p>Using the instance variables, calculate the result to a variable named <strong class="source-inline">result</strong> that the method returns to whoever called it. It is a private method, so only other methods in this class can <span class="No-Break">see it.</span></p>
			<p>The second class from the compound interest example holds just the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> method.</span></p>
			<p>Again, let’s declare the package this file <span class="No-Break">is in:</span></p>
			<pre class="source-code">
package com.kenfogel.compoundinterest04.app;</pre>
			<p>This program will<a id="_idIndexMarker396"/> be using the <strong class="source-inline">CompoundInterestCalculator04</strong> class that we have written. As with all imports, we are referencing a class that we wrote in a package/folder <span class="No-Break">we created:</span></p>
			<pre class="source-code">
import com.kenfogel.compoundinterest04.business
                            .CompoundInterestCalculator04;</pre>
			<p>Here is the first line that declares <span class="No-Break">the class:</span></p>
			<pre class="source-code">
public class CompoundInterest04 {</pre>
			<p>It shows us <span class="No-Break">the following:</span></p>
			<ul>
				<li>This class is public and so can be instantiated in any other class that declares a reference <span class="No-Break">to it.</span></li>
				<li>The class name, <strong class="source-inline">CompoundInterest04</strong>, must also be the name of <span class="No-Break">the file.</span></li>
			</ul>
			<p>You can have more than one class structure in a file but only one of them may <span class="No-Break">be public.</span></p>
			<p>Every Java program must have a <strong class="source-inline">main</strong> method. This is where the JVM begins the execution of <span class="No-Break">your program:</span></p>
			<pre class="source-code">
    public static void main(String[] args) {</pre>
			<p>The <strong class="source-inline">main</strong> method is a static method. What sets static methods apart from non-static ones is that we can call these static methods without instantiating the object, such as what we did with the static methods for <strong class="source-inline">NumberFormat</strong>. The <strong class="source-inline">Math</strong> library works the same way. To use the <strong class="source-inline">pow</strong> function, we just write <strong class="source-inline">Math.pow</strong>. We do not need to instantiate the <strong class="source-inline">Math</strong> <span class="No-Break">object first.</span></p>
			<p>Here, we instantiate the <strong class="source-inline">CompoundInterestCalculator04</strong> class into an object with a reference <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">banker</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        var banker = new CompoundInterestCalculator04();</pre>
			<p>We end <strong class="source-inline">main</strong> with a call to the perform method in <span class="No-Break"><strong class="source-inline">CompoundInterestCalculator04</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
        banker.perform();
    }
}</pre>
			<p>We have now<a id="_idIndexMarker397"/> reviewed how the <strong class="source-inline">CompoundInterest04</strong> program is constructed and how we make use of access control <span class="No-Break">and packages.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor122"/>Class organization based on functionality</h2>
			<p>The compound<a id="_idIndexMarker398"/> interest program we have been using from the start of this book conducts its specific task correctly. However, the problem with this approach is that the program is a dead end–not that being a dead end is necessarily bad. Sometimes, you just want a <em class="italic">one-off</em> program that can determine the answer to a <span class="No-Break">specific problem.</span></p>
			<p>But what if we were to write a complex program? In the real world, meaning coding in your job, you will seldom be writing programs such as our compound interest calculator. Imagine you wanted to create a more thorough banking system. In this system, it will be necessary to gather input from the user rather than hardcoding it in the program’s source code. Taking it further, you may want to store the input and the result in an external storage such as a database. You may also want to generate reports based on the <span class="No-Break">stored data.</span></p>
			<p>Let’s now reorganize the <strong class="source-inline">CompoundInterest04</strong> program, now renamed <strong class="source-inline">CompoundInterest05</strong>, based <span class="No-Break">on functionality.</span></p>
			<h3>The data class</h3>
			<p>The first step is to <a id="_idIndexMarker399"/>design a class that just holds the data. There will be no domain methods, such as for calculating, storing in a database, or interacting with the end user for input and output methods. We are creating a new data type that we can use in classes that perform other actions. This type of class follows a pattern first described <a id="_idIndexMarker400"/>as a <strong class="bold">JavaBean</strong>. Java introduced it as a reusable <span class="No-Break">software component.</span></p>
			<p>What we are creating is not a pure JavaBean, but a variant. I frequently refer to this type of class as a simple box of variables. Let’s look at one for our compound <span class="No-Break">interest problem.</span></p>
			<p>We begin with the <strong class="source-inline">package</strong> statement. We will use the package name in any class that needs to use this by importing the name, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
package com.kenfogel.compoundinterest05.data;</pre>
			<p>Here is the standard public <span class="No-Break">class declaration:</span></p>
			<pre class="source-code">
public class CompoundInterestData {</pre>
			<p>Here are the four variables required to perform <span class="No-Break">the calculation:</span></p>
			<pre class="source-code">
    private final double principal;
    private final double annualInterestRate;
    private final double compoundPerTimeUnit;
    private final double time;</pre>
			<p>We declare the four instance variables here. They are final so that once assigned a value, it becomes immutable. We expect these to come from the program’s user rather than hardcoding the values as we have done up until now. This means that every new calculation will need a new <span class="No-Break"><strong class="source-inline">CompoundInterestData</strong></span><span class="No-Break"> object.</span></p>
			<p>This last variable is where we plan to store the result of <span class="No-Break">the calculation:</span></p>
			<pre class="source-code">
    private double result;</pre>
			<p>As there are no actions in this class, we cannot determine when this value will be set, so it cannot <span class="No-Break">be final.</span></p>
			<p>This is <span class="No-Break">the constructor:</span></p>
			<pre class="source-code">
    public CompoundInterestData(double principal, 
               double annualInterestRate, 
               double compoundPerTimeUnit, 
               double time) {
        this.principal = principal;
        this.annualInterestRate = annualInterestRate;
        this.compoundPerTimeUnit = compoundPerTimeUnit;
        this.time = time;
    }</pre>
			<p>It has four required <a id="_idIndexMarker401"/>arguments when this class is instantiated. Once assigned to the class variables, you cannot change the value they hold. Take note of the <strong class="source-inline">this</strong> keyword. As we used the same name for the instance variables and the arguments of the method, we use <strong class="source-inline">this</strong> to designate an instance variable. Remember that <strong class="source-inline">this</strong> is the address of the instance variables in the class. There is not a <strong class="source-inline">this</strong> reference for class or static variables as there is ever only one of them per class. Without using <strong class="source-inline">this</strong>, you are referring to the method’s argument of the same name. The <strong class="source-inline">result</strong> instance variable is not one of the arguments as you will calculate its value later in <span class="No-Break">the program.</span></p>
			<p>The next four methods are getters for the four class <span class="No-Break">instance variables:</span></p>
			<pre class="source-code">
    public double getPrincipal() {
        return principal;
    }
    public double getAnnualInterestRate() {
        return annualInterestRate;
    }
    public double getCompoundPerTimeUnit() {
        return compoundPerTimeUnit;
    }
    public double getTime() {
        return time;
    }</pre>
			<p>The JavaBean specification that this class is based on requires that all instance variables be private. The spec goes on to define setter and getter methods. As these first four are immutable by virtue of being <strong class="source-inline">final</strong>, you can only have a getter. You will be providing the initial value when you create an object <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break">.</span></p>
			<p>These last two <a id="_idIndexMarker402"/>methods are special because the <strong class="source-inline">result</strong> variable is <span class="No-Break">not final:</span></p>
			<pre class="source-code">
    public double getResult() {
        return result;
    }
    public void setResult(double result) {
        this.result = result;
    }
}</pre>
			<p>We determine the value after this class is instantiated. We assign values to the four input values in the constructor. Frameworks such as the Java Persistence API or Jakarta expect this getter and <span class="No-Break">setter syntax.</span></p>
			<h3>The business class</h3>
			<p>Now, let’s<a id="_idIndexMarker403"/> write the <strong class="source-inline">calculation</strong> class. Its sole purpose will be to calculate the result and store it in the bean. We are importing the data class we <span class="No-Break">just created:</span></p>
			<pre class="source-code">
package com.kenfogel.compoundinterest05.business;
import com.kenfogel.compoundinterest05.data.
                                    CompoundInterestData05;
public class CompoundInterestCalculator05 {</pre>
			<p>This class has only one method and does not have any instance variables. As all the values are in <strong class="source-inline">CompoundInterestData05</strong>, we retrieve the values with a call to the property’s <strong class="source-inline">getter</strong> method. We end by assigning the result to the bean’s result variable by calling the <span class="No-Break">only setter:</span></p>
			<pre class="source-code">
    public voi<a id="_idTextAnchor123"/>d calculateCompoundInterest(
                    CompoundInterestData05 value) {
        var result = value.getPrincipal() * 
               Math.pow(1 + value.getAnnualInterestRate() / 
               value.getCompoundPerTimeUnit(),
               value.getTime() *
               value.getCompoundPerTimeUnit());
        value.setResult(result);
    }
}</pre>
			<h3>The user interface class</h3>
			<p>The last component <a id="_idIndexMarker404"/>is the user interface where we can ask the user for the four pieces of information required to perform the calculation. This is where we will create <span class="No-Break">this object:</span></p>
			<pre class="source-code">
package com.kenfogel.compoundinterest05.ui;</pre>
			<p>After the <strong class="source-inline">package</strong> statement, we have imports for the classes and libraries we will use. We have a new import, and that is for the <strong class="source-inline">Scanner</strong> library class. Objects of the <strong class="source-inline">Scanner</strong> class allow us to gather end-user input, such as from the keyboard, in a <span class="No-Break">console application:</span></p>
			<pre class="source-code">
import com.kenfogel.compoundinterest05.business.
                         CompoundInterestCalculator05;
import com.kenfogel.compoundinterest05.data.
                         CompoundInterestData05;
import java.text.NumberFormat;
import java.util.Scanner;
public class CompoundInterestUI05 {
    private CompoundInterestData05 inputData;
    private final CompoundInterestCalculator05 calculator;
    private final Scanner sc;
    private final NumberFormat currencyFormat;
    private final NumberFormat percentFormat;</pre>
			<p>In Java, there are <a id="_idIndexMarker405"/>no rules covering the order of methods or the locations of fields, unlike in C and C++ where the order can be significant. My personal style is, as you see in these examples, to place the instance variables first and the constructors right after. My advice on this point is to have the team you work with all agree to the coding style. This will make reading each other’s code <span class="No-Break">far easier.</span></p>
			<p>Here is the constructor that instantiates the <strong class="source-inline">NumberFormat</strong> objects and the <strong class="source-inline">Scanner</strong> class. You must provide the <strong class="source-inline">Scanner</strong> class’s constructor with the source of input. It could be from a file on disk, but for this program, it is coming from the keyboard. We call the object that interacts with the <span class="No-Break">keyboard’s </span><span class="No-Break"><strong class="source-inline">System.in</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    public CompoundInterestUI05() {
        currencyFormat = 
                NumberFormat.getCurrencyInstance();
        percentFormat = NumberFormat.getPercentInstance();
        percentFormat.setMinimumFractionDigits(0);
        percentFormat.setMaximumFractionDigits(5);
        
        sc = new Scanner(System.in);
        calculator = new CompoundInterestCalculator05();
    }</pre>
			<p>Next up is the entry point for this user interface class. This will be the only public method in this class. I use the <strong class="source-inline">do</strong> prefix as it ensures that the name is a verb or action. The four values we must request from the user exist as local or method variables. We assign the result of user input to each one. We instantiate the data object with the four local variables as parameters in this expression. The <strong class="source-inline">new</strong> operator copies the values from the local variables to the instance variables of the <strong class="source-inline">CompoundInterestData05</strong> object through the<a id="_idIndexMarker406"/> constructor. We then call upon <strong class="source-inline">calculateCompoundInterest</strong> in our <strong class="source-inline">Calculator</strong> class to calculate the result. The last step is to display <span class="No-Break">the result:</span></p>
			<pre class="source-code">
    public void doUserInterface() {
        doUserInstructions();
        var principal = doPrincipalInput();
        var annualInterestRate = doAnnualInterestRate();
        var compoundPerTimeUnit = doCompoundPerTimeUnit();
        <a id="_idTextAnchor124"/>var time = doTimeInput();
        inputData = new CompoundInterestData05(
              principal, 
              annualInterestRate, 
              compoundPerT<a id="_idTextAnchor125"/>imeUnit, 
              time);
        calculator.calculateCompoundInterest(inputData);
        displayTheResults();
    }</pre>
			<p>This version of the <strong class="source-inline">CompoundInterest</strong> program follows the classic pattern of input, process, and output. The first method we now encounter <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">output</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    private void displayTheResults() {
        System.out.printf(
         "If you deposit %s in a savings account that pays"
         + " %s annual interest compounded monthly%n"
         + "you will have after %1.0f years %s%n", 
         currencyFormat.format(inputData.getPrincipal()),
            percentFormat.format(
                inputData.getAnnualInterestRate()),
                inputData.getTime(), 
                currencyFormat.format(
                    inputData.getResult()));
    }</pre>
			<p>This next method is <a id="_idIndexMarker407"/>part of the input process. It could provide additional instructions on the screen to the end user, but I have kept it <span class="No-Break">simple here:</span></p>
			<pre class="source-code">
    private void doUserInstructions() {
        System.out.printf(
                 "Compound Interest Calculator%n%n");
    }</pre>
			<p>Now, we come to the user input. Each input will display a prompt and wait for input. Once you enter the string, the <strong class="source-inline">nextDouble</strong> method attempts to convert it to the appropriate type–in this <span class="No-Break">case, </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    private double doPrincipalInput() {
        System.out.printf("Enter the principal: ");
        var value = sc.nextDouble();
        return value;
    }
    private double doAnnualInterestRate() {
        System.out.printf("Enter the interest rate: ");
        var value = sc.nextDouble();
        return value;
    }
    private double doCompoundPerTimeUnit() {
        System.out.printf("Enter periods per year: ");
        var value = sc.nextDouble();
        return value;
    }
    private double doTimeInput() {
        System.out.printf("Enter the years: ");
        var value = sc.nextDouble();
        return value;
    }
}</pre>
			<p>But wait–there<a id="_idIndexMarker408"/> is something terribly wrong with the four input methods. They are identical except for the <strong class="source-inline">String</strong> prompt. As a teacher, I described repeated code as an invitation to failure. If we decided to make a change, such as switching from <strong class="source-inline">double</strong> to <strong class="source-inline">float</strong>, we must remember to make this change four times in eight separate places. The potential for inadvertently neglecting one of the changes is too high. Let’s turn this from four methods <span class="No-Break">to one.</span></p>
			<p>It’s simple–just make the prompt an argument to a single input method, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
    private double doUserInput(String prompt) {
        System.out.printf(prompt);
        var value = sc.nextDouble();
        return value;
    }</pre>
			<p>Now, we can use the <strong class="source-inline">doUserInput</strong> method for all four <span class="No-Break">user inputs:</span></p>
			<pre class="source-code">
    public void doUserInterface() {
        doUserInstructions();
        var principal = 
            doUserInput("Enter the principal: ");
        var annualInterestRate = 
            doUserInput("Enter the interest rate: ");
        var compoundPerTimeUnit = 
            doUserInput("Enter periods per year: ");
        var time = doUserInput("Enter the years: ");
        inputData = new CompoundInterestData05(
              principal, 
              annualInterestRate, 
              compoundPerTimeUnit, 
              time);
        calculator.calculateCompoundInterest(inputData);
        displayTheResults();
    }</pre>
			<p>All user input <a id="_idIndexMarker409"/>is a <strong class="source-inline">String</strong> object; you cannot enter pure numbers, Booleans, or characters. The <strong class="source-inline">Scanner</strong> class is responsible for converting from a string to the destination type, as expressed by the <span class="No-Break">next methods.</span></p>
			<p>In our example, they are all doubles. What happens if we enter the <strong class="source-inline">bob</strong> string instead of a number? Java will throw an exception. This is an error condition. When we look at loops, we will learn how to create user-proof input, and when we look at GUI programming, we will learn about other ways we can manage user input. In all situations, all input arrives–as already <span class="No-Break">mentioned–as strings.</span></p>
			<p>The last class is the <strong class="source-inline">app</strong> class. We commonly use the designation app to define a package that contains the class that holds the <strong class="source-inline">main</strong> method. This is a convention, and you can freely <span class="No-Break">change this:</span></p>
			<pre class="source-code">
package com.kenfogel.compoundinterest05.app;
import com.kenfogel.compoundinterest05.ui
                             .CompoundInterestUI05;
public class CompoundInterest05 {
    public static void main(String[] args) {
        var calculator = new CompoundInterestUI05();
        calculator.doUserInterface();
    }
}</pre>
			<p>When we run <a id="_idIndexMarker410"/>this new version, this will be <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Welcome to the Compound Interest Calculator</strong>
<strong class="bold">Enter the principal: 5000</strong>
<strong class="bold">Enter the interest rate: 0.05</strong>
<strong class="bold">Enter periods per year: 12</strong>
<strong class="bold">Enter the years: 5</strong>
<strong class="bold">If you deposit $5,000.00 in a savings account that pays 5% annual interest compounded monthly</strong>
<strong class="bold">you will have after 5 years $6,416.79</strong></pre>
			<p>The program requests from the user the four values it requires, and then using those values, it calculates<a id="_idIndexMarker411"/> the result and <span class="No-Break">displays it.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor126"/>Summary</h1>
			<p>In this chapter, we have explored the basic components of a class. Once we reviewed how we assembled the <strong class="source-inline">CompoundInterest04</strong> example, we broke the program apart and created classes to hold the data, display a user interface, and calculate the result. We also learned about the constructor and the deprecated <strong class="source-inline">finalize</strong> methods. We gained insight into what <strong class="source-inline">new</strong> does and how the JVM manages a <span class="No-Break">program’s memory.</span></p>
			<p>The second version, <strong class="source-inline">CompoundInterest05</strong>, presents how a program is organized professionally based on functionality. It kept separate the data, the user interface, and the action, usually called the business. To gather user input, we had our first look at the Java library <strong class="source-inline">Scanner</strong> class. You should now have a good understanding of how a Java class is organized and how you can control access to members of <span class="No-Break">the class.</span></p>
			<p>In the next chapter, we will look more closely at the methods that carry out the actions of a class and how we manage the relationships <span class="No-Break">between classes.</span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor127"/>Further reading</h1>
			<ul>
				<li><em class="italic">Stack Memory and Heap Space in </em><span class="No-Break"><em class="italic">Java</em></span><span class="No-Break">: </span><a href="https://www.baeldung.com/java-stack-heap"><span class="No-Break">https://www.baeldung.com/java-stack-heap</span></a></li>
			</ul>
		</div>
	</body></html>