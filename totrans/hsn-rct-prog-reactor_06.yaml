- en: Dynamic Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态渲染
- en: In the last chapter, we worked with SpringWebFlux to build simple web services.
    So far, we have built RESTful web services, which return JSON responses. However,
    SpringWebFlux is not limited to RESTful web services; it is a complete web framework
    that offers the capability to build dynamic web pages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用SpringWebFlux构建了简单的Web服务。到目前为止，我们已经构建了返回JSON响应的RESTful Web服务。然而，SpringWebFlux不仅限于RESTful
    Web服务；它是一个完整的Web框架，提供了构建动态网页的能力。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: View templates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图模板
- en: Static resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态资源
- en: WebClient
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebClient
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE, 2018.1 or above
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE，2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub链接为[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06)。
- en: View templates
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模板
- en: SpringWebFlux offers a number of options for rendering views, using various
    technology platforms. Whatever choice we make, the framework employs the same
    view resolution process, allowing us to arrive at the correct view. The view can
    then be rendered by using any of the supported technologies. In this section,
    we will cover the complete process of rendering views using SpringWebFlux.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SpringWebFlux提供了多种使用不同技术平台渲染视图的选项。无论我们做出何种选择，框架都会采用相同的视图解析过程，使我们能够得到正确的视图。然后，可以使用任何支持的技术来渲染视图。在本节中，我们将介绍使用SpringWebFlux渲染视图的完整过程。
- en: Resolving views
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析视图
- en: '**View resolution** is a process used by the framework to determine which view
    needs to be rendered for a received request. The complete view resolution process
    enables us to render different views for the same requests, based on content parameters.
    Before we start to build different views, let''s discuss how the framework determines
    what view it needs to render.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图解析**是框架用来确定对于接收到的请求需要渲染哪个视图的过程。完整的视图解析过程使我们能够根据内容参数渲染不同的视图。在我们开始构建不同的视图之前，让我们讨论一下框架是如何确定它需要渲染哪个视图的。'
- en: 'In the last chapter, we configured `HandlerFunction` for handling requests.
    This function gives back a `HandlerResult`. The `HandlerResult` contains not only
    the result, but also the attributes passed into the request. The framework then
    invokes `ViewResolutionResultHandler`, using the `HandlerResult`. The `ViewResolutionResultHandler`
    determines the correct view by validating the values returned for the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为处理请求配置了`HandlerFunction`。这个函数返回一个`HandlerResult`。`HandlerResult`不仅包含结果，还包含传递给请求的属性。然后，框架使用`HandlerResult`调用`ViewResolutionResultHandler`。`ViewResolutionResultHandler`通过验证以下返回值来确定正确的视图：
- en: '**String**: If the value returned is a string, then the framework builds a
    view using the configured `ViewResolvers`.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String**：如果返回值是字符串，则框架使用配置的`ViewResolvers`构建视图。'
- en: '**Void**: If nothing is returned, it tries to build the default view.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Void**：如果没有返回任何内容，它将尝试构建默认视图。'
- en: '**Map**: The framework looks for the default view, but it also adds the key
    values returned to the request model.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Map**：框架会查找默认视图，但也会将返回的键值添加到请求模型中。'
- en: The `ViewResolutionResultHandler` also looks up the content type passed in the
    request. In order to determine what view should be used, it compares the content
    type passed to the content type supported by the `ViewResolver`. It then selects
    the first `ViewResolver` that supports the request's content type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewResolutionResultHandler`还会查找请求中传递的内容类型。为了确定应该使用哪个视图，它会将传递给`ViewResolver`的内容类型与支持的内容类型进行比较。然后，它选择第一个支持请求内容类型的`ViewResolver`。'
- en: It is important to note that a request can redirect to another request. In order
    to do this, we prefix the `redirect:` keyword before the view name. The framework
    then uses a `UrlBasedViewResolver` and returns a URL for redirection. If the returned
    URL is from the same application, then the path can be built in a relative manner
    (for example, `redirect:/applicationA/locationA`). If the returned URL is from
    an external location, then the view name can be built using an absolute URL (for
    example, `redirect:http://www.google.com/search/`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，一个请求可以重定向到另一个请求。为了做到这一点，我们在视图名称之前加上`redirect:`关键字。然后框架使用`UrlBasedViewResolver`并返回一个用于重定向的URL。如果返回的URL来自同一应用程序，则路径可以以相对方式构建（例如，`redirect:/applicationA/locationA`）。如果返回的URL来自外部位置，则可以使用绝对URL构建视图名称（例如，`redirect:http://www.google.com/search/`）。
- en: Now that you know how the view resolution process works, let's try to build
    dynamic views by using the various supported template frameworks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了视图解析过程是如何工作的，让我们尝试使用各种支持的模板框架来构建动态视图。
- en: Freemarker
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Freemarker
- en: Freemarker is a template engine that can be used to generate dynamic HTML output.
    It is not limited to HTML pages; it can generate any kind of text output, such
    as emails, and reports. In order to use this, we have to write a template file
    using the Freemarker syntax. The Freemarker engine then receives the file, along
    with data to generate the resulting dynamic text.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Freemarker是一个可以用来生成动态HTML输出的模板引擎。它不仅限于HTML页面；它可以生成任何类型的文本输出，例如电子邮件和报告。为了使用它，我们必须使用Freemarker语法编写一个模板文件。然后Freemarker引擎接收该文件以及用于生成结果动态文本的数据。
- en: 'Now, let''s try to configure Freemarker to render our Fibonacci series. In
    order to use Freemarker for our view resolution, we must first add the required
    dependencies to our `build.gradle`, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试配置Freemarker以渲染我们的斐波那契数列。为了使用Freemarker进行视图解析，我们必须首先将所需的依赖项添加到我们的`build.gradle`中，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we added the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了以下内容：
- en: '`org.freemarker:freemarker`: The Freemarker template engine—at the time of
    writing this book, version 2.3.28 was the most recent version.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`org.freemarker:freemarker`：Freemarker模板引擎——在撰写本书时，版本2.3.28是最新的版本。'
- en: '`spring-context-support`: This provides the required integration between Freemarker
    and Spring. Since we have `spring-boot` configured, we need not specify the version
    of the `spring-context-support` dependency.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spring-context-support`：这提供了Freemarker和Spring之间所需的集成。由于我们已经配置了`spring-boot`，因此我们不需要指定`spring-context-support`依赖项的版本。'
- en: 'Now that we have added Freemarker, we have to configure it. The Spring context
    has a view resolver registry that must be updated to include Freemarker resolver,
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了Freemarker，我们必须对其进行配置。Spring上下文有一个视图解析器注册表，必须更新以包括Freemarker解析器，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we did the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Implemented the `WebFluxConfigurer` interface. The interface provides the `configureViewResolvers`
    method.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现了`WebFluxConfigurer`接口。该接口提供了`configureViewResolvers`方法。
- en: The `configureViewResolvers` is invoked by the Spring context, along with a
    `ViewResolverRegistry`. The registry provides the `freeMarker()` method to enable
    Freemarker—based resolution.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`configureViewResolvers`由Spring上下文调用，同时提供一个`ViewResolverRegistry`。该注册表提供了`freeMarker()`方法以启用基于Freemarker的解析。'
- en: Next, we have to create a `FreeMarkerConfigurer`, which can set Freemarker parameters.
    As shown in the preceding code, we configured the template path to `classpath:/freemarker/`.
    This will allow us to create Freemarker templates under the path `src/main/resources/freemarker`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个`FreeMarkerConfigurer`，它可以设置Freemarker参数。如前所述的代码所示，我们配置了模板路径为`classpath:/freemarker/`。这将允许我们在`src/main/resources/freemarker`路径下创建Freemarker模板。
- en: 'Now, let''s add a Freemarker template for showing the Fibonacci series. In
    this case, we would like to list the numbers as a simple HTML list, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个用于显示斐波那契数列的Freemarker模板。在这种情况下，我们希望将数字以简单的HTML列表形式列出，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding HTML template, we did the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的HTML模板中，我们做了以下操作：
- en: We added a `series` variable, containing a list of values.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`series`的变量，其中包含一个值列表。
- en: The `<#list> </#list>` syntax iterates through the list, providing individual
    values.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<#list> </#list>`语法遍历列表，提供单个值。'
- en: The value is then rendered in the `<li>` HTML tag.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值随后在`<li>` HTML标签中呈现。
- en: Now, save the file as `numbers.ftl`, under the `src/main/resources/freemarker`
    path.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将文件保存为`numbers.ftl`，位于`src/main/resources/freemarker`路径下。
- en: This book does not aim to cover Freemarker syntax. To learn more about it, please
    refer to the official Freemarker documentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标不是涵盖 Freemarker 语法。要了解更多信息，请参阅官方 Freemarker 文档。
- en: 'Now, the only configuration remaining is to use the template to render the
    Fibonacci series. First, let''s use this template in our annotation—based controller:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的唯一配置就是使用模板来渲染斐波那契序列。首先，让我们在我们的基于注解的控制器中使用此模板：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we did the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We added the `@controller` annotation, instead of `@RestContoller`. The `RestController`
    annotation only renders a JSON response. On the other hand, the `@controller`
    annotation allows us to render any kind of response.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了 `@controller` 注解，而不是 `@RestController`。`RestController` 注解仅渲染 JSON 响应。另一方面，`@controller`
    注解允许我们渲染任何类型的响应。
- en: We added `fibonacciGenerator(Flux<>)` to our model, as a `series` variable*.*
    This will provide the series value to the Freemarker template.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `fibonacciGenerator(Flux<>)` 添加到我们的模型中，作为 `series` 变量。这将提供系列值给 Freemarker
    模板。
- en: Next, we returned a `numbers` string as the return value. This will resolve
    to pick the `number.ftl` template.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们返回一个 `numbers` 字符串作为返回值。这将解析为选择 `number.ftl` 模板。
- en: 'Now, let''s run `ReactorMain` and hit `http://localhost:8080/numbers`. At this
    point, we will get back an HTML page listing the Fibonacci series, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `ReactorMain` 并访问 `http://localhost:8080/numbers`。在这个时候，我们将得到一个列出斐波那契序列的
    HTML 页面，如下所示：
- en: '![](img/e5ef1f0f-f009-4f13-b615-2fa47c65ca25.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5ef1f0f-f009-4f13-b615-2fa47c65ca25.png)'
- en: 'Now, let''s use the Freemarker view with our `HandlerFunction`. In order to
    do this, we have to change `ServerResponse`, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Freemarker 视图和我们的 `HandlerFunction`。为了做到这一点，我们必须更改 `ServerResponse`，如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we did the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Instead of building `ServerResponse.body`, we are now using the render API.
    This API takes a view name and an optional map of attributes.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在使用渲染 API 而不是构建 `ServerResponse.body`。此 API 接受一个视图名称和一个可选的属性映射。
- en: We provided the series values in the map by mapping the series key to the `fibonacciGenerator
    (Flux<>)`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将系列键映射到 `fibonacciGenerator (Flux<>)` 来在映射中提供系列值。
- en: Now, let's run `ReactorMain` and hit `http://localhost:8080/fibonacci`. At this
    point, we will get back the same HTML page listing the Fibonacci series.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `ReactorMain` 并访问 `http://localhost:8080/fibonacci`。在这个时候，我们将得到相同的列出斐波那契序列的
    HTML 页面。
- en: Thymeleaf
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thymeleaf
- en: Thymeleaf is a modem template engine that is based in Java and XML/HTML. It
    can be used to render any XML/HTML content. Templates built with Thymeleaf are
    of a natural order, meaning that they will render exactly how they are designed,
    unlike JSPs. This template engine is aimed at replacing JSPs. It has an excellent
    integration with Spring.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf 是一个基于 Java 和 XML/HTML 的现代模板引擎。它可以用来渲染任何 XML/HTML 内容。使用 Thymeleaf 构建的模板是自然顺序的，这意味着它们将按照设计的方式渲染，与
    JSP 不同。这个模板引擎旨在取代 JSP。它与 Spring 有很好的集成。
- en: 'Now, let''s try to configure Thymeleaf to render the Fibonacci series. In order
    to use Thymeleaf for view resolution, we must first add the required dependencies
    to our `build.gradle`, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试配置 Thymeleaf 来渲染斐波那契序列。为了使用 Thymeleaf 进行视图解析，我们必须首先在我们的 `build.gradle`
    中添加所需的依赖项，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we added the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了以下内容：
- en: '`spring-boot-starter-thymeleaf`: The Springboot starter imports the required
    Thymeleaf libraries. It also configures the Thymeleaf engine with predefined defaults.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-thymeleaf`: Springboot 启动器导入所需的 Thymeleaf 库。它还使用预定义的默认值配置了
    Thymeleaf 引擎。'
- en: 'Now that we have added Thymeleaf, we must enable it. The Spring context has
    a view resolver registry that must be updated to include the Thymeleaf resolver,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 Thymeleaf，我们必须启用它。Spring 上下文有一个视图解析器注册表，必须更新以包括 Thymeleaf 解析器，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we did the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Implemented the `WebFluxConfigurer` interface. This interface provides the `configureViewResolvers`
    method.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现了 `WebFluxConfigurer` 接口。此接口提供了 `configureViewResolvers` 方法。
- en: The `configureViewResolvers` method is invoked by the Spring context, along
    with a `ViewResolverRegistry`. We have to register a `ThymeleafReactiveViewResolver`
    with this.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`configureViewResolvers` 方法由 Spring 上下文调用，同时还有一个 `ViewResolverRegistry`。我们必须使用此方法注册一个
    `ThymeleafReactiveViewResolver`。'
- en: '`ThymeleafReactiveViewResolver` takes a `ISpringWebFluxTemplateEngine` engine,
    which is available with the Spring context.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ThymeleafReactiveViewResolver` 使用一个 `ISpringWebFluxTemplateEngine` 引擎，该引擎在
    Spring 上下文中可用。'
- en: The template engine looks for a template under `src/main/resources/templates`.
    It also adds a `.html` suffix to a template name before doing a lookup.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板引擎在 `src/main/resources/templates` 下查找模板。在查找之前，它还会在模板名称前添加一个 `.html` 后缀。
- en: 'Now, let''s add a Thymeleaf template to show the Fibonacci series. We would
    like to list the numbers as a simple HTML list, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个 Thymeleaf 模板来显示斐波那契数列。我们希望将数字作为简单的 HTML 列表列出，如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding HTML template, we did the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 HTML 模板中，我们做了以下操作：
- en: Added a `series` variable, containing a list of values.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个包含值的列表的 `series` 变量。
- en: Added `<li th:each></li>`, which iterates the series variable and renders individual
    elements.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了 `<li th:each></li>`，它遍历系列变量并渲染单个元素。
- en: Now, save the file as `numbers.html`, under the path `src/main/resources/templates`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将文件保存为 `numbers.html`，在路径 `src/main/resources/templates` 下。
- en: This book does not aim to cover the Thymeleaf syntax. Please refer to the official
    Thymeleaf documentation for that.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标不是涵盖 Thymeleaf 语法。请参阅官方 Thymeleaf 文档。
- en: 'Now, the only configuration left is to use the template to render the Fibonacci
    series. First, let''s use the template in our annotation—based controller approach:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的配置就是使用模板来渲染斐波那契数列。首先，让我们在我们的基于注解的控制器方法中使用模板：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we did the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We added the `@controller` annotation, instead of `@RestContoller`. The `RestController`
    annotation only renders a JSON response. On the other hand, the `@controller`
    annotation can render any kind of response.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了 `@controller` 注解，而不是 `@RestController`。`RestController` 注解仅渲染 JSON 响应。另一方面，`@controller`
    注解可以渲染任何类型的响应。
- en: We added `fibonacciGenerator(Flux<>)` to our model as a series. This will provide
    the series value to the Freemarker template.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `fibonacciGenerator(Flux<>)` 添加到我们的模型中作为一个系列。这将提供系列值给 Freemarker 模板。
- en: Next, we returned the `numbers` string as the return value. The returned value
    will map to the `number.html` template.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 `numbers` 字符串作为返回值。返回值将映射到 `number.html` 模板。
- en: 'Now, let''s run `ReactorMain` and open `http://localhost:8080/numbers`. At
    this point, we will get back an HTML page listing the Fibonacci series, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `ReactorMain` 并打开 `http://localhost:8080/numbers`。在此阶段，我们将得到一个列出斐波那契数列的
    HTML 页面，如下所示：
- en: '![](img/0e2bd3ce-e54e-4ffe-941d-08ec0e62d0bc.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e2bd3ce-e54e-4ffe-941d-08ec0e62d0bc.png)'
- en: 'Now, let''s use the Thymeleaf view with our `HandlerFunction`. In order to
    do this, we have to change `ServerResponse`, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Thymeleaf 视图与我们的 `HandlerFunction`。为了做到这一点，我们必须更改 `ServerResponse`，如下所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we did the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Instead of building `ServerResponse.body`, we are now using the render API.
    The API takes a view name and an optional map of attributes.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在使用渲染 API 而不是构建 `ServerResponse.body`。该 API 接受一个视图名称和一个可选的属性映射。
- en: We provided the series values in the map by mapping the series key to the `fibonacciGenerator
    (Flux<>)`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将系列键映射到 `fibonacciGenerator (Flux<>)` 来在映射中提供系列值。
- en: Now, let's run `ReactorMain` and open `http://localhost:8080/fibonacci`. At
    this point, we will get back the same HTML page that lists the Fibonacci series.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `ReactorMain` 并打开 `http://localhost:8080/fibonacci`。在此阶段，我们将得到与列出斐波那契数列相同的
    HTML 页面。
- en: Scripting
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'SpringWebFlux is also capable of using various scripting libraries for view
    ending. It uses the JSR-223 Java Scripting engine specification to integrate various
    scripting engines. At the time of writing this book, the following integrations
    are available:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SpringWebFlux 也能够使用各种脚本库进行视图结束。它使用 JSR-223 Java 脚本引擎规范来集成各种脚本引擎。在撰写本书时，以下集成是可用的：
- en: Handlebars, using the Nashrom engine
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Handlebars，使用 Nashrom 引擎
- en: Mustache, using the Nashrom engine
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mustache，使用 Nashrom 引擎
- en: React, using the Nashrom engine
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React，使用 Nashrom 引擎
- en: EJS, using the Nashrom engine
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJS，使用 Nashrom 引擎
- en: ERB, using the JRuby engine
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ERB，使用 JRuby 引擎
- en: String, using the Jython engine
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串，使用 Jython 引擎
- en: Kotlin, using the Kotlin engine
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin，使用 Kotlin 引擎
- en: In the following section, we will cover integration with Mustache. The integrations
    for the other options are similar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍与 Mustache 的集成。其他选项的集成类似。
- en: Mustache
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mustache
- en: Mustache is a simple template engine that is available in various languages.
    We will now use `Mustache.js`, the template engine in JavaScript. Mustache is
    often seen as logic-less, as it lacks explicit control flow statements. Control
    flow is achieved by using section tags.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache 是一个简单的模板引擎，在各种语言中都有可用。我们现在将使用 JavaScript 中的模板引擎 `Mustache.js`。Mustache
    通常被视为无逻辑的，因为它缺少显式的控制流语句。控制流是通过使用部分标签来实现的。
- en: Refer to [http://mustache.github.io/](http://mustache.github.io/) for more details
    about Mustache.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Mustache 的详细信息，请参阅 [http://mustache.github.io/](http://mustache.github.io/)。
- en: 'Now, let''s try to configure Mustache to render our Fibonacci series. We don''t
    need any other dependencies in our `build.gradle`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试配置 Mustache 来渲染我们的斐波那契数列。在我们的 `build.gradle` 文件中不需要任何其他依赖项：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Spring framework provides integration out of the box. The Spring context
    has a view resolver registry, which must be updated to include the `ScriptTemplate`
    resolver, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架提供了开箱即用的集成。Spring 上下文有一个视图解析器注册表，必须更新以包括 `ScriptTemplate` 解析器，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we did the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们做了以下操作：
- en: Implemented the `WebFluxConfigurer` interface. This interface provides the `configureViewResolvers`
    method.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了 `WebFluxConfigurer` 接口。该接口提供了 `configureViewResolvers` 方法。
- en: The `configureViewResolvers` method is invoked by the Spring context, along
    with `ViewResolverRegistry`. The registry provides the `scriptTemplate()` method
    to enable a scripting—based resolver.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configureViewResolvers` 方法由 Spring 上下文调用，同时还有 `ViewResolverRegistry`。该注册表提供了
    `scriptTemplate()` 方法来启用基于脚本的解析器。'
- en: Next, we must set parameters for `ScriptTempletConfigure`. The configurer needs
    to enable `Mustache.js`, and evaluate it using the Nashrom engine.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们必须为 `ScriptTempletConfigure` 设置参数。配置器需要启用 `Mustache.js`，并使用 Nashrom 引擎评估它。
- en: '`ScriptTempletConfigure` also specifies the location of the templates. In the
    preceding code, we configured the location as `src/main/resources/mustache`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScriptTempletConfigure` 还指定了模板的位置。在先前的代码中，我们将位置配置为 `src/main/resources/mustache`。'
- en: Since we are using `Mustache.js`, we also have to add `Mustache.js` (from [http://github.com/janl/mustache.js](http://github.com/janl/mustache.js))
    under the Mustache template location.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用 `Mustache.js`，我们还需要在 Mustache 模板位置下添加 `Mustache.js`（来自 [http://github.com/janl/mustache.js](http://github.com/janl/mustache.js)）。
- en: 'Now, let''s add a Mustache template to show the Fibonacci series. In this case,
    it would be beneficial to list the numbers as a simple HTML list, which is shown
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个 Mustache 模板来显示斐波那契数列。在这种情况下，将数字列表示为一个简单的 HTML 列表是有益的，如下所示：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding HTML template, the following has occurred:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 HTML 模板中，发生了以下情况：
- en: There is a `series` variable, containing a list of values.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个 `series` 变量，包含一系列值。
- en: The `{{#series}} {{/series}}` syntax iterates through the list, providing individual
    values.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{{#series}} {{/series}}` 语法遍历列表，提供单个值。'
- en: The value is then rendered by using the `{{.}}` syntax in an HTML `?div>` tag.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用 HTML `<div>` 标签中的 `{{.}}` 语法渲染该值。
- en: 'Now, save the file as `numbers.html`, under the `src/main/resources/mustache`
    path. The only configuration left is to use the `numbers.html` template to render
    the Fibonacci series. First, let''s use the `numbers.html` template in our annotation—based
    controller approach:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将文件保存为 `numbers.html`，位于 `src/main/resources/mustache` 路径下。剩下的唯一配置就是使用 `numbers.html`
    模板来渲染斐波那契数列。首先，让我们在我们的基于注解的控制器方法中使用 `numbers.html` 模板：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we did the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们做了以下操作：
- en: We added the `@controller` annotation, instead of `@RestContoller`. The `RestController`
    annotation only renders a JSON response. The `@controller` annotation, on the
    other hand, allows us to render any kind of response.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `@controller` 注解，而不是 `@RestController`。`RestController` 注解仅渲染 JSON 响应。另一方面，`@controller`
    注解允许我们渲染任何类型的响应。
- en: We added `fibonacciGenerator(Flux<>)` to our model as a `series`*.* This will
    provide the series value to the Mustache template.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在我们的模型中添加了 `fibonacciGenerator(Flux<>)` 作为 `series`*.* 这将为 Mustache 模板提供系列值。
- en: Next, we returned the `numbers.html` string as the returned value. The returned
    value will map to the `number.html` template. This is unlike the previous template
    engines, which automatically added a suffix to the returned string value to determine
    the template.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们返回了 `numbers.html` 字符串作为返回值。返回值将映射到 `number.html` 模板。这与之前的模板引擎不同，后者会自动在返回的字符串值后添加后缀，以确定模板。
- en: 'Now ,let''s run `ReactorMain` and hit `http://localhost:8080/numbers`. At this
    point, we will get back an HTML page that lists the Fibonacci series, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `ReactorMain` 并访问 `http://localhost:8080/numbers`。此时，我们将得到一个列出斐波那契数列的
    HTML 页面，如下所示：
- en: '![](img/8c211af7-3ec0-4da4-9b3c-31c50e0f5382.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c211af7-3ec0-4da4-9b3c-31c50e0f5382.png)'
- en: 'Now, let''s use the Mustache view with our `HandlerFunction`. In order to do
    this, we have to change `ServerResponse`, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Mustache 视图与我们的 `HandlerFunction` 结合。为了做到这一点，我们必须更改 `ServerResponse`，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we did the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Instead of building `ServerRespose.body`, we are now using the render API. The
    API takes a view name and an optional map of attributes.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在不是构建 `ServerRespose.body`，而是使用渲染 API。该 API 接受一个视图名称和一个可选的属性映射。
- en: We provided the series values in the map by mapping the series key to the `fibonacciGenerator
    (Flux<>)`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将序列键映射到 `fibonacciGenerator (Flux<>)` 来在映射中提供了序列值。
- en: Now ,let's run `ReactorMain` and hit `http://localhost:8080/fibonacci`. In response,
    we will get the same HTML page listing the Fibonacci series.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `ReactorMain` 并访问 `http://localhost:8080/fibonacci`。作为响应，我们将得到一个列出斐波那契数列的相同
    HTML 页面。
- en: Learning about static resources
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习静态资源
- en: 'A dynamic application often has static parts as well. SpringWebFlux also enables
    us to configure static resources. Let''s suppose that we want to use `bootstrap.css`
    in our Thymeleaf application. In order to do this, we have to enable the server
    to determine the static content. This can be configured as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动态应用程序通常也有静态部分。SpringWebFlux 也使我们能够配置静态资源。假设我们想在我们的 Thymeleaf 应用程序中使用 `bootstrap.css`。为了做到这一点，我们必须启用服务器来确定静态内容。这可以配置如下：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, the following has occurred:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了以下情况：
- en: The `addResourceHandler` method takes a URL pattern and configures it to be
    static locations which must be served by the server. In the preceding code, all
    of our static URLs should look like `like/resources/XXXX`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addResourceHandler` 方法接受一个 URL 模式，并将其配置为静态位置，这些位置必须由服务器提供服务。在前面的代码中，我们所有的静态
    URL 应该看起来像 `like/resources/XXXX`。'
- en: The `addResourceLocations` method configures a location from which the static
    content must be served. In the preceding code, we have configured the location
    as `src/main/resources/static`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addResourceLocations` 方法配置了一个必须从其中提供静态内容的位置。在前面的代码中，我们已经将位置配置为 `src/main/resources/static`。'
- en: 'Now, let''s download `bootstrap.css` to `src/main/resources/static`. This will
    be served on `/resources/bootstrap.min.css`. The only thing left to do is to include
    the `css` in our `numbers.html` Thymeleaf template, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `bootstrap.css` 下载到 `src/main/resources/static`。这将服务于 `/resources/bootstrap.min.css`。剩下要做的就是将
    `css` 包含在我们的 `numbers.html` Thymeleaf 模板中，如下所示：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, the following has occurred:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了以下情况：
- en: The `<link rel="stylesheet"../>` will include the `css` from our server.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<link rel="stylesheet"../>` 将包含来自我们服务器的 `css`。'
- en: We have used a `container`, as well as `list-group` and `list-group-item` classes
    from Bootstrap, for our html elements.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了 `container` 以及来自 Bootstrap 的 `list-group` 和 `list-group-item` 类来为我们的 HTML
    元素提供样式。
- en: 'Now, run the server and open `http://localhost:8080/numbers`. The page is now
    formatted with a Bootstrap grid, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行服务器并打开 `http://localhost:8080/numbers`。页面现在使用 Bootstrap 网格格式化，如下所示：
- en: '![](img/32eafbc7-d821-4444-93ae-8c22d5cf26b2.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32eafbc7-d821-4444-93ae-8c22d5cf26b2.png)'
- en: The `ResourceHandlerRegistry` also enables us to configure cache control headers.
    It can also be used to build a chain of resolvers that can resolve `.gz` static
    resources and versioned resources.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceHandlerRegistry` 还使我们能够配置缓存控制头。它还可以用于构建可以解析 `.gz` 静态资源和版本化资源的解析器链。'
- en: WebClient
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebClient
- en: The SpringWebFlux framework also provides a non-blocking, asynchronous HTTP
    client for making requests. **WebClient** offers APIs that can be configured with
    Java 8 lambdas, for processing data. At the backend, the WebClient API configures
    Netty to perform the asynchronous, non-blocking communication. Now, let's look
    at how we can use WebClient in our applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SpringWebFlux 框架还提供了一个非阻塞、异步 HTTP 客户端来发送请求。**WebClient** 提供了可以配置为 Java 8 lambdas
    的 API，用于处理数据。在后台，WebClient API 配置 Netty 执行异步、非阻塞通信。现在，让我们看看我们如何在应用程序中使用 WebClient。
- en: 'WebClient offers the following two methods for consuming data:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: WebClient 提供以下两种方法来消费数据：
- en: '`Retrieve`: This is the simplest method, which decodes the body into a Flux
    or Mono.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`检索`：这是最简单的方法，它将主体解码为 Flux 或 Mono。'
- en: '`Exchange`: If we are interested in the response received, the `exchange` method
    is suited for this purpose. It provides the complete message, which can be converted
    back to a target type. Consider the following code for this:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange`: 如果我们对收到的响应感兴趣，`exchange` 方法适合此目的。它提供了完整的消息，可以将其转换回目标类型。考虑以下代码示例：'
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we built the WebClient to read the Fibonacci series
    response. This code achieved the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了 WebClient 来读取斐波那契数列响应。此代码实现了以下功能：
- en: 'It created an instance of WebClient for the following location: `http://localhost:8080`.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为以下位置创建了一个 WebClient 实例：`http://localhost:8080`。
- en: The client makes an HTTP `GET` to `/fibonacci`, with the required `JSON ACCEPT`
    header.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向 `/fibonacci` 发送一个 HTTP `GET` 请求，并带有所需的 `JSON ACCEPT` 头部。
- en: It then invokes the `retrieve` method and converts the body to a `Flux<Long>`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它调用 `retrieve` 方法，并将正文转换为 `Flux<Long>`。
- en: In the end, we subscribe to the Flux and print the numbers to the console.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们订阅了 Flux 并将数字打印到控制台。
- en: 'The same Fibonacci series can be processed using the `exchange` method, as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `exchange` 方法处理相同的斐波那契数列，如下所示：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following are the key differences between the `exchange` method and the
    `retrieve` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `exchange` 方法与 `retrieve` 方法之间的关键差异：
- en: The exchange method provides a `Mono<ClientResponse>`. This must be converted
    to a Flux by using the `flatMapMany` API.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exchange` 方法提供了一个 `Mono<ClientResponse>`。这必须使用 `flatMapMany` API 转换为 Flux。'
- en: We process the response body and transform it into a `Flux<Long>`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们处理响应体并将其转换为 `Flux<Long>`。
- en: In addition to the differences stated in the preceding points, the `retrieve`
    method provides a convenient `onStatus` API. This method is used to invoke functions
    on the specified HTTP status code. On the other hand, in the `exchange` method,
    we get the complete response, so it is up to the developer to read the HTTP status
    code and invoke the required logic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的差异之外，`retrieve` 方法还提供了一个方便的 `onStatus` API。此方法用于在指定的 HTTP 状态码上调用函数。另一方面，在
    `exchange` 方法中，我们获取完整的响应，因此开发者需要读取 HTTP 状态码并调用所需的逻辑。
- en: 'WebClient can be used to invoke HTTP `GET`, `PUT`, `POST`, `DELETE`, `PATCH`,
    and `HEAD` methods. When using `POST`, we often have to add a request body. This
    is done by invoking the `body()` API, available with the `PUT` method. The API
    takes a Mono or a Flux of a specified type. Alternatively, if there is an object
    available, it can be processed by using the `syncBody()` method. The WebClient
    API also offers the following methods to configure a request:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: WebClient 可以用来调用 HTTP `GET`、`PUT`、`POST`、`DELETE`、`PATCH` 和 `HEAD` 方法。当使用 `POST`
    时，我们通常需要添加一个请求体。这是通过调用 `PUT` 方法中可用的 `body()` API 来完成的。该 API 接受指定类型的 Mono 或 Flux。或者，如果有可用的对象，可以使用
    `syncBody()` 方法进行处理。WebClient API 还提供了以下方法来配置请求：
- en: '`accepts`: Configures the `accepts request` header with the specified content
    type'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accepts`: 使用指定的内容类型配置 `accepts request` 头'
- en: '`acceptCharset`: Configures the `accepts-charset` request header'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acceptCharset`: 配置 `accepts-charset` 请求头'
- en: '`header(s)`: Configures the specified header(s) with the specified value(s)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header(s)`: 使用指定的值配置指定的头（s）'
- en: '`attributes`: Adds the specified attributes to the request'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`: 向请求添加指定的属性'
- en: '`cookies`: Adds a `cookies` header to the request'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookies`: 向请求添加 `cookies` 头'
- en: The WebClient also provides a builder, which can be used to build a WebClient
    for the settings provided. This can be used to instantiate a client as a specific
    SSL context, or with default headers. The builder configuration is applied to
    the created instance of WebClient, and is thus invoked for every call we make
    using the instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: WebClient 还提供了一个构建器，可以用来根据提供的设置构建 WebClient。这可以用来实例化一个客户端，作为特定的 SSL 上下文，或者使用默认的头。构建器配置应用于创建的
    WebClient 实例，因此对于使用该实例进行的每个调用都会调用它。
- en: 'SpringWebFlux also provides `WebTestClient`, which is an extension of WebClient,
    along with assertions to validate the response body and response status. The class
    can be instantiated in a manner similar to WebClient. After making a request using
    the `exchange` method, the response can be asserted by using the following methods:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: SpringWebFlux 还提供了 `WebTestClient`，它是 WebClient 的扩展，并附带断言来验证响应体和响应状态。该类可以以类似于
    WebClient 的方式实例化。在通过 `exchange` 方法发出请求后，可以使用以下方法进行断言：
- en: '`expectStatus()`: This method can validate response status codes, such as `OK`
    and `NOT_FOUND`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectStatus()`: 此方法可以验证响应状态码，例如 `OK` 和 `NOT_FOUND`。'
- en: '`expectHeader()`: This method can validate response headers, such as `MediaType`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectHeader()`: 此方法可以验证响应头，例如 `MediaType`。'
- en: '`expectBody(class)`: This method can validate whether the response body can
    be converted to a specified class.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectBody(class)`: 此方法可以验证响应体是否可以转换为指定的类。'
- en: '`expectBodyList(class)`: This method can validate whether the response body
    can be converted to a list of specified class objects. Post conversion, it can
    validate the list size and the list objects.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectBodyList(class)`: 此方法可以验证响应体是否可以转换为指定类对象的列表。转换后，它可以验证列表大小和列表对象。'
- en: '`WebTestClient` can be used to test and validate a `SpringWebFlux` application.
    `WebTestClient` provides different `bindXXX` methods, which can be used to configure
    a `WebTestClient` for an `ApplicationContext`, URL, controller, router function,
    and so on. It can then perform invocations against the configured resource, and
    validate the response.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTestClient` 可以用来测试和验证 `SpringWebFlux` 应用程序。`WebTestClient` 提供不同的 `bindXXX`
    方法，这些方法可以用来配置 `WebTestClient` 以适用于 `ApplicationContext`、URL、控制器、路由函数等。然后它可以对配置的资源进行调用，并验证响应。'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to render dynamic content, using the various
    template engines available with SpringWebFlux. We integrated Java-based template
    engines, Freemarker, and Thymeleaf. We also looked at how to enable a scripting-based
    engine, and how to work with Mustache.js. Next, we looked at serving static content
    by using `SpringWebFlux`. In the end, we discussed using WebClient to make asynchronous,
    non-blocking HTTP requests. We are now generating events and processing them.
    In the next chapter we will discuss ways to perform flow-control and backpressure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用 SpringWebFlux 可用的各种模板引擎来渲染动态内容。我们集成了基于 Java 的模板引擎、Freemarker
    和 Thymeleaf。我们还探讨了如何启用基于脚本的引擎，以及如何与 Mustache.js 一起工作。接下来，我们研究了如何使用 `SpringWebFlux`
    来提供静态内容。最后，我们讨论了使用 WebClient 来进行异步、非阻塞的 HTTP 请求。我们现在正在生成事件并处理它们。在下一章中，我们将讨论执行流控制和背压的方法。
- en: Questions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does the `SpringWebFlux` framework resolve a view?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpringWebFlux` 框架是如何解析视图的？'
- en: What components are configured to use the Thymeleaf template engine?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些组件被配置为使用 Thymeleaf 模板引擎？
- en: What API is used to configure static resources in SpringWebFlux?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SpringWebFlux 中，使用哪个 API 来配置静态资源？
- en: What are the benefits of WebClient?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebClient 有哪些好处？
- en: What is the difference between the retrieve and exchange WebClient APIs?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索和交换 WebClient API 之间的区别是什么？
