- en: Dynamic Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we worked with SpringWebFlux to build simple web services.
    So far, we have built RESTful web services, which return JSON responses. However,
    SpringWebFlux is not limited to RESTful web services; it is a complete web framework
    that offers the capability to build dynamic web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: View templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebClient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Standard Edition, JDK 8 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA IDE, 2018.1 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: View templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpringWebFlux offers a number of options for rendering views, using various
    technology platforms. Whatever choice we make, the framework employs the same
    view resolution process, allowing us to arrive at the correct view. The view can
    then be rendered by using any of the supported technologies. In this section,
    we will cover the complete process of rendering views using SpringWebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**View resolution** is a process used by the framework to determine which view
    needs to be rendered for a received request. The complete view resolution process
    enables us to render different views for the same requests, based on content parameters.
    Before we start to build different views, let''s discuss how the framework determines
    what view it needs to render.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we configured `HandlerFunction` for handling requests.
    This function gives back a `HandlerResult`. The `HandlerResult` contains not only
    the result, but also the attributes passed into the request. The framework then
    invokes `ViewResolutionResultHandler`, using the `HandlerResult`. The `ViewResolutionResultHandler`
    determines the correct view by validating the values returned for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**String**: If the value returned is a string, then the framework builds a
    view using the configured `ViewResolvers`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Void**: If nothing is returned, it tries to build the default view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map**: The framework looks for the default view, but it also adds the key
    values returned to the request model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ViewResolutionResultHandler` also looks up the content type passed in the
    request. In order to determine what view should be used, it compares the content
    type passed to the content type supported by the `ViewResolver`. It then selects
    the first `ViewResolver` that supports the request's content type.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a request can redirect to another request. In order
    to do this, we prefix the `redirect:` keyword before the view name. The framework
    then uses a `UrlBasedViewResolver` and returns a URL for redirection. If the returned
    URL is from the same application, then the path can be built in a relative manner
    (for example, `redirect:/applicationA/locationA`). If the returned URL is from
    an external location, then the view name can be built using an absolute URL (for
    example, `redirect:http://www.google.com/search/`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the view resolution process works, let's try to build
    dynamic views by using the various supported template frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Freemarker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Freemarker is a template engine that can be used to generate dynamic HTML output.
    It is not limited to HTML pages; it can generate any kind of text output, such
    as emails, and reports. In order to use this, we have to write a template file
    using the Freemarker syntax. The Freemarker engine then receives the file, along
    with data to generate the resulting dynamic text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to configure Freemarker to render our Fibonacci series. In
    order to use Freemarker for our view resolution, we must first add the required
    dependencies to our `build.gradle`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.freemarker:freemarker`: The Freemarker template engine—at the time of
    writing this book, version 2.3.28 was the most recent version.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spring-context-support`: This provides the required integration between Freemarker
    and Spring. Since we have `spring-boot` configured, we need not specify the version
    of the `spring-context-support` dependency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have added Freemarker, we have to configure it. The Spring context
    has a view resolver registry that must be updated to include Freemarker resolver,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implemented the `WebFluxConfigurer` interface. The interface provides the `configureViewResolvers`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `configureViewResolvers` is invoked by the Spring context, along with a
    `ViewResolverRegistry`. The registry provides the `freeMarker()` method to enable
    Freemarker—based resolution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have to create a `FreeMarkerConfigurer`, which can set Freemarker parameters.
    As shown in the preceding code, we configured the template path to `classpath:/freemarker/`.
    This will allow us to create Freemarker templates under the path `src/main/resources/freemarker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s add a Freemarker template for showing the Fibonacci series. In
    this case, we would like to list the numbers as a simple HTML list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding HTML template, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We added a `series` variable, containing a list of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `<#list> </#list>` syntax iterates through the list, providing individual
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value is then rendered in the `<li>` HTML tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, save the file as `numbers.ftl`, under the `src/main/resources/freemarker`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: This book does not aim to cover Freemarker syntax. To learn more about it, please
    refer to the official Freemarker documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the only configuration remaining is to use the template to render the
    Fibonacci series. First, let''s use this template in our annotation—based controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We added the `@controller` annotation, instead of `@RestContoller`. The `RestController`
    annotation only renders a JSON response. On the other hand, the `@controller`
    annotation allows us to render any kind of response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added `fibonacciGenerator(Flux<>)` to our model, as a `series` variable*.*
    This will provide the series value to the Freemarker template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we returned a `numbers` string as the return value. This will resolve
    to pick the `number.ftl` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s run `ReactorMain` and hit `http://localhost:8080/numbers`. At this
    point, we will get back an HTML page listing the Fibonacci series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5ef1f0f-f009-4f13-b615-2fa47c65ca25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s use the Freemarker view with our `HandlerFunction`. In order to
    do this, we have to change `ServerResponse`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of building `ServerResponse.body`, we are now using the render API.
    This API takes a view name and an optional map of attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We provided the series values in the map by mapping the series key to the `fibonacciGenerator
    (Flux<>)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's run `ReactorMain` and hit `http://localhost:8080/fibonacci`. At this
    point, we will get back the same HTML page listing the Fibonacci series.
  prefs: []
  type: TYPE_NORMAL
- en: Thymeleaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thymeleaf is a modem template engine that is based in Java and XML/HTML. It
    can be used to render any XML/HTML content. Templates built with Thymeleaf are
    of a natural order, meaning that they will render exactly how they are designed,
    unlike JSPs. This template engine is aimed at replacing JSPs. It has an excellent
    integration with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to configure Thymeleaf to render the Fibonacci series. In order
    to use Thymeleaf for view resolution, we must first add the required dependencies
    to our `build.gradle`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-boot-starter-thymeleaf`: The Springboot starter imports the required
    Thymeleaf libraries. It also configures the Thymeleaf engine with predefined defaults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have added Thymeleaf, we must enable it. The Spring context has
    a view resolver registry that must be updated to include the Thymeleaf resolver,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implemented the `WebFluxConfigurer` interface. This interface provides the `configureViewResolvers`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `configureViewResolvers` method is invoked by the Spring context, along
    with a `ViewResolverRegistry`. We have to register a `ThymeleafReactiveViewResolver`
    with this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ThymeleafReactiveViewResolver` takes a `ISpringWebFluxTemplateEngine` engine,
    which is available with the Spring context.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The template engine looks for a template under `src/main/resources/templates`.
    It also adds a `.html` suffix to a template name before doing a lookup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s add a Thymeleaf template to show the Fibonacci series. We would
    like to list the numbers as a simple HTML list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding HTML template, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Added a `series` variable, containing a list of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Added `<li th:each></li>`, which iterates the series variable and renders individual
    elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, save the file as `numbers.html`, under the path `src/main/resources/templates`.
  prefs: []
  type: TYPE_NORMAL
- en: This book does not aim to cover the Thymeleaf syntax. Please refer to the official
    Thymeleaf documentation for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the only configuration left is to use the template to render the Fibonacci
    series. First, let''s use the template in our annotation—based controller approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We added the `@controller` annotation, instead of `@RestContoller`. The `RestController`
    annotation only renders a JSON response. On the other hand, the `@controller`
    annotation can render any kind of response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added `fibonacciGenerator(Flux<>)` to our model as a series. This will provide
    the series value to the Freemarker template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we returned the `numbers` string as the return value. The returned value
    will map to the `number.html` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s run `ReactorMain` and open `http://localhost:8080/numbers`. At
    this point, we will get back an HTML page listing the Fibonacci series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e2bd3ce-e54e-4ffe-941d-08ec0e62d0bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s use the Thymeleaf view with our `HandlerFunction`. In order to
    do this, we have to change `ServerResponse`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of building `ServerResponse.body`, we are now using the render API.
    The API takes a view name and an optional map of attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We provided the series values in the map by mapping the series key to the `fibonacciGenerator
    (Flux<>)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's run `ReactorMain` and open `http://localhost:8080/fibonacci`. At
    this point, we will get back the same HTML page that lists the Fibonacci series.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SpringWebFlux is also capable of using various scripting libraries for view
    ending. It uses the JSR-223 Java Scripting engine specification to integrate various
    scripting engines. At the time of writing this book, the following integrations
    are available:'
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars, using the Nashrom engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mustache, using the Nashrom engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React, using the Nashrom engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EJS, using the Nashrom engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERB, using the JRuby engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String, using the Jython engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin, using the Kotlin engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will cover integration with Mustache. The integrations
    for the other options are similar.
  prefs: []
  type: TYPE_NORMAL
- en: Mustache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mustache is a simple template engine that is available in various languages.
    We will now use `Mustache.js`, the template engine in JavaScript. Mustache is
    often seen as logic-less, as it lacks explicit control flow statements. Control
    flow is achieved by using section tags.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [http://mustache.github.io/](http://mustache.github.io/) for more details
    about Mustache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to configure Mustache to render our Fibonacci series. We don''t
    need any other dependencies in our `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring framework provides integration out of the box. The Spring context
    has a view resolver registry, which must be updated to include the `ScriptTemplate`
    resolver, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implemented the `WebFluxConfigurer` interface. This interface provides the `configureViewResolvers`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `configureViewResolvers` method is invoked by the Spring context, along
    with `ViewResolverRegistry`. The registry provides the `scriptTemplate()` method
    to enable a scripting—based resolver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we must set parameters for `ScriptTempletConfigure`. The configurer needs
    to enable `Mustache.js`, and evaluate it using the Nashrom engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScriptTempletConfigure` also specifies the location of the templates. In the
    preceding code, we configured the location as `src/main/resources/mustache`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are using `Mustache.js`, we also have to add `Mustache.js` (from [http://github.com/janl/mustache.js](http://github.com/janl/mustache.js))
    under the Mustache template location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s add a Mustache template to show the Fibonacci series. In this case,
    it would be beneficial to list the numbers as a simple HTML list, which is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding HTML template, the following has occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a `series` variable, containing a list of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `{{#series}} {{/series}}` syntax iterates through the list, providing individual
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value is then rendered by using the `{{.}}` syntax in an HTML `?div>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, save the file as `numbers.html`, under the `src/main/resources/mustache`
    path. The only configuration left is to use the `numbers.html` template to render
    the Fibonacci series. First, let''s use the `numbers.html` template in our annotation—based
    controller approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We added the `@controller` annotation, instead of `@RestContoller`. The `RestController`
    annotation only renders a JSON response. The `@controller` annotation, on the
    other hand, allows us to render any kind of response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added `fibonacciGenerator(Flux<>)` to our model as a `series`*.* This will
    provide the series value to the Mustache template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we returned the `numbers.html` string as the returned value. The returned
    value will map to the `number.html` template. This is unlike the previous template
    engines, which automatically added a suffix to the returned string value to determine
    the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now ,let''s run `ReactorMain` and hit `http://localhost:8080/numbers`. At this
    point, we will get back an HTML page that lists the Fibonacci series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c211af7-3ec0-4da4-9b3c-31c50e0f5382.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s use the Mustache view with our `HandlerFunction`. In order to do
    this, we have to change `ServerResponse`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of building `ServerRespose.body`, we are now using the render API. The
    API takes a view name and an optional map of attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We provided the series values in the map by mapping the series key to the `fibonacciGenerator
    (Flux<>)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now ,let's run `ReactorMain` and hit `http://localhost:8080/fibonacci`. In response,
    we will get the same HTML page listing the Fibonacci series.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about static resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A dynamic application often has static parts as well. SpringWebFlux also enables
    us to configure static resources. Let''s suppose that we want to use `bootstrap.css`
    in our Thymeleaf application. In order to do this, we have to enable the server
    to determine the static content. This can be configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following has occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: The `addResourceHandler` method takes a URL pattern and configures it to be
    static locations which must be served by the server. In the preceding code, all
    of our static URLs should look like `like/resources/XXXX`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `addResourceLocations` method configures a location from which the static
    content must be served. In the preceding code, we have configured the location
    as `src/main/resources/static`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s download `bootstrap.css` to `src/main/resources/static`. This will
    be served on `/resources/bootstrap.min.css`. The only thing left to do is to include
    the `css` in our `numbers.html` Thymeleaf template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following has occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<link rel="stylesheet"../>` will include the `css` from our server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have used a `container`, as well as `list-group` and `list-group-item` classes
    from Bootstrap, for our html elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the server and open `http://localhost:8080/numbers`. The page is now
    formatted with a Bootstrap grid, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32eafbc7-d821-4444-93ae-8c22d5cf26b2.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ResourceHandlerRegistry` also enables us to configure cache control headers.
    It can also be used to build a chain of resolvers that can resolve `.gz` static
    resources and versioned resources.
  prefs: []
  type: TYPE_NORMAL
- en: WebClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SpringWebFlux framework also provides a non-blocking, asynchronous HTTP
    client for making requests. **WebClient** offers APIs that can be configured with
    Java 8 lambdas, for processing data. At the backend, the WebClient API configures
    Netty to perform the asynchronous, non-blocking communication. Now, let's look
    at how we can use WebClient in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebClient offers the following two methods for consuming data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Retrieve`: This is the simplest method, which decodes the body into a Flux
    or Mono.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchange`: If we are interested in the response received, the `exchange` method
    is suited for this purpose. It provides the complete message, which can be converted
    back to a target type. Consider the following code for this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we built the WebClient to read the Fibonacci series
    response. This code achieved the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It created an instance of WebClient for the following location: `http://localhost:8080`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client makes an HTTP `GET` to `/fibonacci`, with the required `JSON ACCEPT`
    header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then invokes the `retrieve` method and converts the body to a `Flux<Long>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, we subscribe to the Flux and print the numbers to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The same Fibonacci series can be processed using the `exchange` method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the key differences between the `exchange` method and the
    `retrieve` method:'
  prefs: []
  type: TYPE_NORMAL
- en: The exchange method provides a `Mono<ClientResponse>`. This must be converted
    to a Flux by using the `flatMapMany` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We process the response body and transform it into a `Flux<Long>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the differences stated in the preceding points, the `retrieve`
    method provides a convenient `onStatus` API. This method is used to invoke functions
    on the specified HTTP status code. On the other hand, in the `exchange` method,
    we get the complete response, so it is up to the developer to read the HTTP status
    code and invoke the required logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebClient can be used to invoke HTTP `GET`, `PUT`, `POST`, `DELETE`, `PATCH`,
    and `HEAD` methods. When using `POST`, we often have to add a request body. This
    is done by invoking the `body()` API, available with the `PUT` method. The API
    takes a Mono or a Flux of a specified type. Alternatively, if there is an object
    available, it can be processed by using the `syncBody()` method. The WebClient
    API also offers the following methods to configure a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accepts`: Configures the `accepts request` header with the specified content
    type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`acceptCharset`: Configures the `accepts-charset` request header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header(s)`: Configures the specified header(s) with the specified value(s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributes`: Adds the specified attributes to the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookies`: Adds a `cookies` header to the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WebClient also provides a builder, which can be used to build a WebClient
    for the settings provided. This can be used to instantiate a client as a specific
    SSL context, or with default headers. The builder configuration is applied to
    the created instance of WebClient, and is thus invoked for every call we make
    using the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'SpringWebFlux also provides `WebTestClient`, which is an extension of WebClient,
    along with assertions to validate the response body and response status. The class
    can be instantiated in a manner similar to WebClient. After making a request using
    the `exchange` method, the response can be asserted by using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expectStatus()`: This method can validate response status codes, such as `OK`
    and `NOT_FOUND`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectHeader()`: This method can validate response headers, such as `MediaType`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectBody(class)`: This method can validate whether the response body can
    be converted to a specified class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectBodyList(class)`: This method can validate whether the response body
    can be converted to a list of specified class objects. Post conversion, it can
    validate the list size and the list objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebTestClient` can be used to test and validate a `SpringWebFlux` application.
    `WebTestClient` provides different `bindXXX` methods, which can be used to configure
    a `WebTestClient` for an `ApplicationContext`, URL, controller, router function,
    and so on. It can then perform invocations against the configured resource, and
    validate the response.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to render dynamic content, using the various
    template engines available with SpringWebFlux. We integrated Java-based template
    engines, Freemarker, and Thymeleaf. We also looked at how to enable a scripting-based
    engine, and how to work with Mustache.js. Next, we looked at serving static content
    by using `SpringWebFlux`. In the end, we discussed using WebClient to make asynchronous,
    non-blocking HTTP requests. We are now generating events and processing them.
    In the next chapter we will discuss ways to perform flow-control and backpressure.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does the `SpringWebFlux` framework resolve a view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What components are configured to use the Thymeleaf template engine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What API is used to configure static resources in SpringWebFlux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of WebClient?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the retrieve and exchange WebClient APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
