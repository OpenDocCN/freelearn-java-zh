- en: Chapter 8. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we deal with an integration project, testing is vital to ensure that your
    logic works as expected. This means testing the different routing logic, and managing
    the errors that can happen during the routing.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, an integration project means that we use services or endpoints provided
    by different teams or third parties. Instead of waiting for the services and endpoints
    provided by the team, we can begin to implement our project by mocking the dependency
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can distinguish two kinds of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are focused on testing your routing logic. Basically, it tests the
    behaviors of your routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests are more dedicated to the installation and deployment of your
    routes in a container. These tests depend on the runtime container that you use
    to run your Camel routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Camel provides the tool to easily implement unit tests—it's called a
    Camel test kit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce:'
  prefs: []
  type: TYPE_NORMAL
- en: The unit test approach and how to use the different modules provided by the
    test kit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to bootstrap integration tests in the special case of Apache Karaf and OSGi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test approach with the Camel test kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a unit test basically means you bootstrap your routes—you load
    `CamelContext` and routes in the tests, and it is ready to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now define the endpoints that you want to mock, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the mocked endpoints, you define assertions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and *inject* exchanges at some points of the routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the assertions are verified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Camel provides different test kits, depending on the DSL that you use to write
    your routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`camel-test` is the core and abstract test kit that you can use if you use
    the Java DSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-test-spring` extends `camel-test`, providing support for the Spring
    DSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-test-blueprint` extends `camel-test` as well, and provides support for
    the Blueprint DSL. Additionally, it also provides an OSGi like service support
    leveraging iPOJO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All Camel test kits provide:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit extensions: JUnit is the most commonly adopted unit test framework for
    Java, and is freely available. Instead of reinventing the wheel, Camel directly
    provides JUnit extensions. This means that your unit test classes will extend
    the Camel JUnit extensions, and you will be able to use the JUnit annotations
    (like `@Test` for instance).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mock component: The mock component is provided directly by `camel-core`. The
    mock component provides a powerful declarative testing mechanism, and can be used
    *on top of* actual components. The declarative expectations can be created on
    any mock endpoint, before the test begins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ProducerTemplate: The `ProducerTemplate` is provided by the Camel Test base
    classes (or the `CamelContext`). It''s a convenient feature that allows you to
    easily create exchanges, and set messages, which you send on the route endpoint
    of your choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ProducerTemplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ProducerTemplate` is a template that provides an easy way to create messages
    in Camel. It allows you to send message instances in an exchange to an endpoint.
    It supports various communication styles—`InOnly`, `InOut`, `Sync`, `Async`, and
    `Callback`. You can get `ProducerTemplate` from the `CamelContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In unit test, as soon as your test class extends to one of the Camel test base
    classes, you have `producerTemplate` ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the producer template can create a message, set the body of the
    `in` message and send it to the `direct:input` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the body of the `in` message, it''s also possible to set a header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `sendBody()` method also accepts a `MessageExchangePattern` argument (if
    you want to simulate the `InOnly` or `InOut` exchange).
  prefs: []
  type: TYPE_NORMAL
- en: When using `InOut`, you might want to get the `out` message after the exchange
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, you have to use the `requestBody()` method on the `producerTemplate`
    instead of `sendBody()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: JUnit extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Camel directly provides classes that you have to extend in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: CamelTestSupport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CamelTestSupport` is the class that you have to extend if you use the Java
    DSL.'
  prefs: []
  type: TYPE_NORMAL
- en: You have to override the `createRouteBuilder()` method. This is where you actually
    bootstrap the route, by calling the `createRouteBuilder()` method defined in your
    route class.
  prefs: []
  type: TYPE_NORMAL
- en: You also have to override the `isMockEndpoints()` or `isMockEndpointsAndSkip()`
    method. This method returns a regular expression—all endpoint URIs matching this
    `regex` will be mocked by the mock component. The `isMockEndpoints()` and `isMockEndpointsAndSkip()`
    methods are the same, but the skip one doesn't send the exchange to the actual
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to create the methods with the `@Test` annotation. These methods
    are the actual tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: CamelSpringTestSupport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CamelSpringTestSupport` is the class that your test class has to extend if
    you use the Spring DSL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly the same as the `CamelTestSupport` class. The only difference
    is that, instead of overriding the `createRouteBuilder()` method, you have to
    override the `createApplicationContext()` method. The `createApplicationContext()`
    method actually directly loads your Spring XML file containing your route definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: CamelBlueprintTestSupport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CamelBlueprintTestSupport` is the class that you have to extend if you use
    the Blueprint DSL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very similar to the `CamelSpringTestSupport` class, but instead of
    the `createApplicationContext()` method, you have to override the `getBlueprintDescriptor()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also override the `addServicesOnStartup()` method, if you want to *fake*
    some OSGi services used in your route blueprint XML.
  prefs: []
  type: TYPE_NORMAL
- en: The mock component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mock component is provided by `camel-core`. It means that you can explicitly
    create mock endpoints with the `mock:name` URI. However, where it really makes
    sense to use the mock component is in unit tests—it's a cornerstone there.
  prefs: []
  type: TYPE_NORMAL
- en: Like a crash test dummy, the mock component is used to simulate real components
    and fake the actual endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Without the mock component, you would have to use the real components and endpoints,
    which is not always possible in tests. Moreover, when testing, you need to apply
    assertions to see if the result is as expected—we can use the mock component for
    that easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mock component is an answer to the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The real component or endpoint doesn't exist yet. For instance, you want to
    call a web service developed by another team. Unfortunately, the web service is
    not yet ready. In that case, you can fake the web service using the mock component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real component is not easy or takes time to bootstrap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real component is difficult to set up. Some components are difficult to
    set up, or require other applications that are difficult to set up, for instance,
    when you use the `camel-hbase` component in your route. This component uses an
    HBase instance running, meaning a running ZooKeeper and a running Hadoop HDFS
    cluster. It doesn't really make sense to actually use an instance HBase in unit
    tests (it could in integration tests). In that case, we will mock the HBase endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real component returns nondeterministic values. For instance, your route
    calls a web service that never returns the same response for the same request
    (for instance, containing a timestamp). It's difficult to define assertions on
    nondeterministic values. In that case, we will mock the web service to always
    return a sample response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to simulate errors. As shown in the previous chapter, it's very important
    to simulate errors in order to test the error handler, for instance. When we mock
    an endpoint, it's possible to simulate errors by throwing exceptions in mocked
    endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MockComponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you override the `isMockEndpoints()`, or `isMockEndpointsAndSkip()` method
    in your `test` class, Camel will automatically *replace* the actual endpoint with
    a mock endpoint, prefixing the endpoint URI with mock.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in your route, you have the file`:/tmp/in` endpoint. The `isMockEndpointsAndSkip()`
    method returns `*` meaning that all endpoints will be mocked. Camel Test creates
    the `mock:file:/tmp/in` mock endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can retrieve the mock endpoint in your `test()` method using the `getMockEndpoint()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define the assertions on a mock endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expectedMessageCount(int)` defines the number of messages expected to be received
    by the endpoint. This count is reset and `init` at `CamelContext` creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectedMinimumMessageCount(int)` defines the minimum number of messages expected
    to be received by the endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectedBodiesReceived(...)` defines the expected `in` message body to be
    received in this order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectedHeaderRecevied(...)` defines the expected `in` message headers to
    be received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectsAscending(Expression)` defines the expectation of the received message
    order. The order is defined by the given expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectsDescending(Expression)` is like `expectsAscending()` but in the reverse
    order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectsNoDuplicate(Expression)` checks that there are no duplicate messages.
    The duplication pattern is expressed by the expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have defined the expectations on the mock endpoint, you call the `assertIsSatisfied()`
    method to validate that the expectations are satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `assertIsSatisfied()` method executes the route and waits for
    10 s before shutting down the route. The timeout can be changed with the `setResultWaitTime(ms)`
    method. When the assertions are satisfied, Camel stops waiting and moves forward
    to the `assertIsSatisfied()` method call. If a message reaches the endpoint after
    the `assertIsSatisfied()` statement, it won''t be considered. Suppose, for instance,
    you want to verify that no message has been received by the endpoint (with `expectedMessageCount(0))`.
    As, at the start, the assertion is already satisfied, Camel doesn''t wait. So,
    you have to explicitly wait for the assertion wait time using the `setAssertPeriod()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to define the assertions on a specific message. The `message()`
    method allows you to access a specific message received by a mock endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The mock endpoint stores the received messages in memory. In addition to the
    messages themselves, it also stores the arrival time of the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you can define timing assertions on the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can also simulate errors on a mock endpoint. It allows you to test the behavior
    of your route (and especially the error handler) when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the previous chapter, an error is actually an exception raised by
    an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a mock endpoint, you can use the `whenAnyExchangeReceived()` method to call
    a processor. If the processor throws an exception, we will simulate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A complete example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a bundle with the following route using the Blueprint DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As usual, this route Blueprint XML is located in the `src/main/resources/OSGI-INF/blueprint/route.xml`
    of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The route logic is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: We receive XML messages on the `direct:input` endpoint
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We implement a Content-based Router EIP with the following logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the message contains a country element with `France` as the value (using
    the `//country=France xpath` expression), we send the message to the `direct:france`
    endpoint.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the message contains a country element with `USA` as the value (using the
    `//country=USA xpath` expression), we send the message to the `direct:usa` endpoint.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the message is sent to the `direct:other` endpoint.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also configure the `DefaultErrorHandler` of the route. For all exceptions,
    we try:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: to redeliver the message two times
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We set the exception handled meaning, so that we don't send back the exception
    *outside* of the route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We *forward* the *faulted* message to the `direct:error` endpoint
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `pom.xml` file of the project defines the dependencies required for the
    tests, especially the `camel-test-blueprint` artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to implement our unit tests. We create a class at `src/test/java/com/packt/camel/test
    folder`, named `RouteTest.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This class extends the `CamelBlueprintTestSupport` class, as our route is written
    using the Blueprint DSL. Before actually implementing the tests, we have to *bootstrap*
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to load the Blueprint XML. For that, we override the `getBlueprintDescriptor()`
    method. This method just returns the location of the Blueprint XML file.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to define the endpoints that we want to mock. So we override
    the `isMockEndpointsAndSkip()` method. This method returns a regular expression
    for the endpoints URI to match. Camel will mock the corresponding endpoints and
    won't send the message to the actual endpoints. Here, we want to mock all *outbound*
    endpoints of the routes—`direct:error`, `direct:france`, `direct:usa`, and `direct:other`.
    We don't want to mock the `direct:input` *inbound* endpoint, as we will use the
    producer template to send an exchange there.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to implement the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The tests are implemented by method annotation with `@Test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test method is `testRoutingFrance()`. This test:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an XML message containing an element country with `France` as the value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the mocked `direct:france` endpoint, we expect to receive one message, according
    to the ContentBasedRouter EIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the mocked `direct:usa` endpoint, we expect to receive no message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the mocked `direct:error` endpoint, we expect to receive no message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the mocked `direct:other` endpoint, we expect to receive no message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the producer template to send the XML message to the `direct:input` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the message has been sent, we check if the expectations are satisfied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test method is `testRoutingUsa()`. This test is basically the same
    as the `testRoutingFrance()` method. However, we want to test the `ContentBasedRouter`
    with an XML message containing the `<country/>` element with the `USA` value.
    We update the expectations on the different mocked endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The third test method is `testRoutingOther()`. This test is basically the same
    as the two previous methods. However, we want to test the `ContentBasedRouter`
    with an XML message containing the `<country/>` element with the `Spain` value.
    We update the expectations accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to test our `DefaultErrorHandling`. So, we want to simulate an
    error to see if the error handler reacts as expected.
  prefs: []
  type: TYPE_NORMAL
- en: To fake an error, we add a processor on the mocked `direct:france` endpoint.
    This processor throws an `IOException`. This exception will be caught by the error
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: As the error handler *forwards* the message to the `direct:error` endpoint,
    we can define the expectations on the mocked `direct:error` to be sure that the
    endpoint received the *failed* message (forwarded by the error handler).
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute our tests, we just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the different mock endpoints created by Camel in the output messages,
    (for instance `[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting:
    Endpoint[mock://direct:other]` is satisfied).'
  prefs: []
  type: TYPE_NORMAL
- en: Additional annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Camel test kit also provides additional annotations, in order to simplify
    the code of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `getMockEndpoint()` method to get the mocked endpoints,
    you can use the `@EndpointInject` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can directly use the `franceEndpoint` mock endpoint in the test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, instead of defining the endpoint URI on the producer template, you
    can use the `@Producer` annotation to define where the producer template sends
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now directly use the producer template without specifying the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Mocking OSGi services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Camel Blueprint test kit allows you to mock and prototype OSGi services.
  prefs: []
  type: TYPE_NORMAL
- en: For that, the kit uses the `PojoSR` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we want to test the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If this route is very simple, it uses an OSGi service via the `<reference/>`
    element. In the OSGi container, the reference element is looking for the actual
    service in the OSGi Service Registry.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using a real blueprint container, the Camel Blueprint test kit allows
    you to register services. For that, we just override the `addServicesOnStartup()`
    method where we add the bean providing the services used in the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we define the mocked service directly in the test. As for the
    previous test, we execute the test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in this chapter, the Camel test kits allow you to easily prototype
    services and endpoints, and test your routes.
  prefs: []
  type: TYPE_NORMAL
- en: Tests are really important to guarantee the integration logic implemented, and
    also to be sure that the error handler and routing react as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we see in this chapter, Camel provides rich features allowing you to easily
    implement unit tests and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to that, you can test the integration logic that you want to implement
    in your routes, and you can also move forward in your implementation, by mocking
    parts of your integration logic.
  prefs: []
  type: TYPE_NORMAL
- en: With such tests, you can use test driven implementation, where you start by
    implementing the test with your expectation, and implement your routes based on
    these expectations.
  prefs: []
  type: TYPE_NORMAL
