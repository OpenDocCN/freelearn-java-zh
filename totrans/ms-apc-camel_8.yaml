- en: Chapter 8. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 测试
- en: When we deal with an integration project, testing is vital to ensure that your
    logic works as expected. This means testing the different routing logic, and managing
    the errors that can happen during the routing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理集成项目时，测试对于确保你的逻辑按预期工作至关重要。这意味着测试不同的路由逻辑，并管理在路由过程中可能发生的错误。
- en: Moreover, an integration project means that we use services or endpoints provided
    by different teams or third parties. Instead of waiting for the services and endpoints
    provided by the team, we can begin to implement our project by mocking the dependency
    services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个集成项目意味着我们使用不同团队或第三方提供的服务或端点。而不是等待团队提供的服务和端点，我们可以通过模拟依赖服务来开始实现我们的项目。
- en: 'We can distinguish two kinds of tests:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种测试类型：
- en: Unit tests are focused on testing your routing logic. Basically, it tests the
    behaviors of your routes.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试主要关注测试你的路由逻辑。基本上，它测试你的路由行为。
- en: Integration tests are more dedicated to the installation and deployment of your
    routes in a container. These tests depend on the runtime container that you use
    to run your Camel routes.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试更多地关注于在你的容器中安装和部署你的路由。这些测试依赖于你用来运行 Camel 路由的运行时容器。
- en: Apache Camel provides the tool to easily implement unit tests—it's called a
    Camel test kit.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Camel 提供了一个易于实现单元测试的工具——称为 Camel 测试套件。
- en: 'This chapter will introduce:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍：
- en: The unit test approach and how to use the different modules provided by the
    test kit.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试方法和如何使用测试套件提供的不同模块。
- en: How to bootstrap integration tests in the special case of Apache Karaf and OSGi
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Apache Karaf 和 OSGi 的特殊情况下启动集成测试
- en: Unit test approach with the Camel test kit
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Camel 测试套件的单元测试方法
- en: Implementing a unit test basically means you bootstrap your routes—you load
    `CamelContext` and routes in the tests, and it is ready to be executed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单元测试基本上意味着你启动你的路由——你在测试中加载 `CamelContext` 和路由，它就准备好执行了。
- en: 'You now define the endpoints that you want to mock, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在定义你想要模拟的端点，如下所示：
- en: On the mocked endpoints, you define assertions.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟端点上，你定义断言。
- en: Create and *inject* exchanges at some points of the routes.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由的某些点上创建和 *注入* 交换。
- en: Check whether the assertions are verified.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查断言是否被验证。
- en: 'Camel provides different test kits, depending on the DSL that you use to write
    your routes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 根据你用来编写路由的 DSL 提供不同的测试套件：
- en: '`camel-test` is the core and abstract test kit that you can use if you use
    the Java DSL.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camel-test` 是如果你使用 Java DSL 可以使用的核心和抽象测试套件。'
- en: '`camel-test-spring` extends `camel-test`, providing support for the Spring
    DSL.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camel-test-spring` 扩展 `camel-test`，提供对 Spring DSL 的支持。'
- en: '`camel-test-blueprint` extends `camel-test` as well, and provides support for
    the Blueprint DSL. Additionally, it also provides an OSGi like service support
    leveraging iPOJO.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camel-test-blueprint` 也在 `camel-test` 的基础上扩展，并提供对 Blueprint DSL 的支持。此外，它还提供了一个类似于
    OSGi 的服务支持，利用 iPOJO。'
- en: 'All Camel test kits provide:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Camel 测试套件都提供：
- en: 'JUnit extensions: JUnit is the most commonly adopted unit test framework for
    Java, and is freely available. Instead of reinventing the wheel, Camel directly
    provides JUnit extensions. This means that your unit test classes will extend
    the Camel JUnit extensions, and you will be able to use the JUnit annotations
    (like `@Test` for instance).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 扩展：JUnit 是最常用的 Java 单元测试框架，并且是免费可用的。Camel 直接提供 JUnit 扩展，这意味着你的单元测试类将扩展
    Camel JUnit 扩展，你将能够使用 JUnit 注解（例如 `@Test`）。
- en: 'Mock component: The mock component is provided directly by `camel-core`. The
    mock component provides a powerful declarative testing mechanism, and can be used
    *on top of* actual components. The declarative expectations can be created on
    any mock endpoint, before the test begins.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟组件：模拟组件直接由 `camel-core` 提供。模拟组件提供了一个强大的声明式测试机制，并且可以用于 *之上* 实际组件。在测试开始之前，可以在任何模拟端点上创建声明式期望。
- en: 'ProducerTemplate: The `ProducerTemplate` is provided by the Camel Test base
    classes (or the `CamelContext`). It''s a convenient feature that allows you to
    easily create exchanges, and set messages, which you send on the route endpoint
    of your choice.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ProducerTemplate：`ProducerTemplate` 由 Camel 测试基类（或 `CamelContext`）提供。这是一个方便的特性，允许你轻松创建交换，并设置消息，你可以在你选择的路线端点发送这些消息。
- en: ProducerTemplate
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProducerTemplate
- en: '`ProducerTemplate` is a template that provides an easy way to create messages
    in Camel. It allows you to send message instances in an exchange to an endpoint.
    It supports various communication styles—`InOnly`, `InOut`, `Sync`, `Async`, and
    `Callback`. You can get `ProducerTemplate` from the `CamelContext`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProducerTemplate` 是一个模板，它提供了一种简单的方法在 Camel 中创建消息。它允许你将消息实例发送到端点。它支持各种通信风格——`InOnly`、`InOut`、`Sync`、`Async`
    和 `Callback`。你可以从 `CamelContext` 获取 `ProducerTemplate`：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In unit test, as soon as your test class extends to one of the Camel test base
    classes, you have `producerTemplate` ready to be used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，一旦你的测试类扩展到 Camel 测试基类之一，你就有 `producerTemplate` 可以使用了。
- en: 'For instance, the producer template can create a message, set the body of the
    `in` message and send it to the `direct:input` endpoint:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，生产模板可以创建一个消息，设置 `in` 消息的主体，并将其发送到 `direct:input` 端点：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In addition to the body of the `in` message, it''s also possible to set a header:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `in` 消息的主体之外，还可以设置一个头部：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `sendBody()` method also accepts a `MessageExchangePattern` argument (if
    you want to simulate the `InOnly` or `InOut` exchange).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendBody()` 方法也接受一个 `MessageExchangePattern` 参数（如果你想要模拟 `InOnly` 或 `InOut`
    交换）。'
- en: When using `InOut`, you might want to get the `out` message after the exchange
    execution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `InOut` 时，你可能在交换执行后想要获取 `out` 消息。
- en: 'In that case, you have to use the `requestBody()` method on the `producerTemplate`
    instead of `sendBody()` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须使用 `producerTemplate` 上的 `requestBody()` 方法而不是 `sendBody()` 方法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: JUnit extensions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JUnit 扩展
- en: Camel directly provides classes that you have to extend in your tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 直接提供了你需要在测试中扩展的类。
- en: CamelTestSupport
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CamelTestSupport
- en: '`CamelTestSupport` is the class that you have to extend if you use the Java
    DSL.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`CamelTestSupport` 是如果你使用 Java DSL 那样你必须扩展的类。'
- en: You have to override the `createRouteBuilder()` method. This is where you actually
    bootstrap the route, by calling the `createRouteBuilder()` method defined in your
    route class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须重写 `createRouteBuilder()` 方法。这是你通过调用在路由类中定义的 `createRouteBuilder()` 方法来启动路由的地方。
- en: You also have to override the `isMockEndpoints()` or `isMockEndpointsAndSkip()`
    method. This method returns a regular expression—all endpoint URIs matching this
    `regex` will be mocked by the mock component. The `isMockEndpoints()` and `isMockEndpointsAndSkip()`
    methods are the same, but the skip one doesn't send the exchange to the actual
    endpoint.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须重写 `isMockEndpoints()` 或 `isMockEndpointsAndSkip()` 方法。此方法返回一个正则表达式——所有匹配此
    `regex` 的端点 URI 都将由模拟组件模拟。`isMockEndpoints()` 和 `isMockEndpointsAndSkip()` 方法相同，但跳过的那个不会将交换发送到实际端点。
- en: You are now ready to create the methods with the `@Test` annotation. These methods
    are the actual tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好使用 `@Test` 注解创建方法了。这些方法是实际的测试。
- en: 'Here''s a complete example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个完整的示例：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: CamelSpringTestSupport
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CamelSpringTestSupport
- en: '`CamelSpringTestSupport` is the class that your test class has to extend if
    you use the Spring DSL.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`CamelSpringTestSupport` 是如果你使用 Spring DSL 那样你的测试类必须扩展的类。'
- en: 'This is exactly the same as the `CamelTestSupport` class. The only difference
    is that, instead of overriding the `createRouteBuilder()` method, you have to
    override the `createApplicationContext()` method. The `createApplicationContext()`
    method actually directly loads your Spring XML file containing your route definition:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `CamelTestSupport` 类完全相同。唯一的区别是，你不必重写 `createRouteBuilder()` 方法，而是必须重写 `createApplicationContext()`
    方法。`createApplicationContext()` 方法实际上直接加载包含你的路由定义的 Spring XML 文件：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: CamelBlueprintTestSupport
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CamelBlueprintTestSupport
- en: '`CamelBlueprintTestSupport` is the class that you have to extend if you use
    the Blueprint DSL.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`CamelBlueprintTestSupport` 是如果你使用 Blueprint DSL 那样必须扩展的类。'
- en: 'This is very similar to the `CamelSpringTestSupport` class, but instead of
    the `createApplicationContext()` method, you have to override the `getBlueprintDescriptor()`
    method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `CamelSpringTestSupport` 类非常相似，但与 `createApplicationContext()` 方法不同，你必须重写
    `getBlueprintDescriptor()` 方法：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also override the `addServicesOnStartup()` method, if you want to *fake*
    some OSGi services used in your route blueprint XML.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以重写 `addServicesOnStartup()` 方法，如果你想要在路由蓝图 XML 中 *模拟* 一些 OSGi 服务。
- en: The mock component
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟组件
- en: The mock component is provided by `camel-core`. It means that you can explicitly
    create mock endpoints with the `mock:name` URI. However, where it really makes
    sense to use the mock component is in unit tests—it's a cornerstone there.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟组件由 `camel-core` 提供。这意味着你可以使用 `mock:name` URI 显式创建模拟端点。然而，真正有意义使用模拟组件的地方是在单元测试中——它是那里的基石。
- en: Like a crash test dummy, the mock component is used to simulate real components
    and fake the actual endpoints.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像碰撞测试假人一样，模拟组件用于模拟真实组件并伪造实际端点。
- en: Without the mock component, you would have to use the real components and endpoints,
    which is not always possible in tests. Moreover, when testing, you need to apply
    assertions to see if the result is as expected—we can use the mock component for
    that easily.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有模拟组件，你就必须使用真实的组件和端点，这在测试中并不总是可能的。此外，在测试时，你需要应用断言来查看结果是否如预期——我们可以轻松地使用模拟组件来做这件事。
- en: 'The mock component is an answer to the following situations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟组件是对以下情况的回应：
- en: The real component or endpoint doesn't exist yet. For instance, you want to
    call a web service developed by another team. Unfortunately, the web service is
    not yet ready. In that case, you can fake the web service using the mock component.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实组件或端点尚不存在。例如，你想调用由另一个团队开发的Web服务。不幸的是，该Web服务尚未准备好。在这种情况下，你可以使用模拟组件伪造Web服务。
- en: The real component is not easy or takes time to bootstrap.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实组件不易启动或需要时间来启动。
- en: The real component is difficult to set up. Some components are difficult to
    set up, or require other applications that are difficult to set up, for instance,
    when you use the `camel-hbase` component in your route. This component uses an
    HBase instance running, meaning a running ZooKeeper and a running Hadoop HDFS
    cluster. It doesn't really make sense to actually use an instance HBase in unit
    tests (it could in integration tests). In that case, we will mock the HBase endpoint.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实组件难以设置。一些组件难以设置，或者需要其他难以设置的程序，例如，当你使用`camel-hbase`组件在你的路由中时。该组件使用一个正在运行的HBase实例，这意味着一个正在运行的ZooKeeper和一个正在运行的Hadoop
    HDFS集群。在实际单元测试中真正使用一个HBase实例并没有太多意义（它可以在集成测试中使用）。在这种情况下，我们将模拟HBase端点。
- en: The real component returns nondeterministic values. For instance, your route
    calls a web service that never returns the same response for the same request
    (for instance, containing a timestamp). It's difficult to define assertions on
    nondeterministic values. In that case, we will mock the web service to always
    return a sample response.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实组件返回非确定性值。例如，你的路由调用一个永远不会为相同请求返回相同响应的Web服务（例如，包含时间戳）。在非确定性值上定义断言是困难的。在这种情况下，我们将模拟Web服务以始终返回一个样本响应。
- en: You have to simulate errors. As shown in the previous chapter, it's very important
    to simulate errors in order to test the error handler, for instance. When we mock
    an endpoint, it's possible to simulate errors by throwing exceptions in mocked
    endpoint.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须模拟错误。如前一章所示，模拟错误以测试错误处理器等非常重要。当我们模拟端点时，通过在模拟端点中抛出异常，可以模拟错误。
- en: Using MockComponent
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MockComponent
- en: When you override the `isMockEndpoints()`, or `isMockEndpointsAndSkip()` method
    in your `test` class, Camel will automatically *replace* the actual endpoint with
    a mock endpoint, prefixing the endpoint URI with mock.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的`test`类中重写`isMockEndpoints()`或`isMockEndpointsAndSkip()`方法时，Camel会自动将实际端点替换为模拟端点，并在端点URI前加上模拟前缀。
- en: For instance, in your route, you have the file`:/tmp/in` endpoint. The `isMockEndpointsAndSkip()`
    method returns `*` meaning that all endpoints will be mocked. Camel Test creates
    the `mock:file:/tmp/in` mock endpoint.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你的路由中，你有文件`:/tmp/in`端点。`isMockEndpointsAndSkip()`方法返回`*`，意味着所有端点都将被模拟。Camel
    Test创建`mock:file:/tmp/in`模拟端点。
- en: 'You can retrieve the mock endpoint in your `test()` method using the `getMockEndpoint()`
    method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`test()`方法中使用`getMockEndpoint()`方法检索模拟端点：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can define the assertions on a mock endpoint:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模拟端点上定义断言：
- en: '`expectedMessageCount(int)` defines the number of messages expected to be received
    by the endpoint. This count is reset and `init` at `CamelContext` creation.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectedMessageCount(int)`定义了端点期望接收的消息数量。这个计数在`CamelContext`创建时重置和初始化。'
- en: '`expectedMinimumMessageCount(int)` defines the minimum number of messages expected
    to be received by the endpoint.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectedMinimumMessageCount(int)`定义了端点期望接收的最小消息数量。'
- en: '`expectedBodiesReceived(...)` defines the expected `in` message body to be
    received in this order.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectedBodiesReceived(...)`定义了期望按此顺序接收的`in`消息体。'
- en: '`expectedHeaderRecevied(...)` defines the expected `in` message headers to
    be received.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectedHeaderRecevied(...)`定义了期望接收的`in`消息头。'
- en: '`expectsAscending(Expression)` defines the expectation of the received message
    order. The order is defined by the given expression.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectsAscending(Expression)`定义了接收消息的顺序期望。顺序由给定的表达式定义。'
- en: '`expectsDescending(Expression)` is like `expectsAscending()` but in the reverse
    order.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectsDescending(Expression)`类似于`expectsAscending()`，但顺序相反。'
- en: '`expectsNoDuplicate(Expression)` checks that there are no duplicate messages.
    The duplication pattern is expressed by the expression.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectsNoDuplicate(Expression)`检查是否存在重复的消息。重复模式由表达式表示。'
- en: 'Once you have defined the expectations on the mock endpoint, you call the `assertIsSatisfied()`
    method to validate that the expectations are satisfied:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在模拟端点的预期上定义了期望，你就可以调用`assertIsSatisfied()`方法来验证这些期望是否得到满足：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By default, the `assertIsSatisfied()` method executes the route and waits for
    10 s before shutting down the route. The timeout can be changed with the `setResultWaitTime(ms)`
    method. When the assertions are satisfied, Camel stops waiting and moves forward
    to the `assertIsSatisfied()` method call. If a message reaches the endpoint after
    the `assertIsSatisfied()` statement, it won''t be considered. Suppose, for instance,
    you want to verify that no message has been received by the endpoint (with `expectedMessageCount(0))`.
    As, at the start, the assertion is already satisfied, Camel doesn''t wait. So,
    you have to explicitly wait for the assertion wait time using the `setAssertPeriod()`
    method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`assertIsSatisfied()`方法执行路由，并在关闭路由前等待10秒。可以通过`setResultWaitTime(ms)`方法更改超时时间。当断言得到满足时，Camel停止等待并继续到`assertIsSatisfied()`方法的调用。如果一个消息在`assertIsSatisfied()`语句之后到达端点，它将不会被考虑。例如，如果你想验证端点没有收到任何消息（使用`expectedMessageCount(0)`），由于断言在开始时已经得到满足，Camel不会等待。因此，你必须显式地使用`setAssertPeriod()`方法等待断言等待时间：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s also possible to define the assertions on a specific message. The `message()`
    method allows you to access a specific message received by a mock endpoint:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在特定消息上定义断言。`message()`方法允许你访问模拟端点接收到的特定消息：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The mock endpoint stores the received messages in memory. In addition to the
    messages themselves, it also stores the arrival time of the messages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟端点将接收到的消息存储在内存中。除了消息本身，它还存储了消息的到达时间。
- en: 'This means that you can define timing assertions on the messages:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以在消息上定义时间断言：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can also simulate errors on a mock endpoint. It allows you to test the behavior
    of your route (and especially the error handler) when an error occurs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在模拟端点上模拟错误。这允许你在发生错误时测试路由（尤其是错误处理器）的行为。
- en: As seen in the previous chapter, an error is actually an exception raised by
    an endpoint.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，错误实际上是由端点引发的异常。
- en: 'On a mock endpoint, you can use the `whenAnyExchangeReceived()` method to call
    a processor. If the processor throws an exception, we will simulate an error:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟端点，你可以使用`whenAnyExchangeReceived()`方法来调用处理器。如果处理器抛出异常，我们将模拟一个错误：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A complete example
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个完整的示例
- en: 'We have a bundle with the following route using the Blueprint DSL:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Blueprint DSL定义了以下路由的bundle：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As usual, this route Blueprint XML is located in the `src/main/resources/OSGI-INF/blueprint/route.xml`
    of our project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，这个路由Blueprint XML位于我们项目的`src/main/resources/OSGI-INF/blueprint/route.xml`中。
- en: 'The route logic is pretty simple:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 路由逻辑相当简单：
- en: We receive XML messages on the `direct:input` endpoint
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`direct:input`端点接收XML消息
- en: 'We implement a Content-based Router EIP with the following logic:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下逻辑实现了一个基于内容的路由EIP：
- en: If the message contains a country element with `France` as the value (using
    the `//country=France xpath` expression), we send the message to the `direct:france`
    endpoint.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息包含一个具有`France`值的`country`元素（使用`//country=France xpath`表达式），我们将消息发送到`direct:france`端点。
- en: If the message contains a country element with `USA` as the value (using the
    `//country=USA xpath` expression), we send the message to the `direct:usa` endpoint.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息包含一个具有`USA`值的`country`元素（使用`//country=USA xpath`表达式），我们将消息发送到`direct:usa`端点。
- en: Otherwise, the message is sent to the `direct:other` endpoint.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，消息将被发送到`direct:other`端点。
- en: 'We also configure the `DefaultErrorHandler` of the route. For all exceptions,
    we try:'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还配置了路由的`DefaultErrorHandler`。对于所有异常，我们尝试：
- en: to redeliver the message two times
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重发消息两次
- en: We set the exception handled meaning, so that we don't send back the exception
    *outside* of the route
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了异常处理的意义，这样我们不会将异常*发送*回路由外部
- en: We *forward* the *faulted* message to the `direct:error` endpoint
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将*故障*消息转发到`direct:error`端点
- en: 'The `pom.xml` file of the project defines the dependencies required for the
    tests, especially the `camel-test-blueprint` artifact:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的`pom.xml`文件定义了测试所需的依赖，特别是`camel-test-blueprint`组件：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s now time to implement our unit tests. We create a class at `src/test/java/com/packt/camel/test
    folder`, named `RouteTest.java`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现我们的单元测试了。我们在`src/test/java/com/packt/camel/test folder`目录下创建一个名为`RouteTest.java`的类：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class extends the `CamelBlueprintTestSupport` class, as our route is written
    using the Blueprint DSL. Before actually implementing the tests, we have to *bootstrap*
    the test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`CamelBlueprintTestSupport`类，因为我们的路由是用Blueprint DSL编写的。在实际上实现测试之前，我们必须*引导*测试。
- en: The first step is to load the Blueprint XML. For that, we override the `getBlueprintDescriptor()`
    method. This method just returns the location of the Blueprint XML file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是加载Blueprint XML。为此，我们重写了`getBlueprintDescriptor()`方法。这个方法只是返回Blueprint XML文件的位置。
- en: The second step is to define the endpoints that we want to mock. So we override
    the `isMockEndpointsAndSkip()` method. This method returns a regular expression
    for the endpoints URI to match. Camel will mock the corresponding endpoints and
    won't send the message to the actual endpoints. Here, we want to mock all *outbound*
    endpoints of the routes—`direct:error`, `direct:france`, `direct:usa`, and `direct:other`.
    We don't want to mock the `direct:input` *inbound* endpoint, as we will use the
    producer template to send an exchange there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是定义我们想要模拟的端点。因此，我们重写了`isMockEndpointsAndSkip()`方法。这个方法返回一个用于匹配端点URI的正则表达式。Camel将模拟相应的端点，并且不会将消息发送到实际端点。在这里，我们想要模拟所有路由的*出站*端点——`direct:error`、`direct:france`、`direct:usa`和`direct:other`。我们不想模拟`direct:input`的*入站*端点，因为我们将在那里使用生产者模板发送交换。
- en: We are now ready to implement the unit tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实现单元测试了。
- en: The tests are implemented by method annotation with `@Test`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过方法注解`@Test`实现。
- en: 'The first test method is `testRoutingFrance()`. This test:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试方法是`testRoutingFrance()`。这个测试：
- en: Creates an XML message containing an element country with `France` as the value
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含国家元素且值为`France`的XML消息
- en: On the mocked `direct:france` endpoint, we expect to receive one message, according
    to the ContentBasedRouter EIP
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟的`direct:france`端点，我们期望根据基于内容的路由EIP接收一条消息
- en: On the mocked `direct:usa` endpoint, we expect to receive no message
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟的`direct:usa`端点，我们期望不接收任何消息
- en: On the mocked `direct:error` endpoint, we expect to receive no message
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟的`direct:error`端点，我们期望不接收任何消息
- en: On the mocked `direct:other` endpoint, we expect to receive no message
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟的`direct:other`端点，我们期望不接收任何消息
- en: We use the producer template to send the XML message to the `direct:input` endpoint
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用生产者模板将XML消息发送到`direct:input`端点
- en: Once the message has been sent, we check if the expectations are satisfied
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦消息被发送，我们检查期望是否得到满足
- en: The second test method is `testRoutingUsa()`. This test is basically the same
    as the `testRoutingFrance()` method. However, we want to test the `ContentBasedRouter`
    with an XML message containing the `<country/>` element with the `USA` value.
    We update the expectations on the different mocked endpoints.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试方法是`testRoutingUsa()`。这个测试基本上与`testRoutingFrance()`方法相同。然而，我们想要测试带有包含`<country/>`元素且值为`USA`的XML消息的`ContentBasedRouter`。我们在不同的模拟端点上更新期望。
- en: The third test method is `testRoutingOther()`. This test is basically the same
    as the two previous methods. However, we want to test the `ContentBasedRouter`
    with an XML message containing the `<country/>` element with the `Spain` value.
    We update the expectations accordingly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个测试方法是`testRoutingOther()`。这个测试基本上与前面两个方法相同。然而，我们想要测试带有包含`<country/>`元素且值为`Spain`的XML消息的`ContentBasedRouter`。我们相应地更新期望。
- en: We also want to test our `DefaultErrorHandling`. So, we want to simulate an
    error to see if the error handler reacts as expected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要测试我们的`DefaultErrorHandling`。因此，我们想要模拟一个错误，看看错误处理器是否如预期那样响应。
- en: To fake an error, we add a processor on the mocked `direct:france` endpoint.
    This processor throws an `IOException`. This exception will be caught by the error
    handler.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟一个错误，我们在模拟的`direct:france`端点上添加一个处理器。这个处理器抛出一个`IOException`。这个异常将被错误处理器捕获。
- en: As the error handler *forwards* the message to the `direct:error` endpoint,
    we can define the expectations on the mocked `direct:error` to be sure that the
    endpoint received the *failed* message (forwarded by the error handler).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为错误处理器，它将消息转发到`direct:error`端点，我们可以定义对模拟的`direct:error`端点的期望，以确保端点接收到了（由错误处理器转发的）*失败*的消息。
- en: 'To execute our tests, we just run:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行我们的测试，我们只需运行：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see the different mock endpoints created by Camel in the output messages,
    (for instance `[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting:
    Endpoint[mock://direct:other]` is satisfied).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以在输出消息中看到Camel创建的不同模拟端点（例如 `[main] INFO org.apache.camel.component.mock.MockEndpoint
    - Asserting: Endpoint[mock://direct:other]` 已满足）。'
- en: Additional annotations
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的注解
- en: The Camel test kit also provides additional annotations, in order to simplify
    the code of your tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Camel测试套件还提供了额外的注解，以便简化测试代码。
- en: 'Instead of using the `getMockEndpoint()` method to get the mocked endpoints,
    you can use the `@EndpointInject` annotation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`@EndpointInject`注解而不是使用`getMockEndpoint()`方法来获取模拟端点：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can directly use the `franceEndpoint` mock endpoint in the test methods:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在测试方法中直接使用`franceEndpoint`模拟端点：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, instead of defining the endpoint URI on the producer template, you
    can use the `@Producer` annotation to define where the producer template sends
    the message:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以在生产者模板上而不是定义端点URI时，使用`@Producer`注解来定义生产者模板发送消息的位置：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now directly use the producer template without specifying the endpoint:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以直接使用生产者模板，而不必指定端点：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Mocking OSGi services
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟OSGi服务
- en: The Camel Blueprint test kit allows you to mock and prototype OSGi services.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Camel蓝图测试套件允许你模拟和原型化OSGi服务。
- en: For that, the kit uses the `PojoSR` library.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，套件使用了`PojoSR`库。
- en: 'For instance, we want to test the following route:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要测试以下路由：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If this route is very simple, it uses an OSGi service via the `<reference/>`
    element. In the OSGi container, the reference element is looking for the actual
    service in the OSGi Service Registry.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个路由非常简单，它通过`<reference/>`元素使用OSGi服务。在OSGi容器中，引用元素正在OSGi服务注册表中查找实际的服务。
- en: Instead of using a real blueprint container, the Camel Blueprint test kit allows
    you to register services. For that, we just override the `addServicesOnStartup()`
    method where we add the bean providing the services used in the route.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用真实的蓝图容器而不是，Camel蓝图测试套件允许你注册服务。为此，我们只需覆盖`addServicesOnStartup()`方法，在其中添加提供路由中使用的服务的bean。
- en: 'The test class is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类如下：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see that we define the mocked service directly in the test. As for the
    previous test, we execute the test with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们直接在测试中定义了模拟服务。至于之前的测试，我们通过以下方式执行测试：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we saw in this chapter, the Camel test kits allow you to easily prototype
    services and endpoints, and test your routes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，Camel测试套件允许你轻松地原型化服务和端点，并测试你的路由。
- en: Tests are really important to guarantee the integration logic implemented, and
    also to be sure that the error handler and routing react as you expect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于确保实现的集成逻辑，以及确保错误处理程序和路由按预期反应，是非常重要的。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we see in this chapter, Camel provides rich features allowing you to easily
    implement unit tests and integration tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，Camel提供了丰富的功能，允许你轻松实现单元测试和集成测试。
- en: Thanks to that, you can test the integration logic that you want to implement
    in your routes, and you can also move forward in your implementation, by mocking
    parts of your integration logic.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，你可以测试你想要在路由中实现集成逻辑，并且可以通过模拟集成逻辑的部分来继续你的实现。
- en: With such tests, you can use test driven implementation, where you start by
    implementing the test with your expectation, and implement your routes based on
    these expectations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类测试，你可以使用测试驱动实现，即首先根据你的预期实现测试，然后根据这些预期实现你的路由。
