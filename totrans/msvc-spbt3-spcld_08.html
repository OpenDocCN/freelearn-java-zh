<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer190" class="Basic-Text-Frame">
    <h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-223" class="chapterTitle">Introduction to Spring Cloud</h1>
    <p class="normal">So far, we have seen how we can use Spring Boot to build microservices with well-documented APIs, along with Spring WebFlux and <code class="inlineCode">springdoc-openapi</code>; persist data in MongoDB and SQL databases using Spring Data for MongoDB and JPA; build reactive microservices either as non-blocking APIs using Project Reactor or as event-driven asynchronous services using Spring Cloud Stream with RabbitMQ or Kafka, together with Docker; and manage and test a system landscape consisting of microservices, databases, and messaging systems.</p>
    <p class="normal">Now, it’s time to see how we<a id="_idIndexMarker550"/> can use <strong class="keyWord">Spring Cloud</strong> to make our services production-ready, that is, scalable, robust, configurable, secure, and resilient.</p>
    <p class="normal">In this chapter, we will introduce you to how Spring Cloud can be used to implement the following design patterns from <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, in the <em class="italic">Design patterns for microservices</em> section:</p>
    <ul>
      <li class="bulletList">Service discovery</li>
      <li class="bulletList">Edge server</li>
      <li class="bulletList">Centralized configuration</li>
      <li class="bulletList">Circuit breaker</li>
      <li class="bulletList">Distributed tracing</li>
    </ul>
    <h1 id="_idParaDest-224" class="heading-1">Technical requirements</h1>
    <p class="normal">This chapter does not contain any source code, and so no tools need to be installed.</p>
    <h1 id="_idParaDest-225" class="heading-1">The evolution of Spring Cloud</h1>
    <p class="normal">In <a id="_idIndexMarker551"/>its initial 1.0 release in March 2015, Spring Cloud was mainly a wrapper around tools from Netflix OSS, which are as follows:</p>
    <ul>
      <li class="bulletList">Netflix Eureka, a discovery server</li>
      <li class="bulletList">Netflix Ribbon, a client-side load balancer</li>
      <li class="bulletList">Netflix Zuul, an edge server</li>
      <li class="bulletList">Netflix Hystrix, a circuit breaker</li>
    </ul>
    <p class="normal">The initial release of Spring Cloud also contained a configuration server and integration with Spring Security that provided OAuth 2.0 protected APIs. In May 2016, the Brixton release (v1.1) of Spring Cloud was made generally available. With the Brixton release, Spring Cloud got support for distributed tracing based on Spring Cloud Sleuth and Zipkin, which originated from Twitter. These initial Spring Cloud components could<a id="_idIndexMarker552"/> be used to implement the preceding design patterns. For more details, see <a href="https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now"><span class="url">https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now</span></a> and <a href="https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available"><span class="url">https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available</span></a>.</p>
    <p class="normal">Since its inception, Spring Cloud has grown considerably over the years and has added support for the following, among others:</p>
    <ul>
      <li class="bulletList">Service discovery and centralized configuration based on HashiCorp Consul and Apache Zookeeper</li>
      <li class="bulletList">Event-driven microservices using Spring Cloud Stream</li>
      <li class="bulletList">Cloud providers such as Microsoft Azure, Amazon Web Services, and Google Cloud Platform</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">See <a href="https://spring.io/projects/spring-cloud"><span class="url">https://spring.io/projects/spring-cloud</span></a> for a complete list of tools.</p>
    </div>
    <p class="normal">Since the release of Spring Cloud Greenwich (v2.1) in January 2019, some of the Netflix tools mentioned previously have been placed in maintenance mode in Spring Cloud.</p>
    <p class="normal">The reason for this is a mixture of Netflix no longer adding new features to some of the tools and Spring Cloud adding better alternatives. The following replacements are recommended by the Spring Cloud project:</p>
    <table id="table001-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Current component</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Replaced by</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Netflix Hystrix</p>
          </td>
          <td class="table-cell">
            <p class="normal">Resilience4j</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Netflix Hystrix Dashboard/Netflix Turbine</p>
          </td>
          <td class="table-cell">
            <p class="normal">Micrometer and monitoring system</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Netflix Ribbon</p>
          </td>
          <td class="table-cell">
            <p class="normal">Spring Cloud LoadBalancer</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Netflix Zuul</p>
          </td>
          <td class="table-cell">
            <p class="normal">Spring Cloud Gateway</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 8.1: Spring Cloud tool replacements</p>
    <p class="normal">For more details, see:</p>
    <ul>
      <li class="bulletList"><a href="https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available"><span class="url">https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available</span></a></li>
      <li class="bulletList"><a href="https://github.com/Netflix/Hystrix#hystrix-status"><span class="url">https://github.com/Netflix/Hystrix#hystrix-status</span></a></li>
      <li class="bulletList"><a href="https://github.com/Netflix/ribbon#project-status-on-maintenance"><span class="url">https://github.com/Netflix/ribbon#project-status-on-maintenance</span></a></li>
    </ul>
    <p class="normal">With <a id="_idIndexMarker553"/>the release of Spring Cloud Ilford (v2020.0.0) in December 2020, the only remaining Netflix component in Spring Cloud is Netflix Eureka.</p>
    <p class="normal">Finally, together with Spring Boot 3, Spring Cloud Kilburn (v2022.0.0) was released in December 2022. As already mentioned in <em class="chapterRef">Chapter 2</em>, <em class="italic">Introduction to Spring Boot</em>, in the <em class="italic">News in Spring Boot 3.0 </em>section, Spring Cloud Sleuth has been replaced by Micrometer Tracing to support distributed tracing.</p>
    <p class="normal">In this book, we will use the software components in the following table to implement the design patterns mentioned previously:</p>
    <table id="table002" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Design pattern</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Software component</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Service discovery</p>
          </td>
          <td class="table-cell">
            <p class="normal">Netflix Eureka and Spring Cloud LoadBalancer</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Edge server</p>
          </td>
          <td class="table-cell">
            <p class="normal">Spring Cloud Gateway and Spring Security OAuth</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Centralized configuration</p>
          </td>
          <td class="table-cell">
            <p class="normal">Spring Cloud Configuration Server</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Circuit breaker</p>
          </td>
          <td class="table-cell">
            <p class="normal">Resilience4j</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Distributed tracing</p>
          </td>
          <td class="table-cell">
            <p class="normal">Micrometer Tracing and Zipkin</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 8.2: Software components by design pattern</p>
    <p class="normal">Now, let’s go through the design patterns and introduce the software components that will be used to implement them!</p>
    <h1 id="_idParaDest-226" class="heading-1">Using Netflix Eureka for service discovery</h1>
    <p class="normal">Service discovery is<a id="_idIndexMarker554"/> probably the most important support function required to make a landscape of cooperating microservices production ready. As we already described in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, in the <em class="italic">Service discovery</em> section, a service discovery service (or a <em class="italic">discovery service</em> as an abbreviation) can be used to keep track of existing microservices and their instances.</p>
    <p class="normal">The first discovery service that Spring Cloud supported was <em class="italic">Netflix Eureka</em>.</p>
    <p class="normal">We will use <a id="_idIndexMarker555"/>this in <em class="chapterRef">Chapter 9</em>, <em class="italic">Adding Service Discovery Using Netflix Eureka</em>, along with a<em class="italic"> </em>load balancer based on Spring Cloud<a id="_idIndexMarker556"/> LoadBalancer.</p>
    <p class="normal">We will see how easy it is to register microservices with Netflix Eureka when using Spring Cloud. We will also learn how a client can send HTTP requests, such as a call to a RESTful API, to one of the instances registered in Netflix Eureka. In addition, the chapter will cover how to scale up the number of instances of a microservice, and how requests to a microservice will be load-balanced over its available instances (based on, by default, round-robin scheduling).</p>
    <p class="normal">The following screenshot demonstrates the web UI from Eureka, where we can see what microservices we have registered:</p>
    <figure class="mediaobject"><img src="../Images/B19825_08_01.png" alt="Graphical user interface, website  Description automatically generated" width="877" height="594"/></figure>
    <p class="packt_figref">Figure 8.1: Viewing microservices currently registered with Eureka</p>
    <p class="normal">From the <a id="_idIndexMarker557"/>preceding screenshot, we can see that <a id="_idIndexMarker558"/>the review service has three instances available, while the other three services only have one instance each.</p>
    <p class="normal">With Netflix Eureka introduced, let’s introduce how Spring Cloud can help to protect a microservices system landscape using an edge server.</p>
    <h1 id="_idParaDest-227" class="heading-1">Using Spring Cloud Gateway as an edge server</h1>
    <p class="normal">Another<a id="_idIndexMarker559"/> very important support function<a id="_idIndexMarker560"/> is an edge server. As we already described in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, in the <em class="italic">Edge server</em> section, it can be used to secure a microservice landscape, which involves hiding private services from external usage and protecting public services when they’re used by external clients.</p>
    <p class="normal">Initially, Spring Cloud used Netflix Zuul v1 as its edge server. Since the Spring Cloud Greenwich release, it’s recommended to use <strong class="keyWord">Spring Cloud Gateway</strong> instead. Spring Cloud Gateway comes with similar support for critical features, such as URL<a id="_idIndexMarker561"/> path-based routing and the protection of endpoints via the <a id="_idIndexMarker562"/>use of <strong class="keyWord">OAuth 2.0</strong> and <strong class="keyWord">OpenID Connect</strong> (<strong class="keyWord">OIDC</strong>).</p>
    <p class="normal">One important difference between Netflix Zuul v1 and Spring Cloud Gateway is that Spring Cloud Gateway is based on non-blocking APIs that use Spring 6, Project Reactor, and Spring Boot 3, while Netflix Zuul v1 is based on blocking APIs. This means that Spring Cloud Gateway should be able to handle larger numbers of concurrent requests than Netflix Zuul v1, which is important for an edge server that all external traffic goes through.</p>
    <p class="normal">The following diagram shows how all requests from external clients go through Spring Cloud Gateway as an edge server. Based on URL paths, it routes requests to the intended microservice:</p>
    <figure class="mediaobject"><img src="../Images/B19825_08_02.png" alt="Graphical user interface, diagram, text  Description automatically generated" width="878" height="417"/></figure>
    <p class="packt_figref">Figure 8.2: Requests being routed through an edge server</p>
    <p class="normal">In the <a id="_idIndexMarker563"/>preceding diagram, we can see how the edge server <a id="_idIndexMarker564"/>will send external requests that have a URL path that starts with <code class="inlineCode">/product-composite/</code> to the <strong class="keyWord">Product Composite</strong> microservice. The core services <strong class="keyWord">Product</strong>, <strong class="keyWord">Recommendation</strong>, and <strong class="keyWord">Review</strong> are not reachable from external clients.</p>
    <p class="normal">In <em class="chapterRef">Chapter 10</em>, <em class="italic">Using Spring Cloud Gateway to Hide Microservices Behind an Edge Server</em>, we will look at how to set up Spring Cloud Gateway with our microservices.</p>
    <p class="normal">In <em class="chapterRef">Chapter 11</em>, <em class="italic">Securing Access to APIs</em>, we will see how we can use Spring Cloud Gateway together with Spring Security OAuth2 to protect access to the edge server using OAuth 2.0 and OIDC. We will also see how Spring Cloud Gateway can propagate identity information of the caller down to our microservices, for example, the<a id="_idIndexMarker565"/> username or email address of the <a id="_idIndexMarker566"/>caller.</p>
    <p class="normal">With Spring Cloud Gateway introduced, let’s see how Spring Cloud can help to manage the configuration of a system landscape of microservices.</p>
    <h1 id="_idParaDest-228" class="heading-1">Using Spring Cloud Config for centralized configuration</h1>
    <p class="normal">To <a id="_idIndexMarker567"/>manage the configuration <a id="_idIndexMarker568"/>of a system landscape of microservices, Spring Cloud contains Spring Cloud Config, which provides the centralized management of configuration files according to the requirements described in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, in the <em class="italic">Central configuration</em> section.</p>
    <p class="normal">Spring Cloud Config supports storing configuration files in a number of different backends, such as the following:</p>
    <ul>
      <li class="bulletList">A Git repository, for example, on GitHub or Bitbucket</li>
      <li class="bulletList">A local filesystem</li>
      <li class="bulletList">HashiCorp Vault</li>
      <li class="bulletList">A JDBC database</li>
    </ul>
    <p class="normal">Spring Cloud Config allows us to handle configuration in a hierarchical structure; for example, we can place common parts of the configuration in a common file and microservice-specific settings in separate configuration files.</p>
    <p class="normal">Spring Cloud Config also supports detecting changes in the configuration and pushing notifications to the affected microservices. It uses <strong class="keyWord">Spring Cloud Bus</strong> to transport the notifications. Spring Cloud Bus is an <a id="_idIndexMarker569"/>abstraction on top of Spring Cloud Stream that we are already familiar with; that is, it supports the use of either RabbitMQ or Kafka as the messaging system for transporting notifications out of the box.</p>
    <p class="normal">The following diagram illustrates the cooperation between Spring Cloud Config, its clients, a Git repository, and Spring Cloud Bus:</p>
    <figure class="mediaobject"><img src="../Images/B19825_08_03.png" alt="Diagram, text  Description automatically generated" width="877" height="475"/></figure>
    <p class="packt_figref">Figure 8.3: How Spring Cloud Config fits into the microservice landscape</p>
    <p class="normal">The diagram shows the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">When the microservices start up, they ask the configuration server for its configuration.</li>
      <li class="numberedList">The configuration server gets the configuration from, in this case, a Git repository.</li>
      <li class="numberedList">Optionally, the Git repository can be configured to send notifications to the configuration server when Git commits are pushed to the Git repository.</li>
      <li class="numberedList">The configuration server will publish change events using Spring Cloud Bus. The <a id="_idIndexMarker570"/>microservices that are affected by the change will react and <a id="_idIndexMarker571"/>retrieve its updated configuration from the configuration server.</li>
    </ol>
    <p class="normal">Finally, Spring Cloud Config also supports the encryption of sensitive information in the configuration, such as credentials.</p>
    <p class="normal">We will learn about Spring Cloud Config in <em class="chapterRef">Chapter 12</em>, <em class="italic">Centralized Configuration</em>.</p>
    <p class="normal">With Spring Cloud Config introduced, let’s see how Spring Cloud can help make microservices more resilient to failures that happen from time to time in a system landscape.</p>
    <h1 id="_idParaDest-229" class="heading-1">Using Resilience4j for improved resilience</h1>
    <p class="normal">In a fairly large-scale system landscape of cooperating microservices, we must assume that there is something going wrong all of the time. Failures must be seen as a normal state, and the system landscape must be designed to handle it!</p>
    <p class="normal">Initially, Spring Cloud came with <a id="_idIndexMarker572"/>Netflix Hystrix, a well-proven circuit breaker. But as already mentioned above, since the Spring Cloud Greenwich release, it is recommended to replace Netflix Hystrix <a id="_idIndexMarker573"/>with <strong class="keyWord">Resilience4j</strong>. Resilience4j is an open source-based fault tolerance library. It comes with a larger range of fault tolerance mechanisms compared to Netflix Hystrix:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">A circuit breaker</strong> is <a id="_idIndexMarker574"/>used to prevent a chain of failure reaction if a remote service stops responding.</li>
      <li class="bulletList"><strong class="keyWord">A rate limiter</strong> is<a id="_idIndexMarker575"/> used to limit the number of requests to a service during a specified time period.</li>
      <li class="bulletList"><strong class="keyWord">A bulkhead</strong> is <a id="_idIndexMarker576"/>used to limit the number of concurrent requests to a service.</li>
      <li class="bulletList"><strong class="keyWord">Retries</strong> are<a id="_idIndexMarker577"/> used to handle random errors that might happen from time to time.</li>
      <li class="bulletList"><strong class="keyWord">A time limiter</strong> is <a id="_idIndexMarker578"/>used to avoid waiting too long for a response from a slow or unresponsive service.</li>
    </ul>
    <p class="normal">You can discover more <a id="_idIndexMarker579"/>about Resilience4j at <a href="https://github.com/resilience4j/resilience4j"><span class="url">https://github.com/resilience4j/resilience4j</span></a>.</p>
    <p class="normal">In <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em>, we will focus on the circuit breaker in Resilience4j. It follows the classic design of a circuit breaker, as illustrated in the following state diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_08_04.png" alt="Diagram  Description automatically generated" width="615" height="329"/></figure>
    <p class="packt_figref">Figure 8.4: Circuit breaker state diagram</p>
    <p class="normal">Let’s take a look at the<a id="_idIndexMarker580"/> state diagram in more detail:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">A circuit breaker starts as <strong class="screenText">Closed</strong>, allowing requests to be processed.</li>
      <li class="numberedList">As long as the requests are processed successfully, it stays in the <strong class="screenText">Closed</strong> state.</li>
      <li class="numberedList">If failures start to happen, a counter starts to count up.</li>
      <li class="numberedList">If a threshold of failures is reached within a specified period of time, the circuit breaker will <strong class="screenText">trip</strong>, that is, go to the <strong class="screenText">Open</strong> state, not allowing further requests to be processed. Both the threshold of failures and the period of time are configurable.</li>
      <li class="numberedList">Instead, a request will <strong class="screenText">fast fail</strong>, meaning it will return immediately with an exception.</li>
      <li class="numberedList">After a configurable period of time, the circuit breaker will enter a <strong class="screenText">Half Open</strong> state and allow one request to go through, as a probe, to see whether the failure has been resolved.</li>
      <li class="numberedList">If the probe request fails, the circuit breaker goes back to the <strong class="screenText">Open</strong> state.</li>
      <li class="numberedList">If the probe<a id="_idIndexMarker581"/> request succeeds, the circuit breaker goes to the initial <strong class="screenText">Closed</strong> state, allowing new requests to be processed.</li>
    </ol>
    <h2 id="_idParaDest-230" class="heading-2">Sample usage of the circuit breaker in Resilience4j</h2>
    <p class="normal">Let’s assume we<a id="_idIndexMarker582"/> have a REST service, called <code class="inlineCode">myService</code>, that is protected by a circuit breaker using Resilience4j.</p>
    <p class="normal">If the service starts to produce internal errors, for example, because it can’t reach a service it depends on, we might get a response from the service such as <code class="inlineCode">500 Internal Server Error</code>. After a number of configurable attempts, the circuit will open and we will get a fast failure that returns an error message such as <code class="inlineCode">CircuitBreaker 'myService' is open</code>. When the error is resolved and we make a new attempt (after the configurable wait time), the circuit breaker will allow a new attempt as a probe. If the call succeeds, the circuit breaker will be closed again; that is, operate normally.</p>
    <p class="normal">When using Resilience4j together with Spring Boot, we will be able to monitor the state of the circuit breakers in a microservice using its Spring Boot Actuator <code class="inlineCode">health</code> endpoint. We can, for example, use <code class="inlineCode">curl</code> to see the state of the circuit breaker, <code class="inlineCode">myService</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">curl $HOST:$PORT/actuator/health -s | jq .components.circuitBreakers
</code></pre>
    <p class="normal">If it operates normally, that is, the circuit is <em class="italic">closed</em>, it will respond with something such as the following:</p>
    <figure class="mediaobject"><img src="../Images/B19825_08_05.png" alt="Text  Description automatically generated" width="416" height="448"/></figure>
    <p class="packt_figref">Figure 8.5: Closed circuit response</p>
    <p class="normal">If something is wrong<a id="_idIndexMarker583"/> and the circuit is <em class="italic">open</em>, it will respond with something such as the following:</p>
    <figure class="mediaobject"><img src="../Images/B19825_08_06.png" alt="A screenshot of a computer screen  Description automatically generated with medium confidence" width="391" height="428"/></figure>
    <p class="packt_figref">Figure 8.6: Open circuit response</p>
    <p class="normal">With Resilience4j introduced, we have seen an example of how the circuit breaker can be used to handle errors for a REST client. Let’s wrap up this chapter with an introduction to how Spring Cloud can be used for distributed tracing.</p>
    <h1 id="_idParaDest-231" class="heading-1">Using Micrometer Tracing and Zipkin for distributed tracing</h1>
    <p class="normal">To<a id="_idIndexMarker584"/> understand what is going on in a distributed <a id="_idIndexMarker585"/>system such as a system landscape of cooperating <a id="_idIndexMarker586"/>microservices, it is crucial to be <a id="_idIndexMarker587"/>able to track and visualize how requests and messages flow between microservices when processing an external call to the system landscape.</p>
    <div class="packt_tip">
      <p class="normal">Refer to <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, in the <em class="italic">Distributed tracing</em> section, for more information on this subject.</p>
    </div>
    <p class="normal">Starting with <a id="_idIndexMarker588"/>Spring Boot 3, distributed tracing is handled by <strong class="keyWord">Micrometer Tracing</strong>, replacing <strong class="keyWord">Spring Cloud Sleuth</strong>. Micrometer Tracing can mark requests and <a id="_idIndexMarker589"/>messages/events that are part of the same processing flow with a common <strong class="keyWord">correlation ID</strong>.</p>
    <p class="normal">Micrometer Tracing can also be used to decorate log records with correlation IDs to make it easier to track log records from different microservices that come from the same processing flow. <strong class="keyWord">Zipkin</strong> is a <a id="_idIndexMarker590"/>distributed tracing system (<a href="http://zipkin.io"><span class="url">http://zipkin.io</span></a>) that Micrometer<a id="_idIndexMarker591"/> Tracing can send tracing data to for storage and visualization. Later on, in <em class="chapterRef">Chapter 19</em>, <em class="italic">Centralized Logging with the EFK Stack</em>, we will learn how to find and visualize log records from one and the same processing flow using the correlation ID.</p>
    <p class="normal">The infrastructure for handling distributed tracing information in Micrometer Tracing and Zipkin is originally based on Google Dapper (<a href="https://ai.google/research/pubs/pub36356"><span class="url">https://ai.google/research/pubs/pub36356</span></a>). In Dapper, the tracing information from a complete workflow is called<a id="_idIndexMarker592"/> a <strong class="keyWord">trace tree</strong>, and subparts of the tree, such as the basic units of work, are <a id="_idIndexMarker593"/>called <strong class="keyWord">spans</strong>. Spans can, in turn, consist of<a id="_idIndexMarker594"/> sub-spans, which form the trace tree. A correlation ID is called <strong class="keyWord">TraceId</strong>, and a span is identified by its own <a id="_idIndexMarker595"/>unique <strong class="keyWord">SpanId</strong>, along with the <strong class="keyWord">TraceId</strong> of the trace tree it belongs to.</p>
    <div class="note">
      <p class="normal">A short history lesson regarding the evolution of standards (or at least commons efforts on establishing open de facto standards) for implementing distributed tracing:</p>
      <p class="normal">Google published the paper on Dapper back in 2010, after using it internally since 2005.</p>
      <p class="normal">In 2016, the <strong class="keyWord">OpenTracing</strong> project joined <strong class="keyWord">CNCF</strong>. OpenTracing is heavily influenced by <a id="_idIndexMarker596"/>Dapper and <a id="_idIndexMarker597"/>provides vendor-neutral APIs and language-specific libraries for instrumenting distributed tracing.</p>
      <p class="normal">In 2019, the OpenTracing project merged with <a id="_idIndexMarker598"/>the <strong class="keyWord">OpenCensus</strong> project, forming a new<a id="_idIndexMarker599"/> CNCF project, <strong class="keyWord">OpenTelemetry</strong>. The OpenCensus project delivers a set of libraries for collecting metrics and distributed traces.</p>
      <p class="normal">Suggested URLs for further reading:</p>
      <ul>
        <li class="bulletList"><a href="https://opentracing.io"><span class="url">https://opentracing.io</span></a></li>
        <li class="bulletList"><a href="https://opencensus.io"><span class="url">https://opencensus.io</span></a></li>
        <li class="bulletList"><a href="https://opentelemetry.io"><span class="url">https://opentelemetry.io</span></a></li>
      </ul>
    </div>
    <p class="normal">In <em class="chapterRef">Chapter 14</em>, <em class="italic">Understanding Distributed Tracing</em>, we will see how we can use Micrometer<a id="_idIndexMarker600"/> Tracing and Zipkin to trace the <a id="_idIndexMarker601"/>processing that goes on in our microservice<a id="_idIndexMarker602"/> landscape. The following is a<a id="_idIndexMarker603"/> screenshot from the Zipkin UI, which visualizes the trace tree that was created as a result of processing the creation of an aggregated product:</p>
    <figure class="mediaobject"><img src="../Images/B19825_08_07.png" alt="Graphical user interface  Description automatically generated" width="878" height="1032"/></figure>
    <p class="packt_figref">Figure 8.7: Trace tree in Zipkin</p>
    <p class="normal">From the preceding screenshot, we can see that an HTTP <code class="inlineCode">POST</code> request is sent to the <strong class="keyWord">product-composite</strong> service through<a id="_idIndexMarker604"/> the gateway (our edge server) and it responds by publishing create events to the topics for products, recommendations, and reviews. These events are consumed by the three core microservices in parallel and asynchronously, meaning that the <strong class="keyWord">product-composite</strong> service does not wait for the core microservices to complete their work. The data in the create events is stored in each microservice’s database.</p>
    <p class="normal">With <a id="_idIndexMarker605"/>Micrometer Tracing and Zipkin for <a id="_idIndexMarker606"/>distributed tracing having been introduced, we<a id="_idIndexMarker607"/> have seen an example of <a id="_idIndexMarker608"/>distributed tracing of the processing of an external synchronous HTTP request that includes asynchronous passing of events between the involved microservices.</p>
    <h1 id="_idParaDest-232" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we saw how Spring Cloud has evolved from being rather Netflix OSS-centric to having a much larger scope as of today, used together with tools including Resilience4j and Micrometer Tracing. We also introduced how components from the latest release of Spring Cloud 2022 can be used to implement some of the design patterns we described in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, in the <em class="italic">Design patterns for microservices</em> section. These design patterns are required to make a landscape of cooperating microservices production ready.</p>
    <p class="normal">Head over to the next chapter to see how we can implement service discovery using Netflix Eureka and Spring Cloud LoadBalancer!</p>
    <h1 id="_idParaDest-233" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is the purpose of Netflix Eureka?</li>
      <li class="numberedList">What are the main features of Spring Cloud Gateway?</li>
      <li class="numberedList">What backends are supported by Spring Cloud Config?</li>
      <li class="numberedList">What are the capabilities that Resilience4j provides?</li>
      <li class="numberedList">What are the concepts of trace trees and spans used for in distributed tracing, and what is the paper called that originally defined them?</li>
    </ol>
  </div>
</div>
</div>
</body></html>