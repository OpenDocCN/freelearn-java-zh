<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Using Aspect-oriented Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Using Aspect-oriented Programming</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a Spring AOP aspect class</li><li class="listitem" style="list-style-type: disc">Measuring the execution time of methods using an around advice</li><li class="listitem" style="list-style-type: disc">Logging method arguments using a before advice</li><li class="listitem" style="list-style-type: disc">Logging methods' return values using an after-returning advice</li><li class="listitem" style="list-style-type: disc">Logging exceptions using an after-throwing advice</li><li class="listitem" style="list-style-type: disc">Using an after advice to clean up resources</li><li class="listitem" style="list-style-type: disc">Making a class implement an interface at runtime using an introduction</li><li class="listitem" style="list-style-type: disc">Setting the execution order of the aspects</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec122"/>Introduction</h1></div></div></div><p><span class="strong"><strong>Aspect-oriented programming</strong></span> (<span class="strong"><strong>AOP</strong></span>) is<a id="id512" class="indexterm"/> about inserting and executing, at runtime, extra pieces of code at various points of the normal execution flow of a program. In AOP terminology, these pieces of code are methods<a id="id513" class="indexterm"/> that are called <span class="strong"><strong>advices</strong></span> and the classes containing them are <a id="id514" class="indexterm"/>called <span class="strong"><strong>aspects</strong></span>. AOP is complementary to object-oriented programming.</p><p>This chapter is about the Spring AOP framework, which enables us to execute advices before and after methods of Spring beans (controller methods, service methods, and so on). For more extensive AOP functionality, <span class="strong"><strong>AspectJ</strong></span> is <a id="id515" class="indexterm"/>the reference Java AOP framework and gets integrated seamlessly with Spring. However, it's more complex to use and requires a customized compilation process.</p><p>In the first recipe, we will create an aspect class and configure Spring to use it. We will use this aspect class in the following recipes, where we will go through the different types of advice offered by Spring AOP, using practical use cases.</p></div></div>
<div class="section" title="Creating a Spring AOP aspect class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec123"/>Creating a Spring AOP aspect class</h1></div></div></div><p>In this recipe, we will create an aspect class and configure Spring to use it. We will use this aspect class and its configuration code in the following recipes.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec291"/>How to do it…</h2></div></div></div><p>Here are<a id="id516" class="indexterm"/> the steps for creating an aspect class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the the AspectJ Weaver Maven dependency in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;version&gt;1.8.5&lt;/version&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">Create a Java package for the aspects of your application. For example, <code class="literal">com.springcookbook.aspect</code>.</li><li class="listitem">In your aspects package, create a class annotated with <code class="literal">@Component</code> and <code class="literal">@Aspect</code>:<div class="informalexample"><pre class="programlisting">@Component
@Aspect
public class Aspect1 {

}</pre></div></li><li class="listitem">In the Spring configuration, add <code class="literal">@EnableAspectJAutoProxy</code> and your aspects package to <code class="literal">@ComponentScan</code>:<div class="informalexample"><pre class="programlisting">@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages = {"com.spring_cookbook.controllers", "com.spring_cookbook.aspect"})
public class AppConfig {
...  
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec292"/>How it works…</h2></div></div></div><p>The AspectJ Weaver Maven dependency provides aspect annotations, so we can use regular Java <a id="id517" class="indexterm"/>classes to define aspects.</p><p>In the aspect class, <code class="literal">@Aspect</code> declares the class as an aspect. <code class="literal">@Component</code> allows it to be detected by Spring and instantiated as a bean.</p><p>In the Spring configuration, we included our aspect package in <code class="literal">@ComponentScan</code>, so the <code class="literal">@Component</code> classes in that package will be detected and instantiated as beans by Spring. <code class="literal">@EnableAspectJAutoProxy</code> in the Spring configuration will make Spring actually use the aspects and execute their advices.</p></div></div>
<div class="section" title="Measuring the execution time of methods using an around advice"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec124"/>Measuring the execution time of methods using an around advice</h1></div></div></div><p>An <span class="strong"><strong>around advice</strong></span> is the most powerful type of advice; it can completely replace the target method by some different code. In this recipe, we will use it only to execute some extra <a id="id518" class="indexterm"/>code before and after the target method. With the before code, we will get the current time. With the after code, we will get the current time again, and will compare it to the previous time to calculate the total time the target method took to execute. Our target methods will be the controller methods<a id="id519" class="indexterm"/> of the controller classes in the controller package.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec293"/>Getting ready</h2></div></div></div><p>We will use the aspect class defined in the previous recipe, <span class="emphasis"><em>Creating a Spring AOP aspect class</em></span>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec294"/>How to do it…</h2></div></div></div><p>Here are the steps for measuring the execution time of controller methods:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the aspect class, create an advice method annotated with <code class="literal">@Around</code> and take <code class="literal">ProceedingJoinPoint</code> as an argument:<div class="informalexample"><pre class="programlisting">@Around("execution(* com.spring_cookbook.controllers.*.*(..))")
public Object doBasicProfiling(ProceedingJoinPoint joinPoint) throws Throwable {
...
}</pre></div></li><li class="listitem">In that advice method, measure the execution time of the target method:<div class="informalexample"><pre class="programlisting">Long t1 = System.currentTimeMillis();
Object returnValue = joinPoint.proceed();
Long t2 = System.currentTimeMillis();        
Long executionTime = t2 - t1;</pre></div></li><li class="listitem">Log <a id="id520" class="indexterm"/>that execution time preceded by the target method name:<div class="informalexample"><pre class="programlisting">String className = joinPoint.getSignature().getDeclaringTypeName();
String methodName = joinPoint.getSignature().getName();
System.out.println(className + "." + methodName + "() took " + executionTime + " ms");</pre></div></li><li class="listitem">Return<a id="id521" class="indexterm"/> the return value of the target method:<div class="informalexample"><pre class="programlisting">return returnValue;</pre></div></li><li class="listitem">To test the advice, you can use a controller method that takes a long time on purpose:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public void userList() throws Exception {
  try {
      Thread.sleep(2500);  // wait 2.5 seconds
  } catch(InterruptedException ex) {
      Thread.currentThread().interrupt();
  }
}</pre></div></li><li class="listitem">Test whether it's working. When going to <code class="literal">/user_list</code> in your browser, you should see this in your server log:<div class="informalexample"><pre class="programlisting">com.spring_cookbook.controllers.UserController.userList() took 2563 ms</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec295"/>How it works…</h2></div></div></div><p>The <code class="literal">@Around</code> annotation preceding the advice method is a pointcut expression:</p><div class="informalexample"><pre class="programlisting">@Around("execution(* com.spring_cookbook.controllers.*.*(..))")</pre></div><p>A pointcut expression determines the target methods (the methods to which the advice will be applied). It works like a regular expression. Here, it matches all controller methods. In detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">execution()</code> means we are targeting a method execution</li><li class="listitem" style="list-style-type: disc">The first asterisk means <span class="emphasis"><em>any return type</em></span></li><li class="listitem" style="list-style-type: disc">The second asterisk means <span class="emphasis"><em>any class</em></span> (from the <code class="literal">com.spring_cookbook.controllers</code> package)</li><li class="listitem" style="list-style-type: disc">The third asterisk means <span class="emphasis"><em>any method</em></span></li><li class="listitem" style="list-style-type: disc"><code class="literal">(..)</code> means <span class="emphasis"><em>any number of method arguments of any type</em></span></li></ul></div><p>The <code class="literal">joinPoint.proceed()</code> instruction executes<a id="id522" class="indexterm"/> the target<a id="id523" class="indexterm"/> method. Skipping this will skip the execution of the target method. A <span class="strong"><strong>join point</strong></span> is another AOP term. It's a moment in the execution flow of the program where an advice can be <a id="id524" class="indexterm"/>executed. With Spring AOP, a join point always designates a target method. To summarize, an advice method is applied at different join points, which are identified by a pointcut expression.</p><p>We also use the <code class="literal">joinPoint</code> object to get the name of the current target method:</p><div class="informalexample"><pre class="programlisting">String className = joinPoint.getSignature().getDeclaringTypeName();
String methodName = joinPoint.getSignature().getName();</pre></div></div></div>
<div class="section" title="Logging method arguments using a before advice"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec125"/>Logging method arguments using a before advice</h1></div></div></div><p>A <span class="strong"><strong>before advice</strong></span> executes some extra code before the execution of the target method. In this recipe, we will log the arguments of the target method.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec296"/>Getting ready</h2></div></div></div><p>We will <a id="id525" class="indexterm"/>use the aspect class defined in<a id="id526" class="indexterm"/> the <span class="emphasis"><em>Creating a Spring AOP aspect class</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec297"/>How to do it…</h2></div></div></div><p>Here are the steps for logging the methods' arguments using a before advice:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your aspect class, create an advice method annotated with <code class="literal">@Before</code> and take <code class="literal">JoinPoint</code> as an argument:<div class="informalexample"><pre class="programlisting">@Before("execution(* com.spring_cookbook.controllers.*.*(..))")
public void logArguments(JoinPoint joinPoint) {
...
}</pre></div></li><li class="listitem">In that method, get the list of arguments of the target method:<div class="informalexample"><pre class="programlisting">Object[] arguments = joinPoint.getArgs();</pre></div></li><li class="listitem">Log the list of arguments preceded by the target method name:<div class="informalexample"><pre class="programlisting">String className = joinPoint.getSignature().getDeclaringTypeName();
String methodName = joinPoint.getSignature().getName();
System.out.println("-----" + className + "." + methodName + "() -----");

for (int i = 0; i &lt; arguments.length; i++) {
  System.out.println(arguments[i]);
}</pre></div></li><li class="listitem">Test<a id="id527" class="indexterm"/> the advice using a controller<a id="id528" class="indexterm"/> method with arguments:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public String userList(Locale locale, WebRequest request) {
...
}</pre></div></li><li class="listitem">Check whether it's working. When going to <code class="literal">/user_list</code> in your browser, you should see this in your server log:<div class="informalexample"><pre class="programlisting">-----
com.spring_cookbook.controllers.UserController.userList()
-----
en_US
ServletWebRequest:
uri=/spring_webapp/user_list;client=10.0.2.2</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec298"/>How it works…</h2></div></div></div><p>The <code class="literal">@Before</code> annotation preceding the advice method is a pointcut expression:</p><div class="informalexample"><pre class="programlisting">@Before("execution(* com.spring_cookbook.controllers.*.*(..))")</pre></div><p>Refer to the <span class="emphasis"><em>Measuring the execution time of methods using an around advice</em></span> recipe for more details.</p><p>The <code class="literal">joinPoint.getArgs()</code> instruction retrieves the argument's values of the target method.</p></div></div>
<div class="section" title="Logging methods' return values using an after-returning advice"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec126"/>Logging methods' return values using an after-returning advice</h1></div></div></div><p>An <a id="id529" class="indexterm"/>
<span class="strong"><strong>after-returning advice</strong></span> executes some extra code after the successful execution of the target method. In this recipe, we will log the return value of the target method.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec299"/>Getting ready</h2></div></div></div><p>We will <a id="id530" class="indexterm"/>use the aspect class defined in the <span class="emphasis"><em>Creating a Spring AOP aspect class</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec300"/>How to do it…</h2></div></div></div><p>Here are the steps for logging the return value of methods using an after-returning advice:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your aspect class, create an advice method annotated with <code class="literal">@AfterReturning</code>. Make it take a <code class="literal">JoinPoint</code> object and the return value of the target method as arguments:<div class="informalexample"><pre class="programlisting">@AfterReturning(pointcut="execution(* com.spring_cookbook.controllers.*.*(..))", returning="returnValue")
public void logReturnValue(JoinPoint joinPoint, Object returnValue) {
...
}</pre></div></li><li class="listitem">In that advice method, log the return value preceded by the target method name:<div class="informalexample"><pre class="programlisting">String className = joinPoint.getSignature().getDeclaringTypeName();
String methodName = joinPoint.getSignature().getName();
System.out.println("-----" + className + "." + methodName + "() -----");
System.out.println("returnValue=" + returnValue);</pre></div></li><li class="listitem">Test the advice using a controller method that returns a value:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public String userList() {
  return "just a test";
}</pre></div></li><li class="listitem">Check whether it's working. When going to <code class="literal">/user_list</code> in your browser, you should see the following in your server log:<div class="informalexample"><pre class="programlisting">-----
com.spring_cookbook.controllers.UserController.userList()
-----
returnValue=just a test</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec301"/>How it works…</h2></div></div></div><p>The <code class="literal">@AfterReturning</code> annotation preceding the advice method is a pointcut expression:</p><div class="informalexample"><pre class="programlisting">@AfterReturning(pointcut="execution(* com.spring_cookbook.controllers.*.*(..))", returning="returnValue")</pre></div><p>Refer<a id="id531" class="indexterm"/> to the <span class="emphasis"><em>Measuring the execution time of methods using an around advice</em></span> recipe for more details. The <code class="literal">returning</code> attribute is the name of the argument of the advice method to be used for the<a id="id532" class="indexterm"/> return value.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Note that if an exception is thrown during the execution of the target method, the after-returning advice won't be executed.</p></div></div></div></div>
<div class="section" title="Logging exceptions using an after-throwing advice"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec127"/>Logging exceptions using an after-throwing advice</h1></div></div></div><p>An <span class="strong"><strong>after-throwing advice</strong></span> executes some extra code when an exception is thrown during the <a id="id533" class="indexterm"/>execution of the target method. In <a id="id534" class="indexterm"/>this recipe, we will just log the exception.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec302"/>Getting ready</h2></div></div></div><p>We will use the aspect class defined in the <span class="emphasis"><em>Creating a Spring AOP aspect class</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec303"/>How to do it…</h2></div></div></div><p>Here are the steps for logging an exception using an after-throwing advice:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your aspect class, create an advice method annotated with <code class="literal">@AfterThrowing</code>. Make it take a <code class="literal">JoinPoint</code> object and an <code class="literal">Exception</code> object as arguments:<div class="informalexample"><pre class="programlisting">@AfterThrowing(pointcut="execution(* com.spring_cookbook.controllers.*.*(..))", throwing="exception")
public void logException(JoinPoint joinPoint, Exception exception) {
...
}</pre></div></li><li class="listitem">In that advice method, log the exception preceded by the target method name:<div class="informalexample"><pre class="programlisting">String className = joinPoint.getSignature().getDeclaringTypeName();
String methodName = joinPoint.getSignature().getName();
System.out.println("-----" + className + "." + methodName + "() -----");
System.out.println("exception message:" + exception.getMessage());</pre></div></li><li class="listitem">Test <a id="id535" class="indexterm"/>the advice using a controller<a id="id536" class="indexterm"/> method throwing an exception:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public String userList() throws Exception  {
  throw new Exception("a bad exception");
}</pre></div></li><li class="listitem">Check whether it's working. When going to <code class="literal">/user_list</code> in your browser, you should see the following in your server log:<div class="informalexample"><pre class="programlisting">-----
com.spring_cookbook.controllers.UserController.userList()
-----
exception message:a bad exception</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec304"/>How it works…</h2></div></div></div><p>The <code class="literal">@AfterThrowing</code> annotation preceding the advice method is a pointcut expression:</p><div class="informalexample"><pre class="programlisting">@AfterThrowing(pointcut="execution(* com.spring_cookbook.controllers.*.*(..))", throwing="exception")</pre></div><p>Refer to the <span class="emphasis"><em>Measuring the execution time of methods using an around advice</em></span> recipe for more details. The <code class="literal">throwing</code> attribute is the name of the argument of the advice method to be used for the exception object thrown by the target method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Note that if no exception is thrown during the execution of the target method, the after-throwing advice won't be executed.</p></div></div></div></div>
<div class="section" title="Using an after advice to clean up resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec128"/>Using an after advice to clean up resources</h1></div></div></div><p>An <span class="strong"><strong>after advice</strong></span> executes some extra code after the execution of the target method, even if an<a id="id537" class="indexterm"/> exception is thrown during its execution. Use this advice to clean up resources by removing a temporary file or closing a <a id="id538" class="indexterm"/>database connection. In this recipe, we will just log the target method name.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec305"/>Getting ready</h2></div></div></div><p>We will use the aspect class defined in the <span class="emphasis"><em>Creating a Spring AOP aspect class</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec306"/>How to do it…</h2></div></div></div><p>Here are the steps for using an after advice:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your aspect class, create an advice method annotated with <code class="literal">@After</code>. Make it take <code class="literal">JoinPoint</code> as an argument:<div class="informalexample"><pre class="programlisting">@After("execution(* com.spring_cookbook.controllers.*.*(..))")
public void cleanUp(JoinPoint joinPoint) {
...
}</pre></div></li><li class="listitem">In that advice method, log the target method name:<div class="informalexample"><pre class="programlisting">String className = joinPoint.getSignature().getDeclaringTypeName();
String methodName = joinPoint.getSignature().getName();
System.out.println("-----" + className + "." + methodName + "() -----");</pre></div></li><li class="listitem">Test the advice using two controller methods: one executes normally and the other one throws an exception:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public String userList() {
  return "method returning normally";
}

@RequestMapping("user_list2")
@ResponseBody
public String userList2() throws Exception  {
  throw new Exception("just a test");
}</pre></div></li><li class="listitem">Check whether it's working. When going to <code class="literal">/user_list</code> or <code class="literal">/user_list2</code> in your browser, you should see this in your server log:<div class="informalexample"><pre class="programlisting">-----
com.spring_cookbook.controllers.UserController.userList()
-----</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec307"/>How it works…</h2></div></div></div><p>The <code class="literal">@After</code> annotation<a id="id539" class="indexterm"/> preceding the advice method is a pointcut expression:</p><div class="informalexample"><pre class="programlisting">@After("execution(* com.spring_cookbook.controllers.*.*(..))")</pre></div><p>Refer<a id="id540" class="indexterm"/> to the <span class="emphasis"><em>Measuring the execution time of methods using an around advice</em></span> recipe for more details.</p></div></div>
<div class="section" title="Making a class implement an interface at runtime using an introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec129"/>Making a class implement an interface at runtime using an introduction</h1></div></div></div><p>An <span class="strong"><strong>introduction</strong></span> allows us to make a Java class (we will refer to it as the <span class="emphasis"><em>target class</em></span>) implement<a id="id541" class="indexterm"/> an interface at runtime. With Spring AOP, introductions can be applied only to Spring beans (controllers, services, and so on). In this recipe, we will create an interface, its implementation, and <a id="id542" class="indexterm"/>make a Spring controller implement that interface at runtime using that implementation. To check whether it's working, we will also add a before advice to the controller method to execute a method from the interface implementation.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec308"/>Getting ready</h2></div></div></div><p>We will use the aspect class defined in the <span class="emphasis"><em>Creating a Spring AOP aspect class</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec309"/>How to do it…</h2></div></div></div><p>Here are the steps for using an introduction:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">Logging</code> interface:<div class="informalexample"><pre class="programlisting">public interface Logging {
  public void log(String str);
}</pre></div></li><li class="listitem">Create an implementation class for it:<div class="informalexample"><pre class="programlisting">public class LoggingConsole implements Logging {

  public void log(String str) {
    System.out.println(str);
  }
}</pre></div></li><li class="listitem">In your<a id="id543" class="indexterm"/> aspect <a id="id544" class="indexterm"/>class, add a <code class="literal">Logging</code> attribute annotated with <code class="literal">@DeclareParents</code>. Add the implementation class to <code class="literal">@DeclareParents</code>:<div class="informalexample"><pre class="programlisting">@DeclareParents(value = "com.spring_cookbook.controllers.*+", defaultImpl = LoggingConsole.class)
public static Logging mixin;</pre></div></li><li class="listitem">Add an advice method annotated with <code class="literal">@Before</code>. Make it take a <code class="literal">Logging</code> object as an argument:<div class="informalexample"><pre class="programlisting">@Before("execution(* com.spring_cookbook.controllers.*.*(..)) &amp;&amp; this(logging)")
public void logControllerMethod(Logging logging) {
...
}</pre></div></li><li class="listitem">In the advice method, use the <code class="literal">Logging</code> object:<div class="informalexample"><pre class="programlisting">logging.log("this is displayed just before a controller method is executed.");</pre></div></li><li class="listitem">Test whether it's working with a standard controller method:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public String userList() {
  return "method returning normally";
}</pre></div></li><li class="listitem">Check whether it's working. When going to <code class="literal">/user_list</code> in your browser, you should see the following in your server log:<div class="informalexample"><pre class="programlisting">this is displayed just before a controller method is executed.</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec310"/>How it works…</h2></div></div></div><p>In the aspect class, the <code class="literal">@DeclareParents</code> annotation preceding the Logging attribute is a pointcut expression:</p><div class="informalexample"><pre class="programlisting">@DeclareParents(value = "com.spring_cookbook.controllers.*+", defaultImpl = LoggingConsole.class)</pre></div><p>This pointcut expression and the <code class="literal">Logging</code> attribute define that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The introduction will be applied to all controller classes: <code class="literal">com.spring_cookbook.controllers.*+</code></li><li class="listitem" style="list-style-type: disc">The introduction will make these controller classes implement the Logging interface: <code class="literal">public static Logging mixin;</code></li><li class="listitem" style="list-style-type: disc">The introduction will make these controller classes use <code class="literal">LoggingConsole</code> as implementation of the Logging interface: <code class="literal">defaultImpl = LoggingConsole.class</code></li></ul></div><p>The before <a id="id545" class="indexterm"/>advice works the <a id="id546" class="indexterm"/>same way as in the <span class="emphasis"><em>Measuring the execution time of methods using an around advice</em></span> recipe. It only takes one extra condition:</p><div class="informalexample"><pre class="programlisting">this(logging)</pre></div><p>This means that the advice will be applied only to objects that implement the Logging interface.</p></div></div>
<div class="section" title="Setting the execution order of the aspects"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec130"/>Setting the execution order of the aspects</h1></div></div></div><p>When using<a id="id547" class="indexterm"/> several aspect classes, it can be necessary to set the order in which the aspects are executed. In this recipe, we will use two aspect classes with before advices targeting controller methods.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec311"/>Getting ready</h2></div></div></div><p>We will use the configuration from the <span class="emphasis"><em>Creating a Spring AOP aspect class</em></span> recipe.</p><p>We will use these two aspect classes containing an advice, which logs some text when it's executed:</p><div class="informalexample"><pre class="programlisting">@Component
@Aspect
public class Aspect1 {

  @Before("execution(* com.spring_cookbook.controllers.*.*(..))")
  public void advice1() {  
    System.out.println("advice1");
  }

}

@Component
@Aspect
public class Aspect2 {

  @Before("execution(* com.spring_cookbook.controllers.*.*(..))")
  public void advice2() {  
    System.out.println("advice2");
  }

}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec312"/>How to do it…</h2></div></div></div><p>Here are<a id="id548" class="indexterm"/> the steps to set the execution order of the two aspect classes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add <code class="literal">@Order</code> with a number as parameter to the first aspect:<div class="informalexample"><pre class="programlisting">@Component
@Aspect
@Order(1)
public class Aspect1 {</pre></div></li><li class="listitem">Add <code class="literal">@Order</code> with another number as parameter to the second aspect:<div class="informalexample"><pre class="programlisting">@Component
@Aspect
@Order(2)
public class Aspect2 {</pre></div></li><li class="listitem">Test whether it's working. When going to <code class="literal">/user_list</code> in your browser, you should see this in your server log:<div class="informalexample"><pre class="programlisting">advice1
advice2</pre></div></li><li class="listitem">Switch the <code class="literal">@Order</code> numbers and check whether the execution order is changed:<div class="informalexample"><pre class="programlisting">advice2
advice1</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec313"/>How it works…</h2></div></div></div><p>The aspects are executed in the ascending order set by <code class="literal">@Order</code>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec314"/>There's more…</h2></div></div></div><p>It's not possible to set an order between advice methods of the same aspect class. If it becomes necessary, create new aspect classes for those advices.</p></div></div></body></html>