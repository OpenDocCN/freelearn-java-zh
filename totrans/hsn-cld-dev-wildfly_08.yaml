- en: Scaling and Connecting Your Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展和连接你的服务
- en: In this chapter, we will look in greater detail at the process of deploying,
    scaling, and connecting your applications. In [Chapter 6](461aee71-984a-4158-addc-fc49341d3455.xhtml),
    *Deploying Applications on the Cloud with OpenShift*, you have already learned
    the basic information about deploying services to the OpenShift cloud. Now it's
    time to extend this knowledge and learn how to use it in practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地探讨部署、扩展和连接应用程序的过程。在[第6章](461aee71-984a-4158-addc-fc49341d3455.xhtml)，“使用OpenShift在云上部署应用程序”，你已经学习了将服务部署到OpenShift云的基本信息。现在，是时候扩展这些知识并学习如何在实践中应用它们了。
- en: Let's start with deployments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从部署开始。
- en: Deployments
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: Let's examine what happens under the hood during deployment of our services.
    We are going to continue work on an example from the previous chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查在部署我们的服务时幕后发生了什么。我们将继续之前章节中的示例进行工作。
- en: 'Examples reference: `chapter8/catalog-service-openshift-load-balancing`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter8/catalog-service-openshift-load-balancing`。
- en: 'You have to open the web console, and navigate to Applications| Deployments
    | catalog-service:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要打开Web控制台，并导航到应用程序|部署|catalog-service：
- en: '![](img/9cd46b6b-7ca7-4fca-bd03-009c0bcf94ce.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cd46b6b-7ca7-4fca-bd03-009c0bcf94ce.png)'
- en: Now we will be able to see the deployment configuration. This is the graphical
    representation of OpenShift's `DeploymentConfiguration` object.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够看到部署配置。这是OpenShift的`DeploymentConfiguration`对象的图形表示。
- en: As you learned in [Chapter 6](461aee71-984a-4158-addc-fc49341d3455.xhtml), *Deploying
    Applications on the Cloud with OpenShift*, OpenShift adds another layer on top
    of Kubernetes to provide a more convenient and productive programmer experience.
    It does that, among other things, by extending the object model of Kubernetes.
    `DeploymentConfiguration` and Deployments are OpenShift objects that extend the
    Kubernetes object model.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第6章](461aee71-984a-4158-addc-fc49341d3455.xhtml)，“使用OpenShift在云上部署应用程序”中学到的，OpenShift在Kubernetes之上添加了另一层，以提供更方便、更高效的编程体验。它通过扩展Kubernetes的对象模型来实现这一点。`DeploymentConfiguration`和Deployments是扩展Kubernetes对象模型的OpenShift对象。
- en: The `DeploymentConfiguration` object manages the creation of the Deployments
    objects. It contains all the necessary information to create Deployments, which,
    as its name suggests, represents an instance of deployment. When one of the Deployments
    triggers happens, the old deployment object is replaced by the new one. All of
    the deployment objects are based on `DeploymentConfiguration`. Deployments, among
    others, encapsulate Kubernetes's `ReplicationController` object. Let's understand
    it in greater detail.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeploymentConfiguration`对象管理Deployments对象的创建。它包含创建Deployments所需的所有必要信息，正如其名称所暗示的，它代表了一个部署实例。当一个Deployments触发器发生时，旧的部署对象将被新的对象替换。所有的部署对象都基于`DeploymentConfiguration`。Deployments，以及其他对象，封装了Kubernetes的`ReplicationController`对象。让我们更深入地理解它。'
- en: Learning the basics of ReplicationController
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习ReplicationController的基础知识
- en: '`ReplicationController` contains the following information: the pod template,
    selector, and the number of replicas. Let''s examine those further.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplicationController`包含以下信息：Pod模板、选择器和副本数量。让我们进一步探讨这些内容。'
- en: The pod template is basically a pod definition. It contains information about
    the containers, volumes, ports, and labels. Every pod created by this replication
    controller will be started using this pod template. The selector is used to determine
    which pods are governed by this `ReplicationController`. Finally, the number of
    replicas is the number of pods that we want to be running.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Pod模板基本上是一个Pod定义。它包含有关容器、卷、端口和标签的信息。由这个复制控制器创建的每个Pod都将使用这个Pod模板启动。选择器用于确定哪些Pod受此`ReplicationController`管理。最后，副本数量是我们希望运行的Pod数量。
- en: 'Kubernetes works in the following way: it monitors the current state of the
    cluster, and if that state is different from the desired state it takes actions
    so that the desired state is restored. The same thing happens with `ReplicationControllers`.
    `ReplicationController` continuously monitors the number of pods that are associated
    with it. If the number of the pods is different than the desired number, it starts
    or stops pods so that the desired state is restored. The pod is started using
    the pod template.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的工作方式如下：它监控集群的当前状态，如果该状态与期望状态不同，它将采取行动以恢复期望状态。同样的事情也发生在`ReplicationControllers`上。`ReplicationController`持续监控与其关联的Pod数量。如果Pod的数量与期望的数量不同，它将启动或停止Pod以恢复期望状态。Pod是通过Pod模板启动的。
- en: 'Let''s examine the `ReplicationController` that Kubernetes created for our
    catalog-service. To do this, we will use the CLI:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查Kubernetes为我们的catalog-service创建的`ReplicationController`。为此，我们将使用CLI：
- en: '![](img/e9048a8c-5ec5-4be4-9a53-6c0c4fff0465.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9048a8c-5ec5-4be4-9a53-6c0c4fff0465.png)'
- en: As you will notice in the preceding screenshot, there are three replication
    controllers created for catalog-service. This is the case because of each redeployment
    of the application results in the creation of a new deployment object with its
    own replication controller. Note that only catalog-service-3 has the desired number
    of instances greater than 0—the previous deployments have been made inactive when
    the new deployment was taking place.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中将注意到的，为catalog-service创建了三个复制控制器。这种情况是因为每次应用程序重新部署都会导致创建一个新的部署对象及其自己的复制控制器。请注意，只有catalog-service-3的期望实例数大于0——当新的部署正在进行时，之前的部署已被设置为不活动状态。
- en: 'Let''s take a look at the description of the active controller:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看活动控制器的描述：
- en: '![](img/991f5556-3a23-416b-9029-9fbfcf65d9e5.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/991f5556-3a23-416b-9029-9fbfcf65d9e5.png)'
- en: 'The selector has three labels: app, deployment, and deployment-config. It unambiguously
    identifies the pods associated with the given deployment.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器有三个标签：app、deployment和deployment-config。它明确地识别了与给定部署关联的Pod。
- en: Exactly the same labels are used in the pod template. Other parts of the pod
    template contain the image from which the container is built, and the environment
    variables that we provided during the creation of the service. Finally, the number
    of current and desired replicas is set, by default, to one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Pod模板中使用了完全相同的标签。Pod模板的其他部分包含构建容器的镜像，以及我们在创建服务时提供的环境变量。最后，当前和期望副本的数量默认设置为1。
- en: 'OK. So how do we scale our service so that it runs on more than one instance?
    Let''s move to the web console again. We need to navigate to Application | Deployments
    again and enter the catalog-service configuration:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们如何扩展我们的服务，使其在多个实例上运行？让我们再次转到Web控制台。我们需要再次导航到应用程序 | 部署，并输入catalog-service配置：
- en: '![](img/b723deee-6a03-417f-9635-512df87f04f7.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b723deee-6a03-417f-9635-512df87f04f7.png)'
- en: To scale the catalog-service application, we have to adjust the Replicas field
    to the number of instances that we want to have. That's it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展catalog-service应用程序，我们必须将副本字段调整为我们想要的实例数量。就是这样。
- en: 'When we look at the `ReplicationControllers` in the `oc`, we will see the following
    information:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`oc`中查看`ReplicationControllers`时，我们将看到以下信息：
- en: '![](img/7ab5e556-694f-4204-a573-6256888f291a.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ab5e556-694f-4204-a573-6256888f291a.png)'
- en: 'The number of pods has been changed to 5\. As we saw in the `oc` output, additional
    pods have been started and we now have five instances. Let''s check in the console
    (navigate to Applications | Pods):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的数量已更改为5。正如我们在`oc`输出中看到的，已经启动了额外的Pod，我们现在有五个实例。让我们检查控制台（导航到应用程序 | Pods）：
- en: '![](img/870f86c6-83b8-4afa-b501-20d33e004397.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/870f86c6-83b8-4afa-b501-20d33e004397.png)'
- en: OpenShift has indeed scaled our application according to our needs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift确实根据我们的需求扩展了我们的应用程序。
- en: 'After having worked with OpenShift for some time, you should be able to see
    what we meant in [Chapter 6](461aee71-984a-4158-addc-fc49341d3455.xhtml), *Deploying
    Applications on the Cloud with OpenShift*, when we wrote that OpenShift builds
    an effective and easy-to-use application development environment on top of Kubernetes.
    The preceding example showed how it works very well: Kubernetes is responsible
    for making sure that the state of the cluster equals the description provided.
    In the preceding example, this description is provided by a `ReplicationController`
    object (which is part of the Kubernetes object model). Note, however, that OpenShift
    has abstracted away all the nitty-gritty details from us. We have only provided
    the information such as the address of the code repository or number of replicas
    that we want to have. The OpenShift layer abstracts away the technical details
    of cluster configuration and provides us with convenient, easy-to-use tools, which
    allow the programmer to concentrate on the development.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用OpenShift一段时间后，你应该能够理解我们在[第6章](461aee71-984a-4158-addc-fc49341d3455.xhtml)，“使用OpenShift在云上部署应用程序”中所说的意思，当我们写道OpenShift在Kubernetes之上构建了一个有效且易于使用的应用程序开发环境。前面的例子展示了它如何很好地工作：Kubernetes负责确保集群的状态等于提供的描述。在前面的例子中，这个描述是由一个`ReplicationController`对象（它是Kubernetes对象模型的一部分）提供的。然而，请注意，OpenShift已经为我们抽象掉了所有繁琐的细节。我们只提供了诸如代码仓库的地址或我们想要有多少副本等信息。OpenShift层抽象掉了集群配置的技术细节，并为我们提供了方便、易于使用的工具，使程序员能够专注于开发。
- en: Let's return to our main topic. The next thing that we will configure is **load
    balancing**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的主要话题。接下来我们将配置的是**负载均衡**。
- en: Load balancing
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: We have just learned how to scale our service. The next natural step is to configure
    the load balancer. The good news is that OpenShift will do most of the stuff automatically
    for us.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何扩展我们的服务。下一步自然的步骤是配置负载均衡器。好消息是OpenShift会为我们自动完成大部分工作。
- en: In [Chapter 6](461aee71-984a-4158-addc-fc49341d3455.xhtml), *Deploying Applications
    on the Cloud with OpenShift*, where we introduced services, we learned that a
    service is reached using a virtual cluster IP. To understand how load balancing
    works, let's understand how cluster IP is implemented.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](461aee71-984a-4158-addc-fc49341d3455.xhtml)，“使用OpenShift在云上部署应用程序”，我们介绍了服务，我们了解到服务是通过虚拟集群IP来访问的。为了理解负载均衡是如何工作的，让我们来了解集群IP是如何实现的。
- en: As we have also learned here, each node in a Kubernetes cluster runs a bunch
    of services, which allow a cluster to provide its functionality. One of those
    services is **kube-proxy**. Kube-proxy runs on every node and is, among other
    things, responsible for service implementation. Kube-proxy continuously monitors
    the object model describing the cluster and gathers information about currently
    active services and pods on which those services run. When the new service appears,
    kube-proxy modifies the iptables rules so that the virtual cluster's IP is routed
    to one of the available pods. The iptables rules are created so that the choice
    of the pod is random. Also, note that those IP rules have to be constantly rewritten
    to match the current state of the cluster.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里学到的那样，Kubernetes集群中的每个节点都运行了一组服务，这些服务允许集群提供其功能。其中之一就是**kube-proxy**。kube-proxy在每个节点上运行，并且负责服务实现。kube-proxy持续监控描述集群的对象模型，并收集关于当前活动服务和运行这些服务的Pod的信息。当新的服务出现时，kube-proxy修改iptables规则，以便虚拟集群的IP被路由到可用的Pod之一。iptables规则被创建为随机选择Pod。此外，请注意，这些IP规则必须不断重写以匹配集群的当前状态。
- en: A kube-proxy runs on every node of the cluster. Owing to that, on each node,
    there is a set of iptables rules, which forward the package to the appropriate
    pods. As a result, the service is accessible from each node of the cluster on
    its virtual cluster IP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy在每个集群节点上运行。正因为如此，在每个节点上，都有一组iptables规则，这些规则将数据包转发到适当的Pod。因此，服务可以通过集群的每个节点在其虚拟集群IP上访问。
- en: What's the implication of that from the client service perspective? The cluster
    infrastructure is hidden from the service client. The client doesn't need to have
    any knowledge about nodes, pods, and their dynamic movement inside the cluster.
    They just invoke the service using its IP as if it was a physical host.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端服务的角度来看，这意味着什么呢？集群基础设施对服务客户端是隐藏的。客户端不需要了解任何关于节点、Pod以及它们在集群内部的动态移动。他们只需使用其IP调用服务，就像它是一个物理主机一样。
- en: 'Let''s return to our example and look at the load balancing of our host. Let''s
    return to the example in which we are working within this chapter. We statically
    scaled our catalog service to five instances. Let''s enter the web console in
    order to look at all the pods on which the application currently runs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的示例，看看我们主机的负载均衡。让我们回到本章中我们正在工作的示例。我们静态地将目录服务扩展到五个实例。让我们进入网页控制台，查看当前运行应用程序的所有
    pod：
- en: '![](img/6969b4f4-2a1f-4af4-b46b-c496a13cd544.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6969b4f4-2a1f-4af4-b46b-c496a13cd544.png)'
- en: 'Let''s trace to which pods are the requests forwarded. In order to achieve
    that, we implemented a simple REST filter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们追踪请求转发到哪些 pod。为了实现这一点，我们实现了一个简单的 REST 过滤器：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding filter adds a `"pod"` property to the response headers. The filter
    will be evaluated after the response is processed (1). On each pod, there is a
    `"HOSTNAME"` environment variable set. We can use this variable and add it to
    the response metadata (2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的过滤器会在响应处理完毕后（1）向响应头添加一个 `"pod"` 属性。该过滤器将在响应处理完毕后进行评估。在每一个 pod 上，都设置了一个 `"HOSTNAME"`
    环境变量。我们可以使用这个变量并将其添加到响应元数据中（2）。
- en: 'As a result, we are ready to trace the load balancing:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们准备好追踪负载均衡：
- en: '![](img/7eecbe42-793c-4170-890a-a21a339d2987.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7eecbe42-793c-4170-890a-a21a339d2987.png)'
- en: In the preceding screenshot, note that the request is being automatically load
    balanced among the available pods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，请注意请求正在自动在可用的 pod 之间进行负载均衡。
- en: Service discovery
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: We have already shown you how to configure balancing for our application. We
    know now that you have access to the virtual cluster IP address behind which the
    request is being balanced by OpenShift. However, how do we actually know how to
    connect to our services? We are going to learn that in the next topic. Before
    we do that, we must introduce our new services that will be talking to each other.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向您展示了如何配置应用程序的负载均衡。我们知道您现在可以访问 OpenShift 背后的虚拟集群 IP 地址，该地址正在对请求进行负载均衡。然而，我们实际上如何知道如何连接到我们的服务呢？我们将在下一个主题中学习这一点。在我们这样做之前，我们必须介绍我们将要相互通信的新服务。
- en: New services
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新服务
- en: In the first chapter, we briefly introduced the pet store application and described
    the services that constitute it. By now, we have used solely the catalog service
    in our examples. Now it's time to implement both the pricing service and customer
    gateway service. These services will serve as an example in this and the future
    chapters. Let's start with the pricing service.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们简要介绍了宠物商店应用程序，并描述了构成它的服务。到目前为止，在我们的示例中我们只使用了目录服务。现在是时候实现定价服务和客户网关服务了。这些服务将作为本章节和未来章节的示例。让我们从定价服务开始。
- en: The pricing service
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定价服务
- en: 'The pricing service is very similar to catalog service. It can be used to obtain
    prices for a pet using their names. Let''s go straight to the implementation.
    Initially, we have to create the database. As before, we will use the PostgreSQL
    template:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 定价服务与目录服务非常相似。它可以用来通过宠物的名称获取价格。让我们直接进入实现。最初，我们必须创建数据库。像以前一样，我们将使用 PostgreSQL
    模板：
- en: '![](img/5089d432-68ce-4dd0-9f27-59d4b4d38d0d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5089d432-68ce-4dd0-9f27-59d4b4d38d0d.png)'
- en: 'As with the catalog service''s database, we would also like to override the
    labels:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与目录服务的数据库一样，我们也想覆盖标签：
- en: '![](img/9fbf091d-5253-4678-b04e-5b33860b96a3.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fbf091d-5253-4678-b04e-5b33860b96a3.png)'
- en: 'To populate the database, we have to create the following script:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充数据库，我们必须创建以下脚本：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, enter the sample data:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入示例数据：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To populate the database, we will execute the following script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充数据库，我们将执行以下脚本：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our pricing database is ready. We can now start writing the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定价数据库已经准备好了。我们现在可以开始编写代码了。
- en: 'Examples reference: `chapter8/pricing-service`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter8/pricing-service`。
- en: We have to configure the database in the similar way that we did for catalog-service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以与 catalog-service 相似的方式配置数据库。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order for the database to work, we have to provide the JDBC driver module:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据库能够工作，我们必须提供 JDBC 驱动模块：
- en: '![](img/f4d00ccd-6c6b-4a34-95be-730bda614b66.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4d00ccd-6c6b-4a34-95be-730bda614b66.png)'
- en: 'As you can see, we also need `persistence.xml`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们还需要 `persistence.xml`：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have to provide an `Entity`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提供一个 `Entity`：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As in `catalog-service`, we will need a service:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `catalog-service` 一样，我们还需要一个服务：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need REST resource:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要 REST 资源：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We would also need an application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个应用程序：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our second service is ready. It''s time to deploy it on OpenShift. Push your
    application to your GitHub repository and invoke:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个服务已经准备好了。现在是时候在OpenShift上部署它了。将你的应用程序推送到GitHub仓库并调用：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After your application is deployed, you can create a route to it and verify
    that it indeed works:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序部署后，你可以为其创建一个路由并验证它确实可以工作：
- en: '![](img/0fb5813b-9d84-4ff6-a8f6-e5bceb63a29c.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fb5813b-9d84-4ff6-a8f6-e5bceb63a29c.png)'
- en: It indeed does. Let's move to the second service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 的确如此。让我们转到第二个服务。
- en: The customer gateway service
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户网关服务
- en: 'In this section, the stuff becomes more interesting again. The customer-gateway
    service is a gateway to our application, which would provide the external interface
    for the web client. The first request that we will implement is obtaining the
    list of pets. Let''s take a look at the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，内容又变得更有趣了。客户网关服务是我们应用程序的网关，它将为Web客户端提供外部接口。我们将实现的第一项请求是获取宠物列表。让我们看一下以下图表：
- en: '![](img/d07150cb-66ec-4f06-b830-675259ac11e7.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d07150cb-66ec-4f06-b830-675259ac11e7.png)'
- en: When the `/catalog/item` request is being executed, the service asks **CATALOG**
    for available items. Based on that information, the pet store service asks the
    **PRICE** service about the price of each pet, merges the results, and then returns
    them to the client. However, how will the gateway service know the addresses of
    the services? We will find that out soon.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`/catalog/item`请求时，服务会向**CATALOG**请求可用的项目。基于这些信息，宠物商店服务会向**PRICE**服务查询每只宠物的价格，合并结果后返回给客户端。然而，网关服务将如何知道这些服务的地址呢？我们很快就会找到答案。
- en: 'Examples reference: `chapter8/customer-gateway-env`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter8/customer-gateway-env`。
- en: The customer service is configured in a similar way to previous services. If
    you have doubts regarding some parts of configuration please refer to the description
    of those.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户服务配置方式与之前的服务类似。如果你对配置的某些部分有疑问，请参考其描述。
- en: 'Let''s look at the implementation details of `catalog/item` request starting
    with the REST resource:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`catalog/item`请求的实现细节，从REST资源开始：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `getItems` method gathers the items from the `CatalogService` (1), obtains
    a price for all of them, and merges the obtained results into the list of pets
    available in the store. Please note that we have introduced `CatalogItemView`—a
    transport object which is a part of the API for the web client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`getItems`方法从`CatalogService`（1）收集项目，为所有项目获取价格，并将获取的结果合并到商店中可用的宠物列表中。请注意，我们引入了`CatalogItemView`——这是一个传输对象，它是Web客户端API的一部分。'
- en: 'We have also implemented the service:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也已经实现了该服务：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The getItems method implementation (1) is pretty straightforward. We are combining
    data from catalog and pricing services and returning the list of resulting object.
    The most interesting part here is the proxies which enable us to communicate with
    those services (2). Let's learn how to implement them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`getItems`方法实现（1）相当直接。我们正在合并目录和定价服务的数据，并返回结果对象的列表。这里最有趣的部分是代理，它使我们能够与这些服务通信（2）。让我们学习如何实现它们。'
- en: Environment variables
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: When the new service is created, its coordinates are written into environment
    variables in every pod in the cluster.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新的服务时，其坐标会被写入集群中每个Pod的环境变量中。
- en: 'Let''s log in to one of the pods inside the cluster and take a look at it.
    All the OpenShift environment variable names are written in uppercase, and we
    need the data about the pricing service:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们登录到集群中的一个Pod并查看它。所有OpenShift环境变量名称都是大写的，我们需要有关定价服务的数据：
- en: '![](img/3bfc0bb5-3f2a-4b60-9285-181178c10b32.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3bfc0bb5-3f2a-4b60-9285-181178c10b32.png)'
- en: 'In the preceding screenshot, note that there are a number of variables describing
    the coordinates of the service. The property that interests us is the host address:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，请注意有许多变量描述了服务的坐标。我们感兴趣的是主机地址：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that this is the virtual cluster IP again. As a result, as long as the
    service is not removed, the proxy address will stay the same. Underlying infrastructure
    changes caused by deployments, node addition, or failures will not result in the
    change of the previous address.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这又是虚拟集群IP。因此，只要服务没有被移除，代理地址将保持不变。由部署、节点添加或故障引起的底层基础设施更改不会导致之前地址的改变。
- en: 'Let''s write proxies that will use this variable in order to connect to the
    services. We will start with the pricing-service proxy:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写使用此变量连接到服务的代理。我们将从定价服务代理开始：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's just it. We obtained the `clusterIP` of the pricing-service when the
    proxy was being created (1) and the user straightforward REST Client API to provide
    an adapter for the `getPrice` method invocation (2).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们在创建代理时获得了`clusterIP`（1），并且用户直接使用REST客户端API为`getPrice`方法调用提供了一个适配器（2）。
- en: The implementation of `catalogProxy` is analogous.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`catalogProxy`的实现类似。'
- en: 'Now we are ready to check whether our application is working. Let''s create
    a route for the `petstore` service and check the web browser:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好检查我们的应用程序是否工作。让我们为`petstore`服务创建一个路由并检查网页浏览器：
- en: '![](img/af7f0316-1188-46d8-be09-6b7b70d36885.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af7f0316-1188-46d8-be09-6b7b70d36885.png)'
- en: It works indeed. This solution has a major disadvantage though—an ordering problem.
    If the pod is created before the service, then service coordinates won't be present
    in the pod environment. Is there a better way to discover the services, then?
    Yes, through **Domain Name Service** (**DNS**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此。然而，这个解决方案有一个主要的缺点——一个排序问题。如果Pod在服务之前创建，那么服务坐标将不会存在于Pod环境中。那么有没有更好的服务发现方法呢？是的，通过**域名系统**（**DNS**）。
- en: DNS discovery
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS发现
- en: 'Each OpenShift cluster contains a DNS service. This service allows you to discover
    services easily using the service name. Each service registers to the DNS service
    during the registration, and later periodically sends live messages to it. The
    DNS server creates a record using the following pattern:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个OpenShift集群都包含一个DNS服务。这个服务允许您通过服务名称轻松地发现服务。每个服务在注册期间都会注册到DNS服务，并且随后定期向其发送实时消息。DNS服务器使用以下模式创建记录：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's take the pricing service as an example. We have created the `petstore`
    application. As a result, the name of the service created using the preceding
    pattern would be pricing-`service.petstore.svc`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以定价服务为例。我们已经创建了`petstore`应用程序。因此，使用前面模式创建的服务名称将是`pricing-service.petstore.svc`。
- en: 'We can confirm that information inside web console. Let''s navigate to Applications
    | Services | pricing-service:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Web控制台中确认信息。让我们导航到应用程序 | 服务 | pricing-service：
- en: '![](img/8155956d-79f5-4a9d-a357-d143e73638e0.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8155956d-79f5-4a9d-a357-d143e73638e0.png)'
- en: Take note of the `hostname` field—this is the address that we created previously.
    Another important thing to note is that those service names are visible only from
    inside the cluster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`hostname`字段——这是我们之前创建的地址。另一个需要注意的重要事项是，那些服务名称只能在集群内部可见。
- en: We are now ready to refactor our application to use elegant DNS discovery.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将我们的应用程序重构为使用优雅的DNS发现。
- en: 'Examples reference: `chapter8/customer-gateway-dns`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter8/customer-gateway-dns`。
- en: 'We have to rewrite both our proxies. Let''s start with `PricingProxy`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重写我们的代理。让我们从`PricingProxy`开始：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We defined a `targetPath` that we can use repeatedly to connect to services
    (1). We are going to provide it as a parameter using YAML configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`targetPath`，我们可以重复使用它来连接到服务（1）。我们将通过YAML配置将其作为参数提供：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, `CatalogProxy` implementation is analogous.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`CatalogProxy`的实现类似。
- en: Now we are ready to redeploy the customer-gateway service again. You can once
    again check whether it works correctly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好再次重新部署customer-gateway服务。你可以再次检查它是否工作正确。
- en: As you may recall, we were using the name of the service when we were creating
    the environment file for our databases. Each service in the cluster can be reached
    using this method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，我们在创建数据库的环境文件时使用了服务的名称。集群中的每个服务都可以使用这种方法访问。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to scale and discover services inside the cluster.
    As you were able to see throughout this chapter, most of the work was done by
    OpenShift. Load balancing is implemented automatically by the services, and the
    integrated DNS service allows for straightforward service discovery.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在集群内部进行扩展和发现服务。正如你在本章中看到的那样，大部分工作都是由OpenShift完成的。负载均衡由服务自动实现，集成的DNS服务允许简单的服务发现。
- en: In the next chapter, you will learn more about networking. You will also learn
    how to provide resiliency to a service invocation so that underlying network failures
    won't cause your application to stop working.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解更多的网络知识。你还将学习如何为服务调用提供弹性，以便底层网络故障不会导致你的应用程序停止工作。
