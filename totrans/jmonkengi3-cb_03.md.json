["```java\n    fractalSum.setFrequency(frequency);\n    fractalSum.setAmplitude(0.5f);\n    fractalSum.setOctaves(octaves);\n    ```", "```java\n    for(int y = 0; y < size; y++){\n      for(int x = 0; x < size; x++){\n        float value = fractalSum.value(x, 0, y) + 0.5f;\n        value = FastMath.clamp(value, 0f, 1f);\n        terrain[x][y] = value;\n      }\n    }\n    ```", "```java\n    ImageGenerator.generateImage(terrain);\n    ```", "```java\n    LightControl lightControl = new LightControl(pointLight);\n    ```", "```java\n    lightControl.setControlDir(LightControl.ControlDirection.SpatialToLight);\n    ```", "```java\n    public void deform(Vector2f location, int radius, float force) {\n      List<Vector2f> heightPoints = new ArrayList<Vector2f>();\n      List<Float> heightValues = new ArrayList<Float>();\n    ```", "```java\n    for(int x = -radius; x < radius; x++){\n      for(int y = -radius; y < radius; y++){\n        Vector2f terrainPoint = new Vector2f(location.x + x, location.y + y);\n        float distance = location.distance(terrainPoint);\n        if(distance < radius){\n          float impact = force * (1 - distance / radius) ;\n          float height = terrain.getHeight(terrainPoint);\n          heightPoints.add(terrainPoint);\n          heightValues.add(Math.max(-impact, -height));\n        }\n      }\n    }\n    ```", "```java\n    terrain.setLocked(false);\n    terrain.adjustHeight(heightPoints, heightValues);\n    terrain.setLocked(true);\n    ```", "```java\n    public void deform(Vector3f location, int radius, float force){\n      Vector2f pos2D = new Vector2f((int)location.x, (int)location.z);\n      deform(pos2D, radius, force);\n    }\n    ```", "```java\n    Ray ray = new Ray(cam.getLocation(), cam.getDirection());\n    ```", "```java\n    CollisionResults cr = new CollisionResults();\n    terrain.collideWith(ray, cr);\n    CollisionResult collision = cr.getClosestCollision();\n    if(collision != null){\n      terrain.getControl(DeformableControl.class).deform(coll.getContactPoint(), 30, 30f);\n    }\n    ```", "```java\n    for(Spatial s: ((Node)spatial).getChildren()){\n      if(s instanceof TerrainQuad){\n        this.terrain = (TerrainQuad) s;\n    ```", "```java\n    float value = fractalSum.value(x, 0, y);\n    float terrainHeight = terrain.getHeight(new Vector2f(x, y)); \n    ```", "```java\n    Spatial treeClone = treeModel.clone();\n    Vector3f location = new Vector3f((x), terrainHeight, (y));\n    treeClone.setLocalTranslation(location);\n    treeNode.attachChild(treeClone);\n    ```", "```java\n    if (name.equals(\"Forward\")) moveForward = isPressed;\n    else if (name.equals(\"Back\")) moveBackward = isPressed;\n    else if (name.equals(\"Left\")) moveLeft = isPressed;\n    else if (name.equals(\"Right\")) moveRight = isPressed;\n    ```", "```java\n    Vector3f camDir = cam.getDirection().mult(tpf).multLocal(50);\n            Vector3f camLeftDir = cam.getLeft().mult(tpf).multLocal(50);\n    ```", "```java\n    if(moveForward) moveTiles(camDir.negate());\n    else if (moveBackward) moveTiles(camDir);\n    if(moveLeft) moveTiles(camLeftDir.negate());\n    else if (moveRight) moveTiles(camLeftDir);\n    ```", "```java\n    for(Geometry g: cachedTiles.values()){\n      g.move(amount);\n    }\n    ```", "```java\n    Vector2f newLocation = null;\n    Iterator<Vector2f> it = cachedTiles.keySet().iterator();\n    while(it.hasNext() && newLocation == null){\n      Vector2f tileLocation = it.next();\n      Geometry g = cachedTiles.get(tileLocation);\n      if(currentTile != g && g.getWorldBound().contains(Vector3f.ZERO.add(0, -15, 0))){\n        currentTile = g;\n        newLocation = tileLocation;\n      }\n    }\n    ```", "```java\n    Vector2f wantedLocation = newLocation.add(new Vector2f(x,y));\n    if(!cachedTiles.containsKey(wantedLocation)){\n      Geometry g = new Geometry(wantedLocation.x + \", \" + wantedLocation.y, new Box(tileSize * 0.5f, 1, tileSize * 0.5f));\n    ```", "```java\n    Vector3f location = new Vector3f(x * tileSize, 0, y * tileSize);\n    if(currentTile != null){\n      location.addLocal(currentTile.getLocalTranslation());\n    }\n    g.setLocalTranslation(location);\n    ```", "```java\n    Iterator<Vector2f> it = cachedTiles.keySet().iterator();\n    List<Vector2f> tilesToDelete = new ArrayList<Vector2f>();\n    while(it.hasNext()){\n      Vector2f tileLocation = it.next();\n      if(tileLocation.x>newLocation.x + 2 || tileLocation.x<newLocation.x - 2 || tileLocation.y>newLocation.y + 2 || tileLocation.y<newLocation.y - 2){\n        tilesToDelete.add(tileLocation);\n      }\n    }\n    ```", "```java\n    inputManager.addMapping(\"Forward\", new KeyTrigger(KeyInput.KEY_UP));\n    inputManager.addMapping(\"Back\", new KeyTrigger(KeyInput.KEY_DOWN));\n    inputManager.addMapping(\"Left\", new KeyTrigger(KeyInput.KEY_LEFT));\n    inputManager.addMapping(\"Right\", new KeyTrigger(KeyInput.KEY_RIGHT));\n    inputManager.addListener(worldControl, \"Forward\", \"Back\", \"Left\", \"Right\");\n    ```", "```java\n    float difference = (otherCell.getTerrainHeight() + otherCell.getAmount()) - (terrainHeight + amount);\n    ```", "```java\n      amountToChange = difference * 0.5f;\n      amountToChange = Math.min(amountToChange, otherCell.getAmount());\n    ```", "```java\n    otherCell.adjustAmount(-amountToChange);\n    ```", "```java\n    for(int x = 0; x < width; x++){\n      for(int y = 0; y < height; y++){\n        WaterCell cell = new WaterCell();cell.setTerrainHeight(((Terrain)s).getHeight(new Vector2f(x, y)));\n        waterField[x][y] = cell;\n      }\n    }\n    ```", "```java\n    WaterCell cell = waterField[x][y];\n      float cellAmount = cell.getAmount();\n      if(cellAmount > 0){\n        int direction = cell.getDirection();\n        for(int i = 0; i < 8; i++){\n          int[] dir = CellUtil.getDirection((direction + i) % 8);\n    ```", "```java\n    WaterCell neighborCell = waterField[x+dx][y+dy];\n    if(cell.getAmount() > 0.01){\n      floatadjustAmount = neighborCell.compareCells(cell);\n      if(adjustAmount > 0){neighborCell.setDirection(CellUtil.getDirection(dx, dy));\n      }\n    }\n    ```", "```java\n    water = new Node(\"Water\");\n    ```", "```java\n    geometry = new Geometry(\"WaterCell\", new Box(1f, 1f, 1f));\n    ```", "```java\n    geometry.setLocalScale(1, 1f + amount, 1);\n    ```", "```java\n    g.setLocalTranslation(x, -1f + cell.getTerrainHeight() + cell.getAmount() * 0.5f, y);\n    water.attachChild(g);\n    ```", "```java\n    water = GeometryBatchFactory.optimize(water, false);\n    water.setMaterial(material);\n    ((Node)spatial).attachChild(water);\n    ```", "```java\n    if(mesh == null || refresh){\n      mesh = CubeUtil.createMesh(this);\n      refresh = false;\n    }\n    return mesh;\n    ```", "```java\n    m.setBuffer(VertexBuffer.Type.Position, 3, BufferUtils.createFloatBuffer(vertices));\n    ```", "```java\n    List<Integer> indices = new ArrayList<Integer>();\n    for(intdir = 0; dir < 6; dir++){\n      if(!cube.hasNeighbor(dir)){\n        for(int j = 0; j < 6; j++){\n          indices.add(GEOMETRY_INDICES_DATA[dir * 6 + j]);\n        }\n      }\n    }\n    ```", "```java\n    m.setBuffer(VertexBuffer.Type.Index, 1, BufferUtils.createIntBuffer(indexArray));\n    ```", "```java\n    m.setBuffer(VertexBuffer.Type.TexCoord, 2, BufferUtils.createFloatBuffer(GEOMETRY_TEXTURE_DATA));\n    m.setBuffer(VertexBuffer.Type.Normal, 3, GEOMETRY_NORMALS_DATA);\n    ```", "```java\n    CubeCell[][][] terrainBlock = new CubeCell[size][size][size];\n    for(int y = 0; y < size; y++){\n      for(int z = 0; z < size; z++){\n        for(int x = 0; x < size; x++){\n          double value = fractalSum.value(x, y, z);\n          if(value >= 0.0f){\n            terrainBlock[x][y][z] = new CubeCell();\n          }\n        }\n      }\n    }\n    ```", "```java\n      for(int y = 0; y < batchSize; y++){\n        repeat for x and z\n        if(terrainBlock[x][y][z] != null){\n          for(inti = 0; i < 6; i++){\n            Vector3f coords = CubeUtil.directionToCoords(i);\n            if(coords.y + y > -1 && coords.y + y < batchSize){\n              repeat for x and z\n              if(terrainBlock[(int)coords.x + x][(int)coords.y y][(int)coords.z + z] != null){terrainBlock[x][y][z].setNeighbor(i, true);\n              } else {terrainBlock[x][y][z].setNeighbor(i, false);\n              }\n            }\n          }\n        }\n      }\n    ```", "```java\n    Geometry g = new Geometry(\"Cube\", terrainBlock[x][y][z].getMesh() );\n    g.setLocalTranslation(x, y, z);\n    g.setMaterial(materials[0]);\n    node.attachChild(g);\n    ```", "```java\n    inputManager.addMapping(\"take\", new MouseButtonTrigger(MouseInput.BUTTON_LEFT));\n    inputManager.addMapping(\"put\", new MouseButtonTrigger(MouseInput.BUTTON_RIGHT));\n    ```", "```java\n    if(coll != null && coll.getDistance() < 2f && pickupCube){\n      Vector3f geomCoords = coll.getGeometry().getWorldTranslation();\n      takenCube = cubeWorld.changeTerrain(geomCoords, takenCube);\n    }\n    ```", "```java\n    Vector3f geomCoords = cam.getLocation().add(cam.getDirection().mult(2f));\n    geomCoords.set(Math.round(geomCoords.x), Math.round(geomCoords.y), Math.round(geomCoords.z));\n    takenCube = cubeWorld.changeTerrain(geomCoords, takenCube);\n    ```", "```java\n    if(changedBlock == null){\n      changedBlock = terrainBlock[x][y][z];\n      terrainBlock[x][y][z] = null;\n    }\n    ```", "```java\n    else if(terrainBlock[x][y][z] == null){\n      terrainBlock[x][y][z] = changedBlock;\n      terrainBlock[x][y][z].requestRefresh();\n      changedBlock = null;\n    }\n    ```"]