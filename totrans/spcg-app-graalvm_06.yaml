- en: '*Chapter 4*: Graal Just-In-Time Compiler'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    we went through the GraalVM architecture and the various components that constitute
    it. We went through some details of the GraalVM Polyglot architecture with Truffle
    and touched upon the Graal's **just-in-time** (**JIT**) compiler. We looked at
    how Graal JIT plugs into the Java Virtual Machine by implementing the Java Virtual
    Machine Compiler Interface. In this chapter, we will explore how the Graal JIT
    compiler works by running sample code and visualizing the Graal graphs and optimizations
    that Graal JIT performs, using the Ideal Graph Visualizer tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Graal JIT compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Graal compiler optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and monitoring applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a very clear understanding of how Graal
    JIT compilation works, understand the various optimization techniques, know how
    to diagnose and debug performance problems using the Ideal Graph Visualizer, and
    be able to fine-tune Graal JIT compiler configurations for optimum performance.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take some sample code and use tools to analyze it.
    The following are some of the tools/runtimes that are required to follow this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenJDK ([https://openjdk.java.net/](https://openjdk.java.net/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VisualVM ([https://visualvm.github.io/index.html](https://visualvm.github.io/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ideal Graph Visualizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some sample code snippets, which are available in our Git repository.
    The code can be downloaded from [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3fmPsaP.](https://bit.ly/3fmPsaP.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using VisualVM and the Ideal Graph Visualizer to
    understand how Graal JIT works. This understanding will help us, in the subsequent
    chapters, to build optimum code with Graal.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Graal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    we discussed the two editions of Graal – Community Edition and **Enterprise Edition**
    (**EE**). Graal Community Edition can be downloaded from the Git repository mentioned
    in the *Technical requirements* section, while EE requires you to register with
    Oracle to download it. EE is available for free for evaluation and non-production
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Community Edition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install GraalVM Community Edition, go to [https://github.com/graalvm/graalvm-ce-builds/releases](https://github.com/graalvm/graalvm-ce-builds/releases)
    and download the latest release for the target operating system (macOS, Linux,
    and Windows). At the time of writing this book, the latest version is 21.0.0.2,
    with base Java 8 or Java 11 versions. The Community Edition is built on OpenJDK.
  prefs: []
  type: TYPE_NORMAL
- en: Please follow the instructions provided next for your target operating system.
    The latest instructions can be found at https://www.graalvm.org/docs/getting-started/#install-graalvm.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GraalVM on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For macOS, after downloading the GraalVM archive file, unzip the archive and
    copy the contents of the unzipped folder to `/Library/Java/JavaVirtualMachines/<graalvm>/Contents/Home`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have copied the files, we have to export the paths to access the GraalVM
    binaries. Let''s run the following `export` commands on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For macOS Catalina and later, the `quarantine` attribute needs to be removed.
    It can be done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is not done, you will see the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Error message while running Graal on MacOS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Error message while running Graal on MacOS
  prefs: []
  type: TYPE_NORMAL
- en: SDKMAN provides an automated way of installing GraalVM. Please refer to [https://sdkman.io/](https://sdkman.io/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GraalVM on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install GraalVM on Linux, extract the downloaded zip file, copy it to any
    target folder, and set the `PATH` and `JAVA_HOME` paths to point to the folder
    where the extracted files are. To do this, execute the following commands on the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installing GraalVM on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install GraalVM on Windows, extract the `.zip` file, copy it to any target
    folder, set the `PATH` and `JAVA_HOME` paths to point to the folder where the
    extracted files are. To set the `PATH` environment variables, execute the following
    commands on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To check that the installation and setup are complete, run the `java -version`
    command on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the command, you should see something like the following output
    (I am using GraalVM EE 21.0.0 on Java 11\. You should see the version that you
    installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now explore the folder structure of GraalVM installation. In the GraalVM
    installation folder, you will find the folder structure explained in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapter, we covered in detail the various runtimes, tools,
    and utilities that come with Graal. Graal Updater is one of the very important
    tools that is used to install optional runtimes. To check the runtimes that are
    available, execute `gu list`. The following screenshot shows the typical output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Graal Updater listing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Graal Updater listing
  prefs: []
  type: TYPE_NORMAL
- en: We can run `gu install <runtime>` to install other runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing EE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraalVM EE is available for free for trial and non-production use. It can be
    downloaded from [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the required GraalVM Enterprise version. The website will redirect you
    to Oracle''s registration page. If you are already registered, you should be able
    to log in, and you will be redirected to a page from where you can download GraalVM
    and the supporting tools. At the time of writing this book, the screen looks something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – GraalVM EE download page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – GraalVM EE download page
  prefs: []
  type: TYPE_NORMAL
- en: 'You can select the right version of EE that you want to download along with
    the base JDK version. At the time of writing the book, Java 8 and Java 11 are
    two viable versions. When you scroll down this page, you will find download links
    for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oracle GraalVM Enterprise Edition Core**: This the code for GraalVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle GraalVM Enterprise Edition Native Image**: This is the native image
    tool. It can also be downloaded using Graal Updater later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ideal Graph Visualizer**: This is a very powerful Graal graph analyzer tool.
    It needs to be downloaded for this chapter. See the instructions in the *Installing
    the Ideal Graph Visualizer* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraalVM LLVM Toolchain**: This is the LLVM toolchain, which is required if
    you want to compile and run C/C++ applications on GraalVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle GraalVM Enterprise Edition Ruby Language Plugin**: This is the Ruby
    language compiler and runtime. It can also be downloaded using Graal Updater later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle GraalVM Enterprise Edition Python Language Plugin**: This is the Python
    language compiler and runtime. It can also be downloaded using Graal Updater later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle GraalVM Enterprise Edition WebAssembly Language Plugin**: This is
    the WebAssembly language compiler and runtime. It can also be downloaded using
    Graal Updater later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle GraalVM Enterprise Edition Java on Truffle**: This is the JVM implementation
    on the Truffle interpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between editions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can have multiple versions/distributions of GraalVM installed on the same
    machine, and we can switch between these various distributions. In this chapter,
    we will be switching between the distributions to compare their performance. The
    best way to switch between distributions is by using Visual Studio Code. Visual
    Studio Code provides a GraalVM plugin that helps us to add the various distributions,
    and with single click of a button, allows us to switch between the various distributions.
    Please refer to [https://www.graalvm.org/tools/vscode/](https://www.graalvm.org/tools/vscode/)
    and [https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm](https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm
    ) for more details. Refer to the *Debugging and monitoring applications* section
    later in this chapter for more details on how to install Visual Studio Code and
    use it for debugging applications.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create shell scripts to switch between the various distributions
    by setting the PATH and JAVA_HOME environment variables to point to appropriate
    distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Graal VisualVM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java VisualVM is one of the most powerful tools for analyzing an application's
    heap, thread, and CPU utilization. VisualVM is widely used to analyze core dumps,
    heap dumps, and applications that are offline. It is a very sophisticated tool
    that can identify bottlenecks and optimize Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Since JDK 9, VisualVM has been moved and upgraded to Graal VisualVM. Graal VisualVM
    extends the functionality to include the analysis of Graal processes, and currently
    supports JavaScript, Python, Ruby, and R. Graal VisualVM also supports some limited
    monitoring and analysis functionality for native image processes. Graal VisualVM
    comes bundled with both Graal Community Edition and EE. Graal VisualVM can be
    found at `.bin/jvisualvm` (`.exe` for windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly go through the key features of Graal VisualVM. Graal VisualVM
    has a very intuitive interface. The left panel of the main window (see *Figure
    4.3*) shows all the **Local** and **Remote** processes. Using this, we can easily
    connect to those processes to start our analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – VisualVM, left pane'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – VisualVM, left pane
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we connect to the process, in the right panel, we will see the following
    five tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview**: On this tab, we can see the process configuration, JVM arguments,
    and system properties. The following screenshot shows the typical screen for the
    **FibonacciCalculator** process that we are running:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – VisualVM – application overview'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – VisualVM – application overview
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitor**: On this tab, we can see CPU usage, heap allocation, the number
    of classes that are loaded, the number of threads that are running, and so on.
    We can also force a garbage collection to see how the process behaves. We can
    perform a heap dump to do a deeper analysis of the heap allocations. Here is a
    screenshot of the window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – VisualVM – application monitoring'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – VisualVM – application monitoring
  prefs: []
  type: TYPE_NORMAL
- en: '**Threads**: This tab provides detailed information about the various threads
    that are running the processes. We can also capture a thread dump to perform further
    analysis. This tab not only shows the live threads, but we can also analyze the
    threads that have finished execution. The following screenshot shows the typical
    **Threads** tab:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – VisualVM – application threads'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – VisualVM – application threads
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical screenshot of the thread dump that can be used to identify
    if there are any deadlocks or thread waits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – VisualVM – thread dump'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – VisualVM – thread dump
  prefs: []
  type: TYPE_NORMAL
- en: '**Sampler**: This tab can be used to take a snapshot of the running process
    and carry out analysis on CPU, memory, and so on. Here is a screenshot that shows
    the memory usage for the snapshot we take by clicking the **Snapshots** button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – VisualVM – Memory usage using Snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – VisualVM – Memory usage using Snapshot
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiler**: This is like the sampler, but it runs all the time. Apart from
    CPU and memory, we can also look at JDBC invocations and the time it takes to
    get the response. The next screenshot shows CPU profiling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – VisualVM – application profiler'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – VisualVM – application profiler
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, Graal VisualVM can be used to analyze Core dumps and to identify
    the root cause of any Java process crashes. At the time of writing this book,
    Graal VisualVM supports JavaScript and Ruby (heap, object view, and thread view
    only), Python, and R (heap and object view only).
  prefs: []
  type: TYPE_NORMAL
- en: '**JDK Flight Recorder** (**JFR**) analysis is another powerful feature of VisualVM.
    It helps us to analyze the data that is connected by JFR with no overhead on the
    running process. JFR provides more advanced analysis, including capturing and
    analyzing file I/O, socket I/O, and thread locks apart from CPU and thread.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Graal VisualVM also provides extension APIs so we can write custom plugins.
    Various plugins can be used to extend Graal VisualVM. Here are some of the most
    widely used plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual GC plugin**: This plugin provides a powerful interface to monitor
    garbage collection, class loader, and JIT compiler performance. It is a very powerful
    plugin that can identify optimizations in the code to improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracer**: Tracer provides a better user interface for detailed monitoring
    and analyzing of the applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Startup Profiler**: As the name suggests, this provides instrumentation to
    profile the startups and identify any optimizations that can be performed to improve
    the startups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the full list of available plugins at [https://visualvm.github.io/pluginscenters.html](https://visualvm.github.io/pluginscenters.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Ideal Graph Visualizer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideal Graph Visualizer is a very powerful tool for analyzing how Graal JIT is
    performing various optimizations. This requires an advanced understanding of Graal
    Graphs, which is an intermediate representation. Later in this chapter, we will
    cover Graal Graph and how to use the Ideal Graph Visualizer so that we can see
    how Graal performs various optimizations. This is critical, as it helps us write
    better code and optimize the code at development time, and reduces the load on
    the compiler to perform it just in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The The Ideal Graph Visualizer is available with GraalVM EE. It can be downloaded
    from the Oracle website. The Ideal Graph Visualizer can be launched with the following
    command, after setting the `PATH` to the location where it has been unzipped/installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--jdkhome` flag can be used to point to the right version of GraalVM.
    Once it has been launched, you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – The Ideal Graph Visualizer – main window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – The Ideal Graph Visualizer – main window
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ideal Graph Visualizer requires Graal dumps to render and analyze Graal
    Graphs. Graal dumps can be created using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `n` in the preceding command can be `1`, `2`, or `3`, and each number denotes
    a level of verbosity. This generates a folder called `graal_dumps`, which consists
    of `bgv` files (Binary Graph Files). Sometimes you will find various `bgv` files
    due to invalidation and recompilation (deoptimization or on-stack replacements
    – please refer to [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT* , and find the *On-stack replacement* section to
    find out more). These `bgv` files can be opened in The Ideal Graph Visualizer
    to do the analysis. Once the `bgv` file is loaded, you will see a screen like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The Ideal Graph Visualizer – main window–Graal dump'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – The Ideal Graph Visualizer – main window–Graal dump
  prefs: []
  type: TYPE_NORMAL
- en: The left pane can be used to navigate through the various phases of compilation
    and optimization, the main window shows the graph, and the right pane can be used
    to configure how to render these graphs. We can view the Graal Graphs, Call Graph,
    AST, and Truffle Call Tree.
  prefs: []
  type: TYPE_NORMAL
- en: The Ideal Graph Visualizer can also be connected from the Java runtime (using
    the `Dgraal.PrintGraph=Network` flag) to view the graphs in real time, while the
    application code is executing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how these Graal Graphs can be read to understand
    how the Graal compiler works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Graal JIT compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly touched upon the Graal compiler and the
    ecosystem around it. In this section, we will dig deeper into various compiler
    options and see how Graal optimizes the code just in time. In the next section,
    we will take a look at Ahead-of-Time compilation, and how a native image can be
    created. Before we get into the details of how the Graal compiler works, let's
    quickly go through some of the Graal compiler configurations, which can be passed
    as arguments to the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Graal compiler configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Graal compiler can be configured with various arguments that can be passed
    from the `java` command (in the GraalVM version of `java`). In this section, we
    will go through some of the most useful command-line configurations.
  prefs: []
  type: TYPE_NORMAL
- en: We will be trying these various flags on a sample application to see how it
    affects the Graal compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple Java class called `FibonacciCalculator`. Here is the
    source code of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are generating `1000000000` to `1000000010` Fibonacci numbers,
    and then later calculating the sum total of all the Fibonacci number that are
    generated. The code is written to loops to trigger the compilation threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of optimization opportunities for JIT. Let''s first run this
    program with Java HotSpot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – FibonnaciCalculator – Java HotSpot output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – FibonnaciCalculator – Java HotSpot output
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the initial iterations took the most time, and it optimized
    to around 1,300 ms over the iterations. Let''s now compile the code with `javac`,
    which we got from the Graal EE distribution, and run the same program with Graal
    JIT. The following screenshot shows the output of running the same application
    with GraalVM (GraalVM EE 21.0.0.2 on Java 11):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – FibonnaciCalculator – GraalVM output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – FibonnaciCalculator – GraalVM output
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see significant improvement in performance. Graal started similarly
    to Java HotSpot, but over the iterations it optimized to 852 ms, compared to the
    1,300 ms it took to run with HotSpot. The following option is used to disable
    GraalJIT and use HotSpot on GraalVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is normally used to compare the performance of Graal. Let''s run this
    option with the preceding source code, with the GraalVM EE 21.0.0.2 compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of the output after running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – FibonnaciCalculator – GraalVM (21/Java 11) output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – FibonnaciCalculator – GraalVM (21/Java 11) output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even though we are using the Graal compiler, the performance
    is similar to Java HotSpot, and in fact is slower than Java HotSpot 15\. Note
    that our Graal is running on Java 11.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CompilerConfiguration` flag is used to specify which JIT compiler is to
    be used. The following is the argument that we can pass to set the compiler configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three options; let''s also run these options with our sample code to
    see how it performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Dgraal.CompilerConfiguration=enterprise`: This uses the enterprise JIT, and
    generates the optimum code. However, there will be initial slowdowns due to compilation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – FibonnaciCalculator – enterprise compiler configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – FibonnaciCalculator – enterprise compiler configuration
  prefs: []
  type: TYPE_NORMAL
- en: '`-Dgraal.CompilerConfiguration=community`: This produces the community version
    of JIT, which optimizes to a decent extent. The compilation is therefore faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.17 – FibonnaciCalculator – community compiler configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – FibonnaciCalculator – community compiler configuration
  prefs: []
  type: TYPE_NORMAL
- en: '`-Dgraal.CompilerConfiguration=economy`: This compiles quickly, with fewer
    optimizations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.18 – FibonnaciCalculator – economy compiler configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – FibonnaciCalculator – economy compiler configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a significant difference in the performance when using enterprise,
    community, and economy. Here is a comparison of the performances of three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – FibonnaciCalculator – enterprise versus community versus economy
    configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – FibonnaciCalculator – enterprise versus community versus economy
    configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from this, there are a lot of other performance tuning options that can
    be used to improve the performance of the compiler, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding flag can be used to enable/disable advanced inlining algorithm.
    Disabling this improves the compilation time and helps throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'This flag can be used to disable auto-vectorization optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This flag can be used to disable the path duplication optimization, such as
    Dominance-Based Duplication Simulation. When this is disabled, it has an impact
    on the throughput:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very useful flag that can be enabled to trace how the JIT compiler
    takes decisions on inlining optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we enable this flag for sample code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the JIT compiler is taking decisions on inlining.
  prefs: []
  type: TYPE_NORMAL
- en: These optimization flags can be set even for other GraalVM launchers, such as
    `js` (for JavaScript), `node`, and `lli`.
  prefs: []
  type: TYPE_NORMAL
- en: Graal JIT compilation pipeline and tiered optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, in the *Graal JIT compiler* section, we looked at how
    Graal JIT integrates with the virtual machine through JVMCI. In this section,
    let's take a deeper look at how Graal JIT interacts with virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graal optimizes the code in three tiers. The tiered approach helps Graal to
    perform optimizations starting from more platform-independent representations
    (high-level intermediate representation) to more platform-dependent representations
    (low-level intermediate representation). The following diagram shows how Graal
    JIT interfaces with the virtual machine and performs these three tiers of optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Graal JIT compiler – compilation tiers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.20_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – Graal JIT compiler – compilation tiers
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand this picture better:'
  prefs: []
  type: TYPE_NORMAL
- en: The virtual machine passes the bytecode and metadata to the Graal JIT when it
    hits the compilation threshold (refer to [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT*, to find out more about the compilation thresholds).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graal parses the bytecode and generates a **high-level intermediate representation**
    (**HIR**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then performs various optimizations on the **HIR**. These are some of the
    standard Java optimization techniques that are applied, with some new techniques
    that have been introduced in Graal, such as partial escape analysis and advanced
    inlining techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once these high-level optimizations are performed, Graal starts converting the
    high-level operations to low-level operations. This phase is called lowering.
    There are two tiers of optimizations that it performs during this phase, and it
    eventually generates the **low-level intermediate representation** (**LIR**) for
    the target processor architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all the optimizations are performed on the LIR, the final optimized machine
    code is generated and stored in the code cache, along with the reference maps
    that the garbage collector will use and the metadata that will be required for
    deoptimization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at how the Graal JIT compiler works internally, and
    we also explored various compiler configurations that will affect the compiler's
    performance. Now let's understand the Graal Intermediate Representation better.
  prefs: []
  type: TYPE_NORMAL
- en: Graal intermediate representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AddNode`, `IfNode`, and `SwitchNode`, all of them deriving from the base class,
    `Node`. The edges (operands) are represented as fields of the class. The following
    diagram shows the hierarchy of various types of node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Graal Graph nodes – The class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.21_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.21 – Graal Graph nodes – The class hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'The representation of code in SSA enables the creation of a single version
    of the variable for each value. This helps perform better data flow analysis and
    optimizations. A phi function (Φ) is used to convert decision-based control paths
    (such as `if` and `switch`). The Phi function is a function of two values, and
    the value is selected based on the control flow. Refer to the following papers
    on SSA for more details: https://gcc.gnu.org/onlinedocs/gccint/SSA.html and [https://en.wikipedia.org/wiki/Static_single_assignment_form](https://en.wikipedia.org/wiki/Static_single_assignment_form).
    The key point is that the complete program is converted into an SSA to perform
    the optimizations.'
  prefs: []
  type: TYPE_NORMAL
- en: Graal IRs are built as a Graal graph, where each node has input edges that point
    to the nodes that create the operands and the successor edges that show the control
    flow. The successor edge points to the node that succeeds the current node in
    terms of the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate everything that we have discussed so far, let''s analyze some
    simple Java code with The Ideal Graph Visualizer. The logic in this code may not
    generate a simple graph – the code is intentionally kept simple. The loops are
    there to hit the threshold so that when the JVM hits the threshold, it will perform
    Graal JIT compilation, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now compile the preceding code using the `javac DemonstrateGraalGraph.java`
    command. To keep the graph simple, we will compile only the `calculateResult()`
    method by using the `-XX:CompileOnly=DemonstrateGraalGraph:calculateResult` flag.
    Let''s also disable some optimizations using the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Dgraal.FullUnroll=false`, `-Dgraal.PartialUnroll=false`, `-Dgraal.LoopPeeling=false`,
    `-Dgraal.LoopUnswitch=false`, `-Dgraal.OptScheduleOutOfLoops=false`, and `-Dgraal.VectorizeLoops=false`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a folder called `graal_dumps` with a dump of all the Graal
    JIT activities. Once you load the `bgv` file that is generated by Graal, you will
    find the various tiers of optimization listed in the left pane, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – The Ideal Graph Visualizer – DemonstrateGraalGraph – left pane'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.22_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – The Ideal Graph Visualizer – DemonstrateGraalGraph – left pane
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on `calculateResult()` method as we asked the JVM to create
    only compile `calculateResult()` method. Let''s understand this graph better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal
    Graph after parsing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.23_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.23 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph
    after parsing
  prefs: []
  type: TYPE_NORMAL
- en: The program starts with **0 Start** and the loop starts at the **7 LoopBegin**
    node. To make the graph easier to understand, some of the sections are highlighted
    with the labels **A** and **B**. Let's explore what these sections of the graph
    are.
  prefs: []
  type: TYPE_NORMAL
- en: '**Section A**'
  prefs: []
  type: TYPE_NORMAL
- en: Section A highlights the `for` loop. It is converted into a `18 if` statement.
    The input for the `if` statement is the current value of I, which is the output
    of the Phi node `9 Phi(4,22,i32)` and constant 2000 node `11 C(2000) i32`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phi is attached where the control flows merge. In this case, *9 Phi (4,22, i32)*
    merges the output from `4 C(0) i32` (`i=0` in the `for` loop) and the output of
    the `22 +` node (which is `i++`). This node will simply output the current value
    of the `i` after incrementing by the value of the **21 C(1) i32 node**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This then flows into the **12 <** node and is compared with **11 C(2000) i32**
    (which is the maximum value of the loop), and this expression is evaluated by
    control flow node **18 if**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Section B**'
  prefs: []
  type: TYPE_NORMAL
- en: Section B highlights the section where the result is calculated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial value of the result is represented as `i64`, as we declared it as
    a `long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `result = result + i` expression. The value of `i` is flowing from the `I`,
    which flows from **9 Phi(4,22, i32)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final out flows into **24 Return** when the loop ends at **18 if**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can go through each phase of optimization by selecting the phase in
    the left pane to see how the code is optimized. Let''s quickly look at how this
    graph is transformed through the phases. When we select **Before Phase Lowering**
    in the left pane''s **Outline** window, we will see the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal
    graph before lowering'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.24_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal graph
    before lowering
  prefs: []
  type: TYPE_NORMAL
- en: 'In this phase, we can see the following optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: The **19 Sign Extend** node is replaced with **27 Zero Extend**, as the compiler
    found out that it is an unsigned integer. Operations with unsigned integers are
    less expensive than operations with signed integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **12 <** node is replaced with **26 |<|**, which is an unsigned less than
    operation, which is faster. The compiler arrives at this conclusion based on the
    various iterations and profiling. Since the operands are considered unsigned,
    even the operations are considered unsigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graph also illustrates application of the canonicalization technique of
    replacing <= with <, to speed up the `if` (which is originally the `for` loop)
    statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The subsequent phases – high tier, mid tier, and low tier – may not show significant
    optimizations, as the code is relatively simple and we have disabled some of the
    optimizations to keep the graph simple to read and understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal
    Graph, other tiers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.25_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.25 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph,
    other tiers
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.26* is a diagram of the graph with all optimizations enabled. You
    will see that loop unrolling has been used very prominently to speed up the loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – The Ideal Graph Visualizer – DemonstrateGraalGraph – The final
    optimized graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.26_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.26 – The Ideal Graph Visualizer – DemonstrateGraalGraph – The final
    optimized graph
  prefs: []
  type: TYPE_NORMAL
- en: Graal performs various optimizations as part of the tiered compilation. We will
    go through this in detail in the next section, and also see how we can use this
    knowledge to improve the way we write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Graal compiler optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Graal compiler performs some of the most advanced optimizations on the code
    just in time. The most critical ones are discussed in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting into this session, please refer to the *Understanding the optimizations
    performed by JIT* section of [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT*.
  prefs: []
  type: TYPE_NORMAL
- en: Speculative optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIT compilation relies heavily on the runtime profiling of the code. As we have
    seen, the graphs are optimized based on the HotSpots. HotSpots, as we covered
    in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*, are the control flows that the program goes through most frequently.
    There is no point in trying to optimize the whole code; instead, the JIT compiler
    tries to optimize the hot control paths/flows. This is based on speculation and
    assumption. When an assumption is proven wrong during execution, the compiler
    quickly deoptimizes and waits for another opportunity to optimize based on new
    HotSpots. We covered compiler thresholds and Hot Spots in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT*, in the *Compiler threshold* section. Graal JIT also
    uses similar techniques to identify the hotspots. Graal performs all the optimizations
    that we discussed in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, Hotspot, and GraalJIT*, in the *Understanding the optimizations performed
    by JIT* section, but also uses some advanced techniques. Let's go through some
    of the most important optimization techniques that Graal JIT applies to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Partial escape analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*, in the section titled *Understanding the optimizations performed
    by JIT*, we explored escape analysis. Escape analysis is one of the most powerful
    techniques. It identifies the object's scope and the objects escape from local
    to global scope. If it identifies objects that don't escape, there is an opportunity
    to optimize, and the compiler will optimize the code to use stack allocation instead
    of heap allocation for the objects that are within the local scope. This saves
    a significant amount of time in allocating and deallocating memory in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Partial escape analysis takes this further by not just limiting to identifying
    objects that escape a method level scope to control branches. This helps to optimize
    the code when an object is found to be escaping only in certain control flows.
    Other control flows where the object is not escaping can be optimized to either
    use a local value or scalar replacements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial escape analysis looks for escapes that might happen through method
    calls, return values, throw statements, and so on. Let''s use a simple code to
    understand how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is some sample code, just to illustrate partial escape analysis.
    In this code we are creating `object1` as an instance of `Class1` and `object2`
    as an instance of `Class2`. Some processing is happening, and `object1` fields
    are updated with some values that are calculated. Based on the flag, `object1`
    or `object2` will escape. Let''s assume that most of the time the flag is `false`,
    and only `object1` escapes, so there is no point in creating `object1` every time
    the method is called. This code gets optimized to something like the following
    (this is just an illustration of how partial escape analysis works; the Graal
    JIT may not do this exact refactoring):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`object1` is only created if required, and a temporary variable is used to
    store the intermediate values, and if `object1` has to be initialized then it
    uses the temporary values before it escapes. This optimizes heap allocation time
    and heap size.'
  prefs: []
  type: TYPE_NORMAL
- en: Inter-procedural analysis and inlining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graal performs optimization at the AST/Graph level. This helps Graal to perform
    inter-procedural analysis and identify any option that may never become empty
    and skips compiling that part of the code, as it may never be called. It adds
    a guard to that code block, just in case. If the control flows through that block,
    the JIT can deoptimize the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand inter-procedural analysis and inlining, one commonly used example
    is a JDK class, `OptionalDouble`. Here is a snippet of the `OptionalDouble` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we call this `getAsDouble()` method, and the method has a `throw`
    block, but that `throw` block may never be called. The Graal compiler will compile
    all the code, except the `if` block, and will place a `guard` statement so that,
    if it gets called, it can deoptimize the code. Apart from this, Graal performs
    more advanced inlining to optimize the code. We can look at the complete set of
    optimizations that Graal performs by passing `-Dgraal.Dump=:2`. With Graal dump
    at level 2, we get a much more detailed list of graphs for each phase. In the
    next screenshot, you can see a whole list of optimizations the Graal JIT performed
    on the code across the various tiers of compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – The Ideal Graph Visualizer – DemonstrateGraalGraph – compilation
    tiers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.27_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – The Ideal Graph Visualizer – DemonstrateGraalGraph – compilation
    tiers
  prefs: []
  type: TYPE_NORMAL
- en: By looking at how the graph is optimized at each step, we can see every area
    where the code can be optimized at development time. This will reduce the load
    on Graal JIT and the code will perform better. Some of these optimization techniques
    are covered in the *Understanding the optimizations performed by JIT* section
    of [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and monitoring applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM comes with a rich set of tools for debugging and monitoring applications.
    We have already looked at VisualVM and the Ideal Graph Visualizer. As you saw
    in the previous sections, these two tools are very powerful for detailed analysis.
    This analysis also provides insights into how we can improve the code at the development
    time to reduce the load on Graal JIT, and write high-performing and low-footprint
    Java code. Apart from these two tools, the following are some of the other tools
    that Graal comes with.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Visual Studio Code extension is one of the most powerful integrated development
    environments for Graal. The following screenshot shows the GraalVM Extension for
    Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – GraalVM environments on Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.28_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.28 – GraalVM environments on Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see all the various GraalVM installations
    that have been configured on the left pane. It is very easy to switch between
    various versions of GraalVM, and the terminal and the whole environment will use
    the selected GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: This extension also makes it easy to install optional components. We don't have
    to manually run `gu` commands. This extension provides easy way to build, debug,
    and run code written in Java, Python, R, Ruby, and Polyglot (mixed language code).
  prefs: []
  type: TYPE_NORMAL
- en: 'This extension can be directly installed from the Visual Studio Code Extensions
    tab by searching for Graal. The following screenshot shows the extension installation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Installing the GraalVM Extension for Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.29_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – Installing the GraalVM Extension for Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a GraalVM Extension Pack that comes with additional features
    such as Micronaut framework integration and NetBeans Language Server, which provide
    Java code completion, refactoring, Javadoc integration, and many more advanced
    features. The next screenshot shows the installation page for the GraalVM Extension
    Pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – GraalVM Extension Pack plugin for Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.30_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.30 – GraalVM Extension Pack plugin for Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about this extension on the GraalVM website at [https://www.graalvm.org/tools/vscode/graalvm-extension/](https://www.graalvm.org/tools/vscode/graalvm-extension/).
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM Dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraalVM Dashboard is a web-based tool with which we can perform detailed analysis
    of both static and dynamic compilations. This is very powerful for Native Image
    analysis. The tool provides details dashboard reports on compilation, reachability,
    usability, profiling data, dynamic compilation parameters, deoptimization, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: We will run this tool in the next chapter, when we create a native image of
    our sample code and perform more detailed analysis of the native image code.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two command-line tools that can be used in the context of Polyglot
    to identify further opportunities the optimize the code. We will be using these
    tools in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle
    – An Overview*, for Polyglot optimization. The following are the two command-line
    tools that come with GraalVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiling CLI**: This tool helps to identify opportunities to optimize CPU
    and memory usage. Please refer to [https://www.graalvm.org/tools/profiling/](https://www.graalvm.org/tools/profiling/)
    for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code Coverage CLI**: This tools records and analyzes the code coverage for
    each execution. This is very powerful for running test cases and ensuring good
    code coverage. This tool can also identify possible dead code that can be eliminated,
    or hot code that can be optimized at development time. Please refer to [https://www.graalvm.org/tools/code-coverage/](https://www.graalvm.org/tools/code-coverage/)
    for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chrome debugger provides the Chrome developer tool extension to debug guest
    language applications. The Chrome debugger can be used while running the application
    with the `--inspect` option. This helps debug JavaScript (Node.js) using Chrome.
    The extension can be installed from [https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/).We
    will be covering this tool while we discuss JavaScript and Node.js on Graal in
    [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An Overview*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through Graal JIT and Ahead of Time compilers in detail.
    We took a sample code and looked at how Graal JIT performs various optimizations
    using the Ideal Graph Visualizer. We also went through Graal Graphs in detail.
    This is very critical knowledge that will help you analyze and identify optimizations
    that can be applied during development to speed up Graal JIT compilation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have gained a detailed understanding of the internal workings
    of Graal JIT compilation, and how to fine-tune Graal JIT. You also have gained
    a good understanding of how to use some of the advanced analysis and diagnosis
    tools to debug Graal JIT compilation, and identify opportunities to optimize the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a more detailed look at Graal Ahead of Time
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the various tiers of Graal JIT compilation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an intermediate representation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is SSA?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is speculative optimization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between escape analysis and partial escape analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial Escape Analysis and Scalar Replacement for Java ([https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf](https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Basic Graal Graphs ([https://chrisseaton.com/truffleruby/basic-graal-graphs/](https://chrisseaton.com/truffleruby/basic-graal-graphs/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing Strategies of GraalVM ([https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm](https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM Enterprise Edition (EE) ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM documentation ([https://www.graalvm.org/docs/introduction/](https://www.graalvm.org/docs/introduction/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static Single Assignment ([https://gcc.gnu.org/onlinedocs/gccint/SSA.html](https://gcc.gnu.org/onlinedocs/gccint/SSA.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
