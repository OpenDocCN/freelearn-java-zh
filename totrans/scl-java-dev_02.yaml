- en: Chapter 2. Code Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 代码集成
- en: Being able to make Java and Scala cooperate on the same code base is a prerequisite
    to guarantee a smooth transition between the two languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 能够让Java和Scala在同一个代码库上协作是保证两种语言之间平稳过渡的先决条件。
- en: In this chapter, we are going to quickly create a small Java web application
    in which we will show you how to add Scala code to it. Then, we will cover some
    of the most common integration points between Java and Scala and how programming
    styles differ so that programmers who want to refactor and extend their Java application
    can do it according to some guidelines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速创建一个小型的Java Web应用，我们将向您展示如何向其中添加Scala代码。然后，我们将介绍Java和Scala之间的一些最常见的集成点以及编程风格的不同之处，以便希望重构和扩展其Java应用的程序员可以根据一些指南进行操作。
- en: To avoid spending too much time on creating, understanding, and documenting
    a sample Java project, we are going to use a small database that is already available
    as part of the Oracle's NetBeans IDE distribution and create a JPA persistence
    layer as well as a REST API from it using the code generation features of the
    IDE.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在创建、理解和记录示例Java项目上花费太多时间，我们将使用Oracle的NetBeans IDE发行版中已经可用的小型数据库，并使用IDE的代码生成功能从中创建JPA持久层以及REST
    API。
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Download the sample Java project**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例Java项目**'
- en: If you are impatient to directly jump into the Scala code integration features
    of this chapter, you may skip the following section and download the ready-to-use
    maven Java project instead from Packt's website at [www.packtpub.com](http://www.packtpub.com).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你迫不及待地想直接跳到本章的Scala代码集成功能，你可以跳过以下部分，并从Packt的网站[www.packtpub.com](http://www.packtpub.com)下载现成的maven
    Java项目。
- en: Creating a REST API from an existing database
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有数据库创建REST API
- en: The sample database bundled with the NetBeans IDE can be downloaded from the
    [www.netbeans.org](http://www.netbeans.org) website. Just click on the **Download**
    button on this website and pick the JavaEE version of the IDE.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans IDE附带示例数据库可以从[www.netbeans.org](http://www.netbeans.org)网站下载。只需点击该网站上的**下载**按钮，选择IDE的JavaEE版本。
- en: 'Once you have run the installation wizard, seen the **The installation was
    successful!** message, and started the IDE (Version 8.0 in our case), we are ready
    to create a fully functional web app in five minutes. The first time you use it,
    just click on the upper-left corner of the NetBeans IDE to close the startup screen
    and you should see the three tabs: **Projects**, **Files**, and **Services** on
    the left-hand side of the IDE.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了安装向导，看到了**安装成功！**的消息，并且启动了IDE（在我们的例子中是8.0版本），我们就可以在五分钟内创建一个功能齐全的Web应用了。第一次使用时，只需点击NetBeans
    IDE左上角来关闭启动屏幕，你应该能看到IDE左侧的三栏：**项目**、**文件**和**服务**。
- en: The sample database
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例数据库
- en: Our reference database can be seen from the IDE by clicking on the **Services**
    panel. Under the **Databases** menu that is part of the **Services** tab, double-click
    on the `jdbc:derby://localhost:1527/sample [app on APP] Database Connection` link
    to connect to the sample database on port 1527 (the default port for Derby databases)
    with the `app` user on the `APP` schema. Under the `APP` schema, you should find
    seven tables including `CUSTOMER` and `PRODUCT`. By right-clicking on the `CUSTOMER`
    table and choosing **View Data…**, you should be able to browse the content of
    the table.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们参考的数据库可以通过点击IDE中的**服务**面板来查看。在**服务**标签页下的**数据库**菜单中，双击`jdbc:derby://localhost:1527/sample
    [app on APP] Database Connection`链接以连接到1527端口的示例数据库（Derby数据库的默认端口）以及`APP`模式下的`app`用户。在`APP`模式下，你应该能找到包括`CUSTOMER`和`PRODUCT`在内的七个表。通过右键单击`CUSTOMER`表并选择**查看数据…**，你应该能够浏览表的内容。
- en: 'The following diagram depicts the whole database schema so that you can visualize
    the dependencies or foreign keys between the different tables:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了整个数据库模式，以便你可以可视化不同表之间的依赖关系或外键：
- en: '![The sample database](img/3637_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![示例数据库](img/3637_02_01.jpg)'
- en: Setting up a Maven project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Maven项目
- en: 'To quickly set up our sample Java project, you may either import it directly
    in your favorite IDE from the downloaded code (and skip creating JPA entities
    and the REST web service) or perform the following simple steps on the NetBeans
    IDE:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速设置我们的示例Java项目，你可以直接从下载的代码中在你的IDE中导入它（并跳过创建JPA实体和REST Web服务），或者在你喜欢的NetBeans
    IDE上执行以下简单步骤：
- en: Right-click anywhere within the **Projects** tab in the IDE, select **New Project…**,
    and then choose the **Maven** category and the **Web Application** project type.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IDE 的 **项目** 选项卡中右键单击任何位置，选择 **新建项目…**，然后选择 **Maven** 类别和 **Web 应用程序** 项目类型。
- en: Enter `Sample` as **Project Name** and `com.demo` as **Group Id**, and then
    click on the **Next >** button.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **项目名称** 输入为 `Sample`，将 **组 ID** 输入为 `com.demo`，然后点击 **Next >** 按钮。
- en: Make sure a **Server** container is selected for deployment (we use the default
    GlassFish 4.0 as part of the NetBeans distribution) as well as **Java EE 7 Web**
    as the Java EE version.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择 **服务器** 容器进行部署（我们使用 NetBeans 分发中的默认 GlassFish 4.0）以及 **Java EE 7 Web**
    作为 Java EE 版本。
- en: Click on the **Finish** button and you should see the structure of the created
    project under the **Projects** tab.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成** 按钮，你应该能在 **项目** 选项卡下看到创建项目的结构。
- en: Creating JPA entities and REST web services
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 JPA 实体和 REST Web 服务
- en: 'Right-click on the **Sample** project root we just created and navigate to
    **New** | **RESTful Web Services from Databases…**. Selecting the `derby sample`
    database connection from the drop-down list in the newly opened window should
    bring up the database tables into the **Available Tables** section. Mark only
    the `CUSTOMER` table and select **Add>**, both `CUSTOMER` and `DISCOUNT_CODE`
    (which are dependent on `CUSTOMER`) should be listed as **Selected Tables**, as
    shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击我们刚刚创建的 **Sample** 项目根目录，导航到 **新建** | **从数据库创建 RESTful Web 服务…**。从新打开的窗口中的下拉列表中选择
    `derby sample` 数据库连接，应该会将数据库表显示在 **可用表** 部分中。仅标记 `CUSTOMER` 表，并选择 **Add>**，`CUSTOMER`
    和 `DISCOUNT_CODE`（依赖于 `CUSTOMER`）应列在 **已选表** 中，如下截图所示：
- en: '![Creating JPA entities and REST web services](img/3637_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建 JPA 实体和 REST Web 服务](img/3637_02_02.jpg)'
- en: Clicking on the **Next** button and again on **Next** on the next page, and
    finally clicking on **Finish** will generate both the persistence JPA entities
    for `Customer` and `DiscountCode` and the service facade classes, `CustomerFacadeREST`
    and `DiscountCodeFacadeREST`. Note that since Java EE6, the `EntityManager` class
    is instantiated in each service class, which avoids the need for JPA controller
    classes that were generated in the previous versions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮，然后在下一页再次点击 **下一步**，最后点击 **完成** 将生成 `Customer` 和 `DiscountCode`
    的持久化 JPA 实体以及服务外观类，`CustomerFacadeREST` 和 `DiscountCodeFacadeREST`。请注意，自 Java
    EE6 以来，`EntityManager` 类在每个服务类中实例化，这避免了需要生成在先前版本中生成的 JPA 控制器类。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A more detailed version of how to generate a RESTful web service from a database
    is available under the NetBeans tutorial at [www.netbeans.org](http://www.netbeans.org).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NetBeans 教程的 [www.netbeans.org](http://www.netbeans.org) 下有关于如何从数据库生成 RESTful
    Web 服务的更详细版本。
- en: Running and testing the project
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和测试项目
- en: 'Before we start introducing Scala code into our Java project, we may launch
    our application and test REST invocations in a browser. Right-click on the **Sample**
    root node of the project and select **Run** to deploy the application. Once the
    console displays that the GlassFish server is running, and that the message **Hello
    World!** appears in your browser to show that everything is deployed correctly,
    right-click on the `RESTful Web Services` folder under the project root, and select
    **Test RESTful Web Services**. The opening dialog lets you choose between generating
    a test client as part of the same project or externally, as shown in the following
    screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始将 Scala 代码引入我们的 Java 项目之前，我们可以在浏览器中启动我们的应用程序并测试 REST 调用。右键单击项目的 **Sample**
    根节点，选择 **运行** 以部署应用程序。一旦控制台显示 GlassFish 服务器正在运行，并且浏览器中显示 **Hello World!** 消息以表明一切部署正确，右键单击项目根目录下的
    `RESTful Web Services` 文件夹，并选择 **测试 RESTful Web 服务**。打开的对话框允许您选择是否将测试客户端作为同一项目的一部分生成或外部生成，如下截图所示：
- en: '![Running and testing the project](img/3637OS_02_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![运行和测试项目](img/3637OS_02_04.jpg)'
- en: Select **Locally Generated Test Client (suitable for Internet Explorer)** and
    click on **OK**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **本地生成的测试客户端（适用于 Internet Explorer）** 并点击 **确定**。
- en: 'Once deployment completes, the browser will display a test page where we can
    invoke REST methods on our `customer` and `discountcode` entities. If we expand
    the `com.demo.sample.customer` folder, additional parameters will be shown. Clicking
    on the `{id}` parameter, we will get an input field on the right pane where we
    can enter a particular customer `id` value. For instance, we can enter `409`.
    In the drop-down list that shows **MIME** types, select **application/json** and
    `GET` as the method to test, and then click on **Test**, as shown in the following
    screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署完成，浏览器将显示一个测试页面，我们可以在这里调用`customer`和`discountcode`实体的REST方法。如果我们展开`com.demo.sample.customer`文件夹，将显示更多参数。点击`{id}`参数，在右侧面板中会出现一个输入字段，我们可以输入特定的客户`id`值。例如，我们可以输入`409`。在显示**MIME**类型的下拉列表中，选择**application/json**和`GET`作为测试方法，然后点击**测试**，如图所示：
- en: '![Running and testing the project](img/3637_02_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![运行和测试项目](img/3637_02_03.jpg)'
- en: 'The bottom part of the page will now display the response to the REST query.
    It consists of a **Status: 200 (OK)** message and a **Response** content where
    the **Raw View** tab will display the body of the response as JSON, as shown in
    the previous screenshot.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的底部现在将显示REST查询的响应。它包括一个**状态：200（OK）**消息和一个**响应**内容，其中**原始视图**选项卡将显示响应体作为JSON，如图所示。
- en: Adding a unit test in Java
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Java中添加单元测试
- en: 'Finally, we can generate a very simple unit test for the `Customer` class by
    selecting the `Customer.java` source file from the **Projects** pane, and then
    right-clicking on it and navigating to **Tools** | **Create Tests**. Simply click
    on the **OK** button in the dialog and eventually allow the installation of the
    **JUnit 4.xx** if required. The resulting generated file appears within **Test
    Packages** under the same Java package structure as the original class under test,
    in our case `com.demo.sample.CustomerTest.java`, which is a common convention
    when dealing with unit testing in Java. Right-clicking on the `CustomerTest` class
    and choosing **Test File** will make all the test methods run with **JUnit** and
    fail as a `fail` clause is present by default at the end of each tested method.
    For now, just comment out the `fail` statement of `testGetCustomerId` and remove
    all the other test methods. Then, rerun the test to see it in green in the IDE.
    Alternatively, if you have set up the Maven project with another IDE or a plain
    text editor, from the root of the project in the filesystem (where the `pom.xml`
    file is located), you may enter the following Maven command, which you probably
    are familiar with, in a terminal window:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过从**项目**面板中选择`Customer.java`源文件，然后右键单击它并导航到**工具** | **创建测试**来为`Customer`类生成一个非常简单的单元测试。只需在对话框中单击**确定**按钮，并在需要的情况下允许安装**JUnit
    4.xx**。生成的文件将出现在与测试类相同的Java包结构下的**测试包**中，在我们的例子中是`com.demo.sample.CustomerTest.java`，这是在Java中进行单元测试时的常见约定。右键单击`CustomerTest`类并选择**测试文件**将使所有测试方法在**JUnit**下运行，并且默认情况下每个测试方法末尾都有一个`fail`子句，因此会失败。现在，只需注释掉`testGetCustomerId`的`fail`语句并删除所有其他测试方法。然后，重新运行测试以在IDE中看到绿色的结果。或者，如果您已经在另一个IDE或纯文本编辑器中设置了Maven项目，您可以在文件系统中的项目根目录（`pom.xml`文件所在位置）中，在终端窗口中输入以下Maven命令，这可能是您熟悉的命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Adding a test in Scala
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Scala中添加测试
- en: 'For now, we have only Java code in the small sample Maven project. We are ready
    to introduce a few lines of Scala to the same codebase in order to show how both
    languages seamlessly interoperate. Let''s create a `src/test/scala` directory,
    next to the existing `java/` directory, where we will put our following new `CustomerScalaTest.scala`
    class, which is a similar test to the one we already have under `src/test/java`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在小型Maven项目中只有Java代码。我们准备向相同的代码库中添加几行Scala代码，以展示这两种语言如何无缝交互。让我们创建一个`src/test/scala`目录，位于现有的`java/`目录旁边，我们将在这里放置以下新的`CustomerScalaTest.scala`类，这是一个与`src/test/java`下已有的测试类似的测试：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we run the tests again, that is, type `>mvn clean test` again, the class
    will just be ignored as it is not a `.java` source file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试，即再次输入`>mvn clean test`，该类将被忽略，因为它不是一个`.java`源文件。
- en: Setting up Scala within a Java Maven project
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java Maven项目中设置Scala
- en: 'In order to be able to start writing a Scala unit test and compile Scala code
    into our Java project, we need to add a few dependencies and the scala-maven-plugin
    to the `pom.xml` file. The dependencies are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够开始编写Scala单元测试并将Scala代码编译到我们的Java项目中，我们需要在`pom.xml`文件中添加一些依赖项和scala-maven-plugin。依赖项如下：
- en: 'Dependency for the core scala-library:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心scala-library的依赖：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Dependency for scalatest (a framework for testing in Scala that supports JUnit
    and other styles; we will cover it in detail in [Chapter 4](ch04.html "Chapter 4. Testing
    Tools"), *Testing Tools)*:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scalatest（一个支持JUnit和其他风格的Scala测试框架；我们将在[第4章](ch04.html "第4章. 测试工具")中详细介绍）的依赖：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Dependency for JUnit to use Java `Assert` statements in our test case:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试用例中使用Java `Assert`语句的JUnit依赖：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Concerning the `scala-maven-plugin`, just add something similar to the following
    XML block to the `<plugins>` section of your `pom.xml` build file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`scala-maven-plugin`，只需将以下XML块添加到`pom.xml`构建文件的`<plugins>`部分即可：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we try to rerun the tests, this time our newly created Scala test will be
    picked up and executed, as shown in the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试重新运行测试，这次我们的新创建的Scala测试将被选中并执行，如下代码片段所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A couple of observations are worth mentioning about the `CustomerScalaTest.scala`
    class. They are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`CustomerScalaTest.scala`类，有几个观察结果值得提及。如下：
- en: The package declaration at the top of the file is similar to package declarations
    in Java. However, having a package declaration in Scala mirroring the path of
    directories in the filesystem is not a requirement unlike Java, but is still recommended.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件顶部的包声明与Java中的包声明类似。然而，与Java不同，Scala中不需要在Scala中有一个与文件系统目录路径相对应的包声明，尽管推荐这样做。
- en: Import statements in Scala are similar to Java except that the `*` wildcard
    is replaced by the underscore, `_`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala中的导入语句与Java类似，只是`*`通配符被下划线`_`替换。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You probably noticed that we suddenly have the enormous power to use any Java
    library in our Scala code, which means that we will never be stuck and can always
    invoke methods in the existing Java classes if we need a piece of functionality
    that is not directly available in Scala.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们突然有了使用任何Java库的巨大能力，这意味着如果我们需要Scala中直接不可用的功能，我们永远都不会陷入困境，并且可以始终调用现有Java类中的方法。
- en: With very few additions to the `pom.xml` build file, we now have made a regular
    Java project Scala aware, which means that we can freely add Scala classes and
    invoke any Java library within them. This also means that as Java developers,
    we are now able to migrate or refactor only small parts of a project if it makes
    sense and progressively improve our codebase as we get more acquainted with the
    Scala constructs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pom.xml`构建文件中仅添加少量内容后，我们现在已经使一个常规Java项目对Scala有了认识，这意味着我们可以自由地添加Scala类并在其中调用任何Java库。这也意味着作为Java开发者，我们现在能够在项目有意义的情况下迁移或重构项目的小部分，随着我们越来越熟悉Scala结构，逐步改进我们的代码库。
- en: This approach of dealing with an existing Maven project is only one way of proceeding.
    In the next chapter, we will see some other approaches with a more radical change
    that involves the Scala's **Simple Build** **Tool** (**SBT**), an alternative
    to Maven builds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理现有Maven项目的方法只是进行操作的一种方式。在下一章中，我们将看到一些其他方法，这些方法涉及更激进的改变，包括Scala的**简单构建工具**（**SBT**），它是Maven构建的替代方案。
- en: Scala and Java collaboration
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala和Java协作
- en: Going back to the REPL, we are going to experiment further with mixing Scala
    and Java to explore some common integration needs, and in particular, testing
    and manipulating the Java REST API that we have built at the beginning of the
    chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回到REPL，我们将进一步实验Scala和Java的混合使用，以探索一些常见的集成需求，特别是测试和操作我们在本章开头构建的Java REST API。
- en: 'As a reminder on how to restart the REPL from the *hello-scala* project introduced
    in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within Your Project"),
    *Programming Interactively within Your Project*, if you closed it in the meantime,
    just start a new terminal window, navigate to the root of the *hello-scala* project,
    and enter the following command in the command prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对如何在[第1章](ch01.html "第1章. 在项目中交互式编程")中介绍的*hello-scala*项目重启REPL的提醒，如果在此期间关闭了它，只需启动一个新的终端窗口，导航到*hello-scala*项目的根目录，并在命令提示符中输入以下命令：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Converting between collection types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合类型之间转换
- en: 'Let''s start by comparing Java and Scala collection classes and see how we
    can go from one to the other. For instance, a Scala `List` (from the `scala.collection.immutable`
    package) is different from `java.util.List`, and sometimes, it can be useful to
    convert from one to the other. A convenient way in Java to create `java.util.List`
    is to use the `java.util.Arrays` utility method, `asList`, whose exact signature
    is `public static<T> List<T> asList(T... a)`, where `T` refers to a generic type.
    Let''s import it in the REPL as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先比较Java和Scala的集合类，看看我们如何从一个转换到另一个。例如，Scala的`List`（来自`scala.collection.immutable`包）与`java.util.List`不同，有时，从一种转换到另一种可能很有用。在Java中创建`java.util.List`的一个方便方法是使用`java.util.Arrays`实用方法`asList`，其确切签名是`public
    static<T> List<T> asList(T... a)`，其中`T`指的是泛型类型。让我们按照以下方式在REPL中导入它：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the JDK classes are in the class path, they can be directly accessed into
    the REPL as shown in the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JDK类在类路径中，它们可以直接在REPL中访问，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have instantiated a Java list of integers, we want to convert it
    to its Scala equivalent and need to import the `JavaConverters` classes for that
    using the following lines of command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实例化了一个整数Java列表，我们想要将其转换为Scala等价物，并需要使用以下命令行导入`JavaConverters`类：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Looking at the documentation of `JavaConverters` in Scaladoc (which is similar
    to Javadoc, used to document Scala APIs, and available online at [www.scala-lang.org/api/current/index.html](http://www.scala-lang.org/api/current/index.html)),
    we can see, for example, that the equivalent of `java.util.List` is `scala.collection.mutable.Buffer`.
    So, if we invoke the `asScala` method on `java.util.List`, we will get exactly
    that:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scaladoc（与Javadoc类似，用于记录Scala API，可在[www.scala-lang.org/api/current/index.html](http://www.scala-lang.org/api/current/index.html)在线查看）中查看`JavaConverters`的文档，我们可以看到，例如，`java.util.List`的等价物是`scala.collection.mutable.Buffer`。因此，如果我们对`java.util.List`调用`asScala`方法，我们将得到确切的结果：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, by invoking the `asJava` method on `scalaList`, we will get back our original
    `java.util.List` collection:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在`scalaList`上调用`asJava`方法，我们将得到原始的`java.util.List`集合：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A good test to verify that we get back the original object after converting
    it to a target type and back again is to use an `assert` statement, as shown in
    the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证在将对象转换为目标类型并再次转换回来后我们是否得到了原始对象，可以使用`assert`语句，如下面的命令所示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having no output from `assert` means that it evaluated to `True`; otherwise,
    we would get a stack trace that shows why they are not equal. You might wonder
    where this `assert` method comes from; `assert` is a method of the `Predef` class,
    a Scala class imported by default containing useful aliases for commonly used
    types, assertions like the one we have used, and simple functions for console's
    I/O and implicit conversions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`assert`没有输出，这意味着它评估为`True`；否则，我们会得到一个堆栈跟踪，显示为什么它们不相等。你可能想知道这个`assert`方法从哪里来；`assert`是`Predef`类的一个方法，这是一个Scala类，默认导入，包含常用类型的别名、断言（如我们使用的）以及控制台I/O和隐式转换的简单函数。
- en: JavaBean-style properties
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaBean风格的属性
- en: 'To ensure compatibility with Java frameworks such as Hibernate or JMX, you
    may sometimes need Java-style getters and setters on the fields of your class.
    For example, if we declare a `Company` class in the REPL as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保与Java框架如Hibernate或JMX的兼容性，有时你可能在类的字段上需要Java风格的getter和setter。例如，如果我们按照以下方式在REPL中声明一个`Company`类：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have seen in [Chapter 1](ch01.html "Chapter 1. Programming Interactively
    within Your Project"), *Programming Interactively within Your Project*, that Scala
    accessor methods to read and mutate the `name` field are `name` and `name_=`,
    respectively, as shown in the following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。在项目中交互式编程")中看到，*在项目中交互式编程*，Scala访问器方法来读取和修改`name`字段分别是`name`和`name_=`，如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A straightforward way to have Java-style getters and setters is to annotate
    the field with `scala.beans.BeanProperty` as shown in the following lines of command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要有Java风格的getter和setter的一个直接方法是使用`scala.beans.BeanProperty`注解字段，如下面的命令行所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scala and Java object orientation
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala和Java面向对象
- en: 'The interoperability between Scala and Java classes makes it very straightforward
    to replace or extend an existing Java class with a Scala class. Compiling a Scala
    class produces bytecode that is pretty similar to what Java produces. For example,
    let''s take a shorter version of the `Customer` Java class we generated earlier:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 和 Java 类之间的互操作性使得用 Scala 类替换或扩展现有的 Java 类变得非常简单。编译 Scala 类产生的字节码与 Java
    产生的非常相似。例如，让我们看一下我们之前生成的 `Customer` Java 类的简短版本：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we refactor it into a Scala class with class parameters and create an instance,
    we get the following in the REPL:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将它重构为一个具有类参数的 Scala 类并创建一个实例，在 REPL 中我们会得到以下内容：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, a constructor that takes only a single `zip` parameter does not exist
    in this definition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个定义中不存在只接受单个 `zip` 参数的构造函数：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To complete our refactoring of the Java class, we need an extra constructor
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们对 Java 类的重构，我们需要一个额外的构造函数，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This time, we were able to create an instance with the auxiliary constructor,
    which obeys to a couple of rules. They are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们能够使用辅助构造函数创建一个实例，它遵循一些规则。具体如下：
- en: Any auxiliary constructor must immediately call another `this(…)` constructor
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何辅助构造函数都必须立即调用另一个 `this(…)` 构造函数
- en: The primary constructor has to be called in the end to make sure all the parameters
    are initialized
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要构造函数必须在最后被调用，以确保所有参数都已初始化
- en: Scala traits as enhanced Java interfaces
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 特质作为增强的 Java 接口
- en: 'Software interfaces are useful mechanisms to make a piece of code interact
    via a contract to other external software systems, isolating the specification
    of what it does from its implementation. Although Java classes on the JVM have
    the limitation to only extend one single class, they can have multiple types by
    implementing several interfaces. However, Java interfaces are purely abstract,
    that is, they contain only constants, method signatures, and nested types, but
    no method bodies; for example, see the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 软件接口是使代码通过合同与其他外部软件系统交互的有用机制，将它的行为规范与其实现隔离开来。尽管 JVM 上的 Java 类只能扩展一个单一类，但它们可以通过实现多个接口拥有多个类型。然而，Java
    接口是纯抽象的，即它们只包含常量、方法签名和嵌套类型，但没有方法体；例如，请参见以下代码片段：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In contrast, Scala traits are more powerful by allowing partial implementation
    of method bodies and therefore, more reusable. One can use a trait to mix in behavior
    into a class. Let''s take an example in the REPL:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Scala 特质更强大，因为它允许部分实现方法体，因此更可重用。可以使用特质将行为混合到类中。让我们在 REPL 中举一个例子：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This class declares two fields, `name` and `discountCode` (initialized to `"N"`
    for normal), as well as two methods, `discounts()` and `toString()`, where `discounts()`
    accumulates discounts for a customer into `List` of integers (initialized to a
    `5` percent discount) and `toString()` displays it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此类声明了两个字段，`name` 和 `discountCode`（初始化为 `"N"` 表示正常），以及两个方法，`discounts()` 和 `toString()`，其中
    `discounts()` 将客户的折扣累加到整数列表（初始化为 `5` 百分比折扣）中，而 `toString()` 则显示它。
- en: 'We can define a couple of traits that extends the class we just created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义几个扩展我们刚刚创建的类的特质：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A `VIPCustomer` class is a customer who gets an extra `10` percent discount
    concatenated to the list of all of the already available discounts he/she has.
    The second trait is given as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`VIPCustomer` 类是一个客户，可以获得额外的 `10` 百分比折扣，并将其附加到所有已提供的折扣列表中。第二个特质如下所示：'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A `GoldCustomer` class is a customer who gets an additional `15` percent discount
    or even `20` percent if her rating, that is, `discountCode` is `"H"` (high).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`GoldCustomer` 类是一个客户，可以获得额外的 `15` 百分比折扣，或者如果她的评级，即 `discountCode` 是 `"H"`（高），则可以获得
    `20` 百分比折扣。'
- en: 'Let''s now write a `Main` class to show the addition of stackable traits when
    instantiating the `Customer` class. We use the `with` keyword to mix in these
    additional behaviors into the class as shown in the following lines of command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写一个 `Main` 类来展示在实例化 `Customer` 类时堆叠特质时的添加。我们使用 `with` 关键字将这些额外的行为混合到类中，如下所示：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now simply execute the main method and get the expected result as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以简单地执行主方法，并得到以下预期的结果：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the order in which traits are stacked is important. They are calling
    each other from right to left. `GoldCustomer` is, therefore, the first one to
    be called.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意特质堆叠的顺序很重要。它们是从右到左相互调用的。因此，`GoldCustomer` 是第一个被调用的。
- en: Traits lie between interfaces and abstract classes. However, you can only extend
    one abstract class whereas you can extend several traits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 特性位于接口和抽象类之间。然而，你只能扩展一个抽象类，而可以扩展多个特性。
- en: Declaring objects
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明对象
- en: 'Java code often refers to the `static` keyword to refer to singleton methods
    and constants. Scala does not support the `static` identifier, but instead provides
    the notion of `object` in place of the `class` declaration. If you need to refactor
    Java code into Scala, by simply using the `object` declaration instead of `class`,
    you get singleton instances and you''re done, having the extra advantage that
    such Scala objects can also extend interfaces and traits. A simple example of
    `object` is the declaration of the `Main` program we exhibited earlier in the
    usage of stackable traits, or the following simple `hello world` application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码经常使用`static`关键字来引用单例方法和常量。Scala不支持`static`标识符，而是用`object`概念代替`class`声明。如果你需要将Java代码重构为Scala，只需使用`object`声明而不是`class`，你就可以得到单例实例，任务完成，额外的优势是这种Scala对象也可以扩展接口和特性。`object`的一个简单例子是我们之前在可堆叠特性使用中展示的`Main`程序声明，或者以下简单的`hello
    world`应用程序：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition to the notion of object, Scala provides the notion of companion
    object, which consists of an object that cohabits with a class of the same name
    in the same package and file. This is why it is called **companion**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象的概念之外，Scala还提供了伴生对象的概念，它由一个与同一包和文件中的同名类共存的伴生对象组成。这就是为什么它被称为**伴生**。
- en: Introducing companion objects
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍伴生对象
- en: 'The companion object enables storing of static methods and from this, you have
    full access to the classes'' members, including private ones. It is, for example,
    a good place to declare static factory methods, and **case classes** overload
    the `apply` factory method so that you are not required to use the `new` keyword
    when creating case class instances:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 伴生对象允许存储静态方法，并且从这一点出发，你可以完全访问类的成员，包括私有成员。例如，这是一个声明静态工厂方法的好地方，并且**案例类**重载了`apply`工厂方法，这样在创建案例类实例时就不需要使用`new`关键字：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, you can still use the `new` keyword if you want to, shown as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想使用，也可以使用`new`关键字，如下所示：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Under the hood, the case class is constructed as a regular class that has,
    among other things, a companion object similar to the following (although simplified)
    code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，案例类被构建为一个常规类，其中包含其他东西，比如以下（虽然简化了）的伴生对象代码片段：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Handling exceptions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'We conclude this section about how to migrate code from Java to Scala with
    exceptions, a notion that appears everywhere in Java. In a quite similar way to
    Java, you can write the `try { } catch { }` blocks to capture method invocations
    that might fail. In Java, you would write something similar to the following code
    snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结本节关于如何使用异常将代码从Java迁移到Scala的内容，这个概念在Java中无处不在。与Java非常相似，你可以编写`try { } catch
    { }`块来捕获可能失败的方法调用。在Java中，你会编写类似于以下代码片段的内容：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code produces the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In Scala, you could translate it directly to the equivalent code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，你可以直接将其翻译成等效的代码：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, in this case, the return value inferred by the compiler is not only
    empty but also of the wrong type, `AnyVal`, which is the common type found between
    an `Int` value and whatever is returned by the exception. To make sure we get
    an integer as the output, we need to return an `Int` value from all the possible
    cases found in the `catch` block:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，编译器推断出的返回值不仅为空，而且类型错误，是`AnyVal`类型，这是`Int`值和异常返回值之间的通用类型。为了确保我们得到整数作为输出，我们需要从`catch`块中找到的所有可能情况中返回一个`Int`值：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This time we can capture the correct return type from the parsing invocation
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们可以从解析调用中捕获正确的返回类型，如下所示：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In all cases, we return an `Int` value, `-1` in case of failure. This solution
    is still only partly satisfying as the caller does not really know the reason
    of failure unless we display/log it. A better way is to use, for example, an `Either`
    class that represents a value of one of the two possible types, where its instances
    are either of the `scala.util.Left` or `scala.util.Right` type. In this case,
    we can use the `Left` part to handle the failure and the `Right` part to handle
    a successful result as shown in the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，我们返回一个`Int`值，失败时返回`-1`。这个解决方案仍然只能部分令人满意，因为调用者除非我们显示/记录它，否则并不真正知道失败的原因。更好的方法是使用例如`Either`类，它表示两种可能类型之一的值，其实例要么是`scala.util.Left`类型，要么是`scala.util.Right`类型。在这种情况下，我们可以使用`Left`部分来处理失败，使用`Right`部分来处理成功结果，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Writing explicitly the return type will cause a compilation error on these types
    of errors, and therefore, is highly recommended.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 明确写出返回类型会导致这些类型的错误在编译时出错，因此强烈推荐这样做。
- en: Finally, without going into too much detail, there is an even more appropriate
    way of handling the `try` and `catch` blocks that are derived from `Either` using
    the `scala.util.Try` class. Instead of handling the exception as `Left` and `Right`,
    it returns `Failure[Throwable]` or `Success[T]`, `T` being a generic type. The
    advantage of this approach is that it can be used in for comprehensions (but we
    have not covered them yet, examples will come in [Chapter 5](ch05.html "Chapter 5. Getting
    Started with the Play Framework"), *Getting Started with the Play Framework*).
    Moreover, the semantics of `Try` for error handling is better than `Either` as
    it describes `Success` or `Failure` rather than the less meaningful and more generic
    terms `Left` and `Right`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无需过多细节，使用`scala.util.Try`类处理从`Either`派生的`try`和`catch`块还有另一种更合适的方法。它不是将异常处理为`Left`和`Right`，而是返回`Failure[Throwable]`或`Success[T]`，其中`T`是一个泛型类型。这种方法的优点是它可以在for推导式中使用（但我们还没有介绍它们，示例将在[第5章](ch05.html
    "第5章。Play框架入门")中给出，*Play框架入门*）。此外，`Try`在错误处理方面的语义比`Either`更好，因为它描述的是`Success`或`Failure`，而不是不那么有意义且更通用的术语`Left`和`Right`。
- en: Differences in style between Java and Scala code
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java和Scala代码之间的风格差异
- en: If you are going to refactor or rewrite Java code into Scala code, there are
    a number of style differences that are useful to be aware of. Obviously, programming
    style is largely a matter of taste; however, a few guidelines generally acknowledged
    by the Scala community can help someone new to Scala to write easier-to-read and
    more maintainable code. This section is dedicated to showing some of the most
    common differences.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将Java代码重构或重写为Scala代码，有一些风格差异是有用的，值得注意。显然，编程风格在很大程度上是一个品味问题；然而，Scala社区普遍认可的一些指导原则可以帮助Scala的新手编写更易于阅读和更易于维护的代码。本节致力于展示一些最常见的差异。
- en: Writing an algorithm in Java follows an imperative style, that is, a sequence
    of statements that change a program state. Scala, focusing primarily on functional
    programming, adopts a more declarative approach, where everything is an expression
    rather than a statement. Let's illustrate this in an example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中编写算法遵循命令式风格，即一系列改变程序状态的语句序列。Scala主要关注函数式编程，采用更声明式的编程方法，其中一切都是一个表达式而不是一个语句。让我们通过一个例子来说明这一点。
- en: 'In Java, you would commonly find the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你通常会找到以下代码片段：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The Scala equivalent consists of the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的等效代码如下所示：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that unlike the Java statements, `if` is now embedded as part of the resulting
    evaluated expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与Java语句不同，`if`现在被嵌入为结果评估表达式的一部分。
- en: In general, working where everything is evaluated as an expression (and here
    an immutable expression) will make it much easier for reuse as well as composition.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将所有内容作为表达式（在这里是一个不可变表达式）评估的工作方式将使代码的重用和组合变得更加容易。
- en: Being able to chain the result of one expression to the next will give you a
    concise way of expressing fairly complicated transformations that would require
    much more code in Java.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将一个表达式的结果链接到下一个表达式，将为您提供一种简洁的方式来表达相对复杂的转换，这在Java中可能需要更多的代码。
- en: Adjusting the code layout
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整代码布局
- en: 'As the intent of functional programming is to minimize state behavior, it often
    consists of short lambda expressions so that you can visualize a fairly complicated
    transformation in an elegant and concise way, in many cases even as one-liners.
    For this reason, general formatting in Scala recommends that you use only two-space
    indentations instead of the four-space indentation that is generally admitted
    in Java code, as shown in the following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的意图是尽量减少状态行为，它通常由简短的lambda表达式组成，这样你就可以以一种优雅和简洁的方式可视化一个相当复杂的转换，在许多情况下甚至是一行代码。因此，Scala的一般格式建议你只使用两个空格缩进，而不是Java代码中普遍接受的四个空格缩进，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you have many constructor/method parameters, having them aligned as previously
    illustrated makes it easier to change them without the need to reformat the whole
    indentation. It is also the case if you want to refactor the class with a longer
    name, for example, `VeryImportantCustomer` instead of `Customer`; it will make
    smaller and more precise differences against your version control management system
    (Git, subversion, and so on).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多构造函数/方法参数，按照前面所示对它们进行对齐可以使更改它们而不需要重新格式化整个缩进变得更容易。如果你想要重构具有更长名称的类，例如，将`Customer`改为`VeryImportantCustomer`，这将对你的版本控制系统（Git、subversion等）产生更小、更精确的差异。
- en: Naming conventions
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名规范
- en: Conventions for naming packages, classes, fields, and methods in the camel case
    generally follow the Java conventions. Note that you should avoid the underscore
    (`_`) in variable names (such as `first_name` or `_first_name`) as the underscore
    has a special meaning in Scala (`self` or `this` in anonymous functions).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在驼峰命名法中命名包、类、字段和方法通常遵循Java规范。请注意，你应该避免在变量名中使用下划线（例如`first_name`或`_first_name`），因为在Scala中下划线有特殊含义（在匿名函数中是`self`或`this`）。
- en: 'However, constants, most likely declared as `private static final myConstant`
    in Java, are normally declared in Scala in the upper camel case, such as in the
    following enclosing object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，常量，很可能是用Java中的`private static final myConstant`声明的，在Scala中通常使用大驼峰命名法声明，如下面的封装对象所示：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Choosing a meaningful name for variables and methods should always be a priority
    in Java, and it is often recommended to use rather long variable names to precisely
    describe what a variable or method represents. In Scala, things are a little bit
    different; meaningful names are, of course, a good way to make code more readable.
    However, as we are at the same time aiming at making behavior transformations
    concise through the use of functions and lambda expressions, short variable names
    can be an advantage if you can capture a whole piece of functionality in a short
    block of code. For example, incrementing a list of integers in Scala can simply
    be expressed as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，为变量和方法选择一个有意义的名称始终是一个优先事项，通常建议使用较长的变量名来精确描述变量或方法所代表的内容。在Scala中，情况略有不同；有意义的名称当然是使代码更易读的好方法。然而，我们同时还在通过使用函数和lambda表达式来使行为转换简洁，如果能在一段简短的代码块中捕捉到整个功能，短变量名可以是一个优势。例如，在Scala中递增整数列表可以简单地表示如下：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Although using `x` as a variable name is often discouraged in Java, here it
    does not matter that much as the variable is not reused and we can capture the
    transformation it does at once. There are many short or long alternatives to the
    previous lambda syntax that will produce the same result. So, which one to choose?
    Some of the alternatives are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Java中使用`x`作为变量名通常是不被推荐的，但在这里这并不重要，因为变量没有被重用，我们可以立即捕捉到它所做的转换。有许多短或长的替代lambda语法会产生相同的结果。所以，应该选择哪一个？以下是一些替代方案：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this case, a long variable name breaks a clear and concise one-liner into
    two lines of code, thereby, making it difficult to understand. Meaningful names
    make more sense here if we start expressing logic on several lines as shown in
    the following code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个长的变量名将一个清晰简洁的一行代码分成两行，因此，使理解变得困难。如果像以下代码片段所示，我们在多行上开始表达逻辑，有意义的名称在这里更有意义。
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A shorter but still expressive name is sometimes a good compromise to indicate
    to the reader that this is an amount we are currently manipulating in our lambda
    expression, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个较短但仍具有表达力的名称是一个很好的折衷方案，向读者表明这是一个我们在lambda表达式中当前正在操作的数量，如下所示：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, the shortest syntax of all that is well accepted by fluent Scala programmers
    for such a simple increment function is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这样一个简单的递增函数，所有这些语法中最简洁的语法，熟练的Scala程序员会这样写：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Underscores are also encountered in Scala for expressing more complicated operations
    in an elegant but more awkward way, as is the following *sum* operation using
    the `foldLeft` method that accumulates the state from one element to the other
    (and is covered in the previous chapter):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，下划线也用于以优雅但略显笨拙的方式表达更复杂的操作，如下面的使用`foldLeft`方法的求和操作（在上一章中已介绍）：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead of explicitly having `0` as the initial value for the sum, we can write
    this summation a bit more elegantly by using the `reduce` method that is similar
    to `foldLeft`. However, we take the first element of the collection as the initial
    value (here, `3` will be the initial value), as shown in the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将`0`显式地作为求和的初始值，我们可以通过使用类似于`foldLeft`的`reduce`方法来使这个求和表达式更加优雅。然而，我们将集合的第一个元素作为初始值（在这里，`3`将是初始值），如下面的命令所示：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As far as style is concerned, fluent Scala programmers will not have any problem
    reading this code. However, if the state accumulation operation is more complicated
    than just a simple `+` operation, it might be wise to write it more explicitly
    as shown in the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就风格而言，熟练的Scala程序员阅读这段代码不会有任何问题。然而，如果状态累积操作比简单的`+`操作更复杂，那么按照以下命令更明确地编写它可能更明智：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered how to start integrating Scala code into a
    Java codebase as well as how to refactor some of the most common Java constructs
    into Scala by following some style guidelines. A much more exhaustive list of
    style recommendations is available at [http://docs.scala-lang.org/style/](http://docs.scala-lang.org/style/)
    if you are interested in learning more.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何开始将Scala代码集成到Java代码库中，以及如何遵循一些风格指南将一些最常用的Java结构重构为Scala。如果您想了解更多，可以在[http://docs.scala-lang.org/style/](http://docs.scala-lang.org/style/)找到一份更详尽的风格建议列表。
- en: So far we have been mostly addressing the Scala language and syntax. In the
    next chapter, we are going to introduce the tools that complement it and that
    are necessary to make our Scala programming both productive and enjoyable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了Scala语言和语法。在下一章中，我们将介绍补充它的工具，以及使我们的Scala编程既高效又愉快所必需的工具。
