- en: Chapter 2. Code Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to make Java and Scala cooperate on the same code base is a prerequisite
    to guarantee a smooth transition between the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to quickly create a small Java web application
    in which we will show you how to add Scala code to it. Then, we will cover some
    of the most common integration points between Java and Scala and how programming
    styles differ so that programmers who want to refactor and extend their Java application
    can do it according to some guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid spending too much time on creating, understanding, and documenting
    a sample Java project, we are going to use a small database that is already available
    as part of the Oracle's NetBeans IDE distribution and create a JPA persistence
    layer as well as a REST API from it using the code generation features of the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Download the sample Java project**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are impatient to directly jump into the Scala code integration features
    of this chapter, you may skip the following section and download the ready-to-use
    maven Java project instead from Packt's website at [www.packtpub.com](http://www.packtpub.com).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a REST API from an existing database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample database bundled with the NetBeans IDE can be downloaded from the
    [www.netbeans.org](http://www.netbeans.org) website. Just click on the **Download**
    button on this website and pick the JavaEE version of the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have run the installation wizard, seen the **The installation was
    successful!** message, and started the IDE (Version 8.0 in our case), we are ready
    to create a fully functional web app in five minutes. The first time you use it,
    just click on the upper-left corner of the NetBeans IDE to close the startup screen
    and you should see the three tabs: **Projects**, **Files**, and **Services** on
    the left-hand side of the IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: The sample database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our reference database can be seen from the IDE by clicking on the **Services**
    panel. Under the **Databases** menu that is part of the **Services** tab, double-click
    on the `jdbc:derby://localhost:1527/sample [app on APP] Database Connection` link
    to connect to the sample database on port 1527 (the default port for Derby databases)
    with the `app` user on the `APP` schema. Under the `APP` schema, you should find
    seven tables including `CUSTOMER` and `PRODUCT`. By right-clicking on the `CUSTOMER`
    table and choosing **View Data…**, you should be able to browse the content of
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the whole database schema so that you can visualize
    the dependencies or foreign keys between the different tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The sample database](img/3637_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up a Maven project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly set up our sample Java project, you may either import it directly
    in your favorite IDE from the downloaded code (and skip creating JPA entities
    and the REST web service) or perform the following simple steps on the NetBeans
    IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click anywhere within the **Projects** tab in the IDE, select **New Project…**,
    and then choose the **Maven** category and the **Web Application** project type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Sample` as **Project Name** and `com.demo` as **Group Id**, and then
    click on the **Next >** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure a **Server** container is selected for deployment (we use the default
    GlassFish 4.0 as part of the NetBeans distribution) as well as **Java EE 7 Web**
    as the Java EE version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button and you should see the structure of the created
    project under the **Projects** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating JPA entities and REST web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right-click on the **Sample** project root we just created and navigate to
    **New** | **RESTful Web Services from Databases…**. Selecting the `derby sample`
    database connection from the drop-down list in the newly opened window should
    bring up the database tables into the **Available Tables** section. Mark only
    the `CUSTOMER` table and select **Add>**, both `CUSTOMER` and `DISCOUNT_CODE`
    (which are dependent on `CUSTOMER`) should be listed as **Selected Tables**, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating JPA entities and REST web services](img/3637_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the **Next** button and again on **Next** on the next page, and
    finally clicking on **Finish** will generate both the persistence JPA entities
    for `Customer` and `DiscountCode` and the service facade classes, `CustomerFacadeREST`
    and `DiscountCodeFacadeREST`. Note that since Java EE6, the `EntityManager` class
    is instantiated in each service class, which avoids the need for JPA controller
    classes that were generated in the previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more detailed version of how to generate a RESTful web service from a database
    is available under the NetBeans tutorial at [www.netbeans.org](http://www.netbeans.org).
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start introducing Scala code into our Java project, we may launch
    our application and test REST invocations in a browser. Right-click on the **Sample**
    root node of the project and select **Run** to deploy the application. Once the
    console displays that the GlassFish server is running, and that the message **Hello
    World!** appears in your browser to show that everything is deployed correctly,
    right-click on the `RESTful Web Services` folder under the project root, and select
    **Test RESTful Web Services**. The opening dialog lets you choose between generating
    a test client as part of the same project or externally, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and testing the project](img/3637OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select **Locally Generated Test Client (suitable for Internet Explorer)** and
    click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once deployment completes, the browser will display a test page where we can
    invoke REST methods on our `customer` and `discountcode` entities. If we expand
    the `com.demo.sample.customer` folder, additional parameters will be shown. Clicking
    on the `{id}` parameter, we will get an input field on the right pane where we
    can enter a particular customer `id` value. For instance, we can enter `409`.
    In the drop-down list that shows **MIME** types, select **application/json** and
    `GET` as the method to test, and then click on **Test**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and testing the project](img/3637_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The bottom part of the page will now display the response to the REST query.
    It consists of a **Status: 200 (OK)** message and a **Response** content where
    the **Raw View** tab will display the body of the response as JSON, as shown in
    the previous screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a unit test in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we can generate a very simple unit test for the `Customer` class by
    selecting the `Customer.java` source file from the **Projects** pane, and then
    right-clicking on it and navigating to **Tools** | **Create Tests**. Simply click
    on the **OK** button in the dialog and eventually allow the installation of the
    **JUnit 4.xx** if required. The resulting generated file appears within **Test
    Packages** under the same Java package structure as the original class under test,
    in our case `com.demo.sample.CustomerTest.java`, which is a common convention
    when dealing with unit testing in Java. Right-clicking on the `CustomerTest` class
    and choosing **Test File** will make all the test methods run with **JUnit** and
    fail as a `fail` clause is present by default at the end of each tested method.
    For now, just comment out the `fail` statement of `testGetCustomerId` and remove
    all the other test methods. Then, rerun the test to see it in green in the IDE.
    Alternatively, if you have set up the Maven project with another IDE or a plain
    text editor, from the root of the project in the filesystem (where the `pom.xml`
    file is located), you may enter the following Maven command, which you probably
    are familiar with, in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adding a test in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For now, we have only Java code in the small sample Maven project. We are ready
    to introduce a few lines of Scala to the same codebase in order to show how both
    languages seamlessly interoperate. Let''s create a `src/test/scala` directory,
    next to the existing `java/` directory, where we will put our following new `CustomerScalaTest.scala`
    class, which is a similar test to the one we already have under `src/test/java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we run the tests again, that is, type `>mvn clean test` again, the class
    will just be ignored as it is not a `.java` source file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Scala within a Java Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be able to start writing a Scala unit test and compile Scala code
    into our Java project, we need to add a few dependencies and the scala-maven-plugin
    to the `pom.xml` file. The dependencies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency for the core scala-library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dependency for scalatest (a framework for testing in Scala that supports JUnit
    and other styles; we will cover it in detail in [Chapter 4](ch04.html "Chapter 4. Testing
    Tools"), *Testing Tools)*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dependency for JUnit to use Java `Assert` statements in our test case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Concerning the `scala-maven-plugin`, just add something similar to the following
    XML block to the `<plugins>` section of your `pom.xml` build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to rerun the tests, this time our newly created Scala test will be
    picked up and executed, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of observations are worth mentioning about the `CustomerScalaTest.scala`
    class. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The package declaration at the top of the file is similar to package declarations
    in Java. However, having a package declaration in Scala mirroring the path of
    directories in the filesystem is not a requirement unlike Java, but is still recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import statements in Scala are similar to Java except that the `*` wildcard
    is replaced by the underscore, `_`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You probably noticed that we suddenly have the enormous power to use any Java
    library in our Scala code, which means that we will never be stuck and can always
    invoke methods in the existing Java classes if we need a piece of functionality
    that is not directly available in Scala.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With very few additions to the `pom.xml` build file, we now have made a regular
    Java project Scala aware, which means that we can freely add Scala classes and
    invoke any Java library within them. This also means that as Java developers,
    we are now able to migrate or refactor only small parts of a project if it makes
    sense and progressively improve our codebase as we get more acquainted with the
    Scala constructs.
  prefs: []
  type: TYPE_NORMAL
- en: This approach of dealing with an existing Maven project is only one way of proceeding.
    In the next chapter, we will see some other approaches with a more radical change
    that involves the Scala's **Simple Build** **Tool** (**SBT**), an alternative
    to Maven builds.
  prefs: []
  type: TYPE_NORMAL
- en: Scala and Java collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going back to the REPL, we are going to experiment further with mixing Scala
    and Java to explore some common integration needs, and in particular, testing
    and manipulating the Java REST API that we have built at the beginning of the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder on how to restart the REPL from the *hello-scala* project introduced
    in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within Your Project"),
    *Programming Interactively within Your Project*, if you closed it in the meantime,
    just start a new terminal window, navigate to the root of the *hello-scala* project,
    and enter the following command in the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Converting between collection types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by comparing Java and Scala collection classes and see how we
    can go from one to the other. For instance, a Scala `List` (from the `scala.collection.immutable`
    package) is different from `java.util.List`, and sometimes, it can be useful to
    convert from one to the other. A convenient way in Java to create `java.util.List`
    is to use the `java.util.Arrays` utility method, `asList`, whose exact signature
    is `public static<T> List<T> asList(T... a)`, where `T` refers to a generic type.
    Let''s import it in the REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As the JDK classes are in the class path, they can be directly accessed into
    the REPL as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have instantiated a Java list of integers, we want to convert it
    to its Scala equivalent and need to import the `JavaConverters` classes for that
    using the following lines of command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the documentation of `JavaConverters` in Scaladoc (which is similar
    to Javadoc, used to document Scala APIs, and available online at [www.scala-lang.org/api/current/index.html](http://www.scala-lang.org/api/current/index.html)),
    we can see, for example, that the equivalent of `java.util.List` is `scala.collection.mutable.Buffer`.
    So, if we invoke the `asScala` method on `java.util.List`, we will get exactly
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, by invoking the `asJava` method on `scalaList`, we will get back our original
    `java.util.List` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A good test to verify that we get back the original object after converting
    it to a target type and back again is to use an `assert` statement, as shown in
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having no output from `assert` means that it evaluated to `True`; otherwise,
    we would get a stack trace that shows why they are not equal. You might wonder
    where this `assert` method comes from; `assert` is a method of the `Predef` class,
    a Scala class imported by default containing useful aliases for commonly used
    types, assertions like the one we have used, and simple functions for console's
    I/O and implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: JavaBean-style properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To ensure compatibility with Java frameworks such as Hibernate or JMX, you
    may sometimes need Java-style getters and setters on the fields of your class.
    For example, if we declare a `Company` class in the REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen in [Chapter 1](ch01.html "Chapter 1. Programming Interactively
    within Your Project"), *Programming Interactively within Your Project*, that Scala
    accessor methods to read and mutate the `name` field are `name` and `name_=`,
    respectively, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A straightforward way to have Java-style getters and setters is to annotate
    the field with `scala.beans.BeanProperty` as shown in the following lines of command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Scala and Java object orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interoperability between Scala and Java classes makes it very straightforward
    to replace or extend an existing Java class with a Scala class. Compiling a Scala
    class produces bytecode that is pretty similar to what Java produces. For example,
    let''s take a shorter version of the `Customer` Java class we generated earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refactor it into a Scala class with class parameters and create an instance,
    we get the following in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a constructor that takes only a single `zip` parameter does not exist
    in this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our refactoring of the Java class, we need an extra constructor
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we were able to create an instance with the auxiliary constructor,
    which obeys to a couple of rules. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Any auxiliary constructor must immediately call another `this(…)` constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary constructor has to be called in the end to make sure all the parameters
    are initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala traits as enhanced Java interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software interfaces are useful mechanisms to make a piece of code interact
    via a contract to other external software systems, isolating the specification
    of what it does from its implementation. Although Java classes on the JVM have
    the limitation to only extend one single class, they can have multiple types by
    implementing several interfaces. However, Java interfaces are purely abstract,
    that is, they contain only constants, method signatures, and nested types, but
    no method bodies; for example, see the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, Scala traits are more powerful by allowing partial implementation
    of method bodies and therefore, more reusable. One can use a trait to mix in behavior
    into a class. Let''s take an example in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This class declares two fields, `name` and `discountCode` (initialized to `"N"`
    for normal), as well as two methods, `discounts()` and `toString()`, where `discounts()`
    accumulates discounts for a customer into `List` of integers (initialized to a
    `5` percent discount) and `toString()` displays it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a couple of traits that extends the class we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A `VIPCustomer` class is a customer who gets an extra `10` percent discount
    concatenated to the list of all of the already available discounts he/she has.
    The second trait is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A `GoldCustomer` class is a customer who gets an additional `15` percent discount
    or even `20` percent if her rating, that is, `discountCode` is `"H"` (high).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write a `Main` class to show the addition of stackable traits when
    instantiating the `Customer` class. We use the `with` keyword to mix in these
    additional behaviors into the class as shown in the following lines of command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now simply execute the main method and get the expected result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order in which traits are stacked is important. They are calling
    each other from right to left. `GoldCustomer` is, therefore, the first one to
    be called.
  prefs: []
  type: TYPE_NORMAL
- en: Traits lie between interfaces and abstract classes. However, you can only extend
    one abstract class whereas you can extend several traits.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java code often refers to the `static` keyword to refer to singleton methods
    and constants. Scala does not support the `static` identifier, but instead provides
    the notion of `object` in place of the `class` declaration. If you need to refactor
    Java code into Scala, by simply using the `object` declaration instead of `class`,
    you get singleton instances and you''re done, having the extra advantage that
    such Scala objects can also extend interfaces and traits. A simple example of
    `object` is the declaration of the `Main` program we exhibited earlier in the
    usage of stackable traits, or the following simple `hello world` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the notion of object, Scala provides the notion of companion
    object, which consists of an object that cohabits with a class of the same name
    in the same package and file. This is why it is called **companion**.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing companion objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The companion object enables storing of static methods and from this, you have
    full access to the classes'' members, including private ones. It is, for example,
    a good place to declare static factory methods, and **case classes** overload
    the `apply` factory method so that you are not required to use the `new` keyword
    when creating case class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can still use the `new` keyword if you want to, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, the case class is constructed as a regular class that has,
    among other things, a companion object similar to the following (although simplified)
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We conclude this section about how to migrate code from Java to Scala with
    exceptions, a notion that appears everywhere in Java. In a quite similar way to
    Java, you can write the `try { } catch { }` blocks to capture method invocations
    that might fail. In Java, you would write something similar to the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, you could translate it directly to the equivalent code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in this case, the return value inferred by the compiler is not only
    empty but also of the wrong type, `AnyVal`, which is the common type found between
    an `Int` value and whatever is returned by the exception. To make sure we get
    an integer as the output, we need to return an `Int` value from all the possible
    cases found in the `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we can capture the correct return type from the parsing invocation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In all cases, we return an `Int` value, `-1` in case of failure. This solution
    is still only partly satisfying as the caller does not really know the reason
    of failure unless we display/log it. A better way is to use, for example, an `Either`
    class that represents a value of one of the two possible types, where its instances
    are either of the `scala.util.Left` or `scala.util.Right` type. In this case,
    we can use the `Left` part to handle the failure and the `Right` part to handle
    a successful result as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Writing explicitly the return type will cause a compilation error on these types
    of errors, and therefore, is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, without going into too much detail, there is an even more appropriate
    way of handling the `try` and `catch` blocks that are derived from `Either` using
    the `scala.util.Try` class. Instead of handling the exception as `Left` and `Right`,
    it returns `Failure[Throwable]` or `Success[T]`, `T` being a generic type. The
    advantage of this approach is that it can be used in for comprehensions (but we
    have not covered them yet, examples will come in [Chapter 5](ch05.html "Chapter 5. Getting
    Started with the Play Framework"), *Getting Started with the Play Framework*).
    Moreover, the semantics of `Try` for error handling is better than `Either` as
    it describes `Success` or `Failure` rather than the less meaningful and more generic
    terms `Left` and `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: Differences in style between Java and Scala code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are going to refactor or rewrite Java code into Scala code, there are
    a number of style differences that are useful to be aware of. Obviously, programming
    style is largely a matter of taste; however, a few guidelines generally acknowledged
    by the Scala community can help someone new to Scala to write easier-to-read and
    more maintainable code. This section is dedicated to showing some of the most
    common differences.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an algorithm in Java follows an imperative style, that is, a sequence
    of statements that change a program state. Scala, focusing primarily on functional
    programming, adopts a more declarative approach, where everything is an expression
    rather than a statement. Let's illustrate this in an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, you would commonly find the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala equivalent consists of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike the Java statements, `if` is now embedded as part of the resulting
    evaluated expression.
  prefs: []
  type: TYPE_NORMAL
- en: In general, working where everything is evaluated as an expression (and here
    an immutable expression) will make it much easier for reuse as well as composition.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to chain the result of one expression to the next will give you a
    concise way of expressing fairly complicated transformations that would require
    much more code in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the code layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the intent of functional programming is to minimize state behavior, it often
    consists of short lambda expressions so that you can visualize a fairly complicated
    transformation in an elegant and concise way, in many cases even as one-liners.
    For this reason, general formatting in Scala recommends that you use only two-space
    indentations instead of the four-space indentation that is generally admitted
    in Java code, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you have many constructor/method parameters, having them aligned as previously
    illustrated makes it easier to change them without the need to reformat the whole
    indentation. It is also the case if you want to refactor the class with a longer
    name, for example, `VeryImportantCustomer` instead of `Customer`; it will make
    smaller and more precise differences against your version control management system
    (Git, subversion, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conventions for naming packages, classes, fields, and methods in the camel case
    generally follow the Java conventions. Note that you should avoid the underscore
    (`_`) in variable names (such as `first_name` or `_first_name`) as the underscore
    has a special meaning in Scala (`self` or `this` in anonymous functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, constants, most likely declared as `private static final myConstant`
    in Java, are normally declared in Scala in the upper camel case, such as in the
    following enclosing object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Choosing a meaningful name for variables and methods should always be a priority
    in Java, and it is often recommended to use rather long variable names to precisely
    describe what a variable or method represents. In Scala, things are a little bit
    different; meaningful names are, of course, a good way to make code more readable.
    However, as we are at the same time aiming at making behavior transformations
    concise through the use of functions and lambda expressions, short variable names
    can be an advantage if you can capture a whole piece of functionality in a short
    block of code. For example, incrementing a list of integers in Scala can simply
    be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Although using `x` as a variable name is often discouraged in Java, here it
    does not matter that much as the variable is not reused and we can capture the
    transformation it does at once. There are many short or long alternatives to the
    previous lambda syntax that will produce the same result. So, which one to choose?
    Some of the alternatives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, a long variable name breaks a clear and concise one-liner into
    two lines of code, thereby, making it difficult to understand. Meaningful names
    make more sense here if we start expressing logic on several lines as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A shorter but still expressive name is sometimes a good compromise to indicate
    to the reader that this is an amount we are currently manipulating in our lambda
    expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the shortest syntax of all that is well accepted by fluent Scala programmers
    for such a simple increment function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Underscores are also encountered in Scala for expressing more complicated operations
    in an elegant but more awkward way, as is the following *sum* operation using
    the `foldLeft` method that accumulates the state from one element to the other
    (and is covered in the previous chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of explicitly having `0` as the initial value for the sum, we can write
    this summation a bit more elegantly by using the `reduce` method that is similar
    to `foldLeft`. However, we take the first element of the collection as the initial
    value (here, `3` will be the initial value), as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As far as style is concerned, fluent Scala programmers will not have any problem
    reading this code. However, if the state accumulation operation is more complicated
    than just a simple `+` operation, it might be wise to write it more explicitly
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered how to start integrating Scala code into a
    Java codebase as well as how to refactor some of the most common Java constructs
    into Scala by following some style guidelines. A much more exhaustive list of
    style recommendations is available at [http://docs.scala-lang.org/style/](http://docs.scala-lang.org/style/)
    if you are interested in learning more.
  prefs: []
  type: TYPE_NORMAL
- en: So far we have been mostly addressing the Scala language and syntax. In the
    next chapter, we are going to introduce the tools that complement it and that
    are necessary to make our Scala programming both productive and enjoyable.
  prefs: []
  type: TYPE_NORMAL
