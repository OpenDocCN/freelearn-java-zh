- en: Chapter 2. Code Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to make Java and Scala cooperate on the same code base is a prerequisite
    to guarantee a smooth transition between the two languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to quickly create a small Java web application
    in which we will show you how to add Scala code to it. Then, we will cover some
    of the most common integration points between Java and Scala and how programming
    styles differ so that programmers who want to refactor and extend their Java application
    can do it according to some guidelines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: To avoid spending too much time on creating, understanding, and documenting
    a sample Java project, we are going to use a small database that is already available
    as part of the Oracle's NetBeans IDE distribution and create a JPA persistence
    layer as well as a REST API from it using the code generation features of the
    IDE.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Download the sample Java project**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: If you are impatient to directly jump into the Scala code integration features
    of this chapter, you may skip the following section and download the ready-to-use
    maven Java project instead from Packt's website at [www.packtpub.com](http://www.packtpub.com).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Creating a REST API from an existing database
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample database bundled with the NetBeans IDE can be downloaded from the
    [www.netbeans.org](http://www.netbeans.org) website. Just click on the **Download**
    button on this website and pick the JavaEE version of the IDE.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have run the installation wizard, seen the **The installation was
    successful!** message, and started the IDE (Version 8.0 in our case), we are ready
    to create a fully functional web app in five minutes. The first time you use it,
    just click on the upper-left corner of the NetBeans IDE to close the startup screen
    and you should see the three tabs: **Projects**, **Files**, and **Services** on
    the left-hand side of the IDE.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The sample database
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our reference database can be seen from the IDE by clicking on the **Services**
    panel. Under the **Databases** menu that is part of the **Services** tab, double-click
    on the `jdbc:derby://localhost:1527/sample [app on APP] Database Connection` link
    to connect to the sample database on port 1527 (the default port for Derby databases)
    with the `app` user on the `APP` schema. Under the `APP` schema, you should find
    seven tables including `CUSTOMER` and `PRODUCT`. By right-clicking on the `CUSTOMER`
    table and choosing **View Data…**, you should be able to browse the content of
    the table.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the whole database schema so that you can visualize
    the dependencies or foreign keys between the different tables:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![The sample database](img/3637_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Setting up a Maven project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly set up our sample Java project, you may either import it directly
    in your favorite IDE from the downloaded code (and skip creating JPA entities
    and the REST web service) or perform the following simple steps on the NetBeans
    IDE:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Right-click anywhere within the **Projects** tab in the IDE, select **New Project…**,
    and then choose the **Maven** category and the **Web Application** project type.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Sample` as **Project Name** and `com.demo` as **Group Id**, and then
    click on the **Next >** button.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure a **Server** container is selected for deployment (we use the default
    GlassFish 4.0 as part of the NetBeans distribution) as well as **Java EE 7 Web**
    as the Java EE version.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button and you should see the structure of the created
    project under the **Projects** tab.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating JPA entities and REST web services
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right-click on the **Sample** project root we just created and navigate to
    **New** | **RESTful Web Services from Databases…**. Selecting the `derby sample`
    database connection from the drop-down list in the newly opened window should
    bring up the database tables into the **Available Tables** section. Mark only
    the `CUSTOMER` table and select **Add>**, both `CUSTOMER` and `DISCOUNT_CODE`
    (which are dependent on `CUSTOMER`) should be listed as **Selected Tables**, as
    shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating JPA entities and REST web services](img/3637_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Clicking on the **Next** button and again on **Next** on the next page, and
    finally clicking on **Finish** will generate both the persistence JPA entities
    for `Customer` and `DiscountCode` and the service facade classes, `CustomerFacadeREST`
    and `DiscountCodeFacadeREST`. Note that since Java EE6, the `EntityManager` class
    is instantiated in each service class, which avoids the need for JPA controller
    classes that were generated in the previous versions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more detailed version of how to generate a RESTful web service from a database
    is available under the NetBeans tutorial at [www.netbeans.org](http://www.netbeans.org).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing the project
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start introducing Scala code into our Java project, we may launch
    our application and test REST invocations in a browser. Right-click on the **Sample**
    root node of the project and select **Run** to deploy the application. Once the
    console displays that the GlassFish server is running, and that the message **Hello
    World!** appears in your browser to show that everything is deployed correctly,
    right-click on the `RESTful Web Services` folder under the project root, and select
    **Test RESTful Web Services**. The opening dialog lets you choose between generating
    a test client as part of the same project or externally, as shown in the following
    screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and testing the project](img/3637OS_02_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Select **Locally Generated Test Client (suitable for Internet Explorer)** and
    click on **OK**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Once deployment completes, the browser will display a test page where we can
    invoke REST methods on our `customer` and `discountcode` entities. If we expand
    the `com.demo.sample.customer` folder, additional parameters will be shown. Clicking
    on the `{id}` parameter, we will get an input field on the right pane where we
    can enter a particular customer `id` value. For instance, we can enter `409`.
    In the drop-down list that shows **MIME** types, select **application/json** and
    `GET` as the method to test, and then click on **Test**, as shown in the following
    screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and testing the project](img/3637_02_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'The bottom part of the page will now display the response to the REST query.
    It consists of a **Status: 200 (OK)** message and a **Response** content where
    the **Raw View** tab will display the body of the response as JSON, as shown in
    the previous screenshot.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Adding a unit test in Java
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we can generate a very simple unit test for the `Customer` class by
    selecting the `Customer.java` source file from the **Projects** pane, and then
    right-clicking on it and navigating to **Tools** | **Create Tests**. Simply click
    on the **OK** button in the dialog and eventually allow the installation of the
    **JUnit 4.xx** if required. The resulting generated file appears within **Test
    Packages** under the same Java package structure as the original class under test,
    in our case `com.demo.sample.CustomerTest.java`, which is a common convention
    when dealing with unit testing in Java. Right-clicking on the `CustomerTest` class
    and choosing **Test File** will make all the test methods run with **JUnit** and
    fail as a `fail` clause is present by default at the end of each tested method.
    For now, just comment out the `fail` statement of `testGetCustomerId` and remove
    all the other test methods. Then, rerun the test to see it in green in the IDE.
    Alternatively, if you have set up the Maven project with another IDE or a plain
    text editor, from the root of the project in the filesystem (where the `pom.xml`
    file is located), you may enter the following Maven command, which you probably
    are familiar with, in a terminal window:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Adding a test in Scala
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For now, we have only Java code in the small sample Maven project. We are ready
    to introduce a few lines of Scala to the same codebase in order to show how both
    languages seamlessly interoperate. Let''s create a `src/test/scala` directory,
    next to the existing `java/` directory, where we will put our following new `CustomerScalaTest.scala`
    class, which is a similar test to the one we already have under `src/test/java`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we run the tests again, that is, type `>mvn clean test` again, the class
    will just be ignored as it is not a `.java` source file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Scala within a Java Maven project
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be able to start writing a Scala unit test and compile Scala code
    into our Java project, we need to add a few dependencies and the scala-maven-plugin
    to the `pom.xml` file. The dependencies are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency for the core scala-library:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Dependency for scalatest (a framework for testing in Scala that supports JUnit
    and other styles; we will cover it in detail in [Chapter 4](ch04.html "Chapter 4. Testing
    Tools"), *Testing Tools)*:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Dependency for JUnit to use Java `Assert` statements in our test case:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Concerning the `scala-maven-plugin`, just add something similar to the following
    XML block to the `<plugins>` section of your `pom.xml` build file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we try to rerun the tests, this time our newly created Scala test will be
    picked up and executed, as shown in the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A couple of observations are worth mentioning about the `CustomerScalaTest.scala`
    class. They are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The package declaration at the top of the file is similar to package declarations
    in Java. However, having a package declaration in Scala mirroring the path of
    directories in the filesystem is not a requirement unlike Java, but is still recommended.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import statements in Scala are similar to Java except that the `*` wildcard
    is replaced by the underscore, `_`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You probably noticed that we suddenly have the enormous power to use any Java
    library in our Scala code, which means that we will never be stuck and can always
    invoke methods in the existing Java classes if we need a piece of functionality
    that is not directly available in Scala.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With very few additions to the `pom.xml` build file, we now have made a regular
    Java project Scala aware, which means that we can freely add Scala classes and
    invoke any Java library within them. This also means that as Java developers,
    we are now able to migrate or refactor only small parts of a project if it makes
    sense and progressively improve our codebase as we get more acquainted with the
    Scala constructs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: This approach of dealing with an existing Maven project is only one way of proceeding.
    In the next chapter, we will see some other approaches with a more radical change
    that involves the Scala's **Simple Build** **Tool** (**SBT**), an alternative
    to Maven builds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Scala and Java collaboration
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going back to the REPL, we are going to experiment further with mixing Scala
    and Java to explore some common integration needs, and in particular, testing
    and manipulating the Java REST API that we have built at the beginning of the
    chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder on how to restart the REPL from the *hello-scala* project introduced
    in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within Your Project"),
    *Programming Interactively within Your Project*, if you closed it in the meantime,
    just start a new terminal window, navigate to the root of the *hello-scala* project,
    and enter the following command in the command prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Converting between collection types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by comparing Java and Scala collection classes and see how we
    can go from one to the other. For instance, a Scala `List` (from the `scala.collection.immutable`
    package) is different from `java.util.List`, and sometimes, it can be useful to
    convert from one to the other. A convenient way in Java to create `java.util.List`
    is to use the `java.util.Arrays` utility method, `asList`, whose exact signature
    is `public static<T> List<T> asList(T... a)`, where `T` refers to a generic type.
    Let''s import it in the REPL as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the JDK classes are in the class path, they can be directly accessed into
    the REPL as shown in the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have instantiated a Java list of integers, we want to convert it
    to its Scala equivalent and need to import the `JavaConverters` classes for that
    using the following lines of command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Looking at the documentation of `JavaConverters` in Scaladoc (which is similar
    to Javadoc, used to document Scala APIs, and available online at [www.scala-lang.org/api/current/index.html](http://www.scala-lang.org/api/current/index.html)),
    we can see, for example, that the equivalent of `java.util.List` is `scala.collection.mutable.Buffer`.
    So, if we invoke the `asScala` method on `java.util.List`, we will get exactly
    that:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, by invoking the `asJava` method on `scalaList`, we will get back our original
    `java.util.List` collection:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A good test to verify that we get back the original object after converting
    it to a target type and back again is to use an `assert` statement, as shown in
    the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having no output from `assert` means that it evaluated to `True`; otherwise,
    we would get a stack trace that shows why they are not equal. You might wonder
    where this `assert` method comes from; `assert` is a method of the `Predef` class,
    a Scala class imported by default containing useful aliases for commonly used
    types, assertions like the one we have used, and simple functions for console's
    I/O and implicit conversions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: JavaBean-style properties
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To ensure compatibility with Java frameworks such as Hibernate or JMX, you
    may sometimes need Java-style getters and setters on the fields of your class.
    For example, if we declare a `Company` class in the REPL as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have seen in [Chapter 1](ch01.html "Chapter 1. Programming Interactively
    within Your Project"), *Programming Interactively within Your Project*, that Scala
    accessor methods to read and mutate the `name` field are `name` and `name_=`,
    respectively, as shown in the following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A straightforward way to have Java-style getters and setters is to annotate
    the field with `scala.beans.BeanProperty` as shown in the following lines of command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scala and Java object orientation
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interoperability between Scala and Java classes makes it very straightforward
    to replace or extend an existing Java class with a Scala class. Compiling a Scala
    class produces bytecode that is pretty similar to what Java produces. For example,
    let''s take a shorter version of the `Customer` Java class we generated earlier:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we refactor it into a Scala class with class parameters and create an instance,
    we get the following in the REPL:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, a constructor that takes only a single `zip` parameter does not exist
    in this definition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To complete our refactoring of the Java class, we need an extra constructor
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This time, we were able to create an instance with the auxiliary constructor,
    which obeys to a couple of rules. They are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Any auxiliary constructor must immediately call another `this(…)` constructor
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary constructor has to be called in the end to make sure all the parameters
    are initialized
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala traits as enhanced Java interfaces
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software interfaces are useful mechanisms to make a piece of code interact
    via a contract to other external software systems, isolating the specification
    of what it does from its implementation. Although Java classes on the JVM have
    the limitation to only extend one single class, they can have multiple types by
    implementing several interfaces. However, Java interfaces are purely abstract,
    that is, they contain only constants, method signatures, and nested types, but
    no method bodies; for example, see the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In contrast, Scala traits are more powerful by allowing partial implementation
    of method bodies and therefore, more reusable. One can use a trait to mix in behavior
    into a class. Let''s take an example in the REPL:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This class declares two fields, `name` and `discountCode` (initialized to `"N"`
    for normal), as well as two methods, `discounts()` and `toString()`, where `discounts()`
    accumulates discounts for a customer into `List` of integers (initialized to a
    `5` percent discount) and `toString()` displays it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a couple of traits that extends the class we just created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A `VIPCustomer` class is a customer who gets an extra `10` percent discount
    concatenated to the list of all of the already available discounts he/she has.
    The second trait is given as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A `GoldCustomer` class is a customer who gets an additional `15` percent discount
    or even `20` percent if her rating, that is, `discountCode` is `"H"` (high).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write a `Main` class to show the addition of stackable traits when
    instantiating the `Customer` class. We use the `with` keyword to mix in these
    additional behaviors into the class as shown in the following lines of command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now simply execute the main method and get the expected result as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the order in which traits are stacked is important. They are calling
    each other from right to left. `GoldCustomer` is, therefore, the first one to
    be called.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Traits lie between interfaces and abstract classes. However, you can only extend
    one abstract class whereas you can extend several traits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 特性位于接口和抽象类之间。然而，你只能扩展一个抽象类，而可以扩展多个特性。
- en: Declaring objects
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明对象
- en: 'Java code often refers to the `static` keyword to refer to singleton methods
    and constants. Scala does not support the `static` identifier, but instead provides
    the notion of `object` in place of the `class` declaration. If you need to refactor
    Java code into Scala, by simply using the `object` declaration instead of `class`,
    you get singleton instances and you''re done, having the extra advantage that
    such Scala objects can also extend interfaces and traits. A simple example of
    `object` is the declaration of the `Main` program we exhibited earlier in the
    usage of stackable traits, or the following simple `hello world` application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码经常使用`static`关键字来引用单例方法和常量。Scala不支持`static`标识符，而是用`object`概念代替`class`声明。如果你需要将Java代码重构为Scala，只需使用`object`声明而不是`class`，你就可以得到单例实例，任务完成，额外的优势是这种Scala对象也可以扩展接口和特性。`object`的一个简单例子是我们之前在可堆叠特性使用中展示的`Main`程序声明，或者以下简单的`hello
    world`应用程序：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition to the notion of object, Scala provides the notion of companion
    object, which consists of an object that cohabits with a class of the same name
    in the same package and file. This is why it is called **companion**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象的概念之外，Scala还提供了伴生对象的概念，它由一个与同一包和文件中的同名类共存的伴生对象组成。这就是为什么它被称为**伴生**。
- en: Introducing companion objects
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍伴生对象
- en: 'The companion object enables storing of static methods and from this, you have
    full access to the classes'' members, including private ones. It is, for example,
    a good place to declare static factory methods, and **case classes** overload
    the `apply` factory method so that you are not required to use the `new` keyword
    when creating case class instances:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 伴生对象允许存储静态方法，并且从这一点出发，你可以完全访问类的成员，包括私有成员。例如，这是一个声明静态工厂方法的好地方，并且**案例类**重载了`apply`工厂方法，这样在创建案例类实例时就不需要使用`new`关键字：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, you can still use the `new` keyword if you want to, shown as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想使用，也可以使用`new`关键字，如下所示：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Under the hood, the case class is constructed as a regular class that has,
    among other things, a companion object similar to the following (although simplified)
    code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，案例类被构建为一个常规类，其中包含其他东西，比如以下（虽然简化了）的伴生对象代码片段：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Handling exceptions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'We conclude this section about how to migrate code from Java to Scala with
    exceptions, a notion that appears everywhere in Java. In a quite similar way to
    Java, you can write the `try { } catch { }` blocks to capture method invocations
    that might fail. In Java, you would write something similar to the following code
    snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结本节关于如何使用异常将代码从Java迁移到Scala的内容，这个概念在Java中无处不在。与Java非常相似，你可以编写`try { } catch
    { }`块来捕获可能失败的方法调用。在Java中，你会编写类似于以下代码片段的内容：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code produces the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In Scala, you could translate it directly to the equivalent code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，你可以直接将其翻译成等效的代码：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, in this case, the return value inferred by the compiler is not only
    empty but also of the wrong type, `AnyVal`, which is the common type found between
    an `Int` value and whatever is returned by the exception. To make sure we get
    an integer as the output, we need to return an `Int` value from all the possible
    cases found in the `catch` block:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，编译器推断出的返回值不仅为空，而且类型错误，是`AnyVal`类型，这是`Int`值和异常返回值之间的通用类型。为了确保我们得到整数作为输出，我们需要从`catch`块中找到的所有可能情况中返回一个`Int`值：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This time we can capture the correct return type from the parsing invocation
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们可以从解析调用中捕获正确的返回类型，如下所示：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In all cases, we return an `Int` value, `-1` in case of failure. This solution
    is still only partly satisfying as the caller does not really know the reason
    of failure unless we display/log it. A better way is to use, for example, an `Either`
    class that represents a value of one of the two possible types, where its instances
    are either of the `scala.util.Left` or `scala.util.Right` type. In this case,
    we can use the `Left` part to handle the failure and the `Right` part to handle
    a successful result as shown in the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Writing explicitly the return type will cause a compilation error on these types
    of errors, and therefore, is highly recommended.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Finally, without going into too much detail, there is an even more appropriate
    way of handling the `try` and `catch` blocks that are derived from `Either` using
    the `scala.util.Try` class. Instead of handling the exception as `Left` and `Right`,
    it returns `Failure[Throwable]` or `Success[T]`, `T` being a generic type. The
    advantage of this approach is that it can be used in for comprehensions (but we
    have not covered them yet, examples will come in [Chapter 5](ch05.html "Chapter 5. Getting
    Started with the Play Framework"), *Getting Started with the Play Framework*).
    Moreover, the semantics of `Try` for error handling is better than `Either` as
    it describes `Success` or `Failure` rather than the less meaningful and more generic
    terms `Left` and `Right`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Differences in style between Java and Scala code
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are going to refactor or rewrite Java code into Scala code, there are
    a number of style differences that are useful to be aware of. Obviously, programming
    style is largely a matter of taste; however, a few guidelines generally acknowledged
    by the Scala community can help someone new to Scala to write easier-to-read and
    more maintainable code. This section is dedicated to showing some of the most
    common differences.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Writing an algorithm in Java follows an imperative style, that is, a sequence
    of statements that change a program state. Scala, focusing primarily on functional
    programming, adopts a more declarative approach, where everything is an expression
    rather than a statement. Let's illustrate this in an example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, you would commonly find the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The Scala equivalent consists of the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that unlike the Java statements, `if` is now embedded as part of the resulting
    evaluated expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In general, working where everything is evaluated as an expression (and here
    an immutable expression) will make it much easier for reuse as well as composition.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Being able to chain the result of one expression to the next will give you a
    concise way of expressing fairly complicated transformations that would require
    much more code in Java.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the code layout
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the intent of functional programming is to minimize state behavior, it often
    consists of short lambda expressions so that you can visualize a fairly complicated
    transformation in an elegant and concise way, in many cases even as one-liners.
    For this reason, general formatting in Scala recommends that you use only two-space
    indentations instead of the four-space indentation that is generally admitted
    in Java code, as shown in the following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you have many constructor/method parameters, having them aligned as previously
    illustrated makes it easier to change them without the need to reformat the whole
    indentation. It is also the case if you want to refactor the class with a longer
    name, for example, `VeryImportantCustomer` instead of `Customer`; it will make
    smaller and more precise differences against your version control management system
    (Git, subversion, and so on).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conventions for naming packages, classes, fields, and methods in the camel case
    generally follow the Java conventions. Note that you should avoid the underscore
    (`_`) in variable names (such as `first_name` or `_first_name`) as the underscore
    has a special meaning in Scala (`self` or `this` in anonymous functions).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'However, constants, most likely declared as `private static final myConstant`
    in Java, are normally declared in Scala in the upper camel case, such as in the
    following enclosing object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Choosing a meaningful name for variables and methods should always be a priority
    in Java, and it is often recommended to use rather long variable names to precisely
    describe what a variable or method represents. In Scala, things are a little bit
    different; meaningful names are, of course, a good way to make code more readable.
    However, as we are at the same time aiming at making behavior transformations
    concise through the use of functions and lambda expressions, short variable names
    can be an advantage if you can capture a whole piece of functionality in a short
    block of code. For example, incrementing a list of integers in Scala can simply
    be expressed as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Although using `x` as a variable name is often discouraged in Java, here it
    does not matter that much as the variable is not reused and we can capture the
    transformation it does at once. There are many short or long alternatives to the
    previous lambda syntax that will produce the same result. So, which one to choose?
    Some of the alternatives are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this case, a long variable name breaks a clear and concise one-liner into
    two lines of code, thereby, making it difficult to understand. Meaningful names
    make more sense here if we start expressing logic on several lines as shown in
    the following code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A shorter but still expressive name is sometimes a good compromise to indicate
    to the reader that this is an amount we are currently manipulating in our lambda
    expression, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, the shortest syntax of all that is well accepted by fluent Scala programmers
    for such a simple increment function is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Underscores are also encountered in Scala for expressing more complicated operations
    in an elegant but more awkward way, as is the following *sum* operation using
    the `foldLeft` method that accumulates the state from one element to the other
    (and is covered in the previous chapter):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead of explicitly having `0` as the initial value for the sum, we can write
    this summation a bit more elegantly by using the `reduce` method that is similar
    to `foldLeft`. However, we take the first element of the collection as the initial
    value (here, `3` will be the initial value), as shown in the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As far as style is concerned, fluent Scala programmers will not have any problem
    reading this code. However, if the state accumulation operation is more complicated
    than just a simple `+` operation, it might be wise to write it more explicitly
    as shown in the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered how to start integrating Scala code into a
    Java codebase as well as how to refactor some of the most common Java constructs
    into Scala by following some style guidelines. A much more exhaustive list of
    style recommendations is available at [http://docs.scala-lang.org/style/](http://docs.scala-lang.org/style/)
    if you are interested in learning more.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: So far we have been mostly addressing the Scala language and syntax. In the
    next chapter, we are going to introduce the tools that complement it and that
    are necessary to make our Scala programming both productive and enjoyable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
