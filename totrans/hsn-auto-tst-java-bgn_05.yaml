- en: Everything You Need to Know About Interfaces and Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go through some important concepts, such as interfaces,
    how they work, and their usage in Java. We will discuss inheritance using a practical
    example. This chapter will also look at the concepts of function overloading and
    function overriding and the differences between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overriding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interface is one of the core concepts used in Java OOPS, so it's necessary
    for us to familiarize ourselves with interfaces and their use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces are similar to classes. The only difference between an interface
    and a class is that an interface will have methods but not a body. Confused? In
    a class, we generally define a method and then start writing code into it. For
    example, in a class, if we want to write any code, we just start off by declaring
    the class using `public void` and proceed with the rest of the code in that class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In interfaces, we can only define the signature of the method; we cannot write
    any code inside the method. But why? What is the use of writing a method signature
    inside an interface? What is the use of this object-oriented concept in Java?
    You might have these questions in your mind, so let's try to understand the concept
    of the interface with a real-life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Using interfaces with a traffic light system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the typical traffic light system, which is used everywhere around the
    world to maintain traffic regulations. Every country has its own traffic rules,
    such as driving on the left or right side of the road. Even though traffic rules
    differ from country to country, there are certain rules that apply globally and
    need to be followed by every country. One such rule is the use of traffic lights
    to govern the traffic flow, where a red light is an indication to stop, an amber/yellow
    light to ready your engine, and a green light to move your vehicle. Let's say
    that these global rules are imposed by a central traffic authority, and we want
    to implement, for example, the Australian traffic system. This system will have
    its own rules, but we need to make sure that it follows the global rules imposed
    by the central traffic authority.
  prefs: []
  type: TYPE_NORMAL
- en: Using this example, we'll try to understand the concept of interfaces. Here,
    the central traffic authority acts as an interface and the Australian traffic
    rules act as a class that implements the interface; that is, the Australian traffic
    system will have to follow the rules/methods mentioned in the central traffic
    authority interface. The methods defined in any interface are just signatures,
    so the classes will define and implement the methods present in an interface.
    Let's look at this example in our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define an interface in the same way that we define a class. In this traffic
    light example, let''s name the class as `CentralTraffic`. We now have a ready
    interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the syntax that instead of `class` we have written `interface`.
    We define a method in the interface using the same method that we use to define
    a method in a class, but remember that we cannot have a method body defining the
    method as this is an interface, and doing so will throw an error. Create another
    class to implement this interface and name it `AustralianTraffic`. Once we have
    a Java class, we need to implement the `CentralTraffic` interface to it, and we
    do that using the `implements` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After using the preceding sentence, our IDE will show an error, and when you
    hover over the error, you''ll see some suggestions related to the error. One suggestion
    would be to import `CentralTraffic`, and another would be to add unimplemented
    methods. Click on these suggestions to resolve the error and you should end up
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All the methods defined in the `CentralTraffic` interface can be seen in the
    `AustralianTraffic` class, and here we can also implement these methods as we
    wish. Now, if we remove the `greenGo` method from our Java class, it'll give us
    an error. As it is a method defined in an interface, it is mandatory for us to
    implement all the methods defined in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface methods are defined outside `public static void main`, and to
    execute these methods, we should create a class object for them in the `main`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code says that we have created an object for the `AustralianTraffic`
    class to implement the methods present in the `CentralTraffic` interface. The
    main class should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after implementing the methods from the interface, we can define our own
    country-specific methods (rules) in our Java class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `main` method, if we try calling our country-specific method using `a.`,
    like we did for the other methods in the `main` class, then we will find that
    we won''t be able to do so because the `walkonsymbol` method is specific to a
    particular country (that is, the `AustralianTraffic` class) and it''s not implemented
    in `CentralTraffic`. For the `walkonsymbol` method, we need to create another
    object in the `main` class specific to the `AustralianTraffic` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another piece of information related to the interface is that a class can implement
    more than one interface. Let''s say that we create another interface, such as
    `ContinentalTraffic`, and define another rule related to traffic lights, such
    as a train symbol to indicate that a train is passing by. We can implement this
    interface in our `AustralianTraffic` class simply by adding a comma, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For this interface, we need to follow the same steps as we did for the `CentralTraffic`
    interface, such as importing `ContinentalTraffic` to `AustralianTraffic`, adding
    unimplemented methods, creating an object specific to `ContinentalTraffic` in
    the main class, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a fair idea of the differences between an interface and a class.
    We learned how to define the interfaces, how to implement them within another
    class, and how to call them using objects.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is another important OOP concept in Java. Let's take an example
    of a vehicle to understand the concept of inheritance, just like we did in using
    the example of a traffic light system to understand interfaces. The basic properties
    of a vehicle are its color, gears, mirrors, brakes, and so on. Let's say that
    we are making a new vehicle with certain advancements to some of these properties,
    such as an engine with a higher CC, and maybe a different design than the old
    one. Now, to create a new vehicle with these new features, we still need the basic
    features of the old vehicle, such as mirrors and brakes, which are present in
    vehicles by default.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the preceding example and use Java to reflect these relationships
    in order to understand the concept of inheritance. In our example, if we have
    a class for a vehicle and enter the basic features of the vehicle as methods that
    are present in that class, then when we create a class for a new vehicle, it can
    inherit the features of the class that is created for the vehicle, and we don't
    have to write the code for these features as they are available to us via inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with the code. Create a `parentClassdemo` class, which will
    be our parent class. In this class, we will define our methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now inherit these methods in our child class. Create a `childClassDemo` in
    Java. We inherit the parent class using the `extends` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we inherited the `parentClassdemo` class in the `childClassDemo` class
    using the `extends` keyword. In this `childClassDemo` class, we defined our own
    `engine` method and used the `color` method, which we inherited from the `parentClassdemo`
    class. We then created a `cd` object and used it to call the methods from the
    inherited class.
  prefs: []
  type: TYPE_NORMAL
- en: More on inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss some notorious tricky questions and misconceptions regarding inheritance
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with some of the more well-known questions asked concerning
    inheritance. Take a look at the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is also one of the differences between inheritance and interfaces, as an
    interface allows us to use multiple interfaces at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an `A` class and it has an `i` variable. There is also a `B` class
    that extends the `A` class, and we also have its local `i` variable set as `20`.
    Now, in `MainClass`, we create an object for the `B` class. What does this step
    actually mean? Here, we are creating an object and saying that this object of
    this `B` class should refer to the properties of the `A` class. Though we have
    permission to access this `B` class through this `a` object, we can only access
    the properties or methods of the `A` class, because the `B` class has permission
    to access the `A` class here, as we are extending it.
  prefs: []
  type: TYPE_NORMAL
- en: The question here is what will `a.i` print—`20` or `10`? The answer is, it will
    print the variable value of `10`, as `A a = new B();` explicitly tells `a` that
    it is an object of the `B` class, but we need to access the methods present in
    the `A` class. If we want this output as `20`, we change the syntax to `B a =
    new B();`.
  prefs: []
  type: TYPE_NORMAL
- en: You may get such questions if you attend Java quizzes or a complex interview.
    These are the important pieces of information that you have to know regarding
    inheritance, and you can plan accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function overloading happens when a class has multiple methods with the same
    name. If we define a `getData` method twice in our class, we can say that the
    `getData` function is overloaded, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few rules that we need to remember while using multiple instances
    of a function with the same name. The first rule is that the number of arguments
    present in the function-overloaded method should be different, and the second
    is that the argument data type should be different. If we keep both the `getData`
    methods with the `int a` argument, it will throw an error, so we need to have
    a different number of arguments for each method. Now, when you print these, you''ll
    get the outputs of `2` and `hello`. We can see that two different arguments are
    printed, but with the same method name. Let''s add one more `getData` instance
    with two arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have two instances of `getData` with the same data type, but the number
    of arguments varies.
  prefs: []
  type: TYPE_NORMAL
- en: You might come across function overloading in the real world as well, such as
    when you are asked for the payment method in an e-commerce website in patches.
    The website might use different `getPayment` methods to confirm the payment—one
    `getPayment` method takes a debit card as an argument, another `getPayment` method
    takes a credit card as an argument, and another `getPayment` might take a gift
    card as an argument. So we pass different kinds of arguments to the same `getPayment`
    method. In this case, we stick to `getPayment` as a method name and pass it different
    arguments, bringing the concept of function overloading to this particular scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Function overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's discuss one more important feature in Java—is function
    overriding. Let's continue with the same example that we looked at when learning
    about inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that example, we had a parent class called `parentClassdemo` and a child
    class called `childClassDemo`, and the child class inherited the parent class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the `engine` method defined in the child class, which prints
    a new engine, and we have another method, `color`, which is defined in the parent
    class, and we call it using an object. If we print this, we will get the output
    of the `color` method, as it is defined in the parent class. Now, we create a
    new method in the child class and name it `color` as well, defining it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have two instances of the `color` method—one defined in the parent class
    and a new one defined in the child class. Here is where the concept of function
    overriding comes into action. If you run the child class, you will get the output
    of `update color`. This is because the new `color` method defined in the child
    class overrides the `color` method from the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: This sums up the whole concept of function overriding, where both the methods
    have the same name, signature, and parameters. In function overloading, we have
    methods that have the same name, but different arguments. This, one of the major
    differences between function overloading and function overriding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to some important Java OOP concepts, such
    as interfaces, inheritance, function overloading, and function overriding. We
    looked at each concept using an example, which helped us better understand the
    concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter we will take a look at one of the most important concept
    in Java code: arrays. We''ll see how different arrays look, and how to initialize
    and display them.'
  prefs: []
  type: TYPE_NORMAL
