- en: Chapter 9. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will finish up our project by securing it with Java EE solutions. But first,
    we will analyze the improvements in the concerned APIs. The development of this
    chapter will be focused on JASPIC 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: JASPIC 1.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Authentication SPI for Containers** (**JASPIC**) Specification was
    developed under JSR 196\. This section just gives you an overview of improvements
    in the API. For more information, the complete document specification can be downloaded
    from [http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Secure access to forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also called JASPI, the JASPIC Specification defines a set of standard interfaces
    for the development of modules for authentication, which allow secure access to
    web resources (Servlets, JSP, and so on), among others. Generally speaking, the
    JASPIC Specification was designed for message-level security; this means that
    JASPIC modules are called to be integrated into message processing containers
    and thus, offer a transparent secured mechanism for protocols such as SOAP and
    HttpServlet.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an authentication module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the case where you don''t want to use a predefined authentication module,
    the JASPIC Specification allows you to develop your own modules. This requires
    the implementation of the `javax.security.auth.message.module.ServerAuthModule`
    interface. For reasons that we will explain later, you may need to implement the
    following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.security.auth.message.config.ServerAuthConfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.security.auth.message.config.ServerAuthContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.security.auth.message.config.AuthConfigProvider`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ServerAuthModule interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ServerAuthModule` interface contains five methods that must be implemented
    by the authentication module. These methods are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize()`: This method is used to initialize the module and retrieve objects
    necessary for the validation of access to resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSupportedMessageTypes()`: This method returns an array of objects designating
    message types supported by the module. For example, for a module that will be
    compatible with a Servlet Container profile, the returned array will contain the
    `HttpServletRequest.class` and `HttpServletResponse.class` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validateRequest()`: This method is called by the container whenever an `HttpServletRequest`
    is received for processing of the incoming message. For this purpose, it receives
    from the container `HttpServletRequest` and `HttpServletResponse` objects in the
    `MessageInfo` parameter. At the end of request processing, this method must return
    a status that determines the sequence of operations in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secureResponse()`: This method is called by the container at the time of returning
    a response to a client. Very often, it should return the status `SEND_SUCCESS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cleanSubject()`: This method is used to remove one or several principles of
    a subject argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code provides an example implementation of the `ServerAuthModule`
    interface methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring the authentication module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Install the authentication module by copying the JAR file of the module in the
    `install_glassfish\ glassfish\domains\domain1\lib` directory of your GlassFish
    Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the module is installed, you can configure it in the GlassFish administration
    console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to the GlassFish administration console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **server-config** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the menu that appears, expand the **Security** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the submenu, expand the **Message security** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **HttpServlet** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the form that appears, click on the **Providers** tab to add a new provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **New** button and fill out the appropriate form. Before recording
    your entry, your form should look like the following screenshot:![Installing and
    configuring the authentication module](img/9235OT_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Binding the authentication module to a web application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To bind an authentication module to an application, you have two options in
    GlassFish:'
  prefs: []
  type: TYPE_NORMAL
- en: The first option (which is by far the simplest) is to configure the `httpservlet-security-provider`
    attribute of the element `glassfish-web-app` in the `glassfish-web.xml` file of
    the application. The purpose of this configuration is to make you use the `AuthConfigProvider`
    implementation provided by GlassFish to instantiate your security module. The
    following code shows the contents of the `glassfish-web.xml` file of our application.
    As you can see, we passed the ID of our provider to the `httpservlet-security-provider`
    attribute. Thus, whenever it is necessary to analyze the security of a request,
    the GlassFish server through its `AuthConfigProvider` implementation will instantiate
    our security module in order to make it operational.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second method is to implement your own implementation of the `AuthConfigProvider`
    interface. Therefore, in this case, you need to implement `javax.security.auth.message.config.ServerAuthConfig`,
    `javax.security.auth.message.config.ServerAuthContext`, and `javax.security.auth.message.config.AuthConfigProvider`
    interfaces. For those who are thrilled about the adventure, you will find all
    the necessary information in this blog: [http://arjan-tijms.blogspot.com/2012/11/implementing-container-authentication.html](http://arjan-tijms.blogspot.com/2012/11/implementing-container-authentication.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a realm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will tell the GlassFish server where all the associated users and groups
    that can access the secure sections of our application are stored. In other words,
    we will configure the realm of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your information, GlassFish provides the ability to define several types
    of realms. They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `file` realm, for storing user information in files. This is the default
    realm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldap` realm, for storage in an LDAP directory server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jdbc` realm, for storing in a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `solaris` realm, for authentication management based on Solaris username
    and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `certificate` realm, for authentication management using certificates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And if none of these realms satisfy your need, don't worry; GlassFish offers
    the possibility of creating your own realm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we opt for the `jdbc` realm; we need a database structure to store
    the necessary information (the user name, its password, and the group to which
    it belongs). The following screenshot shows the structure of tables in which our
    information is stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a realm](img/9235OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `realm_users` table will store all user IDs and passwords, the `realm_groups`
    table will store all the group IDs of our application with their description,
    while the `users_groups` table will tell us what groups a user belongs to. Thus,
    a user can belong to several groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have defined the structure of the database that will host different
    users, you must configure GlassFish so that it can connect to your database (MySQL
    5, in our case) and access authentication information. To do this, you have to
    start by copying the Java connector of your database (`mysql-connector-java-5.1.23-bin.jar`,
    in our case) into the directory: `glassfish_install_dir\glassfish\domains\domain1\lib`.
    Then, you have to connect to the GlassFish administration console and gain access
    to the realms creation form by navigating to **Configurations** | **server-config**
    | **Security** | **Realms**. By clicking on the **Realms** menu, the following
    form will be displayed; you then need to click on the **New** button and the realms
    creation form will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a realm](img/9235OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table shows the fields that you need to fill for a `JDBCRealm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Example value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Name** | `MyJDBCRealm` | The name of the realm that will be used to configure
    security in application |'
  prefs: []
  type: TYPE_TB
- en: '| **Class Name** | `com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm`
    | The class that implements the realm to configure, in our case, `JDBCRealm` |'
  prefs: []
  type: TYPE_TB
- en: '| **JAAS Context** | `jdbcRealm` | JAAS (Java Authentication and Authorization
    Service) context ID |'
  prefs: []
  type: TYPE_TB
- en: '| **JNDI** | `jdbcRealmDataSource` | The JNDI name of the JDBC Resources to
    connect to the database containing the realm |'
  prefs: []
  type: TYPE_TB
- en: '| **User Table** | `realm_users` | The name of the table containing the list
    of system users with their passwords |'
  prefs: []
  type: TYPE_TB
- en: '| **User Name Column** | `USERID` | The name of the column containing the ID
    of the user in the table `realm_users` |'
  prefs: []
  type: TYPE_TB
- en: '| **Password Column** | `PASSWORD` | The name of the column containing the
    passwords of users |'
  prefs: []
  type: TYPE_TB
- en: '| **Group Table** | `users_groups` | The name of the table that associates
    groups and users |'
  prefs: []
  type: TYPE_TB
- en: '| **Group Table User Name Column** | `USERID` | The name of the column in the
    association table containing the ID of the user |'
  prefs: []
  type: TYPE_TB
- en: '| **Group Name Column** | `GROUPID` | The name of the column in the association
    table containing the identifier of the group |'
  prefs: []
  type: TYPE_TB
- en: '| **Password Encryption Algorithm** | `SHA-256` | To set the password encryption
    algorithm |'
  prefs: []
  type: TYPE_TB
- en: '| **Digest Algorithm** | `SHA-256` (even if it is the default value) |   |'
  prefs: []
  type: TYPE_TB
- en: 'After filling the form, you can save your realm. With this configuration, we
    can now use the password validation mechanisms provided by the container to validate
    incoming connections. This is what we have done in the validation method using
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Apart from using the container validation mechanism, you can access your database
    and make this validation yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Security configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To configure the security of an application, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determine the different roles of the application and declare them in `web.xml`.
    In our application, we only need an administrator role to perform batch processing
    and some administrative tasks. The following code demonstrates how to create a
    role named `admin` for this purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Map URL patterns to appropriate roles in the `web.xml` file. This will define
    the forms that each role can access. Before performing this configuration, you
    must group the forms depending on the access constraints you want to define. In
    the case of our application, we have grouped the forms into two folders: a folder
    for preregistration forms in the registration folder and another folder for administration
    forms in the administration folder. Thus, to ensure that only users of the admin
    role will have access to the administration forms, we will associate the URL pattern
    `/faces/administration/*` to the `admin` role. The following code demonstrates
    how to define a constraint that associates the URL pattern `/faces/administration/*`
    to the `admin` role (the word `faces` of the previous pattern represents the pattern
    defined in the `<servlet-mapping>` element of the `web.xml` file).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Associate each role with a user group in the `glassfish-web.xml` file. In the
    realm, each user is associated with a user group. However, the URL patterns are
    associated with roles. So, you need to tell the server which group a role belongs
    to. In GlassFish, this is possible through the `<security-role-mapping>` element.
    The following code shows the complete contents of the `glassfish-web.xml` file
    with the role-group combination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare the realm and authentication types to be used by our application in
    `web.xml`. The following code demonstrates how to declare the MyJDBCRealm we created
    in the preceding step. The authentication type we have chosen is `DIGEST`. It
    transmits the password in an encrypted form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you complete these configurations, candidates can access the registration
    forms without any problem. But, if they try to connect to an admin form, a window
    similar to the following window will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Security configuration](img/9235OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before finishing up this project, you should know that it is possible to customize
    the login screen and even integrate it into your application. The tutorial at
    URL: [http://blog.eisele.net/2013/01/jdbc-realm-glassfish312-primefaces342.html](http://blog.eisele.net/2013/01/jdbc-realm-glassfish312-primefaces342.html)
    can help you.'
  prefs: []
  type: TYPE_NORMAL
- en: The latest improvements in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Maintenance Release B of JASPIC Specification has made some significant
    changes, some of which help to standardize the use of the specification regardless
    of the server; others help to enrich the user experience. Among the changes, we
    present only some relatively important changes and advise you to browse the specification
    document and blog found at: [http://arjan-tijms.blogspot.com/2013_04_01_archive.html](http://arjan-tijms.blogspot.com/2013_04_01_archive.html),
    which will provide you with more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the authenticate, login, and logout methods called
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Version 3.0 of the Servlet, the authenticate, login, and logout methods
    have been added to the `HttpServletRequest` interface for managing the login and
    logout programmatically. However, the behavior of JASPIC modules after calling
    one of these three methods was not clearly established. It was left under the
    care of the server vendors to provide their own method of login and logout. The
    direct consequence is the non portability of applications between Java EE-compliant
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recent changes, Version 1.1 of JASPIC has clearly defined the expected
    behavior of JASPIC modules after calling one of these three methods. We now know
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: The container implementation of the `login` method must throw a `ServletException`
    when there is an incompatibility between the `login` method and the configured
    authentication mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, the behavior of the module after calling the `login` method is not clearly
    defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A call to the `authenticate` method must call the `validateRequest` method.
    This is true if the `authenticate` method is not called in the context of a call
    it made to `validateRequest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A call to the `logout` method must call the `cleanSubject` method. This is true
    if the `logout` method is not called in the context of a call it made to the `cleanSubject`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardizing access to the application context identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application context identifier is an ID used to identify or select `AuthConfigProvider`
    and `ServerAuthConfig` objects for a given application (it is contained in the
    `appContext` parameter). Prior to JASPIC 1.1, there was no standard way to get
    it. As usual, each server vendor proposed a method that was vendor-specific. Now
    it is possible in standard with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Support for forward and include mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JASPIC 1.1 Specification has insisted on the fact that authentication modules
    must be able to forward and include during the processing of the `validateRequest`
    method. Concretely, this is possible by using `request` and `response` within
    the `MessageInfo` parameter type. The following code gives an overview of a redirection
    to an error page based on the results of a condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having reached the end of this chapter, which is the last chapter of the book,
    we are now able to deploy a Java EE public solution with at least some level of
    security. Indeed, through this chapter, readers become aware of a specification
    allowing them to restrict access to the forms. However, it is important to note
    that we have just dealt with one small aspect of security, given the objectives
    of this book. We ask you to complete your knowledge about security with additional
    reading. This is because the domain is made up of several aspects such as the
    transmission of data across the network, method execution, construction, and execution
    of SQL queries.
  prefs: []
  type: TYPE_NORMAL
