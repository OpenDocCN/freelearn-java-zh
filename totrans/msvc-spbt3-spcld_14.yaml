- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Distributed Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use distributed tracing to better understand
    how our microservices cooperate, for example, in fulfilling a request sent to
    the external API. Being able to utilize distributed tracing is essential for being
    able to manage a system landscape of cooperating microservices. As already described
    in *Chapter 8*, *Introduction to Spring Cloud*, Micrometer Tracing will be used
    to collect trace information, and Zipkin will be used for the storage and visualization
    of said trace information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing distributed tracing with Micrometer Tracing and Zipkin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add distributed tracing to the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to programmatically add information to the traces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform distributed tracing, visualizing both successful and unsuccessful
    API requests. We will see how both synchronous and asynchronous processing can
    be visualized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter14`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to add distributed tracing using Micrometer Tracing
    and Zipkin, you can compare it with the source code for *Chapter 13*, *Improving
    Resilience Using Resilience4j*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter13` and `$BOOK_HOME/Chapter14`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing distributed tracing with Micrometer Tracing and Zipkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recapitulate *Chapter 8*, *Introduction to Spring Cloud*, in reference to
    the *Using Micrometer Tracing and Zipkin for distributed tracing* section, the
    tracing information from a complete workflow is called a **trace** or a **trace
    tree**, and sub-parts of the tree, for example, the basic units of work, are called
    **spans**. Spans can consist of sub-spans forming the trace tree. Metadata can
    be added to a trace and its spans as key-value pairs called **tags**. The Zipkin
    UI can visualize a trace tree and its spans as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Example of a trace with its spans'
  prefs: []
  type: TYPE_NORMAL
- en: Micrometer Tracing is used to collect trace information, propagate trace contexts
    (for example, trace and span IDs) in calls to other microservices and export the
    trace information into trace analysis tools like Zipkin. The handling of the trace
    information is done under the hood, by a **tracer**. Micrometer supports auto-configuration
    of tracers based on **OpenTelemetry** ([https://opentelemetry.io/](https://opentelemetry.io/))
    or **OpenZipkin Brave (**[https://github.com/openzipkin/brave](https://github.com/openzipkin/brave)**)**.
    Exporting the trace information into a trace analysis tool is done by a **reporter**.
  prefs: []
  type: TYPE_NORMAL
- en: By default, trace headers are propagated between microservices using **W3C trace
    context** headers ([https://www.w3.org/TR/trace-context/](https://www.w3.org/TR/trace-context/)),
    most importantly the `traceparent` header, but can be configured to use OpenZipkin’s
    `B3` headers. In this chapter, we will use the W3C trace context headers. In *Chapter
    18,* we will use the `B3` headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample W3C trace context `traceparent` header looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the `traceparent` header contains four parts, separated by a `-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`00`, indicates the version used. Will always be “`00`" using the current specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`124…810`, is the trace ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fbe…b20` is the span ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`01`, the last part, contains various flags. The only flag supported by the
    current specification is a flag named `sampled`, with the value `01`. It means
    that the caller is recording the trace data for this request. We will configure
    our microservices to record trace data for all requests, so this flag will always
    have the value of `01`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use of OpenZipkin Brave `B3` headers will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The header names are self-explanatory, and we can see that headers are not only
    provided for the trace and span ID but also for the parent span’s ID.
  prefs: []
  type: TYPE_NORMAL
- en: Traces and spans are created automatically by Spring Boot for incoming traffic,
    both for incoming HTTP requests and messages received by Spring Cloud Stream.
    If an incoming request contains a trace ID, it will be used when creating spans;
    if not, a new trace id will be created. Trace and span IDs are automatically propagated
    to outgoing traffic, either as HTTP requests or by sending messages using Spring
    Cloud Stream.
  prefs: []
  type: TYPE_NORMAL
- en: If required, extra trace info can be added programmatically, either by adding
    custom spans or by adding custom tags to all spans created by a microservice.
    This is done by using **Micrometer Observability** ([https://micrometer.io/docs/observation](https://micrometer.io/docs/observation))
    and its `Observation` API.
  prefs: []
  type: TYPE_NORMAL
- en: The initial release of Micrometer Tracing together with Spring Boot 3 came with
    some limitations for supporting distributed tracing in reactive clients. This
    affects the microservices used in this book that use Project Reactor under the
    hood. In the section *Adding workarounds for lacking support of reactive clients*,
    we will learn how to mitigate these shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: Zipkin comes with native support for storing trace information either in memory,
    or in a database such as Apache Cassandra, Elasticsearch, or MySQL. Added to this,
    a number of extensions are available. For details, refer to [https://zipkin.io/pages/extensions_choices.html](https://zipkin.io/pages/extensions_choices.html).
    In this chapter, we will store the trace information in memory.
  prefs: []
  type: TYPE_NORMAL
- en: With Micrometer Tracing and Zipkin introduced, let’s see what changes are required
    in the source code to enable distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Adding distributed tracing to the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to update the source code to enable distributed
    tracing. This can be done with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add dependencies to the build files to bring in Micrometer Tracing with a tracer
    implementation and a reporter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Zipkin server to the Docker Compose files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the microservices to send trace information to Zipkin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add workarounds for the lacking support of reactive clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code for creating custom spans and custom tags in existing spans.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will go through each of the steps in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to build files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to utilize Micrometer Tracing and the ability to export trace information
    to Zipkin, we need to add a dependency to the selected tracer and reporter to
    the Gradle project build files, `build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is accomplished by adding the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the review service, a dependency has also been added to enable trace information
    regarding SQL database operations. It looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This library can create spans for the SQL operations executed by the review
    service. These spans will contain information about the SQL query that was executed
    and its execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding configuration for Micrometer Tracing and Zipkin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuration for using Micrometer Tracing and Zipkin is added to the common
    configuration file, `config-repo/application.yml`. In the default profile, it
    is specified that trace information will be sent to Zipkin using the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Micrometer Tracing only sends 10% of the traces to Zipkin. To ensure
    that all traces are sent to Zipkin, the following property is added to the default
    profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We also want trace and span IDs to be written to logs; this will enable us to
    correlate log output from cooperating microservices that, for example, fulfill
    a request sent to the external API.
  prefs: []
  type: TYPE_NORMAL
- en: We will investigate how to use this in *Chapter 19**, Centralized Logging with
    the EFK Stack*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can include the trace and span IDs in the log output by specifying the following
    log format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above log format, the log output will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Where `product-composite` is the name of the microservice, `01234` is the trace
    ID, and `56789` is the span ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the log output, we also change the log level from `DEBUG` to `INFO`
    for each microservice’s configuration file in the `config-repo`. This makes it
    easier to verify that trace and span IDs are added as expected. This change is
    applied by the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `product-composite` microservice, the log level for the `HttpWebHandlerAdapter`
    class has been changed from `TRACE` to `INFO` for the same reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding Zipkin to the Docker Compose files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the Zipkin server as a Docker container, we will use a Docker image,
    `openzipkin/zipkin`, published by the Zipkin project. Refer to [https://hub.docker.com/r/openzipkin/zipkin](https://hub.docker.com/r/openzipkin/zipkin)
    for details. The definition of the Zipkin server appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain the preceding source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The version of the Docker image, `openzipkin/zipkin`, is specified to be version
    2.24.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `STORAGE_TYPE=mem` environment variable is used to specify that Zipkin will
    keep all trace information in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory limit for Zipkin is increased to 1,024 MB, compared to 512 MB for
    all other containers. The reason for this is that since Zipkin is configured to
    keep all trace information in memory, it will consume more memory than the other
    containers after a while.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Zipkin happens to run out of memory and stops, we have applied a restart
    policy that requests the Docker engine to always restart the container. This will
    apply both if the container itself crashes or if the Docker engine is restarted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipkin exposes the HTTP port `9411` for web browsers to access its web user
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it is OK to store the trace information in Zipkin in memory for development
    and test activities, Zipkin should be configured to store trace information in
    a database in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding workarounds for lacking support of reactive clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned above, the current versions of Spring Boot, Project Reactor, and
    Micrometer Tracing do not yet work together perfectly. Therefore, a couple of
    workarounds have been applied to the source code for reactive clients. That is,
    the four microservices and the gateway. The problems are mainly related to the
    complexity of propagating trace contexts (for example, trace and span IDs) between
    different threads involved in reactive asynchronous processing, specifically if
    parts of the processing involve imperative synchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: If all processing of a request is done with a synchronous implementation, using
    one and the same thread for all processing, propagating trace context is not an
    issue. A `ThreadLocal` variable can be used to store the trace context. The trace
    context can be retrieved from the `ThreadLocal` variable in any place of the implementation
    since all code runs in one and the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this mix of reactive and imperative processing is the implementation
    of the `review` microservice, where calls to the underlying SQL database are done
    synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in understanding the challenges in more detail, see the
    three-part blog series “*Unified Bridging between Reactive and Imperative*” published
    by the Spring team. It can be found here: [https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive](https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive).'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that the predecessor of Micrometer Tracing, Spring Cloud
    Sleuth, has better support for reactive clients than the current versions of Spring
    Boot, Project Reactor, and Micrometer Tracing. Hopefully, the coming versions
    will soon address these shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a code base that already uses Spring Cloud Sleuth, you can find
    migration guidelines here: [https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide](https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To address many of the challenges with context propagation, we can turn on
    automatic context propagation by calling the method `Hooks.enableAutomaticContextPropagation()`
    in a reactive client’s `main()` method. For details, see the blog series “*Unified
    Bridging between Reactive and Imperative*” referred to above. For the `product-composite`
    service, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for the `product-composite` service, one problem remains. To ensure
    that a `WebClient` instance is correctly instrumented for observation, for example,
    to be able to propagate the current trace and span IDs as headers in an outgoing
    request, the `WebClient.Builder` instance is expected to be injected using auto-wiring.
    Unfortunately, when using Eureka for service discovery, the `WebClient.Builder`
    instance is recommended to be created as a bean annotated with `@LoadBalanced`
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, there is a conflict in how to create a `WebClient` instance when used with
    both Eureka and Micrometer Tracing. To resolve this conflict, the `@LoadBalanced`
    bean can be replaced by a load-balancer-aware exchange-filter function, `ReactorLoadBalancerExchangeFilterFunction`.
    An exchange-filter function can be set on an auto-wired `WebClient.Builder` instance
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means that the application class, `ProductCompositeServiceApplication`,
    registers a `WebClient` bean instead of a `WebClient.Builder` bean. This affects
    the `ProductCompositeIntegration` class; it now needs to auto-wire a `WebClient`
    bean instead of a `WebClient.Builder` bean.
  prefs: []
  type: TYPE_NORMAL
- en: To get access to the `ReactorLoadBalancerExchangeFilterFunction` function, a
    dependency to `org.springframework.cloud:spring-cloud-starter-loadbalancer` has
    been added to the build file, `build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom spans and custom tags to existing spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides relying on the built-in support for creating traces and spans for the
    ongoing processing, we can also use the `Observation` API provided by Micrometer
    Observability to, for example, add our own spans or add custom tags to existing
    spans created by a microservice. The `Observation` API is implemented behind a
    Java interface with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first see how to add a custom span, and after that, see how we can add
    custom tags to all spans created by a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any observation to take place using the `Observation` API, observation
    objects need to be registered in an `ObservationRegistry` bean. An `ObservationRegistry`
    bean can be injected using auto-wiring like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Adding a custom span
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add a custom span, the `Observation` interface provides a static method,
    `createNotStarted()`, that can be used to create a span. To execute the span,
    an `observe()` method can be used to provide the code that the span shall cover.
    If the code doesn’t return any value, it can be specified as a `Runnable` function;
    otherwise, it needs to be specified as a `Supplier` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the creation of a custom span for the execution of a minimalistic
    `Supplier` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `registry` parameter is a bean of type `ObservationRegistry` and is auto-wired
    as described above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of this code will result in log output like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From the log output, we can see that both log statements refer to the same trace
    ID, `9761b2b2b2da59c5096e78252c48ab3d`, but specifies different span IDs, `d8bcbd9cde9fe2d7`
    being the span ID of the custom span!
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add metadata regarding the span, we can specify it by adding a
    contextual name and a set of tags as key-value pairs. The contextual name will
    be the name of the span and it can be used to identify the span when a trace tree
    is visualized in Zipkin. If the possible values for the information are bounded,
    limited to a finite number of alternatives, the tag should be specified using
    the `lowCardinalityKeyValue()` method. For unbounded values, the `highCardinalityKeyValue()`
    method should be used. Calling these methods will result in tags being added to
    the current span, while low-cardinality values will also be tagged to metrics
    created by the observation.
  prefs: []
  type: TYPE_NORMAL
- en: We will investigate how to use metrics in *Chapter 20**, Monitoring Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of specifying information as tags looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From the example above, we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: The contextual name is set to `"product info"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key, `"template-url"`, that only has a few possible values, is specified with
    the `lowCardinalityKeyValue()` method. In our case, it has only three possible
    values for the create, get, and delete methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key, `"actual-url"`, with an unlimited number of values depending on the specified
    `productId`, has been specified with the `highCardinalityKeyValue()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s apply this to the `product-composite` service to create a custom span
    that provides the `productId` as a tag. Since the number of product IDs is unlimited,
    we will specify it using the `highCardinalityKeyValue()` method. We will create
    a span that specifies the current `productId` for each of the three API methods
    for creating, retrieving, and deleting composite products. The creation of a custom
    span that contains one high-cardinality tag is handled by a utility class, `ObservationUtil`.
    The utility class is placed in the package `se.magnus.microservices.composite.product.services.tracing`.
    The utility method `observe()` in this class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `observe()` method wraps the call to the method `Observation.createNotStarted()`.
    The use of this method is explained in the example above, so it needs no further
    explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This utility method is used in the `ProductCompositeServiceImpl` class by a
    helper method `observationWithProductInfo()` that applies common values to the
    `ProductCompositeServiceImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the helper method is used by the three API methods, `createProduct()`,
    `getProduct()`, and `deleteProduct()`. The custom span is created by wrapping
    the existing code in each method. The existing code has been moved to corresponding
    “internal” methods to simplify the structure of the solution. The “internal” methods
    are called by the `observationWithProductInfo()` method. For the `getProduct()`,
    the implementation now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If compared with the corresponding implementation in *Chapter 13*, we can see
    that the changes required to create a custom span are limited to adding a new
    “*inner*” method and calling it from the `observationWithProductInfo()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, adding a custom span to existing code can be made with a very small change,
    given a proper utility method that handles the details of setting up a custom
    span. When we try out the distributed tracing later in this chapter, we will see
    this custom span in action. With a custom span in place, let’s see how we can
    add custom tags to any span created in a microservice!
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom tags to existing spans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to add some custom information to all spans that are created by a
    microservice, we can use an `ObservationFilter`. It needs to be registered in
    the `ObservationRegistry` bean using an `ObservationRegistryCustomizer` bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply a filter that registers the current version of the `product-composite`
    microservice as a tag on every span it creates. We need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the build file to make Gradle create build info, including the current
    version specified by the `version` property in the `build.gradle` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a filter that adds the current version as a low-cardinality tag to all
    spans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a registry configuration bean that registers the filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make Gradle create build info, the following is added to the build file,
    `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This addition will result in the file `build/resources/main/META-INF/build-info.properties`
    being created when the `./gradlew build` command is executed. This file will specify
    the current version as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The build info file will be bundled into the microservice’s JAR file, and its
    information can be accessed using a `BuildProperties` bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filter looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'From the source code above, we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: A `BuildProperties` bean is injected into the filter’s constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filter’s `map()` method retrieves the microservice version from using the
    `BuildProperties` bean and sets it as a low-cardinality tag on the provided observation
    context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The registry configuration bean looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'From the source code above, we can learn that:'
  prefs: []
  type: TYPE_NORMAL
- en: A `BuildProperties` bean is also injected into the configuration class’s constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `customize()` method, the filter is created and registered. The filter
    also gets the `BuildProperties` bean injected here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filter and the registry configuration bean can be found in the `se.magnus.microservices.composite.product.services.tracing`
    package. When we try out the distributed tracing later in this chapter, we will
    see this observation filter in action.
  prefs: []
  type: TYPE_NORMAL
- en: For more ways of handling custom spans, for example, setting up predicates for
    when to apply an observation filter or using annotations to describe an observation,
    see [https://micrometer.io/docs/observation](https://micrometer.io/docs/observation).
  prefs: []
  type: TYPE_NORMAL
- en: That’s what it takes to add distributed tracing using Micrometer Tracing and
    Zipkin, so let’s try it out in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the necessary changes to the source code in place, we can try out distributed
    tracing. We will do this by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build, start, and verify the system landscape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a successful API request and see what trace information we can find in
    Zipkin related to this API request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send an unsuccessful API request and see what error information we can find.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a successful API request that triggers asynchronous processing and see
    how its trace information is represented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will discuss these steps in detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up the system landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start up the system landscape. Build the Docker images with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the system landscape in Docker and run the usual tests with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can call the API, we need an access token. Run the following commands
    to acquire an access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As noticed in previous chapters, an access token issued by the authorization
    server is valid for one hour. So, if you start to get `401 Unauthorized` errors
    after a while, it is probably time to acquire a new access token.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a successful API request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are ready to send a normal request to the API. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Expect the command to return the HTTP status code for success, `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now launch the Zipkin UI to look into what trace information has been
    sent to Zipkin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the following URL in your web browser: `http://localhost:9411/zipkin/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find the trace information for our request, we can search for traces that
    have passed through the `gateway` service. Perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the large plus sign (a white **+** sign on a red background) and select
    **serviceName** and then **gateway**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **RUN****QUERY** button.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start Time** header to see the results ordered by the latest
    first (a down arrow should be visible to the left of the **Start Time** header).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The response from finding traces should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Searching for distributed traces using Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trace information from our preceding API request is the first one in the
    list. Click on its **SHOW** button to see details pertaining to the trace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Sample distributed trace visualized in Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the detailed trace information view, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The request was received by the `gateway` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `gateway` service delegated the processing of the request to the `product-composite`
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `product-composite` service, in turn, sent three parallel requests to the
    core services: `product`, `recommendation`, and `review`. See spans named **product-composite:
    http get**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `product-composite` service received the response from all three core
    services, it created a composite response and sent it back to the caller through
    the `gateway` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The custom span created in the previous section is named **product-composite:
    product info**. Click on it to see its tags. In the details view to the right,
    we can see both the tag created by the custom span, **productId = 1**, and the
    tag created by the observation filter **build.version = 1.0.0-SNAPSHOT**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify that the tag created by the observation filter works as expected,
    click on other spans created by the `product-composite` service, and verify that
    the **build.version** is present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the span named **review: query** to see a span reported by the `review`
    microservice’s database layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19825_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: A span that describes the execution of a SQL query'
  prefs: []
  type: TYPE_NORMAL
- en: In the span’s list of tags, we can see the actual SQL query it has performed.
    We can also see its execution time of 0.8 ms. Rather valuable information!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To better understand how trace and span IDs are propagated between microservices,
    we can change the logging configuration of the `product-composite` service so
    that HTTP headers in outgoing requests are written to its log. This can be achieved
    by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following two lines to the configuration file `config-repo/product-composite.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The two lines already exist in the configuration file but are commented out.
    They are preceded by the following comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find the preceding comment in the configuration file and uncomment the two lines
    below it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, restart the `product-composite` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the log output from the `product-composite` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun the above `curl` request and you will see the log output containing the
    `traceparent` HTTP header mentioned above. For example, a request sent to the
    `recommendation` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the sample log output, we can see the value of the `traceparent` HTTP header,
    where the trace ID is set to `e1420dcc38901378e888b8ce7022510e`, and the span
    ID is set to `06867b65cf84b552`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don’t want to keep the logging of the `traceparent` HTTP header, comment
    out the two lines in `config-repo/product-composite.yml` and restart the `product-composite`
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sending an unsuccessful API request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see what the trace information looks like if we make an unsuccessful
    API request; for example, searching for a product that causes a timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send an API request for product ID `1` and enforce a delay of three seconds,
    which will trigger the time limiter, and verify that it returns the HTTP status
    code `500`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the Zipkin UI, go back to the search page (use the back button in the web
    browser) and click on the **RUN QUERY** button again. To see the results ordered
    by the latest first, click on the **Start Time** header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expect a result similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Finding a failed request using Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the failed request at the top of the returned list. Note that
    its duration bar is red, indicating that an error has occurred. Click on its **SHOW**
    button to see details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer error  Description automatically generated](img/B19825_14_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Viewing a trace of a failed request using Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see a span, **product-composite: secured request**, with an error
    symbol in front of it (a red circle with an exclamation mark).'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the span to see its tags. You will find a tag named **error** that
    clearly indicates that the error is caused by a timeout that occurred after two
    seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sending an API request that triggers asynchronous processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third type of request that is interesting to see represented in the Zipkin
    UI is a request where parts of its processing are done asynchronously. Let’s try
    a delete request, where the delete process in the core services is done asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The `product-composite` service sends a delete event to each of the three core
    services over the message broker and each core service picks up the delete event
    and processes it asynchronously. Thanks to Micrometer Tracing, trace information
    is added to the events that are sent to the message broker, resulting in a coherent
    view of the total processing of the delete request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to delete the product with a product ID of `12345`
    and verify that it returns the HTTP status code for the request being accepted,
    `202`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the delete operation is idempotent, that is, it will succeed even
    if the product doesn’t exist!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Zipkin UI, go back to the search page (use the back button in the web
    browser) and click on the **RUN QUERY** button again. To see the results ordered
    by the latest first, click on the **Start Time** header. Expect a result like
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: Finding a delete request using Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the delete request at the top of the returned list. Note that
    the root service name, **gateway**, is suffixed by the HTTP method used, **delete**.
    Click on its **SHOW** button to see details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Viewing a delete request using Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the trace information for processing the delete request:'
  prefs: []
  type: TYPE_NORMAL
- en: The request was received by the `gateway` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `gateway` service delegated the processing of the request to the `product-composite`
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `product-composite` service has created a custom span named **product-composite:
    product info**, as expected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `product-composite` service, in turn, published three events on the message
    broker (RabbitMQ, in this case). See spans with names suffixed with **send**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `product-composite` service is now done and returns an HTTP `success` status
    code, `200`, through the `gateway` service back to the caller. Note that this
    is done before all processing is completed by the core services!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The core services (`product`, `recommendation`, and `review`) receive the `delete`
    events and start to process them asynchronously, that is, independently of one
    another. See spans with names suffixed with **receive**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To confirm the involvement of the message broker, click on the first product
    span:![A screenshot of a computer  Description automatically generated](img/B19825_14_09.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.9: Viewing information about the asynchronous processing of an event
    using Zipkin'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The selected span contains a tag named **peer.service** that reveals that RabbitMQ
    is used, and the tag **spring.rabbit.listener.id** points out that the messages
    are received by the consumer group **productsGroup**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, to see the `traceparent` header in a message sent through RabbitMQ,
    we can inspect the message stored in the audit queue for the products. Open [http://localhost:15672/#/queues/%2F/products.auditGroup](http://localhost:15672/#/queues/%2F/products.auditGroup)
    in your web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the button named **Get Messages(s)** to see the oldest message in
    the queue. The web page should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_14_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: A message with a traceparent header in RabbitMQ'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Properties** section, you will find the **traceparent** header for
    this message. In this case, the trace ID is **99a9f2501e4d454643184c6b1cb0a232**
    and the span ID is **7458430fe56d6df1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This completes the tests of distributed tracing for this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: The Zipkin UI contains much more functionality for finding traces of interest!
  prefs: []
  type: TYPE_NORMAL
- en: To get more accustomed to the Zipkin UI, try out the query functionality by
    clicking on the plus sign and selecting **tagQuery**. For example, to find requests
    that failed on a `403 - Forbidden` error, set its value to `tagQuery=http.status_code=403`,
    searching for traces that failed on a Forbidden (`403`) error. Also, try setting
    limits for the lookback range (start and end time) and the maximum number of hits
    by clicking on the cogwheel icon to the right of the **RUN QUERY** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap up the tests by bringing down the system landscape. Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use distributed tracing to understand how
    our microservices cooperate. We learned how to use Micrometer Tracing to collect
    trace information, and Zipkin to store and visualize the trace information.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how adding Micrometer Tracing to microservices is affected by adding
    a couple of dependencies to the build files and setting up a few configuration
    parameters. Reactive microservices are currently not fully supported, but we learned
    how to work around the most important issues. If required, we can use the `Observation`
    API to create custom spans or add tags to all spans created by a microservice.
    We also saw how the Zipkin UI makes it very easy to identify which part of a complex
    workflow caused either an unexpectedly long response time or an error. Both synchronous
    and asynchronous workflows can be visualized with the Zipkin UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about container orchestrators, specifically
    Kubernetes. We will learn how to use Kubernetes to deploy and manage microservices,
    while also improving important runtime characteristics such as scalability, high
    availability, and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the `management.tracing.sampling.probability` configuration
    parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you identify the longest-running request after executing the `test-em-all.bash`
    test script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we find requests that have been interrupted by a timeout introduced
    in *Chapter 13*, *Improving Resilience Using Resilience4j*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the trace look like for an API request when the circuit breaker introduced
    in *Chapter 13*, *Improving Resilience Using Resilience4j*, is open?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we locate APIs that failed on the caller not being authorized to perform
    the request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we programmatically add trace information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
