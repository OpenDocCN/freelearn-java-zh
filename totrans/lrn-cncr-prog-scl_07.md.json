["```java\nimport java.util.concurrent.atomic._ \nval urls = new AtomicReference[List[String]](Nil) \nval clen = new AtomicInteger(0) \n\n```", "```java\nimport scala.annotation.tailrec \ndef addUrl(url: String): Unit = { \n  @tailrec def append(): Unit = { \n    val oldUrls = urls.get \n    val newUrls = url :: oldUrls \n    if (!urls.compareAndSet(oldUrls, newUrls)) append() \n  } \n  append() \n  clen.addAndGet(url.length + 1) \n} \n\n```", "```java\ndef getUrlArray(): Array[Char] = { \n  val array = new Array[Char](clen.get) \n  val urlList = urls.get \n  for ((ch, i) <- urlList.map(_ + \"\\n\").flatten.zipWithIndex) { \n    array(i) = ch \n  } \n  array \n} \n\n```", "```java\nimport scala.concurrent._ \nimport ExecutionContext.Implicits.global \nobject AtomicHistoryBad extends App { \n  Future { \n    try { log(s\"sending: ${getUrlArray().mkString}\") } \n    catch { case e: Exception => log(s\"Houston... $e!\") } \n  } \n  Future { \n    addUrl(\"http://scala-lang.org\") \n    addUrl(\"https://github.com/scala/scala\") \n    addUrl(\"http://www.scala-lang.org/api\") \n    log(\"done browsing\") \n  } \n  Thread.sleep(1000) \n} \n\n```", "```java\ndef swap() = atomic { // not actual code \n  val tmp = a \n  a = b \n  b = tmp \n} \ndef inc() = atomic { a = a + 1 } \n\n```", "```java\nlibraryDependencies += \"org.scala-stm\" %% \"scala-stm\" % \"0.7\" \n\n```", "```java\nimport scala.concurrent.stm._ \n\n```", "```java\nval urls = Ref[List[String]](Nil) \nval clen = Ref(0) \n\n```", "```java\ndef addUrl(url: String): Unit = atomic { implicit txn => \n  urls() = url :: urls() \n  clen() = clen() + url.length + 1 \n} \n\n```", "```java\ndef getUrlArray(): Array[Char] = atomic { implicit txn => \n  val array = new Array[Char](clen()) \n  for ((ch, i) <- urls().map(_ + \"\\n\").flatten.zipWithIndex) { \n    array(i) = ch \n  } \n  array \n} \n\n```", "```java\nobject AtomicHistorySTM extends App { \n  Future { \n    addUrl(\"http://scala-lang.org\") \n    addUrl(\"https://github.com/scala/scala\") \n    addUrl(\"http://www.scala-lang.org/api\") \n    log(\"done browsing\") \n  } \n  Thread.sleep(25) \n  Future { \n    try { log(s\"sending: ${getUrlArray().mkString}\") } \n    catch { case e: Exception => log(s\"Ayayay... $e\") } \n  } \n  Thread.sleep(5000) \n} \n\n```", "```java\nobject CompositionSideEffects extends App {` \n  val myValue = Ref(0) \n  def inc() = atomic { implicit txn => \n    log(s\"Incrementing ${myValue()}\") \n    myValue() = myValue() + 1 \n  } \n  Future { inc() } \n  Future { inc() } \n  Thread.sleep(5000) \n} \n\n```", "```java\nForkJoinPool-1-worker-1: Incrementing 0 \nForkJoinPool-1-worker-3: Incrementing 0 \nForkJoinPool-1-worker-3: Incrementing 1 \n\n```", "```java\ndef inc() = atomic { implicit txn => \n  val valueAtStart = myValue() \n  Txn.afterCommit { _ => \n    log(s\"Incrementing $valueAtStart\") \n  } \n  myValue() = myValue() + 1 \n} \n\n```", "```java\ndef inc() = atomic { implicit txn => \n  Txn.afterCommit { _ => \n    log(s\"Incrementing ${myValue()}\") // don't do this! \n  } \n  myValue() = myValue() + 1 \n} \n\n```", "```java\n  def inc() = atomic { implicit txn => \n    Txn.afterRollback { _ => \n      log(s\"rollin' back\") \n    } \n    myValue() = myValue() + 1 \n  } \n\n```", "```java\ncase class Node(elem: Int, next: Ref[Node]) \n\n```", "```java\ndef nodeToString(n: Node): String = atomic { implicit txn => \n  val b = new StringBuilder \n  var curr = n \n  while (curr != null) { \n    b ++= s\"${curr.elem}, \" \n    curr = curr.next() \n  } \n  b.toString \n} \n\n```", "```java\ndef nodeToStringWrong(n: Node): String = { \n  val b = new StringBuilder // very bad \n  atomic { implicit txn => \n    var curr = n \n    while (curr != null) { \n      b ++= s\"${curr.elem}, \" \n      curr = curr.next() \n    } \n  } \n  b.toString \n} \n\n```", "```java\ncase class Node(val elem: Int, val next: Ref[Node]) { \n  def append(n: Node): Unit = atomic { implicit txn => \n    val oldNext = next() \n    next() = n \n    n.next() = oldNext \n  } \n  def nextNode: Node = next.single() \n} \n\n```", "```java\ndef nextNode: Node = atomic { implicit txn => \n  next() \n} \n\n```", "```java\nval nodes = Node(1, Ref(Node(4, Ref(Node(5, Ref(null)))))) \nval f = Future { nodes.append(Node(2, Ref(null))) } \nval g = Future { nodes.append(Node(3, Ref(null))) } \nfor (_ <- f; _ <- g) log(s\"Next node is: ${nodes.nextNode}\") \n\n```", "```java\ndef appendIfEnd(n: Node) = next.single.transform { \n  oldNext => if (oldNext == null) n else oldNext \n} \n\n```", "```java\nclass TSortedList { \n  val head = Ref[Node](null) \n  override def toString: String = atomic { implicit txn => \n    val h = head() \n    nodeToString(h) \n  } \n} \n\n```", "```java\nimport scala.annotation.tailrec \ndef insert(x: Int): this.type = atomic { implicit txn => \n  @tailrec def insert(n: Node): Unit = { \n    if (n.next() == null || n.next().elem > x) \n      n.append(new Node(x, Ref(null))) \n    else insert(n.next()) \n  } \n  if (head() == null || head().elem > x) \n    head() = new Node(x, Ref(head())) \n  else insert(head()) \n  this \n} \n\n```", "```java\n@tailrec \nfinal def insert(n: Node, x: Int)(implicit txn: InTxn): Unit = { \n  if (n.next() == null || n.next().elem > x) \n    n.append(new Node(x, Ref(null))) \n  else insert(n.next(), x) \n} \n\n```", "```java\n@tailrec \nfinal def insert(n: Node, x: Int): Unit = atomic { implicit txn => \n  if (n.next() == null || n.next().elem > x) \n    n.append(new Node(x, Ref(null))) \n  else insert(n.next(), x) \n} \n\n```", "```java\nval sortedList = new TSortedList \nval f = Future { sortedList.insert(1); sortedList.insert(4) } \nval g = Future { sortedList.insert(2); sortedList.insert(3) } \nfor (_ <- f; _ <- g) log(s\"sorted list - $sortedList\") \n\n```", "```java\ndef pop(xs: TSortedList, n: Int): Unit = atomic { implicit txn => \n  var left = n \n  while (left > 0) { \n    xs.head() = xs.head().next() \n    left -= 1 \n  } \n} \n\n```", "```java\nval lst = new TSortedList \nlst.insert(4).insert(9).insert(1).insert(16) \n\n```", "```java\nFuture { pop(lst, 2) } foreach { \n  case _ => log(s\"removed 2 elements; list = $lst\") \n} \n\n```", "```java\nFuture { pop(lst, 3) } onComplete { \n  case Failure(t) => log(s\"whoa $t; list = $lst\") \n} \n\n```", "```java\nFuture { \n  atomic { implicit txn => \n    pop(lst, 1) \n    sys.error(\"\") \n  } \n} onComplete { \n  case Failure(t) => log(s\"oops again $t - $lst\") \n} \n\n```", "```java\nimport scala.util.control.Breaks._ \nFuture { \n  breakable { \n    atomic { implicit txn => \n      for (n <- List(1, 2, 3)) { \n        pop(lst, n) \n        break \n      } \n    } \n  } \n  log(s\"after removing - $lst\") \n} \n\n```", "```java\nimport scala.util.control._ \nFuture { \n  breakable { \n    atomic.withControlFlowRecognizer { \n      case c: ControlThrowable => false \n    } { implicit txn => \n      for (n <- List(1, 2, 3)) { \n        pop(lst, n) \n        break \n      } \n    } \n  } \n  log(s\"after removing - $lst\") \n} \n\n```", "```java\nval lst = new TSortedList \nlst.insert(4).insert(9).insert(1).insert(16) \natomic { implicit txn => \n  pop(lst, 2) \n  log(s\"lst = $lst\") \n  try { pop(lst, 3) } \n  catch { case e: Exception => log(s\"Houston... $e!\") } \n  pop(lst, 1) \n} \nlog(s\"result - $lst\") \n\n```", "```java\nrun-main-26: lst = 9, 16,\nrun-main-26: lst = 9, 16,\nrun-main-26: Houston... java.lang.NullPointerException!\nrun-main-26: result - 16,\n\n```", "```java\ndef headWait(lst: TSortedList): Int = atomic { implicit txn => \n  while (lst.head() == null) {} // never do this \n  lst.head().elem \n} \n\n```", "```java\nobject RetryHeadWaitBad extends App { \n  val myList = new TSortedList \n  Future { \n    val headElem = headWait(myList) \n    log(s\"The first element is $headElem\") \n  } \n  Thread.sleep(1000) \n  Future { myList.insert(1) } \n  Thread.sleep(1000) \n} \n\n```", "```java\ndef headWait(lst: TSortedList): Int = atomic { implicit txn => \n  if (lst.head() != null) lst.head().elem \n  else retry \n} \n\n```", "```java\nobject RetryHeadWait extends App { \n  val myList = new TSortedList \n  Future { \n    blocking { \n      log(s\"The first element is ${headWait(myList)}\") \n    } \n  } \n  Thread.sleep(1000) \n  Future { myList.insert(1) } \n  Thread.sleep(1000) \n} \n\n```", "```java\nval queue1 = new TSortedList \nval queue2 = new TSortedList \nval consumer = Future { \n  blocking { \n    atomic { implicit txn => \n      log(s\"probing queue1\") \n      log(s\"got: ${headWait(queue1)}\") \n    } orAtomic { implicit txn => \n      log(s\"probing queue2\") \n      log(s\"got: ${headWait(queue2)}\") \n    } \n  } \n} \n\n```", "```java\nThread.sleep(50) \nFuture { queue2.insert(2) } \nThread.sleep(50) \nFuture { queue1.insert(1) } \nThread.sleep(2000) \n\n```", "```java\nval message = Ref(\"\") \nFuture { \n  blocking { \n    atomic.withRetryTimeout(1000) { implicit txn => \n      if (message() != \"\") log(s\"got a message - ${message()}\") \n      else retry \n    } \n  } \n} \nThread.sleep(1025) \nmessage.single() = \"Howdy!\" \n\n```", "```java\nFuture { \n  blocking { \n    atomic { implicit txn => \n      if (message() == \"\") { \n        retryFor(1000) \n        log(s\"no message.\") \n      } else log(s\"got a message - '${message()}'\") \n    } \n  } \n} \nThread.sleep(1025) \nmessage.single() = \"Howdy!\" \n\n```", "```java\nval myLog = TxnLocal(\"\") \n\n```", "```java\ndef clearList(lst: TSortedList): Unit = atomic { implicit txn => \n  while (lst.head() != null) { \n    myLog() = myLog() + \"\\nremoved \" + lst.head().elem \n    lst.head() = lst.head().next() \n  } \n} \n\n```", "```java\nval myList = new TSortedList().insert(14).insert(22) \ndef clearWithLog(): String = atomic { implicit txn => \n  clearList(myList)  \n  myLog() \n} \nval f = Future { clearWithLog() } \nval g = Future { clearWithLog() } \nfor (h1 <- f; h2 <- g) log(s\"Log for f: $h1\\nLog for g: $h2\") \n\n```", "```java\nval pages: Seq[String] = Seq.fill(5)(\"Scala 2.10 is out, \" * 7) \nval website: Array[Ref[String]] = pages.map(Ref(_)).toArray \n\n```", "```java\nval pages: Seq[String] = Seq.fill(5)(\"Scala 2.10 is out, \" * 7) \nval website: TArray[String] = TArray(pages) \n\n```", "```java\ndef replace(p: String, s: String): Unit = atomic { implicit txn => \n  for (i <- 0 until website.length) \n    website(i) = website(i).replace(p, s) \n} \n\n```", "```java\ndef asString = atomic { implicit txn => \n  var s: String = \"\" \n  for (i <- 0 until website.length) \n    s += s\"Page $i\\n======\\n${website(i)}\\n\\n\" \n  s \n} \nval f = Future { replace(\"2.10\", \"2.11\") } \nval g = Future { replace(\"out\", \"released\") } \nfor (_ <- f; _ <- g) log(s\"Document\\n$asString\") \n\n```", "```java\nval alphabet = TMap(\"a\" -> 1, \"B\" -> 2, \"C\" -> 3) \n\n```", "```java\nFuture { \n  atomic { implicit txn => \n    alphabet(\"A\") = 1 \n    alphabet.remove(\"a\") \n  } \n} \nThread.sleep(23) \nFuture { \n  val snap = alphabet.single.snapshot \n  log(s\"atomic snapshot: $snap\") \n} \nThread.sleep(2000) \n\n```", "```java\n            class TPair[P, Q](pinit: P, qinit: Q) { \n              def first(implicit txn: InTxn): P = ??? \n              def first_=(x: P)(implicit txn: InTxn): P = ??? \n              def second(implicit txn: InTxn): Q = ??? \n              def second_=(x: Q)(implicit txn: InTxn): Q = ??? \n              def swap()(implicit e: P =:= Q, txn: InTxn): Unit = ??? \n            } \n\n    ```", "```java\n            class MVar[T] { \n              def put(x: T)(implicit txn: InTxn): Unit = ??? \n              def take()(implicit txn: InTxn): T = ??? \n            } \n\n    ```", "```java\n            def swap[T](a: MVar[T], b: MVar[T])(implicit txn: InTxn) \n\n    ```", "```java\n            def atomicRollbackCount[T](block: InTxn => T): (T, Int) \n\n    ```", "```java\n           def atomicWithRetryMax[T](n: Int)(block: InTxn => T): T \n\n    ```", "```java\n            class TQueue[T] { \n              def enqueue(x: T)(implicit txn: InTxn): Unit = ??? \n              def dequeue()(implicit txn: InTxn): T = ??? \n\n    ```", "```java\n            class TSortedSet[T] { \n              def add(x: T)(implicit txn: InTxn): Unit = ??? \n              def remove(x: T)(implicit txn: InTxn): Boolean = ??? \n              def apply(x: T)(implicit txn: InTxn): Boolean = ??? \n            } \n\n    ```"]