["```java\nManagedExecutor executor = ManagedExecutor.builder()\n        .cleared(ThreadContext.TRANSACTION)\n        .propagated(ThreadContext.ALL_REMAINING)\n        .maxAsync(10)\n        .build();\n```", "```java\nCompletableFuture<Long> stage1 =   executor.newIncompleteFuture();\nstage1.thenApply(function1).thenApply(function2);\nstage1.completeAsync(supplier); \n```", "```java\nThreadContextthreadContext = ThreadContext.builder()  .propagated(ThreadContext.APPLICATION, ThreadContext     .SECURITY).unchanged().cleared(ThreadContext       .ALL_REMAINING).build();\n```", "```java\nCompletionStage stage =   threadContext.withContextCapture(someMethod);\nstage.thenApply(function1).thenAccept(aConsumer);\n```", "```java\nFunction<String, String> aFunction =   threadContext.contextualFunction(function1);\nCompletableFuture.thenApply(aFunction)    .thenAccept(aConsumer);\n```", "```java\n<dependency>\n    <groupId>org.eclipse.microprofile.context-      propagation</groupId>\n    <artifactId>microprofile-context-propagation-      api</artifactId>\n    <version>1.2</version>\n</dependency>\n```", "```java\ndependencies {\n  providedCompile org.eclipse.microprofile.context-    propagation: microprofile-context-propagation-api:1.2\n}\n```", "```java\nMessage<T> newMessage =   aMessage.withPayload(payload).withAck(...).withNack(...) \n```", "```java\n@Incoming(\"channel-c\")\n@Acknowledgment(Acknowledgment.Strategy.MANUAL)\npublic CompletionStage<Void> consume(Message<I> msg) {\n  System.out.println(\"Received the message: \" +     msg.getPayload());\n  return msg.ack();\n}\n```", "```java\n@Incoming(\"channel-a\")\nCompletionStage<Void> method(Message<I> msg) {\n    return message.ack();\n}\n```", "```java\n@Inject\n@Channel(\"channel-d\")\nprivate Publisher<String> publisher;\n```", "```java\n@Outgoing(\"channel-b\")\npublic Message<Integer> publish() {\n    return Message.of(123);\n}\n```", "```java\n@Incoming(\"channel-a\")\n@Outgoing(\"channel-b\")\npublic Message<Integer> process(Message<Integer> message) {\n    return message.withPayload(message.getPayload() + 100);\n}\n```", "```java\n@Inject @Channel(\"channel-c\")\nprivate Emitter<String> emitter;\npublic void publishMessage() {\n    emitter.send(\"m\");\n    emitter.send(\"n\");\n    emitter.complete();\n}\n```", "```java\n@Inject @Channel(\"channel-e\")\nprivate Emitter<String> emitter;\npublic void publishMessage() {\n    emitter.send(Message.of(\"m\");\n    emitter.send(Message.of(\"n\");\n    emitter.send(Message.of(\"q\")\n}\n```", "```java\n@Inject @Channel(\"channel-d\")\n@OnOverflow(value=OnOverflow.Strategy.BUFFER,   bufferSize=100)\nprivate Emitter<String> emitter;\npublic void publishMessage() {\n    emitter.send(\"message1\");\n    emitter.send(\"message2\");\n    emitter.complete();\n}\n```", "```java\n@ApplicationScoped\n@Connector(\"my.kafka\")\npublic class KafkaConnector implements   IncomingConnectorFactory, OutgoingConnectorFactory {\n    // ...\n}\n```", "```java\n@Incoming(\"order\")\nCompletionStage<Void> method(Message<I> msg) {\n    return message.ack();\n}\n```", "```java\nmp.messaging.incoming.order.connector=liberty-kafka\nmp.messaging.connector.liberty-kafka.bootstrap.  servers=localhost:9092\nmp.messaging.incoming.order.topic=topic-order\n```", "```java\n<dependency>\n  <groupId>\n    org.eclipse.microprofile.reactive.messaging\n  </groupId>\n  <artifactId>\n    microprofile-reactive-messaging-api\n  </artifactId>\n  <version>2.0</version>\n</dependency>\n```", "```java\ndependencies {\n  providedCompile org.eclipse.microprofile.reactive     .messaging: microprofile-reactive-messaging-api:2.0\n}\n```"]