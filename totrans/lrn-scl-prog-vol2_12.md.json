["```java\nobject ThreadFirstEncounter extends App { \n\n  class FirstThread extends Thread { \n    override def run(): Unit = println(s\"FirstThread's run!\") \n  } \n\n  val firstThread = new FirstThread() \n  firstThread.start() \n\n  println(s\"CurrentThread: ${Thread.currentThread().getName}\") \n  println(s\"firstThread: ${firstThread.getName}\") \n\n} \n```", "```java\nFirstThread's run! \nCurrentThread: main \nfirstThread: Thread-0 \n```", "```java\nobject TowardsLocking extends App { \n  var counter = 0 // counter variable \n\n  def readWriteCounter(): Int = { \n    val incrementedCounter = counter + 1  //Reading counter \n    counter = incrementedCounter // Writing to counter \n    incrementedCounter \n  } \n\n  def printCounter(nTimes: Int): Unit = { \n    val readWriteCounterNTimes = for(i <- 1 to nTimes) yield readWriteCounter() \n    println(s\"${Thread.currentThread.getName} executing :: counter $nTimes times:  $readWriteCounterNTimes\") \n  } \n\n  class First extends Thread { \n    override def run(): Unit = { \n      printCounter(10) \n    } \n  } \n\n  val first = new First \n  first.start() // thread-0 \n\n  printCounter(10)   // main thread \n\n} \n```", "```java\nmain executing :: counter 10 times:  Vector(1, 3, 5, 7, 9, 11, 13, 15, 17, 18) \nThread-0 executing :: counter 10 times:  Vector(1, 2, 4, 6, 8, 10, 11, 12, 14, 16) \n```", "```java\ndef readWriteCounter(): Int = { \n    val incrementedCounter = counter + 1  //Reading counter \n    counter = incrementedCounter // Writing to counter \n    incrementedCounter \n  } \n```", "```java\nsynchronized statement in Scala, using which we can implement a locking mechanism. Let's try that and see how it looks:\n```", "```java\nobject TowardsLockingOne extends App { \n  var counter = 0 // counter variable \n\n  def readWriteCounter(): Int = this.synchronized { \n    val incrementedCounter = counter + 1  //Reading counter \n    counter = incrementedCounter // Writing to counter \n    incrementedCounter \n  } \n\n  def printCounter(nTimes: Int): Unit = { \n    val readWriteCounterNTimes = for(i <- 1 to nTimes) yield readWriteCounter() \n    println(s\"${Thread.currentThread.getName} executing :: counter $nTimes times:  $readWriteCounterNTimes\") \n  } \n\n  class First extends Thread { \n    override def run(): Unit = { \n      printCounter(10) \n    } \n  } \n\n  val first = new First \n  first.start() // thread-0 \n\n  printCounter(10)   // main thread \n} \n```", "```java\ndef readWriteCounter(): Int = this.synchronized { \n    val incrementedCounter = counter + 1  //Reading counter \n    counter = incrementedCounter // Writing to counter \n    incrementedCounter \n  } \n```", "```java\nval any = new Any() \n\ndef readWriteCounter(): Int = any.synchronized { \n    val incrementedCounter = counter + 1  //Reading counter \n    counter = incrementedCounter // Writing to counter \n    incrementedCounter \n  } \nvolatile and *atomic variables*. These are lightweight and less expensive than synchronized statements, and better in performance. They need additional mechanisms to ensure correct synchronization when you only use volatile variables large in numbers. We should be aware that OS scheduler can also freeze any thread for any reason, which might also cause a thread carrying locks to freeze. In this case, if a thread holding a lock gets frozen, it'll block execution of other threads as well; that's not something we want for sure.\n```", "```java\nimport java.util.concurrent.ForkJoinPool \nimport scala.concurrent.{ExecutionContext, ExecutionContextExecutor} \n\nobject TowardsExecutor extends App { \n\n  val executor: ForkJoinPool = new java.util.concurrent.ForkJoinPool() \n  executor.execute(new Runnable { \n    override def run(): Unit = \n      println(s\"${Thread.currentThread().getName()} printing this in execution of juc.ForkJoinPool!\") \n  }) \n\n  val ec: ExecutionContextExecutor = ExecutionContext.global \n  ec.execute(new Runnable { \n    override def run(): Unit = \n      println(s\"${Thread.currentThread().getName()} printing this in execution of sc.ExecutionContext!\") \n  }) \n} \n```", "```java\nval executor: ForkJoinPool = new java.util.concurrent.ForkJoinPool() \nval ec: ExecutionContextExecutor = ExecutionContext.global \n```", "```java\nimport java.util.concurrent.ForkJoinPool \nimport scala.concurrent.{ExecutionContext, ExecutionContextExecutor} \n\nobject TowardsExecutor extends App { \n\n  val executor: ForkJoinPool = new java.util.concurrent.ForkJoinPool() \n  executor.execute(new Runnable { \n    override def run(): Unit = \n      println(s\"${Thread.currentThread().getName()} printing this in execution of juc.ForkJoinPool!\") \n  }) \n\n  val ec: ExecutionContextExecutor = ExecutionContext.global \n  ec.execute(new Runnable { \n    override def run(): Unit = \n      println(s\"${Thread.currentThread().getName()} printing this in execution of sc.ExecutionContext!\") \n  }) \n\n  Thread.sleep(500) \n\n} \n```", "```java\nscala-execution-context-global-11 printing this in execution of sc.ExecutionContext! \nForkJoinPool-1-worker-1 printing this in execution of juc.ForkJoinPool! \n```", "```java\nimport scala.concurrent._ \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nobject FutureExample extends App { \n\n  val fileSource = \"/Users/vika/Documents/LSProg/LSPWorkspace/FirstProject/src/chapter5/football_stats.csv\" \n\n  def listOfPlayers(): Future[List[Player]] = Future { \n    val source = io.Source.fromFile(fileSource) \n    val list = source.getLines().toList \n    source.close() \n    giveMePlayers(list) \n  } \n\n  println(s\"listOfPlayers completed: ${listOfPlayers.isCompleted}\") \n\n  Thread.sleep(500) \n\n  println(s\"listOfPlayers completed: ${listOfPlayers.isCompleted}\") \n\n  def giveMePlayers(list: List[String]): List[Player] = list match { \n    case head :: tail => tail map {line => \n      val columns = line.split((\",\")).map(_.trim) \n      Player(columns(5),columns(6),columns(9),columns(7), \n        columns(8),columns(10), columns(12), columns(0),columns(2)) \n    } \n    case Nil => List[Player]() \n  } \n\n} \n\ncase class Player(name: String, nationality: String, age:String, club: String, domesticLeague: String, rawTotal: String, finalScore: String,ranking2016: String, ranking2015: String) \n```", "```java\nlistOfPlayers completed: false \nlistOfPlayers completed: true \n```", "```java\nimport scala.concurrent._ \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nobject FutureExample extends App { \n\n  val fileSource = \n\"/Users/vika/Documents/LSProg/LSPWorkspace/FirstProject/src/chapter13/football_stats.csv\" \n\n  val listOfPlayers: Future[List[Player]] = Future { \n      val source = io.Source.fromFile(fileSource) \n      val list = source.getLines().toList \n\n      source.close() \n\n      giveMePlayers(list) \n  } \n\n  def giveMePlayers(list: List[String]): List[Player] = list match { \n    case head :: tail => tail map {line => \n      val columns = line.split((\",\")).map(_.trim) \n      Player(columns(5),columns(6),columns(9),columns(7), \n        columns(8),columns(10), columns(12), columns(0),columns(2)) \n    } \n    case Nil => List[Player]() \n  } \n\n  // Registering a callback \n  listOfPlayers foreach { \n    case list => list foreach println \n  } \n\n  Thread.sleep(5000) \n\n} \n\ncase class Player(name: String, nationality: String, age: String, club: String, domesticLeague: String, rawTotal: String, finalScore: String,ranking2016: String, ranking2015: String) \nforeach function, on Future value. This is exactly what we mean when we say registering a *callback.* When the value of Future computation becomes available, it gets executed. That's going to work only if we get some value out of our Future computation. But we should be aware of the fact that the computation might fail. In that case, this callback is not going to be executed. The task of callback execution is taken care of by the execution context.\n```", "```java\nlistOfPlayers onComplete { \n  case Success(list) => list foreach println \n  case Failure(_) => println(s\"listOfPlayers couldn't be fetched.\") \n} \nonComplete*,* which gets called once the Future's value is available; in other words, when Future gets completed. Let's take a look at the onComplete method's signature for a Future[T]:\n```", "```java\ndef onComplete[U](f: Try[T] => U)(implicit executor: ExecutionContext): Unit \n```", "```java\nimport scala.concurrent.Future \nimport scala.concurrent.ExecutionContext.Implicits.global \nimport scala.util.{Failure, Success} \n\nobject TowardsFutureComposition extends App { \n\ndef firstFuture: Future[String] = Future { \"1\" } \ndef secondFuture(str: String): Future[Int] = Future { str.toInt } \n\n  firstFuture onComplete { \n    case Success(value1) => \n         secondFuture(value1) onComplete { \n      case Success(value2) => println(s\"Converted int: $value2\") \n      case Failure(exception) => println(s\"Conversion failed due to ${exception.getMessage} \") \n    } \n    case Failure(excep) => Future.failed(excep) \n  } \n\n  Thread.sleep(5000) \n} \n```", "```java\nobject FutureComposition extends App { \n\n  def firstFuture: Future[String] = Future { \"1\" } \n\n  def secondFuture(str: String): Future[Int] = Future { str.toInt } \n\n  firstFuture flatMap( secondFuture(_) ) map(result => println(s\"Converted int: $result\")) \n\n  Thread.sleep(5000) \n} \n```", "```java\nConverted int: 1 \n```", "```java\nfirstFuture flatMap( secondFuture(_) ) map(result => println(s\"Converted int: $result\")) \n```", "```java\ndef flatMap[S](f: T => Future[S])(implicit executor: ExecutionContext): Future[S] \n```", "```java\nfor { \n  value1 <- firstFuture \n  value2 <- secondFuture(value1) \n} yield println(s\"Converted int: $value2\") \n```", "```java\nimport scala.concurrent._ \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nobject ItsAPromise extends App { \n\n  val firstPromise = Promise[String] \n\n  for { \n    value1 <- firstPromise.future \n  } yield println(s\"Value1: $value1\") \n\n  firstPromise.success(\"1\") \n\n  Thread.sleep(500) \n} \n```", "```java\nValue1: 1 \n```", "```java\ndef apply[T](): Promise[T] \n```", "```java\n  firstPromise.success(\"1\") \n```", "```java\nimport scala.collection.parallel.immutable.ParSeq \nimport scala.concurrent.Future \nimport scala.util.{Failure, Success} \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nobject TowardsParallelCollections extends App { \n\n  val fileSource =    \"/Users/vika/Documents/LSProg/LSPWorkspace/FirstProject/src/chapter13/football_stats.csv\" \n\n  val listOfPlayers: Future[List[Player]] = Future { \n    val source = io.Source.fromFile(fileSource) \n    val list: List[String] = source.getLines().toList \n\n    source.close() \n\n    val parSequence = list.par.tail \n\n    val playerParSequence: ParSeq[Player] = parSequence.map { \n      case line => val columns = line.split((\",\")).map(_.trim) \n        Player(columns(5),columns(6),columns(9),columns(7), \n          columns(8),columns(10), columns(12), columns(0),columns(2)) \n    } \n\n    playerParSequence.toList \n  } \n\n  listOfPlayers foreach { \n    case list => list foreach println \n  } \n\n  Thread.sleep(5000) \n\n} \n```"]