<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer045">
			</div>
		</div>
		<div class="Content" id="_idContainer046">
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>4. Collections, Lists and Java's Built-In APIs</h1>
		</div>
		<div class="Content" id="_idContainer047">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to the powerful Java collections framework, which is used to store, sort, and filter data. It will first take you through the structure of the built-in Collections <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>), the Java collections framework, which will simplify your dealings with complex data structures and allow you to use and create APIs with minimal effort. Through this framework, you will examine the relationship between lists and arrays, and learn to populate lists from arrays. Finally, in this chapter's final activity, you will create and complete a program in which you will be asked to perform standard operations on data stored in sets, lists, and maps in preparation for future chapters.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Introduction</h1>
			<p>Java comes with a built-in Collections API, allowing you to manipulate data structures with very little effort. A collection is an object that contains multiple elements. Collections are used to store, share, process, and communicate aggregated data. We call this system the <strong class="bold">Java collections framework</strong>.</p>
			<p>As part of this framework, there are different components that are used to optimize our interaction with the actual data:</p>
			<ul>
				<li><strong class="bold">Interfaces</strong>: Abstract data types that represent collections</li>
				<li><strong class="bold">Implementations</strong>: Specific implementations of the collection interfaces</li>
				<li><strong class="bold">Algorithms</strong>: Polymorphic methods used to process the data within a collection for operations such as sorting and searching<p class="callout-heading">Note</p><p class="callout">Other programming languages have their own collection frameworks. For example, C++ has the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>). Java boasts simplicity when it comes to its collection framework. </p></li>
			</ul>
			<p>Using the collections framework has many benefits, including a reduction in the complexity of creating programs that deal with data structures, an increase in the performance of programs, a simplification of API creation and use, and an increase in the reuse of functioning software.</p>
			<p>The collections framework is relevant even when handling data that can be accessed by several processes simultaneously, as this would be the case in multithreaded programming scenarios. However, it is not the intention of this chapter to deal with concurrent programming.</p>
			<p>The Collections API comes with five main interfaces:</p>
			<ul>
				<li><strong class="source-inline">Set</strong>: A collection that contains no duplicates</li>
				<li><strong class="source-inline">List</strong>: An ordered collection or sequence, allowing for duplicates</li>
				<li><strong class="source-inline">Queue</strong>: A collection that sorts data in the order of its arrival, typically handled as a <strong class="bold">First In First Out</strong> (<strong class="bold">FIFO</strong>) process</li>
				<li><strong class="source-inline">Deque</strong>: Essentially a queue that allows for data insertion at both ends, meaning that it can be handled both as FIFO and <strong class="bold">Last In First Out</strong> (<strong class="bold">LIFO</strong>)</li>
				<li><strong class="source-inline">Map</strong>: Relates keys—which must be unique—to values</li>
			</ul>
			<p>In this chapter, we will define the main interfaces (lists, sets, and maps), and explore examples of their respective uses. The framework has even more interfaces than the ones listed previously, but the others are either just variations of those listed or are outside the scope of this chapter. Furthermore, we will look at how arrays work in much more depth than we have previously.</p>
			<p>The definition of a simple collection—in this case, a specific type of set would be as follows:</p>
			<p class="source-code">Set mySet = new HashSet();</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The different available classes for sets, lists, queues, deques, and maps are named after the interfaces. The different classes present different properties, as we will see later in the chapter.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Arrays</h1>
			<p>Arrays are part of the collections framework. There are some static methods that can be used to manipulate arrays. The operations you can perform are creating, sorting, searching, comparing, streaming, and transforming arrays. You were introduced to arrays in <em class="italic">Chapter 2</em>, <em class="italic">Learning the Basics</em>, where you saw how they can be used to store data of the same type. The declaration of an array is quite straightforward. Let's see what an array of strings would look like:</p>
			<p class="source-code">String[] text = new String[] { "spam", "more", "buy" };</p>
			<p>Running operations on an array is as easy as calling some of the methods contained in the <strong class="source-inline">java.util.Arrays</strong> package. For example, sorting the previous array would require calling the following:</p>
			<p class="source-code">java.util.Arrays.sort( text );</p>
			<p>The methods dedicated to handling arrays include one method that could be used to print out full arrays as if they were strings. This can be very handy when debugging a program:</p>
			<p class="source-code">System.out.println( java.util.Arrays.toString( text ) );</p>
			<p>This will print the arrays and display each element separated by commas and within square brackets, <strong class="source-inline">[]</strong>. If you executed the previous command after sorting the declared array of strings, the outcome would be:</p>
			<p class="source-code">[buy, more, spam]</p>
			<p>As you can see, the array has been sorted in ascending alphabetical order. There is a difference between that way of printing out an array and using a <strong class="source-inline">for</strong> loop to iterate throughout an array:</p>
			<p class="source-code">for (int i = 0; i &lt; text.length; i++)</p>
			<p class="source-code">    System.out.print(text[i] + " ");</p>
			<p>This would give the following as the result:</p>
			<p class="source-code">buy more spam</p>
			<p>If you want to write your code in a slightly cleaner way, you could import the whole <strong class="source-inline">java.util.Arrays</strong> API at the beginning of your program, which would allow you to call the methods by omitting the <strong class="source-inline">java.util</strong> part of the command. See the following example highlighting this technique:</p>
			<p class="source-code">import java.util.Arrays;</p>
			<p class="source-code">public class Example01 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String[] text = new String[] { "spam", "more", "buy" };</p>
			<p class="source-code">        Arrays.sort(text);</p>
			<p class="source-code">        System.out.println(Arrays.toString(text));</p>
			<p class="source-code">        for (int i = 0; i &lt; text.length; i++)</p>
			<p class="source-code">            System.out.print(text[i] + " ");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The outcome will be:</p>
			<p class="source-code">[buy, more, spam]</p>
			<p class="source-code">buy more spam </p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>If you were to make a new array that you wanted to be filled up with the same data for all cells, there is the possibility of calling the <strong class="source-inline">java.util.Arrays.fill()</strong> method, as shown here:</p>
			<p class="source-code">int[] numbers = new int[5];</p>
			<p class="source-code">Arrays.fill(numbers, 0);</p>
			<p>Such a command would create an array filled with zeros:</p>
			<p class="source-code">[0, 0, 0, 0, 0]</p>
			<p>Creating arrays with prefilled data can also be done with a copy of a preexisting array. It is possible to create an array by copying part of one array, or by instantiating a larger one where the old one would just be part of it. Both methods are shown in the following example, which you can test in your editor:</p>
			<p class="source-code">import java.util.Arrays;</p>
			<p class="source-code">public class Example02 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        int[] numbers = new int[5];</p>
			<p class="source-code">        Arrays.fill(numbers, 1);</p>
			<p class="source-code">        System.out.println(Arrays.toString(numbers));</p>
			<p class="source-code">        int [] shortNumbers = Arrays.copyOfRange(numbers, 0, 2);</p>
			<p class="source-code">        System.out.println(Arrays.toString(shortNumbers));</p>
			<p class="source-code">        int [] longNumbers = Arrays.copyOf(numbers, 10);</p>
			<p class="source-code">        System.out.println(Arrays.toString(longNumbers));</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This example will print the <strong class="source-inline">numbers</strong>, <strong class="source-inline">shortNumbers</strong> (which is shorter), and <strong class="source-inline">longNumbers</strong> (which is longer) arrays. The newly added positions in the array will be filled with zeros. If it was an array of strings, they would be filled up with <strong class="source-inline">null</strong>. The outcome of this example is:</p>
			<p class="source-code">[1, 1, 1, 1, 1]</p>
			<p class="source-code">[1, 1]</p>
			<p class="source-code">[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>You can compare arrays by calling the <strong class="source-inline">java.utils.Arrays.equals()</strong> or <strong class="source-inline">java.util.Arrays.deepEquals()</strong> methods. The difference between them is that the latter can look through nested arrays. A simple comparison example of the former method in use follows:</p>
			<p class="source-code">import java.util.Arrays;</p>
			<p class="source-code">public class Example03 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        int[] numbers1 = new int[3];</p>
			<p class="source-code">        Arrays.fill(numbers1, 1);</p>
			<p class="source-code">        int[] numbers2 = {0, 0, 0};</p>
			<p class="source-code">        boolean comparison = Arrays.equals(numbers1, numbers2);</p>
			<p class="source-code">        System.out.println(comparison);</p>
			<p class="source-code">        int[] numbers3 = {1, 1, 1};</p>
			<p class="source-code">        comparison = Arrays.equals(numbers1, numbers3);</p>
			<p class="source-code">        System.out.println(comparison);</p>
			<p class="source-code">        int[] numbers4 = {1, 1};</p>
			<p class="source-code">        comparison = Arrays.equals(numbers1, numbers4);</p>
			<p class="source-code">        System.out.println(comparison);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we create four arrays: <strong class="source-inline">numbers1</strong>, <strong class="source-inline">numbers2</strong>, <strong class="source-inline">numbers3</strong>, and <strong class="source-inline">numbers4</strong>. Only two of them are the same, containing three instances of <strong class="source-inline">1</strong>. In the example, you can see how the last three arrays are compared to the first one. You can also see how the last array differs not in content, but in size. The outcome of this code is:</p>
			<p class="source-code">false</p>
			<p class="source-code">true</p>
			<p class="source-code">false</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since this chapter is not looking into such a complex data structure as nested arrays, we will not show an example of <strong class="source-inline">java.util.Arrays.deepEquals()</strong>. If you're interested, you should consider checking the Java reference at <a href="https://packt.live/2MuRrNa">https://packt.live/2MuRrNa</a>. </p>
			<p>Searching within arrays is done through different algorithms behind the scenes. It is obviously a lot faster to perform searches on sorted arrays than on unsorted ones. The method to be invoked to run such a search on a sorted array is <strong class="source-inline">Arrays.binarySearch()</strong>. As it has many possible parameter combinations, it is recommended to visit the official documentation for the method. The following example illustrates how it works:</p>
			<p class="source-code">import java.util.Arrays;</p>
			<p class="source-code">public class Example04 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String[] text = {"love","is", "in", "the", "air"};</p>
			<p class="source-code">        int search = Arrays.binarySearch(text, "is");</p>
			<p class="source-code">        System.out.println(search);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This code is going to search for the word <strong class="source-inline">the</strong> inside the array text. The result is:</p>
			<p class="source-code">-4</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>This is wrong! <strong class="source-inline">binarySearch</strong> is an optimized search algorithm within the collections framework, but it is not optimal when used with unsorted arrays. This means that <strong class="source-inline">binarySearch</strong> is mainly very useful for determining whether an object can be found within an array (by sorting it first). At the same time, we will need a different algorithm when we must search through unsorted arrays and when there are multiple occurrences of a value.</p>
			<p>Try the following modification of the previous example:</p>
			<p class="source-code">String[] text = {"love","is", "in", "the", "air"};</p>
			<p class="source-code">Arrays.sort(text);</p>
			<p class="source-code">int search = Arrays.binarySearch(text, "is");</p>
			<p class="source-code">System.out.println(search);</p>
			<p>The outcome, since the array is sorted, will be:</p>
			<p class="source-code">2</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>It is only a coincidence in this case that "<strong class="source-inline">is</strong>" happens to be in the same place in the unsorted and the sorted versions of the array. Making use of the tools you've been learning about, it should be possible for you to create an algorithm that can iterate throughout an array and count all the existing items, even if they are repeated, as well as locating their positions within the array. See <em class="italic">Activity 1</em>,<em class="italic"> Searching for Multiple Occurrences in an Array</em> in this chapter, where we challenge you to write such a program.</p>
			<p>You can also transform objects of the <strong class="source-inline">java.util.Arrays</strong> class into strings with the <strong class="source-inline">Arrays.toString()</strong> method, as we saw at the beginning of this section, into a list with <strong class="source-inline">Arrays.asList()</strong> (we will see this in a later section, as well as in <strong class="source-inline">Example05</strong>) or into a set with <strong class="source-inline">Arrays.setAll()</strong>.</p>
			<p>Arrays and collections play important roles in software development. This section of the chapter dives into the differences between them as well as how they can be used together. If you search the internet for the relationship between these two constructs, most references you find will be focused on the differences, such as:</p>
			<ul>
				<li>Arrays have fixed sizes, while collections have variable sizes.</li>
				<li>Arrays can hold objects of any kind, but also primitives; collections cannot contain primitives.</li>
				<li>Arrays will hold homogeneous elements (elements that are all the same nature), while collections can hold heterogeneous elements.</li>
				<li>Arrays have no underlying data structure, while collections are implemented using standard structures.</li>
			</ul>
			<p>If you know the amount of data you are going to be dealing with, arrays are the preferred tool, mainly because arrays perform better than lists or sets in such cases. However, there will be countless occasions when you don't know the amount of data you will be dealing with, which is where lists will be handy.</p>
			<p>Also, arrays can be used to programmatically populate collections. We will be doing this throughout this chapter as a way of saving you the time of having to manually type all the data that will end up inside a collection, for example. The following example shows how to populate a set using an array: </p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example05 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Integer[] myArray = new Integer[] {3, 25, 2, 79, 2};</p>
			<p class="source-code">        Set mySet = new HashSet(Arrays.asList(myArray));</p>
			<p class="source-code">        System.out.println(mySet);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this program, there is an array of <strong class="source-inline">Integer</strong> used to initialize an object of the <strong class="source-inline">HashSet</strong> class, which is later printed out.</p>
			<p>The outcome of this example is:</p>
			<p class="source-code">[2, 3, 25, 79]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The previous code listing shows a couple of interesting things. First of all, you will notice that the output to the program is sorted; that is because the conversion of the array to a list using <strong class="source-inline">Arrays.asList()</strong> will make the dataset inherit the properties of a list, which means that it will be sorted. Also, since the data has been added to a set and sets do not include duplicates, duplicate number two is left out.</p>
			<p>It is important to note that with collections, you can specify the type to be stored. As such, there would be a difference between the declaration in the previous example, where we displayed a generic declaration, and what follows. The type is declared here using the name given within angle brackets, <strong class="source-inline">&lt;&gt;</strong>. In this case, it is <strong class="source-inline">&lt;Integer&gt;</strong>. You could rewrite the instantiation of the object as follows:</p>
			<p class="source-code">Set&lt;Integer&gt; mySet = new HashSet&lt;Integer&gt;(Arrays.asList(myArray));</p>
			<p>You will see that the result of executing the program will be the same.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Activity 1: Searching for Multiple Occurrences in an Array</h2>
			<p>Write a program that will search for multiple occurrences of a certain word in an array of strings, where each one of the objects is a single word. Use the following array, a famous quote by Frank Zappa, as a point of departure:</p>
			<p class="source-code">String[] text = {"So", "many", "books", "so", "little", "time"};</p>
			<p>The word to search for is <strong class="source-inline">so</strong>. but you will have to consider that it shows up twice and that one instance is not in lowercase. As a hint, the method to compare two strings without looking at the specific casing of any of the letters in them is <strong class="source-inline">text1.compareToIgnoreCase(text2)</strong>. To do so, perform the following steps:</p>
			<ol>
				<li>Create the <strong class="source-inline">text</strong> array.</li>
				<li>Create the variable that contains the word to be searched for: <strong class="source-inline">so</strong></li>
				<li>Initialize the variable <strong class="source-inline">occurrence</strong> to -1.</li>
				<li>Create a for loop to iterate through the array to check for the occurrence. </li>
			</ol>
			<p>That will give the following result:</p>
			<p class="source-code">Found query at: 0</p>
			<p class="source-code">Found query at: 3</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 538.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Sets</h1>
			<p>Sets within the collections framework are the programmatic equivalent of mathematical sets. This means that they can store objects of a specific type while avoiding duplicates. In the same way, sets offer methods that will let you handle data as you would in mathematics. You can add objects to a set, check whether a set is empty, combine the elements of two sets to add all their elements into a single set, see what objects coincide with each other between two sets, and calculate the difference between two sets. </p>
			<p>In the <strong class="source-inline">java.util.Sets</strong> class, we find three interfaces used to represent sets: <strong class="source-inline">HashSet</strong>, <strong class="source-inline">TreeSet</strong>, and <strong class="source-inline">LinkedHashSet</strong>. The differences between them are straightforward:</p>
			<ul>
				<li><strong class="source-inline">HashSet</strong> will store data without guaranteeing the order of iteration.</li>
				<li><strong class="source-inline">TreeSet</strong> orders a set by value.</li>
				<li><strong class="source-inline">LinkedHashSet</strong> orders a set by arrival time.</li>
			</ul>
			<p>Each of these interfaces is meant to be used under specific circumstances. Let's look at a couple of examples of sets, departing from the one in <strong class="source-inline">Example05</strong>, and look at how we can add other methods to check how to operate sets. The first step is populating a set from an array. There are several methods for doing so; let's use the one that is probably the quickest to implement:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example06 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String[] myArray = new String[] {"3", "25", "2", "79", "2"};</p>
			<p class="source-code">        Set mySet = new HashSet();</p>
			<p class="source-code">        Collections.addAll(mySet, myArray);</p>
			<p class="source-code">        System.out.println(mySet);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The above line of code shows how to add all the elements of the array to the set; when printing the results, we get:</p>
			<p class="source-code">[2, 79, 3, 25]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Please note that the order of the resulting print may vary for you. As explained earlier, <strong class="source-inline">HashSet</strong>, because of the way it is implemented, cannot guarantee any sorting of the content. If you performed the following example using <strong class="source-inline">Integer</strong> instead of <strong class="source-inline">String</strong> for the data, it would end up being sorted:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example07 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Integer[] myArray = new Integer[] {3, 25, 2, 79, 2};</p>
			<p class="source-code">        Set mySet = new HashSet();</p>
			<p class="source-code">        Collections.addAll(mySet, myArray);</p>
			<p class="source-code">        System.out.println(mySet);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The result of this program is:</p>
			<p class="source-code">[2, 3, 25, 79]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>This means that the results end up being sorted, even if we don't request it. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The fact that the set in this example is sorted is a mere coincidence. Please be aware that this may not be the case in other situations. <strong class="source-inline">Example08</strong> will show the union operation between two sets, and there the data will not be sorted. </p>
			<p>Working with sets involves working with packages of data and performing operations with them. The union operation for two sets is displayed in the following example:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example08 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Integer[] numbers1 = new Integer[] {3, 25, 2, 79, 2};</p>
			<p class="source-code">        Integer[] numbers2 = new Integer[] {7, 12, 14, 79};</p>
			<p class="source-code">        Set set1 = new HashSet();</p>
			<p class="source-code">        Collections.addAll(set1, numbers1);</p>
			<p class="source-code">        Set set2 = new HashSet();</p>
			<p class="source-code">        Collections.addAll(set2, numbers2);</p>
			<p class="source-code">        set1.addAll(set2);</p>
			<p class="source-code">        System.out.println(set1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This program will print, as its output, the resulting set from the union of the two sets described by the two arrays at the beginning of the main method of the example:</p>
			<p class="source-code">[2, 3, 7, 25, 12, 14, 79]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Besides <strong class="source-inline">HashSet</strong>, we also find <strong class="source-inline">TreeSet</strong>, and here is where data will be sorted by value. Let's simply change the types of the sets in the previous example and see the result:</p>
			<p class="source-code">Set set1 = new TreeSet();</p>
			<p class="source-code">Collections.addAll(set1, numbers1);</p>
			<p class="source-code">Set set2 = new TreeSet();</p>
			<p class="source-code">Collections.addAll(set2, numbers2);</p>
			<p>This, when changed in the previous example, will give the following sorted set as a result:</p>
			<p class="source-code">[2, 3, 7, 12, 14, 25, 79]</p>
			<p>You might be wondering about the pros and cons of using each type of set. When sorting, you are trading speed for tidiness. Therefore, if you are working with large sets of data and speed is a concern, you will have to decide whether it is more convenient to have the system operate faster, or have the results sorted, which would allow faster binary searches through the dataset.</p>
			<p>Given this last modification, we could perform other operations with the data, such as the intersection operation, which is invoked with the <strong class="source-inline">set1.retainAll(set2)</strong> method. Let's see it in action:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example09 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Integer[] numbers1 = new Integer[] {3, 25, 2, 79, 2};</p>
			<p class="source-code">        Integer[] numbers2 = new Integer[] {7, 12, 14, 79};</p>
			<p class="source-code">        Set set1 = new TreeSet();</p>
			<p class="source-code">        Collections.addAll(set1, numbers1);</p>
			<p class="source-code">        Set set2 = new TreeSet();</p>
			<p class="source-code">        Collections.addAll(set2, numbers2);</p>
			<p class="source-code">        set1.retainAll(set2);</p>
			<p class="source-code">        System.out.println(set1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>For the output, given that the arrays are used to populate the arrays, we will get only those numbers that exist in both arrays; in this case, it is just the number <strong class="source-inline">79</strong>:</p>
			<p class="source-code">[79]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The third type of set, <strong class="source-inline">LinkedHashSet</strong>, will sort the objects in order of their arrival. To demonstrate this behavior, let's make a program that will add elements to the set one by one using the <strong class="source-inline">set.add(element)</strong> command.</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example10 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Set set1 = new LinkedHashSet();</p>
			<p class="source-code">        set1.add(35);</p>
			<p class="source-code">        set1.add(19);</p>
			<p class="source-code">        set1.add(11);</p>
			<p class="source-code">        set1.add(83);</p>
			<p class="source-code">        set1.add(7);</p>
			<p class="source-code">        System.out.println(set1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When running this example, the result will be sorted by the way the data arrived in the set:</p>
			<p class="source-code">[35, 19, 11, 83, 7]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>For the sake of experimentation, use the next 2 minutes to chalk out the set construction into <strong class="source-inline">HashSet</strong> once more:</p>
			<p class="source-code">Set set1 = new LinkedHashSet();</p>
			<p>The result of this modified program is uncertain. For example, we get:</p>
			<p class="source-code">[35, 19, 83, 7, 11]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>This is, again, an unsorted version of the same set of data.</p>
			<p>To close our explanation of the possible methods that you can use with sets, let's use <strong class="source-inline">LinkedHashSet</strong> to run an experiment where we will find the difference between two sets.</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example11 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Set set1 = new LinkedHashSet();</p>
			<p class="source-code">        set1.add(35);</p>
			<p class="source-code">        set1.add(19);</p>
			<p class="source-code">        set1.add(11);</p>
			<p class="source-code">        set1.add(83);</p>
			<p class="source-code">        set1.add(7);</p>
			<p class="source-code">        Set set2 = new LinkedHashSet();</p>
			<p class="source-code">        set2.add(3);</p>
			<p class="source-code">        set2.add(19);</p>
			<p class="source-code">        set2.add(11);</p>
			<p class="source-code">        set2.add(0);</p>
			<p class="source-code">        set2.add(7);</p>
			<p class="source-code">        set1.removeAll(set2);</p>
			<p class="source-code">        System.out.println(set1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this case, both sets are slightly different, and by determining the difference, the algorithm behind <strong class="source-inline">set1.removeAll(set2)</strong> will look for the occurrences of each item in <strong class="source-inline">set2</strong> within <strong class="source-inline">set1</strong> and eliminate them. The result of this program is:</p>
			<p class="source-code">[35, 83]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Finally, if you just want to check whether the whole of a set is contained within another set, you can call the <strong class="source-inline">set1.containsAll(set2)</strong> method. We'll leave that for you to explore – just be aware that the method simply responds with a Boolean stating whether the statement is true or false. </p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Lists</h1>
			<p>Lists are ordered collections of data. Unlike sets, lists can have repeated data. Having data contained within lists allows you to perform searches that will give the locations of certain objects within a given list. Given a position, it is possible to directly access an item in a list, add new items, remove items, and even add full lists. Lists are sequential, which makes them easy to navigate using iterators, a feature that will be explored in full in a later section in the chapter. There are also some methods for performing range-based operations on sublists.</p>
			<p>There are two different list implementations: <strong class="source-inline">ArrayList</strong> and <strong class="source-inline">LinkedList</strong>. Each of them is ideal depending on the circumstances. Here, we will work with <strong class="source-inline">ArrayList</strong> mainly. Let's start by creating and populating an instance, then search for a certain value, and given its location within the list, we'll print out the value.</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example12 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        List list = new ArrayList();</p>
			<p class="source-code">        list.add(35);</p>
			<p class="source-code">        list.add(19);</p>
			<p class="source-code">        list.add(11);</p>
			<p class="source-code">        list.add(83);</p>
			<p class="source-code">        list.add(7);</p>
			<p class="source-code">        System.out.println(list);</p>
			<p class="source-code">        int index = list.indexOf(19);</p>
			<p class="source-code">        System.out.println("Find 19 at: " + index);</p>
			<p class="source-code">        System.out.println("Component: " + list.get(index));</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The output of this example is:</p>
			<p class="source-code">[35, 19, 11, 83, 7]</p>
			<p class="source-code">Find 19 at: 1</p>
			<p class="source-code">Component: 19</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The <strong class="source-inline">indexOf</strong> method informs you about the location of an object passed to the method as a parameter. It's sibling method, <strong class="source-inline">lastIndexOf</strong>, reports the location of the last occurrence of an object in the list.</p>
			<p>You should look at a list as a series of nodes connected by links. If one of the nodes is eliminated, the link that used to point to it will be redirected to the following item in the list. When adding nodes, they will be attached by default at the end of the list (if they are not duplicated). As all the nodes in the collection are of the same type, it should be possible to exchange the locations of two nodes in a list.</p>
			<p>Let's experiment with removing an item from a list and ascertaining the locations for objects located immediately before and after the removed item:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example13 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        List list = new ArrayList();</p>
			<p class="source-code">        list.add(35);</p>
			<p class="source-code">        list.add(19);</p>
			<p class="source-code">        list.add(11);</p>
			<p class="source-code">        list.add(83);</p>
			<p class="source-code">        list.add(7);</p>
			<p class="source-code">        System.out.println(list);</p>
			<p class="source-code">        int index = list.lastIndexOf(83);</p>
			<p class="source-code">        System.out.println("Before: find 83 at: " + index);</p>
			<p class="source-code">        list.remove(index - 1);</p>
			<p class="source-code">        System.out.println(list);</p>
			<p class="source-code">        index = list.lastIndexOf(83);</p>
			<p class="source-code">        System.out.println("After: find 83 at: " + index);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This program creates a list, prints it out, looks for a node in the list, and prints its location. Then, it removes an item in the list and repeats the previous process to show that the node has been removed from the list. This is a clear difference from the case with arrays, where it is not possible to remove items from them, and thus it is not possible to change their size. Observe the output of the previous example:</p>
			<p class="source-code">[35, 19, 11, 83, 7]</p>
			<p class="source-code">Before: find 83 at: 3</p>
			<p class="source-code">[35, 19, 83, 7]</p>
			<p class="source-code">After: find 83 at: 2</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>It is also possible to change the content of a node. In the previous example, instead of removing a node, change <strong class="source-inline">list.remove(index-1);</strong> to the following and check the outcome:</p>
			<p class="source-code">list.set(index - 1, 99); </p>
			<p>The final array will have substituted <strong class="source-inline">11</strong> for <strong class="source-inline">99</strong>.</p>
			<p>If instead of deleting one node, you wanted to empty the whole list, the command to the issue would be:</p>
			<p class="source-code">list.clear();</p>
			<p>Using <strong class="source-inline">subList()</strong>, an operator that generates lists from lists, it is possible to, for example, delete a range of cells within a list. See the following example, which deletes part of a string array, changing its meaning when printing it:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example14 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        List list = new ArrayList();</p>
			<p class="source-code">        list.add("No");</p>
			<p class="source-code">        list.add("matter");</p>
			<p class="source-code">        list.add("what");</p>
			<p class="source-code">        list.add("you");</p>
			<p class="source-code">        list.add("do");</p>
			<p class="source-code">        System.out.println(list);</p>
			<p class="source-code">        list.subList(2,4).clear();</p>
			<p class="source-code">        System.out.println(list);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Look at the following result:</p>
			<p class="source-code">[No, matter, what, you, do]</p>
			<p class="source-code">[No, matter, do]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The <strong class="source-inline">list</strong> object has been modified by running the example code so that it becomes shorter. The two index numbers used in the <strong class="source-inline">subList()</strong> method is the places in the list where the method starts and stops. The result of <strong class="source-inline">subList()</strong> can also be assigned to a different variable of the same <strong class="source-inline">List</strong> type, resulting in a reduced copy of the list in the code, after performing the <strong class="source-inline">subList()</strong> operation.</p>
			<p>Look at the following modification in the latest code listing:</p>
			<p class="source-code">List list1 = list.subList(2,4);</p>
			<p class="source-code">System.out.println(list1);</p>
			<p>This will print out the list that was made of the nodes that were deleted in the previous example.</p>
			<p>There are a lot of interesting algorithms within the collections framework that offers relevant functionality for operating with lists:</p>
			<ul>
				<li><strong class="source-inline">sort</strong>: Put the elements of a list in a certain order.</li>
				<li><strong class="source-inline">shuffle</strong>: Randomize the locations of all objects in a list.</li>
				<li><strong class="source-inline">reverse</strong>: Invert the order of a list.</li>
				<li><strong class="source-inline">rotate</strong>: Move objects to the end of a list, and when they reach the end, have them show up at the other end.</li>
				<li><strong class="source-inline">swap</strong>: Swap two elements with one another.</li>
				<li><strong class="source-inline">replaceAll</strong>: Replace all occurrences of an element in a list using a parameter.</li>
				<li><strong class="source-inline">fill</strong>: Fill the content of a list with one value.</li>
				<li><strong class="source-inline">copy</strong>: Make more instances of a list.</li>
				<li><strong class="source-inline">binarySearch</strong>: Perform optimized searches within a list.</li>
				<li><strong class="source-inline">indexOfSubList</strong>: Search for the occurrence of a piece (a set of consecutive nodes) of a list.</li>
				<li><strong class="source-inline">lastIndexOfSubList</strong>: Search for the last occurrence of a piece of a list.<p class="callout-heading">Note</p><p class="callout">Lists generated from arrays using <strong class="source-inline">Arrays.asList()</strong> do not behave in the same way as the objects of the <strong class="source-inline">List</strong> class described in this section. The lists coming from arrays have a fixed length, which means that elements cannot be removed from the array. The reason for this is that <strong class="source-inline">java.util.Arrays</strong> implement its own <strong class="source-inline">ArrayList</strong> class inside the package, one that is different from the one in the collections framework. Confusing, isn't it?</p></li>
			</ul>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Exercise 1: Creating the AnalyzeInput Application</h2>
			<p>In this exercise, we will create a new application that will respond to the CLI by storing whatever strings are provided to it, then run some statistical operations on the data, such as word counting (determining the most frequent word or the most frequent letter, and so on). The intent is to give you an idea of how to use the collections framework instead of other tools to do such operations. This time, we will do something special; instead of getting the data from the CLI as arguments to the script, we will use the <strong class="source-inline">java.io.Console</strong> API, which allows the reading of different types of strings from the terminal, such as usernames (plain strings) and passwords. The goal of this application is to read the input until a line with only the "<strong class="source-inline">*</strong>" symbol (asterisk) is captured. Once the termination symbol is entered, the text will be processed, and the statistics will be delivered to the terminal:</p>
			<ol>
				<li value="1">Open IntelliJ and create a new Java program using the CLI template. Name the project <strong class="source-inline">AnalyzeInput</strong>.</li>
				<li>Start by creating a simple program that can read a line from the terminal and printing it out:<p class="source-code">import java.io.Console;</p><p class="source-code">public class AnalyzeInput {</p><p class="source-code">  public static void main(String[] args) {</p><p class="source-code">    Console cons;</p><p class="source-code">    String line = "";</p><p class="source-code">      if ((cons = System.console()) != null &amp;&amp; (line = cons.readLine()) !=         null) {</p><p class="source-code">      System.out.println("You typed: " + line);</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Execute the program from the CLI by calling <strong class="source-inline">java AnalyzeInput</strong> from the right folder and interact with it:<p class="source-code">usr@localhost:~/IdeaProjects/ch04/out/production/ch04$ java AnalyzeInput </p><p class="source-code">hej this is an example</p><p class="source-code">You typed: hej this is an example</p></li>
				<li>You must import <strong class="source-inline">java.io.Console</strong>, which allows you to instantiate objects of the <strong class="source-inline">Console</strong> class. You can also see the call to <strong class="source-inline">cons = System.console()</strong>, which will make sure that the terminal is ready for you to read the data, and <strong class="source-inline">line = cons.readLine()</strong>, which will ensure that when hitting the <em class="italic">Enter</em> key on the keyboard, the resulting data is not empty. </li>
				<li>The next step is storing the data we are capturing in a collection. Since we don't know the size this could be, we should be using <strong class="source-inline">ArrayList &lt;String&gt;</strong> to store the data. Also, to store data for as long as we want, we can modify the <strong class="source-inline">if</strong> statement and make it into a <strong class="source-inline">while</strong> loop. Finally, use the <strong class="source-inline">add</strong> method to add the lines into a list (note that the following code listing will never exit, so bear with us and do not execute it yet):<p class="source-code">import java.util.*;</p><p class="source-code">import java.io.Console;</p><p class="source-code">public class Exercise01 {</p><p class="source-code">  public static void main(String[] args) {</p><p class="source-code">    ArrayList &lt;String&gt; text = new ArrayList&lt;String&gt;();</p><p class="source-code">    Console cons;</p><p class="source-code">    String line = "";</p><p class="source-code">    while ((cons = System.console()) != null &amp;&amp; (line = cons.readLine())       != null) {</p><p class="source-code">    text.add(line);</p><p class="source-code">    }</p><p class="source-code">    System.out.println("You typed: " + text);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Modify the <strong class="source-inline">while</strong> loop to include the condition we established for finishing the data capture process – the arrival of a line with only an asterisk symbol:<p class="source-code">        while (!line.equals("*") </p><p class="source-code">            &amp;&amp; (cons = System.console()) != null </p><p class="source-code">            &amp;&amp; (line = cons.readLine()) != null) {</p></li>
				<li>The outcome will happen only when you type the asterisk symbol alone in a line, as seen in this log while interacting with the program:<p class="source-code">usr@localhost:~/IdeaProjects/ch04/out/production/ch04$ java AnalyzeInput </p><p class="source-code">this is the array example</p><p class="source-code">until you type *</p><p class="source-code">alone in a line</p><p class="source-code">*</p><p class="source-code">You typed: [this is the array example, until you type *, alone in a line, *]</p></li>
				<li>Since we used <strong class="source-inline">ArrayList</strong> to store the different strings, you could be typing until you exhaust the computer's memory. Now it is possible to execute some commands to work with the strings. The first step will be turning the whole of the text into a list. This will require going through the different strings and splitting them into parts that will be added to a larger list. The easiest trick is to use the <strong class="source-inline">split()</strong> method using a whitespace character as a separator. Modify the <strong class="source-inline">main</strong> method to look like the following, and you will see that the result is now a list with all the words separated as single nodes in the list:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        ArrayList &lt;String&gt; text = new ArrayList&lt;String&gt;();</p><p class="source-code">        Console cons;</p><p class="source-code">        String line = "";</p><p class="source-code">        while (!line.equals("*")</p><p class="source-code">            &amp;&amp; (cons = System.console()) != null</p><p class="source-code">            &amp;&amp; (line = cons.readLine()) != null) {</p><p class="source-code">                List&lt;String&gt; lineList = new                   ArrayList&lt;String&gt;(Arrays.asList(line.split(" ")));</p><p class="source-code">            text.addAll(lineList);</p><p class="source-code">        }</p><p class="source-code">        System.out.println("You typed: " + text);</p><p class="source-code">    }</p></li>
				<li>Having all the data stored in this way allows for the use of a lot of the methods available in the collections framework that will let you do operations with data. Let's start by counting all the words in the text (including the closing symbol, "<strong class="source-inline">*</strong>"). Just add the following at the end of the <strong class="source-inline">main</strong> method: <p class="source-code">System.out.println("Word count: " + text.size());</p></li>
			</ol>
			<p>The result of this exercise is a program that is ready to be used for further analysis of the data. But in order to continue doing so, we need to make use of a tool that has not yet been introduced—the iterator. We will come back to this example later in the chapter and finish off the application by adding some extra functionality to it.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Maps</h1>
			<p>The collections framework offers one more interface, <strong class="source-inline">java.util.Map</strong>, which can be used when dealing with data that is stored as key-value pairs. This type of data storage is becoming more and more relevant as data formats such as JSON are slowly taking over the internet. JSON is a data format that is based on having data stored in the form of nested arrays that always respond to the key-value structure.</p>
			<p>Having data organized in this way offers the possibility of having a very simple way to look for data – by means of the keys instead of using, for example, an index, as we would do in an array. Keys are the way we can identify the block of data we are looking for within a map. Let's look at a simple example of a map before looking at alternatives to maps:</p>
			<p>The following example shows how to create a simple map and how to print some messages based on the information available within it. The first thing that you will notice in comparison to other interfaces in the collections framework is that we do not <em class="italic">add</em> elements to the map – we <em class="italic">put</em> elements in the map. Also, elements have two parts: the <strong class="bold">key</strong> (in our case, we are using strings) and the <strong class="bold">value</strong> (which can be heterogeneous in nature):</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example15 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Map map = new HashMap();</p>
			<p class="source-code">        map.put("number", new Integer(1));</p>
			<p class="source-code">        map.put("text", new String("hola"));</p>
			<p class="source-code">        map.put("decimal", new Double(5.7));</p>
			<p class="source-code">        System.out.println(map.get("text"));</p>
			<p class="source-code">        if (!map.containsKey("byte")) {</p>
			<p class="source-code">            System.out.println("There are no bytes here!");</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This program will give the following result:</p>
			<p class="source-code">hola</p>
			<p class="source-code">There are no bytes here!</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Since there is no key named "<strong class="source-inline">bytes</strong>" in the code, the <strong class="source-inline">maps.containsKey()</strong> method will answer accordingly, and the program will inform the user about it. The main methods available in this interface are:</p>
			<ul>
				<li><strong class="source-inline">put</strong> (Object key, Object value)</li>
				<li><strong class="source-inline">putAll</strong> (Map map)</li>
				<li><strong class="source-inline">remove</strong> (Object key)</li>
				<li><strong class="source-inline">get</strong> (Object key)</li>
				<li><strong class="source-inline">containsKey</strong> (Object key)</li>
				<li><strong class="source-inline">keySet()</strong></li>
				<li><strong class="source-inline">entrySet()</strong></li>
			</ul>
			<p>All but the last two are self-explanatory. Let's focus on augmenting our previous example to see what those two methods do. Make the following addition to the code to see what <strong class="source-inline">keySet()</strong> and <strong class="source-inline">entrySet()</strong> have to offer:</p>
			<p class="source-code">System.out.println(map.entrySet());</p>
			<p class="source-code">System.out.println(map.keySet());</p>
			<p>The outcome of the modified code listing will be:</p>
			<p class="source-code">hola</p>
			<p class="source-code">There are no bytes here!</p>
			<p class="source-code">[number=1, text=hola, decimal=5.7]</p>
			<p class="source-code">[number, text, decimal]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>In other words, <strong class="source-inline">entrySet()</strong> will print the whole map using the key = value formula, while <strong class="source-inline">keySet()</strong> will respond with the set of keys within the map.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might have realized this by now: keys must be unique – there cannot be two of the same keys in a map. </p>
			<p>We will not go deeper into maps at this point because they are, to an extent, a repetition of what we saw with sets. There are three different classes for maps: <strong class="source-inline">HashMap</strong>, <strong class="source-inline">TreeMap</strong>, and <strong class="source-inline">LinkedHashMap</strong>. The last two are put in order, while the first one is neither sorted nor arranged in order of arrival. You should use these classes according to your needs. </p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Iterating through Collections</h1>
			<p>Earlier in this chapter, when working with <em class="italic">Exercise 01, Creating the AnalyzeInput Application</em> we stopped when we were about to make searches through the data. We made it to the point where we had to iterate through the data and look for characteristics such as word frequency. </p>
			<p>Iterators are used in Java to browse through collections. Let's look at a simple example that involves extracting the elements from a simple list one by one and printing them out.</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example16 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        List array = new ArrayList();</p>
			<p class="source-code">        array.add(5);</p>
			<p class="source-code">        array.add(2);</p>
			<p class="source-code">        array.add(37);</p>
			<p class="source-code">        Iterator iterator = array.iterator();</p>
			<p class="source-code">        while (iterator.hasNext()) {</p>
			<p class="source-code">            //  point to next element</p>
			<p class="source-code">            int i = (Integer) iterator.next();</p>
			<p class="source-code">            // print elements</p>
			<p class="source-code">            System.out.print(i + " ");</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The output of this program is:</p>
			<p class="source-code">5 2 37 </p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Iterators such as this one are the most generic ones in the collections framework and can be used with lists, sets, queues, and even maps. There are other less-broad implementations of the iterators that allow for different ways to browse through data, for example, in lists. As you saw in the latest code listing, the <strong class="source-inline">iterator.hasNext()</strong> method checks whether there is a node after the one we are at in the list. When starting the iterator, the object points to the first element in the list. Then, <strong class="source-inline">hasNext()</strong> responds with a Boolean stating whether there are more nodes hanging from it. The <strong class="source-inline">iterator.next()</strong> method will move the iterator to the following node in the collection. This kind of iterator does not have the possibility of going back in the collection; it can only move forward. There is one final method in the iterator, called <strong class="source-inline">remove()</strong>, which will eliminate the current element that the iterator is pointing to from the collection.</p>
			<p>If we used <strong class="source-inline">listIterator()</strong> instead, we would have had a lot more options for navigating collections, such as adding new elements and changing elements. The following code listing demonstrates how to go through a list, add elements, and modify them. <strong class="source-inline">listIterator</strong> works only with lists:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example17 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        List &lt;Double&gt; array = new ArrayList();</p>
			<p class="source-code">        array.add(5.0);</p>
			<p class="source-code">        array.add(2.2);</p>
			<p class="source-code">        array.add(37.5);</p>
			<p class="source-code">        array.add(3.1);</p>
			<p class="source-code">        array.add(1.3);</p>
			<p class="source-code">        System.out.println("Original list: " + array);</p>
			<p class="source-code">        ListIterator listIterator = array.listIterator();</p>
			<p class="source-code">        while (listIterator.hasNext()) {</p>
			<p class="source-code">            //  point to next element</p>
			<p class="source-code">            double d = (Double) listIterator.next();</p>
			<p class="source-code">            // round up the decimal number</p>
			<p class="source-code">            listIterator.set(Math.round(d));</p>
			<p class="source-code">        }</p>
			<p class="source-code">        System.out.println("Modified list: " + array);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we create a list of <strong class="source-inline">Double</strong>, iterate through the list, and round up each of the numbers. The outcome of this program is:</p>
			<p class="source-code">Original list: [5.0, 2.2, 37.5, 3.1, 1.3]</p>
			<p class="source-code">Modified list: [5, 2, 38, 3, 1]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>By calling <strong class="source-inline">listIterator.set()</strong>, we modify each of the items in the list and the second <strong class="source-inline">System.out.println()</strong> command shows where the numbers have been rounded up or down. </p>
			<p>The final iterator example we are going to see in this section is a trick to iterate through a map. This could come in handy in scenarios where you want to perform some operations on data within a map. By using the <strong class="source-inline">entrySet()</strong> method – which returns a list – it is possible to have an iterator over a map. See the following example to understand how this works:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class AnalyzeInput {</p>
			<p class="source-code">     public static void main(String[] args) {</p>
			<p class="source-code">        Map map = new HashMap ();</p>
			<p class="source-code">        map.put("name", "Kristian");</p>
			<p class="source-code">        map.put("family name", "Larssen");</p>
			<p class="source-code">        map.put("address", "Jumping Rd");</p>
			<p class="source-code">        map.put("mobile", "555-12345");</p>
			<p class="source-code">        map.put("pet", "cat");</p>
			<p class="source-code">        Iterator &lt;Map.Entry&gt; iterator = map.entrySet().iterator();</p>
			<p class="source-code">        while (iterator.hasNext()) {</p>
			<p class="source-code">            Map.Entry entry = iterator.next();</p>
			<p class="source-code">            System.out.print("Key = " + entry.getKey());</p>
			<p class="source-code">            System.out.println( ", Value = " + entry.getValue());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This program will iterate through a map and print the contents as they were stored in <strong class="source-inline">HashMap</strong>. Remember that these types of objects are not sorted in any specific way. You can expect an output like the following:</p>
			<p class="source-code">Key = address, Value = Jumping Rd</p>
			<p class="source-code">Key = family name, Value = Larssen</p>
			<p class="source-code">Key = name, Value = Kristian</p>
			<p class="source-code">Key = mobile, Value = 555-12345</p>
			<p class="source-code">Key = pet, Value = cat</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Given that we now have ways to iterate through collections, we can move on to an exercise that picks up where we left off: iterating through a list for data analysis.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Exercise 2: Bringing Analytics into the AnalyzeInput Application</h2>
			<p>We are going to start from where we left off at the end of <em class="italic">Exercise 1</em>, <em class="italic">Creating the AnalyzeInput Application</em>. We managed to capture the text typed in the terminal and store it as a list of strings. This time, we are going to use a method from the collections framework called <strong class="source-inline">frequency</strong>, which will respond with the number of times a certain object can be found inside a list. As words could be repeated in a sentence, we first need to figure out a way to extract the unique elements in a list:</p>
			<ol>
				<li value="1">Sets are objects in the collections framework that keep only one copy of each element. We saw an example of this earlier in the chapter. We will create a <strong class="source-inline">HashSet</strong> instance and copy all the elements from the list into it. This will automatically eliminate duplicates:<p class="source-code">Set &lt;String&gt; textSet = new HashSet &lt;String&gt; ();</p><p class="source-code">textSet.addAll(text);</p></li>
				<li>The next step, now that we have the set, is to create an iterator that will check how many copies of each element from the set can be found in the list:<p class="source-code">Iterator iterator = textSet.iterator();</p></li>
				<li>Using the same technique that we saw in previous examples for how to iterate through a set, we will find the next node in the set and check in the list for the frequency of the string stored in the node:<p class="source-code">while (iterator.hasNext()) {</p><p class="source-code">    //point to next element</p><p class="source-code">    String s = (String) iterator.next();</p><p class="source-code">    // get the amount of times this word shows up in the text</p><p class="source-code">    int freq = Collections.frequency(text, s);</p><p class="source-code">    // print out the result</p><p class="source-code">    System.out.println(s + " appears " + freq + " times");</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">The final code can be referred at: <a href="https://packt.live/2BrplvS">https://packt.live/2BrplvS</a>.</p></li>
				<li>The outcome will depend on the kind of text you type. For the sake of testing, try the following (we will stick to this data entry for the rest of the chapter – you can copy and paste it to the terminal each time you call the application):<p class="source-code">this is a test</p><p class="source-code">is a test</p><p class="source-code">test is this</p><p class="source-code">*</p></li>
				<li>The full outcome of this input will be:<p class="source-code">You typed: [this, is, a, test, is, a, test, test, is, this, *]</p><p class="source-code">Word count: 11</p><p class="source-code">a appears 2 times</p><p class="source-code">test appears 3 times</p><p class="source-code">this appears 2 times</p><p class="source-code">is appears 3 times</p><p class="source-code">* appears 1 times</p><p>While the result is correct, it is not easy to read through. Ideally, results should be sorted. For example, by descending values of frequency, so that it is easy to see at a glance the most and least frequent words. This is the time to make yet another stop in the exercise as we need to introduce the idea of sorting before we move on with it.</p></li>
			</ol>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Sorting Collections</h1>
			<p>As we have seen, there are some classes in the collections framework that force the items within them to be sorted. Examples of that are <strong class="source-inline">TreeSet</strong> and <strong class="source-inline">TreeMap</strong>. The aspect to explore in this section is how to use existing sorting mechanisms for lists, but also for cases that have datasets with more than one value per data point.</p>
			<p>The exercise we are doing throughout this chapter is a good example of a case where there are data points with more than one value. For each data point, we need to store the word for which we are calculating the frequency and the frequency itself. You might think that a good technique to sort that out is by storing the information in the form of maps. The unique words could be the keys, while the frequencies could be the values. This could be achieved by modifying the final part of the previous program to look like this:</p>
			<p class="source-code">Map map = new HashMap();</p>
			<p class="source-code">while (iterator.hasNext()) {</p>
			<p class="source-code">    //  point to next element</p>
			<p class="source-code">    String s = (String) iterator.next();</p>
			<p class="source-code">    // get the amount of times this word shows up in the text</p>
			<p class="source-code">    int freq = Collections.frequency(text, s);</p>
			<p class="source-code">    // print out the result</p>
			<p class="source-code">    System.out.println(s + " appears " + freq + " times");</p>
			<p class="source-code">    // add items to the map</p>
			<p class="source-code">    map.put(s, freq);</p>
			<p class="source-code">}</p>
			<p class="source-code">TreeMap mapTree = new TreeMap();</p>
			<p class="source-code">mapTree.putAll(map);</p>
			<p class="source-code">System.out.println(mapTree);</p>
			<p>While this is an interesting and simple approach to sorting (copying the data into a structure that is sorted by nature), it presents the problem that data is sorted by key and not by value, as the following result of the previous code highlights:</p>
			<p class="source-code">Word count: 11</p>
			<p class="source-code">a appears 2 times</p>
			<p class="source-code">test appears 3 times</p>
			<p class="source-code">this appears 2 times</p>
			<p class="source-code">is appears 3 times</p>
			<p class="source-code">* appears 1 times</p>
			<p class="source-code">{*=1, a=2, is=3, test=3, this=2}</p>
			<p>So, if we want to sort these results by value, we need to figure out a different strategy.</p>
			<p>But let's step back for a second and analyze what tools are offered in the collections framework for sorting. There is a method called <strong class="source-inline">sort()</strong> that can be used to sort lists. An example of this is as follows:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example19 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        List &lt;Double&gt; array = new ArrayList();</p>
			<p class="source-code">        array.add(5.0);</p>
			<p class="source-code">        array.add(2.2);</p>
			<p class="source-code">        array.add(37.5);</p>
			<p class="source-code">        array.add(3.1);</p>
			<p class="source-code">        array.add(1.3);</p>
			<p class="source-code">        System.out.println("Original list: " + array);</p>
			<p class="source-code">        Collections.sort(array);</p>
			<p class="source-code">        System.out.println("Modified list: " + array);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The result of this program is:</p>
			<p class="source-code">Original list: [5.0, 2.2, 37.5, 3.1, 1.3]</p>
			<p class="source-code">Modified list: [1.3, 2.2, 3.1, 5.0, 37.5]</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Given a list, we could sort it this way just fine; it would even be possible to navigate through it backward using <strong class="source-inline">listIterator</strong> to sort a list in descending order. However, these methods do not solve the issue of sorting data points with multiple values. In such a case, we would need to create a class to store our own key-value pair. Let's see how to implement this by continuing with the exercise we have been dealing with throughout the chapter.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Exercise 3: Sort the Results from the AnalyzeInput Application</h2>
			<p>We now have a program that, given some input text, identifies some basic characteristics of the text, such as the number of words in the text or the frequency of each of the words. Our goal is to be able to sort the results in descending order to make them easier to read. The solution will require the implementation of a class that will store our key-value pairs and make a list of objects from that class:</p>
			<ol>
				<li value="1">Create a class containing the two data points: the word and its frequency. Implement a constructor that will take values and pass them to class variables. This will simplify the code later:<p class="source-code">class DataPoint {</p><p class="source-code">    String key = "";</p><p class="source-code">    Integer value = 0;</p><p class="source-code">    // constructor</p><p class="source-code">    DataPoint(String s, Integer i) {</p><p class="source-code">        key = s;</p><p class="source-code">        value = i;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>When calculating the frequency for each word, store the results in a newly created list of objects of the new class:<p class="source-code">        List &lt;DataPoint&gt; frequencies = new ArrayList &lt;DataPoint&gt; ();</p><p class="source-code">        while (iterator.hasNext()) {</p><p class="source-code">        //point to next element</p><p class="source-code">        String s = (String) iterator.next();</p><p class="source-code">        // get the amount of times this word shows up in the text</p><p class="source-code">        int freq = Collections.frequency(text, s);</p><p class="source-code">        // print out the result</p><p class="source-code">        System.out.println(s + " appears " + freq + " times");</p><p class="source-code">        // create the object to be stored</p><p class="source-code">        DataPoint datapoint = new DataPoint (s, freq);</p><p class="source-code">        // add datapoints to the list</p><p class="source-code">        frequencies.add(datapoint);</p><p class="source-code">    }</p></li>
				<li>Sorting is going to require the creation of a new class using the <strong class="source-inline">Comparator</strong> interface, which we are just introducing now. This interface should implement a method that will be used to run comparisons within the objects in the array. This new class must implement <strong class="source-inline">Comparator &lt;DataPoint&gt;</strong> and include a single method called <strong class="source-inline">compare()</strong>. It should have two objects of the class being sorted as parameters:<p class="source-code">class SortByValue implements Comparator&lt;DataPoint&gt;</p><p class="source-code">{</p><p class="source-code">    // Used for sorting in ascending order</p><p class="source-code">    public int compare(DataPoint a, DataPoint b)</p><p class="source-code">    {</p><p class="source-code">        return a.value - b.value;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The way we call the <strong class="source-inline">Collections.sort()</strong> algorithm using this new comparator is by adding an object of that class as a parameter to the <strong class="source-inline">sort</strong> method. We instantiate it directly in the call:<p class="source-code">Collections.sort(frequencies,new SortByValue());</p></li>
				<li>This will sort the frequencies list in ascending order. To print the results, it is no longer valid to make a direct call to <strong class="source-inline">System.out.println(frequencies)</strong> because it is now an array of objects and it will not print the contents of the data points to the terminal. Iterate through the list in the following way instead:<p class="source-code">System.out.println("Results sorted");</p><p class="source-code">for (int i = 0; i &lt; frequencies.size(); i++)</p><p class="source-code">    System.out.println(frequencies.get(i).value</p><p class="source-code">                    + " times for word "</p><p class="source-code">                    + frequencies.get(i).key);</p></li>
				<li>If you run the program using the same input that we have been using for the last couple of examples, the outcome will be:<p class="source-code">Results sorted</p><p class="source-code">1 times for word *</p><p class="source-code">2 times for word a</p><p class="source-code">2 times for word this</p><p class="source-code">3 times for word test</p><p class="source-code">3 times for word is</p></li>
				<li>Our goal is to sort the results in descending order and, to do that, we will need to add one more thing to the call to the <strong class="source-inline">sort</strong> algorithm. When instantiating the <strong class="source-inline">SortByValue()</strong> class, we need to tell the compiler that we want the list to be sorted in reverse order. The collections framework already has a method for this:<p class="source-code">Collections.sort(frequencies, Collections.reverseOrder(new SortByValue()));</p><p class="callout-heading">Note</p><p class="callout">For the sake of clarity, the final code can be referred at: <a href="https://packt.live/2W5qhzP">https://packt.live/2W5qhzP</a>.</p></li>
				<li>A full interaction path with this program, from the moment we call it to include the data entry, would be as follows:<p class="source-code">user@localhost:~/IdeaProjects/ch04/out/production/ch04$ java AnalyzeInput </p><p class="source-code">this is a test</p><p class="source-code">is a test</p><p class="source-code">test is this</p><p class="source-code">*</p><p class="source-code">You typed: [this, is, a, test, is, a, test, test, is, this, *]</p><p class="source-code">Word count: 11</p><p class="source-code">a appears 2 times</p><p class="source-code">test appears 3 times</p><p class="source-code">this appears 2 times</p><p class="source-code">is appears 3 times</p><p class="source-code">* appears 1 times</p><p class="source-code">Results sorted</p><p class="source-code">3 times for word test</p><p class="source-code">3 times for word is</p><p class="source-code">2 times for word a</p><p class="source-code">2 times for word this</p><p class="source-code">1 times for word *</p></li>
			</ol>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Properties</h1>
			<p>Properties in the collections framework are used to maintain lists of key-value pairs where both are of the <strong class="source-inline">String</strong> class. Properties are relevant when obtaining environmental values from the operating system, for example, and are the grounding class for many other classes. One of the main characteristics of the <strong class="source-inline">Properties</strong> class is that it allows the definition of a default response in the case of a search for a certain key not being satisfactory. The following example highlights the basics of this case:</p>
			<p class="source-code-heading">Example20.java</p>
			<p class="source-code">1  import java.util.*;</p>
			<p class="source-code">2  </p>
			<p class="source-code">3  public class Example20 {</p>
			<p class="source-code">4  </p>
			<p class="source-code">5     public static void main(String[] args) {</p>
			<p class="source-code">6         Properties properties = new Properties();</p>
			<p class="source-code">7         Set setOfKeys;</p>
			<p class="source-code">8         String key;</p>
			<p class="source-code">9  </p>
			<p class="source-code">10        properties.put("OS", "Ubuntu Linux");</p>
			<p class="source-code">11        properties.put("version", "18.04");</p>
			<p class="source-code">12        properties.put("language", "English (UK)");</p>
			<p class="source-code">13</p>
			<p class="source-code">14        // iterate through the map</p>
			<p class="source-code">15        setOfKeys = properties.keySet();</p>
			<p class="source-code-link"><a href="https://packt.live/2N0CzoS">https://packt.live/2N0CzoS</a></p>
			<p>Before diving into the results, you will notice that in properties, we put rather than add new elements/nodes. This is the same as we saw with maps. Also, you will have noticed that to iterate, we used the <strong class="source-inline">keySet()</strong> technique that we saw when iterating through maps earlier. Finally, the particularity of <strong class="source-inline">Properties</strong> is that you can set a default response in the case of the searched-for property not being found. This is what happens in the example when searching for <strong class="bold">keyboard layout</strong>—it was never defined, so the <strong class="source-inline">getProperty()</strong> method will answer with its default message without crashing the program.</p>
			<p>The result of this program is:</p>
			<p class="source-code">version = 18.04</p>
			<p class="source-code">OS = Ubuntu Linux</p>
			<p class="source-code">language = English (UK)</p>
			<p class="source-code">keyboard layout = not found</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Another interesting method to be found in the <strong class="source-inline">Properties</strong> class is the <strong class="source-inline">list()</strong>; it comes with two different implementations that allow you to send the contents of a list to different data handlers. We can stream the whole properties list to a <strong class="source-inline">PrintStreamer</strong> object, such as <strong class="source-inline">System.out</strong>. This offers a simple way of displaying what is in a list without having to iterate through it. An example of this follows:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example21 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Properties properties = new Properties();</p>
			<p class="source-code">        properties.put("OS", "Ubuntu Linux");</p>
			<p class="source-code">        properties.put("version", "18.04");</p>
			<p class="source-code">        properties.put("language", "English (UK)");</p>
			<p class="source-code">        properties.list(System.out);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>That will result in:</p>
			<p class="source-code">version=18.04</p>
			<p class="source-code">OS=Ubuntu Linux</p>
			<p class="source-code">language=English (UK)</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The <strong class="source-inline">propertyNames()</strong> method returns an <strong class="source-inline">Enumeration</strong> list, and by iterating through it, we will obtain the keys to the whole list. This is an alternative to creating a set and running the <strong class="source-inline">keySet()</strong> method.</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example22 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Properties properties = new Properties();</p>
			<p class="source-code">        properties.put("OS", "Ubuntu Linux");</p>
			<p class="source-code">        properties.put("version", "18.04");</p>
			<p class="source-code">        properties.put("language", "English (UK)");</p>
			<p class="source-code">        Enumeration enumeration = properties.propertyNames();</p>
			<p class="source-code">        while (enumeration.hasMoreElements()) {</p>
			<p class="source-code">            System.out.println(enumeration.nextElement());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>That will result in:</p>
			<p class="source-code">version</p>
			<p class="source-code">OS</p>
			<p class="source-code">language</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The final method we will introduce you to from <strong class="source-inline">Properties</strong> at this point is <strong class="source-inline">setProperty()</strong>. It will modify the value of an existing key, or will eventually create a new key-value pair if the key is not found. The method will answer with the old value if the key exists, and answer with <strong class="source-inline">null</strong> otherwise. The next example shows how it works:</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example23 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Properties properties = new Properties();</p>
			<p class="source-code">        properties.put("OS", "Ubuntu Linux");</p>
			<p class="source-code">        properties.put("version", "18.04");</p>
			<p class="source-code">        properties.put("language", "English (UK)");</p>
			<p class="source-code">        String oldValue = (String) properties.setProperty("language", "German");</p>
			<p class="source-code">        if (oldValue != null) {</p>
			<p class="source-code">            System.out.println("modified the language property");</p>
			<p class="source-code">        }   </p>
			<p class="source-code">        properties.list(System.out);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here is the outcome:</p>
			<p class="source-code">modified the language property</p>
			<p class="source-code">-- listing properties --</p>
			<p class="source-code">version=18.04</p>
			<p class="source-code">OS=Ubuntu Linux</p>
			<p class="source-code">language=German</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are more methods in the <strong class="source-inline">Properties</strong> class that deals with storing and retrieving lists of properties to/from files. While this is a very powerful feature from the Java APIs, as we haven't yet introduced the use of files in this book, we will not discuss those methods here. For more information at this point, please refer to Java's official documentation.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Activity 2: Iterating through Large Lists</h2>
			<p>In contemporary computing, we deal with large sets of data. The purpose of this activity is to create a random-sized list of random numbers to perform some basic operations on data, such as obtaining the average. </p>
			<ol>
				<li value="1">To start, you should create a random list of numbers.</li>
				<li>To compute the average, you could create an iterator that will go through the list of values and add the weighted value corresponding to each element.</li>
				<li>The value coming from the <strong class="source-inline">iterator.next()</strong> method must be cast into a <strong class="source-inline">Double</strong> before it can be weighed against the total number of elements. </li>
			</ol>
			<p>If you've implemented everything properly, the results of the averaging should similar to:</p>
			<p class="source-code">Total amount of numbers: 3246</p>
			<p class="source-code">Average: 49.785278826074396</p>
			<p>Or, it could be:</p>
			<p class="source-code">Total amount of numbers: 6475</p>
			<p class="source-code">Average: 50.3373892275651</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 539.</p>
			<p>If you managed to make this program work, you should think about how to take advantage of being able to simulate large sets of data like this one. This data could represent the amount of time between different arrivals of data in your application, temperature data from the nodes in an Internet of Things network being captured every second. The possibilities are endless. By using lists, you can make the size of the dataset as endless as their working possibilities.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Summary</h1>
			<p>This chapter introduced you to the Java collections framework, which is a very powerful tool within the Java language that can be used to store, sort, and filter data. The framework is massive and offers tools in the form of interfaces, classes, and methods, some of which are beyond the scope of this chapter. We have focused on <strong class="source-inline">Arrays</strong>, <strong class="source-inline">Lists</strong>, <strong class="source-inline">Sets</strong>, <strong class="source-inline">Maps</strong>, and <strong class="source-inline">Properties</strong>. But there are others, such as queues and dequeues, that are worth exploring on your own.</p>
			<p>Sets, like their mathematical equivalents, store unique copies of items. Lists are like arrays that can be extended endlessly and support duplicates. Maps are used when dealing with key-value pairs, something very common in contemporary computing, and do not support the use of two of the same keys. Properties work very much like <strong class="source-inline">HashMap</strong> (a specific type of <strong class="source-inline">Map</strong>) but offer some extra features, such as the listing of all their contents to streams, which simplifies the printing out of the contents of a list.</p>
			<p>Some of the classes offered in the framework are sorted by design, such as <strong class="source-inline">TreeHash</strong> and <strong class="source-inline">TreeMap</strong>, while others are not. Depending on how you want to handle data, you will have to decide which is the best collection.</p>
			<p>There are standard techniques for looking through data with iterators. These iterators, upon creation, will point to the first element in a list. Iterators offer some basic methods, such as <strong class="source-inline">hasNext()</strong> and <strong class="source-inline">next()</strong>, that state whether there is more data in the list and extract data from the list, respectively. While those two are common to all iterators, there are others, such as <strong class="source-inline">listIterator</strong>, that are much more powerful and allow, for example, the addition of new elements to a list while browsing through it.</p>
			<p>We have looked at a chapter-long example that used many of these techniques, and we have introduced the use of the console to read data through the terminal. In the next chapter, we will cover exceptions and how to handle them.</p>
		</div>
		<div>
			<div class="Basic-Text-Frame" id="_idContainer048">
			</div>
		</div>
	</body></html>