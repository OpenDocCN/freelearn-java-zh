- en: Chapter 5. Digital Signatures and Encryption of Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since many systems interact with each other to achieve their business goals,
    we often feel the obligation to interact with services exposed by others. Also,
    when security needs play an important role, we must verify that the information
    we receive has been sent from whom we expected, and it has come without being
    altered. It is here where digital signatures will play an important role and help
    us meet this need.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we may sometimes need to encrypt the message body to prevent it from being
    read if intercepted by unwanted persons. It is here where we can make use of Secure/Multipurpose
    Internet Mail Extensions, or the S/MIME standard, which is commonly used in the
    world of e-mail for public keys ([http://en.wikipedia.org/wiki/Public_key](http://en.wikipedia.org/wiki/Public_key)),
    encryption ([http://en.wikipedia.org/wiki/Encryption](http://en.wikipedia.org/wiki/Encryption)),
    and signing ([http://en.wikipedia.org/wiki/Digital_signature](http://en.wikipedia.org/wiki/Digital_signature))
    of MIME data ([http://en.wikipedia.org/wiki/MIME](http://en.wikipedia.org/wiki/MIME)),
    and which also offers the ability to adapt the HTTP protocol and allows us to
    use it on RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Signing messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting message bodies with S/MIME
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital signatures, nowadays, are a widely used mechanism. They are mainly used
    to sign digital documents and issue electronic invoices, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the benefits of using them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: They allow the receiver to obtain the identity of whoever has made the signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide the ability to verify that the information sent has not been altered
    since it has been signed by the issuer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to electronically sign the information that we will exchange through
    RESTful web services, we will use the authentication mechanism known as **DomainKeys
    Identified Mail** (**DKIM**), which allows us to decorate messages with headers
    using the rules dictated by the DOSETA specification. This authentication mechanism
    is mainly used for e-mail identity verification; however, it also works over other
    protocols such as HTTP, and it is because of this fact we can integrate it with
    RESTful web services. Thus, we will inject metadata into our messages with the
    purpose of signing, and these signatures can be verified by those who wish to
    consume.
  prefs: []
  type: TYPE_NORMAL
- en: At this time, we will build an example that shows how to sign a message, and
    then dissect each part of it to understand its operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want, you can download the source code using the following link on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, we will explain it in the following pages. Let''s start by creating
    a new project. Open the terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When it asks you for the version, change the default value `1.0-SNAPSHOT` to
    `1.0`
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will generate the keys that allow us to encrypt messages and place them
    in the classpath of our application. For this, we will first import the project
    into Eclipse IDE and then create a folder within the project in which we place
    the keys that we want to generate. In Eclipse, right-click on the new project
    named `signatures` and select the option **New** | **Source folder**.
  prefs: []
  type: TYPE_NORMAL
- en: In the field **Folder name**, we will enter `src/main/resources`, and then we
    press the **Finish** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go to this directory from the command line and execute the following
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should enter a password for both the KeyStore and the keys with which
    we will sign the message. When it asks you for a password, type `changeit`, which
    is the same password we have been using so far in our examples in this book. Then,
    we enter the requested information as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Digital signatures](img/0109OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will implement some source code to sign a message. We first need to
    add the required dependencies to the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the JBoss repository from which we get the artifacts, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add all the dependencies we need to sign our message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the purpose of avoiding duplicated classes in the classpath, we should
    delete the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Updating RESTEasy JAR files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are using the 3.0.6.Final Version to compile the project, it is necessary
    to update the existing versions in JBoss. So, we will go to the URL [http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/](http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/)
    and download the version we just described.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we unzip the `.zip` file, we will find a file named `resteasy-jboss-modules-3.0.6.Final.zip`.
    Let''s unzip this file too, and then paste all its content in our directory `JBOSS_HOME/modules`.
    Given RESTEasy modules have dependencies, we have to update them too. So, after
    we update the RESTEasy modules, we should update the module `org.apache.httpcomponents`.
    Let''s go to the directory `JBOSS_HOME/modules/org/apache/httpcomponents` and
    update the following artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`httpclient-4.1.2.jar` to `httpclient-4.2.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpcore-4.1.4.jar` to `httpcore-4.2.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, we modify the `module.xml` file because the names of the JAR files are
    different, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Applying digital signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have everything we need to compile our project, we will create
    a very simple operation and apply a signature. In order to achieve this, let''s
    create a class called `SignedService` in the source code package called `com.packtpub.resteasy.services`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying digital signatures](img/0109OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To sign a message, we take a key from the KeyStore and use it. We can identify
    the keys in a unique way through their alias and the domain they belong to. For
    example, for the key `demo._domainKey.packtpub.com`, the alias is `demo` and the
    domain it belongs to is the key `packtpub.com`. Given that we can find several
    keys in a KeyStore, RESTEasy offers the capability to select the one we want by
    using the annotation `@Signed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the method highlighted in the following code to the class and watch
    how the annotation works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows us in a better way how the key is selected to sign
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying digital signatures](img/0109OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will define the path under our signed resources will be available,
    so let''s annotate the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In order to make the application work properly, we will give it information
    so that it can apply the appropriate signatures.
  prefs: []
  type: TYPE_NORMAL
- en: First, in the folder `src/main/webapp`, we will create the `WEB-INF` folder
    with an empty `web.xml` file inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `web.xml` file, which should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the first thing we will do is tell our application what resource we want
    to sign, which is the class that contains the method that we are signing. For
    this, let''s configure the parameter `resteasy.resources` with the corresponding
    full class name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will inform our application of the location of the key with which
    we apply the signature (the `.jks` file we created earlier). For this, we have
    two context parameters available, `resteasy.doseta.keystore.classpath` and `resteasy.keystore.filename`.
    Let''s use the first parameter so that our file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you remember, we were asked for a password for the KeyStore when creating
    the key. We will tell our application what this is using the parameter `resteasy.doseta.keystore.password`.
    Let''s add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the KeyStore from which we will extract the key that will allow us
    to sign the message, we must add the following parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should add the RESTEasy servlet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we show how the `web.xml` file should look once you have finished adding
    all the required information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s generate the WAR file by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After this, we will copy the generated artifact in to the JBoss deploy directory.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, open SoapUI and test whether the web service is running as expected, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the functionality](img/0109OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the response, we obtain the `DKIM-Signature` header used
    to sign the message. The full content of this header is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'From this whole string, what is important for us are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d=`: This is the domain, the value which is indicated at the time we implement
    the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a=`: This is the algorithm used by RESTEasy to sign the message. In this case,
    we use RSA because it is the only algorithm that is supported to date by the framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other parameters are not very important, and they are only necessary for
    a signed message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to validate the authenticity of the signature, we will create
    a class from which we will make the verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use JUnit; so, first add the corresponding dependency in the `pom.xml`
    file, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a new source folder named `scr/test/java` and a package
    named `com.packtpub.resteasy.services.test` inside it. Inside the package, let''s
    create the class `SignedServiceTest` using the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, we will see a green bar as a result of our test, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the functionality](img/0109OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Validating signatures with annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simpler way to validate whether a resource is signed is to use annotations.
    This solution can be used mainly when you have a flow of signatures that must
    be met.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that employees of the company Packt Publishing have a
    system through which they can apply to increase the RAM of their computers. To
    treat such requests as valid, they must be signed by the person making the request.
    We mean that we only need that the request be signed to be considered valid, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this example, we will add two methods to our `SignedService` class; the
    first method will allow us to send the requests, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To meet the business requirements, we will use the `@Verify` annotation in which
    we can add restrictions on signatures. For now, we only need to verify that the
    request is signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the method that shows all the complicated logic used by the
    boss to approve or deny memory increases to employee PCs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s deploy the application on JBoss and test it with SoapUI. As we
    have mentioned, the requests must be signed in order to be processed. So, first
    make a request to the method `processRequestRam` without a signature, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What is essential for the application to be processed is that it comes from
    the company domain, in this case, `packtpub.com`. Later, the boss conducts a rigorous
    analysis of the application and issues a judgment to determine whether the application
    is approved or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will remove the method that we created earlier and add
    two methods to our `SignedService` class; the first method will allow us to send
    the requests, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The output shows us the error very clearly. The request couldn't be processed
    because there is no `DKIM-Signature` header that contains the information to verify
    the signature. This means that the headers aren't there because they weren't signed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get the request successfully processed, we will call a web service
    that signs the request. We will add the headers with the signature information
    and call the `processRequestRam` method again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let'' start by calling the `requestRam` operation, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a result of this callback, we will obtain the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s keep moving! Now, we will use these values to make a request. From SoapUI,
    let''s invoke the `processRequestRam` operation and focus on the bottom-left area
    of our request editor; there is an option that says **Header**. Let''s select
    this option and click on the **+** symbol. Now, we have to enter the `DKIM-Signature`
    header and place the corresponding value. Also, don''t forget to send the request
    parameter `8-GB` that was the response of the invocation of the `requestRam` operation,
    as highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the request was successfully processed, but the boss denied
    the increase of memory. Now, we indicate that digital signatures allow us to validate
    that the information is not altered once it has been signed. Suppose malicious
    software intercepted the response, and instead of `8-GB`, it delivered the value
    `12-GB`. Let''s make this request in SoapUI following the theory of digital signatures.
    This request should not be valid; however, we must check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The error message clearly indicates that the message body was altered, so the
    request is not processed and we get the `HTTP 401 Unauthorized` message. This
    corroborates the statement made before regarding the integrity of the signed messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'RESTEasy allows us, however, to do more than just validate that a message has
    been signed. We can verify that the signer belongs to a specific domain. In our
    example, a firm would be considered valid only when it comes under the `packtpub.com`
    domain. To perform this type of control, we will make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s deploy the application in JBoss and execute the request again from SoapUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s force a fault. We will assume that valid messages are only those
    that are signed from the domain `itpacktpub.com`. So, let''s apply the following
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s deploy the application in JBoss again, and execute the request from
    SoapUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we expected, the request failed this time. Obviously, this happened because
    the signatures could not be verified as the message was signed with the `packtpub.com`
    domain and not with the `itpacktpub.com` domain as we set in the operation `processRequestRam`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suddenly, you wonder why the value of the identified name is `d`. As we mentioned
    before, the letter `d` represents the domain. The RESTEasy documentation explains
    a little more about each of the parameters in the header. Here, we show you an
    example from the documentation about JBoss related to this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Here''s what an example DKIM-Signature header might look like:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*DKIM-Signature: v=1;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a=rsa-sha256;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*d=example.com;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*s=burke;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*c=simple/simple;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*h=Content-Type;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x=0023423111111;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bh=2342322111;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*b=M232234=*'
  prefs: []
  type: TYPE_NORMAL
- en: '*As you can see, it is a set of name value pairs delimited by a '';''. While
    it''s not THAT important to know the structure of the header, here''s an explanation
    of each parameter:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*v: Protocol version. Always 1.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a: Algorithm used to hash and sign the message. RSA signing and SHA256 hashing
    is the only supported algorithm at the moment by RESTEasy.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*d: Domain of the signer. This is used to identify the signer as well as discover
    the public key to use to verify the signature.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*s: Selector of the domain. Also used to identify the signer and discover the
    public key.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*c: Canonical algorithm. Only simple/simple is supported at the moment. Basically,
    this allows you to transform the message body before calculating the hash.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*h: Semi-colon delimited list of headers that are included in the signature
    calculation.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x: When the signature expires. This is a numeric long value of the time in
    seconds since epoch. Allows signer to control when a signed message''s signature
    expires.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*t: Timestamp of signature. Numeric long value of the time in seconds since
    epoch. Allows the verifier to control when a signature expires.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bh: Base 64 encoded hash of the message body.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*b: Base 64 encoded signature.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this information, it is clear to assume that if you want to
    check the signer, instead of using the letter `d`, we must use the letter `s`,
    and instead of `packtpub.com`, we will use `demo`. Once you apply these changes,
    our code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, if you want to verify the signer''s name and domain, you must
    apply a slight change. This time, we will use the `@Verifications` annotation;
    this annotation receives an array of `@Verify` annotations as a parameter, which
    allows us to perform what we described earlier. In this case, we should add two
    controls using the `@Verify` annotation, and our code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have applied the changes, we can perform a request using SoapUI. We
    should get a successful execution as the result, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating signatures with annotations](img/0109OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Message body encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to encrypt a complete HTTP message using
    HTTPS. Now, we will explain how we can encrypt just the message body and the differences
    between each process. We start by constructing a simple example, and then, as
    we perform the respective tests of our implementation, we'll understand how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order not to spoil our previous project, we will build a new one. For this,
    we will execute the following commands in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As seen earlier in this chapter, when you get asked for a version, change the
    default value of `1.0-SNAPSHOT` to `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if you want, you can download all the source code from GitHub from
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's import the project into Eclipse, delete the existing default dependence
    in the `pom.xml` file, and add dependencies on the artifacts `resteasy-jaxrs`
    and `resteasy-crypto`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dependencies` section should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the class `EncryptedService` inside the package `com.packtpub`.
    In this class, we will create a very simple operation, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To register the services of our application, let''s create the class `EncryptedApplication`,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Testing the functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After this, our application should be ready. So, let''s execute a test from
    SoapUI to watch the traffic using Wireshark, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the functionality](img/0109OS_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Wireshark shows us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the functionality](img/0109OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the traffic analyzer shows how all the information is traveling
    straight and how easily it is interpreted. Now, let's enable HTTPS on JBoss to
    show how the whole message is encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the server with HTTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, first we have to create a certificate KeyStore. We can achieve this by
    executing the following command on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When it asks you for a password, you should use `changeit` as we have already
    used it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we look at the `JBOSS_HOME/standalone/configuration/standalone.xml` file,
    at the line containing `<connector name="http"`, and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve made this change, we will restart the application server, deploy
    the application, and edit the request. This time, we''ll use port 8443 and the
    HTTPS protocol. So, the URL should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://localhost:8443/encryption-1.0/services/encrypted`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the request using SoapUI; our traffic analyzer will now show
    us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the server with HTTPS](img/0109OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we expected, this time, the analyzer shows us very clearly that all the information
    has been encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward with our example, we will now disable HTTPS in JBoss. For this,
    we have to remove the connector we added before. Now, we will use S/MIME in order
    to encrypt only the message body of the response. First, let's check some concepts
    that will help us understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'S/MIME comes from Secure MIME. MIME stands for Multipurpose Internet Mail Extension,
    which helps us to not only send messages such as "Hello world", but also to send
    more interesting content such as videos, audio, and so on. MIME works with e-mail
    protocols such as SMTP and HTTP. This helps us to work with RESTful S/MIME web
    services. On the other hand, MIME offers us the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Message encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the identity of the user who sends the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capability to verify the information integrity of the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that S/MIME works with certifications, this is where the information of
    the message sender is saved. When the receiver gets the message, they observe
    all the public part of the message. The message can then be deciphered using a
    key. Also, the receiver can access its content. If you want to proceed further
    with S/MIME, we recommend you visit the link [http://datatracker.ietf.org/wg/smime/charter/](http://datatracker.ietf.org/wg/smime/charter/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by making some changes. First, we will create the source folder
    `src/main/resources` in the application; in this directory, we will place the
    resources necessary to encrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we generate a certificate using `openssl`, go to the directory we just
    created from the console, and run the following at the command line on a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to enter the requested information as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the server with HTTPS](img/0109OS_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will generate two files: `demokey.pem`, which is a private key, and `democert.pem`,
    which is a certificate we will use to encrypt the message body. To represent a
    signed response, RESTEasy uses the `EnvelopedOutput` object. In the following
    figure, we show you how RESTEasy encrypts messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the server with HTTPS](img/0109OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, we must replace the return type of the method `gretting()` in the
    `EncryptedService` class. Let''s change the string to `EnvelopedOutput` and encrypt
    the message body using the certificate we generated before. Applying these changes,
    our method should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a change in the `pom.xml` file. We will modify the `dependencies`
    section in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we changed the scope of the `resteasy-jaxrs` and `resteasy-jaxb-provider`
    artifacts; this is necessary to avoid duplicate classes when we encrypt the message.
    Since these artifacts are modules within the application server, you need to indicate
    that we want to load them. For this, we will modify the `pom.xml` file in the
    plugin section of `maven-war-plugin`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since JBoss Version 7 is a module-based application server, by default, only
    a few modules are activated when it starts. If you want to access other modules,
    it is necessary to indicate these dependencies explicitly. This can be done through
    the `MANIFEST.MF` file or by creating a file called `jboss-deployment-structure.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will choose the first file by using `maven-war-`plugin to indicate
    the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's make the request again from SoapUI to the URL `http://localhost:8080/encryption-1.0/services/encrypted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the response we will get is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the functionality](img/0109OS_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is what we will see from the traffic analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the functionality](img/0109OS_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, it shows us something very similar to the response from SoapUI.
    To decrypt the content, it is necessary that we have the private key and certificate.
    Through these two resources, we can obtain the object `EnvelopedInput` and get
    the message from it, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the functionality](img/0109OS_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will be demonstrated in the following code through a unit test. However,
    before going forward, we want to show that when encrypting messages with S/MIME,
    headers remain readable but the message body is fully encrypted. So, if we do
    not have the resources, the information is outdated and cannot be interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will write a class that allows us to read the message body. For this,
    we will create a new source folder called `src/main/test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this folder, let''s create the class `com.packtpub.EncryptedServiceTest`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note how we need both the private key and the certificate to decrypt the message
    to obtain the entity formed from a string containing the message `Hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: When we run this unit test, we should get a green bar if all goes well. This
    indicates that to decrypt the message, using the previous resources (private key
    and certificate) has obtained the expected message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with digital signatures and learned how to use them
    in RESTful web services. These days, digital signatures are often used because
    they guarantee message integrity, and information cannot be compromised while
    it is traveling from the sender to the receptor. We already know that information
    can be modified in transit, but when you're verifying the signed information,
    the receiver can notice it and take the actions that he/she believes are appropriate.
    For example, they can send another request to avoid working with corrupt information.
    At the end of this chapter, we worked with message body encryption, and we saw
    the difference between using these encryptions and HTTPS. Finally, we saw how
    the receiver, using the key, figured out the message body to make use of the information
    according to their needs.
  prefs: []
  type: TYPE_NORMAL
