- en: Chapter 7. Working with Integration and Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because technology stacks evolve continuously, a large area to consider when
    developing commercial software is the integration between systems. The flexibility
    and scalability of the Web have seen the proliferation of services built on top
    of HTTP to integrate systems in a loosely-coupled fashion. Moreover, to be able
    to navigate through secure networks accessible via firewalls and additional security
    mechanisms, the HTTP model has been increasingly popular. In this chapter, we
    are going to cover how to involve Scala when integrating with systems either via
    Web Services or REST Services exchanging messages in formats such as XML and JSON.
    In particular, we will consider running such services through the Play Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating data bindings from XML schemas as well as SOAP web service classes
    out of their WSDL description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating XML and JSON in Scala and in particular in the context of the Play
    Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking other REST web services from Play, and validating and displaying their
    response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding XML data in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if XML has recently stepped down a bit from its ubiquitous position due
    to the increasing popularity of JSON, both formats will continue to be heavily
    used to structure data.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, it is a common practice to use the JAXB libraries to create classes
    that are able to serialize and deserialize XML data and construct XML documents
    through an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, the `scalaxb` library available for Scala can generate
    help classes for working with XML and web services. As an example, let''s consider
    a small XML schema, `Bookstore.xsd,` that defines a set of books as part of a
    book store as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical book is defined by its title, author, date of publication, and ISBN
    number, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways one can run `scalaxb` documented on the [www.scalaxb.org](http://www.scalaxb.org)
    website: either directly as a command line tool, through plugins from SBT or Maven,
    or as a web API hosted on `heroku`. Since we have essentially used SBT so far
    and should be comfortable with it, let''s use the SBT plugin to create the bindings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First create a new SBT project entitled `wssample` by running the following
    commands in a new terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the `scalaxb` plugin dependency to a `plugins.sbt` file
    under `project/` (and at the same time we will add the `sbteclipse` plugin that
    enables us to generate an Eclipse project out of the SBT project). The resulting
    `plugins.sbt` file will look similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we have to slightly modify the `build.sbt` file to notably include
    a command that will generate `scalaxb` XML bindings when compiling with SBT. The
    resulting `build.sbt` file will look similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `Bookstore.xsd` schema shown previously to a new `src/main/xsd` directory
    created within the project. From now on, each time you invoke the SBT command
    `> compile`, `scalaxb` will generate some Scala classes under the `target/scala-2.10/src_managed`
    directory (in the package given in the `build.sbt` file that is, `se.wssample`),
    unless no changes have been made. For instance, in the case of our small example,
    `scalaxb` generates the following case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `*` at the end of the first case class declaration, which is used
    to specify varargs (that is, an unspecified number of arguments, so here the `Book_store`
    constructor can take several `Book_type` instances). A possible test class illustrating
    the usage of the generated code to parse an XML document is given in the `BookstoreSpec.scala`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output from this test when invoking the `> sbt test` command is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running scalaxb from a SOAP web service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `scalaxb` supports the **Web Services Description** **Language** (**WSDL**),
    we can also generate a full web service API in addition to the XML data-only related
    classes. To achieve this functionality, we just need to copy our WSDL service
    description file to `src/main/wsdl`. All the files with the `.wsdl` extension
    will be processed at compile time by the `scalaxb` plugin that will create the
    following three types of output:'
  prefs: []
  type: TYPE_NORMAL
- en: The service API specific to your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes specific to the SOAP protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes responsible for sending the SOAP messages to the endpoint URL via HTTP.
    `scalaxb` uses the dispatch library that we introduced in [Chapter 3](ch03.html
    "Chapter 3. Understanding the Scala Ecosystem"), *Understanding the Scala Ecosystem*.
    This is why we added it as a dependency into the `build.sbt` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take an online SOAP web service as a way to illustrate the usage of
    `scalaxb` from a WSDL description. [www.webservicex.net](http://www.webservicex.net)
    is a site that contains many different samples of such web services in various
    market segments. Here, we will focus on their Stock Quote service that returns
    quotes given by a stock symbol. The API is very straightforward since it consists
    of only one request method, `getQuote`, and the data it returns is limited in
    size. You might want to try any other available service (later on as you can have
    multiple WSDL files in your same project). Its WSDL description looks similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the WSDL file contains the description of the XML schema.
    The second part defines the various web service operations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last part of the WSDL file defines the coupling between web service
    operations and physical URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the WSDL files are often pretty verbose, but the Scala contract
    resulting from the `scalaxb` generation boils down to this one method trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the resulting type is nicely wrapped into an `Either` class that
    represents a value of one of the two possible types, `Left` and `Right`, where
    the `Right` object corresponds to a successful invocation of the service whereas
    the `Left` object contains a `scalaxb.Fault` value in case of failure, as we have
    briefly described in [Chapter 2](ch02.html "Chapter 2. Code Integration"), *Code
    Integration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the generated classes concerning the SOAP protocol and the HTTP dispatch-related
    classes are not specific to the service we are defining, they can be reused and
    therefore have been generated as stackable traits including data types and interface,
    SOAP bindings, and full SOAP clients. A typical usage scenario of these traits
    to invoke a SOAP web service is given in the following `StockQuoteSpec.scala`
    test sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, once we have instantiated the service, we will just call the
    API method `service.getQuote(Some("AAPL"))` for retrieving the stock quote of
    the AAPL symbol (Apple, Inc). We then pattern match on the result to extract the
    XML data out of the `Either` object that was returned by the service. Finally,
    since the retrieved data is given as a string of XML, we parse it and format it
    for better reading. We can execute the test using the following code to see what
    comes out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Working with XML and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML and JSON are the dominant formats to structure data that can be exchanged
    between parts of a system such as backend-frontend or between external systems.
    In Scala, there is some out-of-the-box support in the Scala library to manipulate
    both.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have briefly seen earlier in this chapter as well as in [Chapter 3](ch03.html
    "Chapter 3. Understanding the Scala Ecosystem"), *Understanding the Scala Ecosystem*,
    when working with HTTP that XML documents can be created as literals and transformed
    in many ways. For instance, if we launch an REPL by typing `> play console` from
    a Play project root directory, we can start experimenting with XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `books` variable is of type `Elem`, which represents an XML structure.
    Rather than directly writing an XML literal, we could also construct the XML `Elem`
    using utility methods to parse a file or just parse a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The triple quote used in the preceding command lets us express a preformatted
    string where the characters are escaped (for example, the `"` within a regular
    string would have been noted `\"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing such an XML structure can, for example, consist of computing the
    total price for the books. This operation can be achieved with a Scala `for comprehension`
    leading to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving and transforming XML structures happens all the time when dealing
    with the integration of diverse external systems. Accessing the various XML tags
    through XPath expressions as we have done earlier is very handy and produces concise
    and readable code. Programmatically, creating XML out of information exported
    from Excel in the form of CSV data is also a common operation and can be achieved
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSON is supported in the Scala library and you just need to import the appropriate
    library. An example of some REPL usage is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Any valid JSON message can be transformed into a structure made of `Maps` and
    `Lists`. However, it is often desirable to create meaningful classes, that is,
    expressing the business domain out of the JSON messages. The online service available
    at [http://json2caseclass.cleverapps.io](http://json2caseclass.cleverapps.io)
    does exactly that; it is a convenient JSON to Scala case class converter. We can,
    for example, copy our preceding JSON message into the **Json paste** text area
    and click on the **Let''s go!** button to try it out as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating JSON](img/3637OS_07_05_New.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The converter produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Among the very interesting features of case classes that we have already introduced
    in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within Your Project"),
    *Programming Interactively within Your Project*, is a decomposition mechanism
    for pattern matching. Once JSON messages have been deserialized into case classes,
    we can, for instance, manipulate them using this mechanism, as the sequence of
    the following command illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we defined two instances of books and put them into a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The method defined previously does pattern matching on the `Book` constructor,
    which also contains a guard (that is, the `if` condition). Since we do not use
    the second constructor parameter, we have put an underscore instead of creating
    an anonymous variable. Calling this method on both the book instances that we
    defined earlier will show the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can mix case class pattern matching together with other patterns. Let''s,
    for instance, define the following regular expression (note the usage of the triple
    quotes as well as the use of `.r` to specify that it is a regular expression):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This regular expression will match any string that contains either Scala or
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now try out this method on a number of different inputs and observe
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using Play JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many alternative libraries one can use to manipulate JSON in addition
    to the default implementation of the Scala library. In addition to the ones built
    on top of the known Java libraries such as Jerkson (built on top of Jackson) and
    other known implementations such as sjson, json4s, or Argonaut (functional programming
    oriented), many web frameworks have created their own including lift-json, spray-json,
    or play-json. Since in this book we are mostly covering the Play Framework to
    build web applications, we are going to focus on the play-json implementation.
    Note that play-json can also be run as standalone since it consists of a single
    jar without other dependencies to Play. Running an REPL console from within a
    Play project already includes the play-json dependency so that we can directly
    experiment with it in a console terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to run the following samples into an REPL different from the Play
    console (for instance, a regular SBT project or a Typesafe activator project)
    then you will have to add the following dependency to your `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JsValue` type is the super type of the other JSON data types included
    in play-json and is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JsNull` to represent a null value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JsString`, `JsBoolean`, and `JsNumber` to describe strings, booleans, and
    numbers respectively: numbers include short, int, long, float, double, and BigDecimal
    as seen in the following commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`JsObject` represents a set of name/value pairs as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`JsArray` represents a sequence of any JSON value types (which can be heterogenous,
    that is, of different types):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Programmatically, creating a JSON **Abstract** **Syntax Tree** (**AST**) equivalent
    to our list of books can therefore be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Play has recently been enhanced to provide a slightly simpler syntax when creating
    the JSON structure we have just described. The alternative syntax to construct
    the same JSON object is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Serializing the JsObject to its string representation can be achieved with
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, since a `JsObject` object represents a tree structure, you can navigate
    within the tree by using XPath expressions to retrieve various elements, such
    as the following example to access the titles of both our books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As the return type is a sequence of `JsValue` objects, it can be useful to
    convert them into Scala types and the `.as[…]` method would be convenient to achieve
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Handling Play requests with XML and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are familiar with the JSON and XML formats, we can start using them
    to handle HTTP requests and responses in the context of a Play project.
  prefs: []
  type: TYPE_NORMAL
- en: To exhibit these behaviors, we are going to call an online web service, the
    iTunes media library, which is available and documented at [http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns JSON messages on search invocations. We can, for instance, call
    the API with the following URL and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://itunes.apple.com/search?term=angry+birds&country=se&entity=software](https://itunes.apple.com/search?term=angry+birds&country=se&entity=software)'
  prefs: []
  type: TYPE_NORMAL
- en: The term parameter filters every item in the library that has to do with *Angry
    Birds* and the entity parameter retains only software items. We also apply an
    additional filter to query only the Swedish App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t have it already in your `build.sbt` file, you may need to add
    the dispatch dependency at this point, the same way we did while working with
    HTTP in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"),
    *Understanding the Scala Ecosystem*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters that will be part of our GET method call can be expressed as `(key,value)`
    tuples in a Scala `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of result in this case is `Future[Either[Throwable,String]]`, which
    means we can extract a successful invocation as well as a failed execution by
    pattern matching as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Mocking Play responses with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you need to integrate your services with external systems that you
    do not own or that are not available until you deploy them in production, it can
    be cumbersome to test the interaction of messages that are sent and received.
    An efficient way to avoid calling a real service is to replace it with mock messages,
    that is, hardcoded responses that will cut short the real interaction, especially
    if you need to run your tests as part of an automated process (for instance, daily
    as a Jenkins job). Returning a plain JSON message from within a Play controller
    is very straightforward, as the following example illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Json.format[. . .]` declaration that involves Reads, Writes, and Format
    will be explained later on in this section when we invoke web services, so we
    can skip discussing that part for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try out this controller, you can either create a new Play project, or, as
    we did before, just add this controller to the application we generated out of
    an existing database in the last section of [Chapter 6](ch06.html "Chapter 6. Database
    Access and the Future of ORM"), *Database Access and the Future of ORM*. You also
    need to add a route to the `route` file under `conf/` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the app is running, accessing the `http://localhost:9000/mocksearch` URL
    in a browser will return the following mock JSON message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking Play responses with JSON](img/3637OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another convenient way to obtain a JSON test message that you can use to mock
    a response is to use the online service found at [http://json-generator.appspot.com](http://json-generator.appspot.com).
    It consists of a JSON generator that we can use as it is by simply clicking on
    the **Generate** button. By default, it will generate a JSON sample including
    random data in the panel to the right of the browser window, but adhering to the
    structure defined in the panel to the left, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking Play responses with JSON](img/3637OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can click on the **Copy to** **clipboard** button and paste the resulting
    mock message directly into the response of the Play controller.
  prefs: []
  type: TYPE_NORMAL
- en: Calling web services from Play
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, to quickly experiment with the App Store search API,
    we have used the `dispatch` library; we have already introduced this library in
    [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"), *Understanding
    the Scala Ecosystem*. Play provides its own HTTP library to be able to interact
    with other online web services. It is also built on top of the Java `AsyncHttpClient`
    library ([https://github.com/AsyncHttpClient/async-http-client](https://github.com/AsyncHttpClient/async-http-client)),
    as `dispatch` is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into invoking REST web services from Play controllers, let''s
    experiment a little bit with Play web services from the REPL. In a terminal window,
    either create a new Play project or go to the root directory of the one we have
    used in the previous sections. Once you get a Scala prompt after having typed
    the `> play console` command, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are going to invoke a web service asynchronously, we need an execution
    context to handle the `Future` placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a service URL that needs to be called. Here, we will take
    a simple web service that returns the geographic location of a site given as a
    parameter, according to the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The format parameter can either be `json` or `xml`, and the `site` will be
    a reference to a website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we saw earlier in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala
    Ecosystem"), *Understanding the Scala Ecosystem*, when working with the `dispatch`
    library, a `Future` is a placeholder that contains the result of an asynchronous
    computation and can be in two states, either `completed` or `not`. Here, we want
    to print the result once it is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have only extracted the `region_name` item from the response; the whole
    JSON document is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can encapsulate part of the response if we want to by creating a `case`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `play-json` library includes support to read/write JSON structures via `Reads`/`Writes`/`Format`
    combinators based on `JsPath` so that validation can be made on the fly. If you
    are interested in all the details behind the use of these combinators, you may
    want to read through the blog at [http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/](http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, invoking the validate method on the JSON response will verify that the
    data we receive is well-formed and with acceptable values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous `JsError` object illustrates a validation that failed; it detected
    that the `country` element is not found in the response. In fact, the correct
    spelling is `country_name` instead of `country`, which we can correct in our `locationReads`
    declaration. This time validation goes through and what we get as a response is
    a `JsSuccess` object containing the latitude and longitude information as we expect
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a sample controller that invokes a web service to retrieve
    some data from the App Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the call to the web service is illustrated by invoking methods on the
    `WS` class, first the `url` method giving the URL, then the `withQueryString`
    method with input parameters given as a sequence of `key->value` pairs. Notice
    that the returned type is a `Future`, meaning our web service is asynchronous.
    `recoverTotal` takes a function that will return a default value after managing
    the error. The line `json.validate[AppResult]` makes the JSON response validated
    against an `AppResult` object that is specified here (as part of a `Marketplace.scala`
    file in `app/models/` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppResult` and `AppInfo` case classes are created to encapsulate the elements
    that we care about for our service. As you may have seen when first experimenting
    with the API, most of the search queries to the App Store return a large amount
    of elements, most of which we may not need. This is why, using some Scala syntactic
    sugar with combinators, we can validate the JSON response on the fly and directly
    extract the elements of interest. Before trying out this web service call, we
    just need to add the needed route to the `routes` file under `conf/`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, before launching the application in a web browser, we also need the
    sample view that is referred to in the `MarketplaceController.scala` file by `html.marketplace.list`
    and created in a `list.scala.html` file under `views/marketplace/` in several
    parts as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the view only consists of helper methods to navigate and
    is generated the same way as we did for the CRUD sample generation in [Chapter
    6](ch06.html "Chapter 6. Database Access and the Future of ORM"), *Database Access
    and the Future of ORM*. The second part of the view includes the JSON elements
    we have retrieved from the web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The third and final part of the view is handling pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we re-launch the Play app with `> play run` and access (through a web
    browser) our local `http://localhost:9000/marketplace?f=candy+crush` URL that
    includes a default search from the App Store (the `f` parameter stands for `filter`),
    we will obtain a page similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling web services from Play](img/3637OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw some examples on how to manipulate the XML and JSON
    formats in Scala and how to connect to other systems via web services. In the
    case of XML, we also covered how to generate SOAP bindings out of a WSDL description
    as well as Scala classes to encapsulate the XML domain included in an XML schema.
    Web services in the Play Framework run asynchronously, which means that the caller
    is not waiting for the answer to come back before he continues to do other useful
    processing (such as serving other requests). In the next chapter, we are going
    to study this notion of asynchronous invocations more precisely. It is based on
    the concepts of `Future` and `Promise` that are also emerging in the Java world
    to deal with the execution of concurrent code. In particular, we will go through
    the Akka framework, an open source toolkit and runtime simplifying the construction
    of concurrent applications. Designed and written in Scala, Akka contains both
    Scala and Java APIs and is the basis of the Play Framework infrastructure that
    makes the Play Framework an ideal candidate for running scalable web applications
    on multicore architectures.
  prefs: []
  type: TYPE_NORMAL
