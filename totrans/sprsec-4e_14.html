<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer119">
<h1 class="chapter-number" id="_idParaDest-294"><a id="_idTextAnchor445"/>14</h1>
<h1 id="_idParaDest-295"><a id="_idTextAnchor446"/>Session Management</h1>
<p>This chapter discusses Spring Security’s session management functionality. It starts off with an example of how Spring Security defends against session fixation. We will then discuss how concurrency control can be leveraged to restrict access to software licensed on a per-user basis. We will also see how session management can be leveraged for administrative functions. Last, we will explore how <strong class="source-inline">HttpSession</strong> is used in Spring Security and how we can <span class="No-Break">manage sessions:</span></p>
<p>The following is a list of topics that will be covered in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Session <span class="No-Break">management/session fixation</span></li>
<li><span class="No-Break">Concurrency control</span></li>
<li>Managing <span class="No-Break">logged-in users</span></li>
<li>How <strong class="source-inline">HttpSession</strong> is used in Spring Security and how to <span class="No-Break">control creation</span></li>
<li>How to use the <strong class="source-inline">DebugFilter</strong> class to discover where <strong class="source-inline">HttpSession</strong> <span class="No-Break">was created</span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/qaJyz"><span class="No-Break">https://packt.link/qaJyz</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor447"/>Configuring session fixation protection</h1>
<p>As we are using the security namespace style of configuration, session fixation protection is already <a id="_idIndexMarker969"/>configured on our behalf. If we wanted to explicitly configure it to mirror the default settings, we would do <span class="No-Break">the following:</span></p>
<pre class="source-code">
http.sessionManagement(session -&gt; session.sessionFixation().migrateSession());</pre> <p><strong class="bold">Session fixation protection</strong> is a feature of the framework that you most likely won’t even notice unless you try to act as a malicious user. We’ll show you how to simulate a session-stealing attack; before we do, it’s important to understand what session fixation does and<a id="_idTextAnchor448"/> the type of attack <span class="No-Break">it prevents.</span></p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor449"/>Understanding session fixation attacks</h2>
<p>Session fixation is a type of attack whereby a malicious user attempts to steal the <a id="_idIndexMarker970"/>session of an unauthenticated user of your system. This can be done by using a variety of techniques that result in the attacker obtaining the unique session identifier of the user (for example, <strong class="source-inline">JSESSIONID</strong>). If the attacker creates a cookie or a URL parameter with the user’s <strong class="source-inline">JSESSIONID</strong> identifier in it, they can access the <span class="No-Break">user’s session.</span></p>
<p>Although this is obviously a problem, typically, if a user is unauthenticated, they haven’t entered any sensitive information. This becomes a more critical problem if the same session identifier continues to be used after a user has been authenticated. If the same identifier is used after authentication, the attacker may now gain access to the authenticated user’s session without even having to know their username <span class="No-Break">or password!</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">At this point, you may scoff in disbelief and think this is extremely unlikely to happen in the real world. In fact, session-stealing attacks happen frequently. We would suggest that you spend some time reading the very<a id="_idIndexMarker971"/> informative articles and case studies on the subject, published by the <strong class="bold">Open Web Application Security Project</strong> (<strong class="bold">OWASP</strong>) organization (<a href="http://www.owasp.org/">http://www.owasp.org/</a>). Specifically, you will want to read the OWASP top 10 lists. Attackers and malicious users are real, and they can do very real damage to your users, your application, or your company if you don’t understand the techniques that they <span class="No-Break">commonly use.</span></p>
<p>The following diagram<a id="_idIndexMarker972"/> illustrates how a session fixation <span class="No-Break">attack works:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<img alt="Figure 14.1 – Session fixation attack" height="954" src="image/B21757_14_1.jpg" width="1057"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Session fixation attack</p>
<p>In this diagram, we see that by fixing the session identifier to a known value, the attacker bypasses the normal authentication process and gains unauthorized access to the victim’s account or session. This type of attack underscores the importance of properly managing and securing session identifiers to prevent session <span class="No-Break">fixation vulnerabilities.</span></p>
<p>Now that we have seen how an attack like this works, we’ll see what Spring Security can <a id="_idTextAnchor450"/>do to <span class="No-Break">prevent it.</span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor451"/>Preventing session fixation attacks with Spring Security</h2>
<p>If we can prevent the same session that the user had prior to authentication from being used after authentication, we can effectively render the attacker’s<a id="_idIndexMarker973"/> knowledge of the session ID useless. Spring Security session fixation protection solves this problem by explicitly creating a new session when a user is authenticated and invalidating their <span class="No-Break">old session.</span></p>
<p>Let’s look at the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<img alt="Figure 14.2 – Preventing session fixation attacks with Spring Security" height="975" src="image/B21757_14_2.jpg" width="1174"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Preventing session fixation attacks with Spring Security</p>
<p>We can see that a new filter, <strong class="source-inline">o.s.s.web.session.SessionManagementFilter</strong>, is responsible for evaluating if a particular user is newly authenticated. If the user is newly authenticated, a configured <strong class="source-inline">o.s.s.web.authentication.session.SessionAuthenticationStrategy</strong> interface determines what to <span class="No-Break">do. </span><span class="No-Break"><strong class="source-inline">o.s.s.web.authentication.session.SessionFixation</strong></span><strong class="source-inline">
ProtectionStrategy</strong> will create a new session (if the user already had one) and copy the contents of the existing session to the new one. That’s pretty much it—seems simple. However,<span class="P---Callout-Char"> </span>as we can see in the<a id="_idIndexMarker974"/> preceding diagram, it effectively prevents the malicious user from reusing the session ID after the unknown user <span class="No-Break">is authenticated.</span></p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor452"/>Simulating a session fixation attack</h2>
<p>At this point, you may want to <a id="_idIndexMarker975"/>see what’s involved in simulating a session <span class="No-Break">fixation attack:</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the code <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter14.00-calendar</strong></span><span class="No-Break">.</span></p>
<ol>
<li>You’ll first need to disable session fixation protection in the <strong class="source-inline">SecurityConfig.java</strong> file by adding the <strong class="source-inline">sessionManagement() </strong>method as a child of the <span class="No-Break"><strong class="source-inline">HTTP</strong></span><span class="No-Break"> element.</span><p class="list-inset">Let’s take a look at the following <span class="No-Break">code snippet:</span></p><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
http.sessionManagement(session -&gt; session.sessionFixation().none());</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter14.01-calendar</strong></span><span class="No-Break">.</span></p>
<ol>
<li value="2">Next, you’ll need to open two browsers. We’ll initiate the session in Google Chrome, steal it from there, and our attacker will log in using the stolen session in Firefox. We will use the <em class="italic">Google Chrome</em> and <em class="italic">Firefox Web Developer</em> add-ons in order to view and <span class="No-Break">manipulate cookies.</span></li>
<li>Open the JBCP calendar home page in <span class="No-Break">Google Chrome.</span></li>
<li><span class="No-Break">Next:</span><ul><li><strong class="bold">Open Developer Tools</strong>: Right-click on the web page and select <strong class="bold">Inspect</strong>, or press <em class="italic">Ctrl + Shift + I</em> (Windows/Linux) or <em class="italic">Cmd + Opt + I</em> (Mac) to open the <span class="No-Break">Developer Tools.</span></li><li><strong class="bold">Navigate to the Application Tab</strong>: In the Developer Tools, you will see a menu at the top. Click on<a id="_idIndexMarker976"/> the <span class="No-Break"><strong class="bold">Application</strong></span><span class="No-Break"> tab.</span></li><li><strong class="bold">Locate Cookies in the Sidebar</strong>: On the left sidebar, you should see a <strong class="bold">Cookies</strong> section. Expand it to see the list of domains with their <span class="No-Break">associated cookies.</span></li><li><strong class="bold">Select the Specific Domain</strong>: Click on the domain relevant to the website you are interested in. This will display the list of cookies associated with <span class="No-Break">that domain.</span></li><li><strong class="bold">View the Cookie Values</strong>: You can see the details of each cookie, including its name, value, domain, path, and so on. Look for the specific cookie you are interested in, and you will find <span class="No-Break">its value.</span></li></ul></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer111">
<img alt="Figure 14.3 – Cookies explorer in Google Chrome" height="466" src="image/B21757_14_3.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Cookies explorer in Google Chrome</p>
<ol>
<li value="5">Select the <strong class="source-inline">JSESSIONID</strong> cookie, copy the value of <strong class="bold">Content</strong> to the clipboard, and log in to the JBCP calendar application. If you repeat the <strong class="bold">View Cookie Information</strong> command, you’ll see that <strong class="source-inline">JSESSIONID</strong> did not change after you logged in, making you <a id="_idIndexMarker977"/>vulnerable to a session <span class="No-Break">fixation attack!</span></li>
<li>In Firefox, open the JBCP calendar website. You will have been assigned a session cookie, which you can view by using <em class="italic">Ctrl + F2</em> to open the <strong class="bold">bottom: Cookie</strong> console. Then, type in <em class="italic">cookie list [enter]</em> to bring up cookies for the <span class="No-Break">current page.</span></li>
<li>To complete our hack, we’ll click on the <strong class="bold">Edit Cookie</strong> option and paste in the <strong class="source-inline">JSESSIONID</strong> cookie that we copied to the clipboard from Google Chrome, as shown in the <span class="No-Break">following screenshot:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer112">
<img alt="Figure 14.4 – Cookies hack in Firefox" height="314" src="image/B21757_14_4.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Cookies hack in Firefox</p>
<ol>
<li value="8">Keep in mind that newer versions of Firefox include web developer tools, too. However, you will need to ensure that you are using the extension and not the built-in one, as it provides <span class="No-Break">additional capabilities.</span><p class="list-inset">Our session fixation hack is complete! If you now reload the page in Firefox, you will see that you are logged in as the same user who was logged in using Google Chrome, but without the knowledge of the username and password. Are you scared of malicious <span class="No-Break">users yet?</span></p></li>
<li>Now, re-enable session fixation protection and try this exercise again. You’ll see that, in this case, the <strong class="source-inline">JSESSIONID</strong> changes after the user logs in. Based on our understanding of how session fixation attacks occur, this means that we have reduced the likelihood of an unsuspecting user falling victim to this type of attack. <span class="No-Break">Excellent job!</span></li>
</ol>
<p>Cautious developers should <a id="_idIndexMarker978"/>note that there are many methods of stealing session cookies, some of which—such as <strong class="source-inline">XSS</strong>—may make even session fixation-protected sites vulnerable. Please consult the OWASP site for additional resources on preventing these types <span class="No-Break">of attacks.</span></p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor453"/>Comparing the session-fixation-protection options</h2>
<p>The <strong class="source-inline">session-fixation-protection</strong> attribute has the following three options that allow you to alter its behavior; they<a id="_idIndexMarker979"/> are <span class="No-Break">as follows:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Attribute value</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">none()</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This option disables session fixation protection and (unless other <strong class="source-inline" lang="en-US" xml:lang="en-US">sessionManagement()</strong> attributes are non-default) does not <span class="No-Break">configure </span><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">SessionManagementFilter</strong></span><span class="No-Break">.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">migrateSession()</strong></span></p>
</td>
<td class="No-Table-Style">
<p>When the user is authenticated and a new session is allocated, it ensures that all attributes of the old session are moved to the <span class="No-Break">new session.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">newSession()</strong></span></p>
</td>
<td class="No-Table-Style">
<p>When the user is authenticated, a new session is created and no attributes from the old (unauthenticated) session will <span class="No-Break">be migrated.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.1 – session-fixation-protection options</p>
<p>In most cases, the default behavior of <strong class="source-inline">migrateSession()</strong> will be appropriate for sites that wish to retain important attributes of the user’s session (such as click interest and shopping <a id="_idTextAnchor454"/>carts) after the user has <span class="No-Break">been authenticated.</span></p>
<h1 id="_idParaDest-301"><a id="_idTextAnchor455"/>Restricting the number of concurrent sessions per user</h1>
<p>In the software industry, software is often sold on a per-user basis. This means that, as software developers, we have an <a id="_idIndexMarker980"/>interest in ensuring that only a single session per user exists, to combat the sharing of accounts. Spring Security’s concurrent session control ensures that a single user cannot have more than a fixed number of active sessions simultaneously (typically one). Ensuring that this maximum limit is enforced involves several components working in tandem to accurately track changes in user <span class="No-Break">session activity.</span></p>
<p>Let’s configure the feature, review how it works, and then test <span class="No-Break">it out!</span></p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor456"/>Configuring concurrent session control</h2>
<p>Now that we have understood the<a id="_idIndexMarker981"/> different components involved in concurrent session control, setting it up should make much more sense. Let’s take a look at the following steps to configure concurrent <span class="No-Break">session control:</span></p>
<ol>
<li>Firstly, you update your <strong class="source-inline">SecurityConfig.java</strong> file <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
http.sessionManagement(session -&gt; session.maximumSessions(1));</pre></li> <li>Next, we need to enable <strong class="source-inline">o.s.s.web.session.HttpSessionEventPublisher</strong> in the <strong class="source-inline">SecurityConfig.java</strong> deployment descriptor so that the servlet container will notify Spring Security (through <strong class="source-inline">HttpSessionEventPublisher</strong>) of session life cycle events, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SessionConfig.java
@Configuration
public class SessionConfig {
    @Bean
    public HttpSessionEventPublisher httpSessionEventPublisher() {
       return new HttpSessionEventPublisher();
    }
}</pre></li> </ol>
<p>With these two configuration bits in place, concurrent session control will now be activated<a id="_idTextAnchor457"/>. Let’s see what it <a id="_idIndexMarker982"/>actually does, and then we’ll demonstrate how it can <span class="No-Break">be teste<a id="_idTextAnchor458"/>d.</span></p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor459"/>Understanding concurrent session control</h2>
<p>Concurrent session control uses <strong class="source-inline">o.s.s.core.session.SessionRegistry</strong> to maintain a list of active HTTP sessions and<a id="_idIndexMarker983"/> the authenticated users with which they are associated. As sessions are created and expired, the registry is updated in real time based on the session life cycle events published by <strong class="source-inline">HttpSessionEventPublisher</strong> to track the number of active sessions per <span class="No-Break">authenticated user.</span></p>
<p>Refer to the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<img alt="Figure 14.5 – Concurrent session control" height="1036" src="image/B21757_14_5.jpg" width="996"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Concurrent session control</p>
<p>An extension of <strong class="source-inline">SessionAuthenticationStrategy</strong>, <strong class="source-inline">o.s.s.web.authentication.session.ConcurrentSessionControlStrategy</strong> is the method by which new sessions are tracked and the method by which concurrency control is actually enforced. Each time a user accesses the secured site, <strong class="source-inline">SessionManagementFilter</strong> is <a id="_idIndexMarker984"/>used to check the active session against <strong class="source-inline">SessionRegistry</strong>. If the user’s active session isn’t in the list of active sessions tracked in <strong class="source-inline">SessionRegistry</strong>, the least recently used session is <span class="No-Break">immediately expired.</span></p>
<p>The secondary actor in the modified concurrent session control filter chain is <strong class="source-inline">o.s.s.web.session.ConcurrentSessionFilter</strong>. This filter will recognize expired sessions (typically, sessions that have been expired either by the servlet container or forcibly by the <strong class="source-inline">ConcurrentSessionControlStrategy</strong> interface) and notify the user that their session <span class="No-Break">has expired.</span></p>
<p>Now that we have understood how concurrent session control works, it should be easy for us to reproduce a <a id="_idIndexMarker985"/>scenario in which it <span class="No-Break">is enforced.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter14.02-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor460"/>Testing concurrent session control</h2>
<p>As we did when verifying <a id="_idIndexMarker986"/>session fixation protection, we will need to access two web browsers by performing the <span class="No-Break">following steps:</span></p>
<ol>
<li>In Google Chrome, log in to the site <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">user1@example.com/user1</strong></span><span class="No-Break">.</span></li>
<li>Now, in Firefox, log in to the site as the <span class="No-Break">same user.</span></li>
<li>Finally, go back to Google Chrome and take any action. You will see a message indicating that your session has expired, as shown in the <span class="No-Break">following screenshot:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer114">
<img alt="Figure 14.6 – Testing concurrent session control" height="117" src="image/B21757_14_6.jpg" width="855"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Testing concurrent session control</p>
<p class="list-inset">If you were using this application and received this message, you’d probably be confused. This is because it’s obviously not a friendly method of being notified that only a single user can access the application at a time. However, it does illustrate that the session has been forcibly expired by <span class="No-Break">the software.</span></p>
<p class="callout-heading">Important <a id="_idTextAnchor461"/>note</p>
<p class="callout">Concurrent session control tends to be a very difficult concept for new Spring Security users to grasp. Many users try to implement it without truly understanding how it works and what the benefits are. If you’re trying to enable this powerful feature and it doesn’t seem to be working as you expect, make sure you have everything configured correctly, and then review the theoretical explanations in this section—hopefully, they will help you understand what may <span class="No-Break">be wrong.</span></p>
<p>When a session expiration<a id="_idIndexMarker987"/> event occurs, we should probably redirect the user to the <a id="_idTextAnchor462"/>login page and provide them with a message to indicate what <span class="No-Break">went wrong.</span></p>
<h1 id="_idParaDest-305"><a id="_idTextAnchor463"/>Configuring expired session redirect</h1>
<p>Fortunately, there is a simple <a id="_idIndexMarker988"/>method for directing users to a friendly page (typically the login page) when they are flagged by concurrent session control—simply specify the <strong class="source-inline">expired-url</strong> attribute and set it to a valid page in your application. Update your <strong class="source-inline">SecurityConfig.java</strong> file <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
http.sessionManagement(session -&gt; session.maximumSessions(1)
       .expiredUrl("/login/form?expired"));</pre> <p>In the case of our application, this will redirect the user to the standard login form. We will then use the query parameter to display a friendly message, indicating that we determined that they had multiple active sessions and should log in again. Update your <strong class="source-inline">login.xhtml</strong> page to use this parameter to display <span class="No-Break">our message:</span></p>
<pre class="source-code">
//src/main/resources/templates/login.xhtml
&lt;div th:if="${param.expired != null}" class="alert alert-success"&gt;
    &lt;strong&gt;Session Expired&lt;/strong&gt;
    &lt;span&gt;You have been forcibly logged out due to multiple
    sessions on the same account (only one active
        session per user is allowed).&lt;/span&gt;
&lt;/div&gt;</pre> <p>Go ahead and give it a try by logging in as the user <strong class="source-inline">admin1@example.com/admin1</strong> using both Google Chrome <span class="No-Break">and Firefox.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter14.03-calendar</strong></span><span class="No-Break">.</span></p>
<p>This time, you should see a login<a id="_idIndexMarker989"/> page with a custom <span class="No-Break">error message:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<img alt="Figure 14.7 – A concurrent session login page custom error message" height="103" src="image/B21757_14_7.jpg" width="1058"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – A concurrent session login page custom error message</p>
<p>After setting up redirection for expired sessions, we’ll delve into typical challenges associated with <span class="No-Break">concurrency control.</span></p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor464"/>Common problems with concurrency control</h1>
<p>There are a few common reasons<a id="_idIndexMarker990"/> that logging in with the same user does not trigger a logout event. The first occurs when using the custom <strong class="source-inline">UserDetails</strong> (as we did in <a href="B21757_03.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Custom Authentication</em>) while the equals and <strong class="source-inline">hashCode</strong> methods are not properly implemented. This occurs because the default <strong class="source-inline">SessionRegistry</strong> implementation uses an in-memory map to store <strong class="source-inline">UserDetails</strong>. In order to resolve this, you must<span class="P---Callout-Char"> </span>ensure that you have properly implemented the <strong class="source-inline">hashCode</strong> and <span class="No-Break">equals methods.</span></p>
<p>The second problem occurs when restarting the application container while the user sessions are persisted to a disk. When the container has started back up, the users who were already logged in with a valid session are logged in. However, the in-memory map of <strong class="source-inline">SessionRegistry</strong> that is used to determine if the user is already logged in will be empty. This means that Spring Security will report that the user is not logged in, even though the user is. To solve this problem, either a custom <strong class="source-inline">SessionRegistry</strong> is required along with disabling session persistence within the container, or you must implement a container-specific way to ensure that the persisted sessions get populated into the in-memory map <span class="No-Break">at startup.</span></p>
<p>The last common reason we will cover is that concurrency control will not work in a clustered environment with the default <strong class="source-inline">SessionRegistry</strong> implementation. The default implementation uses an in-memory map. This means that if <strong class="source-inline">user1</strong> logs in to <strong class="source-inline">application server A</strong>, the fact that they are logged in will be associated with that server. Thus, if <strong class="source-inline">user1</strong> then authenticates to <strong class="source-inline">Application Server B</strong>, the previously associated authentication<a id="_idIndexMarker991"/> will be unknown to <strong class="source-inline">Application </strong><span class="No-Break"><strong class="source-inline">Server B</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor465"/>Preventing authentication instead of forcing logout</h2>
<p>Spring Security can also prevent a user from<a id="_idIndexMarker992"/> being able to log in to the application if the user already has a session. This means that instead of forcing the original user to log out, Spring Security will prevent the second user from being able to log in. The configuration changes can be seen <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
http.sessionManagement(session -&gt; session.maximumSessions(1)
        .expiredUrl("/login/form?expired").maxSessionsPreventsLogin(true));</pre> <p>Make the updates and log in to the calendar application with Google Chrome. Now, attempt to log in to the calendar application with Firefox using the same user. You should see our custom error message from our <span class="No-Break"><strong class="source-inline">login.xhtml</strong></span><span class="No-Break"> file:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<img alt="Figure 14.8 – A custom error message preventing authentication for concurrent sessions" height="108" src="image/B21757_14_8.jpg" width="731"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – A custom error message preventing authentication for concurrent sessions</p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter14.04-calendar</strong></span><span class="No-Break">.</span></p>
<p>There is a disadvantage to this approach that may not be apparent without some thought. Try closing Google Chrome without logging out and then opening it up again. Now, attempt to log in to the application again. You will observe that you are unable to log in. This is because when the browser is closed, the <strong class="source-inline">JSESSIONID</strong> cookie is deleted. However, the application is not aware of this, so the user is still considered authenticated. You can <a id="_idIndexMarker993"/>think of this as a kind of memory leak, since <strong class="source-inline">HttpSession</strong> still exists but there is no pointer to it (the <strong class="source-inline">JSESSIONID</strong> cookie is gone). It is not until the session times out that our user will be able to authenticate again. Thankfully, once the session times out, our <strong class="source-inline">SessionEventPublisher</strong> interface will remove the user from our <strong class="source-inline">SessionRegistry</strong> interface. What we can take away from this is that if a user forgets to log out and closes the browser, they will not be able to log in to the application until the session <span class="No-Break">times out.</span></p>
<p class="callout-heading">Impor<a id="_idTextAnchor466"/>tant note</p>
<p class="callout">Just as in <a href="B21757_07.xhtml#_idTextAnchor220"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Remember-</em><em class="italic">m</em><em class="italic">e Services</em>, this experiment may not work if the browser decides to remember a session even after the browser is closed. Typically, this will happen if a plugin or the browser is configured to restore sessions. In this event, you might want to delete the <strong class="source-inline">JSESSIONID</strong> cookie manually to simulate the browser <span class="No-Break">being closed.</span></p>
<h1 id="_idParaDest-308"><a id="_idTextAnchor467"/>Other benefits of concurrent session control</h1>
<p>Another benefit of concurrent session<a id="_idIndexMarker994"/> control is that <strong class="source-inline">SessionRegistry</strong> exists to track active (and, optionally, expired) sessions. This means that we can get runtime information about what user activity exists in our system (for authenticated users, at least) by performing the <span class="No-Break">following steps:</span></p>
<ol>
<li>You can even do this if you don’t want to enable concurrent session control. Simply set <strong class="source-inline">maximumSessions</strong> to <strong class="source-inline">-1</strong>, and session tracking will remain enabled, even though no maximum will be enforced. Instead, we will use the explicit bean configuration provided in the <strong class="source-inline">SessionConfig.java</strong> file of this chapter, <span class="No-Break">as </span><span class="No-Break">follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SessionConfig.java
@Bean
public SessionRegistry sessionRegistry(){
    return new SessionRegistryImpl();
}</pre></li> <li>We have already added the import of the <strong class="source-inline">SessionConfig.java</strong> file to the <strong class="source-inline">SecurityConfig.java</strong> file. So, all that we need to do is reference the custom configuration in our <strong class="source-inline">SecurityConfig.java</strong> file. Go ahead and replace the current <strong class="source-inline">sessionManagement</strong> and <strong class="source-inline">maximumSessions</strong> configurations with <a id="_idIndexMarker995"/>the following <span class="No-Break">code snippet:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
http.sessionManagement(session -&gt; session.maximumSessions(-1)
        .sessionRegistry(sessionRegistry)
        .expiredUrl("/login/form?expired")
        .maxSessionsPreventsLogin(true));</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter14.05-calendar</strong></span><span class="No-Break">.</span></p>
<p>Now, our application will allow an unlimited number of authentications for the same user. However, we can use <strong class="source-inline">SessionRegistry</strong> to forcibly log out the users. Let’s see<a id="_idTextAnchor468"/> how we can use this information to enhance the security of<a id="_idTextAnchor469"/> <span class="No-Break">our users.</span></p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor470"/>Displaying active sessions for a user</h1>
<p>You’ve probably seen how many websites allow a user to view and forcibly log out sessions for their account. We can easily use this forcible logout functionality to do the same. We have already<a id="_idIndexMarker996"/> provided <strong class="source-inline">UserSessionController</strong>, which obtains the active sessions for the currently logged-in user. You can see the implementation <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/controllers/UserSessionController.java
@Controller
public class UserSessionController {
    private final SessionRegistry sessionRegistry;
    public UserSessionController(SessionRegistry sessionRegistry) {
        this.sessionRegistry = sessionRegistry;
    }
    @GetMapping("/user/sessions/")
    public String sessions(Authentication authentication, ModelMap model) {
        List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions(authentication.getPrincipal(),
                false);
        model.put("sessions", sessions);
        return "user/sessions";
    }
    @PostMapping(value="/user/sessions/{sessionId}")
    public String removeSession(@PathVariable String sessionId, RedirectAttributes redirectAttrs) {
        SessionInformation sessionInformation = sessionRegistry.getSessionInformation(sessionId);
        if(sessionInformation != null) {
            sessionInformation.expireNow();
        }
        redirectAttrs.addFlashAttribute("message", "Session was removed");
        return "redirect:/user/sessions/";
    }
}</pre> <p>Our sessions method will use <a id="_idIndexMarker997"/>a Spring <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) to automatically obtain the current Spring Security <strong class="source-inline">Authentication</strong>. If we were not using a Spring MVC, we could also get the current <strong class="source-inline">Authentication</strong> from <strong class="source-inline">SecurityContextHolder</strong>, as discussed in <a href="B21757_03.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Custom Authentication</em>. The principal is then used to obtain all the <strong class="source-inline">SessionInformation</strong> objects for the current user. The information is<a id="_idIndexMarker998"/> easily displayed by iterating over the <strong class="source-inline">SessionInformation</strong> objects in our <strong class="source-inline">sessions.xhtml</strong> file, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/resources/templates/user/sessions.xhtml
…
&lt;tr th:each="currentSession : ${sessions}"&gt;
    &lt;td th:text="${#calendars.format(currentSession.lastReques, 'yyyy-MM-dd HH:mm')}"&gt;lastUsed&lt;/td&gt;
    &lt;td th:text="${currentSession.sessionId}"&gt;&lt;/td&gt;
    &lt;td&gt;
        &lt;form action="#" th:action="@{'/user/sessions/{id}'(id=${currentSession.sessionId)}"
              th:method="post" cssClass="form-horizon"al"&gt;
            &lt;input type="sub"it" value="Del"te" class=""tn"/&gt;
        &lt;/form&gt;
    &lt;/td&gt;
&lt;/tr&gt;
...</pre> <p>You can now safely start the JBCP calendar application and log in to it using <strong class="source-inline">user1@example.com/user1</strong> in Google Chrome. Now, log in using Firefox and click on the <strong class="source-inline">user1@example.com</strong> link in the<a id="_idIndexMarker999"/> upper-right corner. You will then see both sessions listed on the display, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<img alt="Figure 14.9 – A list of available sessions" height="411" src="image/B21757_14_9.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – A list of available sessions</p>
<p>While in Firefox, click on the <strong class="bold">Delete</strong> button for the first session. This sends the request to our <strong class="source-inline">deleteSession</strong> method of <strong class="source-inline">UserSessionsController</strong>. This indicates that the session should be terminated. Now, navigate to any page within Google Chrome. You will see the custom message saying that the session has been forcibly terminated. While the message could use updating, we see that this is a nice feature for users to terminate other <span class="No-Break">active sessions.</span></p>
<p>Other possible uses include allowing an administrator to list and manage all active sessions, displaying the number of active users on the site, or even extending the <a id="_idTextAnchor471"/>information to include things<a id="_idIndexMarker1000"/> like an IP address or <span class="No-Break">location information.</span></p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor472"/>How Spring Security use the HttpSession method?</h2>
<p>We have already discussed how<a id="_idIndexMarker1001"/> Spring Security uses <strong class="source-inline">SecurityContextHolder</strong> to determine the currently logged-in user. However, we have not explained how <strong class="source-inline">SecurityContextHolder</strong> gets automatically populated by Spring Security. The secret to this lies in the <strong class="source-inline">o.s.s.web.context.SecurityContextPersistenceFilter</strong> filter and the <strong class="source-inline">o.s.s.web.context.SecurityContextRepository</strong> interface. Let’s take a look at the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<img alt="Figure 14.10 – Spring Security usage of the HttpSession" height="571" src="image/B21757_14_10.jpg" width="1158"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – Spring Security usage of the HttpSession</p>
<p>Here is an explanation for each step shown in the <span class="No-Break">preceding diagram:</span></p>
<ol>
<li>At the beginning of each web request, <strong class="source-inline">SecurityContextPersistenceFilter</strong> is responsible for obtaining the current <strong class="source-inline">SecurityContext</strong> implementation <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">SecurityContextRepository</strong></span><span class="No-Break">.</span></li>
<li>Immediately afterward, <strong class="source-inline">SecurityContextPersistenceFilter</strong> sets <strong class="source-inline">SecurityContext</strong> <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">SecurityContextHolder</strong></span><span class="No-Break">.</span></li>
<li>For the remainder of the web request, <strong class="source-inline">SecurityContext</strong> is available via <strong class="source-inline">SecurityContextHolder</strong>. For example, if a Spring MVC controller or <strong class="source-inline">CalendarService</strong> wanted to access <strong class="source-inline">SecurityContext</strong>, it could use <strong class="source-inline">SecurityContextHolder</strong> to <span class="No-Break">access it.</span></li>
<li>Then, at the end of each<a id="_idIndexMarker1002"/> request, <strong class="source-inline">SecurityContextPersistenceFilter</strong> gets the <strong class="source-inline">SecurityContext</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">SecurityContextHolder</strong></span><span class="No-Break">.</span></li>
<li>Immediately afterward, <strong class="source-inline">SecurityContextPersistenceFilter</strong> saves <strong class="source-inline">SecurityContext</strong> in <strong class="source-inline">SecurityContextRepository</strong>. This ensures that if <strong class="source-inline">SecurityContext</strong> is updated at any point during the web requests (that is, when a user creates a new account, as done in <a href="B21757_03.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Custom Authentication</em>), <strong class="source-inline">SecurityContext</strong> <span class="No-Break">is saved.</span></li>
<li>Lastly, <strong class="source-inline">SecurityContextPersistenceFilter</strong> <span class="No-Break">clears </span><span class="No-Break"><strong class="source-inline">SecurityContextHolder</strong></span><span class="No-Break">.</span></li>
</ol>
<p>The question that now arises: How is this related to <strong class="source-inline">HttpSession</strong>? This is all tied together by the default <strong class="source-inline">SecurityContextRepository</strong> implementation, which <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">HttpSession</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor473"/>The HttpSessionSecurityContextRepository interface</h2>
<p>The default implementation <a id="_idIndexMarker1003"/>of <strong class="source-inline">SecurityContextRepository</strong>, <strong class="source-inline">o.s.s.web.context.HttpSessionSecurityContextRepository</strong>, uses <strong class="source-inline">HttpSession</strong> to retrieve and store the current <strong class="source-inline">SecurityContext </strong>implementation. There are no other <strong class="source-inline">SecurityContextRepository </strong>implementations provided out of the box. However, since the usage of <strong class="source-inline">HttpSession </strong>is abstracted behind the <strong class="source-inline">SecurityContextRepository</strong> interface, we could easily write our own implementation if <span class="No-Break">we desired.</span></p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor474"/>Configuring how Spring Security uses HttpSession</h2>
<p>Spring Security has the ability to configure when the session is created by Spring Security. This can be done with the <strong class="source-inline">http</strong> element’s <strong class="source-inline">create-session</strong> attribute. A <a id="_idIndexMarker1004"/>summary of the options can be seen in the <span class="No-Break">following table:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-6">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Attribute value</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ifRequired</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Spring Security will create a session only if one is required (the <span class="No-Break">default value).</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">always</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Spring Security will proactively create a session if one does <span class="No-Break">not exist.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">never</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Spring Security will never create a session but will make use of one if the application does create it. This means that if there is a <strong class="source-inline">HttpSession</strong> method, <strong class="source-inline">SecurityContext</strong> will be persisted or retrieve <span class="No-Break">from it.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">stateless</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Spring Security will not create a session and will ignore the session for obtaining a Spring <strong class="source-inline">Authentication</strong>. In such instances, <strong class="source-inline">NullSecurityContextRepository</strong> is used, which will always state that the current <strong class="source-inline">SecurityContext</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.2 – The session-fixation-protection options</p>
<p>In practice, controlling session creation can be more difficult than it first appears. This is because the attributes only control a subset of Spring Security’s usage of <strong class="source-inline">HttpSession</strong>. It does not apply to any other components, such as <strong class="bold">Java Server Pages</strong> (<strong class="bold">JSPs</strong>), in the application. To<a id="_idIndexMarker1005"/> help figure out when the <strong class="source-inline">HttpSession</strong> method was created, we can add Spring <span class="No-Break">Security’s </span><span class="No-Break"><strong class="source-inline">DebugFilter</strong></span><span class="No-Break">.</span><a id="_idTextAnchor475"/><a id="_idTextAnchor476"/></p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor477"/>Debugging with Spring Security’s DebugFilter</h2>
<p>Let’s take a look at the following steps and learn about how to <a id="_idIndexMarker1006"/>debug with <strong class="source-inline">DebugFilter</strong> of <span class="No-Break">Spring Security:</span></p>
<ol>
<li>Update your <strong class="source-inline">SecurityConfig.java</strong> file to have a session policy of <strong class="source-inline">NEVER</strong>. Also, add the <strong class="source-inline">debug</strong> flag to <strong class="source-inline">true</strong> on the <strong class="source-inline">@EnableWebSecurity</strong> annotation so that we can track when the session was created. The updates can be seen <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity(debug = true)
public class SecurityConfig {
...
http.sessionManagement(session -&gt; session
       .sessionCreationPolicy(SessionCreationPolicy.NEVER)
       .maximumSessions(-1)
       .sessionRegistry(sessionRegistry)
       .expiredUrl("/login/form?expired")
       .maxSessionsPreventsLogin(true));</pre></li> <li>When you start up the application, you should see something similar to the following code written to standard output. If you have not already, ensure that you have logging enabled across all levels of the Spring Security <span class="No-Break">debugger category:</span><pre class="source-code">
******************************************************
*******   Security debugging is enabled.        ******
*******  This may include sensitive information.******
*******  Do not use in a production system!     ******</pre></li> <li>Now, clear out your cookies (this can be done in Firefox with <em class="italic">Shift + Ctrl + Delete</em>), start up the application, and navigate directly to <strong class="source-inline">http://localhost:8080</strong>. When we look at the cookies, as we did earlier in the chapter, we can see that <strong class="source-inline">JSESSIONID</strong> is created even though we stated that Spring Security should never create <strong class="source-inline">HttpSession</strong>. Look at the logs again, and you will see a <a id="_idIndexMarker1007"/>call stack of the code that created <strong class="source-inline">HttpSession</strong> <span class="No-Break">as follows:</span><pre class="source-code">
******************************************************
2024-02-02T20:17:27.859+01:00  INFO 54253 --- [nio-8080-exec-1] Spring Security Debugger                :
******************************************************
New HTTP session created: 8C85C6E21D976ED6A1EDE2F8877EB227</pre></li> </ol>
<p>There are several other uses for <strong class="source-inline">DebugFilter</strong>, which we encourage you to explore on your own, for example, determining when a request will match a particular URL, which Spring Security filters are being invoked, and <span class="No-Break">so on.</span></p>
<h1 id="_idParaDest-314"><a id="_idTextAnchor478"/>Summary</h1>
<p>After reading this chapter, you should be familiar with how Spring Security manages sessions and protects against session fixation attacks. We also know how to use Spring Security’s concurrency control to prevent the same user from being authenticated <span class="No-Break">multiple times.</span></p>
<p>We explored the utilization of concurrency control to allow a user to terminate sessions associated with their account. Also, we saw how to configure Spring Security’s creation of sessions. We also covered how to use Spring Security’s <strong class="source-inline">DebugFilter</strong> filter to troubleshoot issues related <span class="No-Break">to Spring.</span></p>
<p>We also learned about security, including determining when a <strong class="source-inline">HttpSession</strong> method was created and the cause <span class="No-Break">of it.</span></p>
<p>This concludes our discussion about Spring Security’s session management. In the next chapter, we will discuss some specifics about integrating Spring Security with <span class="No-Break">other frameworks.</span></p>
</div>
</div></body></html>