- en: Handling Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resilience is an important aspect of reactive systems. As per the Reactive Manifesto,
    a reactive system must remain responsive during failure. The system must handle
    errors gracefully, and generate a user response in a timely manner. This cannot
    be accomplished without an effective error handling mechanism. Reactor offers
    a number of operators to handle errors. In this chapter, we will look at each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeout and retry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebClient error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Standard Edition, JDK 8 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA IDE, 2018.1 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Generating errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we try to handle errors, let''s first try to raise a few. In Java ecosystems,
    error conditions are raised by throwing exceptions. Exceptions can be raised under
    the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The producer can throw an exception while generating the next value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscriber can throw an exception while processing the next value or subscription
    event, or in any operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In all of the preceding conditions, there must be an effective procedure for
    handling the error raised. Reactive Streams prescribe the error event for the
    same purpose. The specification states that a producer should raise an error event,
    instead of throwing an exception. However, the specification does not discuss
    exceptions raised while processing events in the subscriber. Let''s start to work
    on our Fibonacci series, to understand how error handling happens in Reactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test case, the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: The generator implementation throws `RuntimeException` when the value becomes
    negative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we compare this to the original implementation, created in [Chapter 2](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml)
    , *The Publisher and Subscriber APIs in a Reactor*, we are no longer raising a
    completion event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no error function configured in the subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the test case to see how the Reactor responds, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c901d86-36df-49af-baa0-69a51cd7d7e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding execution, you can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All positive values are first printed to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exception thrown is propagated to the subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subscriber raises the `ErrorCallbackNotImplemented` exception, since no
    error function was configured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exception failed the test case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding test execution, please note that we did not raise an error
    event. However, Reactor raised the error event when the exception was thrown.
    The event was then handled at the subscriber end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s enhance our test case and raise an error while processing events
    in the subscriber, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code now does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configures a lambda, instead of the `System.out.println` function, in the event
    handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The lambda throws a `RuntimeException`, instead of printing numbers to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run the preceding test case, the output will be similar to our previous
    execution. The test case will fail, with the following stacktrace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding two pieces of output, we can say that Reactor handles
    exceptions thrown by the producer and the subscriber in the same manner. A subscriber
    must provide an error function to allow the Reactive Streams to finish successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more scenario left. Instead of throwing `RuntimeException` in the
    producer, we must raise an error event. This can be accomplished by replacing
    the `throw new RuntimeException` with `sink.error(e)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I will leave it to the reader to determine the output of the preceding test
    case. All of the test cases discussed have failed, due to a missing error callback
    handler. Consequently, we must define an error function for the subscriber. This
    can be accomplished by passing an additional lambda function in the `subscriber()`
    API. For this, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have passed the `println` function in both the consumer
    and error consumer events. As a result, the subscriber will print both events
    to the console. Now, run all of our previously failing test cases; they will print
    the error to the console, and then finish successfully. This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84983939-28e9-4ad5-996a-426a28372225.png)'
  prefs: []
  type: TYPE_IMG
- en: Checked exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cannot throw checked exceptions from the producer and the subscriber. Each
    of the respective Reactor methods take a `Consumer` function, without any exception
    declarations. So, the implementations cannot throw it. However, there are scenarios
    where the producer invokes resources, such as files, which can throw checked exceptions.
    Reactor provides the `Exceptions` utility class for handling such scenarios. The
    `Exceptions` class provides a `propagate` method, which can wrap any checked exception
    into an unchecked exception, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checked that the `IOException` is thrown by the `raiseCheckedException` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Used `Exception.propagate` to wrap the exception and throw it back
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Used `Exception.unwrap` to get the original checked exception
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's begin with some `try...catch` error types.
  prefs: []
  type: TYPE_NORMAL
- en: The doOnError hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed life cycle hooks in [Chapter 2](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml),
    *The Publisher and Subscriber APIs in a Reactor.* These can be used to configure
    callbacks for every life cycle event. Reactor provides the life cycle error callback
    hook to configure the error handler. The `doOnError` hook allows us to consume
    an error and perform the intended function. If we have configured the `doOnError`
    hook along with the error callback, then both will be invoked simultaneously by
    Reactor. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configures the `println` function in the `doOnError` hook. This function prints
    the error to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configures on error lambda in the subscriber API. The implementation prints
    the stacktrace of the thrown exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the preceding test case and validate the output printed on the console.
    Both error functions are invoked simultaneously, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bbfbc37-de16-4d79-ac66-c8908cac0ec5.png)'
  prefs: []
  type: TYPE_IMG
- en: The doOnTerminate hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `doOnError` life cycle hook, there is the `doOnTerminate` hook.
    This is a generic hook that is invoked for `on completion` and `on error` stream
    termination events. Unlike the specific error hook, which provides the exception
    thrown, this hook does not provide any kind of input. It just executes the lambda
    provided. It is important to note that the `doOnTerminate` hook is invoked as
    soon as we receive termination events. It does not wait for the error callback
    to be processed. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configures the `println` function in the `doOnTerminate` hook. This function
    prints `Terminated` to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configures an error lambda in the subscriber API. This implementation prints
    the stacktrace of the thrown exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the preceding test case and validate the output printed on the console.
    Both functions are invoked simultaneously, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7998c695-4ad2-4d86-8687-50fb2c29f869.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the `doOnTerminate` life cycle hook, there is a `doAfterTerminate`
    life cycle hook. This hook is invoked after the close events have been delivered
    to the subscriber. Just like the `doOnTerminate` hook, `doAfterTerminate` is a
    generic hook that does not provide any events. Since the hook is invoked after
    the events are delivered, it requires error callback subscriber configuration.
    If we do not provide this, the stream fails with an `ErrorCallbackNotImplemented`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: The doFinally hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `doOnError` life cycle hook, there is the `doFinally` hook.
    This hook is invoked post-stream completion. The hook executes the lambda provided.
    It is important to note that the `doFinally` hook is invoked post-stream close
    callback processing, unlike the previously discussed `doOnTerminate` hook, which
    is invoked as soon as we received the close events. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fibonacciGenerator` raises an error on a negative value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It configures the `println` function in the `doFinally` hook. The function prints
    `invoking finally` to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It configures on error lambda in the subscriber API. The implementation prints
    the stacktrace of the thrown exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the preceding test case and validate the output printed on the console,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81cb7987-b2d3-49f0-afc0-3ceaba650c48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As an alternative to the `doFinally` hook, there is the `Flux.using` API. This
    API configures a resource mapped for a publisher. It also configures a callback
    lambda, which is invoked with the respective publisher resource upon stream closure.
    This is synonymous with the `try-with-resource` Java API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It generates a `Flux<Long>` by invoking the `Using` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It maps a `closable` instance to an instance of `fibonacciGenerator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It invokes the `close` method upon stream completion. The `close` method can
    raise checked exceptions, so `Exceptions.propagate` is used to wrap the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the preceding test case and validate the output printed on the console,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2e6c2e5-8330-4f32-bed9-3d783e5b25dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Error recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we determined how to configure an error callback.
    However, when performing error handling, we may encounter cases in which we want
    to continue execution with some alternative values. There are many use cases for
    such scenarios. For example, quote aggregating systems can have errors thrown
    while getting the latest tick value, but the aggregation must continue with the
    last value. In the following sections, we will cover each of the operators offered,
    in order to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: The onErrorReturn operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor provides the `OnErrorReturn` operator to provide a fallback value in
    the event of an error. As a result of the fallback, the original error event is
    not propagated to the error callback. The event processing continues by using
    the event handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `onErrorReturn` operator is used to provide `0` when an error is received
    by the subscriber
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No error callback is configured in the subscriber API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run our test case and validate the understanding of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3514975b-60f9-4b78-a63a-91be791d5f4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `onErrorReturn` operator also provides exception-specific handling. This
    is an overloaded method that takes the exception class, as well as a fallback
    value. Reactor picks the first match it finds by validating whether or not the
    exception thrown is an instance of the exception configured. Consequently, we
    must configure the most specific exception matches first, and the most generic
    ones last. Now, let''s write a test case to validate the exception handling, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are now throwing `IllegalStateException`, instead
    of `RuntimeException`. `IllegalStateException` is a sub-type of `RuntimeException`.
    The subscriber is configured for both of these exceptions. It is important to
    note the order of the configuration here. `RuntimeException` has been configured
    first, with a default value of `0`, and the `IllegalStateException` with the value
    `-1`. Reactor will match the thrown exception against `RuntimeException`. Run
    the test case and validate the result here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is also an `onErrorReturn`, which matches the exception by validating
    it against the predicate provided. The configured predicate takes the exception
    thrown as input, and provides a Boolean result in return. Here, we also configure
    multiple predicates. Reactor will pick the first matching predicate and use its
    fallback value.
  prefs: []
  type: TYPE_NORMAL
- en: The onErrorResume operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `OnErrorReturn` operator, there is the `OnErrorResume` operator,
    which provides a fallback value stream instead of a single fallback value. In
    the event of an error, the fallback stream is returned. The original error event
    is not propagated to the error callback. The event processing continues by using
    the configured event handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `onErrorResume` operator is used to provide back `Flux<Long>` when any error
    is received by the subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No error callback is configured in the subscriber API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run our test case and validate our understanding, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08af6ed3-12ff-4667-aa08-d02f063d92e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the lines of `onErrorReturn`, the `onErrorResume` operator is overloaded
    to provide specific, exception-based fallback values. Exceptions can be provided
    directly, or can be matched using a predicate. Reactor will pick the value that
    matches first.
  prefs: []
  type: TYPE_NORMAL
- en: The onErrorMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactor's `onErrorMap` operator allows us to convert an exception of one type
    to another type. Unlike the previous two operators, the `onErrorMap` operator
    requires an error callback to be configured with the subscriber. If no handler
    is configured, the subscriber throws back an `ErrorCallbackNotImplemented` exception.
    The `onErrorMap` operator provides overloaded functions, similar to the previous
    operators, which can be used to match exceptions based on type or a provided predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build a simple test case to validate our understanding of the `onErrorMap`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `onErrorMap` operator is configured to throw `IllegalStateException` when
    any error is received by the subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The error callback was configured in the subscriber API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run it and confirm the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da1c8b8a-3d7b-4806-941b-57daf3042657.png)'
  prefs: []
  type: TYPE_IMG
- en: Timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the preceding sections, generating a timely response is an important
    aspect of reactive systems. The requirement means that reactive systems must provide
    a deterministic response in a timely manner. However, all software systems are
    inherently unreliable. The underlying network itself is unreliable. All components
    can fail without providing a response. As a result, systems with streaming results
    can get stuck waiting for a response.
  prefs: []
  type: TYPE_NORMAL
- en: A way to address this unreliability is to adapt the fail-fast system design.
    This design dictates that a system makes some assumptions for normal operations,
    and it must fail as soon as these assumptions are broken. This leads to the early
    reporting of likely issues. In order to do this, we must assume a likely response
    time, the most common fail-fast metric. If the response is not received in this
    time, then the system must trigger the fallback/error response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactor offers the `timeout()` operator to enable a response time check. The
    timeout fails when there is no response received in the specific time interval.
    Once the timeout expires, it triggers the error callback configured for the subscriber.
    Let''s validate the operator by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `delayElements` operator is responsible for slowing down each element by
    the configured time. In our case, it sends each element after a one second delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `timeout()` operator is configured for an interval of `500` milliseconds.
    This operator will raise an error when it first discovers a delay of more than
    `500` milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onError` callback is configured for the subscriber. We also added a `CountDownLatch`,
    as we want to hold the test execution until the error is received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run this and confirm the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dbff4db-7bda-4550-8e2f-36f855580b32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `timeout()` operator also offers to provide a fallback `Flux<>` value when
    the timeout is triggered. In this case, the fallback value does not throw a timeout
    error. Consequently, it does not trigger the configured error callbacks. Instead,
    the flow is executed as next events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `delayElements` operator is responsible for slowing down each element by
    the configured time. In our case, it sends each element after a one second delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `timeout()` operator is configured for an interval of `500` milliseconds.
    This operator will raise an error when it first discovers a delay of more than
    `500` milliseconds. The operator also has a fallback Flux. The fallback value
    is returned once the timeout expires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onNext` handler is configured to print the received value. We added a `CountDownLatch`,
    as we want to hold the test execution until the value is received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no `onError` callback configured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run it and validate the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0e52e9c-04fb-49dd-b0e9-2c755a5b72e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While we are discussing errors and timeouts, it is important to mention the
    `retry` operator. This operator allows us to re-subscribe to the published stream
    when an error is discovered. The retry can only be performed a fixed number of
    times. The re-subscribed events are handled as next events by the subscriber.
    If the stream completes normally, no next retry takes place. Error callback is
    only triggered when an error is thrown during the last retry cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `delayElements` operator is responsible for slowing down each element by
    the configured time. In our case, it sends each element after a one second delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `timeout()` operator is configured for an interval of `500` milliseconds.
    The operator will raise an error when it first discovers a delay of more than
    `500` milliseconds. The operator also has a fallback Flux. The fallback value
    is returned once the timeout expires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onNext` handler is configured to print the received value. We added a `CountDownLatch`,
    as we want to hold the test execution until the value is received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No `onError` callback is configured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run it and validate the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aca7cc62-8f7a-421c-811e-053c081e069e.png)'
  prefs: []
  type: TYPE_IMG
- en: WebClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](5e6f3f39-3172-4cde-9e50-d4892791d847.xhtml), *Dynamic Rendering*,
    we discussed using the Spring WebClient to make web calls in a non-blocking and
    asynchronous manner. The operators that we have discussed so far are applicable
    to Reactive Stream publishers and subscribers. WebClient also produces a Mono
    publisher of `ServerResponse`. So, how should we handle errors generated in WebClient,
    and generate a valid response? First, let''s take a look at WebClient''s default
    handling of server-side errors. To do this, we should first generate errors in
    our Fibonacci handler function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we modified our generator to raise a `RuntimeException`.
    The exception will be raised as soon as the server builds a response. This, in
    turn, sends the HTTP 500 status error back, with the exception message in the
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93510c10-e8b0-4f22-8f92-8b9b18d8ff78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we can raise an error using the `sink.error()` method. This
    method will take an exception instance and throw it back. It will also raise a
    500 status code, with an `out of bound` error message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will invoke the preceding URL by using WebClient so as to understand its
    default behavior. Let''s revisit the WebClient sample from [Chapter 6](5e6f3f39-3172-4cde-9e50-d4892791d847.xhtml),
    *Dynamic Rendering*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: We invoked the `/fibonacci` URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We converted the body, using the `retrieve` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the limit operator to select 10 results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, the results were printed to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that there is no explicit error handler configured; run the code to see
    how it responds. The code does not generate any output or convert the body when
    it receives error status codes from the server. Alternatively, let''s configure
    an error handler in the subscriber method and print the exception, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute the WebClient code to determine the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, this time around, we can see a `WebClientResponseException`,
    with the status code as an error message. If we look at the `WebClientResponseException`
    class, the exception allows us to get the response text, status code, and more.
    Typecasting the error and printing the response text would generate the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note the behavior of the WebClient API. Although the stream
    generated an error, we never saw the `ErrorCallbackNotImplemented` exception,
    unlike the behavior of Reactive Stream subscribers without a configured error
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebClient works well with the `onError` operators that were discussed in the
    previous sections. We can configure either `onErrorReturn` or `onErrorResume`
    operators. This would provide fallback values, which are returned in the case
    of an error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute the preceding code and confirm the fallback values in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the WebClient that retrieves an API also offers an `onStatus` method
    to configure response handling. The `onStatus` method takes exception mapping
    and invokes it for the configured HTTP status codes. In our preceding sample,
    let''s try to throw a `RuntimeException` for a 500 server response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RuntimeException` is raised as `Mono.error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mono is configured for all HTTP error status codes (`4XX`, `5XX`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the preceding code is executed, a `RuntimeException` is thrown. However,
    the exception leads to an `ErrorCallbackNotImplemented` exception, unlike the
    previous behavior, where `WebClientResponseException` did not ask for an exception
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can configure exception mapping or a fallback value provider to recover
    from the thrown exception.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the various ways to add resilience to our application.
    First, we covered possible error scenarios involving the producer and the subscriber.
    Next, we looked at how Reactor performs error handling under each of those conditions.
    This enabled us to configure the required error handling in Reactor, by using
    the various operations that are offered. Reactor allows us to configure fallback
    values for the thrown exceptions by using `onErrorReturn` and `onErrorResume`
    operators. We also configured timeouts and retry machines, using the available
    operators, in order to generate timely responses. Finally, we configured error
    handling in WebClient. In a nutshell, we explored the possible ways to configure
    error handlers in Reactor.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How is an error handled in Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which operators allow us to configure error handling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `onErrorResume` and `onErrorReturn`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we generate a timely response for a Reactive Stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the `retry` operator behave?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
