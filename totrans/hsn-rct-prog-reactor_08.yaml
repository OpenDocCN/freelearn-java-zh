- en: Handling Errors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: Resilience is an important aspect of reactive systems. As per the Reactive Manifesto,
    a reactive system must remain responsive during failure. The system must handle
    errors gracefully, and generate a user response in a timely manner. This cannot
    be accomplished without an effective error handling mechanism. Reactor offers
    a number of operators to handle errors. In this chapter, we will look at each
    of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是响应式系统的一个重要方面。根据响应式宣言，响应式系统必须在失败期间保持响应。系统必须优雅地处理错误，并及时生成用户响应。没有有效的错误处理机制是无法实现的。Reactor提供了一些操作符来处理错误。在本章中，我们将查看每个操作符。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Handling errors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: Error operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误操作符
- en: Timeout and retry
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时和重试
- en: WebClient error handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebClient错误处理
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE, 2018.1 or above
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE，2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter08).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub链接为[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter08)。
- en: Generating errors
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成错误
- en: 'Before we try to handle errors, let''s first try to raise a few. In Java ecosystems,
    error conditions are raised by throwing exceptions. Exceptions can be raised under
    the following conditions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试处理错误之前，让我们先尝试引发一些错误。在Java生态系统中，错误条件是通过抛出异常来引发的。以下条件下可以引发异常：
- en: The producer can throw an exception while generating the next value.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者在生成下一个值时可以抛出异常。
- en: The subscriber can throw an exception while processing the next value or subscription
    event, or in any operators.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者在处理下一个值或订阅事件，或在任何操作符中时可以抛出异常。
- en: 'In all of the preceding conditions, there must be an effective procedure for
    handling the error raised. Reactive Streams prescribe the error event for the
    same purpose. The specification states that a producer should raise an error event,
    instead of throwing an exception. However, the specification does not discuss
    exceptions raised while processing events in the subscriber. Let''s start to work
    on our Fibonacci series, to understand how error handling happens in Reactor:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有上述条件下，必须有一个有效的错误处理程序来处理引发的错误。响应式流规范为同一目的指定了错误事件。规范指出，生产者应引发错误事件，而不是抛出异常。然而，规范没有讨论在处理订阅者中的事件时引发的异常。让我们开始处理我们的斐波那契数列，以了解Reactor中的错误处理是如何发生的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding test case, the following occurs:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试用例中，发生以下情况：
- en: The generator implementation throws `RuntimeException` when the value becomes
    negative.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器实现当值变为负数时抛出`RuntimeException`。
- en: If we compare this to the original implementation, created in [Chapter 2](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml)
    , *The Publisher and Subscriber APIs in a Reactor*, we are no longer raising a
    completion event.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将此与第2章中创建的原始实现进行比较，[《Reactor中的发布者和订阅者API》](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml)，我们现在不再引发完成事件。
- en: There is no error function configured in the subscriber.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者中没有配置错误函数。
- en: 'Let''s run the test case to see how the Reactor responds, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试用例以查看Reactor如何响应，如下所示：
- en: '![](img/1c901d86-36df-49af-baa0-69a51cd7d7e9.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c901d86-36df-49af-baa0-69a51cd7d7e9.png)'
- en: 'In the preceding execution, you can see the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的执行中，你可以看到以下情况：
- en: All positive values are first printed to the console.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有正数值首先打印到控制台。
- en: The exception thrown is propagated to the subscriber.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出的异常被传播到订阅者。
- en: The subscriber raises the `ErrorCallbackNotImplemented` exception, since no
    error function was configured.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有配置错误函数，订阅者引发`ErrorCallbackNotImplemented`异常。
- en: The exception failed the test case.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异常导致测试用例失败。
- en: In the preceding test execution, please note that we did not raise an error
    event. However, Reactor raised the error event when the exception was thrown.
    The event was then handled at the subscriber end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试执行中，请注意我们没有引发错误事件。然而，当抛出异常时，Reactor 引发了错误事件。然后该事件在订阅者端被处理。
- en: 'Now, let''s enhance our test case and raise an error while processing events
    in the subscriber, with the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们增强我们的测试用例，并在处理订阅者中的事件时引发错误，以下代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code now does the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码现在执行以下操作：
- en: Configures a lambda, instead of the `System.out.println` function, in the event
    handler.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件处理器中配置一个lambda，而不是`System.out.println`函数。
- en: The lambda throws a `RuntimeException`, instead of printing numbers to the console.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda抛出`RuntimeException`，而不是将数字打印到控制台。
- en: 'If we run the preceding test case, the output will be similar to our previous
    execution. The test case will fail, with the following stacktrace:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的测试案例，输出将与我们之前的执行相似。测试案例将失败，以下为堆栈跟踪：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Looking at the preceding two pieces of output, we can say that Reactor handles
    exceptions thrown by the producer and the subscriber in the same manner. A subscriber
    must provide an error function to allow the Reactive Streams to finish successfully.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的两段输出，我们可以说Reactor以相同的方式处理生产者和订阅者抛出的异常。订阅者必须提供一个错误函数，以便Reactive Streams能够成功完成。
- en: 'We have one more scenario left. Instead of throwing `RuntimeException` in the
    producer, we must raise an error event. This can be accomplished by replacing
    the `throw new RuntimeException` with `sink.error(e)`, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个场景尚未处理。在生产者中，我们不是抛出`RuntimeException`，而是必须引发一个错误事件。这可以通过将`throw new RuntimeException`替换为`sink.error(e)`来实现，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I will leave it to the reader to determine the output of the preceding test
    case. All of the test cases discussed have failed, due to a missing error callback
    handler. Consequently, we must define an error function for the subscriber. This
    can be accomplished by passing an additional lambda function in the `subscriber()`
    API. For this, consider the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把确定前一个测试案例输出的任务留给读者。所有讨论过的测试案例都失败了，因为缺少错误回调处理程序。因此，我们必须为订阅者定义一个错误函数。这可以通过在`subscriber()`
    API中传递一个额外的lambda函数来实现。为此，请考虑以下代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we have passed the `println` function in both the consumer
    and error consumer events. As a result, the subscriber will print both events
    to the console. Now, run all of our previously failing test cases; they will print
    the error to the console, and then finish successfully. This is shown in the following
    screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在消费者和错误消费者事件中传递了`println`函数。因此，订阅者将同时将这两个事件打印到控制台。现在，运行我们之前失败的测试案例；它们将错误打印到控制台，然后成功完成。这如图所示：
- en: '![](img/84983939-28e9-4ad5-996a-426a28372225.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84983939-28e9-4ad5-996a-426a28372225.png)'
- en: Checked exceptions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查异常
- en: 'We cannot throw checked exceptions from the producer and the subscriber. Each
    of the respective Reactor methods take a `Consumer` function, without any exception
    declarations. So, the implementations cannot throw it. However, there are scenarios
    where the producer invokes resources, such as files, which can throw checked exceptions.
    Reactor provides the `Exceptions` utility class for handling such scenarios. The
    `Exceptions` class provides a `propagate` method, which can wrap any checked exception
    into an unchecked exception, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能从生产者和订阅者抛出检查异常。每个相应的Reactor方法都接受一个没有异常声明的`Consumer`函数。因此，实现不能抛出它。然而，存在一些场景，其中生产者调用资源，如文件，这些资源可以抛出检查异常。Reactor提供了`Exceptions`实用类来处理这些场景。`Exceptions`类提供了一个`propagate`方法，可以将任何检查异常包装为非检查异常，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we did the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Checked that the `IOException` is thrown by the `raiseCheckedException` method
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`raiseCheckedException`方法是否抛出`IOException`
- en: Used `Exception.propagate` to wrap the exception and throw it back
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Exception.propagate`包装异常并将其抛回
- en: Used `Exception.unwrap` to get the original checked exception
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Exception.unwrap`获取原始的检查异常
- en: Next, let's begin with some `try...catch` error types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从一些`try...catch`错误类型开始。
- en: The doOnError hook
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doOnError钩子
- en: 'We discussed life cycle hooks in [Chapter 2](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml),
    *The Publisher and Subscriber APIs in a Reactor.* These can be used to configure
    callbacks for every life cycle event. Reactor provides the life cycle error callback
    hook to configure the error handler. The `doOnError` hook allows us to consume
    an error and perform the intended function. If we have configured the `doOnError`
    hook along with the error callback, then both will be invoked simultaneously by
    Reactor. The following code shows this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml)中讨论了生命周期钩子，*Reactor中的发布者和订阅者API*。这些可以用于为每个生命周期事件配置回调。Reactor提供了生命周期错误回调钩子来配置错误处理器。`doOnError`钩子允许我们消费错误并执行预期的功能。如果我们已经配置了`doOnError`钩子和错误回调，那么它们将由Reactor同时调用。以下代码展示了这一点：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code does the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: Configures the `println` function in the `doOnError` hook. This function prints
    the error to the console.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`doOnError`钩子中配置`println`函数。此函数将错误打印到控制台。
- en: Configures on error lambda in the subscriber API. The implementation prints
    the stacktrace of the thrown exception.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订阅者API中配置错误lambda。实现打印抛出的异常的堆栈跟踪。
- en: 'Let''s run the preceding test case and validate the output printed on the console.
    Both error functions are invoked simultaneously, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的测试用例并验证控制台上打印的输出。两个错误函数同时被调用，如下所示：
- en: '![](img/7bbfbc37-de16-4d79-ac66-c8908cac0ec5.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7bbfbc37-de16-4d79-ac66-c8908cac0ec5.png)'
- en: The doOnTerminate hook
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`doOnTerminate`钩子'
- en: 'Similar to the `doOnError` life cycle hook, there is the `doOnTerminate` hook.
    This is a generic hook that is invoked for `on completion` and `on error` stream
    termination events. Unlike the specific error hook, which provides the exception
    thrown, this hook does not provide any kind of input. It just executes the lambda
    provided. It is important to note that the `doOnTerminate` hook is invoked as
    soon as we receive termination events. It does not wait for the error callback
    to be processed. Consider the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与`doOnError`生命周期钩子类似，存在`doOnTerminate`钩子。这是一个通用的钩子，在`on completion`和`on error`流终止事件时被调用。与提供异常抛出的特定错误钩子不同，此钩子不提供任何类型的输入。它只是执行提供的lambda表达式。需要注意的是，`doOnTerminate`钩子在我们收到终止事件时立即被调用。它不会等待错误回调被处理。考虑以下代码：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code does the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: Configures the `println` function in the `doOnTerminate` hook. This function
    prints `Terminated` to the console.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`doOnTerminate`钩子中配置`println`函数。此函数将`Terminated`打印到控制台。
- en: Configures an error lambda in the subscriber API. This implementation prints
    the stacktrace of the thrown exception.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订阅者API中配置错误lambda。此实现打印抛出的异常的堆栈跟踪。
- en: 'Let''s run the preceding test case and validate the output printed on the console.
    Both functions are invoked simultaneously, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的测试用例并验证控制台上打印的输出。两个函数同时被调用，如下所示：
- en: '![](img/7998c695-4ad2-4d86-8687-50fb2c29f869.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7998c695-4ad2-4d86-8687-50fb2c29f869.png)'
- en: Similar to the `doOnTerminate` life cycle hook, there is a `doAfterTerminate`
    life cycle hook. This hook is invoked after the close events have been delivered
    to the subscriber. Just like the `doOnTerminate` hook, `doAfterTerminate` is a
    generic hook that does not provide any events. Since the hook is invoked after
    the events are delivered, it requires error callback subscriber configuration.
    If we do not provide this, the stream fails with an `ErrorCallbackNotImplemented`
    exception.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与`doOnTerminate`生命周期钩子类似，存在一个`doAfterTerminate`生命周期钩子。此钩子在将关闭事件传递给订阅者之后被调用。就像`doOnTerminate`钩子一样，`doAfterTerminate`是一个通用的钩子，不提供任何事件。由于钩子在事件传递后被调用，它需要错误回调订阅者配置。如果我们不提供它，流将因`ErrorCallbackNotImplemented`异常而失败。
- en: The doFinally hook
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`doFinally`钩子'
- en: 'Similar to the `doOnError` life cycle hook, there is the `doFinally` hook.
    This hook is invoked post-stream completion. The hook executes the lambda provided.
    It is important to note that the `doFinally` hook is invoked post-stream close
    callback processing, unlike the previously discussed `doOnTerminate` hook, which
    is invoked as soon as we received the close events. Consider the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与`doOnError`生命周期钩子类似，存在`doFinally`钩子。此钩子在流完成之后被调用。钩子执行提供的lambda表达式。需要注意的是，`doFinally`钩子在流关闭回调处理之后被调用，与之前讨论的`doOnTerminate`钩子不同，后者在收到关闭事件时立即被调用。考虑以下代码：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code does the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: '`fibonacciGenerator` raises an error on a negative value.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fibonacciGenerator`在负值上引发错误。'
- en: It configures the `println` function in the `doFinally` hook. The function prints
    `invoking finally` to the console.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在`doFinally`钩子中配置`println`函数。该函数将`invoking finally`打印到控制台。
- en: It configures on error lambda in the subscriber API. The implementation prints
    the stacktrace of the thrown exception.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在订阅者API中配置错误lambda。实现打印抛出的异常的堆栈跟踪。
- en: 'Let''s run the preceding test case and validate the output printed on the console,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的测试用例并验证控制台上打印的输出，如下所示：
- en: '![](img/81cb7987-b2d3-49f0-afc0-3ceaba650c48.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81cb7987-b2d3-49f0-afc0-3ceaba650c48.png)'
- en: 'As an alternative to the `doFinally` hook, there is the `Flux.using` API. This
    API configures a resource mapped for a publisher. It also configures a callback
    lambda, which is invoked with the respective publisher resource upon stream closure.
    This is synonymous with the `try-with-resource` Java API:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`doFinally`钩子的替代，有`Flux.using` API。此API为发布者配置一个资源映射。它还配置了一个回调lambda，当流关闭时，会使用相应的发布者资源调用它。这与Java的`try-with-resource`
    API同义：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code does the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码执行以下操作：
- en: It generates a `Flux<Long>` by invoking the `Using` API.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过调用`Using` API生成一个`Flux<Long>`。
- en: It maps a `closable` instance to an instance of `fibonacciGenerator`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将一个`closable`实例映射到`fibonacciGenerator`的一个实例。
- en: It invokes the `close` method upon stream completion. The `close` method can
    raise checked exceptions, so `Exceptions.propagate` is used to wrap the error.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在流完成时调用`close`方法。`close`方法可能会抛出检查型异常，因此使用`Exceptions.propagate`来包装错误。
- en: 'Let''s run the preceding test case and validate the output printed on the console,
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的测试用例并验证控制台上打印的输出，如下所示：
- en: '![](img/d2e6c2e5-8330-4f32-bed9-3d783e5b25dc.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2e6c2e5-8330-4f32-bed9-3d783e5b25dc.png)'
- en: Error recovery
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误恢复
- en: In the preceding section, we determined how to configure an error callback.
    However, when performing error handling, we may encounter cases in which we want
    to continue execution with some alternative values. There are many use cases for
    such scenarios. For example, quote aggregating systems can have errors thrown
    while getting the latest tick value, but the aggregation must continue with the
    last value. In the following sections, we will cover each of the operators offered,
    in order to accomplish this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们确定了如何配置错误回调。然而，在执行错误处理时，我们可能会遇到我们想要使用一些替代值继续执行的情况。此类场景有众多用例。例如，报价聚合系统在获取最新tick值时可能会抛出错误，但聚合必须使用最后一个值继续。在接下来的章节中，我们将介绍每个提供的算子，以便完成此操作。
- en: The onErrorReturn operator
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onErrorReturn`算子'
- en: 'Reactor provides the `OnErrorReturn` operator to provide a fallback value in
    the event of an error. As a result of the fallback, the original error event is
    not propagated to the error callback. The event processing continues by using
    the event handler, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor提供了`OnErrorReturn`算子，在发生错误时提供回退值。由于回退，原始错误事件不会被传播到错误回调。事件处理通过使用事件处理器继续，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, the following applies:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `onErrorReturn` operator is used to provide `0` when an error is received
    by the subscriber
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`onErrorReturn`算子，当订阅者收到错误时提供`0`。
- en: No error callback is configured in the subscriber API
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者API中没有配置错误回调
- en: 'Let''s run our test case and validate the understanding of the preceding code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试用例并验证对前面代码的理解：
- en: '![](img/3514975b-60f9-4b78-a63a-91be791d5f4e.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3514975b-60f9-4b78-a63a-91be791d5f4e.png)'
- en: 'The `onErrorReturn` operator also provides exception-specific handling. This
    is an overloaded method that takes the exception class, as well as a fallback
    value. Reactor picks the first match it finds by validating whether or not the
    exception thrown is an instance of the exception configured. Consequently, we
    must configure the most specific exception matches first, and the most generic
    ones last. Now, let''s write a test case to validate the exception handling, as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorReturn`算子也提供了针对特定异常的处理。这是一个重载方法，它接受异常类以及一个回退值。Reactor通过验证抛出的异常是否是配置的异常的实例来选择它找到的第一个匹配项。因此，我们必须首先配置最具体的异常匹配，最后配置最通用的异常匹配。现在，让我们编写一个测试用例来验证异常处理，如下所示：'
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we are now throwing `IllegalStateException`, instead
    of `RuntimeException`. `IllegalStateException` is a sub-type of `RuntimeException`.
    The subscriber is configured for both of these exceptions. It is important to
    note the order of the configuration here. `RuntimeException` has been configured
    first, with a default value of `0`, and the `IllegalStateException` with the value
    `-1`. Reactor will match the thrown exception against `RuntimeException`. Run
    the test case and validate the result here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们现在抛出的是`IllegalStateException`，而不是`RuntimeException`。`IllegalStateException`是`RuntimeException`的一个子类型。订阅者被配置为处理这两种异常。在此处需要注意配置的顺序。`RuntimeException`被首先配置，默认值为`0`，而`IllegalStateException`的值为`-1`。Reactor会将抛出的异常与`RuntimeException`进行匹配。在这里运行测试用例并验证结果。
- en: Finally, there is also an `onErrorReturn`, which matches the exception by validating
    it against the predicate provided. The configured predicate takes the exception
    thrown as input, and provides a Boolean result in return. Here, we also configure
    multiple predicates. Reactor will pick the first matching predicate and use its
    fallback value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个`onErrorReturn`，它通过验证与提供的谓词匹配来匹配异常。配置的谓词接受抛出的异常作为输入，并返回一个布尔结果。在这里，我们也配置了多个谓词。Reactor将选择第一个匹配的谓词并使用其回退值。
- en: The onErrorResume operator
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onErrorResume`运算符'
- en: 'Similar to the `OnErrorReturn` operator, there is the `OnErrorResume` operator,
    which provides a fallback value stream instead of a single fallback value. In
    the event of an error, the fallback stream is returned. The original error event
    is not propagated to the error callback. The event processing continues by using
    the configured event handler, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与`OnErrorReturn`运算符类似，存在`OnErrorResume`运算符，它提供一个回退值流而不是单个回退值。在发生错误的情况下，返回回退流。原始错误事件不会被传播到错误回调。事件处理通过使用配置的事件处理器继续，如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, the following applies:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `onErrorResume` operator is used to provide back `Flux<Long>` when any error
    is received by the subscriber.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onErrorResume`运算符用于在订阅者收到任何错误时提供回`Flux<Long>`。'
- en: No error callback is configured in the subscriber API.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者API中没有配置错误回调。
- en: 'Let''s run our test case and validate our understanding, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试用例并验证我们的理解，如下所示：
- en: '![](img/08af6ed3-12ff-4667-aa08-d02f063d92e5.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08af6ed3-12ff-4667-aa08-d02f063d92e5.png)'
- en: Similar to the lines of `onErrorReturn`, the `onErrorResume` operator is overloaded
    to provide specific, exception-based fallback values. Exceptions can be provided
    directly, or can be matched using a predicate. Reactor will pick the value that
    matches first.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与`onErrorReturn`的行类似，`onErrorResume`运算符被重载以提供基于特定异常的回退值。异常可以直接提供，或者可以使用谓词进行匹配。Reactor将选择第一个匹配的值。
- en: The onErrorMap operator
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onErrorMap`运算符'
- en: Reactor's `onErrorMap` operator allows us to convert an exception of one type
    to another type. Unlike the previous two operators, the `onErrorMap` operator
    requires an error callback to be configured with the subscriber. If no handler
    is configured, the subscriber throws back an `ErrorCallbackNotImplemented` exception.
    The `onErrorMap` operator provides overloaded functions, similar to the previous
    operators, which can be used to match exceptions based on type or a provided predicate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor的`onErrorMap`运算符允许我们将一种类型的异常转换为另一种类型。与前面的两个运算符不同，`onErrorMap`运算符需要与订阅者一起配置错误回调。如果没有配置处理程序，则订阅者会抛出`ErrorCallbackNotImplemented`异常。`onErrorMap`运算符提供了重载函数，类似于前面的运算符，可以用于根据类型或提供的谓词匹配异常。
- en: 'Now, let''s build a simple test case to validate our understanding of the `onErrorMap`
    operator:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的测试用例来验证我们对`onErrorMap`运算符的理解：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, the following applies:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `onErrorMap` operator is configured to throw `IllegalStateException` when
    any error is received by the subscriber.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onErrorMap`运算符配置为在订阅者收到任何错误时抛出`IllegalStateException`。'
- en: The error callback was configured in the subscriber API.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误回调是在订阅者API中配置的。
- en: 'Let''s run it and confirm the output, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它并确认输出，如下所示：
- en: '![](img/da1c8b8a-3d7b-4806-941b-57daf3042657.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da1c8b8a-3d7b-4806-941b-57daf3042657.png)'
- en: Timeout
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: As discussed in the preceding sections, generating a timely response is an important
    aspect of reactive systems. The requirement means that reactive systems must provide
    a deterministic response in a timely manner. However, all software systems are
    inherently unreliable. The underlying network itself is unreliable. All components
    can fail without providing a response. As a result, systems with streaming results
    can get stuck waiting for a response.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，及时响应是反应式系统的一个重要方面。这个要求意味着反应式系统必须及时提供确定性的响应。然而，所有软件系统本质上都是不可靠的。底层网络本身是不可靠的。所有组件都可能失败而不提供响应。因此，具有流式结果系统的可能会卡在等待响应的状态。
- en: A way to address this unreliability is to adapt the fail-fast system design.
    This design dictates that a system makes some assumptions for normal operations,
    and it must fail as soon as these assumptions are broken. This leads to the early
    reporting of likely issues. In order to do this, we must assume a likely response
    time, the most common fail-fast metric. If the response is not received in this
    time, then the system must trigger the fallback/error response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种不可靠性的方法之一是采用快速失败系统设计。这种设计规定系统对正常操作做出一些假设，并且一旦这些假设被打破，系统必须立即失败。这导致可能的问题被提前报告。为了做到这一点，我们必须假设一个可能的响应时间，这是最常见的快速失败指标。如果在规定时间内没有收到响应，那么系统必须触发后备/错误响应。
- en: 'Reactor offers the `timeout()` operator to enable a response time check. The
    timeout fails when there is no response received in the specific time interval.
    Once the timeout expires, it triggers the error callback configured for the subscriber.
    Let''s validate the operator by using the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了 `timeout()` 操作符以启用响应时间检查。当在特定时间间隔内没有收到响应时，超时失败。一旦超时到期，它将触发为订阅者配置的错误回调。让我们通过以下代码验证操作符：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, the following applies:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `delayElements` operator is responsible for slowing down each element by
    the configured time. In our case, it sends each element after a one second delay.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delayElements` 操作符负责通过配置的时间减慢每个元素。在我们的例子中，它在一秒后发送每个元素。'
- en: The `timeout()` operator is configured for an interval of `500` milliseconds.
    This operator will raise an error when it first discovers a delay of more than
    `500` milliseconds.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timeout()` 操作符被配置为 `500` 毫秒的间隔。当它首次发现延迟超过 `500` 毫秒时，此操作符将引发错误。'
- en: The `onError` callback is configured for the subscriber. We also added a `CountDownLatch`,
    as we want to hold the test execution until the error is received.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为订阅者配置了 `onError` 回调。我们还添加了一个 `CountDownLatch`，因为我们想保持测试执行直到接收到错误。
- en: 'Let''s run this and confirm the output, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它并确认输出，如下所示：
- en: '![](img/8dbff4db-7bda-4550-8e2f-36f855580b32.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8dbff4db-7bda-4550-8e2f-36f855580b32.png)'
- en: 'The `timeout()` operator also offers to provide a fallback `Flux<>` value when
    the timeout is triggered. In this case, the fallback value does not throw a timeout
    error. Consequently, it does not trigger the configured error callbacks. Instead,
    the flow is executed as next events, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout()` 操作符还提供在超时触发时提供后备 `Flux<>` 值的功能。在这种情况下，后备值不会抛出超时错误。因此，它不会触发配置的错误回调。相反，流程作为后续事件执行，如下所示：'
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, the following applies:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `delayElements` operator is responsible for slowing down each element by
    the configured time. In our case, it sends each element after a one second delay.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delayElements` 操作符负责通过配置的时间减慢每个元素。在我们的例子中，它在一秒后发送每个元素。'
- en: The `timeout()` operator is configured for an interval of `500` milliseconds.
    This operator will raise an error when it first discovers a delay of more than
    `500` milliseconds. The operator also has a fallback Flux. The fallback value
    is returned once the timeout expires.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timeout()` 操作符被配置为 `500` 毫秒的间隔。当它首次发现延迟超过 `500` 毫秒时，此操作符将引发错误。操作符还有一个后备的 Flux。一旦超时到期，将返回后备值。'
- en: The `onNext` handler is configured to print the received value. We added a `CountDownLatch`,
    as we want to hold the test execution until the value is received.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onNext` 处理器被配置为打印接收到的值。我们添加了一个 `CountDownLatch`，因为我们想保持测试执行直到接收到值。'
- en: There is no `onError` callback configured.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有配置 `onError` 回调。
- en: 'Let''s run it and validate the output, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它并验证输出，如下所示：
- en: '![](img/b0e52e9c-04fb-49dd-b0e9-2c755a5b72e2.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0e52e9c-04fb-49dd-b0e9-2c755a5b72e2.png)'
- en: 'While we are discussing errors and timeouts, it is important to mention the
    `retry` operator. This operator allows us to re-subscribe to the published stream
    when an error is discovered. The retry can only be performed a fixed number of
    times. The re-subscribed events are handled as next events by the subscriber.
    If the stream completes normally, no next retry takes place. Error callback is
    only triggered when an error is thrown during the last retry cycle:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论错误和超时时，重要的是要提到 `retry` 操作符。此操作符允许我们在发现错误时重新订阅发布的流。重试只能执行固定次数。重新订阅的事件由订阅者作为后续事件处理。如果流正常完成，则不会进行后续的重试。错误回调仅在最后重试周期中抛出错误时触发：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, the following applies:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `delayElements` operator is responsible for slowing down each element by
    the configured time. In our case, it sends each element after a one second delay.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delayElements`运算符负责通过配置的时间减慢每个元素。在我们的例子中，它在一秒延迟后发送每个元素。'
- en: The `timeout()` operator is configured for an interval of `500` milliseconds.
    The operator will raise an error when it first discovers a delay of more than
    `500` milliseconds. The operator also has a fallback Flux. The fallback value
    is returned once the timeout expires.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timeout()`运算符被配置为`500`毫秒的间隔。当运算符首次发现延迟超过`500`毫秒时，它将引发一个错误。运算符还有一个回退Flux。一旦超时到期，将返回回退值。'
- en: The `onNext` handler is configured to print the received value. We added a `CountDownLatch`,
    as we want to hold the test execution until the value is received.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onNext`处理器被配置为打印接收到的值。我们添加了一个`CountDownLatch`，因为我们想保持测试执行直到接收到值。'
- en: No `onError` callback is configured.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有配置`onError`回调。
- en: 'Let''s run it and validate the output, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它并验证输出，如下所示：
- en: '![](img/aca7cc62-8f7a-421c-811e-053c081e069e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aca7cc62-8f7a-421c-811e-053c081e069e.png)'
- en: WebClient
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebClient
- en: 'In [Chapter 6](5e6f3f39-3172-4cde-9e50-d4892791d847.xhtml), *Dynamic Rendering*,
    we discussed using the Spring WebClient to make web calls in a non-blocking and
    asynchronous manner. The operators that we have discussed so far are applicable
    to Reactive Stream publishers and subscribers. WebClient also produces a Mono
    publisher of `ServerResponse`. So, how should we handle errors generated in WebClient,
    and generate a valid response? First, let''s take a look at WebClient''s default
    handling of server-side errors. To do this, we should first generate errors in
    our Fibonacci handler function, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](5e6f3f39-3172-4cde-9e50-d4892791d847.xhtml)“动态渲染”中，我们讨论了使用Spring WebClient以非阻塞和异步方式执行网络调用。我们迄今为止讨论的运算符适用于反应式流发布者和订阅者。WebClient还产生一个`ServerResponse`的单子发布者。那么，我们应该如何处理WebClient中生成的错误并生成有效的响应？首先，让我们看看WebClient对服务器端错误的默认处理。为此，我们应该首先在我们的Fibonacci处理函数中生成错误，如下所示：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we modified our generator to raise a `RuntimeException`.
    The exception will be raised as soon as the server builds a response. This, in
    turn, sends the HTTP 500 status error back, with the exception message in the
    body:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们修改了我们的生成器以引发`RuntimeException`。异常将在服务器构建响应时立即引发。这反过来又发送了带有异常消息主体的HTTP
    500状态错误：
- en: '![](img/93510c10-e8b0-4f22-8f92-8b9b18d8ff78.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93510c10-e8b0-4f22-8f92-8b9b18d8ff78.png)'
- en: 'Alternatively, we can raise an error using the `sink.error()` method. This
    method will take an exception instance and throw it back. It will also raise a
    500 status code, with an `out of bound` error message, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`sink.error()`方法引发错误。此方法将接受一个异常实例并将其抛回。它还将引发一个500状态码，并带有`out of bound`错误消息，如下所示：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will invoke the preceding URL by using WebClient so as to understand its
    default behavior. Let''s revisit the WebClient sample from [Chapter 6](5e6f3f39-3172-4cde-9e50-d4892791d847.xhtml),
    *Dynamic Rendering*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用WebClient调用前面的URL来理解其默认行为。让我们回顾一下[第6章](5e6f3f39-3172-4cde-9e50-d4892791d847.xhtml)“动态渲染”中的WebClient示例：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, the following applies:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: We invoked the `/fibonacci` URL.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用了`/fibonacci` URL。
- en: We converted the body, using the `retrieve` method.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`retrieve`方法转换了主体。
- en: We used the limit operator to select 10 results.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用限制运算符选择了10个结果。
- en: In the end, the results were printed to the console.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，结果被打印到控制台。
- en: 'Note that there is no explicit error handler configured; run the code to see
    how it responds. The code does not generate any output or convert the body when
    it receives error status codes from the server. Alternatively, let''s configure
    an error handler in the subscriber method and print the exception, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有配置显式的错误处理器；运行代码以查看其响应。当它从服务器接收到错误状态码时，代码不会生成任何输出或转换主体。或者，让我们在订阅者方法中配置一个错误处理器并打印异常，如下所示：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s execute the WebClient code to determine the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行WebClient代码以确定输出：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Interestingly, this time around, we can see a `WebClientResponseException`,
    with the status code as an error message. If we look at the `WebClientResponseException`
    class, the exception allows us to get the response text, status code, and more.
    Typecasting the error and printing the response text would generate the following
    output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这次我们可以看到一个带有状态码作为错误信息的`WebClientResponseException`。如果我们查看`WebClientResponseException`类，该异常允许我们获取响应文本、状态码等。将错误类型转换为字符串并打印响应文本将生成以下输出：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to note the behavior of the WebClient API. Although the stream
    generated an error, we never saw the `ErrorCallbackNotImplemented` exception,
    unlike the behavior of Reactive Stream subscribers without a configured error
    handler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意WebClient API的行为。尽管流生成了错误，但我们从未看到`ErrorCallbackNotImplemented`异常，这与没有配置错误处理器的Reactive
    Stream订阅者的行为不同。
- en: 'WebClient works well with the `onError` operators that were discussed in the
    previous sections. We can configure either `onErrorReturn` or `onErrorResume`
    operators. This would provide fallback values, which are returned in the case
    of an error, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: WebClient与之前章节中讨论的`onError`运算符配合良好。我们可以配置`onErrorReturn`或`onErrorResume`运算符。这将提供回退值，在发生错误时返回，如下所示：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, execute the preceding code and confirm the fallback values in the output.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行前面的代码并确认输出中的回退值。
- en: 'Here, the WebClient that retrieves an API also offers an `onStatus` method
    to configure response handling. The `onStatus` method takes exception mapping
    and invokes it for the configured HTTP status codes. In our preceding sample,
    let''s try to throw a `RuntimeException` for a 500 server response:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，检索API的WebClient还提供了一个`onStatus`方法来配置响应处理。`onStatus`方法接受异常映射并对其配置的HTTP状态码进行调用。在我们的前一个示例中，让我们尝试为500服务器响应抛出一个`RuntimeException`：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, the following applies:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: '`RuntimeException` is raised as `Mono.error`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeException`作为`Mono.error`被抛出。'
- en: The Mono is configured for all HTTP error status codes (`4XX`, `5XX`).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono被配置为处理所有HTTP错误状态码（`4XX`，`5XX`）。
- en: 'When the preceding code is executed, a `RuntimeException` is thrown. However,
    the exception leads to an `ErrorCallbackNotImplemented` exception, unlike the
    previous behavior, where `WebClientResponseException` did not ask for an exception
    handler:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，会抛出一个`RuntimeException`。然而，与之前的操作不同，这次异常导致了一个`ErrorCallbackNotImplemented`异常，而`WebClientResponseException`没有要求异常处理器：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we can configure exception mapping or a fallback value provider to recover
    from the thrown exception.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置异常映射或回退值提供程序来从抛出的异常中恢复。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the various ways to add resilience to our application.
    First, we covered possible error scenarios involving the producer and the subscriber.
    Next, we looked at how Reactor performs error handling under each of those conditions.
    This enabled us to configure the required error handling in Reactor, by using
    the various operations that are offered. Reactor allows us to configure fallback
    values for the thrown exceptions by using `onErrorReturn` and `onErrorResume`
    operators. We also configured timeouts and retry machines, using the available
    operators, in order to generate timely responses. Finally, we configured error
    handling in WebClient. In a nutshell, we explored the possible ways to configure
    error handlers in Reactor.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了为我们的应用程序添加弹性的各种方法。首先，我们涵盖了涉及生产者和订阅者的可能错误场景。接下来，我们研究了Reactor在每种条件下如何执行错误处理。这使得我们能够通过使用提供的各种操作来配置Reactor中的所需错误处理。Reactor允许我们通过使用`onErrorReturn`和`onErrorResume`运算符来配置抛出异常的回退值。我们还使用可用的运算符配置了超时和重试机制，以生成及时响应。最后，我们在WebClient中配置了错误处理。总的来说，我们探讨了在Reactor中配置错误处理器的可能方法。
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How is an error handled in Reactor?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Reactor中如何处理错误？
- en: Which operators allow us to configure error handling?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些运算符允许我们配置错误处理？
- en: What is the difference between `onErrorResume` and `onErrorReturn`?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onErrorResume`和`onErrorReturn`之间的区别是什么？'
- en: How can we generate a timely response for a Reactive Stream?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为Reactive Stream生成及时响应？
- en: How does the `retry` operator behave?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`retry`运算符的行为如何？'
