<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Securing Java EE Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Securing Java EE Applications</h1></div></div></div><p>In this chapter, we will cover how to secure Java EE applications by taking advantage of GlassFish's built-in security features.</p><p>Java EE security relies on the <span class="strong"><strong>Java Authentication and Authorization Service</strong></span> (<span class="strong"><strong>JAAS</strong></span>) API. As we will see, securing Java<a id="id836" class="indexterm"/> EE applications requires very little coding for the most part. Securing an application is achieved by setting up users and security groups to a security realm in the application server and then configuring our applications to rely on a specific security realm for authentication and authorization.</p><p>Some of the topics we will cover in this chapter include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Admin realms</li><li class="listitem" style="list-style-type: disc">File realms</li><li class="listitem" style="list-style-type: disc">Certificate realms</li><li class="listitem" style="list-style-type: disc">Creating self-signed security certificates</li><li class="listitem" style="list-style-type: disc">JDBC realms</li><li class="listitem" style="list-style-type: disc">Custom realms</li></ul></div><div class="section" title="Security realms"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Security realms</h1></div></div></div><p>Security realms <a id="id837" class="indexterm"/>are, in essence, collections of users and related security groups. A user can belong to one or more security groups. The groups that the user belongs to define what actions the system will allow the user to perform. For example, an application can have regular users that can only use basic application functionality, and it can have administrators that, in addition to being able to use basic application functionality, can add additional users to the system.</p><p>Security realms store user information (user name, password, and security groups). Therefore, applications don't need to implement this functionality and can simply be configured to obtain this information from a security realm. A security realm can be used by more than one application.</p><div class="section" title="Predefined security realms"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec67"/>Predefined security realms</h2></div></div></div><p>GlassFish comes preconfigured<a id="id838" class="indexterm"/> with three predefined security realms: <span class="strong"><strong>admin-realm</strong></span>, <span class="strong"><strong>file</strong></span>, and <span class="strong"><strong>certificate</strong></span>. The <span class="strong"><strong>admin-realm</strong></span> is used to manage the user's access to the GlassFish web console and shouldn't be used for other applications. The<a id="id839" class="indexterm"/> <span class="strong"><strong>file</strong></span> realm stores user information in a file. The <span class="strong"><strong>certificate</strong></span> realm looks for a client-side certificate to authenticate the user.</p><p>The following screenshot <a id="id840" class="indexterm"/>shows the predefined realms in the GlassFish web console:</p><div class="mediaobject"><img src="graphics/6886EN_09_01.jpg" alt="Predefined security realms"/></div><p>In addition to the predefined security realms, we can add additional realms with very little effort. We will cover how to do this later in this chapter, but first let's discuss GlassFish's predefined security realms.</p><div class="section" title="The admin-realm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec16"/>The admin-realm</h3></div></div></div><p>The admin-realm has<a id="id841" class="indexterm"/> a predefined user called <span class="strong"><strong>admin</strong></span>,<a id="id842" class="indexterm"/> which belongs to a predefined group called <a id="id843" class="indexterm"/>
<span class="strong"><strong>asadmin</strong></span>.</p><p>To illustrate how to add users to a realm, <a id="id844" class="indexterm"/>let's add a new user to the admin-realm. This will allow an additional user to log in to the GlassFish web console. In order to add a user to admin-realm, log in to the GlassFish web console and expand the <span class="strong"><strong>Configurations</strong></span> node on the left-hand side. Then expand the <span class="strong"><strong>server-config</strong></span> node, followed by the <span class="strong"><strong>Security</strong></span> node. <a id="id845" class="indexterm"/>Then expand the <span class="strong"><strong>Realms</strong></span> node and click on <span class="strong"><strong>admin-realm</strong></span>. The main area of the page should look like the<a id="id846" class="indexterm"/> following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_02.jpg" alt="The admin-realm"/></div><p>To add a user to the realm, click on the button to the top-left labeled <span class="strong"><strong>Manage Users</strong></span>. The main area of the page should now look like the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_03.jpg" alt="The admin-realm"/></div><p>To add a new <a id="id847" class="indexterm"/>user to the realm, simply click on the <span class="strong"><strong>New...</strong></span> button to the top-left <a id="id848" class="indexterm"/>of the screen and then enter the new user information as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_04.jpg" alt="The admin-realm"/></div><p>As shown in this screenshot, we added a new user named <code class="literal">root</code>, added this user to the <code class="literal">asadmin</code> group, and entered this user's password.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>The GlassFish web console will only allow users in the<a id="id849" class="indexterm"/> <span class="strong"><strong>asadmin</strong></span> group to log in. Failing to add our user to this security group will prevent him/her from logging in to the console.</p></div></div><p>We can now see our newly created user in the list of admin-realm users, as can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_05.jpg" alt="The admin-realm"/></div><p>We have successfully added a <a id="id850" class="indexterm"/>new user for the GlassFish <a id="id851" class="indexterm"/>web console. We can test this new account by logging in to the console with this new user's credentials.</p></div><div class="section" title="The file realm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec17"/>The file realm</h3></div></div></div><p>The second predefined realm in<a id="id852" class="indexterm"/> GlassFish is the file realm. This realm stores user information<a id="id853" class="indexterm"/> encrypted in a text file. Adding users to this realm is very similar to adding users to <span class="strong"><strong>admin-realm</strong></span>. We can add a user by navigating to <span class="strong"><strong>Configurations</strong></span> | <span class="strong"><strong>server-config</strong></span> | <span class="strong"><strong>Security</strong></span> | <span class="strong"><strong>Realm</strong></span>. Under the <span class="strong"><strong>Realm</strong></span> node, click on <span class="strong"><strong>file</strong></span>, then on the <span class="strong"><strong>Manage Users</strong></span> button, and finally on the <span class="strong"><strong>New...</strong></span> button. The main area of the page should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_06.jpg" alt="The file realm"/></div><p>Since this realm is meant to<a id="id854" class="indexterm"/> be used for our applications, we can come up with our own groups. Groups are useful to give the same permissions to several users. For example, all users requiring administrative permissions can be added to an admin  group <a id="id855" class="indexterm"/>(the name of the group is, of course, arbitrary).</p><p>In this example, we added a user with the user ID <code class="literal">peter</code> to the groups <code class="literal">appuser</code> and <code class="literal">appadmin</code>.</p><p>Clicking on the <span class="strong"><strong>OK</strong></span> button should save the new user and take us to the user list for this realm, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_07.jpg" alt="The file realm"/></div><p>Clicking on the <span class="strong"><strong>New...</strong></span> button allows<a id="id856" class="indexterm"/> us to add additional users to the realm. Let's add an additional user named <code class="literal">joe</code> belonging only to the <code class="literal">appuser</code> group, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_08.jpg" alt="The file realm"/></div><p>As we have seen in this section, adding users to the file realm is very simple. We will now illustrate how to authenticate <a id="id857" class="indexterm"/>and authorize users via the file realm.</p><div class="section" title="Basic authentication via the file realm"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec03"/>Basic authentication via the file realm</h4></div></div></div><p>In the previous section, we covered how to add users to the file realm and how to assign these users to groups. In this section, we will illustrate how to secure a web application so that only properly authenticated and <a id="id858" class="indexterm"/>authorized users can access it. This web application will use the file realm for user access control.</p><p>The application will consist of a few very simple JSF pages. All authentication logic is taken care of by the application server; therefore, the only place we need to make modifications in order to secure the application is in its deployment descriptors, <code class="literal">web.xml</code> and <code class="literal">glassfish-web.xml</code>. We will first discuss <code class="literal">web.xml</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0"   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt;
    &lt;param-value&gt;Development&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.jsf&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsf&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
<span class="strong"><strong>  &lt;security-constraint&gt;</strong></span>
<span class="strong"><strong>    &lt;web-resource-collection&gt;</strong></span>
<span class="strong"><strong>      &lt;web-resource-name&gt;Admin Pages&lt;/web-resource-name&gt;</strong></span>
<span class="strong"><strong>      &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;</strong></span>
<span class="strong"><strong>    &lt;/web-resource-collection&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-constraint&gt;</strong></span>
<span class="strong"><strong>      &lt;role-name&gt;admin&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;/auth-constraint&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-constraint&gt;</strong></span>
<span class="strong"><strong>  &lt;security-constraint&gt;</strong></span>
<span class="strong"><strong>    &lt;web-resource-collection&gt;</strong></span>
<span class="strong"><strong>      &lt;web-resource-name&gt;AllPages&lt;/web-resource-name&gt;</strong></span>
<span class="strong"><strong>      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</strong></span>
<span class="strong"><strong>    &lt;/web-resource-collection&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-constraint&gt;</strong></span>
<span class="strong"><strong>      &lt;role-name&gt;user&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;/auth-constraint&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-constraint&gt;</strong></span>
<span class="strong"><strong>  &lt;login-config&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;</strong></span>
<span class="strong"><strong>    &lt;realm-name&gt;file&lt;/realm-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/login-config&gt;</strong></span>
&lt;/web-app&gt;</pre></div><p>The <code class="literal">&lt;security-constraint&gt;</code> element defines who can access pages matching a certain URL pattern. The URL pattern of the pages is defined inside the <code class="literal">&lt;url-pattern&gt;</code> element, which, as shown in the example, must be nested inside a <code class="literal">&lt;web-resource-collection&gt;</code> element. Roles allowed to access the pages are defined in the <code class="literal">&lt;role-name&gt;</code> element, which must be nested inside an <code class="literal">&lt;auth-constraint&gt;</code> element.</p><p>In our example, we<a id="id859" class="indexterm"/> define two sets of pages to be protected. The first set of pages are those whose URLs start with <code class="literal">/admin</code>. These pages can be accessed only by users belonging to the admin group. The second set of pages are the rest of the pages, defined by the URL pattern of <code class="literal">/*</code>. Only users with the role <code class="literal">user</code> can access these pages. It is worth noting that the second set of pages is a superset of the first set, that is, any page whose URL matches <code class="literal">/admin/*</code> also matches <code class="literal">/*</code>. In cases like these, the most specific case wins. In this particular case, users with the role <code class="literal">user</code> (and without the role <code class="literal">admin</code>) will not be able to access any page whose URL starts with <code class="literal">/admin</code>.</p><p>The next element we need to add to <code class="literal">web.xml</code> in order to protect our pages is the <code class="literal">&lt;login-config&gt;</code> element. This element must contain an <code class="literal">&lt;auth-method&gt;</code> element, which defines the authorization method for the application. Valid values for this element include <code class="literal">BASIC</code>, <code class="literal">DIGEST</code>, <code class="literal">FORM</code>, and <code class="literal">CLIENT-CERT</code>.</p><p>
<code class="literal">BASIC</code> indicates that basic authentication will be used. This type of authentication will result in a browser-generated pop up prompting the user for a username and password to be displayed the first time a user tries to access a protected page. Unless using the HTTPS protocol, when using basic authentication, the user's credentials are Base64 encoded, not encrypted. It would be fairly easy for an attacker to decode these credentials; therefore, using basic authentication is not recommended.</p><p>The <code class="literal">DIGEST</code> authentication value is similar to basic authentication, except that it uses an MD5 digest to encrypt the user credentials instead of sending them Base64 encoded.</p><p>The <code class="literal">FORM</code> authentication value uses a custom HTML or JSP page containing an HTML form with the username and password fields. The values in the form are then checked against the security realm for user authentication and authorization. Unless using HTTPS, user credentials are sent in clear<a id="id860" class="indexterm"/> text when using form-based authentication; therefore, using HTTPS is recommended since it encrypts the data. We will cover setting up GlassFish to use HTTPS later in this chapter.</p><p>The <code class="literal">CLIENT-CERT</code> authentication<a id="id861" class="indexterm"/> value uses client-side certificates to authenticate and authorize the user.</p><p>The <code class="literal">&lt;realm-name&gt;</code> element of <code class="literal">&lt;login-config&gt;</code> indicates what security realm to use to authenticate and authorize the user. In this particular example, we are using the file realm.</p><p>All of the <code class="literal">web.xml</code> elements we have discussed in this section can be used with any security realm; they are not tied to the file realm. The only thing that ties our application to the file realm is the value of the <code class="literal">&lt;realm-name&gt;</code> element. Something else to keep in mind is that not all authentication methods are supported by all realms. The file realm supports only basic and form-based authentication.</p><p>Before we can successfully authenticate our users, we need to link the user roles defined in <code class="literal">web.xml</code> with the groups defined in the realm. We accomplish this in the <code class="literal">glassfish-web.xml</code> deployment descriptor as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE glassfish-web-app PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 Servlet 3.0//EN" "http://glassfish.org/dtds/glassfish-web-app_3_0-1.dtd"&gt;
&lt;glassfish-web-app error-url=""&gt;
  &lt;context-root&gt;/filerealmauth&lt;/context-root&gt;
<span class="strong"><strong>  &lt;security-role-mapping&gt;</strong></span>
<span class="strong"><strong>    &lt;role-name&gt;admin&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;group-name&gt;appadmin&lt;/group-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-role-mapping&gt;</strong></span>
<span class="strong"><strong>  &lt;security-role-mapping&gt;</strong></span>
<span class="strong"><strong>    &lt;role-name&gt;user&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;group-name&gt;appuser&lt;/group-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-role-mapping&gt;</strong></span>
  &lt;class-loader delegate="true"/&gt;    
&lt;/glassfish-web-app&gt;</pre></div><p>As can be seen in the preceding example, the <code class="literal">glassfish-web.xml</code> deployment descriptor can have one or more <code class="literal">&lt;security-role-mapping&gt;</code> elements. One of these elements is needed for each role defined in each <code class="literal">&lt;auth-constraint&gt;</code> tag in <code class="literal">web.xml</code>. The <code class="literal">&lt;role-name&gt;</code> subelement indicates the role to map. Its value must match the value of the corresponding <code class="literal">&lt;role-name&gt;</code> element in <code class="literal">web.xml</code>. The <code class="literal">&lt;group-name&gt;</code> subelement must match the value of a security group in the realm used to authenticate users in the application.</p><p>In this example, the first <code class="literal">&lt;security-role-mapping&gt;</code> element maps the <code class="literal">admin</code> role defined in the application's <code class="literal">web.xml</code> deployment descriptor to the <code class="literal">appadmin</code> group we created when adding users to the file<a id="id862" class="indexterm"/> realm earlier in the chapter. The second <code class="literal">&lt;security-role-mapping&gt;</code> element maps the <code class="literal">user</code> role in <code class="literal">web.xml</code> to the <code class="literal">appuser</code> group in the file realm.</p><p>As mentioned earlier, there is nothing we need to do in our code in order to authenticate and authorize users. All we need to do is modify the application's deployment descriptors as described in this section. Since our application<a id="id863" class="indexterm"/> is nothing but a few simple pages, we will not show the source code for them. The structure of our application is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_09.jpg" alt="Basic authentication via the file realm"/></div><p>Based on the way we set up our application in the deployment descriptors, users with the role <code class="literal">user</code> will be able to access the two pages at the root of the application (<code class="literal">index.xhtml</code> and <code class="literal">random.xhtml</code>). Only users with the role <code class="literal">admin</code> will be able to access any pages under the <code class="literal">admin</code> folder, which in this particular case is a single page named <code class="literal">index.xhtml</code>.</p><p>After packaging and deploying our application and pointing the browser to the URL of any of its pages, we should see a pop up asking for a <span class="strong"><strong>User Name</strong></span> and <span class="strong"><strong>Password</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_10.jpg" alt="Basic authentication via the file realm"/></div><p>After entering the correct username<a id="id864" class="indexterm"/> and password, we are directed to the page we were attempting to see, as follows:</p><div class="mediaobject"><img src="graphics/6886EN_09_11.jpg" alt="Basic authentication via the file realm"/></div><p>At this point, the user can navigate to any page he/she is allowed to access in the application, either by following links or by typing in the URL in the browser, without having to reenter his/her username and password.</p><p>Note that we logged in as the user <code class="literal">joe</code>; this user belongs only to the <code class="literal">user</code> role. Therefore, he does not have access to any page that starts with <code class="literal">/admin</code> as the URL. If <code class="literal">joe</code> tries to access one of these pages, he will get an HTTP error reporting <span class="strong"><strong>HTTP Status 403-Forbidden</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_12.jpg" alt="Basic authentication via the file realm"/></div><p>Only users belonging to the <code class="literal">admin</code> role can see pages that match the URL shown in the screenshot. When we<a id="id865" class="indexterm"/> were adding users to the file realm, we added a user named <code class="literal">peter</code> that had this role. If we log in as <code class="literal">peter</code>, we will be able to see the requested page. For basic authentication, the only possible way to log out of the application is to close the browser. Therefore, to log in as <code class="literal">peter</code>, we need to close and reopen the browser. Once logged in as Peter, we will see a window as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_13.jpg" alt="Basic authentication via the file realm"/></div><p>As mentioned before, one disadvantage of the basic authentication method we used in this example is that login information is not <a id="id866" class="indexterm"/>encrypted. One way to get around this is to use the HTTPS (HTTP over SSL) protocol. When using this protocol, all information between the browser and the server is encrypted.</p><p>The easiest way to use HTTPS is by modifying the application's <code class="literal">web.xml</code> deployment descriptor as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;Admin Pages&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
<span class="strong"><strong>    &lt;user-data-constraint&gt;</strong></span>
<span class="strong"><strong>      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;</strong></span>
<span class="strong"><strong>    &lt;/user-data-constraint&gt;</strong></span>
    &lt;/security-constraint&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;AllPages&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;user&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
<span class="strong"><strong>    &lt;user-data-constraint&gt;</strong></span>
<span class="strong"><strong>      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;</strong></span>
<span class="strong"><strong>    &lt;/user-data-constraint&gt;</strong></span>
  &lt;/security-constraint&gt;
  &lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;realm-name&gt;file&lt;/realm-name&gt;
  &lt;/login-config&gt;
&lt;/web-app&gt;</pre></div><p>As we can see, all we need to do to have the application be accessed only through HTTPS is to add a <code class="literal">&lt;user-data-constraint&gt;</code> element containing a nested <code class="literal">&lt;transport-guarantee&gt;</code> element to each set of pages we want to encrypt. Sets of pages to be protected are declared in the <code class="literal">&lt;security-constraint&gt;</code> elements in the <code class="literal">web.xml</code> deployment descriptor.</p><p>Now, when we access the application through the (unsecure) HTTP port (by default, it is 8080), the request is automatically forwarded to the (secure) HTTPS port (by default, 8181).</p><p>In our example, we set the value of the <code class="literal">&lt;transport-guarantee&gt;</code> element to <code class="literal">CONFIDENTIAL</code>. This has the effect of encrypting all the data between the browser and the server. Also, if the request is<a id="id867" class="indexterm"/> made through the unsecured HTTP port, it is automatically forwarded to the secured HTTPS port.</p><p>Another valid value for the <code class="literal">&lt;transport-guarantee&gt;</code> element is <code class="literal">INTEGRAL</code>. When using this value, the integrity of the data between the browser and the server is guaranteed. In other words, the data cannot be changed in transit. When using this value, requests made over HTTP are not automatically forwarded to HTTPS. If a user attempts to access a secure page via HTTP when this value is used, the browser will deny the request and return a 403 (Access Denied) error.</p><p>The third and last valid value for the <code class="literal">&lt;transport-guarantee&gt;</code> element is <code class="literal">NONE</code>. When using this value, no guarantees are made about the integrity or confidentiality of the data. The <code class="literal">NONE</code> value is the default value used when the <code class="literal">&lt;transport-guarantee&gt;</code> element is not present in the application's <code class="literal">web.xml</code> deployment descriptor.</p><p>After making the preceding modifications to the <code class="literal">web.xml</code> deployment descriptor, redeploying the application, and pointing the browser to any of the pages in the application, we should see the following warning page when accessing our application on Firefox:</p><div class="mediaobject"><img src="graphics/6886EN_09_14.jpg" alt="Basic authentication via the file realm"/></div><p>After expanding the <span class="strong"><strong>I Understand the Risks</strong></span> node and <a id="id868" class="indexterm"/>clicking on the button labeled <span class="strong"><strong>Add Exception...</strong></span>, we should see a window similar to the one shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_15.jpg" alt="Basic authentication via the file realm"/></div><p>After clicking on the<a id="id869" class="indexterm"/> button labeled <span class="strong"><strong>Confirm Security Exception</strong></span>, we are prompted for a username and password. After entering the appropriate credentials, we are allowed access to the requested page as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_16.jpg" alt="Basic authentication via the file realm"/></div><p>The reason we see this warning is that, in order for a server to use the HTTPS protocol, it must have an SSL certificate. Typically, SSL certificates are issued by <span class="strong"><strong>Certificate Authorities</strong></span> (<span class="strong"><strong>CA</strong></span>)<a id="id870" class="indexterm"/> such as Verisign or Thawte. These certificate authorities digitally sign the certificate. By doing this, they certify that the server belongs to the entity it claims it belongs to.</p><p>A digital certificate from one of<a id="id871" class="indexterm"/> these certificate authorities typically costs around USD 400 and expires after a year. Since the cost of these certificates may be prohibitive for development or testing purposes, GlassFish comes preconfigured with a self-signed SSL certificate. Since this certificate has not been signed by a certificate authority, the browser shows a warning window when we try to access a secured page via HTTPS.</p><p>Notice the URL in the screenshot. The protocol is set to HTTPS, and the port is 8181. The URL we pointed the browser to was <code class="literal">http://localhost:8080/filerealmauthhttps</code>, because of the modifications we made to the application's <code class="literal">web.xml</code> deployment descriptor, the request was automatically redirected to this URL. Of course, users may directly type in the secure URL and it will work without a problem.</p><p>Any data transferred over HTTPS is encrypted, including the username and password entered in the pop-up window generated by the browser. Using HTTPS allows us to safely use basic authentication. However, basic authentication has a disadvantage, which is that the only way that users can log out of the application is to close the browser. If we need to allow users to log out of the application without closing the browser, we need to use form-based authentication.</p></div><div class="section" title="Form-based authentication"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec04"/>Form-based authentication</h4></div></div></div><p>We need to make some modifications to the application's <code class="literal">web.xml</code> deployment descriptor to use form-based authentication, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0"   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
  &lt;context-param&gt;
   &lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt;
    &lt;param-value&gt;Development&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.jsf&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsf&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;Admin Pages&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
    &lt;user-data-constraint&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;AllPages&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;user&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
    &lt;user-data-constraint&gt;
      &lt;description/&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;login-config&gt;
<span class="strong"><strong>    &lt;auth-method&gt;FORM&lt;/auth-method&gt;</strong></span>
    &lt;realm-name&gt;file&lt;/realm-name&gt;
<span class="strong"><strong>    &lt;form-login-config&gt;</strong></span>
<span class="strong"><strong>      &lt;form-login-page&gt;/login.jsf&lt;/form-login-page&gt;</strong></span>
<span class="strong"><strong>      &lt;form-error-page&gt;/loginerror.jsf&lt;/form-error-page&gt;</strong></span>
<span class="strong"><strong>    &lt;/form-login-config&gt;</strong></span>
  &lt;/login-config&gt;
&lt;/web-app&gt;</pre></div><p>When using form-based authentication, we simply use <code class="literal">FORM</code> as the value of the <code class="literal">&lt;auth-method&gt;</code> element in <code class="literal">web.xml</code>. When using this authentication method, we need to provide a login page and a login error page. We<a id="id872" class="indexterm"/> indicate the URLs for the login and login error pages as the values of the <code class="literal">&lt;form-login-page&gt;</code> and <code class="literal">&lt;form-error-page&gt;</code> elements, respectively. As we can see in the example, these elements must be nested inside the <code class="literal">&lt;form-login-config&gt;</code> element.</p><p>The markup for the login page for our application is shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html  &gt;
  &lt;h:head&gt;
    &lt;title&gt;Login&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;p&gt;Please enter your username and password to access the application
    &lt;/p&gt;
<span class="strong"><strong>    &lt;form method="POST" action="j_security_check"&gt;</strong></span>
      &lt;table cellpadding="0" cellspacing="0" border="0"&gt;
        &lt;tr&gt;
          &lt;td align="right"&gt;Username:&amp;nbsp;&lt;/td&gt;
          &lt;td&gt;
<span class="strong"><strong>            &lt;input type="text" name="j_username"/&gt;</strong></span>
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td align="right"&gt;Password:&amp;nbsp;&lt;/td&gt;
          &lt;td&gt;
<span class="strong"><strong>            &lt;input type="password" name="j_password"/&gt;</strong></span>
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;
            &lt;input type="submit" value="Login"/&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/form&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Please note that even though our login page is a JSF page, it uses a standard <code class="literal">&lt;form&gt;</code> tag as opposed to the JSF-specific <code class="literal">&lt;h:form&gt;</code> tag. The reason for this is that the form's action attribute value must be <code class="literal">j_security_check</code> and it is not possible to set this attribute in the JSF <a id="id873" class="indexterm"/>
<code class="literal">&lt;h:form&gt;</code> tag. Similarly, the input fields in the form are standard HTML fields, as opposed to their JSF-specific counterparts.</p><p>The login page for an application using form-based authentication must contain a form whose method is <code class="literal">POST</code> and whose action is <code class="literal">j_security_check</code>. We don't need to implement the authentication code as it is supplied by the application server.</p><p>The form in the login page must contain a text field named <code class="literal">j_username</code>. This text field is meant to hold the username. Additionally, the form must contain a password field named <code class="literal">j_password</code>, meant for the password. Of course, the form must contain a submit button to submit the data to the server.</p><p>The only requirement for a login<a id="id874" class="indexterm"/> page is for it to have a form whose attributes match those in our example, and the <code class="literal">j_username</code> and <code class="literal">j_password</code> input fields as described in the preceding paragraph.</p><p>There are no special requirements for the error page. Of course, it should show an error message telling the user that login was unsuccessful. However, it can contain anything we wish. The error page for our application simply tells the user that there was an error logging in and links back to the login page to give the user a chance to log back in.</p><p>In addition to a login page and a login error page, we added a CDI named bean to our application. This allows us to implement the logout functionality, something that wasn't possible when we were using basic authentication. The code to implement the logout functionality is as follows:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.enterprise.context.RequestScoped;
import javax.faces.context.ExternalContext;
import javax.faces.context.FacesContext;
import javax.inject.Named;
import javax.servlet.http.HttpSession;

@Named
@RequestScoped
public class LogoutManager {

  public String logout() {
    FacesContext facesContext = FacesContext.getCurrentInstance();
    ExternalContext externalContext = facesContext.getExternalContext();
    HttpSession session = (HttpSession) externalContext.getSession(true);

<span class="strong"><strong>    session.invalidate();</strong></span>

    return "index?faces-redirect=true";
  }
}</pre></div><p>The first few lines of the logout method are meant to get a reference to the <code class="literal">HttpSession</code> object. Once we obtain this object, all<a id="id875" class="indexterm"/> we need to do is invalidate the session by invoking its <code class="literal">invalidate()</code> method<a id="id876" class="indexterm"/>. In our code, we redirect the response to the index page. Since the session is invalid at this point, the security mechanism automatically directs the user to the login page.</p><p>We are now ready to test form-based authentication. After building our application, deploying it, and pointing the browser to any of its pages, we should see our login page rendered in the browser as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_17.jpg" alt="Form-based authentication"/></div><p>If we submit invalid credentials, we are automatically forwarded to the login error page, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_18.jpg" alt="Form-based authentication"/></div><p>We can click on the <span class="strong"><strong>Try again</strong></span> link to try again. <a id="id877" class="indexterm"/>After entering the valid credentials, we are allowed into the application. The following screenshot shows the screen after a successful login:</p><div class="mediaobject"><img src="graphics/6886EN_09_19.jpg" alt="Form-based authentication"/></div><p>As we can see, we added a <span class="strong"><strong>Logout</strong></span> link to the page. This link directs the user to the <code class="literal">logout()</code> method<a id="id878" class="indexterm"/> of our CDI named bean, which, as mentioned before, simply invalidates the session. From the user's point of view, this link will simply log them out and direct them to the login screen.</p></div></div><div class="section" title="The certificate realm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec18"/>The certificate realm</h3></div></div></div><p>The certificate realm uses client-side <a id="id879" class="indexterm"/>certificates for authentication. Just like server-side certificates, client-side certificates are typically obtained from a certificate authority such as Verisign or Thawte. These certificate authorities verify that the certificate really belongs to who it says it belongs to.</p><p>Obtaining a certificate <a id="id880" class="indexterm"/>from a certificate authority costs money and takes some time. It might not be practical to obtain a certificate from one of the certificate authorities when we are developing and/or testing our application. Fortunately, we can create self-signed certificates for testing purposes.</p><div class="section" title="Creating self-signed certificates"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec05"/>Creating self-signed certificates</h4></div></div></div><p>We can create self-signed certificates<a id="id881" class="indexterm"/> with little effort with the <span class="strong"><strong>keytool</strong></span> utility<a id="id882" class="indexterm"/> included with the <span class="strong"><strong>Java Development Kit</strong></span> (<span class="strong"><strong>JDK</strong></span>).<a id="id883" class="indexterm"/>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>We will only briefly cover some of the keytool utility features, specifically the features that are necessary to create and import self-signed certificates into GlassFish and the browser. To learn more about the keytool utility, refer to <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html">http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html</a>.</p></div></div><p>You can generate a self-signed certificate by typing in the following command in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -genkey -v -alias selfsignedkey -keyalg RSA -storetype PKCS12 -keystore client_keystore.p12 -storepass wonttellyou -keypass wonttellyou</strong></span>
</pre></div><p>This command assumes that the keytool utility is in the system path. This tool can be found in the <code class="literal">bin</code> directory under the directory where JDK is installed.</p><p>Substitute the values for the <code class="literal">-storepass</code> and <code class="literal">-keypass</code> parameters with your own password. Both of these passwords must be the same in order to successfully use the certificate to authenticate the client. You may choose any value for the <code class="literal">-alias</code> parameter. You may also choose any value for the <code class="literal">-keystore</code> parameter<a id="id884" class="indexterm"/>. However, the value must end in <code class="literal">.p12</code>, since this command generates a file that needs to be imported into the web browser, and it won't be recognized unless it has the <code class="literal">.p12</code> extension.</p><p>After entering the above command from the command line, keytool will prompt for some information as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>What is your first and last name?</strong></span>

<span class="strong"><strong>  [Unknown]:  David Heffelfinger</strong></span>

<span class="strong"><strong>What is the name of your organizational unit?</strong></span>

<span class="strong"><strong>  [Unknown]:  Book Writing Division</strong></span>

<span class="strong"><strong>What is the name of your organization?</strong></span>

<span class="strong"><strong>  [Unknown]:  Ensode Technology, LLC</strong></span>

<span class="strong"><strong>What is the name of your City or Locality?</strong></span>

<span class="strong"><strong>  [Unknown]:  Fairfax</strong></span>

<span class="strong"><strong>What is the name of your State or Province?</strong></span>

<span class="strong"><strong>  [Unknown]:  Virginia</strong></span>

<span class="strong"><strong>What is the two-letter country code for this unit?</strong></span>

<span class="strong"><strong>  [Unknown]:  US</strong></span>

<span class="strong"><strong>Is CN=David Heffelfinger, OU=Book Writing Division, O="Ensode Technology, LLC", L=Fairfax, ST=Virginia, C=US correct?</strong></span>

<span class="strong"><strong>  [no]:  y</strong></span>
</pre></div><p>After entering the data for each prompt, keytool will generate the certificate. It will be stored in the current directory, and the name of the file will be the value we used for the <code class="literal">-keystore</code> parameter (<code class="literal">client_keystore.p12</code> in the example).</p><p>To be able to use this certificate <a id="id885" class="indexterm"/>to authenticate ourselves, we need to import it into the browser. The procedure, although similar, varies from browser to browser. In Firefox, this can be accomplished by going to the <span class="strong"><strong>Preferences</strong></span> menu, clicking on the <span class="strong"><strong>Advanced</strong></span> icon<a id="id886" class="indexterm"/> at the top of the pop-up window that appears, and then clicking on the <span class="strong"><strong>Certificates </strong></span>tab as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_20.jpg" alt="Creating self-signed certificates"/></div><p>We then need to navigate to <span class="strong"><strong>View Certificates</strong></span> | <span class="strong"><strong>Your Certificates</strong></span> | <span class="strong"><strong>Import</strong></span> on the window that appears. Then navigate and select our certificate from the directory in which it was created. At this point, Firefox<a id="id887" class="indexterm"/> will ask us for the password used to encrypt the certificate; in our example, we used <code class="literal">wonttellyou</code> as the password. After entering the password, we should see a pop-up window confirming that our certificate was successfully imported. We should then see it in the list of certificates, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_21.jpg" alt="Creating self-signed certificates"/></div><p>We have now added our certificate to Firefox so that it can be used to authenticate us. If you are using another browser,<a id="id888" class="indexterm"/> the procedure will be similar. Consult your browser's documentation for details.</p><p>The certificate we created in the previous step needs to be exported into a format that GlassFish can understand. We can accomplish this by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -export -alias selfsignedkey -keystore client_keystore.p12 -storetype PKCS12 -storepass wonttellyou -rfc -file selfsigned.cer</strong></span>
</pre></div><p>The value for the <code class="literal">-alias</code>, <code class="literal">-keystore</code>, and <code class="literal">-storepass</code> parameters must match the values used in the previous command. You may choose any value for the <code class="literal">-file</code> parameter, but it is recommended for the value to end in the <code class="literal">.cer</code> extension.</p><p>Since our certificate was not issued by a certificate authority, GlassFish by default will not recognize it as a valid certificate. GlassFish knows what certificates to trust based on the certificate authority that created them. This is implemented through the storing of certificates for these various authorities in a keystore named <code class="literal">cacerts.jks</code>. This keystore can be found at <code class="literal">[glassfish installation directory]/glassfish/domains/domain1/config/cacerts.jks</code>.</p><p>In order for GlassFish to accept our certificate, we need to import it into the <code class="literal">cacerts</code> keystore. This can be accomplished<a id="id889" class="indexterm"/> by issuing the following command from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -import -file selfsigned.cer -keystore [glassfish installation directory]/glassfish/domains/domain1/config/cacerts.jks -keypass changeit -storepass changeit</strong></span>
</pre></div><p>At this point, keytool <a id="id890" class="indexterm"/>will display the following certificate information in the command line and ask us if we want to trust it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Owner: CN=David Heffelfinger, OU=Book Writing Division, O="Ensode Technology, LLC", L=Fairfax, ST=Virginia, C=US</strong></span>

<span class="strong"><strong>Issuer: CN=David Heffelfinger, OU=Book Writing Division, O="Ensode Technology, LLC", L=Fairfax, ST=Virginia, C=US</strong></span>

<span class="strong"><strong>Serial number: 7a3bca0</strong></span>

<span class="strong"><strong>Valid from: Sun Oct 27 17:00:18 EDT 2013 until: Sat Jan 25 16:00:18 EST 2014</strong></span>

<span class="strong"><strong>Certificate fingerprints:</strong></span>

<span class="strong"><strong>   MD5:  46:EA:41:ED:12:8A:EC:CE:8C:BE:F2:49:D5:71:00:ED</strong></span>

<span class="strong"><strong>   SHA1: 32:C2:D4:20:87:22:95:25:5D:B0:AC:35:43:0D:60:35:94:27:44:58</strong></span>

<span class="strong"><strong>   SHA256: 8C:2E:56:F4:98:45:AC:46:FD:20:27:38:D2:7D:BF:D8:2D:56:D3:91:B7:78:AA:ED:FA:93:30:27:77:7F:F9:03</strong></span>

<span class="strong"><strong>   Signature algorithm name: SHA256withRSA</strong></span>

<span class="strong"><strong>   Version: 3</strong></span>


<span class="strong"><strong>Extensions: </strong></span>


<span class="strong"><strong>#1: ObjectId: 2.5.29.14 Criticality=false</strong></span>

<span class="strong"><strong>SubjectKeyIdentifier [</strong></span>

<span class="strong"><strong>KeyIdentifier [</strong></span>

<span class="strong"><strong>0000: E8 75 1D 12 2F 18 D0 4B   E5 84 C4 79 B6 C0 98 80  .u../..K...y....</strong></span>

<span class="strong"><strong>0010: 33 84 E7 C0                                        3...</strong></span>

<span class="strong"><strong>]</strong></span>

<span class="strong"><strong>]</strong></span>


<span class="strong"><strong>Trust this certificate? [no]:  y</strong></span>

<span class="strong"><strong>Certificate was added to keystore</strong></span>
</pre></div><p>Once we add the certificate to the <code class="literal">cacerts.jks</code> keystore, we need to restart the domain for the change to take effect.</p><p>What we are effectively doing here is adding ourselves as a certificate authority that GlassFish will trust. This, of<a id="id891" class="indexterm"/> course, should not be done in a production system.</p><p>The value for the <code class="literal">-file</code> parameter must match the value we used for this same parameter when we exported the certificate.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>Note that <code class="literal">changeit</code> is the default password for the <code class="literal">-keypass</code> and <code class="literal">-storepass</code> parameters for the <code class="literal">cacerts.jks</code> keystore. This value can be changed by issuing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[glassfish installation directory]/glassfish/bin/asadmin change-master-password --savemasterpassword=true</strong></span>
</pre></div><p>This command will prompt for the existing as well as the new master password. The <code class="literal">–savemasterpassword=true</code> parameter<a id="id892" class="indexterm"/> is optional; it saves the master password into a file called <code class="literal">master-password</code> in the root directory of the domain. If we don't use this parameter when changing the master password, then we will need to enter the master password every time we want to start the domain.</p></div></div><p>Now that we have created a self-signed certificate, imported it into our browser, and established ourselves as a certificate authority that GlassFish will trust, we are ready to develop an application that will use client-side certificates for authentication.</p></div><div class="section" title="Configuring applications to use the certificate realm"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec06"/>Configuring applications to use the certificate realm</h4></div></div></div><p>Since we are taking advantage of Java EE security features, we don't need to modify any code in order to use the security <a id="id893" class="indexterm"/>realm. All we need to do is modify the application's configuration on its deployment descriptors, <code class="literal">web.xml</code> and <code class="literal">glassfish-web.xml</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;AllPages&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;users&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
    &lt;user-data-constraint&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
<span class="strong"><strong>  &lt;login-config&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt;</strong></span>
<span class="strong"><strong>    &lt;realm-name&gt;certificate&lt;/realm-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/login-config&gt;</strong></span>
&lt;/web-app&gt;</pre></div><p>The main difference between this <code class="literal">web.xml</code> deployment descriptor and the one we saw in the previous section is the contents of the <code class="literal">&lt;login-config&gt; </code>element. In this case, we declared <code class="literal">CLIENT-CERT</code> as the authorization method and <code class="literal">certificate</code> as the realm to use to authenticate. This will have the effect of GlassFish asking the browser for a client certificate before allowing a user into the application.</p><p>When using client certificate authentication, the request must always be made via HTTPS. Therefore, it is a good idea to add the <code class="literal">&lt;transport-guarantee&gt;</code> element with a value of <code class="literal">CONFIDENTIAL</code> to the <code class="literal">web.xml</code> deployment descriptor. Recall from the previous section that this has the effect of forwarding any requests through the HTTP port to the HTTPS port. If we don't add this value to the <code class="literal">web.xml</code> deployment descriptor, any requests through the HTTP port will fail, since client certificate authentication cannot be done through the HTTP protocol.</p><p>Notice that we declared that only users with the role <code class="literal">user</code> can access any page in the system. We did this by adding the role <code class="literal">user</code> to the <code class="literal">&lt;role-name&gt;</code> element nested inside the <code class="literal">&lt;auth-constraint&gt;</code> element of the <code class="literal">&lt;security-constraint&gt;</code> element in the <code class="literal">web.xml</code> deployment descriptor. In order to allow access to authorized users, we need to add them to this role. This is done<a id="id894" class="indexterm"/> in the <code class="literal">glassfish-web.xml</code> deployment descriptor as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE glassfish-web-app PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 Servlet 3.0//EN" "http://glassfish.org/dtds/glassfish-web-app_3_0-1.dtd"&gt;
&lt;glassfish-web-app error-url=""&gt;
  &lt;context-root&gt;/certificaterealm&lt;/context-root&gt;
<span class="strong"><strong>  &lt;security-role-mapping&gt;</strong></span>
<span class="strong"><strong>    &lt;role-name&gt;user&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;principal-name&gt;CN=David Heffelfinger, OU=Book Writing Division, O="Ensode Technology, LLC", L=Fairfax, ST=Virginia, C=US&lt;/principal-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-role-mapping&gt;</strong></span>
<span class="strong"><strong>  &lt;class-loader delegate="true"/&gt;</strong></span>
&lt;/glassfish-web-app&gt;</pre></div><p>This assignment is done by mapping the principal user to a role in a <code class="literal">&lt;security-role-mapping&gt;</code> element in the <code class="literal">glassfish-web.xml</code> deployment descriptor; its <code class="literal">&lt;role-name&gt;</code> subelement must contain the role name, and the <code class="literal">&lt;principal-name&gt;</code> subelement must contain the username. This username is taken from the certificate.</p><p>If you are not sure of the name to use, it can be obtained from the certificate with the keytool utility as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -printcert -file selfsigned.cer</strong></span>
<span class="strong"><strong>Owner: CN=David Heffelfinger, OU=Book Writing Division, O="Ensode Technology, LLC", L=Fairfax, ST=Virginia, C=US</strong></span>

<span class="strong"><strong>Issuer: CN=David Heffelfinger, OU=Book Writing Division, O="Ensode Technology, LLC", L=Fairfax, ST=Virginia, C=US</strong></span>

<span class="strong"><strong>Serial number: 7a3bca0</strong></span>

<span class="strong"><strong>Valid from: Sun Oct 27 17:00:18 EDT 2013 until: Sat Jan 25 16:00:18 EST 2014</strong></span>

<span class="strong"><strong>Certificate fingerprints:</strong></span>

<span class="strong"><strong>   MD5:  46:EA:41:ED:12:8A:EC:CE:8C:BE:F2:49:D5:71:00:ED</strong></span>

<span class="strong"><strong>   SHA1: 32:C2:D4:20:87:22:95:25:5D:B0:AC:35:43:0D:60:35:94:27:44:58</strong></span>

<span class="strong"><strong>   SHA256: 8C:2E:56:F4:98:45:AC:46:FD:20:27:38:D2:7D:BF:D8:2D:56:D3:91:B7:78:AA:ED:FA:93:30:27:77:7F:F9:03</strong></span>

<span class="strong"><strong>   Signature algorithm name: SHA256withRSA</strong></span>

<span class="strong"><strong>   Version: 3</strong></span>


<span class="strong"><strong>Extensions: </strong></span>


<span class="strong"><strong>#1: ObjectId: 2.5.29.14 Criticality=false</strong></span>

<span class="strong"><strong>SubjectKeyIdentifier [</strong></span>

<span class="strong"><strong>KeyIdentifier [</strong></span>

<span class="strong"><strong>0000: E8 75 1D 12 2F 18 D0 4B   E5 84 C4 79 B6 C0 98 80  .u../..K...y....</strong></span>

<span class="strong"><strong>0010: 33 84 E7 C0                                        3...</strong></span>

<span class="strong"><strong>]</strong></span>

<span class="strong"><strong>]</strong></span>
</pre></div><p>The value to use as <code class="literal">&lt;principal-name&gt;</code> is the line after <code class="literal">Owner:</code>. Please note that the value of <code class="literal">&lt;principal-name&gt;</code> must be<a id="id895" class="indexterm"/> in the same line as its open and closing elements <code class="literal">(&lt;principal-name&gt;</code> and <code class="literal">&lt;/principal-name&gt;</code>). If there are newline or carriage return characters before or after the value, they are interpreted as being part of the value and validation will fail.</p><p>Since our application has a single user and a single role, we are ready to deploy it. If we had more users, we would have to add additional <code class="literal">&lt;security-role-mapping&gt;</code> elements to our <code class="literal">glassfish-web.xml </code>deployment descriptor, at least one per user. If we had users that belong to more than one role, then we would add a <code class="literal">&lt;security-role-mapping&gt;</code> element for each role the user belongs to, using the <code class="literal">&lt;principal-name&gt;</code> value corresponding to the user's certificate for each one of them.</p><p>We are now ready to test our application. After we deploy it and point the browser to any page in the application, we should see a screen like the following (assuming the browser hasn't been configured to provide a default certificate any time a server requests one):</p><div class="mediaobject"><img src="graphics/6886EN_09_22.jpg" alt="Configuring applications to use the certificate realm"/></div><p>After clicking on the <span class="strong"><strong>OK</strong></span> button, <a id="id896" class="indexterm"/>we are allowed to access the application, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_23.jpg" alt="Configuring applications to use the certificate realm"/></div><p>Before allowing access to the application, GlassFish checks the certificate authority that issued the certificate (since we self-signed the certificate, the owner of the certificate and the certificate authority are the same), checking against the list of trusted certificate authorities. Since we added<a id="id897" class="indexterm"/> ourselves as a trusted authority by importing our self-signed certificate into the <code class="literal">cacerts.jks</code> keystore, GlassFish recognizes the certificate authority as a valid one. It then gets the principal name from the certificate and compares it against entries in the application's <code class="literal">glassfish-web.xml</code> file. Since we added ourselves to this deployment descriptor and gave ourselves a valid role, we are allowed into the application.</p></div></div></div><div class="section" title="Defining additional realms"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec68"/>Defining additional realms</h2></div></div></div><p>In addition to the three <a id="id898" class="indexterm"/>preconfigured security realms we discussed in the previous section, we can create additional realms for application authentication. We can create realms that behave exactly like the file realm or admin-realm. We can also create realms that behave like the certificate realm. Additionally, we can create realms that use other methods of authentication.<a id="id899" class="indexterm"/> We can authenticate users against an LDAP database and against a relational database and, when GlassFish is installed on a Solaris server, use Solaris authentication within GlassFish. Also, if none of the predefined authentication mechanisms fit our needs, we can implement our own.</p><div class="section" title="Defining additional file realms"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec19"/>Defining additional file realms</h3></div></div></div><p>In the administration console, <a id="id900" class="indexterm"/> expand the <span class="strong"><strong>Configurations</strong></span> node, followed by the <span class="strong"><strong>server-config</strong></span> node<a id="id901" class="indexterm"/>, and then the <span class="strong"><strong>Security</strong></span> node. Click on the <span class="strong"><strong>Realms</strong></span> node and then on the <span class="strong"><strong>New...</strong></span> button on the resulting page in the main area of the web console. </p><p>We should now see a screen like the following:</p><div class="mediaobject"><img src="graphics/6886EN_09_24.jpg" alt="Defining additional file realms"/></div><p>All we need to do to create an additional realm is enter a unique name for it in the <span class="strong"><strong>Name</strong></span> field, pick <code class="literal">com.sun.enterprise.security.auth.realm.file.FileRealm</code> for the <span class="strong"><strong>Class Name</strong></span> field, and enter a value for the <span class="strong"><strong>JAAS Context</strong></span> and <span class="strong"><strong>Key File</strong></span> fields; the value for the <span class="strong"><strong>Key File</strong></span> field must be the<a id="id902" class="indexterm"/> absolute path to a file where user information will be stored and, for the file realm, the value for the <span class="strong"><strong>JAAS Context </strong></span>field must always be <code class="literal">fileRealm</code>.</p><p>After entering all of the required information, we can click on the <span class="strong"><strong>OK</strong></span> button and our new realm will be created. We can then use it just like the predefined file realm. Applications wanting to authenticate against this new realm must use its name as the value of the <code class="literal">&lt;realm-name&gt;</code> element in the application's <code class="literal">web.xml</code> deployment descriptor.</p><p>Alternatively, a custom file realm can be added from the command line via the <code class="literal">asadmin</code> utility by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>asadmin create-auth-realm --classname com.sun.enterprise.security.auth.realm.file.FileRealm --property file=/home/heffel/additionalFileRealmKeyFile:jaas-context=fileRealm newFileRealm</strong></span>
</pre></div><p>The <code class="literal">create-auth-realm</code> argument tells <code class="literal">asadmin</code> that we want to create a new security realm. The value of the <code class="literal">--classname</code> parameter corresponds to the security realm class name. Notice that it matches the value we selected above in the web console. The <code class="literal">--property</code> parameter allows us to pass<a id="id903" class="indexterm"/> properties and their values; the value of this parameter must be a colon (<code class="literal">:</code>) separated list of properties and their values. The last argument of this command is the name we wish to give our security realm.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Although it is easier to set up security realms via the web console, doing it through the <code class="literal">asadmin</code> command-line utility has the advantage that it is easily scriptable, allowing us to save this command in a script and easily configure several GlassFish instances.</p></div></div></div><div class="section" title="Defining additional certificate realms"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec20"/>Defining additional certificate realms</h3></div></div></div><p>To define an additional<a id="id904" class="indexterm"/> certificate realm, we simply need to enter its name in<a id="id905" class="indexterm"/> the <span class="strong"><strong>Name</strong></span> field and pick <code class="literal">com.sun.enterprise.security.auth.realm.certificate.CertificateRealm</code> as the value of the <code class="literal">Class Name</code> field and then click on <span class="strong"><strong>OK</strong></span> to create our new realm, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_25.jpg" alt="Defining additional certificate realms"/></div><p>Applications wanting to use this new <a id="id906" class="indexterm"/>realm for authentication must use its name as the value of the <code class="literal">&lt;realm-name&gt;</code> element in the <code class="literal">web.xml</code> deployment descriptor and specify <code class="literal">CLIENT-CERT</code> as the value of its <code class="literal">&lt;auth-method&gt;</code> element. Of course, client certificates must be present and configured as explained in the <span class="emphasis"><em>Configuring applications to use the certificate realm</em></span> section.</p><p>Alternatively, a custom certificate realm can be created on the command line via the <code class="literal">asadmin</code> utility by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>asadmin create-auth-realm --classname com.sun.enterprise.security.auth.realm.certificate.CertificateRealm newCertificateRealm</strong></span>
</pre></div><p>In this case, we don't need to pass any properties as we had to when we created the custom file realm. Therefore, all we need to do is pass the appropriate value to the <code class="literal">--classname</code> parameter<a id="id907" class="indexterm"/> and specify the new security realm name.</p></div><div class="section" title="Defining an LDAP realm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec21"/>Defining an LDAP realm</h3></div></div></div><p>We can easily set up a realm to authenticate against an <span class="strong"><strong>LDAP</strong></span> (<span class="strong"><strong>Lightweight Directory Access Protocol</strong></span>) database. <a id="id908" class="indexterm"/> In order<a id="id909" class="indexterm"/> to do this, we need to, in addition to the obvious step of entering a name for the realm, select <code class="literal">com.sun.enterprise.security.auth.realm.ldap.LDAPRealm</code> as the <span class="strong"><strong>Class Name</strong></span> value for a new realm. We then <a id="id910" class="indexterm"/>need to enter a URL for the directory server in the <span class="strong"><strong>Directory</strong></span> field and the base distinguished name to be used to search user data as the value of the <span class="strong"><strong>Base DN</strong></span> field, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_26.jpg" alt="Defining an LDAP realm"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>At the time of this writing, GlassFish had a bug that prevents LDAP realms from being added successfully from the web admin console. In this section, we explain what should happen, not what actually happens. Hopefully, by the time you read this, the issue will be fixed.</p><p>Adding an LDAP realm from the command line, as explained later in this section, works properly though.</p></div></div><p>After creating an LDAP realm, applications can use it to authenticate against the LDAP database. The name of the realm needs to be used as the value of the <code class="literal">&lt;realm-name&gt;</code> element in the application's <code class="literal">web.xml</code> deployment descriptor. The value of the <code class="literal">&lt;auth-method&gt;</code> element must be either <code class="literal">BASIC</code> or <code class="literal">FORM</code>. </p><p>Users and roles in the LDAP database can be mapped to groups in the<a id="id911" class="indexterm"/> application's <code class="literal">glassfish-web.xml</code> deployment descriptor using the <code class="literal">&lt;principal-name&gt;</code>, <code class="literal">&lt;role-name&gt;</code>, and <code class="literal">&lt;group-name&gt;</code> elements as discussed earlier in this chapter.</p><p>To create an LDAP realm from the command line, we need to use the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>asadmin create-auth-realm --classname com.sun.enterprise.security.auth.realm.ldap.LDAPRealm --property "jaas-context=ldapRealm:directory=ldap\://127.0.0.1\:1389:base-dn=dc\=ensode,dc\=com" newLdapRealm</strong></span>
</pre></div><p>Note that, in this case, the value of the <code class="literal">--property</code> parameter<a id="id912" class="indexterm"/> is between quotes. This is necessary because we need to escape some of the characters in its value, such as all the colons and equal signs. To escape these special characters, we simply prefix them with a backslash (<code class="literal">\</code>).</p></div><div class="section" title="Defining a Solaris realm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec22"/>Defining a Solaris realm</h3></div></div></div><p>When GlassFish is installed on a Solaris server, it can take advantage of the operating system authentication<a id="id913" class="indexterm"/> mechanism via a Solaris Realm. There are no special properties<a id="id914" class="indexterm"/> for this type of realm; all we need to do to create one is pick a name for it and select <code class="literal">com.sun.enterprise.security.auth.realm.solaris.SolarisRealm</code> as the value of the <span class="strong"><strong>Class Name</strong></span> field and enter <code class="literal">solarisRealm</code> as the value of the <span class="strong"><strong>JAAS Context</strong></span> field, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_27.jpg" alt="Defining a Solaris realm"/></div><p>The <span class="strong"><strong>JAAS Context</strong></span> field must be set to <code class="literal">solarisRealm</code>. After adding the realm, applications can authenticate <a id="id915" class="indexterm"/>against it using basic or form-based authentication. Operating system groups and users can be mapped to application roles defined in the application's <code class="literal">web.xml</code> deployment descriptor via the <code class="literal">&lt;principal-name&gt;</code>, <code class="literal">&lt;role-name&gt;</code>, and <code class="literal">&lt;group-name&gt;</code> elements in its <code class="literal">glassfish-web.xml</code> deployment descriptor.</p><p>A Solaris realm can be created from the command line by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>asadmin create-auth-realm --classname com.sun.enterprise.security.auth.realm.solaris.SolarisRealm --property jaas-context=solarisRealm newSolarisRealm</strong></span>
</pre></div></div><div class="section" title="Defining a JDBC realm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec23"/>Defining a JDBC realm</h3></div></div></div><p>Another type of realm we<a id="id916" class="indexterm"/> can create is a JDBC realm. This type of realm <a id="id917" class="indexterm"/>uses user information stored in database tables for user authentication.</p><p>In order to illustrate how to authenticate against a JDBC realm, we need to create a database to hold user information. The following entity-relationship diagram shows an example database we could use to authenticate against a JDBC realm:</p><div class="mediaobject"><img src="graphics/6886EN_09_28.jpg" alt="Defining a JDBC realm"/></div><p>Our database consists of three tables. A <code class="literal">USERS</code> table holding user information and a <code class="literal">GROUPS</code> table holding group information are two of them. Since there is a many-to-many relationship between <code class="literal">USERS</code> and <code class="literal">GROUPS</code>, we need to add a join table to preserve data normalization. The name<a id="id918" class="indexterm"/> of this third table is <code class="literal">USER_GROUPS</code>.</p><p>Notice that the <code class="literal">PASSWORD</code> column of the <code class="literal">USERS</code> table is of type <code class="literal">CHAR(32)</code>. The reason we chose this type instead of <code class="literal">VARCHAR</code> is that we will be hashing passwords using the MD5 hashing algorithm, and these hashes are always 32 characters.</p><p>Passwords can be easily encrypted in the expected format by using the <code class="literal">java.security.MessageDigest</code> class<a id="id919" class="indexterm"/> included with the JDK. The following example code will accept a clear-text password and create an MD5 hash out of it:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class EncryptPassword {

  public static String encryptPassword(String password)throws NoSuchAlgorithmException {
<span class="strong"><strong>    MessageDigest messageDigest = MessageDigest.getInstance("MD5");</strong></span>
    byte[] bs;

    messageDigest.reset();
<span class="strong"><strong>    bs = messageDigest.digest(password.getBytes());</strong></span>

    StringBuilder stringBuilder = new StringBuilder();

    //hex encode the digest
<span class="strong"><strong>    for (int i = 0; i &lt; bs.length; i++) {</strong></span>
<span class="strong"><strong>      String hexVal = Integer.toHexString(0xFF &amp; bs[i]);</strong></span>
<span class="strong"><strong>      if (hexVal.length() == 1) {</strong></span>
<span class="strong"><strong>        stringBuilder.append("0");</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>      stringBuilder.append(hexVal);</strong></span>
<span class="strong"><strong>    }</strong></span>

  return stringBuilder.toString();
  }

  public static void main(String[] args) {
    String encryptedPassword = null;

    try {

      if (args.length == 0) {
        System.err.println("Usage: java "+ "net.ensode.glassfishbook.EncryptPassword "+ "cleartext");
      } else {
        encryptedPassword = encryptPassword(args[0]);
        System.out.println(encryptedPassword);
      }
    } catch (NoSuchAlgorithmException e) {
       e.printStackTrace();
    }
  }
}</pre></div><p>The main functionality of the<a id="id920" class="indexterm"/> preceding class is defined in its <code class="literal">encryptPassword()</code> method<a id="id921" class="indexterm"/>. It basically accepts a clear-text string and digests it using the MD5 algorithm using the <code class="literal">digest()</code> method<a id="id922" class="indexterm"/> of an instance of <code class="literal">java.security.MessageDigest</code>. It then encodes the digest as a series of hexadecimal numbers. This encoding is necessary because GlassFish by default expects MD5-digested passwords to be hex encoded.</p><p>When using JDBC realms, <a id="id923" class="indexterm"/>application users and groups are not added to the realm via the GlassFish console. Instead, they are added by inserting data into the appropriate tables.</p><p>Once we have the database that will hold user credentials in place, we are ready to create a new JDBC realm.</p><p>We can create a JDBC realm by entering its name in the <span class="strong"><strong>Name</strong></span> field of the <span class="strong"><strong>New Realm</strong></span> form in the GlassFish web console and then selecting <code class="literal">com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm</code> as the value of the <span class="strong"><strong>Class Name</strong></span> field, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_29.jpg" alt="Defining a JDBC realm"/></div><p>There are a number of other properties we need to set for our new JDBC realm, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_30.jpg" alt="Defining a JDBC realm"/></div><p>The <span class="strong"><strong>JAAS Context</strong></span> field<a id="id924" class="indexterm"/> must be set to <code class="literal">jdbcRealm</code> for JDBC realms. The value of the <span class="strong"><strong>JNDI</strong></span> property must be the JNDI <a id="id925" class="indexterm"/>name of the data source corresponding to the database that contains the realm's user and group data. The value of the <span class="strong"><strong>User Table</strong></span> property<a id="id926" class="indexterm"/> must be the name of the table that contains username and password information.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>Notice that, in the preceding screenshot, we used <code class="literal">V_USER_ROLE</code> as the value for the <span class="strong"><strong>User Table</strong></span> property<a id="id927" class="indexterm"/>. <code class="literal">V_USER_ROLE</code> is a database view that contains both user and group information. We didn't use the <code class="literal">USERS</code> table directly because GlassFish assumes that both the user table and the group table contain a column containing the username. Doing this results in having duplicate data. To avoid this situation, we created a view that we could use as the value of both the <span class="strong"><strong>User Table</strong></span> and <span class="strong"><strong>Group Table</strong></span> (to be discussed shortly) properties.</p></div></div><p>The <span class="strong"><strong>User Name Column</strong></span> property<a id="id928" class="indexterm"/> must contain the column in the <span class="strong"><strong>User Table</strong></span> property that contains the usernames. The <span class="strong"><strong>Password Column</strong></span> property value must be the name of the column in the <span class="strong"><strong>User Table</strong></span> property that contains the<a id="id929" class="indexterm"/> user's password. The value of the <span class="strong"><strong>Group Table</strong></span> property must be the name of the table containing user groups. The <span class="strong"><strong>Group Name Column</strong></span> property must contain the name of the column in the <span class="strong"><strong>Group Table</strong></span> property containing user group names.</p><p>All other properties are optional and, in most cases, left blank. Of special interest is the <span class="strong"><strong>Digest Algorithm</strong></span> property<a id="id930" class="indexterm"/>. This property allows us to specify the message digest algorithm to use to hash the user's password. Valid values for this property include all algorithms supported by the JDK. These algorithms are MD2, MD5, SHA-1, SHA-256, SHA-384, and SHA-512. Additionally, if we wish to store user passwords in clear text, we can do so by using the value <code class="literal">none</code> for this property.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>MD2, MD5, and SHA-1 are not very secure, and in most cases should not be used.</p></div></div><p>Once we have defined our JDBC realm, we need to configure our application via its <code class="literal">web.xml</code> and <code class="literal">glassfish-web.xml</code> deployment descriptors. Configuring an application to rely on a JDBC realm for authorization and authentication is done just like when using any other type of realm.</p><p>In addition to declaring that we will rely on the JDBC realm for authentication and authorization, just like with other types of realms, we need to map the roles defined in the <code class="literal">web.xml</code> deployment descriptor to security group names. This is accomplished in the <code class="literal">glassfish-web.xml</code> deployment descriptor.</p><p>A JDBC realm can be created from the command line by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>asadmin create-auth-realm --classname com.sun.enterprise.security.ee.auth.realm.jdbc.JDBCRealm</strong></span>
<span class="strong"><strong>--property jaas-context=jdbcRealm:datasource-jndi=jdbc/__UserAuthPool:user-table=V_USER_ROLE:user-name-column=USERNAME:password-column=PASSWORD:group-table=V_USER_ROLE:group-name-column=GROUP_NAME newJdbcRealm</strong></span>
</pre></div></div><div class="section" title="Defining custom realms"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec24"/>Defining custom realms</h3></div></div></div><p>Although the predefined realm<a id="id931" class="indexterm"/> types should cover the vast majority of cases, we can create custom realm types if the provided ones don't meet our needs. Doing so<a id="id932" class="indexterm"/> involves coding custom <code class="literal">Realm</code> and <a id="id933" class="indexterm"/>
<code class="literal">LoginModule</code> classes. Let's first discuss the custom <code class="literal">Realm</code> class as follows:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import java.util.Enumeration;
import java.util.Vector;

import com.sun.enterprise.security.auth.realm.IASRealm;
import com.sun.enterprise.security.auth.realm.InvalidOperationException;
import com.sun.enterprise.security.auth.realm.NoSuchUserException;

<span class="strong"><strong>public class SimpleRealm extends IASRealm {</strong></span>

  @Override
<span class="strong"><strong>  public Enumeration getGroupNames(String userName)throws InvalidOperationException, NoSuchUserException {</strong></span>
    Vector vector = new Vector();

    vector.add("appuser");
    vector.add("appadmin");

    return vector.elements();
    }

  @Override
  public String getAuthType() {
    return "simple";
  }

  @Override
<span class="strong"><strong>  public String getJAASContext() {</strong></span>
    return "simpleRealm";
  }

<span class="strong"><strong>  public boolean loginUser(String userName, String password) {</strong></span>
    boolean loginSuccessful = false;

    if ("glassfish".equals(userName) &amp;&amp; "secret".equals(password)) {
      loginSuccessful = true;
    }

    return loginSuccessful;
  }
}</pre></div><p>Our custom <code class="literal">Realm</code> class must extend <code class="literal">com.sun.enterprise.security.auth.realm.IASRealm</code>. This class can be found inside the <code class="literal">security.jar</code> file, and therefore this JAR file must be added to the CLASSPATH before our <code class="literal">Realm</code> class can be successfully compiled.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>The <code class="literal">security.jar</code> file can be found under <code class="literal">[glassfish installation directory]/glassfish/modules</code>.</p><p>When using Maven or Ivy dependency management, this JAR file can be found in the following repository:</p><p>
<a class="ulink" href="http://download.java.net/maven/glassfish">http://download.java.net/maven/glassfish</a>
</p><p>The group ID is <code class="literal">org.glassfish.security</code> and the artifact ID is <code class="literal">security</code>.</p></div></div><p>Our class must override a method called <a id="id934" class="indexterm"/>
<code class="literal">getGroupNames()</code>. This method takes a single string as a parameter and returns an <code class="literal">Enumeration</code> parameter. The <code class="literal">String</code> parameter is for the username of <a id="id935" class="indexterm"/>the user that is attempting to log in to the realm. The <code class="literal">Enumeration</code> parameter<a id="id936" class="indexterm"/> must contain a collection of strings indicating what groups the user belongs to. In our simple example, we simply hardcoded the groups. In a real application, these groups would be obtained from some kind of persistent storage (database, file, and so on).</p><p>The next method our <code class="literal">Realm</code> class must override is the <code class="literal">getAuthType()</code> method<a id="id937" class="indexterm"/>. This method must return a <code class="literal">String</code> containing a description of the type of authentication used by this realm.</p><p>The <code class="literal">getGroupNames()</code> and <code class="literal">getAuthType()</code> methods are declared as abstract in the <code class="literal">IASRealm</code> (parent) class. Although the <code class="literal">getJAASContext()</code> method<a id="id938" class="indexterm"/> is not abstract, we should nevertheless override it, since the value it returns is used to determine the type of authentication to use from the application server's <code class="literal">login.conf</code> file. The return value of this method is used to map the realm to the corresponding login module.</p><p>Finally, our <code class="literal">Realm</code> class must contain a method to authenticate the user. We are free to call it anything we want. Additionally, we can use as many parameters of any type as we wish. Our simple example has the values for a single username and password hardcoded. Again, a real application would obtain valid credentials from some kind of persistent storage. This method is meant to be called from the corresponding login module class as follows:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import java.util.Enumeration;

import javax.security.auth.login.LoginException;

import com.sun.appserv.security.AppservPasswordLoginModule;
import com.sun.enterprise.security.auth.realm.InvalidOperationException;
import com.sun.enterprise.security.auth.realm.NoSuchUserException;

<span class="strong"><strong>public class SimpleLoginModule extends AppservPasswordLoginModule {</strong></span>

  @Override
<span class="strong"><strong>  protected void authenticateUser() throws LoginException {</strong></span>
    Enumeration userGroupsEnum = null;
    String[] userGroupsArray = null;
    SimpleRealm simpleRealm;

    if (!(_currentRealm instanceof SimpleRealm)) {
      throw new LoginException();
    } else {
      simpleRealm = (SimpleRealm) _currentRealm;
    }

<span class="strong"><strong>    if (simpleRealm.loginUser(_username, _password)) {</strong></span>
      try {
        userGroupsEnum = simpleRealm.getGroupNames(_username);
      } catch (InvalidOperationException e) {
        throw new LoginException(e.getMessage());
      } catch (NoSuchUserException e) {
        throw new LoginException(e.getMessage());
      }

      userGroupsArray = new String[2];
      int i = 0;

      while (userGroupsEnum.hasMoreElements()) {
        userGroupsArray[i++] = ((String) userGroupsEnum.nextElement());
      }
    } else {
      throw new LoginException();
    }
    commitUserAuthentication(userGroupsArray);
  }
}</pre></div><p>Our login module class must extend <code class="literal">com.sun.appserv.security.AppservPasswordLoginModule</code>. This class is also inside the <code class="literal">security.jar</code> file. Our login module class only needs to override a single method, namely <code class="literal">authenticateUser()</code>. <a id="id939" class="indexterm"/>This method takes no parameters and must throw a <code class="literal">LoginException</code> if user authentication is unsuccessful. The <code class="literal">_currentRealm</code> variable<a id="id940" class="indexterm"/> is defined in the parent class and is of type <code class="literal">com.sun.enterprise.security.auth.realm</code>. The <code class="literal">Realm</code> class is the parent of all <code class="literal">Realm</code> classes. This variable is initialized before the <code class="literal">authenticateUser()</code> method<a id="id941" class="indexterm"/> is executed. The <code class="literal">LoginModule</code> class<a id="id942" class="indexterm"/> must <a id="id943" class="indexterm"/>verify that this class is of the expected type (<code class="literal">SimpleRealm</code> in our example). If it is not, a <code class="literal">LoginException</code> must be thrown.</p><p>Two other variables that are defined in the parent class and initialized before the <code class="literal">authenticateUser()</code> method<a id="id944" class="indexterm"/> is executed are <code class="literal">_username</code> and <code class="literal">_password</code>. These variables contain the credentials the user entered in the login form (for form-based authentication) or pop-up window (for basic authentication). Our example simply passes these values to the <code class="literal">Realm</code> class so that it can verify the user credentials.</p><p>The <code class="literal">authenticateUser()</code> method<a id="id945" class="indexterm"/> must call the parent class's <code class="literal">commitUserAuthentication()</code> method<a id="id946" class="indexterm"/> upon successful authentication. This method takes an array of string objects containing the group the user belongs to. Our example simply invokes the <code class="literal">getGroupNames()</code> method<a id="id947" class="indexterm"/> defined in the <code class="literal">Realm</code> class and adds the elements of the <code class="literal">Enumeration</code> parameter it returns to an array; it then passes that array to <code class="literal">commitUserAuthentication()</code>.</p><p>GlassFish is unaware of the existence of our custom realm and login module classes. We need to add these classes to GlassFish's CLASSPATH. The easiest way to do this is to copy the JAR file containing our custom realm and login module at <code class="literal">[glassfish installation directory]/glassfish/domains/domain1/lib</code>.</p><p>The last step we need to follow before we can authenticate applications against our custom realm is to add our new custom realm to the domain's <code class="literal">login.conf</code> file as follows:</p><div class="informalexample"><pre class="programlisting">fileRealm {
  com.sun.enterprise.security.auth.login.FileLoginModule required;
};

ldapRealm {
  com.sun.enterprise.security.auth.login.LDAPLoginModule required;
};

solarisRealm {
  com.sun.enterprise.security.auth.login.SolarisLoginModule required;
};

jdbcRealm {
  com.sun.enterprise.security.auth.login.JDBCLoginModule required;
};

jdbcDigestRealm {
  com.sun.enterprise.security.auth.login.JDBCDigestLoginModule required;
};

pamRealm {

  com.sun.enterprise.security.ee.auth.login.PamLoginModule required;

};


<span class="strong"><strong>simpleRealm {</strong></span>
<span class="strong"><strong>  net.ensode.glassfishbook.SimpleLoginModule required;</strong></span>
<span class="strong"><strong>};</strong></span>
</pre></div><p>The value before the opening brace must match the return value of the <code class="literal">getJAASContext()</code> method<a id="id948" class="indexterm"/> defined in the <code class="literal">Realm</code> class. It is in this file that the <code class="literal">Realm</code> and <code class="literal">LoginModule</code> classes are linked to each other. The GlassFish domain needs to be restarted for this change to take effect.</p><p>We are now ready to use our custom<a id="id949" class="indexterm"/> realm to authenticate users in our applications. We need to add a new realm of the type we created via GlassFish's admin console as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_09_31.jpg" alt="Defining custom realms"/></div><p>To create our realm, as usual, we need to give it a name. Instead of selecting a class name from the dropdown, we need to type it into the text field. Our custom realm didn't have any properties; therefore, we don't have to add any in this example. If it did, they would be added by clicking on the <span class="strong"><strong>Add Property</strong></span> button<a id="id950" class="indexterm"/> and entering the property name and corresponding value. Our realm would then get the properties by overriding the <code class="literal">init()</code> method<a id="id951" class="indexterm"/> from its parent class. This method has the following signature:</p><div class="informalexample"><pre class="programlisting">protected void init(Properties arg0) throws BadRealmException, NoSuchRealmException</pre></div><p>The instance of <code class="literal">java.util.Properties</code> it takes as a parameter would be prepopulated with the properties entered in the page shown in the screenshot (our custom realm doesn't have any properties, <a id="id952" class="indexterm"/>but for those that do, properties are entered the page shown in the screenshot).</p><p>Once we have added the pertinent information for our new custom realm, we can use it just like we use any of the predefined realms. Applications need to specify its name as the value of the<a id="id953" class="indexterm"/> <code class="literal">&lt;realm-name&gt; </code>element of the application's <code class="literal">web.xml</code> deployment descriptor. Nothing extraordinary needs to be done at the application level.</p><p>Just like with standard realms, custom realms can be added via the <code class="literal">asadmin</code> command-line utility, for example, for our custom realm, we would execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>asadmin create-auth-realm --classname net.ensode.glassfishbook.SimpleRealm newCustomRealm</strong></span>
</pre></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we covered how to use GlassFish's default realms to authenticate our web applications. We covered the file realm, which stores user information in a flat file, and the certificate realm, which requires client-side certificates for user authentication.</p><p>We then covered how to create additional realms that behave just like the default realms by using the realm classes included with GlassFish.</p><p>We also covered how to use additional <code class="literal">Realm</code> classes included in GlassFish to create realms that authenticate against an LDAP database, against a relational database, and how to create realms that integrate with a Solaris server's authentication mechanism.</p><p>Finally, we covered how to create custom <code class="literal">Realm</code> classes for cases where the included ones don't fit our needs.</p><p>In the next chapter, we will cover SOAP web services with JAX-WS.</p></div></body></html>