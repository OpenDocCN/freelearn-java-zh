<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer179" class="Basic-Text-Frame">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-181" class="chapterTitle">Developing Reactive Microservices</h1>
    <p class="normal">In this chapter, we will learn how to develop reactive microservices, that is, how to develop non-blocking synchronous REST APIs and asynchronous event-driven services. We will also learn how to choose between these two alternatives. Finally, we will see how to create and run manual and automated tests of a reactive microservice landscape.</p>
    <p class="normal">As already described in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, the foundation for reactive systems is that they are message-driven—they use asynchronous communication. This enables them to be elastic, in other words, scalable and resilient, meaning that they are tolerant of failures. Elasticity and resilience together enable a reactive system to be responsive.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Choosing between non-blocking synchronous APIs and event-driven asynchronous services</li>
      <li class="bulletList">Developing non-blocking synchronous REST APIs</li>
      <li class="bulletList">Developing event-driven asynchronous services</li>
      <li class="bulletList">Running manual tests of the reactive microservice landscape</li>
      <li class="bulletList">Running automated tests of the reactive microservice landscape</li>
    </ul>
    <h1 id="_idParaDest-182" class="heading-1">Technical requirements</h1>
    <p class="normal">For instructions on how to install the tools used in this book and how to access the source code for this book, see:</p>
    <ul>
      <li class="bulletList"><em class="chapterRef">Chapter 21</em>, <em class="italic">Installation Instructions for macOS</em></li>
      <li class="bulletList"><em class="chapterRef">Chapter 22</em>, <em class="italic">Installation Instructions for Microsoft Windows with WSL 2 and Ubuntu</em></li>
    </ul>
    <p class="normal">The code examples in this chapter all come from the source code in <code class="inlineCode">$BOOK_HOME/Chapter07</code>.</p>
    <p class="normal">If you want to view the changes applied to the source code in this chapter, that is, see what it takes to make the microservices reactive, you can compare it with the source code for <em class="chapterRef">Chapter 6</em>, <em class="italic">Adding Persistence</em>. You can use your favorite <code class="inlineCode">diff</code> tool and compare the two folders, that is, <code class="inlineCode">$BOOK_HOME/Chapter06</code> and <code class="inlineCode">$BOOK_HOME/Chapter07</code>.</p>
    <h1 id="_idParaDest-183" class="heading-1">Choosing between non-blocking synchronous APIs and event-driven asynchronous services</h1>
    <p class="normal">When developing reactive microservices, it is not always obvious when to use non-blocking synchronous APIs and when to use event-driven asynchronous services. In general, to make a microservice <a id="_idIndexMarker456"/>robust and scalable, it is important to make it as autonomous as possible, for example, by minimizing its runtime dependencies. This is <a id="_idIndexMarker457"/>also known as <strong class="keyWord">loose coupling</strong>. Therefore, the asynchronous message passing of events is preferable over synchronous APIs. This is because the microservice <a id="_idIndexMarker458"/>will only depend on access to the messaging system at runtime, instead of being dependent on synchronous access to a number of other microservices.</p>
    <p class="normal">There are, however, a number of cases where synchronous APIs could be favorable. For example:</p>
    <ul>
      <li class="bulletList">For read operations where an end user is waiting for a response</li>
      <li class="bulletList">Where the client platforms are more suitable for consuming synchronous APIs, for example, mobile apps or SPA web applications</li>
      <li class="bulletList">Where the clients will connect to the service from other organizations – where it might be hard to agree on a common messaging system to use across organizations</li>
    </ul>
    <p class="normal">For the system landscape in this book, we will use the following:</p>
    <ul>
      <li class="bulletList">The create, read, and delete services exposed by the product composite microservice will be based on non-blocking synchronous APIs. The composite microservice is assumed to have clients on both web and mobile platforms, as well as clients coming from other organizations rather than the ones that operate the system landscape. Therefore, synchronous APIs seem like a natural match.</li>
      <li class="bulletList">The read services provided by the core microservices will also be developed as non-blocking synchronous APIs since there is an end user waiting for their responses.</li>
      <li class="bulletList">The create and delete services provided by the core microservices will be developed as event-driven asynchronous services, meaning that they will listen for create and delete events on topics dedicated to each microservice.</li>
      <li class="bulletList">The synchronous APIs provided by the composite microservices to create and delete aggregated product information will publish create and delete events on these topics. If the publish operation succeeds, it will return with a 202 (Accepted) response; otherwise, an error response will be returned. The 202 response differs from a normal 200 (OK) response – it indicates that the request has been accepted, but not fully processed. Instead, the processing will be completed asynchronously and independently of the 202 response.</li>
    </ul>
    <p class="normal">This is illustrated by the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_01.png" alt="Graphical user interface, diagram  Description automatically generated" width="877" height="275"/></figure>
    <p class="packt_figref">Figure 7.1: The microservice landscape</p>
    <p class="normal">First, let’s <a id="_idIndexMarker459"/>learn how we can develop non-blocking <a id="_idIndexMarker460"/>synchronous REST APIs, and thereafter, we will look at how to develop event-driven asynchronous services.</p>
    <h1 id="_idParaDest-184" class="heading-1">Developing non-blocking synchronous REST APIs</h1>
    <p class="normal">In this section, we will learn how to develop non-blocking versions of the read APIs. The composite <a id="_idIndexMarker461"/>service will make reactive, that is, non-blocking, calls in parallel to the three core services. When the composite service has received responses from all of the core services, it will create a composite response and send it back to the caller. This is illustrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_02.png" alt="Diagram  Description automatically generated" width="878" height="405"/></figure>
    <p class="packt_figref">Figure 7.2: The getCompositeProduct part of the landscape</p>
    <p class="normal">In this section, we will cover the following:</p>
    <ul>
      <li class="bulletList">An introduction to Project Reactor</li>
      <li class="bulletList">Non-blocking persistence using Spring Data for MongoDB</li>
      <li class="bulletList">Non-blocking REST APIs in the core services, including how to handle blocking code for the JPA-based persistence layer</li>
      <li class="bulletList">Non-blocking REST APIs in the composite service</li>
    </ul>
    <h2 id="_idParaDest-185" class="heading-2">An introduction to Project Reactor</h2>
    <p class="normal">As we mentioned in the <em class="italic">Spring WebFlux</em> section in <em class="chapterRef">Chapter 2</em>, <em class="italic">Introduction to Spring Boot</em>, the reactive <a id="_idIndexMarker462"/>support in Spring 5 is based <a id="_idIndexMarker463"/>on <strong class="keyWord">Project Reactor</strong> (<a href="https://projectreactor.io"><span class="url">https://projectreactor.io</span></a>). Project Reactor <a id="_idIndexMarker464"/>is based on the <em class="italic">Reactive Streams specification</em> (<a href="http://www.reactive-streams.org"><span class="url">http://www.reactive-streams.org</span></a>), a standard for building reactive applications. Project Reactor is fundamental – it is what Spring WebFlux, Spring WebClient, and Spring Data rely on to provide their reactive and non-blocking features.</p>
    <p class="normal">The programming model is based on processing streams of data, and the core data types in Project Reactor are <strong class="keyWord">Flux</strong> and <strong class="keyWord">Mono</strong>. A <code class="inlineCode">Flux</code> object is <a id="_idIndexMarker465"/>used to process a stream of <em class="italic">0...n</em> elements and a <code class="inlineCode">Mono</code> object is <a id="_idIndexMarker466"/>used to process a stream that either is empty or returns at most one element. We will see numerous examples of their usage in this chapter. As a short introduction, let’s look at the following test:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">testFlux</span><span class="hljs-params">()</span> {
  List&lt;Integer&gt; list = Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
    .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
    .map(n -&gt; n * <span class="hljs-number">2</span>)
    .log()
    .collectList().block();
  assertThat(list).containsExactly(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
}
</code></pre>
    <p class="normal">Here is an explanation of the preceding source code:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We initiate the stream with the integers <code class="inlineCode">1</code>, <code class="inlineCode">2</code>, <code class="inlineCode">3</code>, and <code class="inlineCode">4</code> using the static helper method <code class="inlineCode">Flux.just()</code>.</li>
      <li class="numberedList">Next, we <code class="inlineCode">filter</code> out the odd numbers – we only allow even numbers to proceed through the stream. In this test, these are <code class="inlineCode">2</code> and <code class="inlineCode">4</code>.</li>
      <li class="numberedList">Next, we transform (or <code class="inlineCode">map</code>) the values in the stream by multiplying them by <code class="inlineCode">2</code>, so they become <code class="inlineCode">4</code> and <code class="inlineCode">8</code>.</li>
      <li class="numberedList">Then, we <code class="inlineCode">log</code> the data that flows through the stream after the <code class="inlineCode">map</code> operation.</li>
      <li class="numberedList">We use the <code class="inlineCode">collectList</code> method to collect all items from the stream into a <code class="inlineCode">List</code>, emitted once the stream completes.</li>
      <li class="numberedList">So far, we have only declared the processing of a stream. To actually get the stream processed, we need someone to subscribe to it. The final call to the <code class="inlineCode">block</code> method will register a subscriber that waits for the processing to complete.</li>
      <li class="numberedList">The resulting list is saved in a member variable named <code class="inlineCode">list</code>.</li>
      <li class="numberedList">We can now wrap up the test by using the <code class="inlineCode">assertThat</code> method to assert that <code class="inlineCode">list</code> after the processing of the stream contains the expected result – the integers <code class="inlineCode">4</code> and <code class="inlineCode">8</code>.</li>
    </ol>
    <p class="normal">The log output will look like the following:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_03.png" alt="Text  Description automatically generated" width="877" height="164"/></figure>
    <p class="packt_figref">Figure 7.3: Log output for the code above</p>
    <p class="normal">From <a id="_idIndexMarker467"/>the preceding log output, we can see that:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The processing of the stream is started by a subscriber that subscribes to the stream and requests its content.</li>
      <li class="numberedList">Next, the integers <code class="inlineCode">4</code> and <code class="inlineCode">8</code> pass through the <code class="inlineCode">log</code> operation.</li>
      <li class="numberedList">The processing concludes with a call to the <code class="inlineCode">onComplete</code> method on the subscriber, notifying it that the stream has come to an end.</li>
    </ol>
    <p class="normal">For the <a id="_idIndexMarker468"/>full source code, see the <code class="inlineCode">ReactorTests</code> test class in the <code class="inlineCode">util</code> project.</p>
    <div class="packt_tip">
      <p class="normal">Normally, we don’t initiate the processing of the stream. Instead, we only define how it will be processed, and it will be the responsibility of an infrastructure component to initiate the processing. For example, Spring WebFlux will do this as a response to an incoming HTTP request. An exception to this rule of thumb is the case where blocking code needs a response from a reactive stream. In these cases, the blocking code can call the <code class="inlineCode">block()</code> method on the <code class="inlineCode">Flux</code> or <code class="inlineCode">Mono</code> object to get the response in a blocking way.</p>
    </div>
    <h2 id="_idParaDest-186" class="heading-2">Non-blocking persistence using Spring Data for MongoDB</h2>
    <p class="normal">Making <a id="_idIndexMarker469"/>the MongoDB-based repositories for the <code class="inlineCode">product</code> and <code class="inlineCode">recommendation</code> services reactive is very simple:</p>
    <ul>
      <li class="bulletList">Change <a id="_idIndexMarker470"/>the base class <a id="_idIndexMarker471"/>for the repositories to <code class="inlineCode">ReactiveCrudRepository</code></li>
      <li class="bulletList">Change the custom finder methods to return either a <code class="inlineCode">Mono</code> or a <code class="inlineCode">Flux</code> object</li>
    </ul>
    <p class="normal"><code class="inlineCode">ProductRepository</code> and <code class="inlineCode">RecommendationRepository</code> look like the following after the change:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ProductRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveCrudRepository</span> &lt;ProductEntity, String&gt; {
    Mono&lt;ProductEntity&gt; <span class="hljs-title">findByProductId</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">RecommendationRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveCrudRepository</span>&lt;RecommendationEntity, String&gt; {
    Flux&lt;RecommendationEntity&gt; <span class="hljs-title">findByProductId</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span>;
}
</code></pre>
    <p class="normal">No <a id="_idIndexMarker472"/>changes are applied to the persistence code for the <code class="inlineCode">review</code> service; it will remain blocking <a id="_idIndexMarker473"/>using the JPA repository. See the following section, <em class="italic">Dealing with blocking code</em>, for how to handle the blocking <a id="_idIndexMarker474"/>code in the persistence layer of the <code class="inlineCode">review</code> service.</p>
    <p class="normal">For the full source code, take a look at the following classes:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductRepository</code> in the <code class="inlineCode">product</code> project</li>
      <li class="bulletList"><code class="inlineCode">RecommendationRepository</code> in the <code class="inlineCode">recommendation</code> project</li>
    </ul>
    <h3 id="_idParaDest-187" class="heading-3">Changes in the test code</h3>
    <p class="normal">When it comes to testing the persistence layer, we have to make some changes. Since our persistence <a id="_idIndexMarker475"/>methods now return a <code class="inlineCode">Mono</code> or <code class="inlineCode">Flux</code> object, the test methods have to wait for the response to be available in the returned reactive objects. The test methods can either use an explicit call to the <code class="inlineCode">block()</code> method on the <code class="inlineCode">Mono</code>/<code class="inlineCode">Flux</code> object to wait until a response is available, or they can use the <code class="inlineCode">StepVerifier</code> helper class from Project Reactor to declare a verifiable sequence of asynchronous events.</p>
    <p class="normal">Let’s see how we can change the following test code to work for the reactive version of the repository:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ProductEntity</span> <span class="hljs-variable">foundEntity</span> <span class="hljs-operator">=</span> repository.findById(newEntity.getId()).get();
assertEqualsProduct(newEntity, foundEntity);
</code></pre>
    <p class="normal">We can use the <code class="inlineCode">block()</code> method on the <code class="inlineCode">Mono</code> object returned by the <code class="inlineCode">repository.findById()</code> method and keep the imperative programming style, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ProductEntity</span> <span class="hljs-variable">foundEntity</span> <span class="hljs-operator">=</span> repository.findById(newEntity.getId()).<span class="code-highlight"><strong class="hljs-slc">block();</strong></span>
assertEqualsProduct(newEntity, foundEntity);
</code></pre>
    <p class="normal">Alternatively, we can use the <code class="inlineCode">StepVerifier</code> class to set up a sequence of processing steps that both executes the repository find operation and also verifies the result. The sequence is initialized by the final call to the <code class="inlineCode">verifyComplete()</code> method like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">StepVerifier</strong></span>.create(repository.findById(newEntity.getId()))
  .expectNextMatches(foundEntity -&gt; areProductEqual(newEntity, foundEntity))
  .<span class="code-highlight"><strong class="hljs-slc">verifyComplete</strong></span>();
</code></pre>
    <p class="normal">For examples of tests that use the <code class="inlineCode">StepVerifier</code> class, see the <code class="inlineCode">PersistenceTests</code> test class in the <code class="inlineCode">product</code> project.</p>
    <p class="normal">For corresponding <a id="_idIndexMarker476"/>examples of tests that use the <code class="inlineCode">block()</code> method, see the <code class="inlineCode">PersistenceTests</code> test class in the <code class="inlineCode">recommendation</code> project.</p>
    <h2 id="_idParaDest-188" class="heading-2">Non-blocking REST APIs in the core services</h2>
    <p class="normal">With a <a id="_idIndexMarker477"/>non-blocking persistence layer in place, it’s time <a id="_idIndexMarker478"/>to make the APIs in the core services non-blocking as well. We need to make the following changes:</p>
    <ul>
      <li class="bulletList">Change the APIs so that they only return reactive data types</li>
      <li class="bulletList">Change the service implementations so they don’t contain any blocking code</li>
      <li class="bulletList">Change our tests so that they can test the reactive services</li>
      <li class="bulletList">Deal with blocking code – isolate the code that still needs to be blocking from the non-blocking code</li>
    </ul>
    <h3 id="_idParaDest-189" class="heading-3">Changes in the APIs</h3>
    <p class="normal">To make <a id="_idIndexMarker479"/>the APIs of the core services reactive, we need to update their methods so that they return either a <code class="inlineCode">Mono</code> or <code class="inlineCode">Flux</code> object.</p>
    <p class="normal">For example, <code class="inlineCode">getProduct()</code> in the <code class="inlineCode">product</code> service now returns <code class="inlineCode">Mono&lt;Product&gt;</code> instead of a <code class="inlineCode">Product</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">Mono&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-meta">@PathVariable</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span>;
</code></pre>
    <p class="normal">For the full source code, take a look at the following <code class="inlineCode">core</code> interfaces in the <code class="inlineCode">api</code> project:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductService</code></li>
      <li class="bulletList"><code class="inlineCode">RecommendationService</code></li>
      <li class="bulletList"><code class="inlineCode">ReviewService</code></li>
    </ul>
    <h3 id="_idParaDest-190" class="heading-3">Changes in the service implementations</h3>
    <p class="normal">For the implementations of the services in the <code class="inlineCode">product</code> and <code class="inlineCode">recommendation</code> projects, which use a reactive <a id="_idIndexMarker480"/>persistence layer, we can use the fluent API in Project Reactor. For example, the implementation of the <code class="inlineCode">getProduct()</code> method looks like the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-slc">Mono</strong></span>&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
    <span class="hljs-keyword">if</span> (productId &lt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">InvalidInputException</span>(<span class="hljs-string">"Invalid productId: "</span> + productId);
    }
    <span class="hljs-keyword">return</span> repository.<span class="code-highlight"><strong class="hljs-slc">findByProductId(productId)</strong></span>
        .switchIfEmpty(Mono.error(<span class="hljs-keyword">new</span> <span class="code-highlight"><strong class="hljs-title-slc">NotFoundException</strong></span>(<span class="hljs-string">"No product found</span>
<span class="hljs-string">         for productId: "</span> + productId)))
        .log(LOG.getName(), FINE)
        .map(e -&gt; <span class="code-highlight"><strong class="hljs-slc">mapper.entityToApi</strong></span>(e))
        .map(e -&gt; <span class="code-highlight"><strong class="hljs-slc">setServiceAddress</strong></span>(e));
} 
</code></pre>
    <p class="normal">Let’s examine what the code does:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The method will return a <code class="inlineCode">Mono</code> object; the processing is only declared here. The processing is triggered by the web framework, Spring WebFlux, subscribing to the <code class="inlineCode">Mono</code> object once it receives a request to this service!</li>
      <li class="numberedList">A product will be retrieved using its <code class="inlineCode">productId</code> from the underlying database using the <code class="inlineCode">findByProductId()</code> method in the persistence repository.</li>
      <li class="numberedList">If no product is found for the given <code class="inlineCode">productId</code>, a <code class="inlineCode">NotFoundException</code> will be thrown.</li>
      <li class="numberedList">The <code class="inlineCode">log</code> method will produce log output.</li>
      <li class="numberedList">The <code class="inlineCode">mapper.entityToApi()</code> method will be called to transform the returned entity from the persistence layer into an API model object.</li>
      <li class="numberedList">The final <code class="inlineCode">map</code> method will use a helper method, <code class="inlineCode">setServiceAddress()</code>, to set the DNS name and IP address of the microservices that processed the request in the <code class="inlineCode">serviceAddress</code> field of the model object.</li>
    </ol>
    <p class="normal">Some <a id="_idIndexMarker481"/>example log output for successful processing is as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_04.png" alt="Text  Description automatically generated" width="878" height="110"/></figure>
    <p class="packt_figref">Figure 7.4: Log output when processing is successful</p>
    <p class="normal">The following is an example log output of a failed processing (throwing a <code class="inlineCode">NotFoundException</code>):</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_05.png" alt="Text  Description automatically generated" width="878" height="217"/></figure>
    <p class="packt_figref">Figure 7.5: Log output when processing fails</p>
    <p class="normal">For the full source code, see the following classes:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductServiceImpl</code> in the <code class="inlineCode">product</code> project</li>
      <li class="bulletList"><code class="inlineCode">RecommendationServiceImpl</code> in the <code class="inlineCode">recommendation</code> project</li>
    </ul>
    <h3 id="_idParaDest-191" class="heading-3">Changes in the test code</h3>
    <p class="normal">The test code for service implementations has been changed in the same way as the tests for the <a id="_idIndexMarker482"/>persistence layer we described previously. To handle the asynchronous behavior of the reactive return types, <code class="inlineCode">Mono</code> and <code class="inlineCode">Flux</code>, the tests use a mix of calling the <code class="inlineCode">block()</code> method and using the <code class="inlineCode">StepVerifier</code> helper class.</p>
    <p class="normal">For the full source code, see the following test classes:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductServiceApplicationTests</code> in the <code class="inlineCode">product</code> project</li>
      <li class="bulletList"><code class="inlineCode">RecommendationServiceApplicationTests</code> in the <code class="inlineCode">recommendation</code> project</li>
    </ul>
    <h3 id="_idParaDest-192" class="heading-3">Dealing with blocking code</h3>
    <p class="normal">In the case of the <code class="inlineCode">review</code> service, which uses JPA to access its data in a relational database, we don’t have <a id="_idIndexMarker483"/>support for a non-blocking programming model. Instead, we can run the blocking code using a <code class="inlineCode">Scheduler</code>, which is capable of running the blocking code on a thread from a dedicated thread pool with a limited number of threads. Using a thread pool for the blocking code avoids draining the available threads in the microservice and avoids affecting concurrent non-blocking processing in the microservice, if there is any.</p>
    <p class="normal">Let’s see how this can be set up in the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we configure a scheduler bean and its thread pool in the main class <code class="inlineCode">ReviewServiceApplication</code>, as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">ReviewServiceApplication</span><span class="hljs-params">(</span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${</span><span class="code-highlight"><strong class="hljs-meta-slc">app.threadPoolSize:10</strong></span><span class="hljs-meta">}")</span><span class="hljs-params"> Integer threadPoolSize,</span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${</span><span class="code-highlight"><strong class="hljs-meta-slc">app.taskQueueSize:100</strong></span><span class="hljs-meta">}")</span><span class="hljs-params"> Integer taskQueueSize</span>
<span class="hljs-params">)</span> {
  <span class="hljs-built_in">this</span>.threadPoolSize = threadPoolSize;
  <span class="hljs-built_in">this</span>.taskQueueSize = taskQueueSize;
}
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Scheduler <span class="code-highlight"><strong class="hljs-title-slc">jdbcScheduler</strong></span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> Schedulers.newBoundedElastic(threadPoolSize,
    taskQueueSize, <span class="hljs-string">"jdbc-pool"</span>);
}
</code></pre>
        <p class="normal">From the preceding code, we can see that the scheduler bean is named <code class="inlineCode">jdbcScheduler</code> and that we can configure its thread pool using the following properties:</p>
      </li>
    </ol>
    <ul>
      <li class="bulletList"><code class="inlineCode">app.threadPoolSize</code>, specifying the max number of threads in the pool; defaults to <code class="inlineCode">10</code></li>
      <li class="bulletList"><code class="inlineCode">app.taskQueueSize</code>, specifying the max number of tasks that are allowed to be placed in a queue waiting for available threads; defaults to <code class="inlineCode">100</code></li>
    </ul>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Next, we inject the scheduler named <code class="inlineCode">jdbcScheduler</code> into the <code class="inlineCode">review</code> service implementation class, as shown here:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReviewServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ReviewService</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Scheduler jdbcScheduler;
  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title">ReviewServiceImpl</span><span class="hljs-params">(</span>
<span class="hljs-params">    </span><span class="code-highlight"><strong class="hljs-meta-slc">@Qualifier("jdbcScheduler")</strong></span>
<span class="hljs-params">    </span><span class="code-highlight"><strong class="hljs-params-slc">Scheduler jdbcScheduler</strong></span><span class="hljs-params">, ...)</span> {
    <span class="hljs-built_in">this</span>.jdbcScheduler = jdbcScheduler;
  }
</code></pre>
      </li>
      <li class="numberedList">Finally, we use <a id="_idIndexMarker484"/>the scheduler’s thread pool in the reactive implementation of the <code class="inlineCode">getReviews()</code> method, like so:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Flux&lt;Review&gt; <span class="hljs-title">getReviews</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
  <span class="hljs-keyword">if</span> (productId &lt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">InvalidInputException</span>(<span class="hljs-string">"Invalid productId: "</span> + 
      productId);
  }
  LOG.info(<span class="hljs-string">"Will get reviews for product with id={}"</span>, 
    productId);
  <span class="hljs-keyword">return</span> Mono.fromCallable(() -&gt; internalGetReviews(productId))
    .flatMapMany(Flux::fromIterable)
    .log(LOG.getName(), FINE)
    .subscribeOn(jdbcScheduler);
}
<span class="hljs-keyword">private</span> List&lt;Review&gt; <span class="hljs-title">internalGetReviews</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
  List&lt;ReviewEntity&gt; entityList = repository.
    findByProductId(productId);
  List&lt;Review&gt; list = mapper.entityListToApiList(entityList);
  list.forEach(e -&gt; e.setServiceAddress(serviceUtil.
    getServiceAddress()));
  LOG.debug(<span class="hljs-string">"Response size: {}"</span>, list.size());
  <span class="hljs-keyword">return</span> list;
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Here, the blocking code is placed in the <code class="inlineCode">internalGetReviews()</code> method and is wrapped in a <code class="inlineCode">Mono</code> object using the <code class="inlineCode">Mono.fromCallable()</code> method. The <code class="inlineCode">getReviews()</code> method uses the <code class="inlineCode">subscribeOn()</code> method to run the blocking code in a thread from the thread pool of <code class="inlineCode">jdbcScheduler</code>.</p>
    <p class="normal">When we run tests later on in this chapter, we can look at the log output from the <code class="inlineCode">review</code> service and see proof that SQL statements are run in threads from the scheduler’s dedicated pool. We will be able to see log output like this:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_06.png" alt="Text  Description automatically generated" width="877" height="115"/></figure>
    <p class="packt_figref">Figure 7.6: Log output from the review service</p>
    <p class="normal">From the <a id="_idIndexMarker485"/>preceding log output, we can see the following:</p>
    <ul>
      <li class="bulletList">The first log output is from the <code class="inlineCode">LOG.info()</code> call in the <code class="inlineCode">getReviews()</code> method and it is executed on an HTTP thread, named <code class="inlineCode">ctor-http-nio-4</code>, a thread used by WebFlux.</li>
      <li class="bulletList">In the second log output, we can see the SQL statement generated by Spring Data JPA, using Hibernate under the hood. The SQL statement corresponds to the method call <code class="inlineCode">repository.findByProductId()</code>. It is executed on a thread named <code class="inlineCode">jdbc-pool-1</code>, meaning it is executed in a thread from the dedicated thread pool for blocking code, as expected!</li>
    </ul>
    <p class="normal">For the full source code, see the <code class="inlineCode">ReviewServiceApplication</code> and <code class="inlineCode">ReviewServiceImpl</code> classes in the <code class="inlineCode">review</code> project.</p>
    <p class="normal">With the logic for handling blocking code in place, we are done with implementing the non-blocking REST APIs in the core services. Let’s move on and see how to also make the REST APIs in the composite services non-blocking.</p>
    <h2 id="_idParaDest-193" class="heading-2">Non-blocking REST APIs in the composite services</h2>
    <p class="normal">To make <a id="_idIndexMarker486"/>our REST API in the composite service <a id="_idIndexMarker487"/>non-blocking, we need to do the following:</p>
    <ul>
      <li class="bulletList">Change the API so that its operations only return reactive data types</li>
      <li class="bulletList">Change the service implementation so it calls the coreata services’ APIs in parallel and in a non-blocking way</li>
      <li class="bulletList">Change the integration layer so it uses a non-blocking HTTP client</li>
      <li class="bulletList">Change our tests so that they can test the reactive service</li>
    </ul>
    <h3 id="_idParaDest-194" class="heading-3">Changes in the API</h3>
    <p class="normal">To make the API of the composite service reactive, we need to apply the same type of change that we <a id="_idIndexMarker488"/>applied for the APIs of the core services we described previously. This means that the return type of the <code class="inlineCode">getProduct()</code> method, <code class="inlineCode">ProductAggregate</code>, needs to be replaced with <code class="inlineCode">Mono&lt;ProductAggregate&gt;</code>. </p>
    <p class="normal">The <code class="inlineCode">createProduct()</code> and <code class="inlineCode">deleteProduct()</code> methods need to be updated to return a <code class="inlineCode">Mono&lt;Void&gt;</code> instead of a <code class="inlineCode">void</code>; otherwise, we can’t propagate any error responses back to the callers of the API.</p>
    <p class="normal">For the full source code, see the <code class="inlineCode">ProductCompositeService</code> interface in the <code class="inlineCode">api</code> project.</p>
    <h3 id="_idParaDest-195" class="heading-3">Changes in the service implementation</h3>
    <p class="normal">To be able to call the three APIs in parallel, the service implementation uses the static <code class="inlineCode">zip()</code> method <a id="_idIndexMarker489"/>on the <code class="inlineCode">Mono</code> class. The <code class="inlineCode">zip</code> method is capable of handling a number of parallel reactive requests and zipping them together once they all are complete. The code looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Mono&lt;ProductAggregate&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
  <span class="hljs-keyword">return</span> <span class="code-highlight"><strong class="hljs-slc">Mono.zip</strong></span>(
    
    <span class="code-highlight"><strong class="hljs-slc">values</strong></span> -&gt; <span class="code-highlight"><strong class="hljs-slc">createProductAggregate</strong></span>(
      (Product) values[<span class="hljs-number">0</span>], 
      (List&lt;Recommendation&gt;) values[<span class="hljs-number">1</span>], 
      (List&lt;Review&gt;) values[<span class="hljs-number">2</span>], 
      serviceUtil.getServiceAddress()),
      
    integration.getProduct(productId),
    integration.getRecommendations(productId).collectList(),
    integration.getReviews(productId).collectList())
      
    .doOnError(ex -&gt; 
      LOG.warn(<span class="hljs-string">"getCompositeProduct failed: {}"</span>, 
      ex.toString()))
    .log(LOG.getName(), FINE);
}
</code></pre>
    <p class="normal">Let’s take a closer look:</p>
    <ul>
      <li class="bulletList">The first parameter of the <code class="inlineCode">zip</code> method is a lambda function that will receive the responses in an array, named <code class="inlineCode">values</code>. The array will contain a product, a list of recommendations, and a list of reviews. The actual aggregation of the responses from the three API calls is handled by the same helper method as before, <code class="inlineCode">createProductAggregate()</code>, without any changes.</li>
      <li class="bulletList">The parameters after the lambda function are a list of the requests that the <code class="inlineCode">zip</code> method will call in parallel, one <code class="inlineCode">Mono</code> object per request. In our case, we send in three <code class="inlineCode">Mono</code> objects that were created by the methods in the integration class, one for each request that is sent to each core microservice.</li>
    </ul>
    <p class="normal">For the full source code, see the <code class="inlineCode">ProductCompositeServiceImpl</code> class in the <code class="inlineCode">product-composite</code> project.</p>
    <div class="note">
      <p class="normal">For information on how the <code class="inlineCode">createProduct</code> and <code class="inlineCode">deleteProduct</code> API operations are implemented in the <code class="inlineCode">product-composite</code> service, see the <em class="italic">Publishing events in the composite service</em> section later on.</p>
    </div>
    <h3 id="_idParaDest-196" class="heading-3">Changes in the integration layer</h3>
    <p class="normal">In the <code class="inlineCode">ProductCompositeIntegration</code> integration class, we have replaced the blocking HTTP client, <code class="inlineCode">RestTemplate</code>, with a non-blocking HTTP client, <code class="inlineCode">WebClient</code>, that comes with Spring 5.</p>
    <p class="normal">To create a <code class="inlineCode">WebClient</code> instance, a <strong class="keyWord">builder pattern</strong> is used. If customization is required, for example, setting up common headers or filters, it can be done using the builder. For the available <a id="_idIndexMarker490"/>configuration options, see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder"><span class="url">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder</span></a>.</p>
    <p class="normal">The <code class="inlineCode">WebClient</code> is used as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In the constructor, the <code class="inlineCode">WebClient</code> is auto-injected. We build the <code class="inlineCode">WebClient</code> instance without any configuration:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductCompositeIntegration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductService</span>, RecommendationService, ReviewService {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">ProductCompositeIntegration</span><span class="hljs-params">(</span>
<span class="hljs-params">        </span><span class="code-highlight"><strong class="hljs-params-slc">WebClient.Builder webClient</strong></span><span class="hljs-params">, ...</span>
<span class="hljs-params">    )</span> {
        <span class="hljs-built_in">this</span>.webClient = webClient.build();
    }
</code></pre>
      </li>
      <li class="numberedList">Next, we use the <code class="inlineCode">webClient</code> instance to make our non-blocking requests for calling the <code class="inlineCode">product</code> service:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Mono&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> productServiceUrl + <span class="hljs-string">"/product/"</span> + productId;
  <span class="hljs-keyword">return</span> <span class="code-highlight"><strong class="hljs-slc">webClient</strong></span>.get().uri(url).retrieve()
    .bodyToMono(Product.class)
    .log(LOG.getName(), FINE)
    .<span class="code-highlight"><strong class="hljs-slc">onErrorMap</strong></span>(WebClientResponseException.class, 
      ex -&gt; handleException(ex)
    );
}
</code></pre>
      </li>
    </ol>
    <p class="normal">If the API call to the <code class="inlineCode">product</code> service fails with an HTTP error response, the whole API request will fail. The <code class="inlineCode">onErrorMap()</code> method in <code class="inlineCode">WebClient</code> will call our <code class="inlineCode">handleException(ex)</code> method, which maps the HTTP exceptions thrown by the HTTP layer to our own exceptions, for example, a <code class="inlineCode">NotFoundException</code> or a <code class="inlineCode">InvalidInputException</code>.</p>
    <p class="normal">However, if calls to the <code class="inlineCode">product</code> service succeed but the call to either the <code class="inlineCode">recommendation</code> or <code class="inlineCode">review</code> API fails, we don’t want to let the whole request fail. Instead, we want to return as much information as is available back to the caller. Therefore, instead of propagating an exception in these cases, we will instead return an empty list of recommendations or reviews. To suppress the error, we will make the call <code class="inlineCode">onErrorResume(error -&gt; empty())</code>. For this, the code looks like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Flux&lt;Recommendation&gt; <span class="hljs-title">getRecommendations</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> recommendationServiceUrl + <span class="hljs-string">"/recommendation?</span>
<span class="hljs-string">  productId="</span> + productId;
  <span class="hljs-comment">// Return an empty result if something goes wrong to make it </span>
  <span class="hljs-comment">// possible for the composite service to return partial responses</span>
  <span class="hljs-keyword">return</span> webClient.get().uri(url).retrieve()
    .bodyToFlux(Recommendation.class)
    .log(LOG.getName(), FINE)
    .<span class="code-highlight"><strong class="hljs-slc">onErrorResume(error -&gt; empty());</strong></span>
}
</code></pre>
    <p class="normal">The <code class="inlineCode">GlobalControllerExceptionHandler</code> class, from the <code class="inlineCode">util</code> project, will, as previously, catch exceptions and transform them into proper HTTP error responses that are sent back to the caller <a id="_idIndexMarker491"/>of the composite API. This way we can decide if a specific HTTP error response from the underlying API calls will result in an HTTP error response or just a partly empty response.</p>
    <p class="normal">For the full source code, see the <code class="inlineCode">ProductCompositeIntegration</code> class in the <code class="inlineCode">product-composite</code> project.</p>
    <h3 id="_idParaDest-197" class="heading-3">Changes in the test code</h3>
    <p class="normal">The only change that’s required in the test classes is to update the setup of Mockito and its mock of <a id="_idIndexMarker492"/>the integration class. The mock needs to return <code class="inlineCode">Mono</code> and <code class="inlineCode">Flux</code> objects. The <code class="inlineCode">setup()</code> method uses the helper methods <code class="inlineCode">Mono.just()</code> and <code class="inlineCode">Flux.fromIterable()</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductCompositeServiceApplicationTests</span> {
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> {
        when(compositeIntegration.getProduct(PRODUCT_ID_OK)).
            thenReturn(<span class="code-highlight"><strong class="hljs-slc">Mono.just</strong></span>(<span class="hljs-keyword">new</span> <span class="hljs-title">Product</span>(PRODUCT_ID_OK, <span class="hljs-string">"name"</span>, <span class="hljs-number">1</span>,
             <span class="hljs-string">"mock-address"</span>)));
        when(compositeIntegration.getRecommendations(PRODUCT_ID_OK)).
            thenReturn(<span class="code-highlight"><strong class="hljs-slc">Flux.fromIterable</strong></span>(singletonList(<span class="hljs-keyword">new</span> 
             <span class="hljs-title">Recommendation</span>(PRODUCT_ID_OK, <span class="hljs-number">1</span>, <span class="hljs-string">"author"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"content"</span>,
             <span class="hljs-string">"mock address"</span>))));
        when(compositeIntegration.getReviews(PRODUCT_ID_OK)).
            thenReturn(<span class="code-highlight"><strong class="hljs-slc">Flux.fromIterable</strong></span>(singletonList(<span class="hljs-keyword">new</span>
             <span class="hljs-title">Review</span>(PRODUCT_ID_OK, <span class="hljs-number">1</span>, <span class="hljs-string">"author"</span>, <span class="hljs-string">"subject"</span>, <span class="hljs-string">"content"</span>,
             <span class="hljs-string">"mock address"</span>))));
</code></pre>
    <p class="normal">For the full source code, see the <code class="inlineCode">ProductCompositeServiceApplicationTests</code> test class in the <code class="inlineCode">product-composite</code> project.</p>
    <p class="normal">This <a id="_idIndexMarker493"/>completes the implementation of our non-blocking synchronous REST APIs. Now it is time to develop our event-driven asynchronous services.</p>
    <h1 id="_idParaDest-198" class="heading-1">Developing event-driven asynchronous services</h1>
    <p class="normal">In this section, we will learn how to develop event-driven and asynchronous versions of the create and <a id="_idIndexMarker494"/>delete services. The composite service will publish create and delete events on each core service topic and then return an OK response back to the caller without waiting for processing to take place in the core services. This is illustrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_07.png" alt="Diagram  Description automatically generated" width="878" height="273"/></figure>
    <p class="packt_figref">Figure 7.7: The createCompositeProduct and deleteCompositeProduct parts of the landscape</p>
    <p class="normal">We will cover the following topics:</p>
    <ul>
      <li class="bulletList">Handling challenges with messaging</li>
      <li class="bulletList">Defining topics and events</li>
      <li class="bulletList">Changes in Gradle build files</li>
      <li class="bulletList">Consuming events in the core services</li>
      <li class="bulletList">Publishing events in the composite service</li>
    </ul>
    <h2 id="_idParaDest-199" class="heading-2">Handling challenges with messaging</h2>
    <p class="normal">To implement the event-driven create and delete services, we will use Spring Cloud Stream. In <em class="chapterRef">Chapter 2</em>, <em class="italic">Introduction to Spring Boot</em>, we have already seen how easy it is to publish and consume messages <a id="_idIndexMarker495"/>on a topic using <a id="_idIndexMarker496"/>Spring Cloud Stream. </p>
    <p class="normal">The programming model is based on a functional paradigm, where functions implementing one of the functional interfaces <code class="inlineCode">Supplier</code>, <code class="inlineCode">Function</code>, or <code class="inlineCode">Consumer</code> in the <code class="inlineCode">java.util.function</code> package can be chained together to perform decoupled event-based processing. To trigger such functional-based processing externally, from non-functional code, the helper class <code class="inlineCode">StreamBridge</code> can be used.</p>
    <p class="normal">For example, to publish the body of an HTTP request to a topic, we only have to write the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> StreamBridge streamBridge;
<span class="hljs-meta">@PostMapping</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sampleCreateAPI</span><span class="hljs-params">(</span><span class="hljs-meta">@RequestBody</span><span class="hljs-params"> String body)</span> {
  <span class="code-highlight"><strong class="hljs-slc">streamBridge.send</strong></span>(<span class="hljs-string">"topic"</span>, body);
}
</code></pre>
    <p class="normal">The helper class <code class="inlineCode">StreamBridge</code> is used to trigger the processing. It will publish a message on a topic. A function <a id="_idIndexMarker497"/>that consumes <a id="_idIndexMarker498"/>events from a topic (not creating new events) can be defined by implementing the functional interface <code class="inlineCode">java.util.function.Consumer</code> as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Consumer&lt;String&gt; <span class="hljs-title">mySubscriber</span><span class="hljs-params">()</span> {
   <span class="hljs-keyword">return</span> s -&gt; System.out.println(<span class="hljs-string">"ML RECEIVED: "</span> + s);
}
</code></pre>
    <p class="normal">To tie the various functions together, we use configuration. We will see examples of such configuration below in the sections <em class="italic">Adding configuration for publishing events</em> and <em class="italic">Adding configuration for consuming events</em>.</p>
    <p class="normal">This programming model can be used independently of the messaging system used, for example, RabbitMQ or Apache Kafka!</p>
    <p class="normal">Even though sending asynchronous messages is preferred over synchronous API calls, it comes with challenges of its own. We will see how we can use Spring Cloud Stream to handle some of them. The following features in Spring Cloud Stream will be covered:</p>
    <ul>
      <li class="bulletList">Consumer groups</li>
      <li class="bulletList">Retries and dead-letter queues</li>
      <li class="bulletList">Guaranteed orders and partitions</li>
    </ul>
    <p class="normal">We’ll study each of these in the following sections.</p>
    <h3 id="_idParaDest-200" class="heading-3">Consumer groups</h3>
    <p class="normal">The problem <a id="_idIndexMarker499"/>here is, if we scale up the number of instances of a message consumer, for example, if we start two instances of the <code class="inlineCode">product</code> microservice, both instances of the <code class="inlineCode">product</code> microservice will consume the same messages, as illustrated by the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_08.png" alt="Diagram  Description automatically generated" width="824" height="339"/></figure>
    <p class="packt_figref">Figure 7.8: Products #1 and #2 consuming the same messages</p>
    <p class="normal">This could result in one message being processed two times, potentially leading to duplicates or other undesired <a id="_idIndexMarker500"/>inconsistencies in the database. Therefore, we only want one instance per consumer to process each message. This can be solved by introducing a <strong class="keyWord">consumer group</strong>, as illustrated by the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_09.png" alt="Diagram  Description automatically generated" width="878" height="397"/></figure>
    <p class="packt_figref">Figure 7.9: Consumer group</p>
    <p class="normal">In Spring Cloud Stream, a consumer group can be configured on the consumer side. For example, for the <code class="inlineCode">product</code> microservice, it will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">spring.cloud.stream</span><span class="hljs-punctuation">:</span>
  <span class="hljs-attribute">bindings.messageProcessor-in-0</span><span class="hljs-punctuation">:</span>
    <span class="hljs-attribute">destination</span><span class="hljs-punctuation">:</span> <span class="hljs-string">products</span>
    <span class="hljs-attribute">group</span><span class="hljs-punctuation">:</span> <span class="hljs-string">productsGroup</span>
</code></pre>
    <p class="normal">From this configuration, we can learn the following:</p>
    <ul>
      <li class="bulletList">Spring Cloud Stream applies, by default, a naming convention for binding a configuration <a id="_idIndexMarker501"/>to a function. For messages sent to a function, the binding name is <code class="inlineCode">&lt;functionName&gt;-in-&lt;index&gt;</code>:<ul>
          <li class="bulletList"><code class="inlineCode">functionName</code> is the name of the function, <code class="inlineCode">messageProcessor</code> in the preceding example.</li>
          <li class="bulletList"><code class="inlineCode">index</code> is set to <code class="inlineCode">0</code>, unless the function requires multiple input or output arguments. We will not use multi-argument functions, so <code class="inlineCode">index</code> will always be set to <code class="inlineCode">0</code> in our examples.</li>
          <li class="bulletList">For outgoing messages, the binding name convention is <code class="inlineCode">&lt;functionName&gt;-out-&lt;index&gt;</code>.</li>
        </ul>
      </li>
      <li class="bulletList">The <code class="inlineCode">destination</code> property specifies the name of the topic that messages will be consumed from, <code class="inlineCode">products</code> in this case.</li>
      <li class="bulletList">The <code class="inlineCode">group</code> property specifies what consumer group to add instances of the <code class="inlineCode">product</code> microservice to, <code class="inlineCode">productsGroup</code> in this example. This means that messages sent to the <code class="inlineCode">products</code> topic will only be delivered by Spring Cloud Stream to one of the instances of the <code class="inlineCode">product</code> microservice.</li>
    </ul>
    <h3 id="_idParaDest-201" class="heading-3">Retries and dead-letter queues</h3>
    <p class="normal">If a consumer fails to process a message, it may be re-queued for the failing consumer until it is successfully <a id="_idIndexMarker502"/>processed. If the content of the message is invalid, also <a id="_idIndexMarker503"/>known as a <strong class="keyWord">poisoned message</strong>, the message will block the consumer from processing other messages until it is manually removed. If the failure is due to a temporary problem, for example, the database can’t be reached due to a temporary network error, the processing will probably succeed after a number of retries.</p>
    <p class="normal">It must be possible to specify the number of retries until a message is moved to another storage for fault analysis and correction. A failing message is typically moved to a dedicated queue called a dead-letter queue. To avoid overloading the infrastructure during temporary failure, for example, a network error, it must be possible to configure how often retries are performed, preferably with an increasing length of time between each retry.</p>
    <p class="normal">In Spring Cloud Stream, this can be configured on the consumer side, for example, for the <code class="inlineCode">product</code> microservice, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream.bindings.messageProcessor-in-0.consumer:</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">maxAttempts:</strong><strong class="hljs-slc"> </strong></span><span class="hljs-number">3</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">backOffInitialInterval:</strong><strong class="hljs-slc"> </strong></span><span class="hljs-number">500</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">backOffMaxInterval:</strong><strong class="hljs-slc"> </strong></span><span class="hljs-number">1000</span>
  <span class="hljs-attr">backOffMultiplier:</span> <span class="hljs-number">2.0</span>
<span class="hljs-attr">spring.cloud.stream.rabbit.bindings.messageProcessor-in-0.consumer:</span>
  <span class="hljs-attr">autoBindDlq:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">republishToDlq:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">spring.cloud.stream.kafka.bindings.messageProcessor-in-0.consumer:</span>
  <span class="hljs-attr">enableDlq:</span> <span class="hljs-literal">true</span>
</code></pre>
    <p class="normal">In the preceding example, we specify that Spring Cloud Stream should perform <code class="inlineCode">3</code> retries before placing a <a id="_idIndexMarker504"/>message on the dead-letter queue. The first retry will be attempted after <code class="inlineCode">500</code> ms and the two other attempts after <code class="inlineCode">1000</code> ms.</p>
    <p class="normal">Enabling the use of dead-letter queues is binding-specific; therefore, we have one configuration for RabbitMQ and one for Kafka.</p>
    <h3 id="_idParaDest-202" class="heading-3">Guaranteed order and partitions</h3>
    <p class="normal">If the business logic requires that messages are consumed and processed in the same order as they were sent, we cannot use multiple instances per consumer to increase processing performance; for example, we cannot use consumer groups. This might, in some cases, lead to an unacceptable <a id="_idIndexMarker505"/>latency in the processing of incoming messages.</p>
    <p class="normal">We can use <strong class="keyWord">partitions</strong> to ensure that messages are delivered in the same order as they were sent but without losing performance and scalability.</p>
    <p class="normal">In most cases, strict order in the processing of messages is only required for messages that affect the same business entities. For example, messages affecting the product with product ID <code class="inlineCode">1</code> can, in many cases, be processed independently of messages that affect the product with product ID <code class="inlineCode">2</code>. This means that the order only needs to be guaranteed for messages that have the same product ID.</p>
    <p class="normal">The solution to this is to make it possible to specify a <strong class="keyWord">key</strong> for each message, which the messaging system can use to guarantee that the order is kept between messages with the same key. This can be solved by introducing sub-topics, also <a id="_idIndexMarker506"/>known as <strong class="keyWord">partitions</strong>, in a topic. The messaging system places messages in a specific partition based on its key.</p>
    <p class="normal">Messages with the same key are always placed in the same partition. The messaging system only needs to guarantee the delivery order for messages in the same partition. To ensure the order of the messages, we configure one consumer instance per partition within a consumer group. By increasing the number of partitions, we can allow a consumer to increase its number of instances. This increases its message-processing performance without losing the delivery order. This is illustrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_10.png" alt="Diagram  Description automatically generated" width="877" height="348"/></figure>
    <p class="packt_figref">Figure 7.10: Specifying keys for messages</p>
    <p class="normal">As seen in the preceding diagram, all messages with the <code class="inlineCode">Key</code> set to <code class="inlineCode">123</code> always go to the <code class="inlineCode">Products-1</code>, partition while messages with the <code class="inlineCode">Key</code> set to <code class="inlineCode">456</code> go to the <code class="inlineCode">Products-2</code> partition.</p>
    <p class="normal">In Spring Cloud Stream, this needs to be configured on both the publisher and consumer sides. On the <a id="_idIndexMarker507"/>publisher side, the key and number of partitions must be specified. For example, for the <code class="inlineCode">product-composite</code> service, we have the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream.bindings.products-out-0.producer:</span>
  <span class="hljs-attr">partition-key-expression:</span> <span class="hljs-string">headers[</span><span class="code-highlight"><strong class="hljs-string-slc">'partitionKey'</strong></span><span class="hljs-string">]</span>
  <span class="hljs-attr">partition-count:</span> <span class="hljs-number">2</span>
</code></pre>
    <p class="normal">This configuration means that the key will be taken from the message header with the name <code class="inlineCode">partitionKey</code> and that two partitions will be used.</p>
    <p class="normal">Each consumer can specify which partition it wants to consume messages from. For example, for the <code class="inlineCode">product</code> microservice, we have the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream.bindings.messageProcessor-in-0:</span>
  <span class="hljs-attr">destination:</span> <span class="hljs-string">products</span>
  <span class="hljs-string">group:productsGroup</span>
  <span class="hljs-attr">consumer:</span>
    <span class="hljs-attr">partitioned:</span> <span class="hljs-literal">true</span>
    <span class="code-highlight"><strong class="hljs-attr-slc">instance-index:</strong><strong class="hljs-slc"> </strong><strong class="hljs-number-slc">0</strong></span>
</code></pre>
    <p class="normal">This configuration tells Spring Cloud Stream that this consumer will only consume messages from partition number <code class="inlineCode">0</code>, that is, the first partition.</p>
    <h2 id="_idParaDest-203" class="heading-2">Defining topics and events</h2>
    <p class="normal">As we <a id="_idIndexMarker508"/>already mentioned <a id="_idIndexMarker509"/>in the <em class="italic">Spring Cloud Stream</em> section in <em class="italic">Chapter 2</em>, <em class="italic">Introduction to Spring Boot</em>, Spring Cloud Stream is based on the publish and subscribe pattern, where a publisher publishes messages to topics and subscribers subscribe to topics they are interested in receiving messages from.</p>
    <p class="normal">We will use one <strong class="keyWord">topic</strong> per type of entity: <code class="inlineCode">products</code>, <code class="inlineCode">recommendations</code>, and <code class="inlineCode">reviews</code>.</p>
    <p class="normal">Messaging systems handle <strong class="keyWord">messages</strong> that typically consist of headers and a body. An <strong class="keyWord">event</strong> is a message that describes something that has happened. For events, the message body can be used to <a id="_idIndexMarker510"/>describe the type of event, the <a id="_idIndexMarker511"/>event data, and a timestamp for when the event occurred.</p>
    <p class="normal">An event is, for the scope of this book, defined by the following:</p>
    <ul>
      <li class="bulletList">The <strong class="keyWord">type</strong> of event, for example, a create or delete event</li>
      <li class="bulletList">A <strong class="keyWord">key</strong> that identifies the data, for example, a product ID</li>
      <li class="bulletList">A <strong class="keyWord">data</strong> element, that is, the actual data in the event</li>
      <li class="bulletList">A <strong class="keyWord">timestamp</strong>, which describes when the event occurred</li>
    </ul>
    <p class="normal">The event class we will use looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="code-highlight"><strong class="hljs-title-slc">Event</strong><strong class="hljs-slc">&lt;K, T&gt;</strong></span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title">Type</span> {<span class="code-highlight"><strong class="hljs-slc">CREATE, DELETE</strong></span>}
    <span class="hljs-keyword">private</span> Event.Type eventType;
    <span class="hljs-keyword">private</span> K key;
    <span class="hljs-keyword">private</span> T data;
    <span class="hljs-keyword">private</span> ZonedDateTime eventCreatedAt;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Event</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">this</span>.eventType = <span class="hljs-literal">null</span>;
        <span class="hljs-built_in">this</span>.key = <span class="hljs-literal">null</span>;
        <span class="hljs-built_in">this</span>.data = <span class="hljs-literal">null</span>;
        <span class="hljs-built_in">this</span>.eventCreatedAt = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title">Event</span><span class="hljs-params">(Type eventType, K key, T data)</span> {
        <span class="hljs-built_in">this</span>.eventType = eventType;
        <span class="hljs-built_in">this</span>.key = key;
        <span class="hljs-built_in">this</span>.data = data;
        <span class="hljs-built_in">this</span>.eventCreatedAt = now();
    }
    <span class="hljs-keyword">public</span> Type <span class="hljs-title">getEventType</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> eventType;
    }
    <span class="hljs-keyword">public</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> key;
    }
    <span class="hljs-keyword">public</span> T <span class="hljs-title">getData</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-keyword">public</span> ZonedDateTime <span class="hljs-title">getEventCreatedAt</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> eventCreatedAt;
    }
}
</code></pre>
    <p class="normal">Let’s explain <a id="_idIndexMarker512"/>the preceding <a id="_idIndexMarker513"/>source code in detail:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">Event</code> class is a generic class parameterized over the types of its <code class="inlineCode">key</code> and <code class="inlineCode">data</code> fields, <code class="inlineCode">K</code> and <code class="inlineCode">T</code></li>
      <li class="bulletList">The event type is declared as an enumerator with the allowed values, that is, <code class="inlineCode">CREATE</code> and <code class="inlineCode">DELETE</code></li>
      <li class="bulletList">The class defines two constructors, one empty and one that can be used to initialize the type, key, and value members</li>
      <li class="bulletList">Finally, the class defines getter methods for its member variables</li>
    </ul>
    <p class="normal">For the full source code, see the <code class="inlineCode">Event</code> class in the <code class="inlineCode">api</code> project.</p>
    <h2 id="_idParaDest-204" class="heading-2">Changes in the Gradle build files</h2>
    <p class="normal">To bring in Spring Cloud Stream and its binders for RabbitMQ and Kafka, we need to add the two <a id="_idIndexMarker514"/>starter dependencies known as <code class="inlineCode">spring-cloud-starter-stream-rabbit</code> and <code class="inlineCode">spring-cloud-starter-stream-kafka</code>. We also <a id="_idIndexMarker515"/>need a test dependency in the <code class="inlineCode">product-composite</code> project, <code class="inlineCode">spring-cloud-stream::test-binder</code>, to bring in test support. The following code shows this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">dependencies</span> {
  <span class="hljs-string">implementation</span> <span class="hljs-string">'org.springframework.cloud:spring-cloud-starter-stream-rabbit'</span>
  <span class="hljs-string">implementation</span> <span class="hljs-string">'org.springframework.cloud:spring-cloud-starter-stream-kafka'</span>
  <span class="hljs-string">testImplementation</span> <span class="hljs-string">'org.springframework.cloud:spring-cloud-stream::test-binder'</span>
}
</code></pre>
    <p class="normal">To specify what version of Spring Cloud we want to use, we first declare a variable for the version:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">ext</span> {
    <span class="hljs-string">springCloudVersion</span> <span class="hljs-string">=</span> <span class="hljs-string">"2022.0.1"</span>
}
</code></pre>
    <p class="normal">Next, we use the variable to set up dependency management for the specified Spring Cloud version, as seen here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">dependencyManagement</span> {
    <span class="hljs-string">imports</span> {
        <span class="hljs-string">mavenBom</span> <span class="hljs-string">"org.springframework.cloud:spring-cloud-</span>
<span class="hljs-string">        dependencies:${springCloudVersion}"</span>
    }
}
</code></pre>
    <p class="normal">For the full source code, see the <code class="inlineCode">build.gradle</code> build file in each of the microservices projects.</p>
    <p class="normal">With the required dependencies added to the Gradle build files, we can start to learn how to consume events in the core services.</p>
    <h2 id="_idParaDest-205" class="heading-2">Consuming events in the core services</h2>
    <p class="normal">To be able <a id="_idIndexMarker516"/>to consume <a id="_idIndexMarker517"/>events in the core services, we need to do the following:</p>
    <ul>
      <li class="bulletList">Declare message processors that consume events published on the core service’s topic</li>
      <li class="bulletList">Change our service implementations to use the reactive persistence layer</li>
      <li class="bulletList">Add configuration required for consuming events</li>
      <li class="bulletList">Change our tests so that they can test the asynchronous processing of the events</li>
    </ul>
    <p class="normal">The source code for consuming events is structured in the same way in all three core services, so we will only go through the source code for the <code class="inlineCode">product</code> service.</p>
    <h3 id="_idParaDest-206" class="heading-3">Declaring message processors</h3>
    <p class="normal">The REST APIs for creating and deleting entities have been replaced with a <strong class="keyWord">message processor</strong> in each <a id="_idIndexMarker518"/>core microservice that consumes create and delete events on each entity’s topic. To be able to consume messages that have been published to a topic, we need to declare a Spring Bean that implements the functional interface <code class="inlineCode">java.util.function.Consumer</code>.</p>
    <p class="normal">The message processor for the <code class="inlineCode">product</code> service is declared as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-meta-slc">@Configuration</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageProcessorConfig</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ProductService productService;
  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title">MessageProcessorConfig</span><span class="hljs-params">(</span><span class="code-highlight"><strong class="hljs-params-slc">ProductService productService</strong></span><span class="hljs-params">)</span> 
  {
    <span class="hljs-built_in">this</span>.productService = productService;
  }
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-keyword">public</span> Consumer&lt;Event&lt;Integer,Product&gt;&gt; <span class="code-highlight"><strong class="hljs-title-slc">messageProcessor</strong></span><span class="hljs-params">()</span> {
    ...
</code></pre>
    <p class="normal">From the preceding code, we can see that:</p>
    <ul>
      <li class="bulletList">The class is annotated with <code class="inlineCode">@Configuration</code>, telling Spring to look for Spring beans in the class.</li>
      <li class="bulletList">We inject an implementation of the <code class="inlineCode">ProductService</code> interface in the constructor. The <code class="inlineCode">productService</code> bean contains the business logic to perform the actual creation and deletions of the product entities.</li>
      <li class="bulletList">We declare the message processor as a Spring bean that implements the functional interface <code class="inlineCode">Consumer</code>, accepting an event as an input parameter of type <code class="inlineCode">Event&lt;Integer,Product&gt;</code>.</li>
    </ul>
    <p class="normal">The <a id="_idIndexMarker519"/>implementation of the <code class="inlineCode">Consumer</code> function looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="code-highlight"><strong class="hljs-slc">event</strong></span> -&gt; {
  <span class="hljs-keyword">switch</span> (event.getEventType()) {
    <span class="hljs-keyword">case</span> CREATE:
      <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> event.getData();
      <span class="code-highlight"><strong class="hljs-slc">productService.createProduct</strong></span>(product).block();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> DELETE:
      <span class="hljs-type">int</span> <span class="hljs-variable">productId</span> <span class="hljs-operator">=</span> event.getKey();
      <span class="code-highlight"><strong class="hljs-slc">productService.deleteProduct</strong></span>(productId).block();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-type">String</span> <span class="hljs-variable">errorMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Incorrect event type: "</span> + 
        event.getEventType() + 
        <span class="hljs-string">", expected a CREATE or DELETE event"</span>;
      <span class="code-highlight"><strong class="hljs-keyword-slc">throw</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">EventProcessingException</strong></span>(errorMessage);
  }
};
</code></pre>
    <p class="normal">The preceding implementation does the following:</p>
    <ul>
      <li class="bulletList">It takes an event of type <code class="inlineCode">Event&lt;Integer,Product&gt;</code> as an input parameter</li>
      <li class="bulletList">Using a <code class="inlineCode">switch</code> statement, based on the event type, it will either create or delete a product entity</li>
      <li class="bulletList">It uses the injected <code class="inlineCode">productService</code> bean to perform the actual create and delete operation</li>
      <li class="bulletList">If the event type is neither create nor delete, an exception will be thrown</li>
    </ul>
    <p class="normal">To ensure that we can propagate exceptions thrown by the <code class="inlineCode">productService</code> bean back to the messaging system, we call the <code class="inlineCode">block()</code> method on the responses we get back from the <code class="inlineCode">productService</code> bean. This ensures that the message processor waits for the <code class="inlineCode">productService</code> bean to complete its creation or deletion in the underlying database. Without calling the <code class="inlineCode">block()</code> method, we would not be able to propagate exceptions and the messaging system would not be able to re-queue a failed attempt or possibly move the message to a dead-letter queue; instead, the message would silently be dropped.</p>
    <div class="packt_tip">
      <p class="normal">Calling a <code class="inlineCode">block()</code> method is, in general, considered a bad practice from a performance and scalability perspective. But in this case, we will only handle a few incoming messages in parallel, one per partition, as described above. This means that we will only have a few threads blocked concurrently, which will not negatively impact the performance or the scalability.</p>
    </div>
    <p class="normal">For the full source code, see the <code class="inlineCode">MessageProcessorConfig</code> classes in the <code class="inlineCode">product</code>, <code class="inlineCode">recommendation</code>, and <code class="inlineCode">review</code> projects.</p>
    <h3 id="_idParaDest-207" class="heading-3">Changes in the service implementations</h3>
    <p class="normal">The service <a id="_idIndexMarker520"/>implementations of the create and delete methods for the <code class="inlineCode">product</code> and <code class="inlineCode">recommendation</code> service have been rewritten to use the non-blocking reactive persistence layer for MongoDB. For example, creating product entities is done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Mono&lt;Product&gt; <span class="hljs-title">createProduct</span><span class="hljs-params">(Product body)</span> {
  <span class="hljs-keyword">if</span> (body.getProductId() &lt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">InvalidInputException</span>(<span class="hljs-string">"</span><span class="hljs-string">Invalid productId: "</span> + 
      body.getProductId());
  }
  <span class="hljs-type">ProductEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> mapper.apiToEntity(body);
  Mono&lt;Product&gt; newEntity = repository.save(entity)
    .log(LOG.getName(), FINE)
    .<span class="code-highlight"><strong class="hljs-slc">onErrorMap</strong></span>(
      DuplicateKeyException.class,
      ex -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">InvalidInputException</span>
        (<span class="hljs-string">"Duplicate key, Product Id: "</span> + body.getProductId()))
    .map(e -&gt; mapper.entityToApi(e));
  <span class="hljs-keyword">return</span> newEntity;
}
</code></pre>
    <p class="normal">Note from the preceding code that the <code class="inlineCode">onErrorMap()</code> method is used to map the <code class="inlineCode">DuplicateKeyException</code> persistence exception to our own <code class="inlineCode">InvalidInputException</code> exception.</p>
    <div class="packt_tip">
      <p class="normal">For the <code class="inlineCode">review</code> service, which uses the blocking persistence layer for JPA, the create and delete methods have been updated in the same way as described in the <em class="italic">Dealing with blocking code section</em>.</p>
    </div>
    <p class="normal">For the full source code, see the following classes:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductServiceImpl</code> in the <code class="inlineCode">product</code> project</li>
      <li class="bulletList"><code class="inlineCode">RecommendationServiceImpl</code> in the <code class="inlineCode">recommendation</code> project</li>
      <li class="bulletList"><code class="inlineCode">ReviewServiceImpl</code> in the <code class="inlineCode">review</code> project</li>
    </ul>
    <h3 id="_idParaDest-208" class="heading-3">Adding configuration for consuming events</h3>
    <p class="normal">We also <a id="_idIndexMarker521"/>need to set up a configuration for the messaging system to be able to consume events. To do this, we need to complete the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We declare that RabbitMQ is the default messaging system and that the default content type is JSON:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream:</span>
  <span class="hljs-attr">defaultBinder:</span> <span class="hljs-string">rabbit</span>
  <span class="hljs-attr">default.contentType:</span> <span class="hljs-string">application/json</span>
</code></pre>
      </li>
      <li class="numberedList">Next, we bind the input to the message processors to specific topic names, as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream:</span>
  <span class="hljs-attr">bindings.messageProcessor-in-0:</span>
    <span class="hljs-attr">destination:</span> <span class="hljs-string">products</span>
</code></pre>
      </li>
      <li class="numberedList">Finally, we declare connectivity information for both Kafka and RabbitMQ:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream.kafka.binder:</span>
  <span class="hljs-attr">brokers:</span> <span class="hljs-number">127.0.0.1</span>
  <span class="hljs-attr">defaultBrokerPort:</span> <span class="hljs-number">9092</span>
<span class="hljs-attr">spring.rabbitmq:</span>
  <span class="hljs-attr">host:</span> <span class="hljs-number">127.0.0.1</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
  <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
  <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring.config.activate.on-profile:</span> <span class="hljs-string">docker</span>
<span class="hljs-attr">spring.rabbitmq.host:</span> <span class="hljs-string">rabbitmq</span>
<span class="hljs-attr">spring.cloud.stream.kafka.binder.brokers:</span> <span class="hljs-string">kafka</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">In the <a id="_idIndexMarker522"/>default Spring profile, we specify hostnames to be used when we run our system landscape without Docker on <code class="inlineCode">localhost</code> with the IP address <code class="inlineCode">127.0.0.1</code>. In the <code class="inlineCode">docker</code> Spring profile, we specify the hostnames we will use when running in Docker and using Docker Compose, that is, <code class="inlineCode">rabbitmq</code> and <code class="inlineCode">kafka</code>.</p>
    <p class="normal">Added to this configuration, the consumer configuration also specifies consumer groups, retry handling, dead-letter queues, and partitions as they were described earlier in the <em class="italic">Handling challenges with messaging</em> section.</p>
    <p class="normal">For the full source code, see the <code class="inlineCode">application.yml</code> configuration files in the <code class="inlineCode">product</code>, <code class="inlineCode">recommendation</code>, and <code class="inlineCode">review</code> projects.</p>
    <h3 id="_idParaDest-209" class="heading-3">Changes in the test code</h3>
    <p class="normal">Since the core services now receive events for creating and deleting their entities, the tests need to be <a id="_idIndexMarker523"/>updated so that they send events instead of calling REST APIs, as they did in the previous chapters. To be able to call the message processor from the test class, we inject the message processor bean into a member variable:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceApplicationTests</span> {
  <span class="hljs-meta">@Autowired</span>
  <span class="code-highlight"><strong class="hljs-meta-slc">@Qualifier("messageProcessor")</strong></span>
  <span class="hljs-keyword">private</span> Consumer&lt;Event&lt;Integer, Product&gt;&gt; messageProcessor;
</code></pre>
    <p class="normal">From the preceding code, we can see that we not only inject any <code class="inlineCode">Consumer</code> function but also use the <code class="inlineCode">@Qualifier</code> annotation to specify that we want to inject the <code class="inlineCode">Consumer</code> function that has the name <code class="inlineCode">messageProcessor</code>.</p>
    <p class="normal">To send create and delete events to the message processor, we add two helper methods, <code class="inlineCode">sendCreateProductEvent</code> and <code class="inlineCode">sendDeleteProductEvent</code>, in the test class:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="code-highlight"><strong class="hljs-title-slc">sendCreateProductEvent</strong></span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
    <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Product</span>(productId, <span class="hljs-string">"Name "</span> + productId, productId, <span class="hljs-string">"SA"</span>);
    Event&lt;Integer, Product&gt; event = <span class="hljs-keyword">new</span> <span class="hljs-title">Event</span>(CREATE, productId, product);
    messageProcessor.<span class="code-highlight"><strong class="hljs-slc">accept</strong></span>(event);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="code-highlight"><strong class="hljs-title-slc">sendDeleteProductEvent</strong></span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
    Event&lt;Integer, Product&gt; event = <span class="hljs-keyword">new</span> <span class="hljs-title">Event</span>(DELETE, productId, <span class="hljs-literal">null</span>);
    messageProcessor.<span class="code-highlight"><strong class="hljs-slc">accept</strong></span>(event);
  }
</code></pre>
    <p class="normal">Note that <a id="_idIndexMarker524"/>we use the <code class="inlineCode">accept()</code> method in the <code class="inlineCode">Consumer</code> function interface declaration to invoke the message processor. This means that we skip the messaging system in the tests and call the message processor directly.</p>
    <p class="normal">The tests for creating and deleting entities are updated to use these helper methods.</p>
    <p class="normal">For the full source code, see the following test classes:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductServiceApplicationTests</code> in the <code class="inlineCode">product</code> project</li>
      <li class="bulletList"><code class="inlineCode">RecommendationServiceApplicationTests</code> in the <code class="inlineCode">recommendation</code> project</li>
      <li class="bulletList"><code class="inlineCode">ReviewServiceApplicationTests</code> in the <code class="inlineCode">review</code> project</li>
    </ul>
    <p class="normal">We have seen what is required to consume events in the core microservices. Now let’s see how we can publish events in the composite microservice.</p>
    <h2 id="_idParaDest-210" class="heading-2">Publishing events in the composite service</h2>
    <p class="normal">When <a id="_idIndexMarker525"/>the composite service receives HTTP requests for the creation and deletion of composite products, it will <a id="_idIndexMarker526"/>publish the corresponding events to the core services on their topics. To be able to publish events in the composite service, we need to perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Publish events in the integration layer</li>
      <li class="numberedList">Add configuration for publishing events</li>
      <li class="numberedList">Change tests so that they can test the publishing of events</li>
    </ol>
    <div class="packt_tip">
      <p class="normal">Note that no changes are required in the composite service implementation class – it is taken care of by the integration layer!</p>
    </div>
    <h3 id="_idParaDest-211" class="heading-3">Publishing events in the integration layer</h3>
    <p class="normal">To publish <a id="_idIndexMarker527"/>an event in the integration layer, we need to:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an <code class="inlineCode">Event</code> object based on the body in the HTTP request</li>
      <li class="numberedList">Create a <code class="inlineCode">Message</code> object where the <code class="inlineCode">Event</code> object is used as the payload and the key field in the <code class="inlineCode">Event</code> object is used as the partition key in the header</li>
      <li class="numberedList">Use the helper class <code class="inlineCode">StreamBridge</code> to publish the event on the desired topic</li>
    </ol>
    <p class="normal">The code for sending create product events looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Mono&lt;Product&gt; <span class="hljs-title">createProduct</span><span class="hljs-params">(Product body)</span> {
    <span class="hljs-keyword">return</span> Mono.fromCallable(() -&gt; {
      sendMessage(<span class="hljs-string">"products-out-0"</span>, 
        <span class="hljs-keyword">new</span> <span class="hljs-title">Event</span>(CREATE, body.getProductId(), body));
      <span class="hljs-keyword">return</span> body;
    }).subscribeOn(publishEventScheduler);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String bindingName, Event event)</span> {
    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder.withPayload(event)
      .setHeader(<span class="hljs-string">"partitionKey"</span>, event.getKey())
      .build();
    <span class="code-highlight"><strong class="hljs-slc">streamBridge</strong></span>.send(bindingName, message);
  }
</code></pre>
    <p class="normal">In the preceding code, we can see:</p>
    <ul>
      <li class="bulletList">The integration layer implements the <code class="inlineCode">createProduct()</code> method in the <code class="inlineCode">ProductService</code> interface by using a helper method, <code class="inlineCode">sendMessage()</code>. The helper method takes the name of an output binding and an event object. The binding name <code class="inlineCode">products-out-0</code> will be bound to the topic of the <code class="inlineCode">product</code> service in the configuration below.</li>
      <li class="bulletList">Since the <code class="inlineCode">sendMessage()</code> uses blocking code, when calling <code class="inlineCode">streamBridge</code>, it is executed on a thread provided by a dedicated scheduler, <code class="inlineCode">publishEventScheduler</code>. This is the same approach as for handling blocking JPA code in the <code class="inlineCode">review</code> microservice. See the section on <em class="italic">Dealing with blocking code</em> for details.</li>
      <li class="bulletList">The helper method, <code class="inlineCode">sendMessage()</code>, creates a <code class="inlineCode">Message</code> object and sets the <code class="inlineCode">payload</code> and the <code class="inlineCode">partitionKey</code> header as described above. Finally, it uses the <code class="inlineCode">streamBridge</code> object to send the event to the messaging system, which will publish it on the topic defined in the configuration.</li>
    </ul>
    <p class="normal">For the full source code, see the <code class="inlineCode">ProductCompositeIntegration</code> class in the <code class="inlineCode">product-composite</code> project.</p>
    <h3 id="_idParaDest-212" class="heading-3">Adding configuration for publishing events</h3>
    <p class="normal">We also <a id="_idIndexMarker528"/>need to set up the configuration for the messaging system, to be able to publish events; this is similar to what we did for the consumers. Declaring RabbitMQ as the default messaging system, JSON as the default content type, and Kafka and RabbitMQ for connectivity information is the same as for the consumers.</p>
    <p class="normal">To declare what topics should be used for the output binding names, we have the following configuration:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream:</span>
  <span class="hljs-attr">bindings:</span>
    <span class="hljs-attr">products-out-0:</span>
      <span class="hljs-attr">destination:</span> <span class="hljs-string">products</span>
    <span class="hljs-attr">recommendations-out-0:</span>
      <span class="hljs-attr">destination:</span> <span class="hljs-string">recommendations</span>
    <span class="hljs-attr">reviews-out-0:</span>
      <span class="hljs-attr">destination:</span> <span class="hljs-string">reviews</span>
</code></pre>
    <p class="normal">When <a id="_idIndexMarker529"/>using partitions, we also need to specify the partition key and the number of partitions that will be used:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream.bindings.</span><span class="code-highlight"><strong class="hljs-attr-slc">products-out-</strong></span><span class="hljs-attr">0.producer:</span>
  <span class="hljs-attr">partition-key-expression:</span> <span class="hljs-string">headers[</span><span class="code-highlight"><strong class="hljs-string-slc">'partitionKey'</strong></span><span class="hljs-string">]</span>
  <span class="hljs-attr">partition-count:</span> <span class="hljs-number">2</span>
</code></pre>
    <p class="normal">In the preceding configuration, we can see that:</p>
    <ul>
      <li class="bulletList">The configuration applies for the binding name <code class="inlineCode">products-out-0</code></li>
      <li class="bulletList">The partition key used will be taken from the message header <code class="inlineCode">partitionKey</code></li>
      <li class="bulletList">Two partitions will be used</li>
    </ul>
    <p class="normal">For the full source code, see the <code class="inlineCode">application.yml</code> configuration file in the <code class="inlineCode">product-composite</code> project.</p>
    <h3 id="_idParaDest-213" class="heading-3">Changes in the test code</h3>
    <p class="normal">Testing asynchronous event-driven microservices is, by its nature, difficult. Tests typically need to synchronize <a id="_idIndexMarker530"/>on the asynchronous background processing in some way to be able to verify the result. Spring Cloud Stream comes with support, in the form of a test binder, that can be used to verify what messages have been sent without using any messaging system during the tests!</p>
    <div class="packt_tip">
      <p class="normal">See the <em class="italic">Changes in the Gradle build files</em> section earlier for how the test support is included in the <code class="inlineCode">product-composite</code> project.</p>
    </div>
    <p class="normal">The test support includes an <code class="inlineCode">OutputDestination</code> helper class, which can be used to get the messages that were sent during a test. A new test class, <code class="inlineCode">MessagingTests</code>, has been added to run tests that verify that the expected messages are sent. Let’s go through the most important parts of the test class:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">To be able to inject an <code class="inlineCode">OutputDestination</code> bean in the test class, we also need to bring in its configuration from the class <code class="inlineCode">TestChannelBinderConfiguration</code>. This is done with the following code:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SpringBootTest</span>
<span class="code-highlight"><strong class="hljs-meta-slc">@Import({TestChannelBinderConfiguration.class})</strong></span>
<span class="hljs-keyword">class</span> <span class="hljs-title">MessagingTests</span> {
  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">private</span> <span class="code-highlight"><strong class="hljs-slc">OutputDestination target</strong></span>;
</code></pre>
      </li>
      <li class="numberedList">Next, we declare <a id="_idIndexMarker531"/>a couple of helper methods for reading messages and also to be able to purge a topic. The code looks like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="code-highlight"><strong class="hljs-title-slc">purgeMessages</strong></span><span class="hljs-params">(String bindingName)</span> {
  getMessages(bindingName);
}
<span class="hljs-keyword">private</span> List&lt;String&gt; <span class="code-highlight"><strong class="hljs-title-slc">getMessages</strong></span><span class="hljs-params">(String bindingName)</span>{
  List&lt;String&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  <span class="hljs-type">boolean</span> <span class="hljs-variable">anyMoreMessages</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">while</span> (anyMoreMessages) {
    Message&lt;<span class="hljs-type">byte</span>[]&gt; message = 
      getMessage(bindingName);
    <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) {
      anyMoreMessages = <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
      messages.add(<span class="hljs-keyword">new</span> <span class="hljs-title">String</span>(message.getPayload()));
    }
  }
  <span class="hljs-keyword">return</span> messages;
}
<span class="hljs-keyword">private</span> Message&lt;<span class="hljs-type">byte</span>[]&gt; <span class="code-highlight"><strong class="hljs-slc">getMessage</strong></span>(String bindingName){
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> target.receive(<span class="hljs-number">0</span>, bindingName);
  } <span class="hljs-keyword">catch</span> (NullPointerException npe) {
    LOG.error(<span class="hljs-string">"getMessage() received a NPE with binding = {}"</span>, bindingName);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
        <p class="normal">From the preceding code, we can see that:</p>
      </li>
    </ol>
    <ul>
      <li class="bulletList">The <code class="inlineCode">getMessage()</code> method returns a message from a specified topic using the <code class="inlineCode">OutputDestination</code> bean, named <code class="inlineCode">target</code></li>
      <li class="bulletList">The <code class="inlineCode">getMessages()</code> method uses the <code class="inlineCode">getMessage()</code> method to return all messages in a topic</li>
      <li class="bulletList">The <code class="inlineCode">purgeMessages()</code> method uses the <code class="inlineCode">getMessages()</code> method to purge a topic from all current messages</li>
    </ul>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Each test starts with purging all topics involved in the tests using a <code class="inlineCode">setup()</code> method annotated with <code class="inlineCode">@BeforeEach</code>:
        <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-meta">@BeforeEach</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> {
    purgeMessages(<span class="hljs-string">"products"</span>);
    purgeMessages(<span class="hljs-string">"recommendations"</span>);
    purgeMessages(<span class="hljs-string">"reviews"</span>);
  }
</code></pre>
      </li>
      <li class="numberedList">An actual test <a id="_idIndexMarker532"/>can verify the messages in a topic using the <code class="inlineCode">getMessages()</code> method. For example, see the following test for the creation of a composite product:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">createCompositeProduct1</span><span class="hljs-params">()</span> {
  <span class="hljs-type">ProductAggregate</span> <span class="hljs-variable">composite</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ProductAggregate</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
  <span class="code-highlight"><strong class="hljs-slc">postAndVerifyProduct</strong></span>(composite, ACCEPTED);
  <span class="hljs-keyword">final</span> List&lt;String&gt; productMessages = <span class="code-highlight"><strong class="hljs-slc">getMessages</strong></span>(<span class="hljs-string">"products"</span>);
  <span class="hljs-keyword">final</span> List&lt;String&gt; recommendationMessages = <span class="code-highlight"><strong class="hljs-slc">getMessages</strong></span>(<span class="hljs-string">"recommendations"</span>);
  <span class="hljs-keyword">final</span> List&lt;String&gt; reviewMessages = <span class="code-highlight"><strong class="hljs-slc">getMessages</strong></span>(<span class="hljs-string">"reviews"</span>);
  <span class="hljs-comment">// Assert one expected new product event queued up</span>
  <span class="code-highlight"><strong class="hljs-slc">assertEquals(</strong></span><span class="hljs-number">1</span>, productMessages.size());
  Event&lt;Integer, Product&gt; expectedEvent =
    <span class="hljs-keyword">new</span> <span class="hljs-title">Event</span>(CREATE, composite.getProductId(), <span class="hljs-keyword">new</span> <span class="hljs-title">Product</span>(composite.getProductId(), composite.getName(), composite.getWeight(), <span class="hljs-literal">null</span>));
  assertThat(productMessages.get(<span class="hljs-number">0</span>), is(<span class="code-highlight"><strong class="hljs-slc">sameEventExceptCreatedAt</strong></span>(expectedEvent)));
  <span class="hljs-comment">// Assert no recommendation and review events</span>
  <span class="code-highlight"><strong class="hljs-slc">assertEquals(</strong><strong class="hljs-number-slc">0</strong></span>, recommendationMessages.size());
  <span class="code-highlight"><strong class="hljs-slc">assertEquals(</strong><strong class="hljs-number-slc">0</strong></span>, reviewMessages.size());
}
</code></pre>
      </li>
    </ol>
    <p class="normal">From the preceding code, we can see an example where a test:</p>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1">First makes an HTTP POST request, requesting the creation of a composite product.</li>
      <li class="alphabeticList">Next, gets all messages from the three topics, one for each underlying core service.</li>
      <li class="alphabeticList">For these tests, the specific timestamp for when an event was created is irrelevant. To be able to compare an actual event with an expected event, ignoring differences in the <code class="inlineCode">eventCreatedAt</code> field, a helper class called <code class="inlineCode">IsSameEvent</code> can be used. The <code class="inlineCode">sameEventExceptCreatedAt()</code> method is a static method in the <code class="inlineCode">IsSameEvent</code> class that compares <code class="inlineCode">Event</code> objects and treats them as equal if all the fields are equal, except for the <code class="inlineCode">eventCreatedAt</code> field.</li>
      <li class="alphabeticList">Finally, it verifies that the expected events can be found, and no others.</li>
    </ol>
    <p class="normal">For the full <a id="_idIndexMarker533"/>source code, see the test classes <code class="inlineCode">MessagingTests</code> and <code class="inlineCode">IsSameEvent</code> in the <code class="inlineCode">product-composite</code> project.</p>
    <h1 id="_idParaDest-214" class="heading-1">Running manual tests of the reactive microservice landscape</h1>
    <p class="normal">Now, we have fully reactive microservices, both in terms of non-blocking synchronous REST APIs and <a id="_idIndexMarker534"/>event-driven asynchronous services. Let’s try them out!</p>
    <p class="normal">We will learn how to run tests using both RabbitMQ and Kafka as the message broker. Since RabbitMQ can be used both with and without partitions, we will test both cases. Three different configurations will be used, each defined in a separate Docker Compose file:</p>
    <ul>
      <li class="bulletList">Using RabbitMQ without the use of partitions</li>
      <li class="bulletList">Using RabbitMQ with two partitions per topic</li>
      <li class="bulletList">Using Kafka with two partitions per topic</li>
    </ul>
    <p class="normal">However, before testing these three configurations, we need to add two features to be able to test the asynchronous processing:</p>
    <ul>
      <li class="bulletList">Saving events for later inspection when using RabbitMQ</li>
      <li class="bulletList">A health API that can be used to monitor the state of the microservice landscape</li>
    </ul>
    <h2 id="_idParaDest-215" class="heading-2">Saving events</h2>
    <p class="normal">After running some tests on event-driven asynchronous services, it might be of interest to see what events <a id="_idIndexMarker535"/>were actually sent. When using Spring Cloud Stream with Kafka, events are retained in the topics, even after consumers have processed them. However, when using Spring Cloud Stream with RabbitMQ, the events are removed after they have been processed successfully.</p>
    <p class="normal">To be able to see what events have been published on each topic, Spring Cloud Stream is configured to save published events in a separate consumer group, <code class="inlineCode">auditGroup</code>, per topic. For the <code class="inlineCode">products</code> topic, the configuration looks like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.cloud.stream:</span>
  <span class="hljs-attr">bindings:</span>
    <span class="hljs-attr">products-out-0:</span>
      <span class="hljs-attr">destination:</span> <span class="hljs-string">products</span>
      <span class="hljs-attr">producer:</span>
        <span class="code-highlight"><strong class="hljs-attr-slc">required-groups:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">auditGroup</strong></span>
</code></pre>
    <p class="normal">When using RabbitMQ, this will result in extra queues being created where the events are stored for later inspection.</p>
    <p class="normal">For the full source code, see the <code class="inlineCode">application.yml</code> configuration file in the <code class="inlineCode">product-composite</code> project.</p>
    <h2 id="_idParaDest-216" class="heading-2">Adding a health API</h2>
    <p class="normal">Testing a system landscape of microservices that uses a combination of synchronous APIs and asynchronous <a id="_idIndexMarker536"/>messaging is challenging. </p>
    <p class="normal">For example, how do we know when a newly started landscape of microservices, together with their databases and messaging system, are ready to process requests and messages?</p>
    <p class="normal">To make it easier to know when all the microservices are ready, we have added health APIs to the microservices. The health APIs are based on the support for <strong class="keyWord">health endpoints</strong> that comes with the Spring Boot module <strong class="keyWord">Actuator</strong>. By default, an Actuator-based health endpoint responds with <code class="inlineCode">UP</code> (and gives 200 as the HTTP return status) if the microservice itself and all the dependencies Spring Boot knows about are available. Dependencies Spring Boot knows about include databases and messaging systems. If the microservice itself or any of its dependencies are not available, the health endpoint responds with <code class="inlineCode">DOWN</code> (and returns 500 as the HTTP return status).</p>
    <p class="normal">We can also extend health endpoints to cover dependencies that Spring Boot is not aware of. We will use this feature to extend to the product composite’s <code class="inlineCode">health</code> endpoint, so it also includes the health of the three core services. This means that the product composite <code class="inlineCode">health</code> endpoint will only respond with <code class="inlineCode">UP</code> if itself and the three core microservices are healthy. This can be used either manually or automatically by the <code class="inlineCode">test-em-all.bash</code> script to find out when all the microservices and their dependencies are up and running.</p>
    <p class="normal">In the <code class="inlineCode">ProductCompositeIntegration</code> class, we have added helper methods for checking the health of the three core microservices, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> Mono&lt;Health&gt; <span class="hljs-title">getProductHealth</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> getHealth(productServiceUrl);
}
<span class="hljs-keyword">public</span> Mono&lt;Health&gt; <span class="hljs-title">getRecommendationHealth</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> getHealth(recommendationServiceUrl);
}
<span class="hljs-keyword">public</span> Mono&lt;Health&gt; <span class="hljs-title">getReviewHealth</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> getHealth(reviewServiceUrl);
}
<span class="hljs-keyword">private</span> Mono&lt;Health&gt; <span class="hljs-title">getHealth</span><span class="hljs-params">(String url)</span> {
    url += <span class="hljs-string">"/actuator/health"</span>;
    LOG.debug(<span class="hljs-string">"Will call the Health API on URL: {}"</span>, url);
    <span class="hljs-keyword">return</span> webClient.get().uri(url).retrieve().bodyToMono(String.class)
        .map(s -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">Health</span>.Builder().up().build())
        .onErrorResume(ex -&gt; Mono.just(<span class="hljs-keyword">new</span> 
         <span class="hljs-title">Health</span>.Builder().down(ex).build()))
        .log(LOG.getName(), FINE);
}
</code></pre>
    <p class="normal">This code is similar to the code we used previously to call the core services to read APIs. Note that the health endpoint is, by default, set to <code class="inlineCode">/actuator/health</code>.</p>
    <p class="normal">For the full source code, see the <code class="inlineCode">ProductCompositeIntegration</code> class in the <code class="inlineCode">product-composite</code> project.</p>
    <p class="normal">In the configuration class, <code class="inlineCode">HealthCheckConfiguration</code>, we use these helper methods to register a composite health <a id="_idIndexMarker537"/>check using the Spring Actuator class <code class="inlineCode">CompositeReactiveHealthContributor</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HealthCheckConfiguration</span> {
  <span class="hljs-meta">@Autowired</span>
  ProductCompositeIntegration integration; 
  <span class="hljs-meta">@Bean</span>
  ReactiveHealthContributor <span class="hljs-title">coreServices</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">final</span> Map&lt;String, ReactiveHealthIndicator&gt; registry = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedHashMap</span>&lt;&gt;();
    registry.put(<span class="hljs-string">"product"</span>, () -&gt; integration.getProductHealth());
    registry.put(<span class="hljs-string">"recommendation"</span>, () -&gt; integration.getRecommendationHealth());
    registry.put(<span class="hljs-string">"</span><span class="hljs-string">review"</span>, () -&gt; integration.getReviewHealth());
    <span class="hljs-keyword">return</span> CompositeReactiveHealthContributor.fromMap(registry);
  }
}
</code></pre>
    <p class="normal">For the full source code, see the <code class="inlineCode">HealthCheckConfiguration</code> class in the <code class="inlineCode">product-composite</code> project.</p>
    <p class="normal">Finally, in the <code class="inlineCode">application.yml</code> configuration file of all four microservices, we configure the Spring Boot Actuator so that it does the following:</p>
    <ul>
      <li class="bulletList">Shows details about the state of health, which not only includes <code class="inlineCode">UP</code> or <code class="inlineCode">DOWN</code>, but also information about its dependencies</li>
      <li class="bulletList">Exposes all its endpoints over HTTP</li>
    </ul>
    <p class="normal">The configuration for these two settings looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">management.endpoint.health.show-details:</span> <span class="hljs-string">"ALWAYS"</span>
<span class="hljs-attr">management.endpoints.web.exposure.include:</span> <span class="hljs-string">"*"</span>
</code></pre>
    <p class="normal">For an example of the full source code, see the <code class="inlineCode">application.yml</code> configuration file in the <code class="inlineCode">product-composite</code> project.</p>
    <div class="note">
      <p class="normal"><strong class="screenText">WARNING</strong>: These configuration settings are helpful during development, but it can be a security issue to reveal too much information in actuator endpoints in production systems. Therefore, plan to minimize the information exposed by the actuator endpoints in production!</p>
      <p class="normal">This can be done by replacing <code class="inlineCode">"*"</code> with, for example, <code class="inlineCode">health,info</code> in the setting of the <code class="inlineCode">management.endpoints.web.exposure.include</code> property above.</p>
    </div>
    <p class="normal">For details regarding the endpoints that are exposed by Spring Boot Actuator, see <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html"><span class="url">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html</span></a>.</p>
    <p class="normal">The health endpoint <a id="_idIndexMarker538"/>can be used manually with the following command (don’t try it yet, wait until we have started up the microservice landscape below!):</p>
    <pre class="programlisting con"><code class="hljs-con">curl localhost:8080/actuator/health -s | jq .
</code></pre>
    <p class="normal">This will result in a response containing:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_11.png" alt="Text  Description automatically generated" width="297" height="478"/></figure>
    <p class="packt_figref">Figure 7.11: Health endpoint response</p>
    <p class="normal">In the preceding output, we can see that the composite service reports that it is healthy; that is, its status is <code class="inlineCode">UP</code>. At the end of the response, we can see that all three core microservices are also reported as healthy.</p>
    <p class="normal">With a health API in place, we are ready to test our reactive microservices.</p>
    <h2 id="_idParaDest-217" class="heading-2">Using RabbitMQ without using partitions</h2>
    <p class="normal">In this <a id="_idIndexMarker539"/>section, we will test the reactive microservices together with RabbitMQ but without using partitions.</p>
    <p class="normal">The default <code class="inlineCode">docker-compose.yml</code> Docker Compose file is used for this configuration. The following changes have been added to the file:</p>
    <ul>
      <li class="bulletList">RabbitMQ has been added, as shown here:
        <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">image:</span> <span class="code-highlight"><strong class="hljs-string-slc">rabbitmq:3.11.8-management</strong></span>
    <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">512m</span>
    <span class="hljs-attr">ports:</span>
      <span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-number-slc">5672</strong><strong class="hljs-string-slc">:5672</strong></span>
      <span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-number-slc">15672</strong><strong class="hljs-string-slc">:15672</strong></span>
    <span class="code-highlight"><strong class="hljs-attr-slc">healthcheck</strong></span><span class="hljs-attr">:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"rabbitmqctl"</span>, <span class="hljs-string">"status"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">5s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">2s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">60</span>
</code></pre>
        <p class="normal">From the declaration of RabbitMQ above, we can see that:</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList">We use a Docker image for RabbitMQ v3.11.8 including the management plugin and Admin Web UI</li>
      <li class="bulletList">We expose the standard ports for connecting to RabbitMQ and the Admin Web UI, <code class="inlineCode">5672</code> and <code class="inlineCode">15672</code></li>
      <li class="bulletList">We add a health check so that Docker can find out when RabbitMQ is ready to accept connections</li>
    </ul>
    <ul>
      <li class="bulletList">The microservices now have a dependency declared on the RabbitMQ service. This means that Docker will not start the microservice containers until the RabbitMQ service is reported to be healthy:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">depends_on:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span>
</code></pre>
      </li>
    </ul>
    <p class="normal">To run <a id="_idIndexMarker540"/>manual tests, perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Build and start the system landscape with the following commands:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter07
./gradlew build &amp;&amp; docker-compose build &amp;&amp; docker-compose up -d
</code></pre>
      </li>
      <li class="numberedList">Now, we have to wait for the microservice landscape to be up and running. Try running the following command a few times:
        <pre class="programlisting con"><code class="hljs-con">curl -s localhost:8080/actuator/health | jq -r .status
</code></pre>
        <p class="normal">When it returns <code class="inlineCode">UP</code>, we are ready to run our tests!</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">First, create a composite product with the following commands:
        <pre class="programlisting con"><code class="hljs-con">body='{"productId":1,"name":"product name C","weight":300, "recommendations":[
{"recommendationId":1,"author":"author 1","rate":1,"content":"content 1"},
 {"recommendationId":2,"author":"author 2","rate":2,"content":"content 2"},
 {"recommendationId":3,"author":"author 3","rate":3,"content":"content 3"}
], "reviews":[
 {"reviewId":1,"author":"author 1","subject":"subject 1","content":"content 1"},
 {"reviewId":2,"author":"author 2","subject":"subject 2","content":"content 2"},
 {"reviewId":3,"author":"author 3","subject":"subject 3","content":"content 3"}
]}'
curl -X POST localhost:8080/product-composite -H "Content-Type: application/json" --data "$body"
</code></pre>
        <p class="normal">When using Spring Cloud Stream together with RabbitMQ, it will create one RabbitMQ exchange per topic and a set of queues, depending on our configuration. Let’s see what queues Spring Cloud Stream has created for us!</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Open the <a id="_idIndexMarker541"/>following URL in a web browser: <code class="inlineCode">http://localhost:15672/#/queues</code>. Log in with the default username/password <code class="inlineCode">guest</code>/<code class="inlineCode">guest</code>. You should see the following queues: <figure class="mediaobject"><img src="../Images/B19825_07_12.png" alt="Graphical user interface, application, table  Description automatically generated" width="812" height="608"/></figure>
        <figure class="mediaobject">Figure 7.12: List of queues</figure>
        <p class="normal">For each topic, we can see one queue for the <strong class="keyWord">auditGroup</strong>, one queue for the consumer group that’s used by the corresponding core microservice, and one dead-letter queue. We can also see that the <strong class="keyWord">auditGroup</strong> queues contain messages, as expected!</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Click on <a id="_idIndexMarker542"/>the <strong class="keyWord">products.auditGroup</strong> queue and scroll down to the <strong class="keyWord">Get messages</strong> section, expand it, and click on the button named <strong class="keyWord">Get Message(s)</strong> to see the message in the queue: <figure class="mediaobject"><img src="../Images/B19825_07_13.png" alt="Graphical user interface, text, application, email  Description automatically generated" width="812" height="554"/></figure>
        <figure class="mediaobject">Figure 7.13: Viewing the message in the queue</figure>
        <p class="normal">From the preceding screenshot, note the <strong class="keyWord">Payload</strong> but also the header <strong class="keyWord">partitionKey</strong>, which we will use in the next section where we try out RabbitMQ with partitions.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Next, try to get the product composite using the following code:
        <pre class="programlisting con"><code class="hljs-con">curl -s localhost:8080/product-composite/1 | jq 
</code></pre>
      </li>
      <li class="numberedList">Finally, delete it with the following command:
        <pre class="programlisting con"><code class="hljs-con">curl -X DELETE localhost:8080/product-composite/1
</code></pre>
      </li>
      <li class="numberedList">Try to get the deleted product again. It should result in a <code class="inlineCode">404 - "NotFound"</code> response!</li>
      <li class="numberedList">If you look in the RabbitMQ audit queues again, you should be able to find new messages containing delete events.</li>
      <li class="numberedList">Wrap up the test by bringing down the microservice landscape with the following command:
        <pre class="programlisting con"><code class="hljs-con">docker-compose down
</code></pre>
      </li>
    </ol>
    <p class="normal">This <a id="_idIndexMarker543"/>completes the tests where we use RabbitMQ without partitions. Now, let’s move on and test RabbitMQ with partitions.</p>
    <h2 id="_idParaDest-218" class="heading-2">Using RabbitMQ with partitions</h2>
    <p class="normal">Now, let’s try out the partitioning support in Spring Cloud Stream!</p>
    <p class="normal">We have <a id="_idIndexMarker544"/>a separate Docker Compose file prepared for using RabbitMQ with two partitions per topic: <code class="inlineCode">docker-compose-partitions.yml</code>. It will also start two instances per core microservice, one for each partition. For example, a second <code class="inlineCode">product</code> instance is configured as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-attr">product-p1:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">microservices/product-service</span>
    <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">512m</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">SPRING_PROFILES_ACTIVE=docker,</span><span class="code-highlight"><strong class="hljs-string-slc">streaming_partitioned</strong></span><span class="hljs-string">,</span><span class="code-highlight"><strong class="hljs-string-slc">streaming_instance_1</strong></span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-attr">mongodb:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span>
      <span class="hljs-attr">rabbitmq:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span>
</code></pre>
    <p class="normal">Here is an explanation of the preceding configuration:</p>
    <ul>
      <li class="bulletList">We use the same source code and Dockerfile that we did for the first <code class="inlineCode">product</code> instance but configure them differently.</li>
      <li class="bulletList">To make all microservice instances aware that they will use partitions, we have added the Spring profile <code class="inlineCode">streaming_partitioned</code> to their environment variable <code class="inlineCode">SPRING_PROFILES_ACTIVE</code>.</li>
      <li class="bulletList">We assign the two <code class="inlineCode">product</code> instances to different partitions using different Spring profiles. The Spring profile <code class="inlineCode">streaming_instance_0</code> is used by the first product instance and <code class="inlineCode">streaming_instance_1</code> is used by the second instance, <code class="inlineCode">product-p1</code>.</li>
      <li class="bulletList">The second <code class="inlineCode">product</code> instance will only process asynchronous events; it will not respond to API calls. Since it has a different name, <code class="inlineCode">product-p1</code> (also used as its DNS name), it will not respond to calls to a URL starting with <code class="inlineCode">http://product:8080</code>.</li>
    </ul>
    <p class="normal">Start up the microservice landscape with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">export COMPOSE_FILE=docker-compose-partitions.yml
docker-compose build &amp;&amp; docker-compose up -d
</code></pre>
    <p class="normal">Create a composite product in the same way as for the tests in the previous section but also create a composite product with the product ID set to <code class="inlineCode">2</code>. If you take a look at the queues set up by Spring Cloud Stream, you will see one queue per partition and that the product audit queues now contain one message each; the event for product ID <code class="inlineCode">1</code> was placed in one partition and the event for <a id="_idIndexMarker545"/>product ID <code class="inlineCode">2</code> was placed in the other partition. </p>
    <p class="normal">If you go back to <code class="inlineCode">http://localhost:15672/#/queues</code> in your web browser, you should see something like the following:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_14.png" alt="Graphical user interface, application  Description automatically generated" width="878" height="834"/></figure>
    <p class="packt_figref">Figure 7.14: List of queues</p>
    <p class="normal">To end the test with RabbitMQ using partitions, bring down the microservice landscape with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose down
unset COMPOSE_FILE
</code></pre>
    <p class="normal">We are now done with tests using RabbitMQ, both with and without partitions. The final test configuration we shall try out is testing the microservices together with Kafka.</p>
    <h2 id="_idParaDest-219" class="heading-2">Using Kafka with two partitions per topic</h2>
    <p class="normal">Now, we shall try out a very cool feature of Spring Cloud Stream: changing the messaging system from RabbitMQ to Apache Kafka!</p>
    <p class="normal">This can <a id="_idIndexMarker546"/>be done simply by changing the value of the <code class="inlineCode">spring.cloud.stream.defaultBinder</code> property from <code class="inlineCode">rabbit</code> to <code class="inlineCode">kafka</code>. This is handled by the <code class="inlineCode">docker-compose-kafka.yml</code> Docker Compose file, which has also replaced RabbitMQ with Kafka and ZooKeeper. The configuration of Kafka and ZooKeeper looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">kafka:</span>
  <span class="hljs-attr">image:</span> <span class="hljs-string">confluentinc/cp-kafka:7.3.1</span>
  <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
  <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">1024m</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">"9092:9092"</span>
  <span class="hljs-attr">environment:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_BROKER_ID=1</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1</span>
  <span class="hljs-attr">depends_on:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span>
<span class="hljs-attr">zookeeper:</span>
  <span class="hljs-attr">image:</span> <span class="hljs-string">confluentinc/cp-zookeeper:7.3.1</span>
  <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
  <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">512m</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">"2181:2181"</span>
  <span class="hljs-attr">environment:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">ZOOKEEPER_CLIENT_PORT=2181</span>
</code></pre>
    <p class="normal">Kafka is also configured to use two partitions per topic, and like before, we start up two instances per core microservice, one for each partition. See the Docker Compose file, <code class="inlineCode">docker-compose-kafka.yml</code>, for details!</p>
    <p class="normal">Start up the microservice landscape with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">export COMPOSE_FILE=docker-compose-kafka.yml
docker-compose build &amp;&amp; docker-compose up -d
</code></pre>
    <p class="normal">Repeat the tests from the previous section: create two products, one with the product ID set to <code class="inlineCode">1</code> and one with the product ID set to <code class="inlineCode">2</code>.</p>
    <div class="packt_tip">
      <p class="normal">Unfortunately, Kafka doesn’t come with any graphical tools that can be used to inspect topics, partitions, and the messages that are placed within them. Instead, we can run CLI commands in the Kafka Docker container.</p>
    </div>
    <p class="normal">To see a list of topics, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec kafka kafka-topics --bootstrap-server localhost:9092 --list
</code></pre>
    <p class="normal">Expect an output like the one shown here:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_15.png" alt="Graphical user interface, text, application  Description automatically generated" width="524" height="220"/></figure>
    <p class="packt_figref">Figure 7.15: Viewing a list of topics</p>
    <p class="normal">Here is <a id="_idIndexMarker547"/>what we see in the preceding output:</p>
    <ul>
      <li class="bulletList">The topics prefixed with <code class="inlineCode">error</code> are the topics corresponding to dead-letter queues.</li>
      <li class="bulletList">You will not find any <code class="inlineCode">auditGroup</code> groups as in the case of RabbitMQ. Since events are retained in the topics by Kafka, even after consumers have processed them, there is no need for an extra <code class="inlineCode">auditGroup</code> group.</li>
    </ul>
    <p class="normal">To see the partitions in a specific topic, for example, the <code class="inlineCode">products</code> topic, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec kafka kafka-topics --bootstrap-server localhost:9092 --describe --topic products
</code></pre>
    <p class="normal">Expect an output like the one shown here:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_16.png" alt="Graphical user interface, text  Description automatically generated" width="726" height="137"/></figure>
    <p class="packt_figref">Figure 7.16: Viewing partitions in the products topic</p>
    <p class="normal">To see all the messages in a specific partition, for example, partition <code class="inlineCode">1</code> in the <code class="inlineCode">products</code> topic, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec kafka kafka-console-consumer --bootstrap-server localhost:9092 --topic products --from-beginning --timeout-ms 1000 --partition 1
</code></pre>
    <p class="normal">Expect an <a id="_idIndexMarker548"/>output like the one shown here:</p>
    <figure class="mediaobject"><img src="../Images/B19825_07_17.png" alt="Graphical user interface, text  Description automatically generated" width="877" height="180"/></figure>
    <p class="packt_figref">Figure 7.17: Viewing all messages in partition 1 in the products topic</p>
    <p class="normal">The output will end with a timeout exception since we stop the command by specifying a timeout for the command of <code class="inlineCode">1000</code> ms.</p>
    <p class="normal">Bring down the microservice landscape with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose down
unset COMPOSE_FILE
</code></pre>
    <p class="normal">Now, we have learned how Spring Cloud Stream can be used to switch a message broker from RabbitMQ to Kafka without requiring any changes in the source code. It just requires a few changes in the Docker Compose file.</p>
    <p class="normal">Let’s move on to the last section of this chapter, learning how to run these tests automatically!</p>
    <h1 id="_idParaDest-220" class="heading-1">Running automated tests of the reactive microservice landscape</h1>
    <p class="normal">To be able <a id="_idIndexMarker549"/>to run tests of the reactive microservice landscape automatically instead of manually, the automated <code class="inlineCode">test-em-all.bash</code> test script has been enhanced. The most important changes are as follows:</p>
    <ul>
      <li class="bulletList">The script uses the new <code class="inlineCode">health</code> endpoint to know when the microservice landscape is operational, as shown here:
        <pre class="programlisting con"><code class="hljs-con">waitForService curl http://$HOST:$PORT/actuator/health
</code></pre>
      </li>
      <li class="bulletList">The script has a new <code class="inlineCode">waitForMessageProcessing()</code> function, which is called after the test data is set up. Its purpose is simply to wait for the creation of the test data to be completed by the asynchronous create services.</li>
    </ul>
    <p class="normal">To use the test script to automatically run the tests with RabbitMQ and Kafka, perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Run the tests using the default Docker Compose file, that is, with RabbitMQ without partitions, with the following commands:
        <pre class="programlisting con"><code class="hljs-con">unset COMPOSE_FILE
./test-em-all.bash start stop
</code></pre>
      </li>
      <li class="numberedList">Run the tests for RabbitMQ with two partitions per topic using the Docker Compose <code class="inlineCode">docker-compose-partitions.yml</code> file with the following commands:
        <pre class="programlisting con"><code class="hljs-con">export COMPOSE_FILE=docker-compose-partitions.yml 
./test-em-all.bash start stop
unset COMPOSE_FILE
</code></pre>
      </li>
      <li class="numberedList">Finally, run the tests with Kafka and two partitions per topic using the Docker Compose <code class="inlineCode">docker-compose-kafka.yml</code> file with the following commands:
        <pre class="programlisting con"><code class="hljs-con">export COMPOSE_FILE=docker-compose-kafka.yml 
./test-em-all.bash start stop
unset COMPOSE_FILE
</code></pre>
      </li>
    </ol>
    <p class="normal">In this section, we have learned how to use the <code class="inlineCode">test-em-all.bash</code> test script to automatically run tests of the reactive microservice landscape, which has been configured to use either RabbitMQ or Kafka as its message broker.</p>
    <h1 id="_idParaDest-221" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have seen how we can develop reactive microservices!</p>
    <p class="normal">Using Spring WebFlux and Spring WebClient, we can develop non-blocking synchronous APIs that can handle incoming HTTP requests and send outgoing HTTP requests without blocking any threads. Using Spring Data’s reactive support for MongoDB, we can also access MongoDB databases in a non-blocking way, that is, without blocking any threads while waiting for responses from the database. Spring WebFlux, Spring WebClient, and Spring Data rely on Project Reactor to provide their reactive and non-blocking features. When we must use blocking code, for example, when using Spring Data for JPA, we can encapsulate the processing of the blocking code by scheduling the processing of it in a dedicated thread pool.</p>
    <p class="normal">We have also seen how Spring Data Stream can be used to develop event-driven asynchronous services that work on both RabbitMQ and Kafka as messaging systems without requiring any changes in the code. By doing some configuration, we can use features in Spring Cloud Stream such as consumer groups, retries, dead-letter queues, and partitions to handle the various challenges of asynchronous messaging.</p>
    <p class="normal">We have also learned how to manually and automatically test a system landscape consisting of reactive microservices.</p>
    <p class="normal">This was the final chapter on how to use fundamental features in Spring Boot and Spring Framework.</p>
    <p class="normal">Next up is an introduction to Spring Cloud and how it can be used to make our services production-ready, scalable, robust, configurable, secure, and resilient!</p>
    <h1 id="_idParaDest-222" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Why is it important to know how to develop reactive microservices?</li>
      <li class="numberedList">How do you choose between non-blocking synchronous APIs and event-/message-driven asynchronous services?</li>
      <li class="numberedList">What makes an event different from a message?</li>
      <li class="numberedList">Name some challenges with message-driven asynchronous services. How do we handle them?</li>
      <li class="numberedList">Why is the following test not failing?
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">testStepVerifier</span><span class="hljs-params">()</span> {
  StepVerifier.create(Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
    .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
    .map(n -&gt; n * <span class="hljs-number">2</span>)
    .log())
    .expectNext(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>);
}
</code></pre>
    <p class="normal">First, ensure that the test fails. Next, correct the test so that it succeeds.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">What are the challenges of writing tests with reactive code using JUnit, and how can we handle them?</li>
    </ol>
  </div>
</div>
</div>
</body></html>