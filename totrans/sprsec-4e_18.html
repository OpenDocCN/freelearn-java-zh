<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer135">
<h1 class="chapter-number" id="_idParaDest-390"><a id="_idTextAnchor591"/>18</h1>
<h1 id="_idParaDest-391"><a id="_idTextAnchor592"/>Single Sign-On with the Central Authentication Service</h1>
<p>In this chapter, we’ll examine the use of the <strong class="bold">Central Authentication Service</strong> (<strong class="bold">CAS</strong>) as a <strong class="bold">Single Sign-On</strong> (<strong class="bold">SSO</strong>) portal for Spring <span class="No-Break">Security-based applications.</span></p>
<p>During the course of this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Learning about <strong class="bold">CAS</strong>, its architecture, and how it benefits system administrators and organizations of <span class="No-Break">any size</span></li>
<li>Understanding how Spring Security can be reconfigured to handle the interception of authentication requests and redirect them <span class="No-Break">to </span><span class="No-Break"><strong class="bold">CAS</strong></span></li>
<li>Configuring the <strong class="bold">JBCP Calendar</strong> application to utilize <span class="No-Break">CAS SSO</span></li>
<li>Gaining an understanding of how the <strong class="bold">Single Logout</strong> feature can be implemented, and configuring our application to <span class="No-Break">support it</span></li>
<li>Discussing how to use <strong class="bold">CAS</strong> proxy ticket authentication for services, and configuring our application to utilize proxy <span class="No-Break">ticket authentication</span></li>
<li>Discussing how to customize the out-of-the-box <strong class="bold">JA-SIG CAS</strong> server using the recommended war <span class="No-Break">overlay approach</span></li>
<li>Integrating the <strong class="bold">CAS</strong> server with <strong class="bold">LDAP</strong>, and passing data from <strong class="bold">LDAP</strong> to <strong class="bold">Spring Security</strong> <span class="No-Break">via </span><span class="No-Break"><strong class="bold">CAS</strong></span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/lFJjp"><span class="No-Break">https://packt.link/lFJjp</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-392"><a id="_idTextAnchor593"/>Introducing the Central Authentication Service</h1>
<p><strong class="bold">CAS</strong> is an <a id="_idIndexMarker1313"/>open source, SSO server that provides centralized access control and authentication to web-based resources within an organization. The benefits of <strong class="bold">CAS</strong> for administrators are numerous, and it supports many applications and diverse user communities. These benefits are <span class="No-Break">as follows:</span></p>
<ul>
<li>Individual <a id="_idIndexMarker1314"/>or group access to resources (applications) can be configured in <span class="No-Break">one location</span></li>
<li>Broad support for a wide variety of authentication stores (to centralize user management) provides a single point of authentication and control in widely distributed <span class="No-Break">cross-machine environments</span></li>
<li>Broad authentication support is provided for web-based and non-web-based Java applications through <strong class="bold">CAS</strong> <span class="No-Break">client libraries</span></li>
<li>A single point of reference for user credentials (via <strong class="bold">CAS</strong>) is provided so that <strong class="bold">CAS</strong> client applications are not required to have any knowledge of the user’s credentials, or knowledge of how to <span class="No-Break">verify them</span></li>
</ul>
<p>In this chapter, we’ll not focus much on the management of <strong class="bold">CAS</strong>, but on authentication and how <strong class="bold">CAS</strong> can act as an authentication point for the users of our site. Although <strong class="bold">CAS</strong> is commonly seen in intranet environments for enterprises or educational institutions, it can also be found in use at high-profile locations such as Sony Online Entertainment’s <span class="No-Break">public-facing site.</span></p>
<h1 id="_idParaDest-393"><a id="_idTextAnchor594"/>High-level CAS authentication flow</h1>
<p>At a high level, <strong class="bold">CAS</strong> is <a id="_idIndexMarker1315"/>composed of a <strong class="bold">CAS</strong> server, which is the central web application for determining authentication, and one or more <strong class="bold">CAS</strong> services, which are distinct web applications that use the CAS server to get authenticated. The basic authentication flow of <strong class="bold">CAS</strong> proceeds via the <span class="No-Break">following actions:</span></p>
<ol>
<li>The user attempts to access a protected resource on <span class="No-Break">the website.</span></li>
<li>The user is redirected through the browser from the <strong class="bold">CAS</strong> service to the <strong class="bold">CAS</strong> server to request <span class="No-Break">a login.</span></li>
<li>The <strong class="bold">CAS</strong> server<a id="_idIndexMarker1316"/> is responsible for user authentication. If the user is not already authenticated to the <strong class="bold">CAS</strong> server, then the latter requests credentials from the user. As shown in the following diagram, the user is presented with a <span class="No-Break">login page.</span></li>
<li>The user submits their credentials (that is, the username <span class="No-Break">and password).</span></li>
<li>If the user’s credentials are valid, the <strong class="bold">CAS</strong> server responds with a redirect through the browser with a service ticket. A service ticket is a one-time use token used to identify <span class="No-Break">a user.</span></li>
<li>The <strong class="bold">CAS</strong> service calls the <strong class="bold">CAS</strong> server back to verify that the ticket is valid, has not expired, and so on. Note that this step does not occur through <span class="No-Break">the browser.</span></li>
<li>The <strong class="bold">CAS</strong> server<a id="_idIndexMarker1317"/> responds with an assertion indicating that trust has been established. If the ticket is acceptable, trust has been established and the user may proceed via normal <span class="No-Break">authorization checking.</span><p class="list-inset">This behavior is illustrated visually in the <span class="No-Break">following diagram:</span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer129">
<img alt="Figure 18.1 – High-level CAS authentication flow" height="1245" src="image/B21757_18_1.jpg" width="1276"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.1 – High-level CAS authentication flow</p>
<p>We can see<a id="_idIndexMarker1318"/> that there is a high level of interaction between the <strong class="bold">CAS</strong> server <a id="_idIndexMarker1319"/>and the secured application, with several data-exchange handshakes required before trust in the user can be established. We assume other network security precautions, such as the use of <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) and <a id="_idIndexMarker1320"/>network monitoring, are <span class="No-Break">in place.</span></p>
<p>The result of <a id="_idIndexMarker1321"/>this complexity is a SSO protocol that is quite hard to spoof through <span class="No-Break">common techniques.</span></p>
<p>Now that we understand how <strong class="bold">CAS</strong> authentication works in general, let’s see how it <a id="_idTextAnchor595"/>applies to <span class="No-Break">Spring Security.</span></p>
<h1 id="_idParaDest-394"><a id="_idTextAnchor596"/>Spring Security and CAS</h1>
<p>Spring Security <a id="_idIndexMarker1322"/>has a strong integration capability with <strong class="bold">CAS</strong>, although it’s not as tightly integrated into the security namespace style of configuration as the <strong class="bold">OAuth2</strong> and <strong class="bold">LDAP</strong> integrations that we’ve explored thus far in the latter part of this book. Instead, much of the configuration relies on bean wiring and configuration by reference from the security namespace elements to <span class="No-Break">bean declarations.</span></p>
<p>The two basic pieces of <strong class="bold">CAS</strong> authentication when using Spring Security involve <span class="No-Break">the following:</span></p>
<ul>
<li>Replacement of the standard <strong class="source-inline">AuthenticationEntryPoint</strong> implementation, which typically handles redirection of unauthenticated users to the login page with an implementation that redirects the user to the CAS <span class="No-Break">server instead</span></li>
<li>Processing the service ticket when the user is redirected back from the <strong class="bold">CAS</strong> server to the protected resource, through the use of a custom <span class="No-Break">servlet filter</span></li>
</ul>
<p>An important thing to understand about <strong class="bold">CAS</strong> is that in typical deployments, <strong class="bold">CAS</strong> is intended to replace all the alternative login mechanisms in our application. As such, once we configure <strong class="bold">CAS</strong> for Spring Security, our users must use <strong class="bold">CAS</strong> exclusively as the authentication mechanism for our application. In most cases, this is not a problem; as we discussed in the previous section, <strong class="bold">CAS</strong> is designed to proxy authentication requests to one or more authentication stores (just as Spring Security does when delegating to a database or <strong class="bold">LDAP</strong> for authentication). From the previous diagram (<span class="No-Break"><em class="italic">Figure 18</em></span><em class="italic">.1</em>), we can see that our application is no longer checking its own authentication store to validate users. Instead, it authenticates the user with service tickets. However, as we will discuss in the <em class="italic">Getting the UserDetails object from a CAS assertion</em> section, initially, Spring Security still needs a data store to determine the user’s authorization. We will discuss how to remove this restriction later in <span class="No-Break">the chapter.</span></p>
<p>After completing the<a id="_idIndexMarker1323"/> basic <strong class="bold">CAS</strong> integration with Spring Security, we can remove the login link from the home page and enjoy automatic redirection to <strong class="bold">CAS</strong>’s login screen, where we attempt to access a protected resource. Of course, depending on the application, it can also be beneficial to still allow the user to explicitly log in (so that they can see c<a id="_idTextAnchor597"/>ustomized content, among <span class="No-Break">other things).</span></p>
<h2 id="_idParaDest-395"><a id="_idTextAnchor598"/>Required dependencies</h2>
<p>Before we go too far, we should ensure that our dependencies are updated. The following is a list of the dependencies that we have added with comments on when they <span class="No-Break">are needed:</span></p>
<pre class="source-code">
//build.gradle
//Spring CAS Support
implementation " org.springframework.security:spring-security-cas"</pre> <h2 id="_idParaDest-396"><a id="_idTextAnchor599"/>Installing and configuring CAS</h2>
<p><strong class="bold">CAS</strong> has the benefit <a id="_idIndexMarker1324"/>of having an extremely dedicated team<a id="_idIndexMarker1325"/> behind it that has done an excellent job of developing both quality software and accurate, straightforward documentation on how to use it. Should you choose to follow along with the examples in this chapter, you are encouraged to read the appropriate getting started manual for your <strong class="bold">CAS</strong> platform. You can find this manual <span class="No-Break">at </span><a href="https://apereo.github.io/cas/"><span class="No-Break">https://apereo.github.io/cas/</span></a><span class="No-Break">.</span></p>
<p>In order to make integration as simple as possible, we have included a <strong class="bold">CAS</strong> server application for this chapter that can be deployed in Eclipse or IntelliJ, along with the <span class="No-Break">calendar application.</span></p>
<p>For the examples in this chapter, we will assume that <strong class="bold">CAS</strong> is deployed at <strong class="source-inline">https://localhost:9443/cas/</strong> and the calendar application is deployed at <strong class="source-inline">https://localhost:8443/</strong>. To work, <strong class="bold">CAS</strong> requires the use <span class="No-Break">of HTTPS.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The examples in this chapter were written using the most recent available version of the <strong class="source-inline">CAS</strong> server, <strong class="source-inline">7.0.1</strong> at the time of writing, which requires Java 21. So, if you are on an earlier version of the server, these instructions may be slightly or significantly different for <span class="No-Break">your environment.</span></p>
<p>Let’s go ahead and configure the components required for <span class="No-Break">CAS authentication.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start the chapter off with the source in <strong class="source-inline">chapter18.00-calendar</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">chapter18.00-cas-server</strong></span><span class="No-Break">.</span></p>
<p>To start the CAS server, run the following command from the <span class="No-Break"><strong class="source-inline">chapter18.00-cas-server</strong></span><span class="No-Break"> project:</span></p>
<pre class="console">
./gradlew build run</pre> <p>We use the following default <a id="_idIndexMarker1326"/>CAS login/password for this <a id="_idIndexMarker1327"/><span class="No-Break">example: </span><span class="No-Break"><strong class="source-inline">casuser</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">Mellon</strong></span><span class="No-Break">.</span></p>
<p>In the <strong class="bold">JBCP Calendar</strong> application, we should be able to use the same credentials to log in. Note that the user has <span class="No-Break">admin rights.</span></p>
<p>For the next steps, we need to do <span class="No-Break">the following:</span></p>
<ul>
<li>Import the CAS SSL <a id="_idIndexMarker1328"/>certificate inside the <strong class="bold">Java Runtime Environment</strong> (<strong class="bold">JRE</strong>) keystore of your <strong class="bold">JBCP Calendar</strong> application by running the following command from the following <span class="No-Break">location: </span><span class="No-Break"><strong class="source-inline">chapter18.00-cas-server/src/main/resources/etc/cas</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">keytool -importcert -file cas.crt -alias cas-server -keystore $JBCP_JAVA_HOME/lib/security/cacerts</strong></pre><p class="list-inset">The <strong class="source-inline">$JBCP_JAVA_HOME</strong> variable is the JVM used by the <strong class="bold">JBCP </strong><span class="No-Break"><strong class="bold">Calendar </strong></span><span class="No-Break">application.</span></p></li> <li>To check the import is done successfully, run the following command. If you are asked for the password the keystore password, the default one is <span class="No-Break"><em class="italic">change it</em></span><span class="No-Break">.</span><pre class="source-code">
<strong class="bold">keytool -list -keystore $JBCP_JAVA_HOME/lib/security/cacerts -alias cas-server</strong></pre><p class="list-inset">The output should be similar to <span class="No-Break">the following:</span></p><pre class="source-code"><strong class="bold">cas-server, May 6, 2024, trustedCertEntry,</strong>
<strong class="bold">Certificate fingerprint (SHA-256): 4C:E5:A1:42:58:78:69:7B:94:05:23:05:23:46:EA:DF:FB:D5:2E:10:4F:C8:90:2D:16:A2:2A:FB:26:99:40:1D</strong></pre></li> <li>Import the <strong class="bold">JBCP Calendar</strong> application certificate inside the JRE keystore of your CAS server by running the following command from the following location: <strong class="source-inline">chapter18.00-calendar/src/main/resources/keys</strong>. If you are asked for the password the keystore password, the default one is <span class="No-Break"><em class="italic">change it</em></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">keytool -importkeystore -srckeystore tomcat.jks -destkeystore </strong><strong class="bold">$CAS_JAVA_HOME</strong><strong class="bold">/lib/security/cacerts  -deststoretype JKS -alias jbcpcalendar</strong></pre><p class="list-inset">The <strong class="source-inline">$CAS_JAVA_HOME</strong> variable is the JVM used by the <span class="No-Break"><strong class="bold">CAS server</strong></span><span class="No-Break">.</span></p></li> <li>To check <a id="_idIndexMarker1329"/>the import is done successfully, you <a id="_idIndexMarker1330"/>can run the following command. If you are asked for the password the keystore password, the default one is <span class="No-Break"><em class="italic">change it</em></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">keytool -list -keystore $CAS_JAVA_HOME/lib/security/cacerts -alias jbcpcalendar</strong></pre><p class="list-inset">The output should be similar <span class="No-Break">to following:</span></p><pre class="source-code"><strong class="bold">jbcpcalendar, May 6, 2024, PrivateKeyEntry,</strong>
<strong class="bold">Certificate fingerprint (SHA-256): 79:0D:62:D7:E7:A1:25:1D:A3:C7:93:F6:03:A8:E4:B8:20:BA:FA:2B:03:9F:5C:E3:5D:6C:61:A5:6F:CD:83:57</strong></pre></li> </ul>
<p class="callout-heading">Important note</p>
<p class="callout"><strong class="source-inline">$JBCP_JAVA_HOME</strong> represents the path of <em class="italic">Java</em> used by the <strong class="bold">JBCP Calendar</strong> application. The location of the <strong class="source-inline">cacerts</strong> file is the following by <span class="No-Break">default: </span><span class="No-Break"><strong class="source-inline">$$JBCP_JAVA_HOME/lib/security/cacerts</strong></span><span class="No-Break">.</span></p>
<p class="callout"><strong class="source-inline">$CAS_JAVA_HOME</strong> represents the path of <em class="italic">Java</em> used by the <strong class="bold">CAS</strong> server. The location of the <strong class="source-inline">cacerts</strong> file is the following by <span class="No-Break">default: </span><span class="No-Break"><strong class="source-inline">$CAS_JAVA_HOME/lib/security/cacerts</strong></span><span class="No-Break">.</span></p>
<p class="callout">This path should be adapted to your current <strong class="source-inline">cacerts</strong> file location if you are not relying on the default JDK <span class="No-Break"><strong class="source-inline">cacerts</strong></span><span class="No-Break"> file.</span></p>
<p class="callout">To adapt the command to Windows, you need to replace the <strong class="source-inline">$JBCP_JAVA_HOME</strong> Unix/Linux environment variable syntax with the <strong class="source-inline">%JBCP_JAVA_HOME%</strong> Windows syntax. In this command, <strong class="source-inline">%JBCP_JAVA_HOME%</strong> is assumed to be a Windows environment variable pointing to the Java installation directory. Make sure to replace it with the actual path in <span class="No-Break">your system.</span></p>
<p class="callout">If you didn’t import both the <em class="italic">CAS server SSL certificate</em> into the <em class="italic">JBCP Calendar JVM</em>, and <em class="italic">JBCP Calendar SSL Certificate</em> into the <em class="italic">CAS server JVM</em>, you will get the following error in <span class="No-Break">the logs:</span></p>
<p class="callout"><strong class="source-inline">javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to </strong><span class="No-Break"><strong class="source-inline">requested target</strong></span></p>
<h1 id="_idParaDest-397"><a id="_idTextAnchor600"/>Configuring basic CAS integration</h1>
<p>Since the Spring Security <a id="_idIndexMarker1331"/>namespace does not support CAS configuration, there are quite a few more steps that we need to implement to get a basic <span class="No-Break">working setup.</span></p>
<h2 id="_idParaDest-398"><a id="_idTextAnchor601"/>Configuring the CAS properties</h2>
<p>The Spring Security<a id="_idIndexMarker1332"/> setup relies on an <strong class="source-inline">o.s.s.cas.ServiceProperties</strong> bean in order to store common information about <strong class="bold">CAS</strong>. The <strong class="source-inline">ServiceProperties</strong> object plays a role in coordinating the data exchange between the various <strong class="bold">CAS</strong> components—it is used as a data object to store CAS configuration settings that are shared (and are expected to match) by the varying participants in the <strong class="bold">Spring CAS</strong> stack. You can view the configuration included in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/CasConfig.java
@Configuration
public class CasConfig {
    @Value("${cas.base.url}")
    private String casBaseUrl;
    @Value("${cas.login.url}")
    private String casLoginUrl;
    @Value("${service.base.url}")
    private String serviceBaseUrl;
    @Bean
    public ServiceProperties serviceProperties() {
       ServiceProperties serviceProperties = new ServiceProperties();
       serviceProperties.setService(serviceBaseUrl+ "/login/cas");
       return serviceProperties;
    }
}</pre> <p>You probably noticed that we leveraged system properties to use variables named<strong class="source-inline"> ${cas.base.url}</strong> and <strong class="source-inline">${service.base.url}</strong>. Both values can be included in your application, and Spring will automatically replace them with the values provided in the <strong class="source-inline">PropertySources</strong> configuration. This is a common strategy when deploying a <strong class="bold">CAS</strong> service, since the <strong class="bold">CAS</strong> server will likely change as we progress from development to production. In this instance, we use <strong class="source-inline">https://localhost:9443/cas</strong> by default for the <strong class="bold">CAS</strong> server and <strong class="source-inline">https://localhost:8443</strong> for the <span class="No-Break">calendar application.</span></p>
<p>This configuration can be overridden using a system argument when the application is taken to production. Alternatively, the configuration can be externalized into a Java properties file. Either mechanism allows us to externalize our <span class="No-Break">configuration properly.</span></p>
<p>You can make the <a id="_idIndexMarker1333"/>following updates to your <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
cas:
  base:
    url: https://localhost:9443/cas
  login:
    url: ${cas.base.url}/login
service:
  base:
    url: https://localhost:8443</pre> <h2 id="_idParaDest-399"><a id="_idTextAnchor602"/>Adding the CasAuthenticationEntryPoint object</h2>
<p>As we briefly<a id="_idIndexMarker1334"/> mentioned in the <em class="italic">Spring Security and CAS</em> section, <strong class="source-inline">Spring Security</strong> uses an <strong class="source-inline">o.s.s.web.AuthenticationEntryPoint</strong> interface to request credentials from the user. Typically, this involves redirecting the user to the login page. With <strong class="bold">CAS</strong>, we will need to redirect the <strong class="bold">CAS</strong> server to request a login. When we redirect to the <strong class="bold">CAS</strong> server, Spring Security must include a <strong class="source-inline">service</strong> parameter that indicates where the <strong class="bold">CAS</strong> server should send the service ticket. Fortunately, Spring Security provides the <strong class="source-inline">o.s.s.cas.web.CasAuthenticationEntryPoint</strong> object, which is specifically designed for this purpose. The configuration that is included in the example application is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/CasConfig.java
@Bean
public CasAuthenticationEntryPoint casAuthenticationEntryPoint(ServiceProperties serviceProperties) {
    CasAuthenticationEntryPoint casAuthenticationEntryPoint = new CasAuthenticationEntryPoint();
    casAuthenticationEntryPoint.setLoginUrl(this.casLoginUrl);
    casAuthenticationEntryPoint.setServiceProperties(serviceProperties);
    return casAuthenticationEntryPoint;
}</pre> <p>The <strong class="source-inline">CasAuthenticationEntryPoint</strong> object uses the <strong class="source-inline">ServiceProperties</strong> class to <a id="_idIndexMarker1335"/>specify where to send the service ticket once the user is authenticated. CAS allows for the selective granting of access per user, per application, based on configuration. We’ll examine the particulars of this URL in a moment when we configure the servlet filter that is expected to <span class="No-Break">process it.</span></p>
<p>Next, we will need to update Spring Security to utilize the bean with <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">casAuthentication</strong></span><strong class="source-inline">
EntryPoint</strong> ID. Make the following update to our <span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http,
       CasAuthenticationEntryPoint casAuthenticationEntryPoint) throws Exception {
...omitted for brevity
          // Exception Handling
          http.exceptionHandling(exceptions -&gt; exceptions
                .authenticationEntryPoint(casAuthenticationEntryPoint)
                .accessDeniedPage("/errors/403"));
...
    return http.build();
}</pre> <h2 id="_idParaDest-400"><a id="_idTextAnchor603"/>Enabling CAS ticket verification</h2>
<p>Referring to the <a id="_idIndexMarker1336"/>diagram that we saw earlier (<span class="No-Break"><em class="italic">Figure 18</em></span><em class="italic">.1</em>), we can see that Spring Security is responsible for identifying an unauthenticated request and redirecting the user to CAS via the <strong class="source-inline">FilterSecurityInterceptor</strong> class. Adding the <strong class="source-inline">CasAuthenticationEntryPoint</strong> object has overridden the standard redirect to the login page functionality and provided the expected redirection from the application to the CAS server. Now, we need to configure things so that, once authenticated to CAS, the user is properly authenticated to <span class="No-Break">the application.</span></p>
<p>If you remember from <a href="B21757_09.xhtml#_idTextAnchor295"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Opening up to OAuth2</em>, <strong class="bold">OAuth2 </strong>uses a similar redirection approach by redirecting unauthenticated users to the <strong class="bold">OAuth2</strong> provider for authentication, and then back to the application with verifiable credentials. CAS differs from <strong class="bold">OAuth2</strong>. In the <strong class="bold">CAS</strong> protocol, upon the user’s return to the application, the application is expected to call back the <strong class="bold">CAS</strong> server to explicitly validate that the credentials provided are valid and accurate. Compare this with <strong class="bold">OAuth2</strong>, which uses the presence of a date-based nonce and key-based signature so that the credentials passed by the <strong class="bold">OAuth2</strong> provider can be <span class="No-Break">independently verified.</span></p>
<p>The <a id="_idIndexMarker1337"/>benefit of the <strong class="bold">CAS</strong> approach is that the information passed on from the <strong class="bold">CAS</strong> server to authenticate the user is much simpler—only a single URL parameter is returned to the application by the <strong class="bold">CAS</strong> server. Additionally, the application itself need not track the active or valid tickets, and instead can wholly rely on <strong class="bold">CAS</strong> to verify this information. Much as we saw with <strong class="bold">OAuth2</strong>, a servlet filter is responsible for recognizing a redirect from CAS and processing it as an authentication request. We can see how this is configured in our <strong class="source-inline">CasConfig.java</strong> file, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/CasConfig.java
@Bean
public CasAuthenticationFilter casAuthenticationFilter(CasAuthenticationProvider casAuthenticationProvider) {
    CasAuthenticationFilter filter = new CasAuthenticationFilter();
    filter.setAuthenticationManager(new ProviderManager(casAuthenticationProvider));
    return filter;
}
@Bean
public CasAuthenticationProvider casAuthenticationProvider(UserDetailsService userDetailsService,
       ServiceProperties serviceProperties, TicketValidator cas30ServiceTicketValidator) {
    CasAuthenticationProvider provider = new CasAuthenticationProvider();
    provider.setAuthenticationUserDetailsService(new UserDetailsByNameServiceWrapper&lt;&gt;(userDetailsService));
    provider.setServiceProperties(serviceProperties);
    provider.setTicketValidator(cas30ServiceTicketValidator);
    provider.setKey("key");
    return provider;
}
@Bean
public TicketValidator cas30ServiceTicketValidator() {
    return new Cas30ServiceTicketValidator(this.casBaseUrl);
}</pre> <p>Next, we need <a id="_idIndexMarker1338"/>to update Spring Security to utilize the bean with the <strong class="source-inline">CasAuthenticationFilter</strong> bean. Make the following update to our <span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
public SecurityFilterChain filterChain(HttpSecurity http,
       CasAuthenticationEntryPoint casAuthenticationEntryPoint,
       CasAuthenticationFilter casAuthenticationFilter) throws Exception {
...omitted for brevity
     // CAS Filter
    http.addFilterAt(casAuthenticationFilter, CasAuthenticationFilter.class);
     // Exception Handling
    http.exceptionHandling(exceptions -&gt; exceptions
                .authenticationEntryPoint(casAuthenticationEntryPoint)
                .accessDeniedPage("/errors/403"));
...
    return http.build();
}</pre> <p>The last thing to do is to remove the existing <strong class="source-inline">formLogin</strong> <strong class="source-inline">Spring Security</strong> definition in the <strong class="source-inline">SecurityFilterChain</strong> Bean, as we will rely on <strong class="bold">CAS</strong> login forms for <span class="No-Break">user authentication.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter18.01-calendar</strong></span><span class="No-Break">.</span></p>
<p>At this point, we <a id="_idIndexMarker1339"/>should be able to start both the <strong class="bold">CAS</strong> server and <strong class="bold">JBCP Calendar</strong> application. Then, visit <strong class="source-inline">https://localhost:8443/</strong> and select <strong class="bold">All Events</strong>, which will redirect you to the <strong class="bold">CAS</strong> server. You can then log in using the username <strong class="source-inline">casuser</strong> and the password <strong class="source-inline">Mellon</strong>. Upon successful authentication, you will be redirected back to the <strong class="bold">JBCP Calendar</strong> application. <span class="No-Break">Excellent job!</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">If you are experiencing issues, it is most likely due to <strong class="bold">an improper SSL configuration</strong>. Ensure that you have import the CAS SSL certificate inside the JRE keystore of your <strong class="bold">JBCP </strong><span class="No-Break"><strong class="bold">Calendar </strong></span><span class="No-Break">application.</span></p>
<p>Now that we have covered the basics of CAS configuration in the introduction, we will proceed to delve deeper into <span class="No-Break"><strong class="bold">Single Logout</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-401"><a id="_idTextAnchor604"/>Single Logout</h1>
<p>You may notice that if you log out<a id="_idIndexMarker1340"/> of the application, you get a logout confirmation page. However, if you click on a protected page, such as the <strong class="bold">My Events</strong> page, you are still authenticated. The problem is that the logout is only occurs locally. So, when you request another protected resource in the <strong class="bold">JBCP Calendar</strong> application, a login is requested from the <strong class="bold">CAS</strong> server. Since the user is still logged in to the <strong class="bold">CAS</strong> server, it immediately returns a service ticket and logs the user back into the <strong class="bold">JBCP </strong><span class="No-Break"><strong class="bold">Calendar</strong></span><span class="No-Break"> application.</span></p>
<p>This also means that if the user had signed in to other applications using the <strong class="bold">CAS</strong> server, they would still be authenticated to those applications, since our calendar application does not know anything about the other applications. Fortunately, <strong class="bold">CAS</strong> and Spring Security offer a solution to this problem. Just as we can request a login from the <strong class="bold">CAS</strong> server, we can also request <span class="No-Break">a logout.</span></p>
<p>You can see a high-level diagram of how logging out works within <strong class="bold">CAS</strong>, <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<img alt="Figure 18.2 – CAS Single Logout" height="903" src="image/B21757_18_2.jpg" width="1480"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.2 – CAS Single Logout</p>
<p>The following steps explain <a id="_idIndexMarker1341"/>how the <strong class="bold">Single Logout</strong> <span class="No-Break">functionality works:</span></p>
<ol>
<li>The user requests to log out of the <span class="No-Break">web application.</span></li>
<li>The web application then requests to log out of CAS by sending a redirect through the browser to the <span class="No-Break">CAS server.</span></li>
<li>The CAS server recognizes the user and then sends a logout request to each CAS service that was authenticated. Note that these logout requests do not occur through <span class="No-Break">the browser.</span></li>
<li>The CAS server indicates which user should log out by providing the original service ticket that was used to log the user in. The application is then responsible for ensuring that the user is <span class="No-Break">logged out.</span></li>
<li>The CAS server <a id="_idIndexMarker1342"/>displays the logout success page to <span class="No-Break">the user.</span></li>
</ol>
<h2 id="_idParaDest-402"><a id="_idTextAnchor605"/>Configuring Single Logout</h2>
<p>The<a id="_idIndexMarker1343"/> configuration for a <strong class="bold">Single Logout</strong> is <span class="No-Break">relatively simple:</span></p>
<ol>
<li>First, make the following updates to your <strong class="source-inline">application.yml</strong> file, adding the <strong class="bold">CAS</strong> <span class="No-Break">logout URL:</span><pre class="source-code">
cas:
  base:
    url: https://localhost:9443/cas
  login:
    url: ${cas.base.url}/login
  logout:
    url: ${cas.base.url}/logout
service:
  base:
    url: https://localhost:8443</pre></li> <li>The first step is to specify a <strong class="source-inline">logout-success-url</strong> attribute to be the logout URL of the <strong class="bold">CAS</strong> server in our <strong class="source-inline">SecurityConfig.java</strong> file. This means that after we log out locally, we will automatically redirect the user to the <strong class="bold">CAS</strong> server’s <span class="No-Break">logout page:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Value("${cas.logout.url}")
    private String casLogoutUrl;
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http,
          CasAuthenticationEntryPoint casAuthenticationEntryPoint) throws Exception {
...omitted for brevity
       // Logout
       http.logout(form -&gt; form
                   .logoutUrl("/logout")
                   .logoutSuccessUrl(casLogoutUrl))
...
       return http.build();
    }
}</pre><p class="list-inset">Since we<a id="_idIndexMarker1344"/> only have one application, this is all we need to make it appear as though a single logout is occurring. This is because we log out of our calendar application before redirecting to the <strong class="bold">CAS</strong> server logout page. This means that by the time the <strong class="bold">CAS</strong> server sends the logout request to the calendar application, the user has already been <span class="No-Break">logged out.</span></p></li> <li>We will also add our <strong class="source-inline">LogoutFilter</strong> to <strong class="source-inline">CasConfig.java</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Bean
public LogoutFilter logoutFilter() {
    LogoutFilter logoutFilter = new LogoutFilter(casLogoutUrl, new SecurityContextLogoutHandler());
    logoutFilter.setFilterProcessesUrl("/logout/cas");
    return logoutFilter;
}</pre></li> <li>If there were multiple applications and the user logged out of another application, the <strong class="bold">CAS</strong> server would send a logout request to our calendar application and the <strong class="bold">CAS</strong> server will not process the logout event. This is because our application is not listening to these logout events. The solution is simple; we must create the <strong class="source-inline">SingleSignoutFilter</strong> object. Then we need to make Spring Security aware of the <strong class="source-inline">singleLogoutFilter</strong> object in <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break">.</span><p class="list-inset">Place<a id="_idIndexMarker1345"/> the <strong class="bold">Single Logout</strong> filter before the regular logout to ensure that it receives the logout events, <span class="No-Break">as follows:</span></p><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http,
       CasAuthenticationEntryPoint casAuthenticationEntryPoint,
       CasAuthenticationFilter casAuthenticationFilter,
       LogoutFilter logoutFilter) throws Exception {
...omitted for brevity
      // Logout Filter
      http
         .addFilterBefore(new SingleSignOutFilter(), CasAuthenticationFilter.class)
         .addFilterBefore(logoutFilter, LogoutFilter.class);
    // Logout
    http.logout(form -&gt; form
                .logoutUrl("/logout")
                .logoutSuccessUrl(casLogoutUrl));
...
    return http.build();
}</pre></li> <li>Go ahead<a id="_idIndexMarker1346"/> and start up the application and try logging out now. You will observe that you are <span class="No-Break">logged out.</span></li>
<li>Now, try logging back in and visiting the <strong class="bold">CAS</strong> server’s logout URL directly. For our setup, the URL <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">https://localhost:9443/cas/logout</strong></span><span class="No-Break">.</span></li>
<li>Now, try to visit the <strong class="bold">JBCP Calendar</strong> application. You will observe that you are unable to access the application without authenticating again. This demonstrates<a id="_idIndexMarker1347"/> that the <strong class="bold">Single Logout</strong> functionality <span class="No-Break">is operational.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter18.02-calendar</strong></span><span class="No-Break">.</span></p>
<p>In this section, we covered the <strong class="bold">Single Logout</strong> implementation with <strong class="bold">CAS</strong>. Next, we will move on to discuss <span class="No-Break">clustered environments.</span></p>
<h1 id="_idParaDest-403"><a id="_idTextAnchor606"/>Clustered environments</h1>
<p>One of the things that we failed to mention<a id="_idIndexMarker1348"/> in our initial <a id="_idIndexMarker1349"/>diagram of <strong class="bold">Single Logout</strong> was how the logout is performed. Unfortunately, it is implemented by storing a mapping of the service ticket to <strong class="source-inline">HttpSession</strong> as an in-memory map. This means that <strong class="bold">Single Logout</strong> will not work properly within a <span class="No-Break">clustered environment:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<img alt="Figure 18.3 – CAS authentication in a clustered environment" height="855" src="image/B21757_18_3.jpg" width="1401"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.3 – CAS authentication in a clustered environment</p>
<p>Consider the following situation in the context of the <span class="No-Break">preceding diagram:</span></p>
<ol>
<li>The user logs in to <strong class="bold">Cluster </strong><span class="No-Break"><strong class="bold">Member A</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Cluster Member A</strong> validates the <span class="No-Break">service ticket.</span></li>
<li>It then stores in memory, the mapping of the service ticket to the <span class="No-Break">user’s session.</span></li>
<li>The user requests to log out from the <span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break"> server</span><span class="No-Break">.</span></li>
</ol>
<p>The <strong class="bold">CAS</strong> server sends a logout request to the <strong class="bold">CAS</strong> service, but <strong class="bold">Cluster Member B</strong> receives the logout request. It looks in its memory but does not find a session for <strong class="bold">Service Ticket A</strong>, because it only exists in <strong class="bold">Cluster Member A</strong>. This means the user will not be logged <span class="No-Break">out </span><span class="No-Break"><a id="_idIndexMarker1350"/></span><span class="No-Break">successfully.</span></p>
<h2 id="_idParaDest-404"><a id="_idTextAnchor607"/>Proxy ticket authentication for stateless services</h2>
<p>Centralizing <a id="_idIndexMarker1351"/>our authentication using <strong class="bold">CAS</strong> seems to work rather well for web applications, but what if we want to call a web service using <strong class="bold">CAS</strong>? In order to support this, CAS has a notion of <strong class="bold">proxy tickets</strong> (<strong class="bold">PT</strong>). The following is a diagram of how <span class="No-Break">it works:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<img alt="Figure 18.4 – CAS proxy ticket authentication" height="626" src="image/B21757_18_4.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.4 – CAS proxy ticket authentication</p>
<p>The flow is the same as standard <strong class="bold">CAS</strong> authentication until the following things <span class="No-Break">take place:</span></p>
<ol>
<li>The <strong class="bold">Service Ticket</strong> is validated when an additional parameter is included called the proxy ticket callback URL (<span class="No-Break"><strong class="bold">PGT URL</strong></span><span class="No-Break">).</span></li>
<li>The <strong class="bold">CAS</strong> server calls the <strong class="bold">PGT URL</strong> over <strong class="bold">HTTPS</strong> to validate that the <strong class="bold">PGT URL</strong> is what it claims to be. Like most of the processes in a CAS, this is done by performing an SSL handshake to the <span class="No-Break">appropriate URL.</span></li>
<li>The <strong class="bold">CAS</strong> server<a id="_idIndexMarker1352"/> submits<a id="_idIndexMarker1353"/> the <strong class="bold">Proxy Granting Ticket</strong> (<strong class="bold">PGT</strong>) and <a id="_idIndexMarker1354"/>the<strong class="bold"> Proxy Granting Ticket I Owe You</strong> (<strong class="bold">PGTIOU</strong>) to the <strong class="bold">PGT URL</strong> over <strong class="bold">HTTPS</strong> to ensure that the tickets are submitted to the source they claim <span class="No-Break">to be.</span></li>
<li>The <strong class="bold">PGT URL</strong> receives the two tickets and must store an association of the <strong class="bold">PGTIOU</strong> to <span class="No-Break">the </span><span class="No-Break"><strong class="bold">PGT</strong></span><span class="No-Break">.</span></li>
<li>The <strong class="bold">CAS</strong> server finally returns a response to the request in <em class="italic">step 1</em> that includes the username and <span class="No-Break">the </span><span class="No-Break"><strong class="bold">PGTIOU</strong></span><span class="No-Break">.</span></li>
<li>The <strong class="bold">CAS</strong> service <a id="_idIndexMarker1355"/>can look up the <strong class="bold">PGT</strong> using <span class="No-Break">the </span><span class="No-Break"><strong class="bold">PGTIOU</strong></span><span class="No-Break">.</span></li>
</ol>
<h2 id="_idParaDest-405"><a id="_idTextAnchor608"/>Configuring proxy ticket authentication</h2>
<p>Now that we know <a id="_idIndexMarker1356"/>how <strong class="bold">PT</strong> authentication works, we will update our current configuration to obtain a <strong class="bold">PGT</strong> by performing the <span class="No-Break">following steps:</span></p>
<ol>
<li>The first step is to add a reference to a <strong class="source-inline">ProxyGrantingTicketStorage</strong> implementation. Go ahead and add the following code to our <span class="No-Break"><strong class="source-inline">CasConfig.java</strong></span><span class="No-Break"> file:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Bean
public ProxyGrantingTicketStorage pgtStorage() {
    return new ProxyGrantingTicketStorageImpl();
}
@Scheduled(fixedRate = 300_000)
public void proxyGrantingTicketStorageCleaner(){
    logger.info("Running ProxyGrantingTicketStorage#cleanup() at {}",
          LocalDateTime.now());
    pgtStorage().cleanUp();
}</pre></li> <li>The <strong class="source-inline">ProxyGrantingTicketStorageImpl</strong> implementation is an in-memory <a id="_idIndexMarker1357"/>mapping of the <strong class="bold">PGTIOU</strong> to a <strong class="bold">PGT</strong>. Just as with logging out, this means we would have problems in a clustered environment using this implementation. Refer to the JA-SIG documentation to determine how to set this up in a clustered <span class="No-Break">environment: </span><a href="https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml"><span class="No-Break">https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml</span></a><span class="No-Break">.</span></li>
<li>We also need to periodically clean <strong class="source-inline">ProxyGrantingTicketStorage</strong> by invoking its <strong class="source-inline">cleanUp()</strong> method. As you can see, Spring’s task abstraction makes this very simple. You may consider tweaking the configuration to clear the tickets in a separate thread pool that makes sense for your environment. For more information, refer to the <em class="italic">Task Execution and Scheduling</em> section of the Spring Framework Reference documentation <span class="No-Break">at </span><a href="https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml"><span class="No-Break">https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml</span></a><span class="No-Break">.</span></li>
<li>Now we need to use <strong class="source-inline">ProxyGrantingTicketStorage</strong>, which we have just created. We just need to update the <strong class="source-inline">ticketValidator</strong> method to refer to our storage and to know the <strong class="bold">PGT URL</strong>. Make the following updates <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CasConfig.java</strong></span><span class="No-Break">:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Value("${service.proxy.callback-url}")
private String calendarServiceProxyCallbackUrl;
@Bean
public TicketValidator cas30ServiceTicketValidator() {
    Cas30ProxyTicketValidator tv = new Cas30ProxyTicketValidator(this.casBaseUrl);
    tv.setProxyCallbackUrl(calendarServiceProxyCallbackUrl);
    tv.setProxyGrantingTicketStorage(pgtStorage());
    return tv;
}</pre></li> <li>Then, we need to update the <strong class="source-inline">application.yml</strong> file by adding the proxy <span class="No-Break">callback URL:</span><pre class="source-code">
service:
  base:
    url: https://localhost:8443
  proxy:
    callback-url: ${service.base.url}/callback</pre></li> <li>The last <a id="_idIndexMarker1358"/>update we need to make is to our <strong class="source-inline">CasAuthenticationFilter</strong> object, to store the <strong class="bold">PGTIOU</strong>-to-<strong class="bold">PGT</strong> mapping in our <strong class="source-inline">ProxyGrantingTicketStorage</strong> implementation when the <strong class="bold">PGT URL</strong> is called. It is critical to ensure that the <strong class="source-inline">proxyReceptorUrl</strong> attribute matches the <strong class="source-inline">proxyCallbackUrl</strong> attribute of the <strong class="source-inline">Cas20ProxyTicketValidator</strong> object to ensure that the <strong class="bold">CAS</strong> server sends the ticket to the URL that our application is listing to. Make the following changes <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CasConfig.java</strong></span><span class="No-Break">:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Bean
public CasAuthenticationFilter casAuthenticationFilter(CasAuthenticationProvider casAuthenticationProvider,
       ProxyGrantingTicketStorage pgtStorage) {
    CasAuthenticationFilter filter = new CasAuthenticationFilter();
    filter.setAuthenticationManager(new ProviderManager(casAuthenticationProvider));
    filter.setProxyGrantingTicketStorage(pgtStorage);
    filter.setProxyReceptorUrl("/pgtUrl");
    return filter;
}</pre></li> </ol>
<p>Now that we have a <strong class="bold">PGT</strong>, what do we do with it? A service ticket is a single-use token. However, a <strong class="bold">PGT</strong> can be used to <a id="_idIndexMarker1359"/>produce a <strong class="bold">PT</strong>. Let’s see how we can create a <strong class="bold">PT</strong> using <span class="No-Break">a </span><span class="No-Break"><strong class="bold">PGT</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">In the <strong class="source-inline">application.yml</strong> configuration file, we can observe that the <strong class="source-inline">proxyCallBackUrl</strong> attribute matches the absolute path of our context-relative <strong class="source-inline">proxyReceptorUrl</strong> attribute path. Since we are deploying our base application to <strong class="source-inline">${service.base.url}</strong>, the full path of our <strong class="source-inline">proxyReceptor</strong> URL will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">${service.base.url}/pgtUrl</strong></span><span class="No-Break">.</span></p>
<p>Following this examination of the configuration on a <strong class="bold">CAS</strong> Server clustered environments, we will next delve into the detailed utilization of CAS <span class="No-Break">proxy tickets.</span></p>
<h1 id="_idParaDest-406"><a id="_idTextAnchor609"/>Using proxy tickets</h1>
<p>We can now use<a id="_idIndexMarker1360"/> our <strong class="bold">PGT</strong> to create a <strong class="bold">PT</strong> to authenticate it to a service. The code to do this is quite trivially demonstrated in the <strong class="source-inline">EchoController</strong> class that we have included in the code for this chapter. You can see the relevant portions of it in the following <a id="_idIndexMarker1361"/>code snippet. For additional details, refer to the example <span class="No-Break">source code:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/controllers/ EchoController.java
@GetMapping("/echo")
   public String echo()  {
       final CasAuthenticationToken token = (CasAuthenticationToken) SecurityContextHolder
               .getContext()
               .getAuthentication();
    // The proxyTicket could be cached in session and reused if we wanted to
       final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);
       // Make a remote call using the proxy ticket
       return restTemplate.getForObject(targetUrl+"?ticket={pt}", String.class, proxyTicket);
   }</pre> <p>This controller is a contrived example that will obtain a <strong class="bold">PT</strong> that will be used to authenticate a RESTful call to obtain all the events for the currently logged-in user. It then writes the JSON response to the page. The thing that may confuse some users is that the <strong class="source-inline">EchoController</strong> object is actually making a RESTful call to the <strong class="source-inline">MessagesController</strong> object that is in the same application. This means that the calendar application makes a RESTful call <span class="No-Break">to itself.</span></p>
<p>Go ahead <a id="_idIndexMarker1362"/>and visit <strong class="source-inline">https://localhost:8443/echo</strong> to see it in action. The page looks a lot like the <strong class="bold">CAS</strong> login page (minus the CSS). This is because the controller attempts to echo our <strong class="bold">My Events</strong> page, and our application does not yet know how to authenticate a <strong class="bold">PT</strong>. This means it is redirected to the <strong class="bold">CAS</strong> login page. Let’s see how we can authenticate <span class="No-Break">proxy tickets.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter18.03-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-407"><a id="_idTextAnchor610"/>Authenticating proxy tickets</h2>
<p>Let’s look at the following steps to <a id="_idIndexMarker1363"/>learn about authenticating <span class="No-Break">proxy tickets:</span></p>
<ol>
<li>We first need to tell the <strong class="source-inline">ServiceProperties</strong> object that we want to authenticate all of the tickets and not just those submitted to the <strong class="source-inline">filterProcessesUrl</strong> attribute. Make the following updates <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CasConfig.java</strong></span><span class="No-Break">:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Bean
public ServiceProperties serviceProperties() {
    ServiceProperties serviceProperties = new ServiceProperties();
    serviceProperties.setService(serviceBaseUrl+ "/login/cas");
    serviceProperties.setAuthenticateAllArtifacts(true);
    return serviceProperties;
}</pre></li> <li>We then need to update our <strong class="source-inline">CasAuthenticationFilter</strong> object for it to know that we want to authenticate all artifacts (that is, tickets) instead of only listening to a specific URL. We also need to use an <strong class="source-inline">AuthenticationDetailsSource</strong> interface that can dynamically provide the CAS service URL when validating proxy tickets on arbitrary URLs. This is important because when a CAS service asks whether a ticket is valid or not, it must also provide the CAS service URL that was used to create the ticket. Since proxy tickets can occur for any URL, we must be able to dynamically discover this URL. This is done by leveraging the <strong class="source-inline">ServiceAuthenticationDetailsSource</strong> object, which will provide the current URL <a id="_idIndexMarker1364"/>from the <span class="No-Break">HTTP request:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Bean
public CasAuthenticationFilter casAuthenticationFilter(CasAuthenticationProvider casAuthenticationProvider,
       ProxyGrantingTicketStorage pgtStorage, ServiceProperties serviceProperties) {
    CasAuthenticationFilter filter = new CasAuthenticationFilter();
    filter.setAuthenticationManager(new ProviderManager(casAuthenticationProvider));
    filter.setProxyGrantingTicketStorage(pgtStorage);
    filter.setProxyReceptorUrl("/pgtUrl");
    filter.setServiceProperties(serviceProperties);
    filter.setAuthenticationDetailsSource(new ServiceAuthenticationDetailsSource(serviceProperties));
    return filter;
}</pre></li> <li>We will also need to ensure that we are using the <strong class="source-inline">Cas30ProxyTicketValidator</strong> object and not the <strong class="source-inline">Cas30ServiceTicketValidator</strong> implementation, and indicate which proxy tickets we will accept. We will configure our <strong class="source-inline">Cas30ProxyTicketValidator</strong> to accept a proxy ticket from any CAS service. In a<a id="_idIndexMarker1365"/> production environment, you will want to consider restricting yourself to only those CAS services that <span class="No-Break">are trusted:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Bean
public TicketValidator cas30ServiceTicketValidator() {
    Cas30ProxyTicketValidator tv = new Cas30ProxyTicketValidator(this.casBaseUrl);
    tv.setProxyCallbackUrl(calendarServiceProxyCallbackUrl);
    tv.setProxyGrantingTicketStorage(pgtStorage());
    tv.setAcceptAnyProxy(true);
    return tv;
}</pre></li> <li>Lastly, we want to provide a cache for our <strong class="source-inline">CasAuthenticationProvider</strong> object so that we do not need to hit the CAS service for every call made to our service. To do this, we need to configure a <strong class="source-inline">StatelessTicketCache</strong> <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CasConfig.java
@Bean
public CasAuthenticationProvider casAuthenticationProvider(UserDetailsService userDetailsService,
       ServiceProperties serviceProperties, TicketValidator cas30ServiceTicketValidator, SpringCacheBasedTicketCache springCacheBasedTicketCache) {
    CasAuthenticationProvider provider = new CasAuthenticationProvider();
    provider.setAuthenticationUserDetailsService(new UserDetailsByNameServiceWrapper&lt;&gt;(userDetailsService));
    provider.setServiceProperties(serviceProperties);
    provider.setTicketValidator(cas30ServiceTicketValidator);
    provider.setKey("key");
    provider.setStatelessTicketCache(springCacheBasedTicketCache);
    return provider;
}
@Bean
public SpringCacheBasedTicketCache springCacheBasedTicketCache(CacheManager cacheManager) {
    return new SpringCacheBasedTicketCache(cacheManager.getCache("castickets"));
}</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">Don’t forget the <strong class="source-inline">@EnableCaching</strong> in the <strong class="bold">CAS</strong> configuration class-level <strong class="source-inline">CasConfig.java</strong>, so that caching can automatically enabled <span class="No-Break">by Spring.</span></p>
<ol>
<li value="5">As you might <a id="_idIndexMarker1366"/>have suspected, the Spring cache can rely on external implementations including <strong class="source-inline">EhCache</strong>. Go ahead and start the application back up and visit <strong class="source-inline">https://localhost:8443/echo</strong> again. This time, you should see a response to calling our <strong class="bold">My </strong><span class="No-Break"><strong class="bold">Events</strong></span><span class="No-Break"> page:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer133">
<img alt="Figure 18.5 – Authenticating proxy tickets response" height="352" src="image/B21757_18_5.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.5 – Authenticating proxy tickets response</p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter18.04-calendar</strong></span><span class="No-Break">.</span></p>
<p>After using proxy tickets, we’ll next explore the process of customizing the <span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break"> server.</span></p>
<h1 id="_idParaDest-408"><a id="_idTextAnchor611"/>Customizing the CAS server</h1>
<p>All the changes in this section <a id="_idIndexMarker1367"/>will be made to the <strong class="bold">CAS</strong> server and not the calendar application. This section is only meant to be an introduction to configuring the <strong class="bold">CAS</strong> server, as a detailed setup is certainly beyond the scope of this book. Just as with the changes made to the calendar application, we encourage you to follow along with the changes in this chapter. For more information, you can refer to the <strong class="bold">CAS Aperero</strong> <span class="No-Break">documentation: </span><span class="No-Break">https://apereo.github.io/cas</span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-409"><a id="_idTextAnchor612"/>CAS WAR overlay</h2>
<p>The preferred way to<a id="_idIndexMarker1368"/> customize <strong class="bold">CAS</strong> is to use a <strong class="bold">Maven</strong> or <strong class="bold">Gradle</strong> <strong class="bold">WAR overlay</strong>. With this mechanism, you can change everything from the UI to the method in which you authenticate with the <strong class="bold">CAS</strong> server. The concept of a WAR overlay is simple. You add a <strong class="bold">WAR overlay</strong>, <strong class="source-inline">cas-server-webapp</strong>, as a dependency, and then provide additional files that will be merged with the existing <span class="No-Break"><strong class="bold">WAR overlay</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-410"><a id="_idTextAnchor613"/>How does the CAS internal authentication work?</h2>
<p>Before we jump into <a id="_idIndexMarker1369"/>CAS configuration, we’ll briefly illustrate the standard behavior of CAS authentication processing. The following diagram should help you follow the configuration steps required to allow CAS to talk to our embedded <span class="No-Break">LDAP server:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<img alt="Figure 18.6 – CAS internal authentication flow" height="445" src="image/B21757_18_6.jpg" width="1049"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.6 – CAS internal authentication flow</p>
<p>While the preceding diagram describes the internal flow of authentication within the <strong class="bold">CAS</strong> server itself, it is likely that if you are implementing an integration between Spring Security and <strong class="bold">CAS</strong>, you will need to adjust the configuration of the <strong class="bold">CAS</strong> server as well. It’s important, therefore, that you understand how <strong class="bold">CAS</strong> authentication works at a <span class="No-Break">high level.</span></p>
<p>The <strong class="bold">CAS</strong> server’s <strong class="source-inline">org.apereo.cas.authentication.AuthenticationManager</strong> interface (not to be confused with the Spring Security interface of the same name) is responsible for authenticating the user based on the provided credentials. In Spring Security, the actual processing of the credentials is delegated to one (or more) processing class implementing the <strong class="source-inline">org.apereo.cas.authentication.AuthenticationHandler</strong> interface. We recognize that the analogous interface in <strong class="source-inline">Spring Security</strong> would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">AuthenticationProvider</strong></span><span class="No-Break">.</span></p>
<p>While not a full review of the behind-the-scenes functionality of the <strong class="bold">CAS</strong> server, this should help you understand the configuration steps in the next several exercises. We encourage you to read the source code for <strong class="bold">CAS</strong> and consult the <span class="No-Break">web-based documentation.</span></p>
<h2 id="_idParaDest-411"><a id="_idTextAnchor614"/>Configuring CAS to connect to our embedded LDAP server</h2>
<p><strong class="bold">CAS</strong> verifies a <a id="_idIndexMarker1370"/>username/password by authenticating against an LDAP directory, such as Active Directory or OpenLDAP. There are various directory architectures, and we offer configuration options for four <span class="No-Break">common scenarios.</span></p>
<p>It’s important to note that <strong class="bold">CAS</strong> automatically generates the necessary components internally based on the specified settings. If you want to authenticate against multiple LDAP servers, you can increment the index and specify the settings for the next <span class="No-Break">LDAP server.</span></p>
<p>Additionally, please be aware that attributes obtained during <strong class="bold">LDAP</strong> authentication are combined with attributes from other attribute repository sources, if applicable. Attributes obtained directly through <strong class="bold">LDAP</strong> authentication take precedence over all <span class="No-Break">other attributes.</span></p>
<p>You can find the available settings and properties in the CAS <span class="No-Break">documentation (</span><a href="https://apereo.github.io/cas/"><span class="No-Break">https://apereo.github.io/cas/</span></a><span class="No-Break">).</span></p>
<p>Let’s take a look at the following steps to configure an embedded LDAP server <span class="No-Break">with </span><span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break">:</span></p>
<ol>
<li>First, we update the <strong class="source-inline">build.gradle</strong> dependencies of the <strong class="source-inline">chapter18.00-cas-server</strong> project. We enable the CAS LDAP support and add the <strong class="source-inline">spring-security</strong> built-in support for the embedded <span class="No-Break">LDAP server:</span><pre class="source-code">
//CAS LDAP Support
implementation "org.apereo.cas:cas-server-support-ldap"
// Spring Security LDAP
implementation("org.springframework.security:spring-security-ldap")
implementation("org.springframework.security:spring-security-config")
// Embedded LDAP Server
implementation("com.unboundid:unboundid-ldapsdk")</pre></li> <li>Then we<a id="_idIndexMarker1371"/> need to add the following sections to our <strong class="source-inline">application.yml</strong> file with the connection parameters for the embedded <span class="No-Break">LDAP server:</span><pre class="source-code">
// Embedded LDAP
spring:
  ldap:
    embedded:
      ldif: classpath:/ldif/calendar.ldif
      baseDn: dc=jbcpcalendar,dc=com
      port: 33389
      credential:
        username: uid=admin,ou=system
        password: secret
// CAS configuration for LDAP
cas:
  authn:
    ldap[0]:
      useStartTls: false
      search-filter: uid={user}
      type: AUTHENTICATED
      ldapUrl: ldap://localhost:${spring.ldap.embedded.port}
      baseDn: ${spring.ldap.embedded.baseDn}
      bindDn: ${spring.ldap.embedded.credential.username}
      bindCredential: ${spring.ldap.embedded.credential.password}</pre></li> <li>For this<a id="_idIndexMarker1372"/> exercise, we will be using an LDIF file created for this book, intended to capture many of the common configuration scenarios with LDAP and Spring Security (just as we did in <a href="B21757_06.xhtml#_idTextAnchor180"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">LDAP Directory Services</em>). Copy the provided LDIF file to the following project <span class="No-Break">location: </span><span class="No-Break"><strong class="source-inline">src/main/resources/ldif/calendar.ldif</strong></span><span class="No-Break">.</span></li>
<li>Finally, we need to configure the <strong class="source-inline">CasOverlayOverrideConfiguration.java</strong> <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/org/apereo/cas/config/CasOverlayOverrideConfiguration.java
@Lazy(false)
@AutoConfiguration
public class CasOverlayOverrideConfiguration {
    private final BaseLdapPathContextSource contextSource;
    public CasOverlayOverrideConfiguration(BaseLdapPathContextSource contextSource) {
       this.contextSource = contextSource;
    }
}</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look like that in <strong class="source-inline">chapter18.05-cas-server</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">chapter18.05-calendar</strong></span><span class="No-Break">.</span></p>
<p>So, now we’ve <a id="_idIndexMarker1373"/>configured basic <strong class="bold">LDAP</strong> authentication in <strong class="bold">CAS</strong>. At this point, you should be able to restart <strong class="bold">CAS</strong>, start the <strong class="bold">JBCP Calendar</strong> application (if it’s not already running), and authenticate it using <strong class="source-inline">admin1@example.com/admin</strong> or <strong class="source-inline">user1@example.com/user1</strong>. Go ahead and try it to check whether it works. If it does not work, try checking the logs and comparing your configuration with the <span class="No-Break">example configuration.</span></p>
<p>Following the customization of the <strong class="bold">CAS</strong> server, we’ll proceed to explore how to extract the <strong class="source-inline">UserDetails</strong> object from a <span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break"> assertion.</span></p>
<h1 id="_idParaDest-412"><a id="_idTextAnchor615"/>Getting the UserDetails object from a CAS assertion</h1>
<p>Up until<a id="_idIndexMarker1374"/> this point, we have been authenticating<a id="_idIndexMarker1375"/> with <strong class="bold">CAS</strong> by obtaining the roles from our <strong class="source-inline">InMemoryUserDetailsManager</strong> object. However, we can create the <strong class="source-inline">UserDetails</strong> object from the <strong class="bold">CAS</strong> assertion just as we did with <strong class="bold">OAuth2</strong>. The first step is to configure the <strong class="bold">CAS</strong> server to return the <span class="No-Break">additional attributes.</span></p>
<h2 id="_idParaDest-413"><a id="_idTextAnchor616"/>Returning LDAP attributes in the CAS response</h2>
<p>We know<a id="_idIndexMarker1376"/> that <strong class="bold">CAS</strong> can return the username in the <strong class="bold">CAS</strong> response, but<a id="_idIndexMarker1377"/> it can also return arbitrary attributes in the <strong class="bold">CAS</strong> response. Let’s see how we can update the CAS server to return additional attributes. Ag<a id="_idTextAnchor617"/>ain, all the changes in this section are in the <em class="italic">CAS server and not in the </em><span class="No-Break"><em class="italic">calendar application</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-414"><a id="_idTextAnchor618"/>Mapping LDAP attributes to CAS attributes</h2>
<p>The first step<a id="_idIndexMarker1378"/> requires us to map <strong class="bold">LDAP</strong> attributes to <a id="_idIndexMarker1379"/>attributes in the <strong class="bold">CAS</strong> assertion (including the role attribute, which we’re expecting to contain the <span class="No-Break">user’s </span><span class="No-Break"><strong class="source-inline">GrantedAuthority</strong></span><span class="No-Break">).</span></p>
<p>We’ll add another bit of configuration to the CAS <strong class="source-inline">application.yml</strong> file. This new bit of configuration is required to instruct <strong class="bold">CAS</strong> as to how to map attributes from the <strong class="bold">CAS</strong> <strong class="source-inline">Principal</strong> object to the <strong class="bold">CAS</strong> <strong class="source-inline">principalAttributeList</strong>, which will ultimately be serialized as part of ticket validation. The configuration should be declared as follows in the <span class="No-Break"><strong class="source-inline">chapter18.06-cas-server</strong></span><span class="No-Break"> project:</span></p>
<pre class="source-code">
//src/main/resources/application.yml
cas:
  service-registry:
    core:
      init-from-json: true
    json:
      location: classpath:/etc/cas/services
  authn:
    ldap[0]:
      principalAttributeList: sn:lastName,cn:fullName,description:role
      useStartTls: false
      search-filter: uid={user}
      type: AUTHENTICATED
      ldapUrl: ldap://localhost:${spring.ldap.embedded.port}
      baseDn: ${spring.ldap.embedded.baseDn}
      bindDn: ${spring.ldap.embedded.credential.username}
      bindCredential: ${spring.ldap.embedded.credential.password}</pre> <p>The functionality behind the scenes here is confusing—essentially, the purpose of this class is to map <strong class="source-inline">org.apereo.cas.authentication.principal.Principal</strong> back to the LDAP directory. The provided <strong class="source-inline">baseDN</strong> Java bean property is searched using the LDAP query (<strong class="source-inline">uid=user1@example.com</strong>), and attributes are read from the matching entry. The attributes are mapped back to <strong class="source-inline">org.apereo.cas.authentication.principal.Principal</strong> using the key/value pairs in the <strong class="source-inline">principalAttributeList</strong> property. We recognize that LDAP’s <strong class="source-inline">cn</strong> and <strong class="source-inline">sn</strong> attributes are mapped to meaningful names, and the <strong class="source-inline">description</strong> attribute is mapped to the role that will be used for determining the authorization of <span class="No-Break">our user.</span></p>
<p>Last, we would<a id="_idIndexMarker1380"/> love to set up the same type of query in <strong class="bold">LDAP</strong> as we used with Spring Security LDAP in <a href="B21757_06.xhtml#_idTextAnchor180"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">LDAP Directory Services</em>, to be able to map <strong class="source-inline">Principal</strong> to a full LDAP-distinguished name, and then use<a id="_idIndexMarker1381"/> that <strong class="bold">Distinguished Name</strong> (<strong class="bold">DN</strong>) to look up<a id="_idIndexMarker1382"/> group membership by matching based on the <strong class="source-inline">uniqueMember</strong> attribute of a <strong class="source-inline">groupOfUniqueNames</strong> entry. Unfortunately, the CAS LDAP code doesn’t have this flexibility yet, leading to the conclusion that more advanced <strong class="bold">LDAP</strong> mapping will require extensions to base classes <span class="No-Break">in </span><span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-415"><a id="_idTextAnchor619"/>Acquiring a UserDetails from CAS</h2>
<p>When we first set <a id="_idIndexMarker1383"/>up <strong class="bold">CAS</strong> integration with Spring Security, we <a id="_idIndexMarker1384"/>configured <strong class="source-inline">UserDetailsByNameServiceWrapper</strong>, which simply translated the username presented to <strong class="bold">CAS</strong> into a <strong class="source-inline">UserDetails</strong> object from <strong class="source-inline">UserDetailsService</strong>, which we had referenced. Now that <strong class="bold">CAS </strong>is referencing the LDAP server, we can set up <strong class="source-inline">LdapUserDetailsService</strong> as we discussed at the tail end of <a href="B21757_06.xhtml#_idTextAnchor180"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">LDAP Directory Services</em>, and things will work <span class="No-Break">just fine.</span></p>
<p>Note that in the next section, we will switch back to modifying the <em class="italic">calendar application and not the </em><span class="No-Break"><em class="italic">CAS server</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-416"><a id="_idTextAnchor620"/>The GrantedAuthorityFromAssertionAttributesUser object</h2>
<p>Now that we<a id="_idIndexMarker1385"/> have modified the <strong class="bold">CAS</strong> server to return custom attributes, we’ll experiment with another capability of the Spring Security <strong class="bold">CAS</strong> integration—the ability to populate <strong class="source-inline">UserDetails</strong> from the <strong class="bold">CAS</strong> assertion itself! This is actually as simple as switching the <strong class="source-inline">AuthenticationUserDetailsService</strong> implementation <span class="No-Break">to the</span></p>
<p><span class="No-Break"><strong class="source-inline">o.s.s.cas.userdetails.GrantedAuthorityFromAssertionAttributesUser</strong></span><strong class="source-inline">
DetailsService</strong> object, whose job it is to read the <strong class="bold">CAS</strong> assertion, look for a certain attribute, and map the value of that attribute directly to the <strong class="source-inline">GrantedAuthority</strong> object for the user. Let’s assume that there is an attribute-entitled role that will be returned with the assertion. We simply configure a new <strong class="source-inline">authenticationUserDetailsService</strong> bean (be sure to replace the previously defined <strong class="source-inline">authenticationUserDetailsService</strong> bean) in the <span class="No-Break"><strong class="source-inline">CaseConfig.java</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/CasConfig.java
@Bean
public AuthenticationUserDetailsService userDetailsService() {
    return new GrantedAuthorityFromAssertionAttributesUserDetailsService(new String[] { "role" });
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Your code should look like that in <strong class="source-inline">chapter18.06-cas-server</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">chapter18.06-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-417"><a id="_idTextAnchor621"/>How is attribute retrieval useful?</h2>
<p>Remember that <strong class="bold">CAS</strong> provides a<a id="_idIndexMarker1386"/> layer of abstraction for our application, removing the ability for our application to directly access the user repository, and instead forcing all such access to be performed through <strong class="bold">CAS</strong> as <span class="No-Break">a proxy.</span></p>
<p>This is extremely powerful! It means that our application no longer cares what kind of repository the users are stored in, nor does it have to worry about the details of how to access them. This confirms that authentication with <strong class="bold">CAS</strong> is sufficient to prove that a user should be able to access our application. For system administrators, this means that should an LDAP server be renamed, moved, or otherwise adjusted, they only need to reconfigure it in a single location—<strong class="bold">CAS</strong>. Centralizing access through <strong class="bold">CAS</strong> allows for a high level of flexibility and adaptability in the overall security architecture of <span class="No-Break">the organization.</span></p>
<p>Now all applications authenticated through <strong class="bold">CAS</strong> have the same view of a user and can consistently display information across any <span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break">-enabled environment.</span></p>
<p>Be aware that, once authenticated, Spring Security does not require the <strong class="bold">CAS</strong> server unless the user is required to reauthenticate. This means that attributes and other user information stored locally in the application in the user’s <strong class="source-inline">Authentication</strong> object may become stale over time<a id="_idTextAnchor622"/>, and possibly out of sync with the source <strong class="bold">CAS</strong> server. Take care to set session timeouts appropriately to avoid this <span class="No-Break">potential issue!</span></p>
<h1 id="_idParaDest-418"><a id="_idTextAnchor623"/>Additional CAS capabilities</h1>
<p><strong class="bold">CAS</strong> offers additional advanced configuration <a id="_idIndexMarker1387"/>capabilities outside of those that are exposed through the Spring Security <strong class="bold">CAS</strong> wrappers. Some of these include the <span class="No-Break">following capabilities:</span></p>
<ul>
<li>Providing transparent SSO for users who are accessing multiple <strong class="bold">CAS</strong>- secured applications within a configurable time window on the <span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break"> server.</span></li>
<li>Applications can force users to authenticate to <strong class="bold">CAS</strong> by setting the <strong class="source-inline">renew</strong> property to <strong class="source-inline">true</strong> on <strong class="source-inline">TicketValidator</strong>; you may want to conditionally set this property in some custom code in the event that the user attempts to access a highly secured area of <span class="No-Break">the application.</span></li>
<li>A <strong class="bold">RESTful API</strong> for obtaining <span class="No-Break">service tickets.</span></li>
<li>The Aperero CAS server can also act as an <strong class="bold">OAuth2</strong> server. If you think about it, this makes sense, since <strong class="bold">CAS</strong> is very similar <span class="No-Break">to </span><span class="No-Break"><strong class="bold">OAuth2</strong></span><span class="No-Break">.</span></li>
<li>Providing <strong class="bold">OAuth</strong> support for the <strong class="bold">CAS</strong> server so that it can obtain access tokens to a delegate OAuth provider (that is, Google), or so the CAS server can be the OAuth <span class="No-Break">server</span><span class="No-Break"><a id="_idIndexMarker1388"/></span><span class="No-Break"> itself.</span></li>
</ul>
<p>We’d encourage you to explore the full capabilities of the CAS client and server as well as ask any questions to the helpful folks in the <strong class="bold">CAS Aperero</strong> <span class="No-Break">community forums!</span></p>
<h1 id="_idParaDest-419"><a id="_idTextAnchor624"/>Summary</h1>
<p>In this chapter, we learned about the <strong class="bold">CAS</strong> SSO portal and how it can be integrated with Spring Security, and we also covered the <strong class="bold">CAS</strong> architecture and communication paths between actors in a <strong class="bold">CAS</strong>-enabled environment. We also saw the benefits of <strong class="bold">CAS</strong>-enabled applications for application developers and system administrators. We also learned about configuring the <strong class="bold">JBCP Calendar</strong> application to interact with a basic <strong class="bold">CAS</strong> installation. We also covered the use of <strong class="bold">CAS</strong>’s <strong class="bold">Single </strong><span class="No-Break"><strong class="bold">Logout</strong></span><span class="No-Break"> support.</span></p>
<p>We also saw how proxy ticket authentication works and how to leverage it to authenticate <span class="No-Break">stateless services.</span></p>
<p>We also covered the tasks of updating <strong class="bold">CAS</strong> to interact with <strong class="bold">LDAP</strong> and sharing <strong class="bold">LDAP</strong> data with our <strong class="bold">CAS</strong>-enabled application. We even learned about implementing attribute exchange with the industry-standard <span class="No-Break"><strong class="bold">SAML</strong></span><span class="No-Break"> protocol.</span></p>
<p>We hope this chapter was an interesting introduction to the world of SSO. There are many other SSO systems on the market, mostly commercial, but <strong class="bold">CAS</strong> is one of the leaders of the open source SSO world and offers an excellent platform to build out <strong class="bold">SSO</strong> capability in <span class="No-Break">any organization.</span></p>
<p>For the last chapter, we’ll learn more on building GraalVM <span class="No-Break">native images.</span></p>
</div>
</div></body></html>