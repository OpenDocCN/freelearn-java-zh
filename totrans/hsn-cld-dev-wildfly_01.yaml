- en: Java EE and Modern Architectural Methodologies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 和现代架构方法论
- en: In this chapter, we will give users an overview of the current state of **Java**
    **Enterprise Edition** (**EE**) and its relevance in modern architectural methodologies,
    that is, **microservices** and **cloud computing**. We will introduce the tools
    that will be used throughout the book and the application that we will be developing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向用户概述当前**Java** **企业版**（**EE**）的状态及其在现代架构方法论中的相关性，即**微服务**和**云计算**。我们将介绍本书中将使用的工具以及我们将要开发的应用程序。
- en: Let's start by recalling a few basic facts about Java EE.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下关于 Java EE 的几个基本事实。
- en: Java EE
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE
- en: Before sketching the Java EE architecture, let's take a quick look at the process
    through which the standard is created.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制 Java EE 架构之前，让我们快速了解一下该标准是如何创建的过程。
- en: Java Community Process
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 社区进程
- en: Java EE is a standard designed for building enterprise applications with the
    Java programming language. It contains a number of specifications, which define
    functionalities required by implementations of the standard.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 是一个为使用 Java 编程语言构建企业应用而设计的标准。它包含一系列规范，这些规范定义了标准实现所需的功能。
- en: Specifications that constitute Java EE are developed in an open, community-based
    process. Both organizations and individual users can join it and take part in
    the development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 构成 Java EE 的规范是在一个开放、基于社区的过程中开发的。组织和个人用户都可以加入其中并参与开发。
- en: As a standard, Java EE may possess multiple implementations. A vendor who is
    willing to create a product that is Java EE-certified has to pass a technology
    compliance test, which guarantees that the product is in alignment with the standard.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种标准，Java EE 可能具有多个实现。愿意创建 Java EE 认证产品的供应商必须通过一项技术合规性测试，这保证了产品与标准的一致性。
- en: The standard provides the contract between enterprise application developers
    and the vendors of standard implementations. An application developer can be sure
    that their application will be supported and portable, as there are a number of
    standard implementations; they are not dependent on one vendor. Application developers
    are free to migrate their applications between different standard implementations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该标准为企业应用开发者和标准实现供应商之间的合同提供保障。应用开发者可以确信他们的应用将得到支持并且是可移植的，因为存在多个标准实现；他们不依赖于单一供应商。应用开发者可以自由地在不同的标准实现之间迁移他们的应用。
- en: It is also important to note that the standard does not determine the details
    of server implementation. As a result, vendors have to compete to provide the
    most efficient, robust, and easy-to-use implementation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，该标准并不决定服务器实现的细节。因此，供应商必须竞争以提供最有效、最稳健且易于使用的实现。
- en: To sum up, the Java EE standard provides enterprise application developers with
    an ability to write supported and portable applications. Furthermore, the community-based
    specification development process and competition between vendors help the standard
    to evolve and allows users to choose the best implementation for their needs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Java EE 标准为企业应用开发者提供了编写受支持和可移植应用的能力。此外，基于社区的规范开发过程和供应商之间的竞争有助于标准的演变，并使用户能够根据需要选择最佳实现。
- en: 'On the flip side, the fact that Java EE is a standard implementation result
    in a slower evolution and decision-making process than alternative frameworks.
    In a world in which technology is being developed rapidly, this becomes a bigger
    problem. As a result, recently, an effort has been made to refactor the way in
    which standards and specifications are created. Java EE is currently transforming
    into EE4J, a standard developed under Eclipse Foundation''s governance. We will
    return to this topic in the final [Chapter 12](9920ab21-5983-4d44-b8e5-0d08bb4e0717.xhtml):
    *Future Directions*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Java EE 作为一种标准实现的事实导致其演变和决策过程比替代框架慢。在一个技术发展迅速的世界里，这成为一个更大的问题。因此，最近，人们努力重构标准和规范创建的方式。Java
    EE 正在转型为 EE4J，这是一个在 Eclipse 基金会治理下开发的标准。我们将在最终的[第 12 章](9920ab21-5983-4d44-b8e5-0d08bb4e0717.xhtml)：*未来方向*中回到这个话题。
- en: The basic architecture of Java EE applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 应用程序的基本架构
- en: Java EE applications are written in the Java language and run on **Java virtual
    machine** (**JVM**). On top of the standard Java SE functionality, the Java EE
    implementation provider implements a number of services, which can be used by
    those applications. Examples of such services may be security, transactions, or
    dependency injection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE应用程序是用Java语言编写的，并在**Java虚拟机**（**JVM**）上运行。在标准Java SE功能之上，Java EE实现提供者实现了一系列服务，这些服务可以被这些应用程序使用。此类服务的例子可能包括安全、事务或依赖注入。
- en: Applications don't interact with enterprise services directly. Instead, the
    specifications define the **component** and **containers** concepts. Components
    are software units written in the Java language and configured and built in a
    similar way to standard Java classes. The difference is that metatada provided
    with the component allows it to be run using a runtime provided by the Java EE
    implementation. Such a runtime, which may differ for the different types of component,
    is called a container. The container is responsible for providing access to all
    enterprise services required by the component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不直接与企业服务交互。相反，规范定义了**组件**和**容器**的概念。组件是用Java语言编写的软件单元，其配置和构建方式与标准Java类类似。区别在于组件提供的元数据允许它使用Java
    EE实现提供的运行时运行。这种可能因组件类型而异运行时称为容器。容器负责提供组件所需的所有企业服务的访问。
- en: 'As an example, let''s take a look at the following component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下以下组件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding script presents an `ejb` component (1), that is, `FooDaoBean`,
    which is responsible for saving objects of the `Foo` type into the database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本展示了一个`ejb`组件（1），即`FooDaoBean`，它负责将`Foo`类型的对象保存到数据库中。
- en: 'The `ejb` container in which this component will run will be responsible for
    pooling instances of this component and managing the lifecycle for all of them.
    Furthermore, this concrete component takes advantage of the number of enterprise
    services: dependency injection (2), ORM persistence (3), and transactions (the
    default for this kind of component).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此组件的`ejb`容器将负责管理此组件的所有实例的池化以及它们的生命周期。此外，此具体组件利用了企业服务数量：依赖注入（2）、ORM持久化（3）和事务（此类组件的默认设置）。
- en: 'In general, the goal of the Java EE runtime is to take care of all technical
    aspects of enterprise applications so that the application developer can concentrate
    on writing business code. The preceding example demonstrates how it is realized
    in Java EE: the application developer writes their code using POJOs with minimal
    configuration (provided mostly by annotations). The code written by an application
    developer implements business functionalities declaratively, informing middleware
    about its technical requirements.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Java EE运行时的目标是处理企业应用的所有技术方面，以便应用开发者可以专注于编写业务代码。前面的例子演示了在Java EE中是如何实现的：应用开发者使用POJOs编写代码，配置最小化（主要由注解提供）。应用开发者编写的代码以声明性方式实现业务功能，向中间件告知其技术需求。
- en: The scope of the Java EE standard
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE标准的范围
- en: 'Traditionally, business applications written in the Java EE technology were
    based on a three-tier architectures, web, business, and enterprise information
    system tier:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，用Java EE技术编写的业务应用基于三层架构，即Web层、业务层和企业信息系统层：
- en: '![](img/3e5671a2-6106-4f18-8d30-56a4d9ff3c12.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e5671a2-6106-4f18-8d30-56a4d9ff3c12.png)'
- en: Application server implements web and business tiers. It can be accessed by
    various types of clients
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器实现了Web和业务层。它可以被各种类型的客户端访问
- en: Web components, such as **Servlets**, JSPs, or JAX-RS, allow for the implementation
    of the web layer. They are able to respond to the HTTP requests from different
    kinds of clients. For example, JSF may be used to create web user interfaces in
    a convenient way, whereas the JAX-RS API allows for the implementation of RESTful
    services.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件，如**Servlets**、JSPs或JAX-RS，允许实现Web层。它们能够响应来自不同类型客户端的HTTP请求。例如，JSF可以方便地创建Web用户界面，而JAX-RS
    API允许实现RESTful服务。
- en: The business layer is implemented by EJBs, pooled POJO-based components that
    allow for the easy implementation of transactional operations and that can provide
    a wide array of capabilities such as security, database, external system integration,
    remote access, or dependency injection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层由EJB实现，这些是基于POJO的池化组件，允许轻松实现事务操作，并提供广泛的特性，如安全、数据库、外部系统集成、远程访问或依赖注入。
- en: Although the bird's-eye view architecture is quite straightforward, it is very
    elastic and allows for the implementation of a wide array of enterprise applications.
    Moreover, the standard has evolved throughout the years, providing tools for a
    wide array enterprise usage.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从宏观角度看架构非常直接，但它非常灵活，允许实现各种企业应用程序。此外，该标准在多年中不断发展，为广泛的业务使用提供了工具。
- en: If you take a look at Java EE specification (Further Reading, link 1) you will
    be able to see all the specifications that are part of the standard. The shared
    amount of them may be intimidating at first slight. It should be noted that, in
    most cases, you will have to deal with only a subset of those. On the other hand,
    when your applications require any kind of enterprise functionality, it is highly
    probable that the needed tool is already there for you—integrated with the whole
    platform and easy to use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Java EE规范（进一步阅读，链接1），你将能够看到所有属于标准规范的部分。它们的共享量一开始可能会让人感到有些吓人。需要注意的是，在大多数情况下，你只需要处理其中的一小部分。另一方面，当你的应用程序需要任何类型的业务功能时，所需工具很可能已经集成在整个平台中，并且易于使用。
- en: Implementation of Java EE standard
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE标准的实现
- en: Java EE standard implementations are runtimes that allow us to run the components
    and provide them with the services specified in the Java EE standard. Such runtimes
    are called **application servers**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE标准实现是运行时，允许我们运行组件，并为他们提供Java EE标准中指定的服务。这样的运行时被称为**应用程序服务器**。
- en: Application developers create components based on the specification. Those components
    are assembled into archives, which can be deployed on application servers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发人员根据规范创建组件。这些组件被组装成存档，可以在应用程序服务器上部署。
- en: 'Application servers allow for the deployment of a number of applications. Furthermore,
    as hinted at the beginning of this chapter, an application can change the server
    implementation and deploy archives using the application server from the other
    vendor:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务器允许部署多个应用程序。此外，正如本章开头所暗示的，一个应用程序可以更改服务器实现，并使用来自其他供应商的应用程序服务器部署存档：
- en: '![](img/aae33ada-0215-43cb-9b91-de56f42051c3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aae33ada-0215-43cb-9b91-de56f42051c3.png)'
- en: Current development trends
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前开发趋势
- en: 'The way applications are developed evolves over time. Let''s sketch concepts
    that have had a big impact on software development in recent years: cloud computing
    and microservices.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的开发方式随着时间的推移而演变。让我们概述一下近年来对软件开发产生重大影响的几个概念：云计算和微服务。
- en: Cloud computing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算
- en: Cloud computing is an infrastructure that makes it possible to automatically
    provision computing resources on demand. The types of resource provided depend
    on the contract between the cloud provider and the customer—the cloud provider
    can provide software services, such as email or disk storage, platforms for software
    development, access to virtual machines, or infrastructure for running software
    applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算是一种基础设施，使得能够按需自动配置计算资源。提供的资源类型取决于云服务提供商与客户之间的合同——云服务提供商可以提供软件服务，如电子邮件或磁盘存储，软件开发平台，虚拟机的访问，或运行软件应用程序的基础设施。
- en: 'The resources are provided dynamically and rapidly using the internet, and,
    as a result, the customer is able to use (and pay) for resources that they currently
    use. The cloud provider, on the other hand, can take advantage of economies of
    scale: specialization and optimal resource usage will result in quality improvements
    and cost optimization.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 资源通过互联网动态和快速地提供，因此客户能够使用（并支付）他们当前使用的资源。另一方面，云服务提供商可以利用规模经济：专业化和资源的最优使用将导致质量提升和成本优化。
- en: 'So, how does interaction with cloud computing infrastructures look from the
    developer''s point of view? During the development, the cloud provider provides
    a platform that contains a number of tools: it enables developers to run multiple
    application frameworks, standalone services, and databases among others. It provides
    functionalities and tools needed by those applications: scaling, networking, security,
    and communication. Furthermore, as hinted earlier, a user pays only for the resources
    used; cloud infrastructure will adjust the resources provided based on the load
    used by your application.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，从开发者的角度来看，与云计算基础设施的交互是什么样的呢？在开发过程中，云服务提供商提供了一个包含许多工具的平台：它使开发者能够运行多个应用程序框架、独立服务和数据库等。它提供了这些应用程序所需的功能和工具：扩展、网络、安全和通信。此外，如之前所暗示的，用户只为使用的资源付费；云基础设施将根据你的应用程序使用的负载调整提供的资源。
- en: The preceding description sounds promising, but it immediately raises a number
    of questions, such as how are the resources provisioned and scaled, what kinds
    of tools can I use, and what are the APIs for the tools provided.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述听起来很有希望，但它立即引发了许多问题，例如资源是如何分配和扩展的，我可以使用哪些类型的工具，以及提供的工具的API是什么。
- en: 'One of the goals of this book is to provide you with all this information throughout.
    For the purpose of this introductory chapter, it is enough to acknowledge the
    most important information: cloud computing infrastructures will enable us to
    develop and deploy with a wide array of tools using computing resources provided
    on demand.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标是在整个过程中为你提供所有这些信息。为了介绍章节的目的，承认最重要的信息就足够了：云计算基础设施将使我们能够使用按需提供的计算资源，利用各种工具进行开发和部署。
- en: Microservices
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Microservices architecture is a software development methodology that advocates
    creating an application from loosely coupled services that cooperate together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种软件开发方法，它提倡从松散耦合的服务中创建一个应用程序，这些服务相互协作。
- en: 'Such an architecture was researched and advertised for a long period of time:
    Some time ago, a lot of attention was given to **Service-Oriented Architecture**
    (**SOA**). Even earlier, **CORBA**, the standard for distributed computing, was
    designed. Furthermore, building your applications with loosely coupled, highly
    cohesive services is a good software practice, and it can (and should) also be
    applied in a traditional monolithic application. Why has the new concept been
    created then, and what distinguishes it?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一种架构在长时间内被研究和宣传：不久前，人们对**面向服务的架构**（**SOA**）给予了大量的关注。更早之前，用于分布式计算的**CORBA**标准已经被设计出来。此外，使用松散耦合、高度内聚的服务来构建你的应用程序是一种良好的软件开发实践，并且它（以及应该）也可以应用于传统的单体应用程序。那么，为什么会有这个新概念的产生，它与什么不同？
- en: In recent years, a number of companies building large distributed systems have
    found it harder to build and maintain their systems using the traditional monolithic
    software architectures and decided to refactor their systems to loosely coupled
    modular distributed systems. Looking at the experience of those companies that
    succeeded in doing so, we were able to gather common architectural patterns in
    the systems that they built. This gave birth to the microservice architecture
    concept. Put in another way, microservices can be thought of as a software architecture
    that is another iteration of distributed computing systems, whose characteristics
    were derived from practical experience. As a result, instead of providing a definition
    of microservice architectures to which all aspiring implementors have to adhere,
    it is easier to provide a common set of characteristics that microservice systems
    share (Further Reading, link 2). Let's do it now.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在近年来，许多构建大型分布式系统的公司发现使用传统的单体软件架构来构建和维护他们的系统变得越来越困难，并决定将他们的系统重构为松散耦合的模块化分布式系统。观察那些成功做到这一点的公司的经验，我们能够收集到他们在构建的系统中的共同架构模式。这催生了微服务架构的概念。换句话说，微服务可以被看作是分布式计算系统的另一轮迭代，其特性是从实践经验中得出的。因此，而不是提供一个所有有志于实施者都必须遵守的微服务架构的定义，更容易提供一个微服务系统共有的特征集（进一步阅读，链接2）。现在就让我们来做这件事。
- en: Microservices are built as standalone services that are independently deployable.
    From the technical point of view, it means that they run in different processes
    and communicate through the network using their APIs. Each of the services can
    be started, stopped, and updated independently. Each service is responsible for
    its own data and can modify the data of other services using only their API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务被构建为独立的、可独立部署的服务。从技术角度来看，这意味着它们在不同的进程中运行，并通过它们的API通过网络进行通信。每个服务都可以独立启动、停止和更新。每个服务对其自己的数据负责，并且只能通过它们的API修改其他服务的数据。
- en: The system is decomposed into microservices around business functionalities.
    Each microservices is built by one, small team that consists of all necessary
    technical specialists. For example, in a store application, there may be a review
    service. The review service team may consist of programmers, database engineers,
    testers, and domain experts. The team is responsible for every aspect of this
    service—from getting customer feedback to database administration.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 系统被分解为围绕业务功能的微服务。每个微服务都是由一个由所有必要的专业技术专家组成的小团队构建的。例如，在一个商店应用程序中，可能有一个评论服务。评论服务团队可能包括程序员、数据库工程师、测试员和领域专家。该团队负责该服务的各个方面——从获取客户反馈到数据库管理。
- en: As you can see, instead of advertising a set of recommended characteristics
    that the applications should adhere to, successful microservice practitioners
    have created a technological environment that enforces modularity and loose coupling.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，成功的微服务实践者并没有宣传一套应用应该遵守的推荐特性，而是创造了一个强制模块化和松散耦合的技术环境。
- en: So, if you successfully implement a microservice architecture, what benefits
    will you obtain?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你成功实施了微服务架构，你将获得哪些好处？
- en: Advantages of implementing microservices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施微服务的优势
- en: The first thing that is straightforward but should be emphasized is that if
    you successfully create a system whose architectural characteristics-force modularity
    and loose coupling, you will obtain a highly modular system as ad hoc fixes and
    extensions won't compromise and effectively abandon the boundaries between services
    throughout the development process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要强调的是，如果你成功创建了一个具有强制模块化和松散耦合的架构特性的系统，你将获得一个高度模块化的系统，因为即时的修复和扩展不会妥协，并且在整个开发过程中有效地放弃服务之间的边界。
- en: 'Because of the modular characteristics of developed applications, components
    that constitute them may be developed more effectively: As there is a small, cross-sectional
    team working on each service, its members can concentrate on their own area of
    work relatively independently of other teams. As the practice suggests, as the
    team grows communication starts to inhibit work more and more. The small, focused
    team knows the domain well, and they also know each other well, can communicate
    immediately, and move the work forward.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发应用程序的模块化特性，构成它们的组件可以更有效地开发：由于每个服务都有一个小型、交叉团队在开发，其成员可以相对独立于其他团队地专注于自己的工作领域。正如实践所表明的，随着团队的增长，沟通开始越来越多地阻碍工作。小型、专注的团队对领域非常了解，他们也彼此了解，可以立即沟通，并推进工作。
- en: Also, crucial is the fact that the service can be deployed independently of
    other services. A successful microservices architecture does not have the concept
    of big system release in which all teams gather their recent updates together
    and create a major release of the whole system. Instead, all teams are able to
    release and deploy their new functionalities independently of other services.
    There is no synchronization between the teams, and if there is a new version of
    a service that can be released, the service's team can just independently design
    to do it. Such a characteristic is a catalyst for Continous Integration. The team
    is able to build the pipeline so that each code triggers a test, review, and deploy
    process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个关键的事实是，该服务可以独立于其他服务进行部署。一个成功的微服务架构没有大系统发布的概念，即所有团队将他们的最新更新集中在一起，创建整个系统的一个主要版本。相反，所有团队都能够独立于其他服务发布和部署他们的新功能。团队之间没有同步，如果有服务的某个新版本可以发布，该服务的团队可以独立设计并执行。这种特性是持续集成的催化剂。团队能够构建管道，以便每个代码触发测试、审查和部署过程。
- en: 'The characteristics described in the preceding paragraph—small, focused teams
    and independent and automated build and deployment processess—lead to very important
    characteristics of the successful microservices-based system: an ability to implement
    required changes very fast. This is crucial, as it allows for immediate responses
    to customer needs. This tightens the feedback loop between the customer and developer
    and allows the system to quickly evolve to meet the customer needs.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段描述的特征——小型、专注的团队和独立且自动化的构建和部署流程——导致了基于微服务的成功系统的重要特征：能够非常快速地实施所需变更。这是至关重要的，因为它允许立即响应用户需求。这缩短了客户和开发者之间的反馈循环，并允许系统快速进化以满足客户需求。
- en: 'Last but not least, we should mention the direct technical consequences. Microservices
    can be scaled more effectively: When scaling a traditional monolith application,
    we need to replicate a number of application servers effectively, replicating
    all the functionalities implemented in the application. Scaling microservices
    can be more fine-grained; we are able to replicate only the services that need
    more instances across different servers.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们应该提到直接的技术后果。微服务可以更有效地进行扩展：当扩展传统的单体应用程序时，我们需要有效地复制多个应用服务器，复制应用程序中实现的所有功能。扩展微服务可以更加细致；我们能够只复制在不同服务器上需要更多实例的服务。
- en: 'Furthermore, microservices architecture tends to improve the availability:
    if a review service is down, the rest of the store can work regardless of it.
    Such a situation is obviously far from ideal but way better than a shutdown of
    the whole system.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，微服务架构往往可以提高可用性：如果一个审查服务宕机，其他存储服务仍然可以正常工作，不受其影响。显然，这种情况远非理想，但比整个系统关闭要好得多。
- en: In the preceding paragraph, we mentioned that the preceding characteristics
    apply to successful microservices implementation. As it turns out, creating such
    systems is not simple. Let's learn why.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一段中，我们提到前面的特征适用于成功的微服务实施。实际上，创建这样的系统并不简单。让我们来看看原因。
- en: Challenges of implementing microservices
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施微服务的挑战
- en: 'The challenges that encompass implementing microservice architecture can be
    summarized in one phrase: distributed system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实施微服务架构所面临的挑战可以总结为一个词：分布式系统。
- en: Is the functionality that you will implement will use a bunch of services throughout
    a network. You will have to deal with network delays and failures. What if the
    response is not immediate? Is the target service down or busy? How should we find
    out, and what we should do about it?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要实现的功能是否将在整个网络中使用多个服务。你将不得不处理网络延迟和故障。如果响应不是即时的怎么办？目标服务是否宕机或忙碌？我们应该如何找出原因，以及我们应该采取什么措施？
- en: Should the data belong to one microservice? Easier said than done. We can make
    the database underlying the service consistent, but how do we propagate this information
    to other services that rely on this data?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是否应该属于一个微服务？说起来容易，做起来难。我们可以使服务底层的数据库保持一致，但如何将这一信息传播到依赖这些数据的其他服务呢？
- en: 'Also, it is nice that each team can work independently, but what if we really
    need to implement cross-service functionality? That can become a pain: a cross-team
    endeavor that may introduce large architectural changes and substantially impact
    the whole architecture.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个团队可以独立工作是一件好事，但如果我们真的需要实现跨服务功能呢？那可能会变成一件头疼的事情：一个可能引入重大架构变化并严重影响整个架构的跨团队项目。
- en: Let's assume that we managed to deal with the preceding problems and have a
    running system. What happens when an error occurs? We will have to analyze logs
    scattered around a number of services, also tracing network interactions between
    all of them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功解决了前面的问题，并且系统正在运行。当发生错误时会发生什么？我们不得不分析散布在多个服务中的日志，还要追踪它们之间的网络交互。
- en: So, how should you decide whether the microservice architecture is suitable
    for your application?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该如何决定微服务架构是否适合你的应用程序？
- en: When to adopt the microservice architecture
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时采用微服务架构
- en: Microservices should primarily be considered for systems in which managing the
    traditional monolithic application has become too complex to develop and maintain.
    If you are developing a small application, additional complexity, described in
    the preceding paragraph, may outweigh the modularity benefits and inhibit, instead
    of amplifying, your development process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应主要考虑将微服务用于管理传统单体应用程序变得过于复杂，难以开发和维护的系统。如果你正在开发一个小型应用程序，前面段落中描述的额外复杂性可能会超过模块化带来的好处，并抑制而不是放大你的开发过程。
- en: It has been suggested (*Further Reading*, link 3) that microservices architecture
    should be an evolution of the monolith application. Most systems should start
    as a monolith, and the transition to microservices should only be considered when
    the system grows to the extent that it becomes too hard to develop and maintain.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有建议（*进一步阅读*，链接3）称，微服务架构应该是单体应用程序的演变。大多数系统应该从单体开始，只有当系统增长到难以开发和维护的程度时，才应考虑过渡到微服务。
- en: Last but not least, if the system is badly designed, the transition to microservices
    won't magically solve its problems. To put it more bluntly, distributing a messy
    system will result in an even greater mess. As we have already mentioned, microservices
    should be considered as a solution when the complexity of the system requires
    imposing modularity and not as a magical fix for badly written software.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，如果系统设计得不好，过渡到微服务也不会神奇地解决其问题。更直白地说，分散一个混乱的系统只会导致更大的混乱。正如我们之前提到的，当系统的复杂性需要强加模块化时，应将微服务视为一种解决方案，而不是作为糟糕软件的神奇修复。
- en: Microservices and the cloud
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与云
- en: In order to implement a successful microservices architecture, we will need
    to automate as much of the infrastructure as possible. Eventually, we will be
    dealing with a system containing a large number of independent services running
    somewhere across the network. Maintaining such systems manually is virtually impossible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个成功的微服务架构，我们需要尽可能自动化基础设施的大部分工作。最终，我们将处理一个包含大量独立服务，这些服务在网络中的某个地方运行的系统。手动维护这样的系统几乎是不可能的。
- en: We will like each service to be automatically built, tested, scaled, and monitored.
    The cloud infrastructure is a natural microservices environment, which allows
    you to achieve that. Each service can be run and scaled on resources provided
    on demand, and the tools available will allow us to build, test, and connect the
    services in a fault-tolerant way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个服务都能自动构建、测试、扩展和监控。云基础设施是一个自然的微服务环境，这允许你实现这一点。每个服务都可以在按需提供的资源上运行和扩展，可用的工具将允许我们以容错的方式构建、测试和连接服务。
- en: You will learn about all of those in this book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中学到所有这些内容。
- en: It's time to look how Java EE can fit into the cloud-microservices picture.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看Java EE如何融入云微服务场景了。
- en: Java EE microservices
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE微服务
- en: 'As mentioned in *The basic architecture of Java EE applications* section, traditionally,
    in Java EE, you were creating JARs with your applications and deploying them on
    an application server. With microservices, we will like to transform the same
    kind of JARs into runnable services:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Java EE应用程序的基本架构*部分所述，在Java EE中，你通常创建包含应用程序的JAR文件，并在应用服务器上部署它们。在微服务中，我们希望将同类的JAR文件转换成可运行的服务：
- en: '![](img/eab1f248-568f-4adb-afc4-d9588e6b76b3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eab1f248-568f-4adb-afc4-d9588e6b76b3.png)'
- en: In a traditional scenario, the application server has to support all the APIs
    specified in the standard.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统场景中，应用服务器必须支持标准中指定的所有API。
- en: In a microservices scenario, we will like to transform each JAR, which is an
    implementation of a microservice, into a runnable JAR. This can be done by creating
    a runtime for the given microservice and assembling this runtime and the service's
    archive into a runnable JAR. Since the assembled runtime will be used by only
    one service, we don't have to include all the Java EE modules in it. The tool
    that builds your microservices will have to analyze your service's archive and
    create a runtime, which contains only those functionalities that are required
    by it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务场景中，我们希望将每个JAR（微服务的实现）转换成一个可运行的JAR。这可以通过为给定的微服务创建一个运行时，并将这个运行时和服务的存档组装成一个可运行的JAR来实现。由于组装的运行时只为一个服务使用，我们不需要在其中包含所有的Java
    EE模块。构建你的微服务的工具将不得不分析你的服务存档并创建一个运行时，其中只包含它所需的那些功能。
- en: We have already sketched how we can use Java EE as a base for microservices
    architecture, but what are the benefits that you will achieve by doing so? Firstly,
    you will be able to take advantage of proven technologies and your experience
    with them immediately. Moreover, there is a portability aspect. As we covered
    in the preceding section, you are encouraged to start with monolithic applications
    and refactor it microservices, if necessary. Owing to the common set of technologies
    used and the standard archive format that is used in both scenarios, you can easily
    migrate between the two, creating an elastic architecture that can be changed
    and refactored when necessary.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经概述了如何使用Java EE作为微服务架构的基础，但这样做的好处是什么？首先，您将能够立即利用经过验证的技术和您对它们的经验。此外，还有一个可移植性方面。正如我们在前面的章节中提到的，我们鼓励您从单体应用程序开始，并在必要时将其重构为微服务。由于两种情况下都使用了共同的技术集合和标准归档格式，您可以轻松地在两者之间迁移，创建一个在必要时可以更改和重构的弹性架构。
- en: The goal of the book
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书的目标
- en: As you are going to learn in this book, you are able to use your existing Java
    EE knowledge to create microservices architecture. This knowledge will not be
    sufficient though, because, as we mentioned in the *Microservices* section, this
    kind of architecture introduces its own complexity, which has to be handled.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在本书中学到的，您可以使用现有的Java EE知识来创建微服务架构。然而，这种知识是不够的，因为正如我们在“微服务”部分中提到的，这种架构引入了自己的复杂性，必须加以处理。
- en: The goal of this book is to fill this knowledge gap by providing you with a
    practical, hands-on introduction to the development of microservice-based applications
    running on cloud infrastructures. This book makes an assumption that you are familiar
    with Java EE and the traditional way of developing Java EE applications. It will
    complement this knowledge with the information about a concrete set of tools that
    will allow you to immediately take advantage of both cloud computing and microservices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是通过向您提供关于在云基础设施上运行基于微服务的应用程序的实用、动手实践介绍，来填补这一知识空白。本书假设您熟悉Java EE以及传统的Java
    EE应用程序开发方式。它将通过提供一组具体工具的信息来补充这一知识，这些工具将使您能够立即利用云计算和微服务。
- en: We will like to emphasize that this book does not advertise any particular methodology,
    and, as we mentioned in the *Microservices* section, any architecture decision
    should be made with regard to the concrete project, taking into consideration
    all the advantages and disadvantages. Our goal is to provide you with a set of
    tools so that if you decide to make such a transition, you will immediately know
    what to do.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想强调的是，本书不宣传任何特定的方法，正如我们在“微服务”部分中提到的，任何架构决策都应基于具体项目，考虑到所有优点和缺点。我们的目标是为您提供一套工具，以便如果您决定进行这种转型，您将立即知道该怎么做。
- en: Throughout the book, we will develop a sample application, which will serve
    as a base for all our examples. Let's learn more about it now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将开发一个示例应用程序，它将作为我们所有示例的基础。现在让我们更深入地了解它。
- en: The pet store application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宠物店应用程序
- en: Computer programming books often start with the `Hello World` application. Similarly,
    books describing a framework often develop a pet store application. We will follow
    this tradition. The pet store that we will develop will be a simple application
    that will allow you to browse the catalog of pets, add some of them to your cart,
    and finalize the payment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程书籍通常从“Hello World”应用程序开始。同样，描述框架的书籍通常开发宠物店应用程序。我们将遵循这一传统。我们将开发的宠物店将是一个简单的应用程序，允许您浏览宠物目录，将一些宠物添加到购物车，并完成支付。
- en: 'During the development of the application, we will be concentrating on cloud
    and microservice aspects. The service code is simple and uses basic Java EE technologies
    so that the reader can concentrate on what is being taught in this book: cloud
    integration and microservices development.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的开发过程中，我们将专注于云和微服务方面。服务代码简单，使用基本的Java EE技术，以便读者可以专注于本书所教授的内容：云集成和微服务开发。
- en: 'Let''s take the bird''s-eye view of the application:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的宏观角度来审视：
- en: '![](img/363032cd-f01c-4d94-bc80-801c788730c8.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/363032cd-f01c-4d94-bc80-801c788730c8.png)'
- en: The backend services (red), gateways (yellow), and security server (blue) are
    deployed in a cloud. The UI application (green) is deployed outside the cloud.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务（红色）、网关（黄色）和安全服务器（蓝色）部署在云端。UI应用程序（绿色）部署在云外。
- en: The gateway services are responsible for providing APIs for different users.
    The customer gateway provides an API for customers, which is used by petstore-ui—web-client
    implementing the store interface. The customer gateway orchestrates invocations
    to the underlying base services and is accessible from outside the cloud.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 网关服务负责为不同用户提供API。客户网关为顾客提供一个API，该API被实现商店接口的web-client宠物商店使用。客户网关协调对底层基础服务的调用，并且可以从云外访问。
- en: The security service is responsible for the authentication and authorization
    of access to different parts of the API. It is used by all other components. The
    security service is accessible from outside the cloud.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安全服务负责API不同部分的访问认证和授权。它被所有其他组件使用。安全服务可以从云外访问。
- en: 'The core functionalities are implemented by backend services. Backend services
    are not accessible from the gateway service. Let''s take a look at their functions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 核心功能由后端服务实现。后端服务不可从网关服务访问。让我们看看它们的函数：
- en: 'Catalog service: Provides information about pets available in the store'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录服务：提供商店中可用的宠物信息
- en: 'Pricing service: Responsible for providing the price of a given pet'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定价服务：负责提供特定宠物的价格
- en: 'Cart service: Responsible for keeping information about the cart of a given
    customer'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车服务：负责维护特定客户的购物车信息
- en: We will develop the application step by step throughout the book. The application
    is attached to the book, and as a result, you could work with it immediately while
    learning various concepts described in the book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中逐步开发应用程序。应用程序附在书中，因此，在学习书中描述的各种概念的同时，您可以立即与之一起工作。
- en: The technologies used
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用的技术
- en: We will convert our traditional Java EE JARs into runnable ones using WildFly
    Swarm—the tool that we will introduce in [Chapter 2](c00cfc93-f395-446e-9132-242f02216783.xhtml),
    *Get Familiar with WildFly Swarm*. WildFly Swarm is able to wrap our application
    into a JAR containing a minimal number of libraries needed for it, effectively
    creating microservices from a deployable JAR. We will cover how Swarm does it
    in [Chapter 3](dd01a81c-3ad7-4b3b-80fa-a8af1b89581c.xhtml), *Right-Size Your Applications*,
    and how to configure the created services in [Chapter 4](d76eaa85-5053-41f6-bcd1-307db5a17f60.xhtml),
    *Tuning the Configuration of Your Services*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用WildFly Swarm将我们的传统Java EE JAR转换为可运行的JAR，WildFly Swarm是我们在[第2章](c00cfc93-f395-446e-9132-242f02216783.xhtml)，*熟悉WildFly
    Swarm*中将要介绍的工具。WildFly Swarm能够将我们的应用程序包装成一个包含所需的最小数量库的JAR，有效地从可部署的JAR中创建微服务。我们将在[第3章](dd01a81c-3ad7-4b3b-80fa-a8af1b89581c.xhtml)，*调整应用程序大小*中介绍Swarm是如何做到的，以及在[第4章](d76eaa85-5053-41f6-bcd1-307db5a17f60.xhtml)，*调整您服务的配置*中讨论如何配置创建的服务。
- en: After services are written, we have to write tests for them. We will use the
    Arquillian library to do it. We will discuss how to use it in [Chapter 5](c1be724d-e5fd-4c33-bd27-c04887d5cc8e.xhtml),
    *Testing Your Services with Arquillian*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写服务之后，我们必须为它们编写测试。我们将使用Arquillian库来完成这项工作。我们将在[第5章](c1be724d-e5fd-4c33-bd27-c04887d5cc8e.xhtml)，*使用Arquillian测试您的服务*中讨论如何使用它。
- en: We will deploy the created services in cloud using OpenShift. In [Chapter 6](461aee71-984a-4158-addc-fc49341d3455.xhtml),
    *Deploying Applications on the Cloud with OpenShift*, we will give you a theoretical
    introduction to the platform, the API, and tools that it provides. In [Chapter
    7](d8bc5d6c-476e-45cf-b282-67388834947a.xhtml), *Configuring Persistent Storage
    for your Applications*, we will discuss how to configure persistent storage for
    our applications on OpenShift and how to scale and connect our services.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OpenShift在云中部署创建的服务。在[第6章](461aee71-984a-4158-addc-fc49341d3455.xhtml)，*使用OpenShift在云中部署应用程序*中，我们将向您介绍平台、API以及它提供的工具的理论介绍。在[第7章](d8bc5d6c-476e-45cf-b282-67388834947a.xhtml)，*为您的应用程序配置持久存储*中，我们将讨论如何在OpenShift上为我们的应用程序配置持久存储，以及如何扩展和连接我们的服务。
- en: Creating and deploying applications in cloud is not enough for them to be ready
    for production. We still need to secure them, monitor them, and take care of network
    failures.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中创建和部署应用程序对于它们准备就绪并不足够。我们还需要确保它们的安全，监控它们，并处理网络故障。
- en: To provide security, we will take advantage of the Keycloak server. In order
    to take care of network failures, we will use the Hystrix library. In order to
    provide monitoring.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供安全，我们将利用Keycloak服务器。为了处理网络故障，我们将使用Hystrix库。为了提供监控。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was intended to give you an overview of what you can expect from
    reading this book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为您概述阅读本书可以期待的内容。
- en: 'We have recalled basic information about Java EE and the traditional way in
    which it was used to develop enterprise application. Later, we introduced modern
    trends in software development: cloud computing and microservices architecture.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了关于Java EE及其传统开发企业应用方式的基本信息。随后，我们介绍了软件开发中的现代趋势：云计算和微服务架构。
- en: Then, we introduced the pet store—the sample application that we are going to
    develop throughout the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了宠物商店——我们将在这本书中开发的全书示例应用程序。
- en: Finally, we introduced all the technologies and tools used throughout the book,
    such as WildFly Swarm, OpenShift, Hystrix, Jenkins, and Keycloak.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了书中使用到的所有技术和工具，例如WildFly Swarm、OpenShift、Hystrix、Jenkins和Keycloak。
- en: Further reading
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[http://www.oracle.com/technetwork/java/javaee/overview/index.html](http://www.oracle.com/technetwork/java/javaee/overview/index.html)'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://www.oracle.com/technetwork/java/javaee/overview/index.html](http://www.oracle.com/technetwork/java/javaee/overview/index.html)'
- en: '[https://www.youtube.com/watch?v=wgdBVIX9ifA](https://www.youtube.com/watch?v=wgdBVIX9ifA)'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=wgdBVIX9ifA](https://www.youtube.com/watch?v=wgdBVIX9ifA)'
- en: '[https://martinfowler.com/bliki/MonolithFirst.html](https://martinfowler.com/bliki/MonolithFirst.html)'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://martinfowler.com/bliki/MonolithFirst.html](https://martinfowler.com/bliki/MonolithFirst.html)'
