- en: Garbage Collector Optimizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集器优化
- en: Java 10 offered two major improvements in the **garbage collection** (**GC**)
    domain. It included parallel full GC for **garbage-first** (**G1**) GCs, improving
    its worst-case latency. It also improved source code isolation of multiple GCs
    for the GC code in HotSpot, introducing the GC interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 10在垃圾收集（**GC**）领域提供了两大改进。它包括为**垃圾优先**（**G1**）GC提供并行完全GC，提高了其最坏情况下的延迟。它还改善了HotSpot中多个GC的源代码隔离，引入了GC接口。
- en: G1 was designated as the default GC in Java 9\. G1 was designed to avoid full
    collections by dividing memory into the survivor, eden, and old memory regions,
    and by performing intermediate GCs to free up the heap. However, when the pace
    of object allocation is high and memory can't be reclaimed fast enough, full GC
    occurs. Until JDK 9, full GC for G1 was executed using a single thread. Java 10
    supports parallel full GC for G1.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: G1被指定为Java 9的默认GC。G1通过将内存划分为幸存者、伊甸园和老年代区域，并通过执行中间GC来释放堆空间，旨在避免完全收集。然而，当对象分配速度很快且内存无法快速回收时，就会发生完全GC。直到JDK
    9，G1的完全GC使用单个线程执行。Java 10支持G1的并行完全GC。
- en: The creation of the GC interface is a pure refactoring of the HotSpot internal
    code. It isolates the source code of GCs by introducing a clean GC interface.
    It will enable new HotSpot developers to find the GC code, and for GC developers
    to develop new GCs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: GC接口的创建是对HotSpot内部代码的纯重构。它通过引入一个干净的GC接口来隔离GC的源代码。这将使新的HotSpot开发者能够找到GC代码，并使GC开发者能够开发新的GC。
- en: 'In this chapter, we''ll learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: The GC interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC接口
- en: Parallel full GC for G1
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1的并行完全GC
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the code in this chapter, you should have JDK version 10, or later,
    installed on your system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的代码，你应该在你的系统上安装了JDK版本10或更高版本。
- en: 'All code in this chapter can be accessed using the following URL: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以通过以下URL访问：[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)。
- en: Let's get started with the GC interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从GC接口开始吧。
- en: The GC interface
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC接口
- en: Imagine what happens if you are a developer working on a new GC? Or, a HotSpot
    developer (not a GC developer) working on modifying the existing GC code? Prior
    to JEP 304 or Java 10, you will have had a tough life because the GC code was
    scattered all over the HotSpot source code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你是一个正在开发新GC的开发者？或者，一个HotSpot开发者（不是GC开发者）正在修改现有的GC代码？在JEP 304或Java 10之前，你将会有一个艰难的生活，因为GC代码散布在HotSpot源代码的各个地方。
- en: The objective of **JDK Enhancement Proposals** (**JEP**) 304 is to improve the
    source code isolation of GCs by introducing a GC interface. This offers a number
    of benefits.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JDK增强提案（**JEP**）304的目标是通过引入GC接口来提高GC的源代码隔离。这提供了许多好处。
- en: Benefits
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利益
- en: By isolating the GC source code, the HotSpot internal GC code is organized better,
    meeting the basic design principles, which recommend code modularity and organization.
    A clean GC interface will help developers to add new GCs to HotSpot with ease.
    GC code segregation also makes it easier to exclude a GC from a specific JDK build.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隔离GC源代码，HotSpot内部GC代码的组织更好，符合基本的设计原则，即推荐代码模块化和组织。一个干净的GC接口将帮助开发者轻松地将新的GC添加到HotSpot。GC代码的隔离也使得从特定的JDK构建中排除GC变得更加容易。
- en: It doesn't add any new GCs or remove an existing one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会添加任何新的GC或删除现有的一个。
- en: GC code isolation and the GC interface makes it easier to exclude a GC from
    a JDK build.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GC代码隔离和GC接口使得从JDK构建中排除GC变得更加容易。
- en: Driving factors
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动因素
- en: 'Imagine that you are a GC developer and you are supposed to know all the places
    where you could locate the code for GC in HotSpot. If this doesn''t sound scary
    enough, imagine how it would feel if you didn''t know how to extend it to your
    specific requirements. Or, imagine that you are a HotSpot developer (not a GC
    developer), and you can''t seem to find a specific code for a GC. We are not done
    yet—now imagine that you must exclude a specific GC at build time. These cases
    are represented in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你是一个GC开发者，你应该知道所有可以找到HotSpot中GC代码的地方。如果这还不够可怕，想象一下如果你不知道如何将其扩展到你的特定需求会是什么感觉。或者，想象一下，如果你是一个HotSpot开发者（而不是GC开发者），你似乎找不到GC的特定代码。我们还没有结束——现在想象一下，你必须排除构建时的特定GC。这些情况在以下图中表示：
- en: '![](img/29e15f5f-6288-4b0c-8c4b-d60c854bbe0e.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29e15f5f-6288-4b0c-8c4b-d60c854bbe0e.png)'
- en: The preceding use cases demonstrate the major factors driving the changes to
    the code base—by pushing the creation of a clean GC interface.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述用例展示了推动代码库变化的主要因素——通过推动创建一个干净的 GC 接口。
- en: Even though the code of the GCs was defined in their respective directories
    (for example, the `src/hotspot/share/gc/g1` stored code for G1 GC), some code
    was defined outside these directories. A typical example of this is the barrier
    required by most of the GC. Since the barrier code was implemented in the C1 and
    C2 runtime interpreter, this code was defined in the directories that defined
    the code for C1 and C2\. However, this leads to a fragmented GC code, which is
    hard to track and locate.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管GC的代码在其各自的目录中定义（例如，`src/hotspot/share/gc/g1` 存储了 G1 GC 的代码），但一些代码是在这些目录之外定义的。一个典型的例子是大多数
    GC 所需的屏障。由于屏障代码是在 C1 和 C2 运行时解释器中实现的，因此这些代码定义在定义 C1 和 C2 代码的目录中。然而，这导致 GC 代码碎片化，难以追踪和定位。
- en: A GC interface introduces a layer of abstraction, taking the burden to track
    all the GC code off a developer (both GC and HotSpot).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: GC 接口引入了一层抽象，将跟踪所有 GC 代码的负担从开发者（包括 GC 和 HotSpot）身上移开。
- en: Impact
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响
- en: The GC interface will affect other **JavaServer Pages** (**JSPs**). It will
    help to deprecate the **Concurrent Mark Sweep** (**CMS**) **garbage collector**
    (**GC**) (**JEP 291**). With the GC interface, a GC can be isolated in the base
    code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GC 接口将影响其他 **JavaServer Pages** (**JSPs**)。它将有助于弃用 **并发标记清除** (**CMS**) **垃圾收集器**
    (**GC**) (**JEP 291**)。使用 GC 接口，GC 可以在基础代码中隔离。
- en: A GC interface will also help to lower the impact of the introduction of a new
    GC in HotSpot. For example, it will help to lower the intrusiveness of the changes
    made by the Shenandoah (JEP 189) GC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GC 接口还将有助于降低在 HotSpot 中引入新 GC 的影响。例如，它将有助于降低 Shenandoah (JEP 189) GC 所做的更改的侵入性。
- en: In the next section, let's see how the changes with the G1 GC are helping to
    make applications more responsive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看 G1 GC 的变化是如何帮助使应用程序更响应的。
- en: Parallel full GC for G1 (JEP 307)
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1 的并行完全 GC（JEP 307）
- en: Imagine that you are asked to clean every nook and corner of your home, all
    by yourself, without any help. In this case, for how long will your house will
    remain inaccessible for others (since you don't want any interruptions while the
    cleaning is going on)?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被要求独自打扫你家的每一个角落，没有任何帮助。在这种情况下，你的房子将保持多长时间无法进入（因为你不想在打扫过程中有任何干扰）？
- en: Now compare yourself to a single thread and your house to the memory allocated
    to your JVM. If a single thread performs a full GC, your application will witness
    worst-case latencies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你自己与一个单线程相比，将你的房子与分配给 JVM 的内存相比。如果一个单线程执行完全 GC，你的应用程序将见证最坏情况的延迟。
- en: G1 GC was made the default GC with Java 9, but with a single thread for full
    GC. With JEP 307, Java 10 makes full G1 GC parallel to improve application latency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC 在 Java 9 中被设置为默认 GC，但完全 GC 使用单个线程。随着 JEP 307，Java 10 使完全 G1 GC 并行化，以改善应用程序的延迟。
- en: Let's quickly go through the details of G1, so that JEP 307 makes more sense
    to you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下 G1 的细节，以便 JEP 307 对您更有意义。
- en: The design goals of G1 GC
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1 GC 的设计目标
- en: G1 GC was designed to avoid full GC collections. One of the main design goals
    of G1 was to add predictability and configurability to the duration and distribution
    of *stop-the-world* GC pauses.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC 被设计为避免完全 GC 收集。G1 的一个主要设计目标是向 *停止世界的* GC 暂停的持续时间和分布添加可预测性和可配置性。
- en: For instance, with G1 GC, you can specify that the stop-the-world pauses should
    not be longer than *x* ms in a *y* ms time range. A real example of this is by
    specifying that a stop-the-world pause with a G1 GC should not be more than 8
    milliseconds, every 70 seconds. The G1 GC will do its best to meet this performance
    goal.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 G1 GC，你可以在一个 *y* 毫秒的时间范围内指定停止世界的暂停不应超过 *x* 毫秒。一个真实的例子是，指定 G1 GC 的停止世界暂停不应超过每
    70 秒 8 毫秒。G1 GC 将尽力达到这个性能目标。
- en: However, there could be a mismatch in how you configure these values and the
    actual pause times with the G1 GC.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您配置这些值的方式可能与 G1 GC 的实际暂停时间不匹配。
- en: A stop-the-world GC pause refers to a state when JVM applications become unresponsive
    because GC doesn't allow any changes when it is marking or cleaning up memory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 停止世界 GC 暂停指的是 JVM 应用程序在 GC 标记或清理内存时不允许任何更改时变得无响应的状态。
- en: G1 memory
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1 内存
- en: 'G1 divides the memory into regions—that is, the **Eden**, **Survivor**, and
    **Old** generation regions—this is typically about 2,048 in the count (or as close
    to this as possible). A region is the memory space used to store objects of different
    generations, without requiring them to be allocated contiguously. The size of
    each region depends on the memory size. All the **Eden** and **Survivor** regions
    are together referred to as the young generation, and all the **Old** regions
    are referred to as the old generation. The size of the regions is calculated as
    *X* to the power of *2*, where *X* is between 1 MB and 64 MB. G1 also defines
    the **Humongous** memory regions for large objects, whose size is greater than
    50% of the size of the **Eden** regions. Since these regions are not allocated
    contiguously, here''s how your memory might look with G1 GC:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: G1将内存划分为区域——即**伊甸**、**幸存者**和**老年代**区域——这通常在计数上约为2,048（或尽可能接近这个数字）。区域是用于存储不同代对象的内存空间，不需要它们连续分配。每个区域的大小取决于内存大小。所有**伊甸**和**幸存者**区域合在一起被称为年轻代，所有**老年代**区域合在一起被称为老年代。区域的大小计算为*X*的*2*次方，其中*X*介于1
    MB和64 MB之间。G1还定义了用于大对象的**巨无霸**内存区域，其大小大于**伊甸**区域大小的50%。由于这些区域不是连续分配的，以下是使用G1 GC时内存可能的样子：
- en: '![](img/5231a748-4ccd-4068-9ab0-689dcbf79be3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5231a748-4ccd-4068-9ab0-689dcbf79be3.png)'
- en: New objects are allocated in the **Eden** regions. During a young collection,
    a G1 GC moves the live objects from the **Eden** regions to the **Survivor** regions.
    Objects in the **Survivor** region are moved to the **Old** region if they have
    lived long enough (this is specified by using `XX:MaxTenuringThreshold`), or until
    they are collected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 新对象分配在**伊甸**区域。在年轻收集期间，G1 GC将活动对象从**伊甸**区域移动到**幸存者**区域。如果**幸存者**区域的对象存活时间足够长（这是通过使用`XX:MaxTenuringThreshold`指定的），或者直到它们被收集，它们将被移动到**老**区域。
- en: A **young collection** collects, evacuates, and compacts objects to the **Survivor**
    regions from the **Eden** regions. A **mixed collection**, as the name suggests,
    will include a *select* set of **Eden** and **Old** regions. A mixed collection
    works by collecting objects quickly and frequently so that the **Eden** and **Survivor**
    regions are freed up as soon as they can be.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**年轻收集**从**伊甸**区域收集、清除和压缩对象到**幸存者**区域。**混合收集**，正如其名所示，将包括一组**伊甸**和**老年代**区域。混合收集通过快速频繁地收集对象，以便**伊甸**和**幸存者**区域能够尽快释放。'
- en: When an object is more than 50% of the size of a region, it is allocated to
    the **Humongous** region—a contiguous set of regions in the **Old** generation
    regions. A **Humongous** region is not allocated in the **Eden** regions in order
    to keep the cost of copying or evacuating it low.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象的大小超过一个区域大小的50%时，它会被分配到**巨无霸**区域——这是**老年代**区域中一系列连续的区域。**巨无霸**区域不会分配在**伊甸**区域中，以保持复制或清除它的成本较低。
- en: When young and mixed collections can no longer reclaim enough memory, full GC
    occurs. This includes marking the live objects, preparing for compaction, adjusting
    pointers, and compacting the heap.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当年轻和混合收集无法回收足够的内存时，就会发生完全GC。这包括标记活动对象、准备压缩、调整指针以及压缩堆。
- en: This section covers just an overview of how the memory is organized and reclaimed
    in G1 GC so that you can follow the contents of this section. For further details,
    you can refer to [https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅概述了G1 GC中内存的组织和回收情况，以便您能理解本节的内容。对于更详细的信息，您可以参考[https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)。
- en: Let's work with a sample code that, apart from triggering young and mixed collections,
    also triggers full GC, eventually exiting the JVM due to an exhausted heap and
    an inability to allocate more objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个示例代码来工作，这个代码除了触发年轻和混合收集之外，还会触发完全垃圾回收（GC），最终由于堆空间耗尽和无法分配更多对象而退出JVM。
- en: Sample code
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The following sample code allocates an image array of size `999999` and loads
    images to it. Then, the code retrieves the image bytes and stores them to a byte
    array of size `999999`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码分配了一个大小为`999999`的图像数组，并将图像加载到其中。然后，代码检索图像字节并将它们存储到一个大小为`999999`的字节数组中。
- en: 'On a heap size of 3,044 MB and region size of 1 MB, this code will force full
    G1 GC and eventually shut down the JVM with `OutOfMemoryError`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在3,044 MB的堆大小和1 MB的区域大小下，此代码将强制执行完全G1 GC，并最终因`OutOfMemoryError`而关闭JVM：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can execute the preceding code using the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令执行前面的代码：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code will output GC logs to the console (by courtesy of `-Xlog:gc*`).
    It will also store the log to the `myG1log.log` file. The code (as we expected)
    will fail with `OutOfMemoryError`. Let's examine the contents of the GC log file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将输出GC日志到控制台（由`-Xlog:gc*`提供便利）。它还将日志存储到`myG1log.log`文件中。代码（正如我们预期的）将以`OutOfMemoryError`失败。让我们检查GC日志文件的内容。
- en: Starting with Java 9, G1 is the default GC. So, the preceding code doesn't use
    any runtime options to specifically use G1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 9开始，G1是默认的GC。因此，前面的代码没有使用任何运行时选项来特别使用G1。
- en: Understanding G1 GC logs
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解G1 GC日志
- en: In this section, we will have a look at the G1 GC logs in detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细查看G1 GC日志。
- en: 'The following features are marked in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中的以下功能被标记：
- en: Each heap region is of the size, 1M.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个堆区域的大小为，1M。
- en: The JVM is using G1 as its GC.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM正在使用G1作为其GC。
- en: The G1 collector starts a young collection 0.309 seconds after starting the
    application execution.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: G1收集器在启动应用程序执行后0.309秒开始年轻收集。
- en: The G1 collector uses multiple threads for the young collection.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: G1收集器使用多个线程进行年轻收集。
- en: 'The G1 collector moves live objects from 14 Eden regions to 2 Survivor regions:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: G1收集器将14个Eden区域中的存活对象移动到2个Survivor区域：
- en: '![](img/7f75cd91-8fc2-428f-9016-228cf0789c0a.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f75cd91-8fc2-428f-9016-228cf0789c0a.png)'
- en: 'Let''s examine another section of the same GC log, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查同一GC日志的另一部分，如下所示：
- en: '![](img/9f86ff2c-5ac7-4bf6-9e78-73a093e92c28.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f86ff2c-5ac7-4bf6-9e78-73a093e92c28.png)'
- en: The logs in the preceding screenshot are part of the same GC collection (note
    GC (5) in the logs). It shows logs from another young collection by the G1 GC.
    I've highlighted the Eden, Survivor, Old, and Humongous regions that the collector
    worked on. The values on the left side of the arrows show the counts of regions
    before the collection, and the values on the right are the counts of regions after
    the GC.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图中的日志是同一GC收集的一部分（注意日志中的GC（5））。它显示了G1 GC进行的另一个年轻收集的日志。我已经突出显示了收集器工作的Eden、Survivor、Old和Humongous区域。箭头左侧的值显示收集前的区域数量，右侧的值是GC后的区域数量。
- en: 'Let''s examine the last section of the G1 log before the JVM quits with `OutOfMemoryError`,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM因`OutOfMemoryError`退出之前，让我们检查G1日志的最后部分，如下所示：
- en: The collection uses multiple threads for the full collection.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集使用多个线程进行完全收集。
- en: Full GC starts.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全GC开始。
- en: Full GC includes a multiple number of steps, including marking live objects,
    preparing for compaction, adjusting pointers, and compacting the heap.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全GC包括多个步骤，包括标记存活对象、准备压缩、调整指针和压缩堆。
- en: As you will notice, there are no more Eden regions and Survivor regions available
    for allocation and compaction (0 -> 0). The Old and Humongous regions contain
    live objects that can't be collected. As a result, the JVM shuts down with `OutOfMemoryError`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您将注意到的，没有更多的Eden区域和Survivor区域可用于分配和压缩（0 -> 0）。Old和Humongous区域包含无法回收的存活对象。因此，JVM以`OutOfMemoryError`错误关闭。
- en: 'This information logs the actual time taken by the full GC:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此信息记录了完全GC的实际耗时：
- en: '![](img/e9e6fd29-c941-4e80-b75e-665a757014bf.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9e6fd29-c941-4e80-b75e-665a757014bf.png)'
- en: The bottom of the preceding screenshot includes a few final statistics, including
    total heap size, used heap size, region size, and more.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图的底部包括一些最终统计数据，包括总堆大小、已用堆大小、区域大小等。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered two JEPs that have brought improvements to the GC
    domain. JEP 304 improves the source code isolation of GCs by introducing a GC
    interface. It organizes the HotSpot internal GC code, enables GC developers to
    add new GCs to HotSpot with ease, and makes it easier to exclude a GC from a specific
    JDK build. JEP 307 improves the worst-case latencies of your application by making
    full G1 GC parallel.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两个对GC领域带来改进的JEP。JEP 304通过引入GC接口来提高GC的源代码隔离性。它组织了HotSpot内部GC代码，使GC开发者能够轻松地将新的GC添加到HotSpot中，并使得从特定的JDK构建中排除GC变得更加容易。JEP
    307通过使全G1 GC并行化来提高应用程序的最坏情况延迟。
- en: In the next chapter, we will go through multiple smaller additions and modifications
    in Java 10.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Java 10中的多个较小的新增和修改。
