- en: Garbage Collector Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 10 offered two major improvements in the **garbage collection** (**GC**)
    domain. It included parallel full GC for **garbage-first** (**G1**) GCs, improving
    its worst-case latency. It also improved source code isolation of multiple GCs
    for the GC code in HotSpot, introducing the GC interface.
  prefs: []
  type: TYPE_NORMAL
- en: G1 was designated as the default GC in Java 9\. G1 was designed to avoid full
    collections by dividing memory into the survivor, eden, and old memory regions,
    and by performing intermediate GCs to free up the heap. However, when the pace
    of object allocation is high and memory can't be reclaimed fast enough, full GC
    occurs. Until JDK 9, full GC for G1 was executed using a single thread. Java 10
    supports parallel full GC for G1.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of the GC interface is a pure refactoring of the HotSpot internal
    code. It isolates the source code of GCs by introducing a clean GC interface.
    It will enable new HotSpot developers to find the GC code, and for GC developers
    to develop new GCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The GC interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel full GC for G1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the code in this chapter, you should have JDK version 10, or later,
    installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'All code in this chapter can be accessed using the following URL: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the GC interface.
  prefs: []
  type: TYPE_NORMAL
- en: The GC interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine what happens if you are a developer working on a new GC? Or, a HotSpot
    developer (not a GC developer) working on modifying the existing GC code? Prior
    to JEP 304 or Java 10, you will have had a tough life because the GC code was
    scattered all over the HotSpot source code.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of **JDK Enhancement Proposals** (**JEP**) 304 is to improve the
    source code isolation of GCs by introducing a GC interface. This offers a number
    of benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By isolating the GC source code, the HotSpot internal GC code is organized better,
    meeting the basic design principles, which recommend code modularity and organization.
    A clean GC interface will help developers to add new GCs to HotSpot with ease.
    GC code segregation also makes it easier to exclude a GC from a specific JDK build.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't add any new GCs or remove an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: GC code isolation and the GC interface makes it easier to exclude a GC from
    a JDK build.
  prefs: []
  type: TYPE_NORMAL
- en: Driving factors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you are a GC developer and you are supposed to know all the places
    where you could locate the code for GC in HotSpot. If this doesn''t sound scary
    enough, imagine how it would feel if you didn''t know how to extend it to your
    specific requirements. Or, imagine that you are a HotSpot developer (not a GC
    developer), and you can''t seem to find a specific code for a GC. We are not done
    yet—now imagine that you must exclude a specific GC at build time. These cases
    are represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29e15f5f-6288-4b0c-8c4b-d60c854bbe0e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding use cases demonstrate the major factors driving the changes to
    the code base—by pushing the creation of a clean GC interface.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the code of the GCs was defined in their respective directories
    (for example, the `src/hotspot/share/gc/g1` stored code for G1 GC), some code
    was defined outside these directories. A typical example of this is the barrier
    required by most of the GC. Since the barrier code was implemented in the C1 and
    C2 runtime interpreter, this code was defined in the directories that defined
    the code for C1 and C2\. However, this leads to a fragmented GC code, which is
    hard to track and locate.
  prefs: []
  type: TYPE_NORMAL
- en: A GC interface introduces a layer of abstraction, taking the burden to track
    all the GC code off a developer (both GC and HotSpot).
  prefs: []
  type: TYPE_NORMAL
- en: Impact
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GC interface will affect other **JavaServer Pages** (**JSPs**). It will
    help to deprecate the **Concurrent Mark Sweep** (**CMS**) **garbage collector**
    (**GC**) (**JEP 291**). With the GC interface, a GC can be isolated in the base
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A GC interface will also help to lower the impact of the introduction of a new
    GC in HotSpot. For example, it will help to lower the intrusiveness of the changes
    made by the Shenandoah (JEP 189) GC.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's see how the changes with the G1 GC are helping to
    make applications more responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel full GC for G1 (JEP 307)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are asked to clean every nook and corner of your home, all
    by yourself, without any help. In this case, for how long will your house will
    remain inaccessible for others (since you don't want any interruptions while the
    cleaning is going on)?
  prefs: []
  type: TYPE_NORMAL
- en: Now compare yourself to a single thread and your house to the memory allocated
    to your JVM. If a single thread performs a full GC, your application will witness
    worst-case latencies.
  prefs: []
  type: TYPE_NORMAL
- en: G1 GC was made the default GC with Java 9, but with a single thread for full
    GC. With JEP 307, Java 10 makes full G1 GC parallel to improve application latency.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly go through the details of G1, so that JEP 307 makes more sense
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: The design goals of G1 GC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: G1 GC was designed to avoid full GC collections. One of the main design goals
    of G1 was to add predictability and configurability to the duration and distribution
    of *stop-the-world* GC pauses.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, with G1 GC, you can specify that the stop-the-world pauses should
    not be longer than *x* ms in a *y* ms time range. A real example of this is by
    specifying that a stop-the-world pause with a G1 GC should not be more than 8
    milliseconds, every 70 seconds. The G1 GC will do its best to meet this performance
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: However, there could be a mismatch in how you configure these values and the
    actual pause times with the G1 GC.
  prefs: []
  type: TYPE_NORMAL
- en: A stop-the-world GC pause refers to a state when JVM applications become unresponsive
    because GC doesn't allow any changes when it is marking or cleaning up memory.
  prefs: []
  type: TYPE_NORMAL
- en: G1 memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'G1 divides the memory into regions—that is, the **Eden**, **Survivor**, and
    **Old** generation regions—this is typically about 2,048 in the count (or as close
    to this as possible). A region is the memory space used to store objects of different
    generations, without requiring them to be allocated contiguously. The size of
    each region depends on the memory size. All the **Eden** and **Survivor** regions
    are together referred to as the young generation, and all the **Old** regions
    are referred to as the old generation. The size of the regions is calculated as
    *X* to the power of *2*, where *X* is between 1 MB and 64 MB. G1 also defines
    the **Humongous** memory regions for large objects, whose size is greater than
    50% of the size of the **Eden** regions. Since these regions are not allocated
    contiguously, here''s how your memory might look with G1 GC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5231a748-4ccd-4068-9ab0-689dcbf79be3.png)'
  prefs: []
  type: TYPE_IMG
- en: New objects are allocated in the **Eden** regions. During a young collection,
    a G1 GC moves the live objects from the **Eden** regions to the **Survivor** regions.
    Objects in the **Survivor** region are moved to the **Old** region if they have
    lived long enough (this is specified by using `XX:MaxTenuringThreshold`), or until
    they are collected.
  prefs: []
  type: TYPE_NORMAL
- en: A **young collection** collects, evacuates, and compacts objects to the **Survivor**
    regions from the **Eden** regions. A **mixed collection**, as the name suggests,
    will include a *select* set of **Eden** and **Old** regions. A mixed collection
    works by collecting objects quickly and frequently so that the **Eden** and **Survivor**
    regions are freed up as soon as they can be.
  prefs: []
  type: TYPE_NORMAL
- en: When an object is more than 50% of the size of a region, it is allocated to
    the **Humongous** region—a contiguous set of regions in the **Old** generation
    regions. A **Humongous** region is not allocated in the **Eden** regions in order
    to keep the cost of copying or evacuating it low.
  prefs: []
  type: TYPE_NORMAL
- en: When young and mixed collections can no longer reclaim enough memory, full GC
    occurs. This includes marking the live objects, preparing for compaction, adjusting
    pointers, and compacting the heap.
  prefs: []
  type: TYPE_NORMAL
- en: This section covers just an overview of how the memory is organized and reclaimed
    in G1 GC so that you can follow the contents of this section. For further details,
    you can refer to [https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with a sample code that, apart from triggering young and mixed collections,
    also triggers full GC, eventually exiting the JVM due to an exhausted heap and
    an inability to allocate more objects.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sample code allocates an image array of size `999999` and loads
    images to it. Then, the code retrieves the image bytes and stores them to a byte
    array of size `999999`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a heap size of 3,044 MB and region size of 1 MB, this code will force full
    G1 GC and eventually shut down the JVM with `OutOfMemoryError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute the preceding code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will output GC logs to the console (by courtesy of `-Xlog:gc*`).
    It will also store the log to the `myG1log.log` file. The code (as we expected)
    will fail with `OutOfMemoryError`. Let's examine the contents of the GC log file.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Java 9, G1 is the default GC. So, the preceding code doesn't use
    any runtime options to specifically use G1.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding G1 GC logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will have a look at the G1 GC logs in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following features are marked in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Each heap region is of the size, 1M.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM is using G1 as its GC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The G1 collector starts a young collection 0.309 seconds after starting the
    application execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The G1 collector uses multiple threads for the young collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The G1 collector moves live objects from 14 Eden regions to 2 Survivor regions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f75cd91-8fc2-428f-9016-228cf0789c0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s examine another section of the same GC log, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f86ff2c-5ac7-4bf6-9e78-73a093e92c28.png)'
  prefs: []
  type: TYPE_IMG
- en: The logs in the preceding screenshot are part of the same GC collection (note
    GC (5) in the logs). It shows logs from another young collection by the G1 GC.
    I've highlighted the Eden, Survivor, Old, and Humongous regions that the collector
    worked on. The values on the left side of the arrows show the counts of regions
    before the collection, and the values on the right are the counts of regions after
    the GC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the last section of the G1 log before the JVM quits with `OutOfMemoryError`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The collection uses multiple threads for the full collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Full GC starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Full GC includes a multiple number of steps, including marking live objects,
    preparing for compaction, adjusting pointers, and compacting the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you will notice, there are no more Eden regions and Survivor regions available
    for allocation and compaction (0 -> 0). The Old and Humongous regions contain
    live objects that can't be collected. As a result, the JVM shuts down with `OutOfMemoryError`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This information logs the actual time taken by the full GC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e9e6fd29-c941-4e80-b75e-665a757014bf.png)'
  prefs: []
  type: TYPE_IMG
- en: The bottom of the preceding screenshot includes a few final statistics, including
    total heap size, used heap size, region size, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered two JEPs that have brought improvements to the GC
    domain. JEP 304 improves the source code isolation of GCs by introducing a GC
    interface. It organizes the HotSpot internal GC code, enables GC developers to
    add new GCs to HotSpot with ease, and makes it easier to exclude a GC from a specific
    JDK build. JEP 307 improves the worst-case latencies of your application by making
    full G1 GC parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through multiple smaller additions and modifications
    in Java 10.
  prefs: []
  type: TYPE_NORMAL
