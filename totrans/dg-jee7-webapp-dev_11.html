<html><head></head><body><div class="book" title="Appendix&#xA0;B.&#xA0;From Request to Response" id="aid-30A8Q1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="appB" class="calibre1"/>Appendix B. From Request to Response</h1></div></div></div><p class="calibre7">During the job interviews for a software developer role, many people are frequently asked to describe how the web actually works behind the scenes. A candidate that can explain well the architectural layers of a software application to an interviewer may give the impression of a so-called full stack developer. However, it can be surprising how many candidates have just plausible knowledge of this topic, especially if they purport to work professionally in the digital domain. This appendix provides a concise and definitive description of the modern issues. The digital developers ought to be able to sketch and effectively document their current working architecture. So let's start with HTTP.</p><div class="book" title="HTTP"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec94" class="calibre1"/>HTTP</h1></div></div></div><p class="calibre7">HTTP is a<a id="id1102" class="calibre1"/> fundamental stateless protocol designed to transport hypermedia between a server and client. HTTP 1.1 supports the fine-grained caching of resources and the ability to retain persistent connections and chunked transfer encoding. HTTP 1.1 was <a id="id1103" class="calibre1"/>created in 1999 (refer to the superseded RFC <a class="calibre1" href="https://tools.ietf.org/html/rfc2068">https://tools.ietf.org/html/rfc2068</a>). To cope with the modern demand and usage patterns, the HTTP now supports the WebSocket handshaking and upgrade requests (<a class="calibre1" href="https://tools.ietf.org/html/rfc6455">https://tools.ietf.org/html/rfc6455</a>). The next HTTP 2.0 standard will provide the multiplexing of streams over a single client server channel. There are exciting possibilities for Java EE 8 (expected by May/June 2017) and the HTTP 2.0 support in the <a id="id1104" class="calibre1"/>Java Servlet 4.0 specification. For more details, see <a id="id1105" class="calibre1"/>RFC 7540 (<a class="calibre1" href="http://www.rfc-editor.org/rfc/rfc7540.txt">http://www.rfc-editor.org/rfc/rfc7540.txt</a>) and JSR 369 (<a class="calibre1" href="https://www.jcp.org/en/jsr/detail?id=369">https://www.jcp.org/en/jsr/detail?id=369</a>).</p><div class="book" title="An HTTP request"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec132" class="calibre1"/>An HTTP request</h2></div></div></div><p class="calibre7">An HTTP request <a id="id1106" class="calibre1"/>consists of a payload with a header and then body content. The header information contains the URI request, HTTP method, agent information, request parameters, and cookies. For the POST and PUT requests, it may also contain the form encoded properties with names and values.</p><p class="calibre7">The four basic HTTP methods that every digital engineer ought to understand are GET, POST, PUT, and DELETE. They are described in the following list:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">GET</strong></span>: This<a id="id1107" class="calibre1"/> request fetches the contents of the resources associated with a given URL</li><li class="listitem"><span class="strong"><strong class="calibre8">POST</strong></span>: This <a id="id1108" class="calibre1"/>creates a brand new resource with a payload (body content) that specifies the data for the new resource</li><li class="listitem"><span class="strong"><strong class="calibre8">PUT</strong></span>: This<a id="id1109" class="calibre1"/> updates an existing resource with a payload that specifies some or all of the data that is being replaced</li><li class="listitem"><span class="strong"><strong class="calibre8">DELETE</strong></span>: This<a id="id1110" class="calibre1"/> is a request to delete the specified resource association with the URL</li></ul></div><p class="calibre7">The following are the rare HTTP methods that are also used in special circumstances:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">HEAD</strong></span>: This<a id="id1111" class="calibre1"/> performs an acknowledgement of the resources associated with a given URL by just retrieving the headers. This request is similar to the GET request but without the body content.</li><li class="listitem"><span class="strong"><strong class="calibre8">OPTION</strong></span>: This<a id="id1112" class="calibre1"/> retrieves the application server features or web container capabilities.</li><li class="listitem"><span class="strong"><strong class="calibre8">TRACE</strong></span>: This<a id="id1113" class="calibre1"/> request allows the infrastructure to find out the network hops between the client and servers and therefore validates the latency, availability, and performance.</li></ul></div></div><div class="book" title="An HTTP response"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec133" class="calibre1"/>An HTTP response</h2></div></div></div><p class="calibre7">The HTTP response <a id="id1114" class="calibre1"/>consists of the header information and payload data (the body content). The header contains the HTTP status code, MIME type, data length, last modified date, character set encoding, cookie parameters, and cache information of the resource. The header may also contain the authentication data. The body<a id="id1115" class="calibre1"/> content is the data returned that is the client's request.</p><p class="calibre7">The HTTP Status codes are defined by the W3C. These are integer codes with ranges. Generally, the status codes 100-199 are informational messages, 200-299 represent the successful outcomes, 300-399 represent the redirection requests, 400-499 are server side errors, and the 500-599 status codes represent the authentication failures. Hence, the HTTP OK 200 and 404 NOT FOUND status codes are well-known to developers outside the digital <a id="id1116" class="calibre1"/>domain. You can find all of them listed in the RFC<a id="id1117" class="calibre1"/> at <a class="calibre1" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>.</p></div></div></div>
<div class="book" title="Java Enterprise Architectures"><div class="book" id="aid-318PC2"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec95" class="calibre1"/>Java Enterprise Architectures</h1></div></div></div><p class="calibre7">Applications in the digital domain share a common thread of architecture across multiple industrial sector <a id="id1118" class="calibre1"/>domains. Obviously, they share and rely on the Java EE 7 standard platform and JVM in order to piggy-bank the development, various nonfunctional attributes, and enterprise application infrastructure. There are subtle differences in the building of the applications.</p><div class="book" title="Standard Java EE web architecture"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec134" class="calibre1"/>Standard Java EE web architecture</h2></div></div></div><p class="calibre7">The standard Java EE web architecture is derived from the client-server models of the 1990s. The<a id="id1119" class="calibre1"/> application<a id="id1120" class="calibre1"/> server is the key component as it is responsible for three containers in the full Java EE 7 specification: Servlet, CDI, and EJB. Generally, we map these containers to the layer tier architecture for a monolithic web application. The idea of this architecture is to enhance the best practice from the point of view of solid software engineering. We want to maintain a separation of the concerns in the layers in order to avoid rigid coupling between layers and have a strong cohesion in the layers. The three layers are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Presentation layer is strongly associated with code that depends and requires the <a id="id1121" class="calibre1"/>Servlet container. FacesServlet is supplied as a part of the JSF. Alternative web application frameworks also have the idea of Front Controller that dispatches a request to the separate controllers. The presentation tier also contains the controllers and view templates.</li><li class="listitem">Domain layer<a id="id1122" class="calibre1"/> is associated with code that holds the business logic and projections of the persistence objects. It contains the application rules, business logic, and business process management. Domain objects may or may not be a part of a dependency injection. In most of the modern web applications, almost all the domain layer components and objects are a part of a dependency injection container. Therefore, domain layer is associated with the CDI container.</li><li class="listitem">Integration layer is associated with the transportation of data from the application <a id="id1123" class="calibre1"/>to the durable persistence or service areas of the system. This layer maps to a POJO that is a part of the EJB container. Usually, these objects handle the service calls from the application. As EJBs, they are transactional and not necessarily contextual, which is why they are not a part of the CDI container. These objects communicate with an external system like database through JPA and/or JDBC asynchronously to the other systems through a message over JMS or they can also synchronously (or asynchronously) invoke the remote web service endpoints through the REST or SOAP calls.</li></ul></div><p class="calibre7">The<a id="id1124" class="calibre1"/> following diagram<a id="id1125" class="calibre1"/> illustrates the architecture:</p><div class="mediaobject"><img src="../Images/image00429.jpeg" alt="Standard Java EE web architecture" class="calibre10"/><div class="caption"><p class="calibre24">The standard Java EE web architecture</p></div></div><p class="calibre11"> </p></div><div class="book" title="Extended architectures"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec135" class="calibre1"/>Extended architectures</h2></div></div></div><p class="calibre7">From the standard Java web architecture, there are several adaptations. Organizations may choose to optimize their architecture in order to suit a particular trade-off. A trade-off might be performance versus scalability, which may mean restructuring the integration<a id="id1126" class="calibre1"/> layer in order to use a NoSQL database <a id="id1127" class="calibre1"/>over a particular RDMS solution.</p><p class="calibre7">In this section, we will examine availability versus performance for a particular customer. Availability is the degree of a system to be accessible. If the system is down, then it is not available. Performance is the ability of the system to carry out the required functionality in a target timeframe. So, this customer is truly interested in the uptime of the system because the downtime will cost money, but they also want a fixed quantum of throughput.</p><p class="calibre7">Which items can degrade the performance? If the application has too much sanity checking in the code (check pointing), then it will degrade the performance. If the performance is degraded, then it may also reduce availability. However, if you do not perform a sanity check for enough parameters, then a system will be culpable to errors. If a hacker finds a weakness in your security or your caseworkers enter the wrong data too often, then your availability is compromised because your business will suffer downtime to fix issues.</p><p class="calibre7">One solution is to split the architecture in two computation bunkers. We can take advantage of the modern power in smartphones, tablets, and desktop computers to render the content on the client side. Therefore, this architecture, suits rich clients and other suitable devices with enough GPU power.</p><p class="calibre7">The code that has been sanity-checked and rendered is removed from the server side to a large degree. Depending on the architecture, we can use the JavaScript framework technologies that rely on <span class="strong"><strong class="calibre8">Model View ViewModel</strong></span> (<span class="strong"><strong class="calibre8">MVVM</strong></span>), which is supported by AngularJS. Based <a id="id1128" class="calibre1"/>on the technology choice, we can use an alternative to JSF such as the upcoming Java EE 8 MVC or directly the JAX-RS endpoints. We must ensure that correct validation takes places on both the client and server sides. We must also design the REST API or other remote invocation between client and server to be secure, safe, and idempotent. Note that we still have the features such as CDI, EJB, JMS, and JPA available to us on the server side.</p><p class="calibre7">There are benefits in this extended Java EE 7 architecture that help in the performance versus scalability trade-off. If we introduce a caching layer of data, we will gain the ability to return the data that is mostly derived from static references or changes very infrequently or is requested most often. The key benefit of caching requests from the smart clients means that response times are minimized.</p><p class="calibre7">Just after Java EE 7 was released in 2013, JCache temporary caching 1.0 final JSR 107 (<a class="calibre1" href="https://jcp.org/en/jsr/detail?id=107">https://jcp.org/en/jsr/detail?id=107</a>) was released, which is now supported by brands <a id="id1129" class="calibre1"/>such as HazelCast and Terracota.</p><p class="calibre7">This <a id="id1130" class="calibre1"/>architecture suits a hybrid form that <a id="id1131" class="calibre1"/>extends Java EE and goes beyond and outside the box of specifications. The Java EE 7 umbrella specification does not specify the orchestration of the servers, monitoring of servers or systems, deep authorization, and cloud provisioning. Let's take a look at the following figure:</p><div class="mediaobject"><img src="../Images/image00430.jpeg" alt="Extended architectures" class="calibre10"/><div class="caption"><p class="calibre24">An extended hybrid Java EE architecture that remedies performance versus availability</p></div></div><p class="calibre11"> </p></div><div class="book" title="Containerless systems"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec136" class="calibre1"/>Containerless systems</h2></div></div></div><p class="calibre7">There is another architecture that is popular with the leading edge businesses that favor continuous <a id="id1132" class="calibre1"/>deployment and guerilla engineering. This is called containerless application, which is actually a misnomer. If <a id="id1133" class="calibre1"/>we think about it, every entity system is contained in some abstract component from the highest level container and down to the hardware CPU. The operating system is constrained by the CPU, the JVM process is constrained by the operating system, and the application server contains the deployed Java EE application.</p><p class="calibre7">Technical architects make trade-offs all the time. They may consider agility like time-to-market versus cost, innovation versus affordability, and politically, the integration of legacy systems with new technology, such as a containerless system. The proper name for the containerless application ought to be embedded application controlled server, which accurately describes the architecture. There are several Java EE application server providers that allow a standalone Java application to spin a fully embedded server from the <code class="email">static void main()</code> entry point. Vendors such as JBoss's WildFly, Tomitribe's Tom EE, and of course, Oracle's GlassFish have nonstandard APIs for embedded execution. Some of the proprietary vendor solutions even allow the modular selection of the Java EE abilities in the runtime of the embedded server. An architect may thus pick and choose the provisioning of the JAX-RS, JSF, CDI, EJB, and JMS modules. A well-balanced and proficient developed team is able to circumvent the change management. The team operates <span class="strong"><em class="calibre9">under the radar</em></span> by writing a Containerless solution instead of being told for the 100th time that they are not permitted to upgrade the IBM WebSphere 7 application server.</p><p class="calibre7">Therefore, embedded servers are popular for the beginning of building the microservices architecture across several concerns. Allowing the application to control the start up and halting of the embedded servers means that these archetypes play well with the modern DevOps movement (Developers/Operations team) and the concepts around the automatic configuration management control.</p><p class="calibre7">The clear disadvantage of the containerless solution is that the building of the development tools for the traditional WAR deployment does not understand this mode. So, a digital engineer may lose the interactive and fast turnaround of increment engineering using a Java EE solution. However, it might be a short-term issue as the Java IDE makers are fairly good at picking up trends in engineering. We can hope that the Java EE technical leaders, architects, and the wider community voice their support for the specification to include a containerless API.</p><p class="calibre7">With an embedded server, engineering teams have the responsibility to ensure that the infrastructure is correctly set up. The technical architects gain the benefit of precisely controlling the external integration points and this is useful for the security, authorization and authentication, monitoring and logging, and persistent access. However, going from request to<a id="id1134" class="calibre1"/> the response is exactly the same <a id="id1135" class="calibre1"/>as in the standard Java web architecture. Let's have a look at the following screenshot:</p><div class="mediaobject"><img src="../Images/image00431.jpeg" alt="Containerless systems" class="calibre10"/><div class="caption"><p class="calibre24">Containerless Java EE architecture diagram</p></div></div><p class="calibre11"> </p><p class="calibre7">Although there is no standardization on Java EE 8 for the embedded server application architecture, other developers have at least precipitated some innovations in order to move the <a id="id1136" class="calibre1"/>community in this direction. There<a id="id1137" class="calibre1"/> is the Apache Delta Spike CDI Container Control (<a class="calibre1" href="https://deltaspike.apache.org/documentation/container-control.html">https://deltaspike.apache.org/documentation/container-control.html</a>) that currently provides a cross server library to start and stop the CDI container in a<a id="id1138" class="calibre1"/> standalone Java SE environment. Delta Spike is an award-winning open source project that has specialist modules for Bean Validation, CDI, Data, Security, and Servlets as well as container management. It is worth keeping an eye on this project because some of their innovations have made it to the Java EE 8 standard. The <code class="email">@javax.transactional.Transational</code> annotation that allows CDI managed beans take part in Container Managed Transactions (Java EE 7 and JTA 1.2) was first proposed and developed in project Delta Spike.</p></div><div class="book" title="Microservices"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec137" class="calibre1"/>Microservices</h2></div></div></div><p class="calibre7">The<a id="id1139" class="calibre1"/> embedded application controlled server<a id="id1140" class="calibre1"/> is a gateway to the Java-based microservices architecture. These microservices are a style of designing an enterprise architecture where each component solves and operates one requirement of the overall system. These key drivers are the nonfunctional requirements and can be any combination of Availability, Flexibility, Maintainability, Networkability, Performance, Robustness and Scalability. Of these, the original requirements for businesses to choose this style over the traditional monolithic architecture were Availability and Scalability.</p><p class="calibre7">Architects see certain advantages in microservices: these components follow the UNIX architectural principle of <span class="strong"><em class="calibre9">do one thing and do it well</em></span> and the ability to chop and change the component at will. The microservices style enables the language agnostic communications; therefore, the implementer has the freedom to write a component in Java, Groovy, or Scala or even in a non-JVM language such as C++. This architecture strongly favors JSON or XML over REST; however, there is nothing to stop a software shop from using SOAP and XML. Technically, microservices are some of the most exciting digital projects on the planet today; because of these investments, some businesses have clear distinct commercial advantages.</p><p class="calibre7">The cost of microservices is the networking complexity that includes payload sizes, monitoring (heart-beating), logging, and fault tolerance with redundancy management and service routing. There are ancillary costs that business managers and stakeholders should be aware of, namely time-to-marketing, training, information silos, and of course, change culture.</p><p class="calibre7">As with many movements, there is also a spectrum of effort, ability, and feasibility. A business may not necessarily have to give up on the monolith architecture completely, especially if scalability and high availability are not a high priority. There is certainly a route for the componentized services architecture for the majority of the digital business, which takes the best of the monolith—transactions, persistence, and configuration—and radically<a id="id1141" class="calibre1"/> employs as much of the styles of the <a id="id1142" class="calibre1"/>microservices as possible. Therefore, an embedded server dedicated for order management should not have code that is relevant to the payment processing in it. Rather, the order management component should invoke the payment processing component externally. Let's have a look at the following figure:</p><div class="mediaobject"><img src="../Images/image00432.jpeg" alt="Microservices" class="calibre10"/><div class="caption"><p class="calibre24">An evolution of a Java EE monolith to a microservices architecture</p></div></div><p class="calibre11"> </p><p class="calibre7">The<a id="id1143" class="calibre1"/> preceding illustration shows a decomposition <a id="id1144" class="calibre1"/>of the standard Java EE web architecture into a hybrid component architecture and then an evolution to a full microservice.</p><p class="calibre7">There are many ways to go from the request and then back to the response. In addition to where do we go as a team in order to get there? We must ask ourselves the key questions: how do we get there? Why do we want to get there?</p></div></div>
<div class="book" title="To be full stack or not" id="aid-3279U1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec96" class="calibre1"/>To be full stack or not</h1></div></div></div><p class="calibre7">Is it important to be known as a full stack developer? The consultant's typical answer is that it always <a id="id1145" class="calibre1"/>depends on the context. Some cynics might say that the term full stack is a loaded marketing term, but then these same people may also suggest that digital is likewise. Obviously, there is more meaning to the term than the thoughts that are recurring through some poor recruitment consultant's brain. There is a lot to be desired for large organizations that claim and advertise that they want to recruit only full stack developers. Are they cutting corners? Or are they genuinely interested in getting the best programming talent?</p><p class="calibre7">That said, from the discussion in this appendix, it is important to know the architecture of a project to a certain degree. For a couple of decades already, it has been impossible to be a jack of all trades in the software business and therefore, an engineer will specialize in a certain environment, field, role, or system. It is no longer possible to live completely closeted in an underground silo and resolutely say, <span class="strong"><em class="calibre9">all I want to know is Java on the server side because it is the only skill that I care about and it will always be that way</em></span>. Decent professional engineers must be sympathetic to the other staff members including front-end developers, back-end developers, interface and UX designers, testers, stakeholders, and management. Everyone has an ultimate stakeholder and therefore they share the ultimate responsibility with accountability. Whether this means full stack or not depends largely on your attitude towards working life and knowing about and respecting the modern web architecture around you.</p></div></body></html>