- en: Reactive Web Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have created the whole project infrastructure to consume the Twitter
    stream. We have created an application which stores the tracked hashtags.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use the Spring Reactive Web Client and
    make HTTP calls using the reactive paradigm, which is one of the most anticipated
    features of Spring 5.0\. We will call the Twitter REST APIs asynchronously and
    use the Project Reactor to provide an elegant way to work with streams.
  prefs: []
  type: TYPE_NORMAL
- en: We will be introduced to Spring Messaging for the RabbitMQ. We will interact
    with the RabbitMQ broker using the Spring Messaging API and see how Spring helps
    developers use the high-level abstractions for that.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we will wrap up the application and create a docker
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive web clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Messaging for RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ Docker usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Actuator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Twitter Gathering project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to create Spring Boot projects with the amazing Spring Initializr.
    In this chapter, we will create a project in a different way, to show you an alternative
    way of creating a Spring Boot project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `tweet-gathering` folder, in any directory. We can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can access the folder created previously and copy the `pom.xml` file
    located at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml).
  prefs: []
  type: TYPE_NORMAL
- en: Open the `pom.xml` on IDE.
  prefs: []
  type: TYPE_NORMAL
- en: There are some interesting dependencies here.  The `jackson-module-kotlin` helps
    to work with JSON in Kotlin language. Another interesting dependency is `kotlin-stdlib`,
    which provides the Kotlin standard libraries in our classpath.
  prefs: []
  type: TYPE_NORMAL
- en: In the plugin sections, the most important plugin is the `kotlin-maven-plugin`,
    which permits and configures the build for our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create a folder structure to start the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project structure follows the maven suggested pattern. We will code the
    project in the Kotlin language, then we will create a `kotlin` folder to store
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We made that configuration on the `pom.xml` created before, so it will work
    fine. Let''s take a look at the correct folder structure for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/438c8a02-e527-43ec-ad1c-c769881b21b2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the base package is the `springfive.twittergathering` package.
    Then, we will start to create sub-packages in this package as soon.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our infrastructure for the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code can be found at GitHub:  [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering.](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering)
  prefs: []
  type: TYPE_NORMAL
- en: Starting the RabbitMQ server with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Docker to spin up the RabbitMQ server. We do not want to install
    the server on our developer machines as it can create library conflicts and a
    lot of files. Let's understand how to start RabbitMQ in a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do that in the next couple of sections.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling the RabbitMQ image from Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to pull the RabbitMQ image from Docker Hub. We will use the image from
    the official repository as it is more safe and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the image, we need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the download to end and then we can move forward to the next section.
    In the next section, we will learn how to set up the RabbitMQ server.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the RabbitMQ server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start the RabbitMQ server, we will run the Docker command. There are some
    considerations which we need to pay attention to; we will run this container on
    the Twitter Docker network created previously, but we will expose some ports on
    the host, as it makes it easier to interact with the broker.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will use the management image because it provides a page which enables
    us to manage and see the RabbitMQ information on something similar to a control
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a few seconds so that RabbitMQ establishes the connections and then
    we can connect to the management page. To do that, go to `http://localhost:15672`
    and log on to the system. The default user is guest, and the password is `guest`
    as well. The control panel looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1d84684-2304-4d27-baec-65b63d1ff099.png)'
  prefs: []
  type: TYPE_IMG
- en: There is a lot of interesting information on the panel, but for now, we are
    going to explore the channels and some interesting parts.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome. Our RabbitMQ server is up and running. We will use the infrastructure
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Messaging AMQP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project supports the AMQP-based messaging solutions. There is a high-level
    API to interact with desired brokers. These interactions can send and receive
    messages from a broker.
  prefs: []
  type: TYPE_NORMAL
- en: Like in the other Spring projects, these facilities are provided by the *template*
    classes, which expose the core features provided by the broker and implemented
    by the Spring Module.
  prefs: []
  type: TYPE_NORMAL
- en: This project has two parts: `spring-amqp` is the base abstraction, and `spring-rabbit`
    is the RabbitMQ implementation for RabbitMQ. We will use `spring-rabbit` because
    we are using the RabbitMQ broker.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring AMQP in our pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the `spring-amqp` jars to our project. `spring-amqp` has a starter
    dependency which configures some common things for us, such as `ConnectionFactory`
    and `RabbitTemplate`, so we will use that. To add this dependency, we will configure
    our `pom.xml` follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to configure the connections; we will use the `application.yaml`
    file because we are using the starter. In the next section, we will do the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Spring Application and RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have configured the `spring-amqp` dependencies in our project. Now, it is
    time to configure the RabbitMQ connections properly. We will use the `RabbitMQTemplate`
    to send messages to the broker; this has some converters which help us convert
    our domain models into JSON and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure our RabbitMQ connections. The configurations should be in
    the `application.yaml` file and should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, some Spring configurations are quite similar to others, the same
    style, and the node in `yaml` is the name of the technology followed by a couple
    of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the default credentials for the RabbitMQ. The host and port are
    related to the RabbitMQ Broker address. The configuration is quite simple but
    does a lot of things for us such as `ConnectionFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RabbitMQ exchanges, queues, and bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are doing some interesting things with RabbitMQ. We configured connections
    successfully. There are some other things that we have not done yet, such as configuring
    the exchanges, queue, and bindings, but before we do that, let's understand a
    little bit more about these terms.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exchanges are RabbitMQ entities where the messages are sent. We can make an
    analogy with a river where the water is flowing; the river is the course of the
    messages. There are four different kinds of exchanges which we will understand
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Direct exchanges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The direct exchanges allow for route messages based on the routing key. The
    name is self-explanatory, it permits to send the messages directly to the specified
    customer, who is the one listening to the exchange. Remember, it uses the routing
    key as the argument to route the message to the customers.
  prefs: []
  type: TYPE_NORMAL
- en: Fanout exchanges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fanout exchanges route the messages for all the queues bound independently
    of the routing key. All the bound queues will receive the message sent to fanout
    exchanges. They can be used to have the topic behavior or distributed listings.
  prefs: []
  type: TYPE_NORMAL
- en: Topic exchanges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic exchanges are similar to direct exchanges, but topic exchanges enable
    us to use pattern matching as compared to the direct exchanges, which permit only
    the exact routing key. We will use this exchange in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Header exchanges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header exchanges are self-explanatory, the behavior is like the topic exchange,
    but instead of using the routing key, it uses the header attributes to match the
    correct queue.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues are the buffer where the exchanges will write the messages respecting
    the routing key. Queues are the place where consumers get the messages which are
    published to exchanges. Messages are routed to queues depending on the exchange
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binding can be thought of as a link between exchanges and queues. We can say
    that it is a kind of traffic cop which instructs the messages where they should
    be redirected based on the configuration, in this case, links.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring exchanges, queues, and bindings on Spring AMQP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring AMQP project has abstractions for all the RabbitMQ entities listed
    previously, and we need to configure it to interact with the broker. As we did
    in other projects, we need a `@Configuration` class, which will declare the beans
    for the Spring container.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring exchanges, queues, and bindings in yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to configure the entity names to instruct the framework to connect with
    the broker entities. We will use the `application.yaml` file to store these names,
    since it is easier to maintain and is the correct way to store application infrastructure
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The section with the entity names should look like this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The properties are self-explanatory, the `exchange` node has the name of the
    exchange, the `queue` node has the queue name, and finally, the `routing_key`
    node has the routing argument.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome. The properties are configured, and now we will create our `@Configuration`
    class. Let's do that in the next section. We are almost ready to interact with
    the RabbitMQ broker.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Spring beans for RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create our configuration class. The class is pretty simple and as
    we will see with the Spring abstraction, they are easy to understand too, especially
    because the class names allude to the RabbitMQ entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are interesting things to pay attention to here. In the `RabbitMQConfiguration`
    constructor, we injected the values configured in the `application.yaml` file
    to name the entities. After that, we started to configure the Spring beans for
    the container to allow it to inject them into the Spring-managed classes. The
    key point here is that if they do not exist in the RabbitMQ broker, Spring will
    create them. Thanks, Spring, we appreciate that and love how helpful that is.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the DSL to declare `Binding`, it makes the developer's life easier
    and prevents errors in the code.
  prefs: []
  type: TYPE_NORMAL
- en: On the last part of the class, we declared the `Jackson2JsonMessageConverter`.
    These converters are used to convert the domain models in JSON and vice versa.
    It enables us to receive the domain object on Listener instead of an array of
    bytes or strings. The same behavior can be used in the `Producers`, we are able
    to send the domain object instead of JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We need to supply the `ObjectMapper` to `Jackson2JsonMessageConverter`, and
    we have used the Kotlin module because of the way Kotlin handles data classes,
    which do not have no-args constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent job! Our infrastructure is fully configured. Let's code the producers
    and consumers right now!
  prefs: []
  type: TYPE_NORMAL
- en: Consuming messages with Spring Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring AMQP provides the `@RabbitListener` annotation; it will configure the
    subscriber for the desired queue, it removes a lot of infrastructure code, such
    as connect to `RabbitListenerConnectionFactory`, and creates a consumer programmatically.
    It makes the creation of queue consumers really easy.
  prefs: []
  type: TYPE_NORMAL
- en: The `spring-boot-starter-amqp` provides some automatic configurations for us.
    When we use this module, Spring will automatically create a `RabbitListenerConnectionFactory` for
    us and configure the Spring converters to convert JSON to domain classes automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty simple. Spring AMQP really provides a super high-level abstraction for
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example which will be used in our application soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The full source code can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt.](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt)'
  prefs: []
  type: TYPE_NORMAL
- en: A piece of cake. The code is really easy to understand and it makes it possible
    to pay attention only to the business rules. The infrastructure is not a good
    thing to maintain because this does not bring real value to the business, as it
    is only a piece of technology. Spring tries to abstract the whole infrastructure
    code to help developers write business code. It is a real asset provided by the
    Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks, Spring Team.
  prefs: []
  type: TYPE_NORMAL
- en: Producing messages with Spring Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `spring-amqp` module provides a `RabbitTemplate` class, which abstracts
    high-level RabbitMQ driver classes. It improves the developer performance and
    makes the application void of bugs because the Spring modules are a very well-tested
    set of codes. We will use the `convertAndSend()` function which permits to pass exchange,
    the routing key, and the message object as parameters. Remember this function
    uses Spring converters to convert our model class into a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of overloaded functions for `convertAndSend()`, and depending
    on the use case, others could be more appropriate. We will use the simple one
    as we saw before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the piece of code which sends the message to the broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Good. The first parameter is the `Exchange` name, and the second is the `RoutingKey`.
    Finally, we have the message object, which will be converted into a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the code in action soon.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Twitter in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will enable the use of Twitter APIs on our Twitter Gathering
    application. This application should get Tweets based on the query specified by
    the user. This query was registered on the previous microservice that we created
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When the user calls the API to register `TrackedHashTag`, the microservice will
    store the `TrackedHashTag` on the Redis database and send the message through
    the RabbitMQ. Then, this project will start to gather Tweets based on that. This
    is the data flow. In the next chapter, we will do a reactive stream and dispatch
    Tweets through our Reactive API. It will be amazing.
  prefs: []
  type: TYPE_NORMAL
- en: However, for now, we need to configure the Twitter credentials; we will do that
    using Spring beans – let's implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Producing Twitter credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the `@Configuration` class to provide our Twitter configuration
    objects. The `@Configuration` class is really good to provide infrastructure beans,
    if we do not have starter projects for the required module.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will use the `application.yaml` file to store the Twitter credentials.
    This kind of configuration should not be kept in the source code repository because
    it is sensitive data and should not be shared with others. Then, the Spring Framework
    enables us to declare properties in the `yaml` file and configures the environment
    variables to fill these properties at runtime. It is an excellent way to keep
    sensitive data out of the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Twitter credentials in application.yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start configuring the Twitter API in our application, we must provide the
    credentials. We will use the `yaml` file for this. Let''s add credentials in our
    `application.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Easy peasy. The properties have been declared and then we used the `$` to instruct
    the Spring Framework that this value will be received as an environment variable.
    Remember, we configured the Twitter account in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Modelling objects to represent Twitter settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must create abstractions and an amazing data model for our applications.
    This will create some models which make the developer's life easier to understand
    and code. Let's create our Twitter settings models.
  prefs: []
  type: TYPE_NORMAL
- en: Twittertoken
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class represents the application token previously configured in Twitter.
    The token can be used for the application authentication only. Our model should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I love the Kotlin way to declare data classes—totally immutable and without
    boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: TwitterAppSettings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TwitterAppSettings` represents the consumer key and consumer secret. It is
    a kind of identity for our application, from Twitter''s perspective. Our model
    is pretty simple and must look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Good job, our models are ready. It is time to produce the objects for the Spring
    Container. We will do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Twitter credentials for the Spring container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s produce our Twitter configuration objects. As a pattern we have been
    using, we will use the `@Configuration` class for that. The class should be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Pretty simple and a Spring way to declare beans. We are improving how we use
    Spring step by step. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are done with Twitter configurations. We will consume the Twitter API
    using the WebClient from the Spring WebFlux, which supports the reactive programming
    paradigm. Let's understand something before we run the code.
  prefs: []
  type: TYPE_NORMAL
- en: Spring reactive web clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a pretty new feature which was added in Spring Framework 5\. It enables
    us to interact with HTTP services, using the reactive paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: It is not a replacement for a `RestTemplate` provided by Spring, however, it
    is an addition to working with reactive applications. Do not worry, the `RestTemplate`
    is an excellent and tested implementation for interaction with HTTP services in
    traditional applications.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `WebClient` implementation supports the `text/event-stream` mime type
    which can enable us to consume server events.
  prefs: []
  type: TYPE_NORMAL
- en: Producing WebClient in a Spring Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to call the Twitter APIs, we want to create an instance of `WebClient`
    in a Spring way. It means we are looking for a way to inject the instance, using
    the Dependency Injection Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we can use the `@Configuration` annotation and create a `WebClient`
    instance, using the `@Bean` annotation to declare the bean for the Spring container.
    Let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of known annotations in this class; this is a pretty standard
    way to declare bean instances in a Spring way. It makes it possible to inject
    an instance of `WebClient` in other Spring-managed classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models to gather Tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to consume the Twitter APIs asynchronously and reactively, then we
    should create the API client. Before we code the client, we need to create our
    classes for modeling, according to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not need all Tweets'' attributes. We expect the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createdAt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will model our class based on the attributes listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the user attribute. This attribute is a JSON attribute, and
    we will create a separated class for that. The class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have used the Kotlin `data class,` it fits our use case well, and we want
    to use that as a data container. Also, we need to put in `@JsonIgnoreProperties(ignoreUnknown
    = true)` because this annotation instructs the Spring converters to ignore the
    attribute when it is missing in the JSON response. That is the important part
    of this portion of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created the `TwitterUser` class, which represents the user who created
    the Tweet. Now, we will create the `Tweet` class which represents the Tweet. Let''s
    create our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are some common things for us and one that's new. The `@JsonProperty`
    permits developers to customize the attribute name on the class which has a different
    attribute name in JSON; this is common for Java developers because they usually
    use *CamelCase* as a way to name attributes, and in JSON notation, people usually
    use *SnakeCase*. This annotation can help us to solve this mismatch between the
    programming language and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find a more detailed explanation of snake case here: [https://en.wikipedia.org/wiki/Snake_case](https://en.wikipedia.org/wiki/Snake_case).
    Also, we can find a full explanation of camel case here: [https://en.wikipedia.org/wiki/Camel_case](https://en.wikipedia.org/wiki/Camel_case).'
  prefs: []
  type: TYPE_NORMAL
- en: Good. Our API objects are ready. With these objects, we are enabled to interact
    with the APIs. We will create a service to collect the Tweets. We will do that
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with Twitter APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our objects ready, we need to create a class to help us handle the Twitter
    authentication. We will use the Twitter Application Only Auth authentication model.
    This kind of authentication should be used for backend applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application using this kind of authentication can:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull user timelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access friends and followers of any account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access lists and resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search in Tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve any user information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the application is a read-only Twitter API consumer.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Twitter documentation to understand this kind of authentication
    in detail. The documentation can be found here: [https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request.](https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request)
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow the Twitter documentation to authorize our request, which is
    a kind of cooking recipe, so we must follow all the steps. The final class should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is a recipe. The function, `buildAuthHeader`, will create the authorization
    header using the rules to authorize the request. We have signed some request headers
    combined with a request body. Moreover, replace the template values with our Twitter
    credentials objects.
  prefs: []
  type: TYPE_NORMAL
- en: Some words about server-sent events (SSE)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-sent events (SSE) is a technology where the server sends events to the
    client, instead of the client polling the server to check the information availability.
    The message flow will not get interrupted until the client or server closes the
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to understand here is the direction of the information
    flow. The server decides when to send data to a client.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to handle resource load and bandwidth usage. The client
    will receive the chunk of data instead to apply load on the server through the
    polling techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter has a stream API and the Spring Framework WebClient supports SSE. It
    is time to consume the Twitter stream.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gather service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `TweetGatherService` will be responsible for interacting with Twitter APIs
    and collecting the request tweets according to the requested hashtag. The service
    will be a Spring bean with some inject attributes. The class should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There are some important points here. The first is the function declaration;
    take a look at `Flux<Tweet>`, it means the data can never get interrupted because
    it represents the N values. In our case, we will consume the Twitter stream until
    the client or server interrupts the data flow.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we configured the HTTP request body with our desired track to get
    events. After that, we configured the Accept HTTP header; it is essential to instruct
    the WebClient what kind of mime type it needs to consume.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have used our `Twitter.buildAuthHeader` function to configure the
    Twitter authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, we are ready to start to consume the Twitter API, and we only need
    to code the trigger to use that function. We will do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the Rabbit Queue and consuming the Twitter API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will consume the Twitter API, but when?
  prefs: []
  type: TYPE_NORMAL
- en: We need to start to get Tweets when the request for tracking the hashtags comes
    to our application. To reach that goal, we will implement the RabbitMQ Listener
    when the `TrackedHashTag` gets registered on our microservice. The application
    will send the message to the broker to start consuming the Twitter stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code and step by step understand the behaviors; the
    final code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Keep calm. We will cover the whole code. In the `@RabbitListener,` we configured
    the name of the queue we want to consume. The Spring AMQP module will configure
    our listener automatically for us and start to consume the desired queue. As we
    can see, we received the `TrackedHashTag` object; remember the converters on the
    previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction will start to consume the Twitter stream. The stream returns
    a flux and can have a lot of data events there. After the consumer, we want to
    filter the data on the flow. We want `Tweet` in which the `id`, `text`, and `createdAt`
    are not null.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we subscribe this stream and start to receive the data in the flow. Also,
    the `subscribes` function returns the disposable object which will be helpful
    in the next steps. We have created an anonymous function which will print the
    `Tweet` on the console and send the Tweet to the RabbitMQ queue, to be consumed
    in another microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the schedulers to stop the data flow and consume the data for
    10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Before you test the Twitter stream, we need to change the Tracked Hashtag Service
    to send the messages through the RabbitMQ. We will do that in the next sections.
    The changes are small ones and we will do them quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Tracked Hashtag Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the whole solution, we need to make some changes to the Tracked Hashtag
    Service project. The changes are simple and basic; configure the RabbitMQ connection
    and change the service to send the messages to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Spring Starter RabbitMQ dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did before in the Twitter Gathering project, we need to add `spring-boot-starter-amqp`
    to provide some auto-configuration for us. To do that, we need to add the following
    snippet to our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Right. Now, it is time to configure the RabbitMQ connections. We will do this
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the RabbitMQ connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the `application.yaml` to configure the RabbitMQ connections. Then,
    we need to create a couple of properties in it and the Spring AMQP module will
    use that provided configuration to start the connection factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is pretty simple to configure it. The final `yaml` file for Tracked Hashtag
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are two profiles in this yaml. Take a look at the different host for the
    RabbitMQ. In the default profile, we are able to connect the localhost because
    we exposed the RabbitMQ ports on the host. But on the Docker profile, we are not
    able to connect the localhost, we need to connect to the `rabbitmq` host, which
    is the host for the Twitter network.
  prefs: []
  type: TYPE_NORMAL
- en: Our RabbitMQ connection is ready to use. Let's try it in the next section. Let's
    go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating exchanges, queues, and bindings for the Twitter Hashtag Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's declare our RabbitMQ entities for the Tracked Hashtag usage. We will do
    that using the `@Configuration` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RabbitMQ connection should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Pretty straightforward. We declared one exchange, queue, and binding, as we
    did before.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the messages to the broker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most interesting part now. When we want to save the `TrackedHashTag`,
    we must send the pretty new entity to the RabbitMQ. This process will send the
    message, and then the Twitter Gathering microservice will start to consume the
    stream in ten seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change the `TrackedHashTagService` a little bit; the final version
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Awesome job. When the new entity comes, it will be sent to the broker. We have
    finished our changes on the Tracked Hashtag Service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are able to test the whole flow. Let's start to play and perceive
    the real power of our built application.
  prefs: []
  type: TYPE_NORMAL
- en: It's showtime!!!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the microservice's integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to test the whole solution. Before you start, we need to
    check the following infrastructure items:'
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the items are up and running, we can jump to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `docker ps` command, and the command should list the Redis and
    RabbitMQ containers in running mode.
  prefs: []
  type: TYPE_NORMAL
- en: Running Tracked Hashtag Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no special thing to run this application. It includes the infrastructure
    connections which are configured in the default profile in `application.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the main function present on the `TrackedHashTagApplication`. We can use
    the IDE or command line to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the console output; the output will be presented on the IDE or command
    line. We want to find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/693c333b-d14e-40fb-bfdb-66a4297ee0f9.png)'
  prefs: []
  type: TYPE_IMG
- en: It means the first application is fully operational and we are able to run Twitter
    Gathering. Please keep the application running as it is required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run Twitter Gathering!!!
  prefs: []
  type: TYPE_NORMAL
- en: Running the Twitter Gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application is a little bit more complicated to run. We need to configure
    some environment variables for that. It is required because we do not want the
    Twitter application credentials in our repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is pretty simple to do in the IDE. To do that, we can configure the run
    configuration. Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Edit Configurations...like in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/07088397-9d6c-4b4c-b869-363fbf29531d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we are able to see the Environment variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0251ce5-b76a-4b51-ae10-fdef199f1dc2.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to click on **...**, as highlighted in the proceeding image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next screen will be shown and we can configure the Environment Variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e3e70570-87ff-4d8a-a157-da89622fc957.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to configure the following environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: consumer-key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: consumer-secret
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: access-token
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: access-token-secret
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These values should be filled with the Twitter Application Management values.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can run the application. Run it!!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should see the following lines in the console, which means the application
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ff9703d-2e38-4a23-aab0-57e5a83c7a9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome, our two microservices are running. Let's trigger the Twitter stream.
    We will do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to run the application, for example, with the maven Spring
    Boot goals or Java command line. If you prefer to run in the Java command line,
    keep in mind the `-D` argument to pass environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Testing stuff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are excited to test the full integration. We can use the `curl` tool to send
    request data to the Tracked Hashtag Service. We want to track the `"bitcoin"`
    from Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Check the HTTP status code; it should be HTTP status 200\. After that, we can
    check the console from the Twitter Gathering project, and there should be a lot
    of Tweets logged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the log, the log must have Tweets like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dce09e86-356a-46f0-8ad8-bb5d10c3a28b.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Great work guys, we have the full application integrated with RabbitMQ and the
    Twitter stream.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Actuator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot Actuator is a kind of helper when the application is running
    in production. The project provides built-in information of a deployed application.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices world, monitoring instances of applications are the key
    point to getting success. In these environments, there are usually many applications
    calling the other applications over the network protocols such as HTTP. The network
    is an unstable environment and sometimes it will fail; we need to track these
    incidents to make sure the application is up and fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot Actuator helps developers in these situations. The project exposes
    a couple of HTTP APIs with application information, such as the memory usage,
    CPU usage, application health check, and the infrastructure components of the
    application, such as a connection with databases and message brokers, as well.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important points is that the information is exposed over HTTP.
    It helps integrations with external monitor applications such as Nagios and Zabbix,
    for instance. There is no specific protocol for exposing this information.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add it to our project and try a couple of endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring Boot Actuator in our pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot Actuator is pretty simple to configure in our `pom.xml`. We extended
    the parent pom of Spring Boot, so it is not necessary to specify the version of
    the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure our new dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Awesome, really easy. Let's understand a little bit more before we test.
  prefs: []
  type: TYPE_NORMAL
- en: Actuator Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The projects have a lot of built-in endpoints and they will be up when the application
    started. Remember, we have used the starter project, which is the one that configures
    it automatically for us.
  prefs: []
  type: TYPE_NORMAL
- en: There are several endpoints for different requirements, and we will take a look
    at the most used in production microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '`/health`: The most known actuator endpoint; it shows the application''s health,
    and usually, there is a `status` attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/configprops`: Displays a collapse `@ConfigurationProperties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/env`: Exposes properties from the Spring `ConfigurableEnvironment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dump`: Shows the thread dump'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/info`: We can put some arbitrary information at this endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/metrics`: Metrics from the running application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mappings`: `@RequestMappings` endpoints from the current application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another important endpoint to show the application logs over the HTTP
    interface. The `/logfile` endpoint can help us visualize logfiles.
  prefs: []
  type: TYPE_NORMAL
- en: The list of endpoints created by the Spring Boot Actuator can be found at: [https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html).
  prefs: []
  type: TYPE_NORMAL
- en: Application custom information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one particular endpoint which we can use to expose custom information
    from our application. This information will be exposed to `/info` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure that, we can use the `application.yaml` file and put the desired
    information respecting the pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Thr desired properties must be preceded by the `info. *`. Then, we can test
    our first actuator endpoint and check our `/info` resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to access the `http://localhost:8081/info`. The information filled
    on `application.yaml` should be displayed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef882dee-d213-488f-83c9-81ff4119644b.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the properties are exposed from the HTTP endpoint. We can use
    that to put the application version, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Testing endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In version 2 of  Spring Boot, the Spring Actuator management endpoints are disabled
    by default, because these endpoints can have sensitive data of a running application.
    Then, we need to configure to enable these endpoints properly.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special point to pay attention to. If the application is exposed
    publicly, you should protect these endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enable our management endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, we enabled all the management endpoints, and
    then we can start to test some endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test some endpoints. First, we will test the metrics endpoints. This
    endpoint shows the metrics available for the running application. Go to `http://localhost:8081/actuator/metrics`
    and check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a5582e9-5f54-4a81-ba83-c62808f0787b.png)'
  prefs: []
  type: TYPE_IMG
- en: We are using port `8081` because we configured the property `server.port` in `application.yaml`.
    The port can be changed as you desire.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of metrics configured automatically for us. That endpoint exposes
    only the available metrics. To check the metric value, we need to use another
    endpoint. Let's check the value of the `http.server.request`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base endpoint to check the value is: `http://localhost:8081/actuator/metrics/{metricName}`.
    Then, we need to go to: `http://localhost:8081/actuator/metrics/http.server.requests`.
    The result should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d482622-a6d0-46e9-8d6c-a8100da65714.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the server received eight calls. Try to hit a few more times
    to see the metrics changing.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome job. Our microservice is ready for production. We have the docker image
    and endpoints for monitoring our services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned and put into practice a lot of Spring Advanced concepts,
    such as RabbitMQ integration.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a fully reactive WebClient and took advantage of the reactive
    paradigm; it enables resource computational optimization and increases performance
    for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have integrated two microservices through the RabbitMQ broker. This
    is an excellent solution to integrating applications because it decouples the
    applications and also permits you to scale the application horizontally really
    easily. Message-driven is one of the required characteristics to build a reactive
    application; it can be found at Reactive Manifesto ([https://www.reactivemanifesto.org/en](https://www.reactivemanifesto.org/en)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will improve our solution and create a new microservice
    to stream the filtered Tweets for our clients. We will use RabbitMQ one more time.
  prefs: []
  type: TYPE_NORMAL
