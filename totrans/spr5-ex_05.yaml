- en: Reactive Web Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式Web客户端
- en: Until now, we have created the whole project infrastructure to consume the Twitter
    stream. We have created an application which stores the tracked hashtags.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了整个项目基础设施以消费Twitter流。我们已经创建了一个存储跟踪标签的应用程序。
- en: In this chapter, we will learn how to use the Spring Reactive Web Client and
    make HTTP calls using the reactive paradigm, which is one of the most anticipated
    features of Spring 5.0\. We will call the Twitter REST APIs asynchronously and
    use the Project Reactor to provide an elegant way to work with streams.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Spring Reactive Web Client，并使用反应式范式进行HTTP调用，这是Spring 5.0最期待的功能之一。我们将异步调用Twitter
    REST API，并使用Project Reactor提供优雅的流式处理方式。
- en: We will be introduced to Spring Messaging for the RabbitMQ. We will interact
    with the RabbitMQ broker using the Spring Messaging API and see how Spring helps
    developers use the high-level abstractions for that.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍Spring Messaging for RabbitMQ。我们将使用Spring Messaging API与RabbitMQ代理进行交互，并了解Spring如何帮助开发者使用高级抽象。
- en: At the end of this chapter, we will wrap up the application and create a docker
    image.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将封装应用程序并创建一个Docker镜像。
- en: 'In this chapter, we will learn about:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Reactive web clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式Web客户端
- en: Spring Messaging for RabbitMQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Messaging for RabbitMQ
- en: RabbitMQ Docker usage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ Docker使用
- en: Spring Actuator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Actuator
- en: Creating the Twitter Gathering project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Twitter Gathering项目
- en: We learned how to create Spring Boot projects with the amazing Spring Initializr.
    In this chapter, we will create a project in a different way, to show you an alternative
    way of creating a Spring Boot project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用惊人的Spring Initializr创建Spring Boot项目。在本章中，我们将以不同的方式创建项目，以向您展示创建Spring
    Boot项目的另一种方法。
- en: 'Create the `tweet-gathering` folder, in any directory. We can use the following
    command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何目录中创建`tweet-gathering`文件夹。我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, we can access the folder created previously and copy the `pom.xml` file
    located at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以访问之前创建的文件夹，并复制位于GitHub上的`pom.xml`文件：[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml).
- en: Open the `pom.xml` on IDE.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE中打开`pom.xml`文件。
- en: There are some interesting dependencies here.  The `jackson-module-kotlin` helps
    to work with JSON in Kotlin language. Another interesting dependency is `kotlin-stdlib`,
    which provides the Kotlin standard libraries in our classpath.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的依赖项。`jackson-module-kotlin`帮助我们在Kotlin语言中处理JSON。另一个有趣的依赖项是`kotlin-stdlib`，它为我们提供了类路径中的Kotlin标准库。
- en: In the plugin sections, the most important plugin is the `kotlin-maven-plugin`,
    which permits and configures the build for our Kotlin code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件部分，最重要的插件是`kotlin-maven-plugin`，它允许并配置我们的Kotlin代码的构建。
- en: In the next section, we will create a folder structure to start the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建文件夹结构以开始编写代码。
- en: Let's do it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Project structure
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: The project structure follows the maven suggested pattern. We will code the
    project in the Kotlin language, then we will create a `kotlin` folder to store
    our code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构遵循maven建议的模式。我们将使用Kotlin语言编写项目代码，然后我们将创建一个`kotlin`文件夹来存储我们的代码。
- en: 'We made that configuration on the `pom.xml` created before, so it will work
    fine. Let''s take a look at the correct folder structure for the project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前创建的`pom.xml`文件上进行了配置，所以它将正常工作。让我们看看项目的正确文件夹结构：
- en: '![](img/438c8a02-e527-43ec-ad1c-c769881b21b2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/438c8a02-e527-43ec-ad1c-c769881b21b2.png)'
- en: As we can see, the base package is the `springfive.twittergathering` package.
    Then, we will start to create sub-packages in this package as soon.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，基本包是`springfive.twittergathering`包。然后，我们将尽快在这个包中创建子包。
- en: Let's create our infrastructure for the microservice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为微服务创建基础设施。
- en: The full source code can be found at GitHub:  [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering.](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering)
- en: Starting the RabbitMQ server with Docker
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker启动RabbitMQ服务器
- en: We can use Docker to spin up the RabbitMQ server. We do not want to install
    the server on our developer machines as it can create library conflicts and a
    lot of files. Let's understand how to start RabbitMQ in a Docker container.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Docker 启动 RabbitMQ 服务器。我们不想在我们的开发机器上安装服务器，因为它可能会创建库冲突和大量的文件。让我们了解如何在
    Docker 容器中启动 RabbitMQ。
- en: Let's do that in the next couple of sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中这样做。
- en: Pulling the RabbitMQ image from Docker Hub
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Docker Hub 拉取 RabbitMQ 镜像
- en: We need to pull the RabbitMQ image from Docker Hub. We will use the image from
    the official repository as it is more safe and reliable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 Docker Hub 拉取 RabbitMQ 镜像。我们将使用官方存储库中的镜像，因为它更安全、更可靠。
- en: 'To get the image, we need to use the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取图像，我们需要使用以下命令：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Wait for the download to end and then we can move forward to the next section.
    In the next section, we will learn how to set up the RabbitMQ server.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 等待下载完成，然后我们就可以继续到下一部分。在下一部分，我们将学习如何设置 RabbitMQ 服务器。
- en: Starting the RabbitMQ server
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 RabbitMQ 服务器
- en: To start the RabbitMQ server, we will run the Docker command. There are some
    considerations which we need to pay attention to; we will run this container on
    the Twitter Docker network created previously, but we will expose some ports on
    the host, as it makes it easier to interact with the broker.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 RabbitMQ 服务器，我们将运行 Docker 命令。有一些考虑事项我们需要注意；我们将在这个之前创建的 Twitter Docker 网络上运行这个容器，但我们将在主机上暴露一些端口，因为这使与代理交互变得更容易。
- en: Also, we will use the management image because it provides a page which enables
    us to manage and see the RabbitMQ information on something similar to a control
    panel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用管理镜像，因为它提供了一个页面，使我们能够管理并查看类似控制面板上的 RabbitMQ 信息。
- en: 'Let''s run:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Wait for a few seconds so that RabbitMQ establishes the connections and then
    we can connect to the management page. To do that, go to `http://localhost:15672`
    and log on to the system. The default user is guest, and the password is `guest`
    as well. The control panel looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟，以便 RabbitMQ 建立连接，然后我们可以连接到管理页面。为此，请访问 `http://localhost:15672` 并登录系统。默认用户是
    guest，密码也是 `guest`。控制面板看起来像这样：
- en: '![](img/a1d84684-2304-4d27-baec-65b63d1ff099.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1d84684-2304-4d27-baec-65b63d1ff099.png)'
- en: There is a lot of interesting information on the panel, but for now, we are
    going to explore the channels and some interesting parts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在面板上有很多有趣的信息，但到目前为止，我们将探索通道和一些有趣的部件。
- en: Awesome. Our RabbitMQ server is up and running. We will use the infrastructure
    soon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。我们的 RabbitMQ 服务器已经启动并运行。我们很快就会使用这个基础设施。
- en: Spring Messaging AMQP
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Messaging AMQP
- en: This project supports the AMQP-based messaging solutions. There is a high-level
    API to interact with desired brokers. These interactions can send and receive
    messages from a broker.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目支持基于 AMQP 的消息解决方案。有一个高级 API 可以与所需的代理进行交互。这些交互可以从代理发送和接收消息。
- en: Like in the other Spring projects, these facilities are provided by the *template*
    classes, which expose the core features provided by the broker and implemented
    by the Spring Module.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在其他 Spring 项目中一样，这些功能是由 *模板* 类提供的，它们公开了由代理提供并由 Spring 模块实现的核心理念。
- en: This project has two parts: `spring-amqp` is the base abstraction, and `spring-rabbit`
    is the RabbitMQ implementation for RabbitMQ. We will use `spring-rabbit` because
    we are using the RabbitMQ broker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目有两个部分：`spring-amqp` 是基础抽象，而 `spring-rabbit` 是 RabbitMQ 的实现。我们将使用 `spring-rabbit`，因为我们正在使用
    RabbitMQ 代理。
- en: Adding Spring AMQP in our pom.xml
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的 pom.xml 中添加 Spring AMQP
- en: 'Let''s add the `spring-amqp` jars to our project. `spring-amqp` has a starter
    dependency which configures some common things for us, such as `ConnectionFactory`
    and `RabbitTemplate`, so we will use that. To add this dependency, we will configure
    our `pom.xml` follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把 `spring-amqp` jar 包添加到我们的项目中。`spring-amqp` 有一个启动依赖，它会为我们配置一些常见的东西，比如 `ConnectionFactory`
    和 `RabbitTemplate`，所以我们会使用它。为了添加这个依赖，我们将按照以下方式配置我们的 `pom.xml`：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The next step is to configure the connections; we will use the `application.yaml`
    file because we are using the starter. In the next section, we will do the configuration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置连接；我们将使用 `application.yaml` 文件，因为我们正在使用启动器。在下一节中，我们将进行配置。
- en: Integrating Spring Application and RabbitMQ
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Spring 应用程序和 RabbitMQ
- en: We have configured the `spring-amqp` dependencies in our project. Now, it is
    time to configure the RabbitMQ connections properly. We will use the `RabbitMQTemplate`
    to send messages to the broker; this has some converters which help us convert
    our domain models into JSON and vice versa.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的项目中配置了`spring-amqp`依赖项。现在，是时候正确配置RabbitMQ连接了。我们将使用`RabbitMQTemplate`向代理发送消息；这有一些转换器，帮助我们将我们的领域模型转换为JSON，反之亦然。
- en: 'Let''s configure our RabbitMQ connections. The configurations should be in
    the `application.yaml` file and should look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置我们的RabbitMQ连接。配置应该在`application.yaml`文件中，并且应该看起来像这样：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, some Spring configurations are quite similar to others, the same
    style, and the node in `yaml` is the name of the technology followed by a couple
    of attributes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一些Spring配置与其他配置相当相似，相同的风格，`yaml`中的节点是技术的名称后面跟着几个属性。
- en: We are using the default credentials for the RabbitMQ. The host and port are
    related to the RabbitMQ Broker address. The configuration is quite simple but
    does a lot of things for us such as `ConnectionFactory`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用RabbitMQ的默认凭据。主机和端口与RabbitMQ代理地址相关。配置很简单，但为我们做了很多事情，例如`ConnectionFactory`。
- en: Understanding RabbitMQ exchanges, queues, and bindings
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解RabbitMQ交换、队列和绑定
- en: We are doing some interesting things with RabbitMQ. We configured connections
    successfully. There are some other things that we have not done yet, such as configuring
    the exchanges, queue, and bindings, but before we do that, let's understand a
    little bit more about these terms.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用RabbitMQ做一些有趣的事情。我们已经成功配置了连接。还有一些其他的事情我们还没有做，比如配置交换、队列和绑定，但在我们做这些之前，让我们更深入地了解一下这些术语。
- en: Exchanges
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换
- en: Exchanges are RabbitMQ entities where the messages are sent. We can make an
    analogy with a river where the water is flowing; the river is the course of the
    messages. There are four different kinds of exchanges which we will understand
    in the following sections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 交换是RabbitMQ实体，消息被发送到那里。我们可以将其比作一条河流，水流就是消息的流程。在接下来的几节中，我们将了解四种不同类型的交换。
- en: Direct exchanges
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接交换
- en: The direct exchanges allow for route messages based on the routing key. The
    name is self-explanatory, it permits to send the messages directly to the specified
    customer, who is the one listening to the exchange. Remember, it uses the routing
    key as the argument to route the message to the customers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 直接交换允许基于路由键发送路由消息。这个名字本身就说明了问题，它允许将消息直接发送到指定的客户，即正在监听交换的客户。记住，它使用路由键作为参数来将消息路由到客户。
- en: Fanout exchanges
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播交换
- en: The fanout exchanges route the messages for all the queues bound independently
    of the routing key. All the bound queues will receive the message sent to fanout
    exchanges. They can be used to have the topic behavior or distributed listings.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 广播交换将消息路由到所有独立绑定的队列，而不考虑路由键。所有绑定的队列都将接收到发送到广播交换的消息。它们可以用作具有主题行为或分布式列表。
- en: Topic exchanges
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题交换
- en: The topic exchanges are similar to direct exchanges, but topic exchanges enable
    us to use pattern matching as compared to the direct exchanges, which permit only
    the exact routing key. We will use this exchange in our project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主题交换与直接交换类似，但主题交换使我们能够使用模式匹配，而直接交换只能允许精确的路由键。我们将在我们的项目中使用这种交换。
- en: Header exchanges
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部交换
- en: Header exchanges are self-explanatory, the behavior is like the topic exchange,
    but instead of using the routing key, it uses the header attributes to match the
    correct queue.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 头部交换是自解释的，其行为类似于主题交换，但不是使用路由键，而是使用头部属性来匹配正确的队列。
- en: Queues
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Queues are the buffer where the exchanges will write the messages respecting
    the routing key. Queues are the place where consumers get the messages which are
    published to exchanges. Messages are routed to queues depending on the exchange
    type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是交换将消息写入的地方，它根据路由键来路由消息。队列是消费者获取已发布到交换的消息的地方。消息根据交换类型被路由到队列。
- en: Bindings
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: Binding can be thought of as a link between exchanges and queues. We can say
    that it is a kind of traffic cop which instructs the messages where they should
    be redirected based on the configuration, in this case, links.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定可以被视为交换和队列之间的链接。我们可以将其视为一种交通警察，根据配置指导消息应该被重定向到何处，在这种情况下，链接。
- en: Configuring exchanges, queues, and bindings on Spring AMQP
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring AMQP上配置交换、队列和绑定
- en: The Spring AMQP project has abstractions for all the RabbitMQ entities listed
    previously, and we need to configure it to interact with the broker. As we did
    in other projects, we need a `@Configuration` class, which will declare the beans
    for the Spring container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AMQP 项目为之前列出的所有 RabbitMQ 实体提供了抽象，我们需要配置它以与代理交互。正如我们在其他项目中做的那样，我们需要一个
    `@Configuration` 类，它将为 Spring 容器声明豆。
- en: Declaring exchanges, queues, and bindings in yaml
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 yaml 中声明交换、队列和绑定
- en: We need to configure the entity names to instruct the framework to connect with
    the broker entities. We will use the `application.yaml` file to store these names,
    since it is easier to maintain and is the correct way to store application infrastructure
    data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置实体名称以指导框架连接到代理实体。我们将使用 `application.yaml` 文件来存储这些名称，因为它更容易维护，并且是存储应用程序基础设施数据的正确方式。
- en: 'The section with the entity names should look like this snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实体名称的部分应如下所示：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The properties are self-explanatory, the `exchange` node has the name of the
    exchange, the `queue` node has the queue name, and finally, the `routing_key`
    node has the routing argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是自解释的，`exchange` 节点具有交换机的名称，`queue` 节点具有队列名称，最后，`routing_key` 节点具有路由参数。
- en: Awesome. The properties are configured, and now we will create our `@Configuration`
    class. Let's do that in the next section. We are almost ready to interact with
    the RabbitMQ broker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。属性已配置，现在我们将创建我们的 `@Configuration` 类。让我们在下一节中这样做。我们几乎准备好与 RabbitMQ 代理交互了。
- en: Declaring Spring beans for RabbitMQ
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明 RabbitMQ 的 Spring 豆
- en: Now, let's create our configuration class. The class is pretty simple and as
    we will see with the Spring abstraction, they are easy to understand too, especially
    because the class names allude to the RabbitMQ entities.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的配置类。这个类相当简单，正如我们将通过 Spring 抽象看到的那样，它们也容易理解，特别是因为类名暗示了 RabbitMQ 实体。
- en: 'Let''s create our class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的类：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are interesting things to pay attention to here. In the `RabbitMQConfiguration`
    constructor, we injected the values configured in the `application.yaml` file
    to name the entities. After that, we started to configure the Spring beans for
    the container to allow it to inject them into the Spring-managed classes. The
    key point here is that if they do not exist in the RabbitMQ broker, Spring will
    create them. Thanks, Spring, we appreciate that and love how helpful that is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情需要注意。在 `RabbitMQConfiguration` 构造函数中，我们注入了在 `application.yaml` 文件中配置的值来命名实体。之后，我们开始为容器配置
    Spring 豆，以便它可以将其注入到 Spring 管理的类中。这里的关键点是，如果它们在 RabbitMQ 代理中不存在，Spring 将创建它们。谢谢，Spring，我们感激并喜欢它的帮助。
- en: We can see the DSL to declare `Binding`, it makes the developer's life easier
    and prevents errors in the code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到声明 `Binding` 的 DSL，它使开发者的生活变得更轻松，并防止代码中的错误。
- en: On the last part of the class, we declared the `Jackson2JsonMessageConverter`.
    These converters are used to convert the domain models in JSON and vice versa.
    It enables us to receive the domain object on Listener instead of an array of
    bytes or strings. The same behavior can be used in the `Producers`, we are able
    to send the domain object instead of JSON.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的最后部分，我们声明了 `Jackson2JsonMessageConverter`。这些转换器用于将域模型转换为 JSON 以及相反。它使我们能够在监听器上接收域对象而不是字节数组或字符串。同样的行为也可以用在
    `Producers` 中，我们能够发送域对象而不是 JSON。
- en: We need to supply the `ObjectMapper` to `Jackson2JsonMessageConverter`, and
    we have used the Kotlin module because of the way Kotlin handles data classes,
    which do not have no-args constructors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 `Jackson2JsonMessageConverter` 提供一个 `ObjectMapper`，我们使用了 Kotlin 模块，因为
    Kotlin 处理数据类的方式，这些数据类没有无参构造函数。
- en: Excellent job! Our infrastructure is fully configured. Let's code the producers
    and consumers right now!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们的基础设施已完全配置。现在让我们编写生产者和消费者代码！
- en: Consuming messages with Spring Messaging
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 消息传递消费消息
- en: Spring AMQP provides the `@RabbitListener` annotation; it will configure the
    subscriber for the desired queue, it removes a lot of infrastructure code, such
    as connect to `RabbitListenerConnectionFactory`, and creates a consumer programmatically.
    It makes the creation of queue consumers really easy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AMQP 提供了 `@RabbitListener` 注解；它将为所需的队列配置订阅者，它移除了很多基础设施代码，例如连接到 `RabbitListenerConnectionFactory`，并程序化地创建消费者。这使得创建队列消费者变得非常简单。
- en: The `spring-boot-starter-amqp` provides some automatic configurations for us.
    When we use this module, Spring will automatically create a `RabbitListenerConnectionFactory` for
    us and configure the Spring converters to convert JSON to domain classes automatically.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-amqp` 为我们提供了一些自动配置。当我们使用这个模块时，Spring 将自动为我们创建一个 `RabbitListenerConnectionFactory`
    并配置 Spring 转换器以自动将 JSON 转换为领域类。'
- en: Pretty simple. Spring AMQP really provides a super high-level abstraction for
    developers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。Spring AMQP 真的为开发者提供了一个超级高级的抽象。
- en: 'Let''s see an example which will be used in our application soon:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看即将在我们的应用程序中使用的示例：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The full source code can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt.](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt)
- en: A piece of cake. The code is really easy to understand and it makes it possible
    to pay attention only to the business rules. The infrastructure is not a good
    thing to maintain because this does not bring real value to the business, as it
    is only a piece of technology. Spring tries to abstract the whole infrastructure
    code to help developers write business code. It is a real asset provided by the
    Spring Framework.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 小菜一碟。代码非常容易理解，它使得我们只需关注业务规则。基础设施并不是一件好事，因为它并不为业务带来真正的价值，它只是一项技术。Spring 尝试抽象整个基础设施代码，以帮助开发者编写业务代码。这是
    Spring 框架提供的一项真正有价值的资产。
- en: Thanks, Spring Team.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢，Spring 团队。
- en: Producing messages with Spring Messaging
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 消息传递产生消息
- en: The `spring-amqp` module provides a `RabbitTemplate` class, which abstracts
    high-level RabbitMQ driver classes. It improves the developer performance and
    makes the application void of bugs because the Spring modules are a very well-tested
    set of codes. We will use the `convertAndSend()` function which permits to pass exchange,
    the routing key, and the message object as parameters. Remember this function
    uses Spring converters to convert our model class into a JSON string.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-amqp` 模块提供了一个 `RabbitTemplate` 类，它抽象了高级 RabbitMQ 驱动类。它提高了开发者的性能，并使应用程序无bug，因为
    Spring 模块是一组经过充分测试的代码。我们将使用 `convertAndSend()` 函数，该函数允许传递交换机、路由键和消息对象作为参数。请记住，这个函数使用
    Spring 转换器将我们的模型类转换为 JSON 字符串。'
- en: There are a lot of overloaded functions for `convertAndSend()`, and depending
    on the use case, others could be more appropriate. We will use the simple one
    as we saw before.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`convertAndSend()` 方法有很多重载版本，根据具体的使用场景，其他版本可能更合适。我们将使用之前看到的那种简单版本。'
- en: 'Let''s see the piece of code which sends the message to the broker:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看发送消息到代理的消息代码片段：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Good. The first parameter is the `Exchange` name, and the second is the `RoutingKey`.
    Finally, we have the message object, which will be converted into a JSON string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。第一个参数是 `Exchange` 名称，第二个是 `RoutingKey`。最后，我们有消息对象，它将被转换为 JSON 字符串。
- en: We will see the code in action soon.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到代码的实际应用。
- en: Enabling Twitter in our application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中启用 Twitter
- en: In this section, we will enable the use of Twitter APIs on our Twitter Gathering
    application. This application should get Tweets based on the query specified by
    the user. This query was registered on the previous microservice that we created
    in the previous chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将启用 Twitter Gathering 应用程序上 Twitter API 的使用。这个应用程序应该根据用户指定的查询获取推文。这个查询是在上一章中我们创建的先前微服务上注册的。
- en: When the user calls the API to register `TrackedHashTag`, the microservice will
    store the `TrackedHashTag` on the Redis database and send the message through
    the RabbitMQ. Then, this project will start to gather Tweets based on that. This
    is the data flow. In the next chapter, we will do a reactive stream and dispatch
    Tweets through our Reactive API. It will be amazing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调用 API 注册 `TrackedHashTag` 时，微服务将 `TrackedHashTag` 存储在 Redis 数据库中，并通过 RabbitMQ
    发送消息。然后，这个项目将开始根据这些信息收集推文。这是数据流。在下一章中，我们将进行反应式流，并通过我们的反应式 API 分发推文。这将非常令人兴奋。
- en: However, for now, we need to configure the Twitter credentials; we will do that
    using Spring beans – let's implement it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前，我们需要配置Twitter凭证；我们将使用Spring bean来完成这项工作——让我们来实现它。
- en: Producing Twitter credentials
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Twitter凭证
- en: We will use the `@Configuration` class to provide our Twitter configuration
    objects. The `@Configuration` class is really good to provide infrastructure beans,
    if we do not have starter projects for the required module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`@Configuration`类来提供我们的Twitter配置对象。`@Configuration`类非常适合提供基础设施bean，如果我们没有所需模块的启动项目。
- en: Also, we will use the `application.yaml` file to store the Twitter credentials.
    This kind of configuration should not be kept in the source code repository because
    it is sensitive data and should not be shared with others. Then, the Spring Framework
    enables us to declare properties in the `yaml` file and configures the environment
    variables to fill these properties at runtime. It is an excellent way to keep
    sensitive data out of the source code repository.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用`application.yaml`文件来存储Twitter凭证。这种类型的配置不应该保存在源代码仓库中，因为它包含敏感数据，不应该与他人共享。然后，Spring框架使我们能够在`yaml`文件中声明属性，并在运行时配置环境变量以填充这些属性。这是一种将敏感数据从源代码仓库中排除的绝佳方式。
- en: Configuring Twitter credentials in application.yaml
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在application.yaml中配置Twitter凭证
- en: 'To start configuring the Twitter API in our application, we must provide the
    credentials. We will use the `yaml` file for this. Let''s add credentials in our
    `application.yaml`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在应用程序中配置Twitter API，我们必须提供凭证。我们将使用`yaml`文件来完成这项工作。让我们在我们的`application.yaml`中添加凭证：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Easy peasy. The properties have been declared and then we used the `$` to instruct
    the Spring Framework that this value will be received as an environment variable.
    Remember, we configured the Twitter account in the previous chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 简单易懂。属性已经声明，然后我们使用`$`来指示Spring框架这个值将作为一个环境变量接收。记住，我们在上一章中已经配置了Twitter账户。
- en: Modelling objects to represent Twitter settings
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模对象以表示Twitter设置
- en: We must create abstractions and an amazing data model for our applications.
    This will create some models which make the developer's life easier to understand
    and code. Let's create our Twitter settings models.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为我们的应用程序创建抽象和出色的数据模型。这将创建一些模型，使开发者的生活更容易理解和编码。让我们创建我们的Twitter设置模型。
- en: Twittertoken
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twittertoken
- en: 'This class represents the application token previously configured in Twitter.
    The token can be used for the application authentication only. Our model should
    look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示之前在Twitter中配置的应用程序令牌。该令牌只能用于应用程序认证。我们的模型应该如下所示：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I love the Kotlin way to declare data classes—totally immutable and without
    boilerplate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢Kotlin声明数据类的方式——完全不可变且没有样板代码。
- en: TwitterAppSettings
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TwitterAppSettings
- en: '`TwitterAppSettings` represents the consumer key and consumer secret. It is
    a kind of identity for our application, from Twitter''s perspective. Our model
    is pretty simple and must look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterAppSettings`表示消费者密钥和消费者密钥。从Twitter的角度来看，这是我们应用程序的一种身份标识。我们的模型相当简单，必须如下所示：'
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Good job, our models are ready. It is time to produce the objects for the Spring
    Container. We will do that in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，我们的模型已经准备好了。现在是时候为Spring容器生成对象了。我们将在下一节中这样做。
- en: Declaring Twitter credentials for the Spring container
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Spring容器声明Twitter凭证
- en: 'Let''s produce our Twitter configuration objects. As a pattern we have been
    using, we will use the `@Configuration` class for that. The class should be as
    follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成我们的Twitter配置对象。按照我们一直在使用的模式，我们将使用`@Configuration`类。该类应该如下所示：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Pretty simple and a Spring way to declare beans. We are improving how we use
    Spring step by step. Well done!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，这是声明Spring中bean的一种Spring方式。我们正在逐步改进我们使用Spring的方式。做得好！
- en: Now, we are done with Twitter configurations. We will consume the Twitter API
    using the WebClient from the Spring WebFlux, which supports the reactive programming
    paradigm. Let's understand something before we run the code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了Twitter的配置。我们将使用Spring WebFlux的WebClient来消费Twitter API，它支持响应式编程范式。在我们运行代码之前，让我们先了解一下。
- en: Spring reactive web clients
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring响应式Web客户端
- en: This is a pretty new feature which was added in Spring Framework 5\. It enables
    us to interact with HTTP services, using the reactive paradigm.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当新的功能，它是在Spring Framework 5中添加的。它使我们能够使用响应式范式与HTTP服务交互。
- en: It is not a replacement for a `RestTemplate` provided by Spring, however, it
    is an addition to working with reactive applications. Do not worry, the `RestTemplate`
    is an excellent and tested implementation for interaction with HTTP services in
    traditional applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它并不是Spring提供的`RestTemplate`的替代品，而是一个用于处理反应式应用程序的补充。不用担心，`RestTemplate`是传统应用程序中与HTTP服务交互的出色且经过测试的实现。
- en: Also, the `WebClient` implementation supports the `text/event-stream` mime type
    which can enable us to consume server events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`WebClient`实现支持`text/event-stream` MIME类型，这可以让我们消费服务器事件。
- en: Producing WebClient in a Spring Way
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以Spring方式生成WebClient
- en: Before we start to call the Twitter APIs, we want to create an instance of `WebClient`
    in a Spring way. It means we are looking for a way to inject the instance, using
    the Dependency Injection Pattern.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始调用Twitter API之前，我们希望在Spring中以某种方式创建一个`WebClient`实例。这意味着我们正在寻找一种方法来注入实例，使用依赖注入模式。
- en: 'To achieve this, we can use the `@Configuration` annotation and create a `WebClient`
    instance, using the `@Bean` annotation to declare the bean for the Spring container.
    Let''s do that:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用`@Configuration`注解并创建一个`WebClient`实例，使用`@Bean`注解来声明Spring容器中的bean。让我们这样做：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are a couple of known annotations in this class; this is a pretty standard
    way to declare bean instances in a Spring way. It makes it possible to inject
    an instance of `WebClient` in other Spring-managed classes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别中有一两个已知的注释；这是一种在Spring中以标准方式声明bean实例的相当常见方法。这使得在Spring管理的其他类中注入`WebClient`实例成为可能。
- en: Creating the models to gather Tweets
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型以收集推文
- en: If we want to consume the Twitter APIs asynchronously and reactively, then we
    should create the API client. Before we code the client, we need to create our
    classes for modeling, according to our requirements.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要异步和反应式地消费Twitter API，那么我们应该创建API客户端。在我们编写客户端代码之前，我们需要根据我们的要求创建我们的模型类。
- en: 'We do not need all Tweets'' attributes. We expect the following attributes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要所有推文的属性。我们期望以下属性：
- en: '`id`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`'
- en: '`text`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`'
- en: '`createdAt`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createdAt`'
- en: '`user`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`'
- en: Then, we will model our class based on the attributes listed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将根据列出的属性来构建我们的班级模型。
- en: 'Let''s start with the user attribute. This attribute is a JSON attribute, and
    we will create a separated class for that. The class should look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用户属性开始。这个属性是一个JSON属性，我们将为它创建一个单独的类。这个类应该看起来像这样：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have used the Kotlin `data class,` it fits our use case well, and we want
    to use that as a data container. Also, we need to put in `@JsonIgnoreProperties(ignoreUnknown
    = true)` because this annotation instructs the Spring converters to ignore the
    attribute when it is missing in the JSON response. That is the important part
    of this portion of code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Kotlin的`data class`，它非常适合我们的用例，我们希望将其用作数据容器。此外，我们需要添加`@JsonIgnoreProperties(ignoreUnknown
    = true)`，因为这个注解指示Spring转换器在JSON响应中缺少属性时忽略该属性。这是这部分代码的重要部分。
- en: 'We have created the `TwitterUser` class, which represents the user who created
    the Tweet. Now, we will create the `Tweet` class which represents the Tweet. Let''s
    create our class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`TwitterUser`类，它代表了创建推文的用户。现在，我们将创建一个代表推文的`Tweet`类。让我们创建我们的类：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are some common things for us and one that's new. The `@JsonProperty`
    permits developers to customize the attribute name on the class which has a different
    attribute name in JSON; this is common for Java developers because they usually
    use *CamelCase* as a way to name attributes, and in JSON notation, people usually
    use *SnakeCase*. This annotation can help us to solve this mismatch between the
    programming language and JSON.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说有一些常见的事情，还有一件新的事情。`@JsonProperty`允许开发者自定义类上的属性名，该类在JSON中有不同的属性名；这对于Java开发者来说很常见，因为他们通常使用*CamelCase*作为命名属性的命名方式，而在JSON表示法中，人们通常使用*SnakeCase*。这个注解可以帮助我们解决编程语言和JSON之间的这种不匹配。
- en: 'We can find a more detailed explanation of snake case here: [https://en.wikipedia.org/wiki/Snake_case](https://en.wikipedia.org/wiki/Snake_case).
    Also, we can find a full explanation of camel case here: [https://en.wikipedia.org/wiki/Camel_case](https://en.wikipedia.org/wiki/Camel_case).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里找到关于蛇形命名的更详细解释：[https://en.wikipedia.org/wiki/Snake_case](https://en.wikipedia.org/wiki/Snake_case)。同样，我们也可以在这里找到关于驼峰命名的完整解释：[https://en.wikipedia.org/wiki/Camel_case](https://en.wikipedia.org/wiki/Camel_case)。
- en: Good. Our API objects are ready. With these objects, we are enabled to interact
    with the APIs. We will create a service to collect the Tweets. We will do that
    in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们的API对象已经准备好了。有了这些对象，我们就可以与API交互。我们将创建一个服务来收集推文。我们将在下一节中这样做。
- en: Authentication with Twitter APIs
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Twitter API进行认证
- en: With our objects ready, we need to create a class to help us handle the Twitter
    authentication. We will use the Twitter Application Only Auth authentication model.
    This kind of authentication should be used for backend applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的对象准备好后，我们需要创建一个类来帮助我们处理Twitter认证。我们将使用Twitter应用程序仅认证模型。这种认证应该用于后端应用程序。
- en: 'The application using this kind of authentication can:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种认证方式的应用程序可以：
- en: Pull user timelines
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取用户时间线
- en: Access friends and followers of any account
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问任何账户的朋友和关注者
- en: Access lists and resources
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问列表和资源
- en: Search in Tweets
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在推文中搜索
- en: Retrieve any user information
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取任何用户信息
- en: As we can see, the application is a read-only Twitter API consumer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该应用程序是一个只读的Twitter API消费者。
- en: We can use the Twitter documentation to understand this kind of authentication
    in detail. The documentation can be found here: [https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request.](https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Twitter文档详细了解这种认证。文档可以在以下位置找到：[https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request.](https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request)
- en: 'We will follow the Twitter documentation to authorize our request, which is
    a kind of cooking recipe, so we must follow all the steps. The final class should
    look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循Twitter文档来授权我们的请求，它类似于烹饪食谱，因此我们必须遵循所有步骤。最终的类应该看起来像这样：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is a recipe. The function, `buildAuthHeader`, will create the authorization
    header using the rules to authorize the request. We have signed some request headers
    combined with a request body. Moreover, replace the template values with our Twitter
    credentials objects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个食谱。函数`buildAuthHeader`将使用授权请求的规则创建授权头。我们已对一些请求头进行了签名，并结合请求体。此外，用我们的Twitter凭证对象替换模板值。
- en: Some words about server-sent events (SSE)
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有关服务器发送事件（SSE）的一些说明
- en: Server-sent events (SSE) is a technology where the server sends events to the
    client, instead of the client polling the server to check the information availability.
    The message flow will not get interrupted until the client or server closes the
    stream.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送事件（SSE）是一种技术，其中服务器向客户端发送事件，而不是客户端轮询服务器以检查信息可用性。消息流不会中断，直到客户端或服务器关闭流。
- en: The most important thing to understand here is the direction of the information
    flow. The server decides when to send data to a client.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要理解的最重要的事情是信息流的流向。服务器决定何时向客户端发送数据。
- en: It is very important to handle resource load and bandwidth usage. The client
    will receive the chunk of data instead to apply load on the server through the
    polling techniques.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理资源负载和带宽使用非常重要。客户端将接收数据块，而不是通过轮询技术将负载施加在服务器上。
- en: Twitter has a stream API and the Spring Framework WebClient supports SSE. It
    is time to consume the Twitter stream.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter有一个流API，Spring Framework WebClient支持SSE。现在是消费Twitter流的时候了。
- en: Creating the gather service
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建收集服务
- en: 'The `TweetGatherService` will be responsible for interacting with Twitter APIs
    and collecting the request tweets according to the requested hashtag. The service
    will be a Spring bean with some inject attributes. The class should look like
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`TweetGatherService`将负责与Twitter API交互，并根据请求的标签收集请求推文。该服务将是一个带有一些注入属性的Spring
    Bean。类应该看起来像这样：'
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are some important points here. The first is the function declaration;
    take a look at `Flux<Tweet>`, it means the data can never get interrupted because
    it represents the N values. In our case, we will consume the Twitter stream until
    the client or server interrupts the data flow.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的要点。首先是函数声明；看看`Flux<Tweet>`，这意味着数据永远不会中断，因为它代表了N个值。在我们的情况下，我们将消费Twitter流，直到客户端或服务器中断数据流。
- en: After that, we configured the HTTP request body with our desired track to get
    events. After that, we configured the Accept HTTP header; it is essential to instruct
    the WebClient what kind of mime type it needs to consume.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们配置了HTTP请求体，以获取我们想要的跟踪事件。之后，我们配置了Accept HTTP头；这是向WebClient指示它需要消费哪种MIME类型的关键。
- en: Finally, we have used our `Twitter.buildAuthHeader` function to configure the
    Twitter authentication.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了 `Twitter.buildAuthHeader` 函数来配置 Twitter 认证。
- en: Awesome, we are ready to start to consume the Twitter API, and we only need
    to code the trigger to use that function. We will do that in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们准备好开始消费 Twitter API，我们只需要编写触发器来使用该函数。我们将在下一节中这样做。
- en: Listening to the Rabbit Queue and consuming the Twitter API
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听 RabbitMQ 队列并消费 Twitter API
- en: We will consume the Twitter API, but when?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将消费 Twitter API，但何时开始？
- en: We need to start to get Tweets when the request for tracking the hashtags comes
    to our application. To reach that goal, we will implement the RabbitMQ Listener
    when the `TrackedHashTag` gets registered on our microservice. The application
    will send the message to the broker to start consuming the Twitter stream.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当跟踪标签的请求到达我们的应用程序时，我们需要开始获取推文。为了达到这个目标，当 `TrackedHashTag` 在我们的微服务上注册时，我们将实现
    RabbitMQ 监听器。应用程序将向代理发送消息以开始消费 Twitter 流。
- en: 'Let''s take a look at the code and step by step understand the behaviors; the
    final code should look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，一步一步地理解其行为；最终的代码应该看起来像这样：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keep calm. We will cover the whole code. In the `@RabbitListener,` we configured
    the name of the queue we want to consume. The Spring AMQP module will configure
    our listener automatically for us and start to consume the desired queue. As we
    can see, we received the `TrackedHashTag` object; remember the converters on the
    previous sections.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 保持冷静。我们将涵盖整个代码。在 `@RabbitListener` 中，我们配置了我们想要消费的队列名称。Spring AMQP 模块将自动为我们配置监听器并开始消费所需的队列。正如我们所见，我们收到了
    `TrackedHashTag` 对象；记住之前章节中的转换器。
- en: The first instruction will start to consume the Twitter stream. The stream returns
    a flux and can have a lot of data events there. After the consumer, we want to
    filter the data on the flow. We want `Tweet` in which the `id`, `text`, and `createdAt`
    are not null.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将开始消费 Twitter 流。该流返回一个 flux，其中可以有很多数据事件。在消费者之后，我们希望在流中过滤数据。我们想要 `Tweet`，其中
    `id`、`text` 和 `createdAt` 都不为空。
- en: Then, we subscribe this stream and start to receive the data in the flow. Also,
    the `subscribes` function returns the disposable object which will be helpful
    in the next steps. We have created an anonymous function which will print the
    `Tweet` on the console and send the Tweet to the RabbitMQ queue, to be consumed
    in another microservice.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们订阅这个流并开始接收流中的数据。此外，`subscribes` 函数返回一个可丢弃的对象，这将在下一步中很有帮助。我们创建了一个匿名函数，该函数将在控制台上打印
    `Tweet` 并将 Tweet 发送到 RabbitMQ 队列，以便在另一个微服务中消费。
- en: Finally, we use the schedulers to stop the data flow and consume the data for
    10 seconds.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用调度器停止数据流并消费数据 10 秒。
- en: Before you test the Twitter stream, we need to change the Tracked Hashtag Service
    to send the messages through the RabbitMQ. We will do that in the next sections.
    The changes are small ones and we will do them quickly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 Twitter 流之前，我们需要将跟踪标签服务更改为通过 RabbitMQ 发送消息。我们将在下一节中这样做。这些更改很小，我们会快速完成。
- en: Changing the Tracked Hashtag Service
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改跟踪标签服务
- en: To run the whole solution, we need to make some changes to the Tracked Hashtag
    Service project. The changes are simple and basic; configure the RabbitMQ connection
    and change the service to send the messages to the broker.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行整个解决方案，我们需要对跟踪标签服务项目做一些更改。这些更改很简单且基本；配置 RabbitMQ 连接并将服务更改为向代理发送消息。
- en: Let's do that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做。
- en: Adding the Spring Starter RabbitMQ dependency
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Spring Starter RabbitMQ 依赖
- en: 'As we did before in the Twitter Gathering project, we need to add `spring-boot-starter-amqp`
    to provide some auto-configuration for us. To do that, we need to add the following
    snippet to our `pom.xml`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Twitter Gathering 项目中之前所做的那样，我们需要添加 `spring-boot-starter-amqp` 以提供一些自动配置。为此，我们需要将以下片段添加到我们的
    `pom.xml` 文件中：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Right. Now, it is time to configure the RabbitMQ connections. We will do this
    in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对了。现在，是时候配置 RabbitMQ 连接了。我们将在下一节中这样做。
- en: Configuring the RabbitMQ connections
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 RabbitMQ 连接
- en: We will use the `application.yaml` to configure the RabbitMQ connections. Then,
    we need to create a couple of properties in it and the Spring AMQP module will
    use that provided configuration to start the connection factory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `application.yaml` 来配置 RabbitMQ 连接。然后，我们需要在其中创建一些属性，Spring AMQP 模块将使用提供的配置来启动连接工厂。
- en: 'It is pretty simple to configure it. The final `yaml` file for Tracked Hashtag
    should look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 配置它很简单。跟踪标签的最终`yaml`文件应该看起来像这样：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are two profiles in this yaml. Take a look at the different host for the
    RabbitMQ. In the default profile, we are able to connect the localhost because
    we exposed the RabbitMQ ports on the host. But on the Docker profile, we are not
    able to connect the localhost, we need to connect to the `rabbitmq` host, which
    is the host for the Twitter network.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个yaml文件中有两个配置文件。看看RabbitMQ的不同主机。在默认配置文件中，我们能够连接到localhost，因为我们已经在主机上公开了RabbitMQ端口。但在Docker配置文件中，我们无法连接到localhost，我们需要连接到`rabbitmq`主机，这是Twitter网络的主机。
- en: Our RabbitMQ connection is ready to use. Let's try it in the next section. Let's
    go.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的RabbitMQ连接已准备好使用。让我们在下一节尝试它。让我们开始吧。
- en: Creating exchanges, queues, and bindings for the Twitter Hashtag Service
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Twitter标签服务创建交换、队列和绑定
- en: Let's declare our RabbitMQ entities for the Tracked Hashtag usage. We will do
    that using the `@Configuration` class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明我们的RabbitMQ实体以用于跟踪标签。我们将使用`@Configuration`类来完成这项工作。
- en: 'The RabbitMQ connection should look like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ连接应该看起来像这样：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pretty straightforward. We declared one exchange, queue, and binding, as we
    did before.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单。我们声明了一个交换、队列和绑定，就像我们之前做的那样。
- en: Sending the messages to the broker
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向代理发送消息
- en: This is the most interesting part now. When we want to save the `TrackedHashTag`,
    we must send the pretty new entity to the RabbitMQ. This process will send the
    message, and then the Twitter Gathering microservice will start to consume the
    stream in ten seconds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在是最有趣的部分。当我们想要保存`TrackedHashTag`时，我们必须将这个全新的实体发送到RabbitMQ。这个过程将发送消息，然后Twitter聚集微服务将在十秒后开始消费流。
- en: 'We need to change the `TrackedHashTagService` a little bit; the final version
    should look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要稍微修改一下`TrackedHashTagService`；最终版本应该看起来像这样：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Awesome job. When the new entity comes, it will be sent to the broker. We have
    finished our changes on the Tracked Hashtag Service.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。当新的实体到来时，它将被发送到代理。我们已经完成了对跟踪标签服务的修改。
- en: Finally, we are able to test the whole flow. Let's start to play and perceive
    the real power of our built application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们能够测试整个流程。让我们开始玩耍并感知我们构建的应用程序的真正力量。
- en: It's showtime!!!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 演示时间！！！
- en: Testing the microservice's integrations
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试微服务的集成
- en: 'Now, we are ready to test the whole solution. Before you start, we need to
    check the following infrastructure items:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好测试整个解决方案。在你开始之前，我们需要检查以下基础设施项目：
- en: Redis
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: RabbitMQ
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: If the items are up and running, we can jump to the next section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目正在运行，我们可以跳到下一节。
- en: We can use the `docker ps` command, and the command should list the Redis and
    RabbitMQ containers in running mode.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker ps`命令，该命令应该列出运行模式下的Redis和RabbitMQ容器。
- en: Running Tracked Hashtag Service
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行跟踪标签服务
- en: There is no special thing to run this application. It includes the infrastructure
    connections which are configured in the default profile in `application.yaml`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个应用程序没有特别的事情要做。它包括在`application.yaml`的默认配置文件中配置的基础设施连接。
- en: Run the main function present on the `TrackedHashTagApplication`. We can use
    the IDE or command line to do that.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`TrackedHashTagApplication`上的主函数。我们可以使用IDE或命令行来完成这项工作。
- en: 'Check the console output; the output will be presented on the IDE or command
    line. We want to find the following line:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 检查控制台输出；输出将在IDE或命令行上显示。我们想要找到以下行：
- en: '![](img/693c333b-d14e-40fb-bfdb-66a4297ee0f9.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/693c333b-d14e-40fb-bfdb-66a4297ee0f9.png)'
- en: It means the first application is fully operational and we are able to run Twitter
    Gathering. Please keep the application running as it is required.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第一个应用程序完全运行，我们可以运行Twitter聚集。请保持应用程序运行，因为它需要这样做。
- en: Let's run Twitter Gathering!!!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行Twitter聚集！！！
- en: Running the Twitter Gathering
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Twitter聚集
- en: This application is a little bit more complicated to run. We need to configure
    some environment variables for that. It is required because we do not want the
    Twitter application credentials in our repository.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序运行起来稍微复杂一些。我们需要为它配置一些环境变量。这是必需的，因为我们不希望在我们的存储库中包含Twitter应用程序凭证。
- en: 'It is pretty simple to do in the IDE. To do that, we can configure the run
    configuration. Let''s do it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE中做这件事很简单。为此，我们可以配置运行配置。让我们来做这件事：
- en: 'Click on the Edit Configurations...like in the following image:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击编辑配置...，如下图所示：
- en: '![](img/07088397-9d6c-4b4c-b869-363fbf29531d.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07088397-9d6c-4b4c-b869-363fbf29531d.png)'
- en: 'Then, we are able to see the Environment variables like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们能够看到像这样的环境变量：
- en: '![](img/a0251ce5-b76a-4b51-ae10-fdef199f1dc2.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0251ce5-b76a-4b51-ae10-fdef199f1dc2.png)'
- en: We need to click on **...**, as highlighted in the proceeding image.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要点击 **...**，如图中所示。
- en: 'The next screen will be shown and we can configure the Environment Variable:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个屏幕将显示，我们可以配置环境变量：
- en: '![](img/e3e70570-87ff-4d8a-a157-da89622fc957.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3e70570-87ff-4d8a-a157-da89622fc957.png)'
- en: 'We need to configure the following environment variables:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置以下环境变量：
- en: consumer-key
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: consumer-key
- en: consumer-secret
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: consumer-secret
- en: access-token
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: access-token
- en: access-token-secret
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: access-token-secret
- en: These values should be filled with the Twitter Application Management values.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值应该填写 Twitter 应用程序管理器的值。
- en: Then, we can run the application. Run it!!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行应用程序。运行它！！
- en: 'Now, we should see the following lines in the console, which means the application
    is running:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该在控制台中看到以下行，这意味着应用程序正在运行：
- en: '![](img/2ff9703d-2e38-4a23-aab0-57e5a83c7a9d.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ff9703d-2e38-4a23-aab0-57e5a83c7a9d.png)'
- en: Awesome, our two microservices are running. Let's trigger the Twitter stream.
    We will do that in the next section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的两个微服务正在运行。让我们触发 Twitter 流。我们将在下一节中这样做。
- en: There are other ways to run the application, for example, with the maven Spring
    Boot goals or Java command line. If you prefer to run in the Java command line,
    keep in mind the `-D` argument to pass environment variables.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序还有其他方法，例如使用 Maven Spring Boot 目标或 Java 命令行。如果你更喜欢在 Java 命令行中运行，请记住使用 `-D`
    参数来传递环境变量。
- en: Testing stuff
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试内容
- en: We are excited to test the full integration. We can use the `curl` tool to send
    request data to the Tracked Hashtag Service. We want to track the `"bitcoin"`
    from Twitter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常期待测试完整的集成。我们可以使用 `curl` 工具向 Tracked Hashtag 服务发送请求数据。我们想跟踪来自 Twitter 的 `"bitcoin"`。
- en: 'We can execute the following command line:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下命令行：
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Check the HTTP status code; it should be HTTP status 200\. After that, we can
    check the console from the Twitter Gathering project, and there should be a lot
    of Tweets logged.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 HTTP 状态码；它应该是 HTTP 状态 200。之后，我们可以检查 Twitter Gathering 项目的控制台，并且应该有大量的推文被记录。
- en: 'Take a look at the log, the log must have Tweets like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 看看日志，日志中必须有像这样的推文：
- en: '![](img/dce09e86-356a-46f0-8ad8-bb5d10c3a28b.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dce09e86-356a-46f0-8ad8-bb5d10c3a28b.png)'
- en: Awesome!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: Great work guys, we have the full application integrated with RabbitMQ and the
    Twitter stream.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的工作，伙计们，我们已经将完整的应用程序与 RabbitMQ 和 Twitter 流集成在一起。
- en: Spring Actuator
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Actuator
- en: The Spring Boot Actuator is a kind of helper when the application is running
    in production. The project provides built-in information of a deployed application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 是当应用程序在生产环境中运行时的一种辅助工具。该项目提供了已部署应用程序的内置信息。
- en: In the microservices world, monitoring instances of applications are the key
    point to getting success. In these environments, there are usually many applications
    calling the other applications over the network protocols such as HTTP. The network
    is an unstable environment and sometimes it will fail; we need to track these
    incidents to make sure the application is up and fully operational.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，监控应用程序的实例是获得成功的关键点。在这些环境中，通常有许多应用程序通过网络协议（如 HTTP）调用其他应用程序。网络是一个不稳定的
    环境，有时它可能会失败；我们需要跟踪这些事件以确保应用程序处于运行状态并且完全可用。
- en: The Spring Boot Actuator helps developers in these situations. The project exposes
    a couple of HTTP APIs with application information, such as the memory usage,
    CPU usage, application health check, and the infrastructure components of the
    application, such as a connection with databases and message brokers, as well.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 在这些情况下帮助开发者。该项目公开了一些包含应用程序信息的 HTTP API，例如内存使用情况、CPU 使用情况、应用程序健康检查以及应用程序的基础设施组件，例如与数据库和消息代理的连接等。
- en: One of the most important points is that the information is exposed over HTTP.
    It helps integrations with external monitor applications such as Nagios and Zabbix,
    for instance. There is no specific protocol for exposing this information.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的一点是，信息通过 HTTP 暴露。它有助于与外部监控应用程序（如 Nagios 和 Zabbix）的集成，例如。没有特定的协议用于暴露这些信息。
- en: Let's add it to our project and try a couple of endpoints.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到我们的项目中并尝试几个端点。
- en: Adding Spring Boot Actuator in our pom.xml
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的 pom.xml 中添加 Spring Boot Actuator
- en: Spring Boot Actuator is pretty simple to configure in our `pom.xml`. We extended
    the parent pom of Spring Boot, so it is not necessary to specify the version of
    the dependency.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 在我们的 `pom.xml` 中配置起来非常简单。我们扩展了 Spring Boot 的父 pom，因此没有必要指定依赖项的版本。
- en: 'Let''s configure our new dependency:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置我们的新依赖项：
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Awesome, really easy. Let's understand a little bit more before we test.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，真的很容易。在我们测试之前，让我们更深入地了解一下。
- en: Actuator Endpoints
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actuator 端点
- en: The projects have a lot of built-in endpoints and they will be up when the application
    started. Remember, we have used the starter project, which is the one that configures
    it automatically for us.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 项目有很多内置的端点，并且当应用程序启动时它们会启动。记住，我们已经使用了启动项目，这是自动为我们配置它的项目。
- en: There are several endpoints for different requirements, and we will take a look
    at the most used in production microservices.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个端点用于不同的需求，我们将查看在生产微服务中最常用的端点。
- en: '`/health`: The most known actuator endpoint; it shows the application''s health,
    and usually, there is a `status` attribute'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/health`：最知名的actuator端点；它显示了应用程序的健康状况，通常有一个`status`属性'
- en: '`/configprops`: Displays a collapse `@ConfigurationProperties`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/configprops`：显示折叠的 `@ConfigurationProperties`'
- en: '`/env`: Exposes properties from the Spring `ConfigurableEnvironment`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/env`：公开 Spring `ConfigurableEnvironment` 的属性'
- en: '`/dump`: Shows the thread dump'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dump`：显示线程转储'
- en: '`/info`: We can put some arbitrary information at this endpoint'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/info`：我们可以在该端点放置一些任意信息'
- en: '`/metrics`: Metrics from the running application'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/metrics`：运行应用程序的指标'
- en: '`/mappings`: `@RequestMappings` endpoints from the current application'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mappings`：当前应用程序的 `@RequestMappings` 端点'
- en: There is another important endpoint to show the application logs over the HTTP
    interface. The `/logfile` endpoint can help us visualize logfiles.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的端点可以通过 HTTP 接口显示应用程序日志。`/logfile` 端点可以帮助我们可视化日志文件。
- en: The list of endpoints created by the Spring Boot Actuator can be found at: [https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 创建的端点列表可以在以下位置找到：[https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html)。
- en: Application custom information
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序自定义信息
- en: There is one particular endpoint which we can use to expose custom information
    from our application. This information will be exposed to `/info` endpoint.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个特定的端点来从我们的应用程序中公开自定义信息。这些信息将通过`/info`端点公开。
- en: 'To configure that, we can use the `application.yaml` file and put the desired
    information respecting the pattern, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置这一点，我们可以使用 `application.yaml` 文件并将所需信息按照以下模式放置，如下所示：
- en: '[PRE25]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Thr desired properties must be preceded by the `info. *`. Then, we can test
    our first actuator endpoint and check our `/info` resource.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的属性必须以 `info. *` 开头。然后，我们可以测试我们的第一个 actuator 端点并检查我们的 `/info` 资源。
- en: 'Let''s try to access the `http://localhost:8081/info`. The information filled
    on `application.yaml` should be displayed, as shown here:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试访问`http://localhost:8081/info`。在`application.yaml`中填写的信息应该会显示出来，如下所示：
- en: '![](img/ef882dee-d213-488f-83c9-81ff4119644b.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef882dee-d213-488f-83c9-81ff4119644b.png)'
- en: As we can see, the properties are exposed from the HTTP endpoint. We can use
    that to put the application version, for instance.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，属性是从 HTTP 端点公开的。我们可以使用它来放置应用程序版本，例如。
- en: Testing endpoints
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试端点
- en: In version 2 of  Spring Boot, the Spring Actuator management endpoints are disabled
    by default, because these endpoints can have sensitive data of a running application.
    Then, we need to configure to enable these endpoints properly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 的第 2 版中，Spring Actuator 管理端点默认是禁用的，因为这些端点可能包含运行中应用程序的敏感数据。然后，我们需要配置以正确启用这些端点。
- en: There is a special point to pay attention to. If the application is exposed
    publicly, you should protect these endpoints.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的特殊点。如果应用程序公开暴露，你应该保护这些端点。
- en: 'Let''s enable our management endpoints:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启用我们的管理端点：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding configuration, we enabled all the management endpoints, and
    then we can start to test some endpoints.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们启用了所有管理端点，然后我们可以开始测试一些端点。
- en: 'Let''s test some endpoints. First, we will test the metrics endpoints. This
    endpoint shows the metrics available for the running application. Go to `http://localhost:8081/actuator/metrics`
    and check the result:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一些端点。首先，我们将测试指标端点。此端点显示了运行应用程序可用的指标。访问 `http://localhost:8081/actuator/metrics`
    并查看结果：
- en: '![](img/9a5582e9-5f54-4a81-ba83-c62808f0787b.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a5582e9-5f54-4a81-ba83-c62808f0787b.png)'
- en: We are using port `8081` because we configured the property `server.port` in `application.yaml`.
    The port can be changed as you desire.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用端口 `8081` 是因为我们已在 `application.yaml` 中配置了属性 `server.port`。端口可以根据你的需求进行更改。
- en: There are a lot of metrics configured automatically for us. That endpoint exposes
    only the available metrics. To check the metric value, we need to use another
    endpoint. Let's check the value of the `http.server.request`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为我们自动配置了许多指标。该端点仅公开可用的指标。要检查指标值，我们需要使用另一个端点。让我们检查 `http.server.request` 的值。
- en: 'The base endpoint to check the value is: `http://localhost:8081/actuator/metrics/{metricName}`.
    Then, we need to go to: `http://localhost:8081/actuator/metrics/http.server.requests`.
    The result should be:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 检查值的基端点是：`http://localhost:8081/actuator/metrics/{metricName}`。然后，我们需要访问：`http://localhost:8081/actuator/metrics/http.server.requests`。结果应该是：
- en: '![](img/5d482622-a6d0-46e9-8d6c-a8100da65714.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d482622-a6d0-46e9-8d6c-a8100da65714.png)'
- en: As you can see, the server received eight calls. Try to hit a few more times
    to see the metrics changing.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，服务器接收了八次调用。尝试再点击几次以查看指标的变化。
- en: Awesome job. Our microservice is ready for production. We have the docker image
    and endpoints for monitoring our services.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。我们的微服务已准备好投入生产。我们有 Docker 镜像和用于监控服务的端点。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned and put into practice a lot of Spring Advanced concepts,
    such as RabbitMQ integration.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了并将许多 Spring 高级概念付诸实践，例如 RabbitMQ 集成。
- en: We have created a fully reactive WebClient and took advantage of the reactive
    paradigm; it enables resource computational optimization and increases performance
    for the application.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个完全响应式的 WebClient 并利用了响应式范式；它实现了资源计算优化并提高了应用程序的性能。
- en: Also, we have integrated two microservices through the RabbitMQ broker. This
    is an excellent solution to integrating applications because it decouples the
    applications and also permits you to scale the application horizontally really
    easily. Message-driven is one of the required characteristics to build a reactive
    application; it can be found at Reactive Manifesto ([https://www.reactivemanifesto.org/en](https://www.reactivemanifesto.org/en)).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过 RabbitMQ 代理集成了两个微服务。这是集成应用程序的一个优秀解决方案，因为它解耦了应用程序，并且允许你非常容易地水平扩展应用程序。消息驱动是构建响应式应用程序的必要特性之一；它可以在《响应式宣言》中找到（[https://www.reactivemanifesto.org/en](https://www.reactivemanifesto.org/en)）。
- en: In the next chapter, we will improve our solution and create a new microservice
    to stream the filtered Tweets for our clients. We will use RabbitMQ one more time.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改进我们的解决方案并创建一个新的微服务来向我们的客户流式传输过滤后的推文。我们还将再次使用 RabbitMQ。
