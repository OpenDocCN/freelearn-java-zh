- en: Chapter 5. Working with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC approach talks about the model, view, and controller. We have seen views
    and controllers in detail in the previous chapters and neglected models to quite
    an extent. Models are an important part of MVC; the changes made to a model are
    reflected in the views and controllers using them.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications are incomplete without data transactions. This chapter is about
    designing models and handling DB transactions in Play.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anorm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactiveMongo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Cache API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **model** is a domain object, which maps to database entities. For example,
    a social networking application has users. The users can register, update their
    profile, add friends, post links, and so on. Here, the user is a domain object
    and each user will have corresponding entries in the database. Therefore, we could
    define a user model in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we defined a model without using a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The task list example had a `Task` model but it was not bound to a database,
    keeping things simpler. At the end of this chapter, we will be able to back it
    up with a database.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing the DB using **Java Database Connectivity** (**JDBC**) is common in
    applications using relational DBs. Play provides a plugin to manage the JDBC connection
    pool. The plugin internally uses BoneCP ([http://jolbox.com/](http://jolbox.com/)),
    a fast **Java Database Connection pool** (**JDBC pool**) library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use the plugin, a dependency in the build file should be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin supports H2, SQLite, PostgreSQL, MySQL, and SQL. Play is bundled
    with an H2 database driver, but to use any of the other databases we should add
    a dependency on its corresponding driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin exposes the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getConnection`: It accepts the name of the database it should get the connection
    for and whether any statement executed using this connection should commit automatically
    or not. If a name is not provided, it fetches the connection for database with
    the default name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withConnection`: It accepts a block of code that should be executed using
    a JDBC connection. Once the block is executed, the connection is released. Alternatively,
    it accepts the name of the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withTransaction`: It accepts a block of code that should be executed using
    a JDBC transaction. Once the block is executed, the connection and all its created
    statements are released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How does the plugin know the details of the database? The details of the database
    can be set in `conf/application.` `conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first part, `db`, is a set of properties, which are used by the DBPlugin.
    The second part is the name of the database, `default` in the example, and the
    last part is the name of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For MySQL and PostgreSQL, we could include the user and password in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For additional JDBC configurations, refer to [https://www.playframework.com/documentation/2.3.x/SettingsJDBC](https://www.playframework.com/documentation/2.3.x/SettingsJDBC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve enabled and configured the the JDBC plugin, we can connect
    to a SQL-like database and execute queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `DB.withConnection` helper, which manages the
    DB connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Anorm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Anorm** is a module in Play that supports interactions with the database
    using a plain SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: Anorm exposes methods to query the SQL database and parse the result as Scala
    objects, built in as well as custom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective behind Anorm as stated on the Play website ([https://www.playframework.com/documentation/2.3.x/ScalaAnorm](https://www.playframework.com/documentation/2.3.x/ScalaAnorm))
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using JDBC is a pain, but we provide a better API**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We agree that using the JDBC API directly is tedious, particularly in Java.
    You have to deal with checked exceptions everywhere and iterate over and over
    around the ResultSet to transform this raw dataset into your own data structure.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We provide a simpler API for JDBC; using Scala you don''t need to bother with
    exceptions, and transforming data is really easy with a functional language. In
    fact, the goal of the Play Scala SQL access layer is to provide several APIs to
    effectively transform JDBC data into other Scala structures.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**You don''t need another DSL to access relational databases**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*SQL is already the best DSL for accessing relational databases. We don''t
    need to invent something new. Moreover the SQL syntax and features can differ
    from one database vendor to another.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you try to abstract this point with another proprietary SQL like DSL you
    will have to deal with several dialects dedicated for each vendor (like Hibernate
    ones), and limit yourself by not using a particular database''s interesting features.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Play will sometimes provide you with pre-filled SQL statements, but the idea
    is not to hide the fact that we use SQL under the hood. Play just saves typing
    a bunch of characters for trivial queries, and you can always fall back to plain
    old SQL.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A typesafe DSL to generate SQL is a mistake**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some argue that a type safe DSL is better since all your queries are checked
    by the compiler. Unfortunately the compiler checks your queries based on a meta-model
    definition that you often write yourself by mapping your data structure to the
    database schema.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*There are no guarantees that this meta-model is correct. Even if the compiler
    says that your code and your queries are correctly typed, it can still miserably
    fail at runtime because of a mismatch in your actual database definition.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Take control of your SQL code**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Object Relational Mapping works well for trivial cases, but when you have
    to deal with complex schemas or existing databases, you will spend most of your
    time fighting with your ORM to make it generate the SQL queries you want.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Writing SQL queries yourself can be tedious for a simple ''Hello World'' application,
    but for any real-life application, you will eventually save time and simplify
    your code by taking full control of your SQL code.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When developing an application using Anorm, its dependency should be specified
    explicitly, since it is a separate module in Play (starting from Play 2.1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s picture our user model in MySQL. The table can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at the different queries we will make in this table. The queries
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Insert`: This query includes adding a new user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update`: This query includes updating the profile, password, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Select`: This query includes fetching one or more user''s details, based on
    particular criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume that when a user requests to delete his account from our application,
    we do not delete the user from the database, but instead mark the user's status
    as inactive. Therefore, we will not use any delete queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Anorm, we could have the `userId` autogenerated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `loginId`, `password`, `name`, and `dob` are variables that are replaced
    in the query at runtime. Anorm builds only `java.sql.PreparedStatements`, which
    prevents SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL method returns an object of the `SimpleSql` type and is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`SimpleSql` is used to represent a query in an intermediate format. Its constructor
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `executeInsert` method fetches `PreparedStatement` from the `SimpleSql`
    object using its `getFilledStatement` method. Then the `getGeneratedKeys()` method
    of `PreparedStatement` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `getGeneratedKeys` method results in an autogenerated key, created as a
    result of executing the statement in which it is called. If no key is created,
    it returns an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s use Anorm to update a user''s password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `executeUpdate` method works similar to `executeInsert`. The difference
    is that it calls the `executeUpdate` method of the `PreparedStatement`, instead
    of `getGeneratedKeys`.
  prefs: []
  type: TYPE_NORMAL
- en: The `executeUpdate` method returns a count of affected rows for the **Data Manipulation
    Language** (**DML**) statements. If the SQL statement is of the other types, such
    as **Data Definition Language** (**DDL**), it returns `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to fetch the details of all registered users. If we want the
    resulting rows to be parsed as user objects, we should define a parser. The parser
    for a user will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In most queries, we will not need the password and date of birth, so we can
    exclude them from the user `RowParser` default.
  prefs: []
  type: TYPE_NORMAL
- en: 'A query using this parser can be shown in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `.*` symbol indicates that the result should have one or more rows similar
    to its common interpretation in regular expressions. Similarly, the `.+` symbol
    can be used when we expect the result to consist of zero or more rows.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''re using an older version of Scala where string interpolations are
    not supported, the queries would be written in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `on` method updates the query with the parameter map passed to it. It is
    defined for `SimpleSql` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the Play documentation ([http://www.playframework.com/documentation/2.3.x/ScalaAnorm](http://www.playframework.com/documentation/2.3.x/ScalaAnorm))
    and the Anorm API documentation ([http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package](http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package))
    for more use casess and details.
  prefs: []
  type: TYPE_NORMAL
- en: Slick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Slick''s website ([http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick](http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Slick is Typesafe''s modern database query and access library for Scala. It
    allows you to work with stored data almost as if you were using Scala collections
    while at the same time giving you full control over when a database access happens
    and which data is transferred. You can also use SQL directly.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When using Scala instead of raw SQL for your queries you benefit from compile-time
    safety and compositionality. Slick can generate queries for different backend
    databases including your own, using its extensible query compiler.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can use Slick in our Play application through the play-slick plugin. The
    plugin provides some additional features for the use of Slick in a Play application.
    According to [https://github.com/playframework/](https://github.com/playframework/),
    play-slick consists of three features:'
  prefs: []
  type: TYPE_NORMAL
- en: A wrapper DB object that uses the datasources defined in the Play config files,
    and pulls them from a connection pool. It is there so it is possible to use Slick
    sessions in the same fashion as you would Anorm JDBC connections. There are some
    smart caching and load balancing that make your connections to your DB perform
    better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DDL plugin that reads Slick tables and automatically creates schema updates
    on reload. This is useful in particular for demos and to get started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wrapper to use play Enumeratees together with Slick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use it, we need to add the following library dependency in the build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to define the schema in Scala. This can be done by mapping the
    required tables to case classes. For our user table, the schema can be defined
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Table` is a Slick trait and its columns are specified through the `column`
    method. The following types are supported for a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numeric types**: These include `Byte`, `Short`, `Int`, `Long`, `BigDecimal`,
    `Float`, and `Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date types**: These include `java.sql.Date`, `java.sql.Time`, and `java.sql.Timestamp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UUID type:** `This includes java.util.UUID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LOB types**: These include `java.sql.Blob`, `java.sql.Clob`, and `Array[Byte]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other types**: These include `Boolean`, `String`, and `Unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `column` method accepts column constraints, such as `PrimaryKey`, `Default`,
    `AutoInc`, `NotNull`, and `Nullable`.
  prefs: []
  type: TYPE_NORMAL
- en: The `*` method is mandatory for every table and is similar to `RowParser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define a `TableQuery` Slick using this and use it to query a database.
    There are simple methods available for performing equivalent DB operations. We
    can define the methods in the Anorm object using the play-slick wrapper along
    with the Slick API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `run` method is equivalent to calling `SELECT *`.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on this, refer to the Slick ([http://slick.typesafe.com/doc/2.1.0/](http://slick.typesafe.com/doc/2.1.0/))
    and the play-slick documentation ([https://github.com/playframework/play-slick](https://github.com/playframework/play-slick)).
  prefs: []
  type: TYPE_NORMAL
- en: ReactiveMongo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of applications these days use a NoSQL database as a result of unstructured
    data, write scalability, and so on. MongoDB is one such database. According to
    its website ([http://docs.mongodb.org/manual/core/introduction/](http://docs.mongodb.org/manual/core/introduction/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*MongoDB is an open source document database that provides high performance,
    high availability, and automatic scaling.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key features of MongoDB are:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: High performance
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: High availability (automatic failover, data redundancy)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Automatic scaling (horizontal scalability)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ReactiveMongo is a Scala driver for MongoDB that supports non-blocking and asynchronous
    I/O operations. There is a plugin for the Play Framework called Play-ReactiveMongo.
    It is not a Play plugin but it's supported and maintained by the team of ReactiveMongo.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section requires prior knowledge of MongoDB, so please refer to [https://www.mongodb.org/](https://www.mongodb.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include it as a dependency in the build file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the plugin in `conf/play.plugins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the MongoDB server details in `conf/application.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's see usage of the plugin with a sample application. We may come across
    an instance in our application where we allow users to monitor activities on their
    devices in the form of heat sensors, smoke detectors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the device with our application installed on it, the device should
    be registered with this application. Each device has `ownerId`, `deviceId`, its
    configuration, and product information. So, let''s assume that, on registration,
    we get a JSON in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once a device is registered, the owner can update the configuration or agree
    to update the product's software. Updating software is handled by the device company,
    and we only need to update the details in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The queries to the database will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Insert`: This query includes registering a device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update`: This query includes updating device configuration or information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delete`: This query occurs when a device is unregistered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Select`: This query occurs when an owner wishes to view the details of the
    device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Reactive Mongo, the device registration will be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this snippet, we''ve built a JSON object from the available device details
    and inserted it in `devices`. Here, the collection is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The insert command accepts the data and its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This leaves us with just the update query. An update is triggered for a single
    property of configuration or information, that is, the request has just one field
    and its new value is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a query to update this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we wish to update a field for a given document in MongoDB, we should add
    the updated data to the `$set` field in the query. For example, an equivalent
    MongoDB query would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The Cache API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching in a web application is the process of storing dynamically generated
    items, whether these are data objects, pages, or parts of a page, in memory at
    the initial time they are requested. This can later be reused if subsequent requests
    for the same data are made, thereby reducing response time and enhancing user
    experience. One can cache or store these items on the web server or other software
    in the request stream, such as the proxy server or browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play has a minimal cache API, which uses EHCache. As stated on its website
    ([http://ehcache.org/](http://ehcache.org/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ehcache** *is an open source, standards-based cache for boosting performance,
    offloading your database, and simplifying scalability. It''s the most widely-used
    Java-based cache because it''s robust, proven, and full-featured. Ehcache scales
    from in-process, with one or more nodes, all the way to mixed in-process/out-of-process
    configurations with terabyte-sized caches.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It provides caching for presentation layers as well as application-specific
    objects. It is easy to use, maintain, and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use the default cache API within a Play application, we should declare it
    as a dependency as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the default cache API is similar to using a mutable `Map[String, Any]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This API is made available through `EHCachePlugin`. The plugin is responsible
    for creating an instance of EHCache CacheManager with an available configuration
    on starting the application, and shutting it down when the application is stopped.
    We will discuss Play plugins in detail in [Chapter 13](ch13.html "Chapter 13. Writing
    Play Plugins"), *Writing Play Plugins*. Basically, `EHCachePlugin` handles all
    the boilerplate required to use EHCache in an application and `EhCacheImpl` provides
    the methods to do so, such as `get`, `set`, and `remove`. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the plugin looks for `ehcache.xml` in the `conf` directory and,
    if the file does not exist, the default configuration provided by the `ehcache-default.xml`
    framework is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to specify the location of the `ehcache` configuration when
    starting the application using the `ehcache.configResource` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache API also simplifies handling a cache for results from requests on
    both the client and server side of the application. Adding `EXPIRES` and `etag`
    headers can be used to manipulate the client-side cache, while on the server side
    the results are cached so that its corresponding action is not computed for each
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can cache the result of the request used to fetch details of
    inactive users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, what if we want this to get updated every hour? We just need to specify
    the duration explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this is handled by the `Cached` case class and its companion object.
    The case class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The companion object provides commonly required methods to generate cached instances,
    such as cache action based on its status, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apply` method in cached calls the `build` method, which is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It simply checks if the result was modified or not. If it hasn''t been, it
    tries to get the result from the `Cache`. If the result does not exist in the
    cache, it fetches it from the action and adds it to the `Cache` using the `handleResult`
    method. The `handleResult` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If a duration is specified, it returns that else it returns the default duration
    of one year.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleResult` method simply takes the result, adds `etag`, expires headers,
    and then adds the result with the given key to `Cache`.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following section covers some common scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Anorm throws an error at the `SqlMappingError` runtime (too many rows when you're
    expecting a single one), even though the query resulted in expected behavior.
    It is an insert query using "on duplicate key update".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can happen when such a query is being executed using `executeInsert`.
    The `executeInsert` method should be used when we need to return an autogenerated
    key. If we are updating some fields through a duplicate key, it means that we
    do not actually need the key. We could use `executeUpdate` to add a check if one
    row has been updated. For example, we may want to update the wishlist table, which
    tracks what a user has wished for:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can we use multiple databases for a single application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, it is possible to use a different database of the same as well as a different
    kind. If an application requires this, we can use two or more different relational
    or NoSQL databases or a combination of both. For example, the application may
    store its user data in SQL (as we already know the format of the user data) and
    the information about THE user's devices in MongoDB (since the devices are from
    different vendors, the format of their data can change).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Anorm does not throw a compilation error when a query has an incorrect syntax.
    Is there a configuration to enable this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has been developed with the aim of using SQL queries in the code without
    any hassle. The developers are expected to pass correct queries to Anorm methods.
    To ensure that such errors do not occur at runtime, developers can execute the
    query locally and use it in the code if it succeeds. Alternatively, there are
    some third-party plugins that provide a typesafe DSL and can be used instead of
    Anorm if they meet the requirement, such as play-slick or scalikejdbc-play-support
    ([https://github.com/scalikejdbc/scalikejdbc-play-support](https://github.com/scalikejdbc/scalikejdbc-play-support))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Is it possible to use another caching mechanism?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, it is possible to extend support for any other cache, such as OSCache,
    SwarmCache, MemCached, and so on, or a custom one by writing a plugin similar
    to EHCachePlugin. Some of the popular caching mechanisms already have Play plugins
    developed by individuals and/or other organizations. For example, play2-memcached
    ([https://github.com/mumoshu/play2-memcached](https://github.com/mumoshu/play2-memcached))
    and Redis plugin ([https://github.com/typesafehub/play-plugins/tree/master/redis](https://github.com/typesafehub/play-plugins/tree/master/redis)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we saw different ways of persisting application data in an
    application built using the Play Framework. In doing so, we have seen two contrasting
    approaches: one using a relational DB and the other using a NoSQL DB. To persist
    in a relational DB, we looked at how the Anorm module and the JDBC plugin work.
    To use a NoSQL database (MongoDB) for our application''s backend, we used the
    Play plugin for ReactiveMongo. In addition to this, we saw how the Play Cache
    API can be used and how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning all about handling data streams in
    Play.
  prefs: []
  type: TYPE_NORMAL
