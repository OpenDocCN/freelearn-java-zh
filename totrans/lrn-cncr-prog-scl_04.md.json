["```java\ndef getWebpage(url: String): String \n\n```", "```java\ndef getWebpage(url: String): Future[String] \n\n```", "```java\ntrait Future[T] \n\n```", "```java\ndef apply[T](b: =>T)(implicit e: ExecutionContext): Future[T] \n\n```", "```java\nimport scala.concurrent._ \nimport ExecutionContext.Implicits.global \nobject FuturesCreate extends App { \n  Future { log(\"the future is here\") } \n  log(\"the future is coming\") \n  Thread.sleep(1000) \n} \n\n```", "```java\nimport scala.io.Source \nobject FuturesDataType extends App { \n  val buildFile: Future[String] = Future { \n    val f = Source.fromFile(\"build.sbt\") \n    try f.getLines.mkString(\"\\n\") finally f.close() \n  } \n  log(s\"started reading the build file asynchronously\") \n  log(s\"status: ${buildFile.isCompleted}\") \n  Thread.sleep(250) \n  log(s\"status: ${buildFile.isCompleted}\") \n  log(s\"value: ${buildFile.value}\") \n} \n\n```", "```java\nobject FuturesCallbacks extends App { \n  def getUrlSpec(): Future[List[String]] = Future { \n    val url = \"http://www.w3.org/Addressing/URL/url-spec.txt\" \n    val f = Source.fromURL(url) \n    try f.getLines.toList finally f.close() \n  } \n  val urlSpec: Future[List[String]] = getUrlSpec() \n\n```", "```java\n  def find(lines: List[String], keyword: String): String = lines.zipWithIndex collect { \n      case (line, n) if line.contains(keyword) => (n, line) \n    } mkString(\"\\n\") \n\n```", "```java\n  urlSpec foreach { \n    case lines => log(find(lines, \"telnet\")) \n  } \n  log(\"callback registered, continuing with other work\") \n  Thread.sleep(2000) \n\n```", "```java\n  urlSpec foreach { \n    case lines => log(find(lines, \"password\")) \n  } \n  Thread.sleep(1000) \n} \n\n```", "```java\nobject FuturesFailure extends App { \n  val urlSpec: Future[String] = Future { \n    val invalidUrl = \"http://www.w3.org/non-existent-url-spec.txt\" \n    Source.fromURL(invalidUrl).mkString \n  } \n  urlSpec.failed foreach { \n    case t => log(s\"exception occurred - $t\") \n  } \n  Thread.sleep(1000) \n} \n\n```", "```java\ndef handleMessage(t: Try[String]) = t match { \n  case Success(msg) => log(msg) \n  case Failure(error) => log(s\"unexpected failure - $error\") \n} \n\n```", "```java\nimport scala.util.{Try, Success, Failure} \nobject FuturesTry extends App { \n  val threadName: Try[String] = Try(Thread.currentThread.getName) \n  val someText: Try[String] = Try(\"Try objects are synchronous\") \n  val message: Try[String] = for { \n    tn <- threadName \n    st <- someText \n  } yield s\"Message $st was created on t = $tn\" \n  handleMessage(message) \n} \n\n```", "```java\nurlSpec onComplete { \n  case Success(txt) => log(find(txt)) \n  case Failure(err) => log(s\"exception occurred - $err\") \n} \n\n```", "```java\nobject FuturesNonFatal extends App { \n  val f = Future { throw new InterruptedException } \n  val g = Future { throw new IllegalArgumentException } \n  f.failed foreach { case t => log(s\"error - $t\") } \n  g.failed foreach { case t => log(s\"error - $t\") } \n} \n\n```", "```java\nf.failed foreach { \n  case NonFatal(t) => log(s\"$t is non-fatal!\") \n} \n\n```", "```java\nimport java.io._ \nimport org.apache.commons.io.FileUtils._ \nimport scala.collection.convert.decorateAsScala._ \n\n```", "```java\nlibraryDependencies += \"commons-io\" % \"commons-io\" % \"2.4\" \n\n```", "```java\nobject FuturesClumsyCallback extends App { \n  def blacklistFile(name: String): Future[List[String]] = Future { \n    val lines = Source.fromFile(name).getLines \n    lines.filter(x => !x.startsWith(\"#\") && !x.isEmpty).toList \n  } \n\n```", "```java\n  def findFiles(patterns: List[String]): List[String] = { \n    val root = new File(\".\") \n    for { \n      f <- iterateFiles(root, null, true).asScala.toList \n      pat <- patterns \n      abspat = root.getCanonicalPath + File.separator + pat \n      if f.getCanonicalPath.contains(abspat) \n    } yield f.getCanonicalPath \n  } \n\n```", "```java\n  blacklistFile(\".gitignore\") foreach { \n    case lines => \n      val files = findFiles(lines) \n      log(s\"matches: ${files.mkString(\"\\n\")}\") \n  } \n  Thread.sleep(1000) \n} \n\n```", "```java\ndef blacklisted(name: String): Future[List[String]] \n\n```", "```java\ndef map[S](f: T => S)(implicit e: ExecutionContext): Future[S] \n\n```", "```java\ndef blacklisted(name: String): Future[List[String]] = \n  blacklistFile(name).map(patterns => findFiles(patterns)) \n\n```", "```java\nval buildFile = Future {  \n  Source.fromFile(\"build.sbt\").getLines  \n} \n\nval longest = for (ls <- buildFile) yield ls.maxBy(_.length) \nlongest foreach { \n  case line => log(s\"longest line: $line\") \n} \n\n```", "```java\nval longest = buildFile.map(ls => ls.maxBy(_.length)) \n\n```", "```java\ndef flatMap[S](f: T => Future[S])(implicit e: ExecutionContext): \n  Future[S] \n\n```", "```java\nval netiquetteUrl = \"http://www.ietf.org/rfc/rfc1855.txt\" \nval netiquette = Future { Source.fromURL(netiquetteUrl).mkString } \nval urlSpecUrl = \"http://www.w3.org/Addressing/URL/url-spec.txt\" \nval urlSpec = Future { Source.fromURL(urlSpecUrl).mkString } \nval answer = netiquette.flatMap { nettext => \n  urlSpec.map { urltext => \n    \"Check this out: \" + nettext + \". And check out: \" + urltext \n  } \n} \nanswer foreach { case contents => log(contents) } \n\n```", "```java\nval answer = for { \n  nettext <- netiquette \n  urltext <- urlSpec \n} yield { \n  \"First, read this: \" + nettext + \". Now, try this: \" + urltext \n} \n\n```", "```java\nval answer = for { \n  nettext <- Future { Source.fromURL(netiquetteUrl).mkString } \n  urltext <- Future { Source.fromURL(urlSpecUrl).mkString } \n} yield { \n  \"First, read this: \" + nettext + \". Now, try this: \" + urltext \n} \n\n```", "```java\ndef recover(pf: PartialFunction[Throwable, T]) \n  (implicit e: ExecutionContext): Future[T] \n\n```", "```java\nval netiquetteUrl = \"http://www.ietf.org/rfc/rfc1855.doc\" \nval netiquette = Future { Source.fromURL(netiquetteUrl).mkString } \nval answer = netiquette recover { \n  case e: java.io.FileNotFoundException => \n    \"Dear secretary, thank you for your e-mail.\" + \n    \"You might be interested to know that ftp links \" + \n    \"can also point to regular files we keep on our servers.\" \n} \nanswer foreach { case contents => log(contents) } \nThread.sleep(2000) \n\n```", "```java\ndef apply[T](): Promise[T] \n\n```", "```java\nobject PromisesCreate extends App { \n  val p = Promise[String] \n  val q = Promise[String] \n  p.future foreach { case x => log(s\"p succeeded with '$x'\") } \n  Thread.sleep(1000) \n  p success \"assigned\" \n  q failure new Exception(\"not kept\") \n  q.future.failed foreach { case t => log(s\"q failed with $t\") } \n  Thread.sleep(1000) \n} \n\n```", "```java\nimport scala.util.control.NonFatal \nobject PromisesCustomAsync extends App { \n  def myFuture[T](b: =>T): Future[T] = { \n    val p = Promise[T] \n    global.execute(new Runnable { \n      def run() = try { \n        p.success(b) \n      } catch { \n        case NonFatal(e) => p.failure(e) \n      } \n    }) \n    p.future \n  } \n  val f = myFuture { \"naa\" + \"na\" * 8 + \" Katamari Damacy!\" } \n  f foreach { case text => log(text) } \n} \n\n```", "```java\nimport org.apache.commons.io.monitor._ \n\n```", "```java\ndef fileCreated(directory: String): Future[String] = { \n  val p = Promise[String] \n  val fileMonitor = new FileAlterationMonitor(1000) \n  val observer = new FileAlterationObserver(directory) \n  val listener = new FileAlterationListenerAdaptor { \n    override def onFileCreate(file: File): Unit = \n      try p.trySuccess(file.getName) finally fileMonitor.stop() \n  } \n  observer.addListener(listener) \n  fileMonitor.addObserver(observer) \n  fileMonitor.start() \n  p.future \n} \n\n```", "```java\nfileCreated(\".\") foreach { \n  case filename => log(s\"Detected new file '$filename'\") \n} \n\n```", "```java\nimport java.util._ \nprivate val timer = new Timer(true) \n\n```", "```java\ndef timeout(t: Long): Future[Unit] = { \n  val p = Promise[Unit] \n  timer.schedule(new TimerTask { \n    def run() = { \n      p success () \n      timer.cancel() \n    } \n  }, t) \n  p.future \n} \ntimeout(1000) foreach { case _ => log(\"Timed out!\") } \nThread.sleep(2000) \n\n```", "```java\ndef or(that: Future[T]): Future[T] \n\n```", "```java\nimplicit class FutureOps[T](val self: Future[T]) { \n  def or(that: Future[T]): Future[T] = { \n    val p = Promise[T] \n    self onComplete { case x => p tryComplete x } \n    that onComplete { case y => p tryComplete y } \n    p.future \n  } \n} \n\n```", "```java\nval f = timeout(1000).map(_ => \"timeout!\") or Future { \n  Thread.sleep(999) \n  \"work completed!\" \n} \n\n```", "```java\nobject PromisesCancellation extends App { \n  type Cancellable[T] = (Promise[Unit], Future[T]) \n\n```", "```java\n  def cancellable[T](b: Future[Unit] => T): Cancellable[T] = { \n    val cancel = Promise[Unit] \n    val f = Future { \n      val r = b(cancel.future) \n      if (!cancel.tryFailure(new Exception)) \n        throw new CancellationException \n      r \n    } \n    (cancel, f) \n  } \n\n```", "```java\n  val (cancel, value) = cancellable { cancel => \n    var i = 0 \n    while (i < 5) { \n      if (cancel.isCompleted) throw new CancellationException \n      Thread.sleep(500) \n      log(s\"$i: working\") \n      i += 1 \n    } \n    \"resulting value\" \n  } \n\n```", "```java\n  Thread.sleep(1500) \n  cancel trySuccess () \n  log(\"computation cancelled!\") \n  Thread.sleep(2000) \n} \n\n```", "```java\nimport scala.concurrent.duration._ \nobject BlockingAwait extends App { \n  val urlSpecSizeFuture = Future { \n    val specUrl = \"http://www.w3.org/Addressing/URL/url-spec.txt\" \n    Source.fromURL(specUrl).size \n  } \n  val urlSpecSize = Await.result(urlSpecSizeFuture, 10.seconds) \n  log(s\"url spec contains $urlSpecSize characters\") \n} \n\n```", "```java\nval startTime = System.nanoTime \nval futures = for (_ <- 0 until 16) yield Future { \n  Thread.sleep(1000) \n} \nfor (f <- futures) Await.ready(f, Duration.Inf) \nval endTime = System.nanoTime \nlog(s\"Total time = ${(endTime - startTime) / 1000000} ms\") \nlog(s\"Total CPUs = ${Runtime.getRuntime.availableProcessors}\") \n\n```", "```java\n  val futures = for (_ <- 0 until 16) yield Future { \n    blocking { \n      Thread.sleep(1000) \n    } \n  } \n\n```", "```java\nlibraryDependencies += \n  \"org.scala-lang.modules\" %% \"scala-async\" % \"0.9.1\" \n\n```", "```java\ndef delay(n: Int): Future[Unit] = async { \n  blocking { Thread.sleep(n * 1000) } \n} \n\n```", "```java\nasync { \n  log(\"T-minus 1 second\") \n  await { delay(1) } \n  log(\"done!\") \n} \n\n```", "```java\nFuture { \n  log(\"T-minus 1 second\") \n  delay(1) foreach { \n    case x => log(\"done!\") \n  } \n} \n\n```", "```java\ndef countdown(n: Int)(f: Int => Unit): Future[Unit] = async { \n  var i = n \n  while (i > 0) { \n    f(i) \n    await { delay(1) } \n    i -= 1 \n  } \n} \n\n```", "```java\ncountdown(10) { n => log(s\"T-minus $n seconds\") } foreach { \n  case _ => log(s\"This program is over!\") \n} \n\n```", "```java\nlibraryDependencies += \n  \"org.scalaz\" %% \"scalaz-concurrent\" % \"7.0.6\" \n\n```", "```java\nimport scalaz.concurrent._ \nobject Scalaz extends App { \n  val tombola = Future { \n    scala.util.Random.shuffle((0 until 10000).toVector) \n  } \n  tombola.runAsync { numbers => \n    log(s\"And the winner is: ${numbers.head}\") \n  } \n  tombola.runAsync { numbers => \n    log(s\"... ahem, winner is: ${numbers.head}\") \n  } \n} \n\n```", "```java\nval tombola = Future { \n  scala.util.Random.shuffle((0 until 10000).toVector) \n} start \n\n```", "```java\n                class IVar[T] { \n                  def apply(): T = ??? \n                  def :=(x: T): Unit = ??? \n                } \n\n    ```", "```java\n                def exists(p: T => Boolean): Future[Boolean] \n\n    ```", "```java\n                def spawn(command: String): Future[Int] \n\n    ```", "```java\n                class IMap[K, V] { \n                  def update(k: K, v: V): Unit \n                  def apply(k: K): Future[V] \n                } \n\n    ```", "```java\n                def compose[S](f: S => T): Promise[S] \n\n    ```", "```java\n                def scatterGather[T](tasks: Seq[() => T]): Future[Seq[T]] \n\n    ```", "```java\n                class DAG[T](val value: T) { \n                  val edges = scala.collection.mutable.Set[DAG[T]] \n                } \n\n    ```", "```java\n                val a = new DAG(\"a\") \n                val b = new DAG(\"b\") \n                val c = new DAG(\"c\") \n                val d = new DAG(\"d\") \n                val e = new DAG(\"e\") \n                a.edges += b \n                b.edges += c \n                b.edges += d \n                c.edges += e \n                d.edges += e \n\n    ```", "```java\n                def fold[T, S](g: DAG[T], f: (T, Seq[S]) => S): Future[S] \n\n    ```"]