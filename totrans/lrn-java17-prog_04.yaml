- en: '*Chapter 3*: Java Fundamentals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents to you a more detailed view of Java as a language. It
    starts with code organization in packages and a description of accessibility levels
    of classes (interfaces) and their methods and properties (fields). Reference types,
    as the main types of a Java object-oriented nature, are also presented in detail,
    followed by a list of reserved and restricted keywords and a discussion of their
    usage. The chapter ends with the methods of conversion between different primitive
    types and from a primitive type to a corresponding reference type and back.
  prefs: []
  type: TYPE_NORMAL
- en: These are the fundamental terms and features of the Java language. The importance
    of understanding them cannot be overstated. Without them, you cannot write any
    Java program. So, try not to rush through this chapter and make sure you understand
    everything presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Packages, importing, and access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved and restricted keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of the `this` and `super` keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between primitive and reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or a code editor you prefer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and an IntelliJ IDEA editor were
    provided in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started
    with Java 17*, of this book. The files with the code examples for this chapter
    are available in the GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch03_fundamentals` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Packages, importing, and access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already know, a package name reflects a directory structure, starting
    with the project directory that contains the `.java` files. The name of each `.java`
    file has to be the same as the name of the top-level class declared in it (this
    class can contain other classes). The first line of the `.java` file is the package
    statement that starts with the `package` keyword, followed by the actual package
    name – the directory path to this file in which slashes are replaced with dots.
  prefs: []
  type: TYPE_NORMAL
- en: A package name and the class name together compose a **fully qualified class
    name**. It uniquely identifies the class but tends to be too long and inconvenient
    to use. This is when **importing** comes to the rescue by allowing specification
    of the fully qualified name only once, and then referring to the class only by
    the class name.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a method of a class from the method of another class is possible only
    if a caller has access to that class and its methods. The `public`, `protected`,
    and `private` access modifiers define the level of accessibility and allow (or
    disallow) some methods, properties, or even the class itself to be visible to
    other classes.
  prefs: []
  type: TYPE_NORMAL
- en: All these aspects will be discussed in detail in the current section.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the class we called `Packages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the `Packages` class is a package declaration that identifies
    the class location on the source tree or, in other words, the `.java` file location
    in a filesystem. When the class is compiled and its `.class` file with bytecode
    is generated, the package name also reflects the `.class` file location in the
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Importing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the package declaration, the `import` statements follow. As you can see
    from the previous example, they allow you to avoid using the fully qualified class
    (or interface) name anywhere else in the current class (or interface). When many
    classes (or interfaces) from the same package are imported, it is possible to
    import all classes and interfaces from the same package as a group, using the
    `*` symbol. In our example, it would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'But that is not a recommended practice as it hides away the imported class
    (or interface) location when several packages are imported as a group. For example,
    look at this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, can you guess the package to which class `C` or class
    `D` belongs? Also, it is possible that two classes in different packages have
    the same name. If that is the case, group importing can create a degree of confusion
    or even a problem that’s difficult to nail down.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to import an individual static class (or interface) members.
    For example, if `SomeInterface` has a `NAME` property (as a reminder, interface
    properties are public and static by default), you can typically refer to it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid using even the interface name, you can use a static import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if `SomeClass` has a public static property, `someProperty`, and
    a public static method, `someMethod()`, it is possible to import them statically
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: But this technique should be used wisely, since it may create the impression
    that a statically imported method or property belongs to the current class.
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already used in our examples the three access modifiers –`public`, `protected`,
    and `private` – which regulate access to the classes, interfaces, and their members
    from outside – from other classes or interfaces. There is also a fourth implicit
    one (also called the **default modifier package-private**) that is applied when
    none of the three explicit access modifiers is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of their usage is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: Accessible to other classes and interfaces of the current and other
    packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: Accessible only to other members of the same package and children
    of the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'no access modifier: Accessible only to other members of the same package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: Accessible only to members of the same class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From inside the class or an interface, all the class or interface members are
    always accessible. Besides, as we have stated several times already, all interface
    members are public by default, unless declared as `private`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, please note that class accessibility supersedes the class members’ accessibility
    because, if the class itself is not accessible from somewhere, no change in the
    accessibility of its methods or properties can make them accessible.
  prefs: []
  type: TYPE_NORMAL
- en: When people talk about access modifiers for classes and interfaces, they mean
    the classes and interfaces that are declared inside other classes or interfaces.
    The encompassing class or interface is called a top-level class or interface,
    while those inside them are called inner classes or interfaces. The static inner
    classes are also called static nested classes.
  prefs: []
  type: TYPE_NORMAL
- en: It does not make sense to declare a top-level class or interface `private` because
    it will not be accessible from anywhere. And the Java authors decided against
    allowing the top-level class or interface to be declared `protected` too. It is
    possible, though, to have a class without an explicit access modifier, thus making
    it accessible only to members of the same package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Please note that static nested classes do not have access to other members of
    the top-level class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another particular feature of an inner class is that it has access to all,
    even private members, of the top-level class, and vice versa. To demonstrate this
    feature, let’s create the following private properties and methods in the top-level
    class and in a `private` inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the methods and properties in the previous classes are private,
    which means that normally, they are not accessible from outside the class. And
    that is true for the `AccessModifiers` class – its private methods and properties
    are not accessible for other classes that are declared outside of it. But the
    `InnerClass` class can access the private members of the top-level class, while
    the top-level class can access the private members of its inner classes. The only
    limitation is that a non-static inner class cannot have static members. By contrast,
    a static nested class can have both static and non-static members, which makes
    a static nested class much more usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate all the possibilities described, we will add the following `main()`
    method to the `AccessModifiers` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, a non-static inner class cannot be accessed from a static context
    of the top-level class, hence the `compiler error` comment in the preceding code.
    If we run it, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_3.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first two lines of the output come from `topLevelPrivateMethod()`, and the
    rest from the `main()` method. As you can see, an inner- and a top-level class
    can access each other’s private state, inaccessible from outside.
  prefs: []
  type: TYPE_NORMAL
- en: Java reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `new` operator creates an object of a class and returns the reference to the
    memory where the object resides. From a practical standpoint, the variable that
    holds this reference is treated in the code as if it is the object itself. Such
    a variable can be a class, an interface, an array, or a `null` literal that indicates
    that no memory reference is assigned to the variable. If the type of reference
    is an interface, it can be assigned either `null` or a reference to the object
    of the class that implements this interface because the interface itself cannot
    be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: A JVM watches for all the created objects and checks whether there are references
    to each of them in the currently executed code. If there is an object without
    any reference to it, JVM removes it from the memory in a process called **garbage
    collection**. We will describe this process in [*Chapter 9*](B18388_09_ePub.xhtml#_idTextAnchor205),
    *JVM Structure and Garbage Collection*. For example, an object was created during
    a method execution and was referred to by the local variable. This reference will
    disappear as soon as the method finishes its execution.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen the examples of custom classes and interfaces, and we have talked
    about the `String` class already (see [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*). In this section, we will also describe two other
    Java reference types – array and enum – and demonstrate how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Class and interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable of a class type is declared using the corresponding class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The value that can be assigned to such a variable can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `null` literal reference type (which means the variable can be used but does
    not refer to any object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to an object of the same class or any of its descendants (because
    a descendant inherits the types of all of its ancestors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This last type of assignment is called a `java.lang.Object`, the following
    assignment can be done for any class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Such an assignment is also called an **upcasting** because it moves the type
    of the variable up on the line of inheritance (which, like any family tree, is
    usually presented with the oldest ancestor at the top).
  prefs: []
  type: TYPE_NORMAL
- en: 'After such an upcasting, it is possible to make a narrowing assignment using
    a `(type)` cast operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Such an assignment is also called `instanceof` operator (see [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*) to check the reference type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if a class implements a certain interface, its object reference
    can be assigned to this interface or any ancestor of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, as in the case with class reference upcasting and downcasting,
    it is possible to recover the original type of the object after its reference
    was assigned to a variable of one of the implemented interface types.
  prefs: []
  type: TYPE_NORMAL
- en: The material of this section can also be viewed as another demonstration of
    Java polymorphism in action.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `java.lang.Object` class too. The array elements have the same type as the
    declared array type. The number of elements may be zero, in which case the array
    is said to be an empty array. Each element can be accessed by an index, which
    is a positive integer or zero. The first element has an index of zero. The number
    of elements is called an array length. Once an array is created, its length never
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of an array declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Each bracket pair indicates another dimension. The number of bracket pairs
    is the nesting depth of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new` operator allocates memory for each element that can be assigned (filled
    with) a value later. But in my case, the elements of an array are initialized
    to the default values at creation time, as the following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to create an array is to use an array initializer – a comma-separated
    list of values enclosed in braces for each dimension, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'A multidimensional array can be created without declaring the length of each
    dimension. Only the first dimension has to have the length specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The missing length of other dimensions can be specified later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, it is possible to assign a different length to different dimensions.
    Using the array initializer, it is also possible to create dimensions of different
    lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The only requirement is that a dimension has to be initialized before it can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Enum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.lang.Enum` class, which, in turn, extends `java.lang.Object`. It
    allows the specification of a limited set of constants, each of them an instance
    of the same type. The declaration of such a set starts with the `enum` keyword.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Each of the listed items – `SPRING`, `SUMMER`, `AUTUMN`, and `WINTER` – is an
    instance of a `Season` type. They are the only four instances the `Season` class
    can have. They are created in advance and can be used everywhere as a value of
    a `Season` type. No other instance of the `Season` class can be created, and that
    is the reason for the creation of the `enum` type – it can be used for cases when
    the list of instances of a class has to be limited to the fixed set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` declaration can also be written in title case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: However, the all-capitals style is used more often because, as we mentioned
    earlier, there is a convention to express the static final constant’s identifier
    in a capital case. It helps to distinguish constants from variables. The `enum`
    constants are implicitly static and final.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `enum` values are constants, they exist uniquely in a JVM and can
    be compared by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the most frequently used methods of the `java.lang.Enum`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name()`: Returns the `enum` constant’s identifier as it is spelled when declared
    (`WINTER`, for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`: Returns the same value as the `name()` method by default but
    can be overridden to return any other `String` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordinal()`: Returns the position of the `enum` constant when declared (the
    first in the list has a `0` ordinal value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueOf(Class enumType, String name)`: Returns the `enum` constant object
    by its name, expressed as a `String` literal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: A static method, described in the documentation of the `valueOff()`
    method as follows: “All the constants of an `enum` class can be obtained by calling
    the implicit `public static T[] values()` method of that class.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the preceding methods, we are going to use the already familiar
    `enum`, `Season`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'To override the `toString()` method, let’s create the `Season1` `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to add any other property to each `enum` constant. For example,
    let’s add an average temperature value to each `enum` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'If we iterate over values of the `Season2` `enum`, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: In the standard Java libraries, there are several `enum` classes – for example,
    `java.time.Month`, `java.time.DayOfWeek`, and `java.util.concurrent.TimeUnit`.
  prefs: []
  type: TYPE_NORMAL
- en: Default values and literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen, the default value of a reference type is `null`. Some
    sources call it a `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The only reference type that has a literal other than the `null` literal is
    the `String` class. We discussed strings in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*.
  prefs: []
  type: TYPE_NORMAL
- en: A reference type as a method parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a primitive type value is passed into a method, we use it. If we do not
    like the value passed into the method, we change it as we see fit and do not think
    twice about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'We have no concerns that the variable value outside the method may change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to change the parameter value of a primitive type outside
    the method because a primitive type parameter is passed into the method by value.
    This means that the copy of the value is passed into the method, so even if the
    code inside the method assigns a different value to it, the original value is
    not affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another issue with a reference type is that even though the reference itself
    is passed by value, it still points to the same original object in the memory,
    so the code inside the method can access the object and modify it. To demonstrate
    it, let’s create a `DemoClass` and the method that uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the preceding method, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: That’s a big difference, isn’t it? So, you have to be careful not to modify
    the passed-in object in order to avoid an undesirable effect. However, this effect
    is occasionally used to return the result. But it does not belong to the list
    of best practices because it makes code less readable. Changing the passed-in
    object is like using a secret tunnel that is difficult to notice. So, use it only
    when you have to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the passed-in object is a class that wraps a primitive value, this
    effect still holds (we will talk about the primitive values wrapping type in the
    *Converting between primitive and reference types* section). Here is `DemoClass1`
    and an overloaded version of the `modifyParameter()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the preceding method, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The only exception to this behavior of reference types is an object of the
    `String` class. Here is another overloaded version of the `modifyParameter()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the preceding method, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, whether we use a literal or a new `String` object, the result
    remains the same – the original `String` value is not changed after the method
    that assigns another value to it. That is exactly the purpose of the `String`
    value immutability feature we discussed in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*.
  prefs: []
  type: TYPE_NORMAL
- en: equals() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The equality operator (`==`), when applied to the variables of reference types,
    compares the references themselves, not the content (the state) of the objects.
    But two objects always have different memory references even if they have identical
    content. Even when used for `String` objects, the operator (`==`) returns `false`
    if at least one of them is created using a `new` operator (see the discussion
    about `String` value immutability in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*).
  prefs: []
  type: TYPE_NORMAL
- en: To compare content, you can use the `equals()` method. Its implementation in
    the `String` class and numerical type wrapper classes (`Integer`, `Float`, and
    so on) does exactly that – compare the content of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `equals()` method implementation in the `java.lang.Object` class
    compares only references, which is understandable because the variety of possible
    content the descendants can have is huge, and the implementation of the generic
    content comparison is just not feasible. This means that every Java object that
    needs to have the `equals()` method comparing the object’s content – not just
    references – has to re-implement the `equals()` method and, thus, override its
    implementation in the `java.lang.Object` class, which appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, look at how the same method is implemented in the `Integer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it extracts the primitive `int` value from the input object
    and compares it to the primitive value of the current object. It does not compare
    object references at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `String` class, on the other hand, compares the references first and, if
    the references are not the same value, compares the content of the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: The `StringLatin1.equals()` and `StringUTF16.equals()` methods compare the values
    character by character, not just references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if the application code needs to compare two objects by their content,
    the `equals()` method in the corresponding class has to be overridden. For example,
    let’s look at the familiar `DemoClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add to it the `equals()` method manually, but the IDE can help us to
    do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click inside the class just before the closing brace (`}`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Generate** and then follow the prompts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Eventually, two methods will be generated and added to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the generated code, focus your attention on the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The usage of the `@Override` annotation – this ensures that the method does
    override a method (with the same signature) in one of the ancestors. With this
    annotation in place, if you modify the method and change the signature (by mistake
    or intentionally), the compiler (and your IDE) will immediately raise an error,
    telling you that there is no method with such a signature in any of the ancestor
    classes. So, it helps to detect an error early.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usage of the `java.util.Objects` class – this has quite a few very helpful
    methods, including the `equals()` static method that not only compares references
    but also uses the `equals()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we have demonstrated earlier, the `equals()` method, implemented in the `String`
    class, compares strings by their content and serves this purpose because the `getProp()`
    method of `DemoClass` returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: The `hashCode()` method – the integer returned by this method uniquely identifies
    this particular object (but please do not expect it to be the same between different
    runs of the application). It is not necessary to have this method implemented
    if the only method needed is `equals()`. Nevertheless, it is recommended to have
    it just in case the object of this class is going to be collected in `Set` or
    another collection based on a hash code (we are going to talk about Java collections
    in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*).
  prefs: []
  type: TYPE_NORMAL
- en: Both these methods are implemented in `Object` because many algorithms use the
    `equals()` and `hashCode()` methods, and your application may not work without
    these methods implemented. Meanwhile, your objects may not need them in your application.
    However, once you decide to implement the `equals()` method, it is a good idea
    to implement the `hasCode()` method too. Besides, as you have seen, an IDE can
    do this without any overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved and restricted keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **keywords** are the words that have particular meaning for a compiler and
    cannot be used as identifiers. As of Java 17, there are 52 reserved keywords,
    5 reserved identifiers, 3 reserved words, and 10 restricted keywords. The reserved
    keywords cannot be used as identifiers anywhere in the Java code, while the restricted
    keywords cannot be used as identifiers only in the context of a module declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of all Java-reserved keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Table_3.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By now, you should feel at home with most of the preceding keywords. By way
    of an exercise, you can go through the list and check how many of them you remember.
    Up until now, we have not discussed the following eight keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` and `goto` are reserved but not used, so far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assert` keyword is used in an `assert` statement (we will talk about this
    in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110), *Exception Handling*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `synchronized` keyword is used in concurrent programming (we will talk about
    this in [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187), *Multithreading
    and Concurrent Processing*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `volatile` keyword makes the value of a variable uncacheable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `transient` keyword makes the value of a variable not serializable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `strictfp` keyword restricts floating-point calculations, making it the
    same result on every platform while performing operations in the floating-point
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `native` keyword declares a method implemented in platform-dependent code,
    such as C or C++.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The five reserved identifiers in Java are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`permits`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`record`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sealed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved words for literal values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three reserved words in Java are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricted keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 10 restricted keywords in Java are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requires`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transitive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opens`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uses`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provides`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are called *restricted* because they cannot be identifiers in the context
    of a module declaration, which we will not discuss in this book. In all other
    places, it is possible to use them as identifiers, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Although you can, it is a good practice not to use them as identifiers, even
    outside module declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the this and super keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `this` keyword provides a reference to the current object. The `super` keyword
    refers to the parent class object. These keywords allow us to refer to a variable
    or method that has the same name in the current context and the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the this keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the most popular example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line looks ambiguous, but, in fact, it is not – the local variable,
    `int count`, hides the `int count` private property instance. We can demonstrate
    this by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `this` keyword fixes the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Adding `this` to line `1` allows the value to be assigned the instance property.
    Adding `this` to line `2` does not make a difference, but it is good practice
    to use the `this` keyword every time with the `instance` property. It makes the
    code more readable and helps avoid difficult-to-trace errors, such as the one
    we have just demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also seen the `this` keyword usage in the `equals()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'And, just to remind you, here are the examples of a constructor that we presented
    in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented
    Programming (OOP)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see not only the `this` keyword but also the
    usage of the `super` keyword, which we are going to discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the super keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `super` keyword refers to the parent object. We saw its usage in the *Usage
    of the this keyword* section in a constructor already, where it has to be used
    only in the first line because the parent class object has to be created before
    the current object can be created. If the first line of the constructor is not
    `super()`, this means the parent class has a constructor without parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `super` keyword is especially helpful when a method is overridden and the
    method of the parent class has to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: As we progress through this book, we will see more examples of using the `this`
    and `super` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maximum numeric value that a numeric type can hold depends on the number
    of bits allocated to it. The following are the number of bits for each numeric
    type of representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: 8 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: 16 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: 16 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: 32 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: 64 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: 32 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: 64 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a value of one numeric type is assigned to a variable of another numeric
    type and the new type can hold a bigger number, such a conversion is called a
    `cast` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Widening conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the Java Language Specification, there are 19 widening primitive
    type conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte` to `short`, `int`, `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short` to `int`, `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` to `int`, `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` to `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long` to `float` or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` to `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During widening conversion between integral types, and from some integral types
    to a floating-point type, the resulting value matches the original one exactly.
    However, conversion from `int` to `float`, from `long` to `float`, or from `long`
    to `double` may result in a loss of precision. The resulting floating-point value
    may be correctly rounded using `IEEE 754 round-to-nearest mode`, according to
    the Java Language Specification. Here are a few examples that demonstrate the
    loss of precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, conversion from `int` to `double` preserves the value, but `long`
    to `float`, or `long` to `double`, may lose precision. It depends on how big the
    value is. So, be aware and allow for some loss of precision if it is important
    for your calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java Language Specification identifies 22 narrowing primitive conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`short` to `byte` or `char`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` to `byte` or `short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` to `byte`, `short`, or `char`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long` to `byte`, `short`, `char`, or `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` to `byte`, `short`, `char`, `int`, or `long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` to `byte`, `short`, `char`, `int`, `long`, or `float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to the widening conversion, a narrowing conversion may result in a
    loss of precision, or even in a loss of the value magnitude. The narrowing conversion
    is more complicated than a widening one, and we are not going to discuss it in
    this book. It is important to remember that before performing a narrowing, you
    must make sure that the original value is smaller than the maximum value of the
    target type. Otherwise, you can get a completely different value (with lost magnitude).
    Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the examples, without checking first whether the target
    type can accommodate the value, you can get the result just equal to the maximum
    value of the target type. The rest will be just lost, no matter how big the difference
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Before performing a narrowing conversion, check whether the maximum value of
    the target type can hold the original value.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the conversion between the `char` type and the `byte` or `short`
    types is an even more complicated procedure because the `char` type is an unsigned
    numeric type, while the `byte` and `short` types are signed numeric types, so
    some loss of information is possible even when a value may look as though it fits
    in the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the casting, each primitive type has a corresponding reference
    type (called a `boolean` and `char`. All the wrapper classes belong to the `java.lang`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang.Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Byte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Character`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Integer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of them – except the `Boolean` and `Character` classes – extends the `java.lang.Number`
    abstract class, which has the following abstract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byteValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shortValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`floatValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doubleValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such design forces the descendants of the `Number` class to implement all of
    them. The results they produce are the same as the `cast` operator in the previous
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, each of the wrapper classes has methods that allow the conversion
    of the `String` representation of a numeric value to the corresponding primitive
    numeric type or reference type, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: In the examples, please note the two methods that accept the `property` parameter.
    These two and similar methods of other wrapper classes convert a system property
    (if one exists) to the corresponding primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the wrapper classes has the `toString(primitive value)` static method
    to convert the primitive type value to its `String` representation, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: The wrapper classes have many other useful methods of conversion from one primitive
    type to another and to different formats. So, if you need to do something such
    as that, look into the corresponding wrapper class first.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between primitive and reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The conversion of a primitive type value to an object of the corresponding wrapper
    class is called **boxing**. Also, the conversion from an object of a wrapper class
    to the corresponding primitive type value is called **unboxing**.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The boxing of a primitive type can be done either automatically (called `valueOf()`
    method available in each wrapper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: Note that autoboxing is only possible in relation to a corresponding wrapper
    type. Otherwise, the compiler generates an error.
  prefs: []
  type: TYPE_NORMAL
- en: The input value of the `valueOf()` method of the `Byte` and `Short` wrappers
    required casting because it was a narrowing of a primitive type we discussed in
    the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unboxing can be accomplished using methods of the `Number` class implemented
    in each wrapper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the comment in the example, the conversion from a wrapper
    type to the corresponding primitive type is not called **auto-unboxing**; it is
    called **implicit unboxing** instead. In contrast to autoboxing, it is possible
    to use implicit unboxing even between wrapping and primitive types that do not
    match.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what Java packages are and the role they play in
    organizing code and class accessibility, including the `import` statement and
    access modifiers. You also became familiar with reference types – classes, interfaces,
    arrays, and enums. The default value of any reference type is `null`, including
    the `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: You should now understand that the reference type is passed into a method by
    reference and how the `equals()` method is used and can be overridden. You also
    had an opportunity to study the full list of reserved and restricted keywords
    and learned the meaning and usage of the `this` and `super` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter concluded by describing the process and methods of conversion between
    primitive types, wrapping types, and `String` literals.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about the Java exceptions framework, checked
    and unchecked (runtime) exceptions, `try-catch-finally` blocks, `throws` and `throw`
    statements, and the best practices of exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Package` statement describes the class or interface location.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Package` statement describes the class or interface name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Package` is a fully qualified name.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Package` name and class name compose a fully qualified name of the class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Import` statement allows the use of the fully qualified name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Import` statement has to be the first in the `.java` file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Group import` statement brings in the classes (and interfaces) of one package
    only.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Import statement` allows the use of the fully qualified name to be avoided.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without an access modifier, the class is accessible only by other classes and
    interfaces of the same package.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The private method of a private class is accessible to other classes declared
    in the same `.java` file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The public method of a private class is accessible to other classes not declared
    in the same `.java` file but from the same package.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The protected method is accessible only to the descendants of the class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Private methods can be overloaded but not overridden.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Protected methods can be overridden but not overloaded.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods without an access modifier can be both overridden and overloaded.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Private methods can access private properties of the same class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Narrowing and downcasting are synonyms.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Widening and downcasting are synonyms.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Widening and upcasting are synonyms.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Widening and narrowing have nothing in common with upcasting and downcasting.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Array` is an object.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Array` has a length that is a number of the elements it can hold.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The first element of an array has the index 1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second element of an array has the index 1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Enum` contains constants.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Enum` always has a constructor, either default or explicit.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An `enum` constant can have properties.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Enum` can have constants of any reference type.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any reference type passed in as a parameter can be modified.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `new String()` object passed in as a parameter can be modified.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An object reference value passed in as a parameter cannot be modified.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An array passed in as a parameter can have elements assigned to different values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reserved keywords cannot be used.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Restricted keywords cannot be used as identifiers.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A reserved `identifier` keyword cannot be used as an identifier.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A reserved keyword cannot be used as an identifier.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `this` keyword refers to the `current` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `super` keyword refers to the `super` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `this` and `super` keywords refer to objects.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `this` and `super` keywords refer to methods.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The widening of a primitive type makes the value bigger.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The narrowing of a primitive type always changes the type of the value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The widening of a primitive type can be done only after narrowing a conversion.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Narrowing makes the value smaller.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boxing puts a limit on the value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unboxing creates a new value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Boxing creates a reference-type object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unboxing deletes a reference-type object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
