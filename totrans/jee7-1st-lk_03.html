<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;The Presentation Layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. The Presentation Layer</h1></div></div></div><p>In this chapter, we will review the improvements in the Java EE platform for the presentation layer. In concrete terms, we are going to talk about the following specifications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Servlet 3.1</li><li class="listitem" style="list-style-type: disc">Expression Language 3.0</li><li class="listitem" style="list-style-type: disc">JavaServer Faces 2.2</li></ul></div><div class="section" title="Servlet 3.1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Servlet 3.1</h1></div></div></div><p>The Servlet 3.1 Specification was developed <a id="id126" class="indexterm"/>under JSR 340. This section gives you only an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html</a>.</p><div class="section" title="What is a Servlet?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>What is a Servlet?</h2></div></div></div><p>There was a time in computer science <a id="id127" class="indexterm"/>when we could not create dynamic web pages. At that time, users had access only to static web pages, such as in a newspaper. Among the many proposed solutions, the first Java solution was the <span class="strong"><strong>Servlet</strong></span>, a revolutionary technology used to extend the capabilities of servers based on the request-response programming model. It enabled web servers to handle http requests and dynamically generate web pages according to user parameters. Since then, technologies have advanced a lot in order to facilitate the development of web applications. However, the Servlet technology remains the most widely used Java solution for processing of HTTP requests/responses in the background.</p><p>That said, at the base of almost all Java frameworks dedicated to the HTTP protocol (JSF, Struts, Spring MVC, BIRT, web services solutions), you will find at least one Servlet (that is, you have <code class="literal">FacesServlet</code> in JSF, <code class="literal">ViewerServlet</code>, and the <code class="literal">BirtEngineServlet</code> for BIRT). You understand why this technology should attract our attention, because a change in the Servlet specification will have repercussions on a multitude of tools.</p><div class="section" title="A login page with a Servlet"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec15"/>A login page with a Servlet</h3></div></div></div><p>Concretely, a Servlet is a Java <a id="id128" class="indexterm"/>class that implements the Servlet interface directly or indirectly. The following code represents an example of a Servlet that returns a connection interface to the user and redirects it to another interface after validating its input:</p><div class="informalexample"><pre class="programlisting">@WebServlet(name = "connexionServlet", urlPatterns = {"/connexionServlet"})
public class ConnexionServlet extends HttpServlet {

    Logger logger = Logger.getLogger(ConnexionServlet.class.getName());
    
    protected void processRequest(HttpServletRequest request, HttpServletResponse response) {
        response.setContentType("text/html;charset=UTF-8");       
        try (PrintWriter out = response.getWriter();){
            out.println("&lt;!DOCTYPE html&gt;");
            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;Online pre-registration site&lt;/title&gt;");            
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");
            out.write("        &lt;form method=\"post\"&gt;");
            out.write("            &lt;h4&gt;Your name&lt;/h4&gt;");
            out.write("            &lt;input type=\"text\" name=\"param1\" /&gt;");
            out.write("            &lt;h4&gt;Your password&lt;/h4&gt;");
            out.write("            &lt;input type=\"password\" name=\"param2\" /&gt;");
            out.write("            &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;");
            out.write("            &lt;input type=\"submit\"  value=\"Sign it\"/&gt;");
            out.write("            &lt;input type=\"reset\" value=\"Reset\" /&gt;");
            out.write("        &lt;/form&gt;");
            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
            
            String name = request.getParameter("param1");
            String password = request.getParameter("param2");
            
            String location = request.getContextPath();
            
            if("arnoldp".equals(name) &amp;&amp; "123456".equals(password)){
                response.sendRedirect(location+"/WelcomeServlet?name="+name);
            }else if((name != null) &amp;&amp; (password != null))
                 response.sendRedirect(location+"/ConnexionFailureServlet"); 
                           
        } catch(IOException ex){
            logger.log(Level.SEVERE, null, ex);
        }   
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }
}</pre></div><p>As you can see, our <a id="id129" class="indexterm"/>
<code class="literal">ConnexionServlet</code> class extends <code class="literal">javax.servlet.http.</code>
<code class="literal">HttpServlet</code>; this is an abstract class that implements the <code class="literal">Servlet</code> interface. It defines the lifecycle methods (<code class="literal">doGet</code> and <code class="literal">doPost</code>) of the <code class="literal">Servlet</code> object that allows us to handle HTTP service requests and send back a response. To access the page generated by this Servlet, you must enter an URL similar to this one: <code class="literal">http://localhost:8080/chapter03PresentationLayer/connexionServlet</code>. Here, <code class="literal">connexionServlet</code> <a id="id130" class="indexterm"/>is the name <a id="id131" class="indexterm"/>given in the <code class="literal">@WebServlet</code> annotation. On this page, you will have the <span class="strong"><strong>Sign it</strong></span> button displayed by using the following instruction<code class="literal">:</code></p><div class="informalexample"><pre class="programlisting">out.write("            &lt;input type=\"submit\"  value=\"Sign it\"/&gt;");</pre></div><p>A click on this button generates an HTTP request that will cause execution of the <code class="literal">processRequest(HttpServletRequest request, HttpServletResponse response)</code> method. Based on the results of the <code class="literal">connexion</code> parameters validation, you will be redirected to the error page or home page. In the case of a redirect to the home page, we will add to the URL a parameter containing the name of the user in order to adapt the greeting. The URL of the homepage is the following:</p><p><code class="literal">http://localhost:8080/chapter03PresentationLayer/WelcomeServlet?name=arnoldp</code></p><p>To access the <code class="literal">name</code> parameter, we execute <a id="id132" class="indexterm"/>the instruction:<code class="literal"> out.println("&lt;h1&gt;Welcome Mr " + request.getParameter("name")+ "&lt;/h1&gt;");</code> in the <code class="literal">WelcomeServlet</code> Servlet.</p></div><div class="section" title="Latest improvements of Servlet 3.1 in action"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec16"/>Latest improvements of Servlet 3.1 in action</h3></div></div></div><p>Following Servlet 3.0, which was <a id="id133" class="indexterm"/>focused on ease of development, pluggability, asynchronous processing, and security enhancements, Servlet 3.1 has brought a number of clarifications to features of the previous version and some changes; the main ones are: non blocking I/O API and protocol upgrade processing.</p></div><div class="section" title="Non blocking I/O API"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec17"/>Non blocking I/O API</h3></div></div></div><p>The non blocking I/O API piggybacks <a id="id134" class="indexterm"/>on the asynchronous request processing and the upgrade processing to improve the scalability of the Web Container. Indeed, the introduction of asynchronous processing in Servlet 3.0 has made it possible to reduce waiting time <a id="id135" class="indexterm"/>between requests by enabling the thread responsible for processing the client's requests and delegating to other threads the execution of heavy processes in order to be ready to accept a new request. But, because of the traditional way to collect data input/output with a <code class="literal">while</code> loop (see the following code), the main thread responsible for request processing can be blocked due to pending data. For example, when you send a large amount of data to a very powerful server across a network, the time taken for data collection will be inversely proportional to the bandwidth of the network. The smaller the bandwidth, the more time the server will take to do the job.</p><div class="informalexample"><pre class="programlisting">public class TraditionnalIOProcessing extends HttpServlet {

    Logger logger = Logger.getLogger(TraditionnalIOProcessing.class.getName());
    
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        try (ServletInputStream input = request.getInputStream();
                FileOutputStream outputStream = new FileOutputStream("MyFile");) {

            byte b[] = new byte[3072];
            int data = input.read(b);

            while (data != -1) {
                outputStream.write(b);
                data = input.read(b);
            }
        } catch (IOException ex) {
            logger.log(Level.SEVERE, null, ex);
        }
    }
}</pre></div><p>To solve this problem, two listeners (<code class="literal">ReadListener</code> and <code class="literal">WriteListener</code>) have been added to the Java EE platform and new APIs were also introduced into <code class="literal">ServletInputStream</code> and <code class="literal">ServletOutputStream</code>.</p><p>The following table describes the new <a id="id136" class="indexterm"/>listeners for the non blocking I/O API:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Listener</strong></span></p>
</th><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Callbacks</strong></span></p>
</th><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Description</strong></span></p>
</th></tr></thead><tbody><tr><td rowspan="3" style="text-align: left" valign="top">
<p><code class="literal">ReadListener</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">void onDataAvailable()</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id137" class="indexterm"/>method is called whenever data is available to read without blocking</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">void onAllDataRead()</code></p>
</td><td style="text-align: left" valign="top">
<p>This method is called when all the data of <code class="literal">ServletRequest</code> has been read</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">void onError(Throwable t)</code></p>
</td><td style="text-align: left" valign="top">
<p>This method is called when an error or exception occurs during request processing</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p><code class="literal">WriteListener</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">void onWritePossible()</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id138" class="indexterm"/>method is called whenever it is possible to write data without blocking</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">void onError(Throwable t)</code></p>
</td><td style="text-align: left" valign="top">
<p>This method is called when an error or exception occurs during response processing</p>
</td></tr></tbody></table></div><p>The table that follows describes the new APIs for the non blocking I/O API:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Class</strong></span></p>
</th><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Method</strong></span></p>
</th><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Description</strong></span></p>
</th></tr></thead><tbody><tr><td rowspan="3" style="text-align: left" valign="top">
<p><code class="literal">ServletInputStream</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">void setReadListener(Readlistener ln)</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id139" class="indexterm"/>associates <code class="literal">Readlistener</code> with the current <code class="literal">ServletInputStream</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boolean isFinished()</code></p>
</td><td style="text-align: left" valign="top">
<p>This returns <code class="literal">true</code> when all the data of <code class="literal">ServletInputStream</code> has been read</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boolean isReady()</code></p>
</td><td style="text-align: left" valign="top">
<p>This returns <code class="literal">true</code> if data can be read without blocking</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p><code class="literal">ServletOutputStream</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">boolean isReady()</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id140" class="indexterm"/>returns <code class="literal">true</code> if data can be written successfully to <code class="literal">ServletOutputStream</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">void setWriteListener(WriteListener ln)</code></p>
</td><td style="text-align: left" valign="top">
<p>This associates <code class="literal">WriteListener</code> with the current <code class="literal">ServletOutputStream</code></p>
</td></tr></tbody></table></div><p>By using the non blocking I/O API, the <code class="literal">doGet(HttpServletRequest request, HttpServletResponse response)</code> method of the <code class="literal">TraditionnalIOProcessing</code> class shown earlier may be transformed to the <code class="literal">doGet(HttpServletRequest request, HttpServletResponse response)</code> method represented in the following code. As you can see, the data reception has been delegated to a listener (<code class="literal">ReadListenerImpl</code>), which will be notified whenever a new package is <a id="id141" class="indexterm"/>available. This prevents the server from being blocked while waiting for new packages.</p><div class="informalexample"><pre class="programlisting">protected void doGet(HttpServletRequest request, HttpServletResponse response) {
    try (ServletInputStream input = request.getInputStream();
            FileOutputStream outputStream = new FileOutputStream("MyFile");) {
       AsyncContext context = request.startAsync();
       input.setReadListener(new ReadListenerImpl(context, input,outputStream));
    }catch (IOException ex) {
       logger.log(Level.SEVERE, null, ex);
    }
}</pre></div><p>The implementation of <code class="literal">ReadListenerImpl</code> <a id="id142" class="indexterm"/>used in the preceding code snippet is as follows:</p><div class="informalexample"><pre class="programlisting">public class ReadListenerImpl implements ReadListener {

    AsyncContext context;
    ServletInputStream input;
    FileOutputStream outputStream;

    public ReadListenerImpl(AsyncContext c, ServletInputStream i, FileOutputStream f) {
        this.context = c;
        this.input = i;
        outputStream = f;
    }

    @Override
    public void onDataAvailable() throws IOException {
        byte b[] = new byte[3072];
        int data = input.read(b);
        while (input.isReady() &amp;&amp; data != -1) {
            outputStream.write(b);
            data = input.read(b);
        }
    }

    @Override
    public void onAllDataRead() throws IOException {
        System.out.println("onAllDataRead");
    }

    @Override
    public void onError(Throwable t) {
        System.out.println("onError : " + t.getMessage());
    }
}</pre></div></div><div class="section" title="Protocol upgrade processing"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec18"/>Protocol upgrade processing</h3></div></div></div><p>Protocol upgrade processing is a <a id="id143" class="indexterm"/>mechanism that was introduced in HTTP 1.1 to provide the possibility of switching from HTTP protocol to another (one that is completely different). A concrete example of protocol upgrade processing usage is the migration from HTTP protocol to the WebSocket protocol where the client begins by sending a request for WebSocket to the server. The client request is sent via HTTP and if the server accepts the connection request, it will still respond through HTTP. From this moment, every other communication will be through the established WebSocket channel. Support for this mechanism in the Servlet 3.1 Specification was done by adding the <code class="literal">upgrade</code> method to <code class="literal">HttpServletRequest</code> and two new interfaces: <code class="literal">javax.servlet.http.HttpUpgradeHandler</code> and <code class="literal">javax.servlet.http.WebConnection</code>.</p><p>The following table shows a description of protocol upgrade methods, interfaces, and classes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Class/Interface</strong></span></p>
</th><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Method</strong></span></p>
</th><th style="text-align: left" valign="bottom">
<p><span class="strong"><strong>Description</strong></span></p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">HttpServletRequest</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">HttpUpgradeHandler upgrade(Class handler)</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id144" class="indexterm"/>method starts the upgrade processing, instantiates, and returns the handler class that implements the <code class="literal">HttpUpgradeHandler</code> interface.</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p><code class="literal">HttpUpgradeHandler</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">void init(WebConnection wc)</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id145" class="indexterm"/>method is called when the upgrade operation is accepted by the Servlet. It takes a <code class="literal">WebConnection</code> object to allow the protocol handler have access to the input/output streams.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">void destroy()</code></p>
</td><td style="text-align: left" valign="top">
<p>This method is called when the client disconnects.</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p><code class="literal">WebConnection</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ServletInputStream getInputStream()</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id146" class="indexterm"/>method gives access to the input stream of the connection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ServletOutputStream getOutputStream()</code></p>
</td><td style="text-align: left" valign="top">
<p>This method gives access to the output stream of the connection.</p>
</td></tr></tbody></table></div><p>The two blocks of code that follow show us how the new method and new interfaces can be used in order to accept a given client protocol upgrade request.</p><p>The following is an example of an upgrading <a id="id147" class="indexterm"/>request:</p><div class="informalexample"><pre class="programlisting">protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");        
    try (PrintWriter out = response.getWriter();){
            System.out.println("protocol : "+request.getHeader("Upgrade"));
        if ("CYPHER".equals(request.getHeader("Upgrade"))) {
            response.setStatus(101);
            response.setHeader("Upgrade", "CYPHER");
            response.setHeader("Connection", "Upgrade");
            CypherUpgradeHandler cHandler = request.upgrade(CypherUpgradeHandler.class);                
        } else {
            out.println("The "+request.getHeader("Upgrade")+" protocol is not supported");
        }
    } 
}</pre></div><p>The following is an example of upgrade handler class implementation:</p><div class="informalexample"><pre class="programlisting">public class CypherUpgradeHandler implements HttpUpgradeHandler{

    Logger logger = Logger.getLogger(CypherUpgradeHandler.class.getName());
    public void init(WebConnection wc) {
        ServletInputStream input = null;
        ServletOutputStream output = null;
        try {
            System.out.println("A client just logged in");
            input = wc.getInputStream();
            // use input stream
            output = wc.getOutputStream();
            //use output stream
        } catch (IOException ex) {
            logger.log(Level.SEVERE, null, ex);
        }        
    }

    public void destroy() {
         System.out.println("A client just logged out");
    }    
}</pre></div></div></div></div></div>
<div class="section" title="Expression Language 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Expression Language 3.0</h1></div></div></div><p>The Expression Language 3.0 <a id="id148" class="indexterm"/>Specification was developed under JSR 341. This section gives you only an overview of improvement in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html</a>.</p><div class="section" title="What is Expression Language?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>What is Expression Language?</h2></div></div></div><p><span class="strong"><strong>Expression Language</strong></span> (<span class="strong"><strong>EL</strong></span>) is a language used to access and <a id="id149" class="indexterm"/>manipulate data in your JSP or JSF web pages. It provides a simple way to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read/write data from/to JavaBean component properties</li><li class="listitem" style="list-style-type: disc">Invoke static and public methods</li><li class="listitem" style="list-style-type: disc">Perform arithmetic, relational, logical, and conditional operations</li></ul></div><p>An EL expression looks like <code class="literal">${expr}</code> or <code class="literal">#{expr}</code>. The former syntax is often used for immediate evaluation while the latter is used for deferred evaluation. The following code demonstrates how to access a JSF bean property from a JSF page and how to perform an operation between two integers using EL <a id="id150" class="indexterm"/>expressions:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;             
   &lt;h:outputText 
     id="beanProperty" 
     value="Bean property value : #{studentBean.identity}" /&gt;
  &lt;br/&gt;
  &lt;h:outputText 
       id="operator" 
       value="operator : 3 + 12 = #{3 + 12}"  /&gt;
&lt;/h:form&gt;</pre></div></div><div class="section" title="The latest improvements of EL 3.0 in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>The latest improvements of EL 3.0 in action</h2></div></div></div><p>EL was first designed for <a id="id151" class="indexterm"/>
<span class="strong"><strong>JSP Standard Tag Library</strong></span> (<span class="strong"><strong>JSTL</strong></span>), before being associated with the JSP Specification and then to the <a id="id152" class="indexterm"/>JSF Specification. Since both specifications had different needs at the onset, each specification used a variant of the EL. The advent of JSP 2.1 EL led to unification of the EL used in JSP and JSF pages; this gave birth to a dedicated specification document for EL, although EL was always dependent on the same JSR as JSP. Version 3.0 is the first to be developed in a separate JSR: JSR 341. This new specification comes with many changes; the most important are: an API for standalone environments, lambda expressions, collection object support, string concatenation operator, assignment operator, semi-colon operator, and static fields and methods.</p><div class="section" title="API for standalone environments"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec19"/>API for standalone environments</h3></div></div></div><p>Since EL 3.0, it is now possible to <a id="id153" class="indexterm"/>handle EL in a standalone environment. For this purpose, it provides the <code class="literal">ELProcessor</code> class, which allows direct evaluation of EL expressions and makes easier the definition of functions, variables, and local repository beans. The following code demonstrates how the <code class="literal">ELProcessor</code> class <a id="id154" class="indexterm"/>can be used in standalone environment. The present case is the content of a Servlet, but you can do the same in a Java SE application.</p><div class="informalexample"><pre class="programlisting">ELProcessor el = new ELProcessor();

//Simple EL evaluation
 out.println("&lt;h1&gt;'Welcome to the site!' : "
             + "" + el.eval("'Welcome to the site!'") + "&lt;/h1&gt;");
//Definition of local repository bean
el.defineBean("student", new StudentBean());
//Direct evaluation of EL expression 
out.println("&lt;h1&gt;" + el.eval("'The id of : '+=student.lastName+=' "
             + "is : '+=student.identity") + "&lt;/h1&gt;");
//Function definition
el.defineFunction("doub", "hex", "java.lang.Double","toHexString");
//Access to a function defined
out.println("&lt;h1&gt; The hexadecimal of 29 is : "
              + el.eval("doub:hex(29)") + "&lt;/h1&gt;");</pre></div><p>Always in the context of the API for standalone environments, EL 3.0 has added the <code class="literal">ELManager</code> class to provide lower-level APIs that enable the management of the EL parsing and evaluation environment. With this class, <a id="id155" class="indexterm"/>you can import classes or add your own resolver to <code class="literal">ELProcessor</code><span class="strong"><strong>.</strong></span></p></div><div class="section" title="Lambda expressions"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec20"/>Lambda expressions</h3></div></div></div><p>A lambda expression is an anonymous <a id="id156" class="indexterm"/>function that consists of one or more parameters in brackets (if there are several), the lambda operator (<code class="literal">-&gt;</code>), and the body <a id="id157" class="indexterm"/>of the lambda expression. The expression: <code class="literal">x-&gt; x * x</code>, is a lambda expression used to determine the square of a number. Basically, lambda expressions save you from having to create a whole class for a single method or to declare a method for a very simple operation that will be used once. So, they can help to write more readable and maintainable code.</p><p>A lambda expression can take many forms, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It may involve a number of parameters and can be invoked immediately. The expression: <code class="literal">((x,y,z)-&gt;x+y*z)(3,2,4)</code>, returns 11.</li><li class="listitem" style="list-style-type: disc">It can be associated with an identifier and invoked later. The expression: <code class="literal">diff = (x,y)-&gt; x-y; diff(10,3)</code>, returns 7.</li><li class="listitem" style="list-style-type: disc">It can be passed as an argument to a method or nested within another lambda expression. The expression: <code class="literal">diff=(x,y)-&gt;(x-y);diff(10,[ 2,6,4,5].stream().filter(s-&gt;s &lt; 4).max().get())</code>, returns 8.</li></ul></div></div><div class="section" title="Collection object support"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec21"/>Collection object support</h3></div></div></div><p>The support of collection objects in the <a id="id158" class="indexterm"/>EL 3.0 Specification is done in two ways: the construction of collection objects and implementation of operations that will be used to manipulate them.</p><div class="section" title="Collection object construction"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec06"/>Collection object construction</h4></div></div></div><p>Concerning the creation of a collection, EL allow us to create objects of type <code class="literal">java.lang.util.Set</code>, <code class="literal">java.lang.util.List</code>, and <code class="literal">java.lang.util.Map</code> dynamically by using an expression or literals.</p><p>The different types of object construction <a id="id159" class="indexterm"/>are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set object construction:<p>The construction of <a id="id160" class="indexterm"/>
<code class="literal">Set</code> collection type results in an instance of <code class="literal">Set &lt;Object&gt;</code> and it is done according to the following syntax:</p><div class="informalexample"><pre class="programlisting">SetCollectionObject = '{'elements '}'</pre></div><p>Here, <code class="literal">elements</code> has the form <code class="literal">(expression (',' expression)* )?</code></p><p>For example: <code class="literal">{1, 2, 3, 4, 5},</code> <code class="literal">{'one','two','three','four'},</code> <code class="literal">{1.3, 2, 3,{4.9, 5.1}}</code></p></li><li class="listitem" style="list-style-type: disc">List object construction:<p>The construction of <code class="literal">List</code> <a id="id161" class="indexterm"/>collection type results in an instance of <code class="literal">List&lt;Object&gt;</code> and it is done according to the following syntax:</p><div class="informalexample"><pre class="programlisting">ListCollectionObject = '['elements']'</pre></div><p>Here, <code class="literal">elements</code> has the form <code class="literal">(expression (',' expression)* )?</code></p><p>For example: <code class="literal">[one, 'two', ['three', 'four'],five], [1, 2, 3, [4,5]]</code></p></li><li class="listitem" style="list-style-type: disc">Map object construction:<p>The construction of <code class="literal">Map</code> <a id="id162" class="indexterm"/>object type results in an instance of <code class="literal">Map&lt;Object&gt;</code> and it is done according to the following  syntax:</p><div class="informalexample"><pre class="programlisting">MapCollectionObject = '{' MapElements '}'</pre></div><p>Here, <code class="literal">MapElements</code> has the form <code class="literal">(MapElement (',' MapElement)* )?</code> and <code class="literal">MapElement</code> the form <code class="literal">expression ':' expression</code></p><p>For example: <code class="literal">{1:'one', 2:'two', 3:'three', 4:'four'}</code></p></li></ul></div></div><div class="section" title="Collection operations"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec07"/>Collection operations</h4></div></div></div><p>The second aspect of the collection <a id="id163" class="indexterm"/>support in EL 3.0 concerns collection operations. For this aspect, the specification only defines the syntax and behavior of a standard set of collection operations to be implemented with <code class="literal">ELResolvers</code>. It has the advantage of allowing developers to modify the default behavior by providing their own <code class="literal">ELResolvers</code>.</p><p>Execution of a collection operation is done through a stream pipeline which is made up of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">stream</code> object that represents the source of a pipeline; it is obtained from the <code class="literal">stream()</code> method of the <a id="id164" class="indexterm"/>collection or array. In the case of a map, the collection view of the map can be use as the source.</li><li class="listitem" style="list-style-type: disc">Zero or more intermediate <code class="literal">stream</code> methods that return a <code class="literal">stream</code> object.</li><li class="listitem" style="list-style-type: disc">A terminal operation, which is a <code class="literal">stream</code> method that returns nothing.</li></ul></div><p>The following code<span class="emphasis"><em> </em></span>demonstrates the construction <a id="id165" class="indexterm"/>of a pipeline by giving an example of collection operations:</p><div class="informalexample"><pre class="programlisting">public class ELTestMain {
    static ELProcessor el = new ELProcessor();
	
    public static void main(String[] args) {
        List l = new ArrayList();
        l.add(1); l.add(8); l.add(7); l.add(14); l.add(2);
        el.defineBean("list", l);

        out.println("Evaluation of " + l + " is : " + el.eval("list"));
        out.println("The ordering of: " + l + " is : " 
                 + el.eval("list.stream().sorted().toList()"));
        out.println("List of number &lt; 7 : " 
                 + el.eval("list.stream().filter(s-&gt;s &lt; 7).toList()"));
        out.println("The sum of : " + l + " is : " 
                + el.eval("list.stream().sum()"));
    }
}</pre></div></div><div class="section" title="String concatenation operator (+=)"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec08"/>String concatenation operator (<code class="literal">+=</code>)
</h4></div></div></div><p>The <code class="literal">+=</code> operator returns the <a id="id166" class="indexterm"/>concatenation of operands located on either side of the operator. For example, <code class="literal">1 += 2</code> returns 12 while <code class="literal">1 + 2</code> <a id="id167" class="indexterm"/>returns 3. To welcome a new connected student to our website we only need to locate the following expression somewhere in a web page:</p><p><code class="literal">#{'Welcome' += studentBean.lastName}</code>.</p></div><div class="section" title="Assignment operator (=)"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec09"/>Assignment operator (<code class="literal">=</code>)
</h4></div></div></div><p>The <code class="literal">A = B</code> expression assigns the <a id="id168" class="indexterm"/>value of <code class="literal">B</code> to <code class="literal">A</code>. To make this possible, <code class="literal">A</code> must be a writable property. The assignment operator (<code class="literal">=</code>) can be used to change the <a id="id169" class="indexterm"/>value of a property. For example, the <code class="literal">#{studentBean.identity = '96312547'</code>} expression assigns the value <code class="literal">96312547</code> to property <code class="literal">studentBean.identity</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The assignment operator returns a value and it is right-associative. The expression <code class="literal">a = b = 8 * 3</code> is the same as <code class="literal">a = (b = 8 * 3)</code>.</p></div></div></div><div class="section" title="Semi-colon operator (;)"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec10"/>Semi-colon operator (<code class="literal">;</code>)
</h4></div></div></div><p>The semi-colon operator can be used like the <a id="id170" class="indexterm"/>comma operator in C or C++. When two expressions exp1 and exp2 are separated by a semi-colon operator, the first <a id="id171" class="indexterm"/>expression is evaluated before the second, and it is the result of the second expression that is returned. The first expression may be an intermediate operation, such as incrementation, whose result will be used in the last expression.</p><p>The expression: <code class="literal">a = 6+1; a*2</code> returns 14.</p></div><div class="section" title="Static fields and methods"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec11"/>Static fields and methods</h4></div></div></div><p>With EL 3.0, it is now possible to <a id="id172" class="indexterm"/>directly access static fields and methods of a Java class by using the syntax <code class="literal">MyClass.field</code> or <code class="literal">MyClass.method</code>, where <code class="literal">MyClass</code> is the name of the class that contains the static variable or method. The code that follows demonstrates how to access the <code class="literal">MIN_VALUE</code> field of the <code class="literal">Integer</code> class and how to parse the String <code class="literal">'2'</code> to <code class="literal">int</code> by using the static <code class="literal">parseInt</code> method of the <code class="literal">Integer</code> class:</p><div class="informalexample"><pre class="programlisting">ELProcessor el = new ELProcessor();
//static variable access
out.println("&lt;h1&gt; The value of Integer.MIN_VALUE : " 
                 + el.eval("Integer.MIN_VALUE") + "&lt;/h1&gt;");
//static method access
out.println("&lt;h1&gt; The value of Integer.parseInt('2') : " 
                + el.eval("Integer.parseInt('2')") + "&lt;/h1&gt;");</pre></div></div></div></div></div>
<div class="section" title="JavaServer Faces 2.2"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>JavaServer Faces 2.2</h1></div></div></div><p>The JavaServer Faces 2.2 Specification <a id="id173" class="indexterm"/>was developed under JSR 344. This section gives you only an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html</a>.</p><div class="section" title="What is JavaServer Faces?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>What is JavaServer Faces?</h2></div></div></div><p><span class="strong"><strong>JavaServer Faces</strong></span> (<span class="strong"><strong>JSF</strong></span>) is a component-based architecture with <a id="id174" class="indexterm"/>a set of standard UI widgets and helper tags (<code class="literal">convertDateTime</code>, <code class="literal">inputText</code>, <code class="literal">buttons</code>, <code class="literal">table</code>, <code class="literal">converter</code>, <code class="literal">inputFile</code>, <code class="literal">inputSecret</code>, <code class="literal">selectOneRadio</code>). It was released after the Servlet and JSP Specification in order to facilitate the development and maintenance of component-oriented web applications. In this light, it offers developers the ability to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create web applications that meet the design pattern of MVC(Model-View-Controller). This design pattern allows a clear separation of the presentation layer from the other layers and facilitates the maintenance of the whole application.</li><li class="listitem" style="list-style-type: disc">Create different types of components <a id="id175" class="indexterm"/>(widgets, validators, and so on).</li><li class="listitem" style="list-style-type: disc">Reuse and customize multiple components provided by the specification according to need.</li><li class="listitem" style="list-style-type: disc">Bind Java components to different views and manipulate them easily by using <span class="strong"><strong>Expression Language</strong></span> (<span class="strong"><strong>EL</strong></span>).</li><li class="listitem" style="list-style-type: disc">Generate web pages in different formats (HTML, WML, and so on) through render kits.</li><li class="listitem" style="list-style-type: disc">Intercept the various events that occur on a form and manage the lifecycle of Java components according to the request scope.</li></ul></div><p>To make this possible, the lifecycle of JSF applications includes six phases (restore view phase, apply request values, process validations, update model values, invoke application, and render response), each of which manages a specific aspect while processing the form instead of just managing requests/responses, as is the case with Servlets.</p></div><div class="section" title="An identification page with JSF"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>An identification page with JSF</h2></div></div></div><p>The following code shows an example of a <a id="id176" class="indexterm"/>JSF page to enter personal information, such as first name and nationality. It also contains components for selection lists and checkboxes. As you can see, it is not necessary to be a geek to make a good job. To manage the navigation after validation of parameters, we use the <code class="literal">action</code> attribute of the <code class="literal">commandButton</code> component that expects a return value from the method <code class="literal">onclickValidateListener</code>. The web page that follows displays relative to the value returned and is defined in the <code class="literal">faces-config.xml</code> file of the web application.</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
    &lt;h:head&gt;
        &lt;title&gt;Online pre-registration site&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
        &lt;f:view&gt;            
            &lt;h:form &gt;                
                &lt;dir align="center" &gt;
                    &lt;h:panelGrid columns="2" style="border: solid blue"&gt;
                        &lt;h:outputText value="First name  : " /&gt;
                        &lt;h:inputText value="#{studentBean.firstName}" /&gt;
                        &lt;h:outputText value="Last name : " /&gt;
                        &lt;h:inputSecret value="#{studentBean.lastName}" /&gt;
                        &lt;h:outputText value="Birth date: " /&gt;
                        &lt;h:inputSecret value="#{studentBean.birthDate}" /&gt;
                        &lt;h:outputText value="Birth place : " /&gt;
                        &lt;h:inputSecret value="#{studentBean.birthPlace}" /&gt;
                        &lt;h:outputText value="Nationality : " /&gt;
                        &lt;h:selectOneMenu value="#{studentBean.nationality}"&gt;
                            &lt;f:selectItems value="#{studentBean.nationalities}" /&gt;
                        &lt;/h:selectOneMenu&gt;
                        &lt;h:outputText value="Gender : " /&gt;
                        &lt;h:selectOneRadio value="#{studentBean.gender}"&gt;
                            &lt;f:selectItem itemValue="M" itemLabel="Male" /&gt;
                            &lt;f:selectItem itemValue="F" itemLabel="Female" /&gt;                           
                        &lt;/h:selectOneRadio&gt;
                        &lt;h:outputText value="Language : " /&gt;
                        &lt;h:selectOneMenu value="#{studentBean.language}"&gt;
                            &lt;f:selectItems value="#{studentBean.languages}" /&gt;
                        &lt;/h:selectOneMenu&gt;
                        &lt;dir align="right"&gt;
                            &lt;h:panelGroup&gt;
                                &lt;h:commandButton value="Validate" 
                                                 action="#{studentBean.onclickValidateListener}" /&gt;
                                &lt;h:commandButton value="Cancel" 
                                                 actionListener="#{studentBean.onclickCancelListener}"  /&gt;
                            &lt;/h:panelGroup&gt; 
                        &lt;/dir&gt;
                    &lt;/h:panelGrid&gt;
                &lt;/dir&gt;  
            &lt;/h:form&gt;
        &lt;/f:view&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</pre></div></div><div class="section" title="The latest improvements of JSF 2.2 in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>The latest improvements of JSF 2.2 in action</h2></div></div></div><p>Because of the great improvements provided <a id="id177" class="indexterm"/>in HTML5, a priority of JSF 2.2 was to incorporate new features of the language; but this is not the only big change. Besides the integration of HTML5, the JSF 2.2 Specification comes with Resource Library Contracts, which announce multitemplate features, Faces Flow, and Stateless Views.</p><div class="section" title="HTML5-friendly markup"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec22"/>HTML5-friendly markup</h3></div></div></div><p>As we saw earlier, JSF is a <a id="id178" class="indexterm"/>component-based architecture. This justifies the fact that the creation of relatively complex user interface features is done by the development of JavaServer Faces components. These components are processed on the server side before delivering the right content to the browser. Although this approach saves the developer from the complexity of HTML, scripts, and other resources involved in each component, you have to know that the creation of a component is not always easy and the generated code is not always the lightest or most optimal.</p><p>The advent of HTML5 has greatly simplified the development of web applications with the introduction of new features, new elements, and new attributes. To avoid JSF component developers from reinventing the wheel, JSF 2.2 has integrated support of markup through two major concepts: pass-through attributes and pass-through elements.</p><div class="section" title="Pass-through attributes"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec12"/>Pass-through attributes</h4></div></div></div><p>During the generation of web pages that <a id="id179" class="indexterm"/>will be sent to the browser, the attributes for each JSF component are interpreted and validated by the <code class="literal">UIComponent</code> or Renderer. Unlike adding HTML5 attributes into all JSF components so that they can be validated by the <code class="literal">UIComponent</code> or Renderer, pass-through attributes give developers the ability to list a set of attributes that will be passed straight through to the browser without being interpreted by the <code class="literal">UIComponent</code> or Renderer. This can be done with three different approaches:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By introducing the namespace <code class="literal"/>; this will be used to prefix all of the component attributes that must be copied without interpretation into the web page intended for the browser (see <code class="literal">Pass through attributes 1</code> in the code that follows)</li><li class="listitem" style="list-style-type: disc">By nesting the <code class="literal">&lt;f:passThroughAttribute&gt;</code> tag within a <code class="literal">UIComponent</code> tag for a single attribute (see <code class="literal">Pass through attributes 2</code> in the following code)</li><li class="listitem" style="list-style-type: disc">By nesting the <code class="literal">&lt;f:passThroughAttributes&gt;</code> tag within a <code class="literal">UIComponent</code> tag for an EL value that is evaluated to <code class="literal">Map&lt;String, Object&gt;</code> (see <code class="literal">Pass through attributes 3</code> in the <a id="id180" class="indexterm"/>code that follows)<div class="informalexample"><pre class="programlisting">&lt;!-- namespace --&gt;
&lt;html  ...
      &gt;

&lt;h:form&gt;
    &lt;!-- Pass through attributes 1 --&gt;
    &lt;h:inputText pta:type="image" pta:src="img_submit.gif" 
                 value="image1" pta:width="58" pta:height="58" /&gt;

    &lt;!-- Pass through attributes 2 --&gt;
    &lt;h:inputText value="image2" &gt;
        &lt;f:passThroughAttribute name="type" value="image" /&gt;
        &lt;f:passThroughAttribute name="src" value="img_submit.gif" /&gt;
        &lt;f:passThroughAttribute name="width" value="68" /&gt;
        &lt;f:passThroughAttribute name="height" value="68" /&gt;
    &lt;/h:inputText&gt;

    &lt;!-- Pass through attributes 3 --&gt;
    &lt;h:inputText value="image3" &gt;
        &lt;f:passThroughAttributes 
          value="#{html5Bean.mapOfParameters}" /&gt;                
    &lt;/h:inputText&gt;
&lt;/h:form&gt;</pre></div></li></ul></div></div><div class="section" title="Pass-through elements"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec13"/>Pass-through elements</h4></div></div></div><p>In contrast to pass-through attributes that allow <a id="id181" class="indexterm"/>you to pass HTML attributes to the browser without interpretation, pass-through elements allow you to use the HTML tag as a JSF component. This gives you the opportunity to enrich the HTML tag with JSF features and take advantage of the JSF component lifecycle. To make this possible, the framework will establish a correspondence between the HTML markup specified by the developer, which is rendered to the browser, and an equivalent JSF component for server-side processing.</p><p>To use pass-through elements in a given HTML tag, you must prefix at least one of its attributes with the short name assigned to the <code class="literal">http://xmlns.jcp.org/jsf</code> namespace.</p><p>The following code snippet shows how to use <a id="id182" class="indexterm"/>pass-through elements:</p><div class="informalexample"><pre class="programlisting">&lt;!-- namespace --&gt;
&lt;html ...
      "&gt;

&lt;h:form&gt;
    &lt;!-- Pass through element --&gt;
    &lt;input type="submit" value="myButton" 
     pte:actionListener="#{html5Bean.submitListener}"/&gt;
&lt;/h:form&gt;</pre></div></div></div><div class="section" title="Resource Library Contracts"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec23"/>Resource Library Contracts</h3></div></div></div><p>The Resource Library Contracts provide a <a id="id183" class="indexterm"/>JSF mechanism for applying templates to different parts of your web application. This feature announces a <a id="id184" class="indexterm"/>major change: the ability to download a look and feel (theme) and apply it to your account or website by using a button or management console, as in Joomla!.</p><p>For now, the Resource Library Contracts enable you to group resources (template files, JavaScript files, style sheets, and images) of your various templates in the <code class="literal">contracts</code> folder of your web application. To improve the maintainability of your application, resources for each template can be grouped into a subfolder called <code class="literal">contract</code>. The following code demonstrates a web application with three templates stored in three different <code class="literal">contracts</code>: <code class="literal">template1</code>, <code class="literal">template2</code>, and <code class="literal">template3</code>:</p><div class="informalexample"><pre class="programlisting">src/main/webapp
    WEB-INF/
    contracts/
        template1/
            header.xhtml
            footer.xhtml
            style.css
            logo.png
            scripts.js
        template2/
            header.xhtml
            footer.xhtml
            style.css
            logo.png
            scripts.js
        Template3/
            header.xhtml
            footer.xhtml
            style.css
            logo.png
            scripts.js

    index.xhtml
    ...</pre></div><p>In addition to the deployment in the <code class="literal">contracts</code> folder, your templates can be packaged in a JAR file; in this case, they must be stored in the <code class="literal">META-INF</code>/<code class="literal">contracts</code> folder of the JAR which will be deployed in the <code class="literal">WEB-INF</code>/<code class="literal">lib</code> folder of your application.</p><p>Once defined, templates must be referenced within an application's <code class="literal">faces-config.xml</code> file, with the <code class="literal">resource-library-contracts</code> element. The configurations of the following request mean that <code class="literal">template1</code> is applied to <a id="id185" class="indexterm"/>pages whose URLs respect the pattern <code class="literal">/templatepages/*</code>. And for other pages, <a id="id186" class="indexterm"/>the <code class="literal">template2</code> will be applied.</p><div class="informalexample"><pre class="programlisting">&lt;resource-library-contracts&gt;
    &lt;contract-mapping&gt;
        &lt;url-pattern&gt;/templatepages/*&lt;/url-pattern&gt;
        &lt;contracts&gt;template1&lt;/contracts&gt;
    &lt;/contract-mapping&gt;
    &lt;contract-mapping&gt;
        &lt;url-pattern&gt;*&lt;/url-pattern&gt;
        &lt;contracts&gt;template2&lt;/contracts&gt;
    &lt;/contract-mapping&gt;
&lt;/resource-library-contracts&gt;</pre></div><p>The following code snippet shows us what the header of <code class="literal">template1</code> looks like. It contains only a picture to be displayed in the header. You can add text, style, and color if you want.</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html&gt;
&lt;html 
      
       
      &gt;
    &lt;h:head&gt;
        &lt;title&gt;Resource Library Contracts&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
     &lt;ui:insert name="header" &gt;
       &lt;img src="image.jpg" width="400" height="50" alt="Header image"/&gt;                                               
     &lt;/ui:insert&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>The following code demonstrates how a <a id="id187" class="indexterm"/>template can be <a id="id188" class="indexterm"/>used in a web page:</p><div class="informalexample"><pre class="programlisting">&lt;f:view&gt;
    &lt;h:form&gt;               
        &lt;h:panelGrid border="1" columns="3" &gt;        
            &lt;f:facet name="header"&gt;
                &lt;ui:composition template="/header.xhtml"&gt;

                &lt;/ui:composition&gt;
            &lt;/f:facet&gt;            
            &lt;f:facet name="footer"&gt;
                &lt;ui:composition template="/footer.xhtml"&gt;

                &lt;/ui:composition&gt;
            &lt;/f:facet&gt;
        &lt;/h:panelGrid&gt; 
    &lt;/h:form&gt;
&lt;/f:view&gt;  </pre></div></div><div class="section" title="Faces Flow"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec24"/>Faces Flow</h3></div></div></div><p>Faces Flow is used to define and <a id="id189" class="indexterm"/>perform processes that are split over several forms. If we take, for example, the case of online registration, the registration form can be <a id="id190" class="indexterm"/>split over several pages, each representing a step. In our case we have: the acceptance conditions, entering identification information, contact information, medical information, school information, and finally the validation. To implement this type of application with previous versions of JSF, it was necessary to use beans with session scope and declare hard links between pages that formed the flow. This reduces the usability of the flow in another application and does not give the possibility to open the same flow in many windows.</p><p>A flow is made up of an entry called the starting point, an exit point called a return node and zero, or many other nodes. A node can be a JSF page (<code class="literal">ViewNode</code>), a navigation decision (<code class="literal">SwitchNode</code>), an application logic invocation (<code class="literal">MethodCallNode</code>), a call to another flow (<code class="literal">FlowCallNode</code>), or a return to the calling flow (<code class="literal">ReturnNode</code>).</p><p>A flow can be configured either with an XML configuration file or programmatically. It can be packaged in a JAR file or folder. The following example demonstrates how to implement an online preregistration website with Faces Flow (our flow is configured with an XML configuration file; for program configuration, please consult the Java EE 7 tutorial.)</p><p>In the case of a flow packaged in a folder, <a id="id191" class="indexterm"/>the following conventions are followed by default:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The package folder of the flow has the same name as the flow</li><li class="listitem" style="list-style-type: disc">The starting node of the flow has the same name as the flow</li><li class="listitem" style="list-style-type: disc">All pages of the flow are assumed to be in the same folder except the exit points</li><li class="listitem" style="list-style-type: disc">For a flow that is configured with an XML configuration file, the configuration file is a <code class="literal">faces-config</code> whose name is <code class="literal">&lt;name_of_flow&gt;-flow.xml</code></li></ul></div><p>According to the rule we have just presented, the web application that the tree is showing contains a flow named <code class="literal">inscriptionFlow</code> <a id="id192" class="indexterm"/>with six views. This flow is configured in <code class="literal">inscriptionFlow-flow.xml</code> and its starting node is <code class="literal">inscriptionFlow.xhtml</code>.</p><div class="informalexample"><pre class="programlisting">webapp
  WEB-INF
  inscriptionFlow
      inscriptionFlow-flow.xml  
  inscriptionFlow.xhtml
  inscriptionFlow1.xhtml
  inscriptionFlow2.xhtml
  inscriptionFlow3.xhtml
  inscriptionFlow4.xhtml
  inscriptionFlow5.xhtml
  ...
   index.xhtml </pre></div><p>In the configuration file, we must define the ID of the flow and the ID of exit points. The following code shows the contents of the file <code class="literal">inscriptionFlow-flow.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;faces-config version="2.2"
    
    
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"&gt;

    &lt;flow-definition id="inscriptionFlow"&gt;
        &lt;flow-return id="inscriptionFlowExit"&gt;
            &lt;from-outcome&gt;#{inscriptionFlowBean.exitValue}&lt;/from-outcome&gt;          
        &lt;/flow-return&gt;        
    &lt;/flow-definition&gt;
&lt;/faces-config&gt; </pre></div><p>Navigation between different views can be done through the <code class="literal">action</code> attribute of the tag that will actuate the display of the next view. <a id="id193" class="indexterm"/>In this attribute you put the name of the page to which you want to go after the current page. The following code shows the contents of the <code class="literal">inscriptionFlow1</code> view. This view corresponds to the input form for personal information; it contains a field for entering the name, a button to go to the next view (<code class="literal">inscriptionFlow2</code>), and a <a id="id194" class="indexterm"/>button to return to the previous view (<code class="literal">inscriptionFlow</code>).</p><div class="informalexample"><pre class="programlisting">&lt;!-- inscriptionFlow1 view --&gt;
&lt;f:view&gt;
&lt;h:form&gt;
   &lt;h1&gt;Identification information&lt;/h1&gt;
   &lt;p&gt;Name : &lt;h:inputText id="name" 
           value="#{inscriptionFlowBean.name}" /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;h:commandButton value="Next" action="inscriptionFlow2" /&gt;&lt;/p&gt;
  &lt;p&gt;&lt;h:commandButton value="Back" action="inscriptionFlow" /&gt;&lt;/p&gt;
&lt;/h:form&gt;
&lt;/f:view&gt;</pre></div><p>To end a flow, just pass to the <code class="literal">action</code> attribute of the dedicated tag for this action the ID of the exit point defined in the configuration file (<code class="literal">inscriptionFlowExit</code>). And to save data between different views, you must use a Flow-Scoped Managed Bean. The following code shows the skeleton of the <code class="literal">inscriptionFlowBean</code> managed bean that we use in our inscription flow:</p><div class="informalexample"><pre class="programlisting">@Named
@FlowScoped(value="inscriptionFlow")
public class InscriptionFlowBean {
    //...
}
If all settings have been made, you can call your inscriptionFlow  in the start page with a button as follows:
&lt;h:commandButton id="start" value="Registration" 
                              action="inscriptionFlow"&gt;
   &lt;f:attribute name="toFlowDocumentId" value=""/&gt;
&lt;/h:commandButton&gt;</pre></div></div><div class="section" title="Stateless views"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec25"/>Stateless views</h3></div></div></div><p>JSF 2.2 did not only add new widgets, it <a id="id195" class="indexterm"/>also improved memory usage. Prior to Version 2.0 of the specification, the whole component tree was saved and restored whenever there was any change in the view. This degraded system performance and stuffed the memory. With Version 2.0, the specification has introduced the partial state saving mechanism. This mechanism consists of saving only the state that has changed after the creation of the component tree and reduces the amount of data to be saved. In the same light, JSF 2.2 offers us the possibility to define stateless views. As the name suggests, no data about the <code class="literal">UIComponent</code> state of the view's components will be saved.</p><p>To transform a simple view into a <a id="id196" class="indexterm"/>stateless view, <a id="id197" class="indexterm"/>you just need to specify <code class="literal">true</code> as the value of the transient attribute of the <code class="literal">f:view</code> tag (see the following code).</p><div class="informalexample"><pre class="programlisting">&lt;h:head&gt;
    &lt;title&gt;Facelet Title&lt;/title&gt;
&lt;/h:head&gt;
&lt;h:body&gt;
    &lt;f:view transient="true"&gt;
        &lt;h:form&gt;
            Hello from Facelets
        &lt;/h:form&gt;
    &lt;/f:view&gt;
&lt;/h:body&gt;</pre></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we discussed the specifications related to data presentation that have been improved in Java EE 7. These are: Servlet, Expression Language, and the JSF Specification. Each presentation was followed by an analysis of the various improvements made and a small example to show how these new features can be implemented. In the next chapter, we will talk about Java APIs used to communicate with databases, which will lead us to another chapter that focuses on putting together all of the APIs that we have seen.</p></div></body></html>