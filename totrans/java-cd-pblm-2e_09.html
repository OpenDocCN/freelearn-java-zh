<html><head></head><body>
  <div id="_idContainer240" class="Basic-Text-Frame">
    <h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-401" class="chapterTitle">Functional Style Programming – Extending APIs</h1>
    <p class="normal">This chapter includes 24 problems covering a wide range of functional programming topics. We will start by introducing the JDK 16 <code class="inlineCode">mapMulti()</code> operation, and continue with a handful of problems for working with predicates (<code class="inlineCode">Predicate</code>), functions, and collectors.</p>
    <p class="normal">If you don’t have a background in functional programming in Java, then I strongly recommend you postpone this chapter until you have spent some time getting familiar with it. You could consider reading <em class="italic">Chapters 8</em> and<em class="italic"> 9</em> from <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>.</p>
    <p class="normal">At the end of this chapter, you’ll be deeply skilled in functional programming in Java.</p>
    <h1 id="_idParaDest-402" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess in functional programming in Java. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="185"><strong class="keyWord">Working with mapMulti()</strong>: Explain and exemplify the JDK 16 <code class="inlineCode">mapMulti()</code>. Provide a brief introduction, explain how it works in comparison with <code class="inlineCode">flatMap()</code>, and point out when <code class="inlineCode">mapMulti()</code> is a good fit.</li>
      <li class="numberedList"><strong class="keyWord">Streaming custom code to map</strong>: Imagine a class that shapes some blog posts. Each post is identified by a unique integer ID, and the post has several properties, including its tags. The tags of each post are actually represented as a string of tags separated by a hashtag (<code class="inlineCode">#</code>). Whenever we need the list of tags for a given post, we can call the <code class="inlineCode">allTags()</code> helper method. Our goal is to write a stream pipeline that extracts from this list of tags a <code class="inlineCode">Map&lt;String, List&lt;Integer&gt;&gt;</code> containing, for each tag (key), the list of posts (value).</li>
      <li class="numberedList"><strong class="keyWord">Exemplifying a method reference vs. a lambda</strong>: Write a relevant snippet of code to highlight the difference in behavior between a method reference and the equivalent lambda expression.</li>
      <li class="numberedList"><strong class="keyWord">Hooking lambda laziness via Supplier/Consumer</strong>: Write a Java program that highlights how <code class="inlineCode">Supplier</code>/<code class="inlineCode">Consumer</code> works. In this context, point out the lazy characteristic of lambdas.</li>
      <li class="numberedList"><strong class="keyWord">Refactoring code to add lambda laziness:</strong> Provide a simple example of refactoring a piece of imperative code via functional code. </li>
      <li class="numberedList"><strong class="keyWord">Writing a Function&lt;String, T&gt; to parse data</strong>: Imagine a given text (<code class="inlineCode">test, a, 1, 4, 5, 0xf5, 0x5, 4.5d, 6, 5.6, 50000, 345, 4.0f, 6$3, 2$1.1, 5.5, 6.7, 8, a11, 3e+1, -11199, 55</code>). Write an application that exposes a <code class="inlineCode">Function&lt;String, T&gt;</code> capable of parsing this text, and extract only doubles, integers, longs, and so on.</li>
      <li class="numberedList"><strong class="keyWord">Composing predicates in a Stream’s filters</strong>: Write several examples that highlight the usage of composite predicates in filters.</li>
      <li class="numberedList"><strong class="keyWord">Filtering nested collections with Streams</strong>: Imagine that you have two nested collections. Provide several stream pipeline examples to filter data from the inner collection.</li>
      <li class="numberedList"><strong class="keyWord">Using BiPredicate:</strong> Exemplify the usage of <code class="inlineCode">BiPredicate</code>.</li>
      <li class="numberedList"><strong class="keyWord">Building a dynamic predicate for a custom model</strong>: Write an application capable of dynamically generating predicates (<code class="inlineCode">Predicate</code>) based on some simple inputs.</li>
      <li class="numberedList"><strong class="keyWord">Building a dynamic predicate from a custom map of conditions</strong>: Consider having a map of conditions (the map’s key is a field, and the map’s value is the expected value for that field). In this context, write an application that dynamically generates the proper predicate.</li>
      <li class="numberedList"><strong class="keyWord">Logging in predicates</strong>: Write a custom solution that allows us to log failures in predicates.</li>
      <li class="numberedList"><strong class="keyWord">Extending Stream with containsAll() and containsAny()</strong>: Provide a solution that extends the Java Stream API with two final operations named <code class="inlineCode">containsAll()</code> and <code class="inlineCode">containsAny()</code>.</li>
      <li class="numberedList"><strong class="keyWord">Extending Stream with removeAll() and retainAll()</strong>: Provide a solution that extends the Java Stream API with two final operations named <code class="inlineCode">removeAll()</code> and <code class="inlineCode">retainAll()</code>.</li>
      <li class="numberedList"><strong class="keyWord">Introducing stream comparators</strong>: Provide a detailed covering (with examples) of using stream comparators.</li>
      <li class="numberedList"><strong class="keyWord">Sorting a map</strong>: Write several snippets of code to highlight different use cases for sorting a map.</li>
      <li class="numberedList"><strong class="keyWord">Filtering a map</strong>: Write several snippets of code to highlight different use cases for filtering a map.</li>
      <li class="numberedList"><strong class="keyWord">Creating a custom collector via Collector.of()</strong>: Write an arbitrarily chosen set of custom collectors via the <code class="inlineCode">Collector.of()</code> API.</li>
      <li class="numberedList"><strong class="keyWord">Throwing checked exceptions from lambdas</strong>: Provide a hack that allows us to throw checked exceptions from lambdas.</li>
      <li class="numberedList"><strong class="keyWord">Implementing distinctBy() for the Stream API</strong>: Write a Java application that implements the <code class="inlineCode">distinctBy()</code> stream intermediate operation. This is like the built-in <code class="inlineCode">distinct()</code>, only it allows us to filter distinct elements by a given property/field.</li>
      <li class="numberedList"><strong class="keyWord">Writing a custom collector that takes/skips a given number of elements</strong>: Provide a custom collector that allows us to collect only the first <em class="italic">n</em> elements. Moreover, provide a custom collector that skips the first <em class="italic">n</em> elements and collects the rest of them.</li>
      <li class="numberedList"><strong class="keyWord">Implementing a Function that takes five (or any other arbitrary number of) arguments</strong>: Write and use a five-argument functional interface that represents a specialization of <code class="inlineCode">java.util.function.Function</code>.</li>
      <li class="numberedList"><strong class="keyWord">Implementing a Consumer that takes five (or any other arbitrary number of) arguments</strong>: Write and use a five-argument functional interface that represents a specialization of <code class="inlineCode">java.util.function.Consumer</code>.</li>
      <li class="numberedList"><strong class="keyWord">Partially applying a Function</strong>: Write an <em class="italic">n</em>-arity functional interface that represents a specialization of <code class="inlineCode">java.util.function.Function</code>. Moreover, this interface should provide support (i.e., provide the necessary <code class="inlineCode">default</code> methods) to apply only <em class="italic">n</em>-1, <em class="italic">n</em>-2, <em class="italic">n</em>-3,…,1 argument(s).</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09</span></a>.</p>
    <h1 id="_idParaDest-403" class="heading-1">185. Working with mapMulti()</h1>
    <p class="normal">Starting with JDK 16, the Stream API was enriched with a new intermediate operation, named <code class="inlineCode">mapMulti()</code>. This<a id="_idIndexMarker999"/> operation is represented by the following <code class="inlineCode">default</code> method in the <code class="inlineCode">Stream</code> interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> &lt;R&gt; Stream&lt;R&gt; <span class="hljs-title">mapMulti</span> <span class="hljs-params">(</span>
<span class="hljs-params">  BiConsumer&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T, ? </span><span class="hljs-built_in">super</span><span class="hljs-params"> Consumer&lt;R&gt;&gt; mapper)</span>
</code></pre>
    <p class="normal">Let’s follow the learning-by-example approach and consider the next classical example, which uses a combination of <code class="inlineCode">filter()</code> and <code class="inlineCode">map()</code> to filter even integers and double their value:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Integer&gt; integers = List.of(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);
List&lt;Integer&gt; evenDoubledClassic = integers.stream()
  .filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
  .map(i -&gt; i * <span class="hljs-number">2</span>)
  .collect(toList());
</code></pre>
    <p class="normal">The same result can be obtained via <code class="inlineCode">mapMulti()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Integer&gt; evenDoubledMM = integers.stream()
  .&lt;Integer&gt;mapMulti((i, consumer) -&gt; {
     <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
       consumer.accept(i * <span class="hljs-number">2</span>);
     }
  })
  .collect(toList());
</code></pre>
    <p class="normal">So instead of using two intermediate operations, we used only one, <code class="inlineCode">mapMulti()</code>. The <code class="inlineCode">filter()</code> role was replaced by an <code class="inlineCode">if</code> statement, and the <code class="inlineCode">map()</code> role is accomplished in the <code class="inlineCode">accept()</code> method. This time, we filtered the evens and doubled their values via <code class="inlineCode">mapper</code>, which is a <code class="inlineCode">BiConsumer&lt;? super T, ? super Consumer&lt;R&gt;&gt;</code>. This bi-function is applied to each integer (each stream element), and only the even integers are passed to the consumer. This consumer acts as a buffer that simply passes downstream (in the stream pipeline) the received elements. The <code class="inlineCode">mapper.accept(R r)</code> can be called any number of times, which means that, for a given stream element, we can produce as many output elements as we need. In the previous example, we have a one-to-zero mapping (when <code class="inlineCode">i % 2 == 0</code> is evaluated as <code class="inlineCode">false</code>) and a one-to-one mapping (when <code class="inlineCode">i % 2 == 0</code> is evaluated as <code class="inlineCode">true</code>).</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">More precisely, <code class="inlineCode">mapMulti()</code> gets an input stream of elements and outputs another stream containing zero, less, the same, or a larger number of elements that can be unaltered or replaced by other elements. This means that each element from the input stream can pass through a one-to-zero, one-to-one, or one-to-many mapping.</p>
    </div>
    <p class="normal">Have you noticed the <code class="inlineCode">&lt;Integer&gt;mapMulti(…)</code> type-witness applied to the returned value? Without this type-witness, the code will not compile because the compiler cannot determine the <a id="_idIndexMarker1000"/>proper type of <code class="inlineCode">R</code>. This is the shortcoming of using <code class="inlineCode">mapMulti()</code>, so we have to pay this price. </p>
    <p class="normal">For primitive types (<code class="inlineCode">double</code>, <code class="inlineCode">long</code>, and <code class="inlineCode">int</code>) we have <code class="inlineCode">mapMultiToDouble()</code>, <code class="inlineCode">mapMultiToLong()</code>, and <code class="inlineCode">mapMultiToInt()</code>, which return <code class="inlineCode">DoubleStream</code>, <code class="inlineCode">LongStream</code>, and <code class="inlineCode">IntStream</code>, respectively. For instance, if we plan to sum the even integers, then using <code class="inlineCode">mapMultiToInt()</code> is a better choice than <code class="inlineCode">mapMulti()</code>, since we can skip the type-witness and work only with a primitive <code class="inlineCode">int</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">evenDoubledAndSumMM</span> <span class="hljs-operator">=</span> integers.stream()
  .mapMultiToInt((i, consumer) -&gt; {
     <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
       consumer.accept(i * <span class="hljs-number">2</span>);
     }
  })
  .sum();
</code></pre>
    <p class="normal">On the other hand, whenever you need a <code class="inlineCode">Stream&lt;T&gt;</code> instead of <code class="inlineCode">Double</code>/<code class="inlineCode">Long</code>/<code class="inlineCode">IntStream</code>, you still need to rely on <code class="inlineCode">mapToObj()</code> or <code class="inlineCode">boxed()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Integer&gt; evenDoubledMM = integers.stream()
  .mapMultiToInt((i, consumer) -&gt; {
    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
      consumer.accept(i * <span class="hljs-number">2</span>);
    }
  })
  .mapToObj(i -&gt; i) <span class="hljs-comment">// or, .boxed()</span>
  .collect(toList());
</code></pre>
    <p class="normal">Once you get familiar with <code class="inlineCode">mapMulti()</code>, you start to realize that it is pretty similar to the well-known <code class="inlineCode">flatMap()</code>, which is useful to flatten a nested <code class="inlineCode">Stream&lt;Stream&lt;R&gt;&gt;</code> model. Let’s consider the following <a id="_idIndexMarker1001"/>one-to-many relationship:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Book&gt; books;
  ...
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> {
    
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String title;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LocalDate published;
  ...
}
</code></pre>
    <p class="normal">Each <code class="inlineCode">Author</code> has a list of books. So a <code class="inlineCode">List&lt;Author&gt;</code> (candidate to become <code class="inlineCode">Stream&lt;Author&gt;</code>) will nest a <code class="inlineCode">List&lt;Book&gt;</code> (candidate to become a nested <code class="inlineCode">Stream&lt;Book&gt;</code>) for each <code class="inlineCode">Author</code>. Moreover, we have the following simple model for mapping an <code class="inlineCode">author</code> and a single <code class="inlineCode">book</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bookshelf</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String author;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String book;
  ...
}
</code></pre>
    <p class="normal">In functional programming, mapping this one-to-many model to the flat <code class="inlineCode">Bookshelf</code> model is a classical scenario for using <code class="inlineCode">flatMap()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Bookshelf&gt; bookshelfClassic = authors.stream()
  .flatMap(
    author -&gt; author.getBooks()
                    .stream()
                    .map(book -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">Bookshelf</span>(
                       author.getName(), book.getTitle()))
  ).collect(Collectors.toList());
</code></pre>
    <p class="normal">The problem with <code class="inlineCode">flatMap()</code> is that we need to create a new intermediate stream for each author (for a large number of authors, this can become a performance penalty), and only afterward we can apply the <code class="inlineCode">map()</code> operation. With <code class="inlineCode">mapMulti()</code>, we don’t need these intermediate streams, and <a id="_idIndexMarker1002"/>the mapping is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Bookshelf&gt; bookshelfMM = authors.stream()
  .&lt;Bookshelf&gt;mapMulti((author, consumer) -&gt; {
     <span class="hljs-keyword">for</span> (Book book : author.getBooks()) {
       consumer.accept(<span class="hljs-keyword">new</span> <span class="hljs-title">Bookshelf</span>(
         author.getName(), book.getTitle()));
     }
  })
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">This is a one-to-many mapping. For each author, the consumer buffers a number of <code class="inlineCode">Bookshelf</code> instances equal to the number of author’s books. These instances are flattened over the downstream and are finally collected in a <code class="inlineCode">List&lt;Bookshelf&gt;</code> via the <code class="inlineCode">toList()</code> collector.</p>
    <p class="normal">And this route takes us to the following important note on <code class="inlineCode">mapMulti()</code>.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The <code class="inlineCode">mapMulti()</code> intermediate operation is useful when we have to replace just a few elements of the stream. This statement is formulated in the official documentation as follows: “<em class="italic">When replacing each stream element with a small (possibly zero) number of elements</em>.”</p>
    </div>
    <p class="normal">Next, check out this example based on <code class="inlineCode">flatMap()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Bookshelf&gt; bookshelfGt2005Classic = authors.stream()
  .flatMap(
    author -&gt; author.getBooks()
      .stream()
      .filter(book -&gt; book.getPublished().getYear() &gt; <span class="hljs-number">2005</span>)
      .map(book -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">Bookshelf</span>(
         author.getName(), book.getTitle()))
  ).collect(Collectors.toList());
</code></pre>
    <p class="normal">This example fits perfectly when using <code class="inlineCode">mapMulti()</code>. An author has a relatively small number of books, and we apply a filter on them. So basically, we replace each stream element with a <a id="_idIndexMarker1003"/>small (possibly zero) number of elements:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Bookshelf&gt; bookshelfGt2005MM = authors.stream()
  .&lt;Bookshelf&gt;mapMulti((author, consumer) -&gt; {
    <span class="hljs-keyword">for</span> (Book book : author.getBooks()) {
      <span class="hljs-keyword">if</span> (book.getPublished().getYear() &gt; <span class="hljs-number">2005</span>) {
        consumer.accept(<span class="hljs-keyword">new</span> <span class="hljs-title">Bookshelf</span>(
          author.getName(), book.getTitle()));
      }
    }
  })
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">This is better than using <code class="inlineCode">flatMap()</code>, since we reduce the number of intermediate operations (no more <code class="inlineCode">filter()</code> calls), and we avoided intermediate streams. This is also more readable.</p>
    <p class="normal">Another use case of <code class="inlineCode">mapMulti()</code> is as follows.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The <code class="inlineCode">mapMulti()</code> operation is also useful when the imperative approach is preferable against the stream approach. This statement is formulated in the official documentation as follows: “<em class="italic">When it is easier to use an imperative approach for generating result elements than it is to return them in the form of a </em><code class="inlineCode">Stream</code>.”</p>
    </div>
    <p class="normal">Imagine that we have added to the <code class="inlineCode">Author</code> class the following method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bookshelfGt2005</span><span class="hljs-params">(Consumer&lt;Bookshelf&gt; consumer)</span> {
  <span class="hljs-keyword">for</span> (Book book : <span class="hljs-built_in">this</span>.getBooks()) {
    <span class="hljs-keyword">if</span> (book.getPublished().getYear() &gt; <span class="hljs-number">2005</span>) {
      consumer.accept(<span class="hljs-keyword">new</span> <span class="hljs-title">Bookshelf</span>(
        <span class="hljs-built_in">this</span>.getName(), book.getTitle()));
    }
  }
}
</code></pre>
    <p class="normal">Now, we get the <code class="inlineCode">List&lt;Bookshelf&gt;</code> by simply using <code class="inlineCode">mapMulti()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Bookshelf&gt; bookshelfGt2005MM = authors.stream()
  .&lt;Bookshelf&gt;mapMulti(Author::bookshelfGt2005)
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">How cool is this?! In the<a id="_idIndexMarker1004"/> next problem, we will use <code class="inlineCode">mapMulti()</code> in another scenario.</p>
    <h1 id="_idParaDest-404" class="heading-1">186. Streaming custom code to map</h1>
    <p class="normal">Let’s assume that <a id="_idIndexMarker1005"/>we have the following legacy class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post</span> {
    
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String title;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String tags;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">Post</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> id, String title, String tags)</span><span class="hljs-function"> </span>{
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-keyword">this</span>.title = title;
    <span class="hljs-keyword">this</span>.tags = tags;
  }
  ...
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-type">static</span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title">allTags</span><span class="hljs-params">(Post post)</span><span class="hljs-function"> </span>{
        
    <span class="hljs-keyword">return</span> Arrays.<span class="hljs-built_in">asList</span>(post.<span class="hljs-built_in">getTags</span>().<span class="hljs-built_in">split</span>(<span class="hljs-string">"#"</span>));
  }
}
</code></pre>
    <p class="normal">So we have a class that shapes some blog posts. Each post has several properties, including its tags. The tags of each post are actually represented as a string of tags separated by hashtag (<code class="inlineCode">#</code>). Whenever we need the list of tags for a given post, we can call the <code class="inlineCode">allTags()</code> helper. For instance, here is a list of posts and their tags:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Post&gt; posts = List.of(
  <span class="hljs-keyword">new</span> <span class="hljs-title">Post</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"</span><span class="hljs-string">Running jOOQ"</span>, <span class="hljs-string">"#database #sql #rdbms"</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Post</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"I/O files in Java"</span>, <span class="hljs-string">"#io #storage #rdbms"</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Post</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"</span><span class="hljs-string">Hibernate Course"</span>, <span class="hljs-string">"#jpa #database #rdbms"</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Post</span>(<span class="hljs-number">4</span>, <span class="hljs-string">"Hooking Java Sockets"</span>, <span class="hljs-string">"#io #network"</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Post</span>(<span class="hljs-number">5</span>, <span class="hljs-string">"</span><span class="hljs-string">Analysing JDBC transactions"</span>, <span class="hljs-string">"#jdbc #rdbms"</span>)
);
</code></pre>
    <p class="normal">Our goal is to extract from this list a <code class="inlineCode">Map&lt;String, List&lt;Integer&gt;&gt;</code>, containing, for each tag (key) the list of posts (value). For instance, for the tag <code class="inlineCode">#database</code>, we have articles 1 and 3; for tag <code class="inlineCode">#rdbms</code>, we have articles 1, 2, 3, and 5, and so on.</p>
    <p class="normal">Accomplishing this task in functional programming can be done via <code class="inlineCode">flatMap()</code> and <code class="inlineCode">groupingBy()</code>. In a nutshell, <code class="inlineCode">flatMap()</code> is useful for flattening a nested <code class="inlineCode">Stream&lt;Stream&lt;R&gt;&gt;</code> model, while <code class="inlineCode">groupingBy()</code> is a collector useful for grouping data in a map by some logic or <a id="_idIndexMarker1006"/>property.</p>
    <p class="normal">We need <code class="inlineCode">flatMap()</code> because we have the <code class="inlineCode">List&lt;Post&gt;</code> that, for each <code class="inlineCode">Post</code>, nests via <code class="inlineCode">allTags()</code> a <code class="inlineCode">List&lt;String&gt;</code> (so if we simply call <code class="inlineCode">stream()</code>, then we get back a <code class="inlineCode">Stream&lt;Stream&lt;R&gt;&gt;</code>). After flattening, we wrap each tag in <code class="inlineCode">Map.Entry&lt;String, Integer&gt;</code>. Finally, we group these entries by tags into a <code class="inlineCode">Map</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;String, List&lt;Integer&gt;&gt; result = posts.stream()
  .flatMap(post -&gt; Post.allTags(post).stream()
  .map(t -&gt; entry(t, post.getId())))
  .collect(groupingBy(Entry::getKey,
              mapping(Entry::getValue, toList())));
</code></pre>
    <p class="normal">However, based on the previous problem, we know that, starting with JDK 16, we can use <code class="inlineCode">mapMulti()</code>. So, we can rewrite the previous snippet as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;String, List&lt;Integer&gt;&gt; resultMulti = posts.stream()
  .&lt;Map.Entry&lt;String, Integer&gt;&gt;mapMulti((post, consumer) -&gt; {
      <span class="hljs-keyword">for</span> (String tag : Post.allTags(post)) {
             consumer.accept(entry(tag, post.getId()));
      }
  })
  .collect(groupingBy(Entry::getKey,
              mapping(Entry::getValue, toList())));
</code></pre>
    <p class="normal">This time, we saved the <code class="inlineCode">map()</code> intermediate operation and intermediate streams.</p>
    <h1 id="_idParaDest-405" class="heading-1">187. Exemplifying a method reference vs. a lamda</h1>
    <p class="normal">Have you ever written a lambda expression and your IDE advises you to replace it with a method reference? You probably have! And I’m sure that you<a id="_idIndexMarker1007"/> preferred to follow the replacement because <em class="italic">names matter</em>, and method references are often more readable than lambdas. While this is a subjective matter, I’m pretty sure you’ll agree that extracting long lambdas in methods and using/reusing them via method references is a generally accepted good practice.</p>
    <p class="normal">However, beyond some esoteric JVM internal representations, do they behave the same? Is there any difference<a id="_idIndexMarker1008"/> between a lambda and a method reference that may affect how the code behaves?</p>
    <p class="normal">Well, let’s assume that we have the following simple class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span> {
        
  Printer() {
    System.out.println(<span class="hljs-string">"Reset printer ..."</span>);
  }
       
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNoReset</span><span class="hljs-params">()</span> {
    System.out.println(
      <span class="hljs-string">"Printing (no reset) ..."</span> + Printer.class.hashCode());
  }
        
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printReset</span><span class="hljs-params">()</span> {
    System.out.println(<span class="hljs-string">"Printing (with reset) ..."</span> 
      + Printer.class.hashCode());
  }
}
</code></pre>
    <p class="normal">If we assume that <code class="inlineCode">p1</code> is a method reference and <code class="inlineCode">p2</code> is the corresponding lambda, then we can perform the following calls:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.print(<span class="hljs-string">"p1:"</span>);p1.run();
System.out.print(<span class="hljs-string">"p1:"</span>);p1.run();
System.out.print(<span class="hljs-string">"p2:"</span>);p2.run();
System.out.print(<span class="hljs-string">"p2:"</span>);p2.run();
System.out.print(<span class="hljs-string">"p1:"</span>);p1.run();
System.out.print(<span class="hljs-string">"p2:"</span>);p2.run();
</code></pre>
    <p class="normal">Next, let’s see two scenarios of working with <code class="inlineCode">p1</code> and <code class="inlineCode">p2</code>.</p>
    <h2 id="_idParaDest-406" class="heading-2">Scenario 1: Calling printReset() </h2>
    <p class="normal">In the first <a id="_idIndexMarker1009"/>scenario, we call <code class="inlineCode">printReset()</code> via <code class="inlineCode">p1</code> and <code class="inlineCode">p2</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Printer</span>()::printReset;
<span class="hljs-type">Runnable</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">Printer</span>().printReset();
</code></pre>
    <p class="normal">If we run the code right now, then we get this output (the message generated by the <code class="inlineCode">Printer</code> constructor):</p>
    <pre class="programlisting con"><code class="hljs-con">Reset printer ...
</code></pre>
    <p class="normal">This output is caused by the method reference, <code class="inlineCode">p1</code>. The <code class="inlineCode">Printer</code> constructor is invoked right away, even if we didn’t call the <code class="inlineCode">run()</code> method. Because <code class="inlineCode">p2</code> (the lambda) is lazy, the <code class="inlineCode">Printer</code> constructor is not <a id="_idIndexMarker1010"/>called until we call the <code class="inlineCode">run()</code> method. </p>
    <p class="normal">Going further, we fire the chain of <code class="inlineCode">run()</code> calls for <code class="inlineCode">p1</code> and <code class="inlineCode">p2</code>. The output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">p1:Printing (with reset) ...1159190947
p1:Printing (with reset) ...1159190947
p2:Reset printer ...
Printing (with reset) ...1159190947
p2:Reset printer ...
Printing (with reset) ...1159190947
p1:Printing (with reset) ...1159190947
p2:Reset printer ...
Printing (with reset) ...1159190947
</code></pre>
    <p class="normal">If we analyze this output, we can see that the <code class="inlineCode">Printer</code> constructor is called each time the lambda (<code class="inlineCode">p2.run()</code>) is executed. On the other hand, for the method reference (<code class="inlineCode">p1.run()</code>), the <code class="inlineCode">Printer</code> constructor is not called. It was called a single time, at the <code class="inlineCode">p1</code> declaration. So <code class="inlineCode">p1</code> prints without resetting the printer.</p>
    <h2 id="_idParaDest-407" class="heading-2">Scenario 2: Calling static printNoReset()</h2>
    <p class="normal">Next, let’s call the <a id="_idIndexMarker1011"/>static method <code class="inlineCode">printNoReset()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> Printer::printNoReset;
<span class="hljs-type">Runnable</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> () -&gt; Printer.printNoReset();
</code></pre>
    <p class="normal">If we run the code right away, then nothing will happen (no output). Next, we fire up the <code class="inlineCode">run()</code> calls, and we get this output:</p>
    <pre class="programlisting con"><code class="hljs-con">p1:Printing (no reset) ...149928006
p1:Printing (no reset) ...149928006
p2:Printing (no reset) ...149928006
p2:Printing (no reset) ...149928006
p1:Printing (no reset) ...149928006
p2:Printing (no reset) ...149928006
</code></pre>
    <p class="normal">The <code class="inlineCode">printNoReset()</code> is a static method, so the <code class="inlineCode">Printer</code> constructor is not invoked. We can interchangeably use <code class="inlineCode">p1</code> or <code class="inlineCode">p2</code> without having any difference in behavior. So, in this case, it is just a matter of<a id="_idIndexMarker1012"/> preference.</p>
    <h2 id="_idParaDest-408" class="heading-2">Conclusion</h2>
    <p class="normal">When calling non-static methods, there is one main difference between a method reference and a lambda. A method reference calls the constructor immediately and only once (at method invocation (<code class="inlineCode">run()</code>), the constructor is not called). On the other hand, lambdas are lazy. They call the constructor only at method invocation and at each such invocation (<code class="inlineCode">run()</code>).</p>
    <h1 id="_idParaDest-409" class="heading-1">188. Hooking lambda laziness via Supplier/Consumer</h1>
    <p class="normal">The <code class="inlineCode">java.util.function.Supplier</code> is a functional<a id="_idIndexMarker1013"/> interface capable of supplying results via its <code class="inlineCode">get()</code> method. The <code class="inlineCode">java.util.function.Consumer</code> is another functional interface capable of consuming the argument given via its <code class="inlineCode">accept()</code> method. It returns no result (<code class="inlineCode">void</code>). Both of these functional interfaces are lazy, so it is not that easy to analyze and understand code that uses them, especially when a snippet of code uses both. Let’s give it a try!</p>
    <p class="normal">Consider the following simple class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> c;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> {
    System.out.println(<span class="hljs-string">"Incrementing c from "</span> 
      + c + <span class="hljs-string">" to "</span> + (c + <span class="hljs-number">1</span>));
    <span class="hljs-keyword">return</span> c++; 
  }
}
</code></pre>
    <p class="normal">And let’s write the following <code class="inlineCode">Supplier</code> and <code class="inlineCode">Consumer</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Supplier&lt;Integer&gt; supplier = () -&gt; Counter.count();
Consumer&lt;Integer&gt; consumer = c -&gt; {
  c = c + Counter.count(); 
  System.out.println(<span class="hljs-string">"Consumer: "</span> + c ); 
};
</code></pre>
    <p class="normal">So, at this point, what is <a id="_idIndexMarker1014"/>the value of <code class="inlineCode">Counter.c</code>?</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Counter: "</span> + Counter.c); <span class="hljs-comment">// 0</span>
</code></pre>
    <p class="normal">The correct answer is, <code class="inlineCode">Counter.c</code> is 0. The supplier and the consumer are lazy, so none of the <code class="inlineCode">get()</code> or <code class="inlineCode">accept()</code> methods were called at their declarations. The <code class="inlineCode">Counter.count()</code> was not invoked, so <code class="inlineCode">Counter.c</code> was not incremented.</p>
    <p class="normal">Here is a tricky one… how about now?</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Supplier: "</span> + supplier.get()); <span class="hljs-comment">// 0</span>
</code></pre>
    <p class="normal">We know that by calling <code class="inlineCode">supplier.get()</code>, we trigger the <code class="inlineCode">Counter.count()</code> execution, and <code class="inlineCode">Counter.c</code> should be incremented and become 1. However, the <code class="inlineCode">supplier.get()</code> will return 0.</p>
    <p class="normal">The explanation resides in the <code class="inlineCode">count()</code> method at line <code class="inlineCode">return c++;</code>. When we write <code class="inlineCode">c++</code>, we use the post-increment operation, so we use the current value of <code class="inlineCode">c</code> in our statement (in this case, <code class="inlineCode">return</code>), and afterward, we increment it by 1. This means that <code class="inlineCode">supplier.get()</code> gets back the value of <code class="inlineCode">c</code> as 0, while the incrementation takes place after this <code class="inlineCode">return</code>, and <code class="inlineCode">Counter.c</code> is now 1:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Counter: "</span> + Counter.c); <span class="hljs-comment">// 1</span>
</code></pre>
    <p class="normal">If we switch from post-increment (<code class="inlineCode">c++</code>) to pre-increment (<code class="inlineCode">++c</code>), then <code class="inlineCode">supplier.get()</code> will get back the value of 1, which will be in sync with <code class="inlineCode">Counter.c</code>. This happens because the incrementation takes place before the value is used in our statement (here, <code class="inlineCode">return</code>).</p>
    <p class="normal">OK, so far we know that <code class="inlineCode">Counter.c</code> is equal to 1. Next, let’s call the consumer and pass in the <code class="inlineCode">Counter.c</code> value:</p>
    <pre class="programlisting code"><code class="hljs-code">consumer.accept(Counter.c); 
</code></pre>
    <p class="normal">Via this call, we push the <code class="inlineCode">Counter.c</code> (which is 1) in the following computation and display:</p>
    <pre class="programlisting code"><code class="hljs-code">c -&gt; {
  c = c + Counter.count(); 
  System.out.println(<span class="hljs-string">"Consumer: "</span> + c ); 
} <span class="hljs-comment">// Consumer: 2</span>
</code></pre>
    <p class="normal">So <code class="inlineCode">c = c + Counter.count()</code> can be seen as <code class="inlineCode">Counter.c = Counter.c + Counter.count()</code>, which is <a id="_idIndexMarker1015"/>equivalent to 1 = 1 + <code class="inlineCode">Counter.count()</code>, so 1 = 1 + 1. The output will be <code class="inlineCode">Consumer: 2</code>. This time, <code class="inlineCode">Counter.c</code> is also 2 (remember the post-increment effect):</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Counter: "</span> + Counter.c); <span class="hljs-comment">// 2      </span>
</code></pre>
    <p class="normal">Next, let’s invoke the supplier:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Supplier: "</span> + supplier.get()); <span class="hljs-comment">// 2</span>
</code></pre>
    <p class="normal">We know that <code class="inlineCode">get()</code> will receive the current value of <code class="inlineCode">c</code>, which is 2. Afterward, <code class="inlineCode">Counter.c</code> becomes 3:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Counter: "</span> + Counter.c); <span class="hljs-comment">// 3</span>
</code></pre>
    <p class="normal">We can continue like this forever, but I think you’ve got an idea of how the <code class="inlineCode">Supplier</code> and <code class="inlineCode">Consumer</code> functional interfaces work.</p>
    <h1 id="_idParaDest-410" class="heading-1">189. Refactoring code to add lambda laziness</h1>
    <p class="normal">In this problem, let’s have a refactoring session designed to transform a dysfunctional code into a functional one. We <a id="_idIndexMarker1016"/>start from the following given code – a simple piece of class mapping information about application dependencies:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationDependency</span> {
    
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> id;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
  <span class="hljs-keyword">private</span> String dependencies;
  <span class="hljs-keyword">public</span> <span class="hljs-title">ApplicationDependency</span><span class="hljs-params">(</span><span class="hljs-type">long</span><span class="hljs-params"> id, String name)</span> {
    <span class="hljs-built_in">this</span>.id = id;
    <span class="hljs-built_in">this</span>.name = name;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> id;
  }
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> name;
  }   
    
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> String </strong><strong class="hljs-title-slc">getDependencies</strong><strong class="hljs-params-slc">()</strong><strong class="hljs-slc"> {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> dependencies;</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  }</strong></span>  
    
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloadDependencies</span><span class="hljs-params">()</span> {
          
    dependencies = <span class="hljs-string">"list of dependencies </span>
<span class="hljs-string">      downloaded from repository "</span> + Math.random();
  }    
}
</code></pre>
    <p class="normal">Why did we highlight the <code class="inlineCode">getDependencies()</code> method? Because this is the point in the application where there is dysfunction. More precisely, the following class needs the dependencies of an <a id="_idIndexMarker1017"/>application in order to process them accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DependencyManager</span> {
    
  <span class="hljs-keyword">private</span> Map&lt;Long,String&gt; apps = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
    
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processDependencies</span><span class="hljs-params">(ApplicationDependency appd)</span>{
        
    System.out.println();
    System.out.println(<span class="hljs-string">"Processing app: "</span> + appd.getName());
    System.out.println(<span class="hljs-string">"Dependencies: "</span> 
      + <span class="code-highlight"><strong class="hljs-slc">appd.getDependencies()</strong></span>);
        
    apps.put(appd.getId(),<span class="code-highlight"><strong class="hljs-slc">appd.getDependencies()</strong></span>); 
  }    
}
</code></pre>
    <p class="normal">This class relies on the <code class="inlineCode">ApplicationDependency.getDependecies()</code> method, which just returns <code class="inlineCode">null</code> (the default value of the <code class="inlineCode">dependencies</code> fields). The expected application’s dependencies were not downloaded, since the <code class="inlineCode">downloadDependecies()</code> method was not called. Most probably, a <a id="_idIndexMarker1018"/>code reviewer will signal this issue and raise a ticket to fix it.</p>
    <h2 id="_idParaDest-411" class="heading-2">Fixing in imperative fashion</h2>
    <p class="normal">A possible fix will be as<a id="_idIndexMarker1019"/> follows (in <code class="inlineCode">ApplicationDependency</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationDependency</span> {
    
  <span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> </strong><strong class="hljs-type-slc">String</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">dependencies</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> downloadDependencies();</strong></span>
  ...
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getDependencies</span><span class="hljs-params">()</span> {
             
    <span class="hljs-keyword">return</span> dependencies;
  }
  ...
  <span class="hljs-keyword">private</span> String <span class="hljs-title">downloadDependencies</span><span class="hljs-params">()</span> {
           
    <span class="hljs-keyword">return</span> <span class="hljs-string">"list of dependencies downloaded from repository "</span> 
      + Math.random();
  }  
}
</code></pre>
    <p class="normal">Calling <code class="inlineCode">downloadDependencies()</code> at <code class="inlineCode">dependencies</code> initialization will definitely fix the problem of loading the dependencies. When the <code class="inlineCode">DependencyManager</code> calls <code class="inlineCode">getDependencies()</code>, it will have access to the downloaded dependencies. However, is this a good approach? I mean, downloading the dependencies is a costly operation, and we do it every time an <code class="inlineCode">ApplicationDependency</code> instance is created. If the <code class="inlineCode">getDependencies()</code> method is never called, then this costly operation doesn’t pay off the effort.</p>
    <p class="normal">So a better approach would be to postpone the download of the application’s dependencies until <code class="inlineCode">getDependencies()</code> is actually called:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationDependency</span> {
  <span class="hljs-keyword">private</span> String dependencies;
  ...
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getDependencies</span><span class="hljs-params">()</span> {
               
    <span class="code-highlight"><strong class="hljs-slc">downloadDependencies();</strong></span> 
       
    <span class="hljs-keyword">return</span> dependencies;
  }  
  ...
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloadDependencies</span><span class="hljs-params">()</span> {
           
    dependencies = <span class="hljs-string">"list of dependencies </span>
<span class="hljs-string">      downloaded from repository "</span> + Math.random();
  }    
}
</code></pre>
    <p class="normal">This is better, but it is not the<a id="_idIndexMarker1020"/> best approach! This time, the application’s dependencies are downloaded every time the <code class="inlineCode">getDependencies()</code> method is called. Fortunately, there is a quick fix for this. We just need to add a <code class="inlineCode">null</code> check before performing the download:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDependencies</span><span class="hljs-params">()</span> {
        
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (dependencies == </strong><strong class="hljs-literal-slc">null</strong><strong class="hljs-slc">) {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    downloadDependencies();</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  }</strong></span>
        
  <span class="hljs-keyword">return</span> dependencies;
}  
</code></pre>
    <p class="normal">Done! Now, the application’s dependencies are downloaded only at the first call of the <code class="inlineCode">getDependencies()</code> method. This imperative solution works like a charm and passes the code review.</p>
    <h2 id="_idParaDest-412" class="heading-2">Fixing in functional fashion</h2>
    <p class="normal">How about providing this fix in a functional programming fashion? Practically, all we want is to lazy-download the application’s dependencies. Since laziness is a specialty of functional programming, and<a id="_idIndexMarker1021"/> we’re now familiar with the <code class="inlineCode">Supplier</code> (see the previous problem), we can start as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationDependency</span> {
          
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">final</strong><strong class="hljs-slc"> Supplier&lt;String&gt; dependencies </strong></span>
<span class="code-highlight"><strong class="hljs-slc">    = </strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">::downloadDependencies;    </strong></span>
<span class="code-highlight"><strong class="hljs-slc">  ...</strong></span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getDependencies</span><span class="hljs-params">()</span> {
    <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> dependencies.get();</strong></span>
  }   
  ...
  <span class="hljs-keyword">private</span> <span class="code-highlight"><strong class="hljs-slc">String</strong></span> <span class="hljs-title">downloadDependencies</span><span class="hljs-params">()</span> {
           
    <span class="hljs-keyword">return</span> <span class="hljs-string">"list of dependencies downloaded from repository "</span> 
     + Math.random();
  } 
}
</code></pre>
    <p class="normal">First, we defined a <code class="inlineCode">Supplier</code> that calls the <code class="inlineCode">downloadDependencies()</code> method. We know that the <code class="inlineCode">Supplier</code> is lazy, so nothing happens until its <code class="inlineCode">get()</code> method is explicitly called.</p>
    <p class="normal">Second, we have modified <code class="inlineCode">getDependencies()</code> to return <code class="inlineCode">dependencies.get()</code>. So we delay the application’s <a id="_idIndexMarker1022"/>dependencies downloading until they are explicitly required.</p>
    <p class="normal">Third, we modified the return type of the <code class="inlineCode">downloadDependencies()</code> method from <code class="inlineCode">void</code> to <code class="inlineCode">String</code>. This is needed for the <code class="inlineCode">Supplier.get()</code>. </p>
    <p class="normal">This is a nice fix, but it has a serious shortcoming. We lost the caching! Now, the dependencies will be downloaded at every <code class="inlineCode">getDependencies()</code> call.</p>
    <p class="normal">We can avoid this issue via <em class="italic">memoization</em> (<a href="https://en.wikipedia.org/wiki/Memoization"><span class="url">https://en.wikipedia.org/wiki/Memoization</span></a>). This concept is also covered in detail in <em class="italic">Chapter 8</em> of <em class="italic">The Complete Coding Interview Guide in Java</em>. In a nutshell, memoization is a technique used to avoid duplicate work by caching results that can be reused later.</p>
    <p class="normal">Memoization is a technique commonly applied in dynamic programming, but there are no restrictions or limitations. For instance, we can apply it in functional programming. In our particular case, we start by defining a functional interface that extends the <code class="inlineCode">Supplier</code> interface (or, if you find it simpler, just use <code class="inlineCode">Supplier</code> directly):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">FSupplier</span>&lt;R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Supplier</span>&lt;R&gt; {}
</code></pre>
    <p class="normal">Next, we provide an implementation of <code class="inlineCode">FSupplier</code> that basically cashes the unseen results and serves, from the cache, the already seen ones:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Memoize</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Object</span>();
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; FSupplier&lt;T&gt; <span class="hljs-title">supplier</span><span class="hljs-params">(</span>
<span class="hljs-params">    </span><span class="hljs-keyword">final</span><span class="hljs-params"> Supplier&lt;T&gt; supplier)</span> {
       
    <span class="hljs-type">AtomicReference</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AtomicReference</span>&lt;&gt;(UNDEFINED);
      
    <span class="hljs-keyword">return</span> () -&gt; { 
            
      <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cache.get(); 
            
      <span class="hljs-keyword">if</span> (value == UNDEFINED) { 
                
        <span class="hljs-keyword">synchronized</span> (cache) {
                   
          <span class="hljs-keyword">if</span> (cache.get() == UNDEFINED) {
                        
            System.out.println(<span class="hljs-string">"Caching: "</span> + supplier.get());
            value = supplier.get();
            cache.set(value);
          }
        }
      }
            
      <span class="hljs-keyword">return</span> (T) value;
    };
  }
}
</code></pre>
    <p class="normal">Finally, we replace our initial <code class="inlineCode">Supplier</code> with <code class="inlineCode">FSupplier</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;String&gt; dependencies 
  = Memoize.supplier(<span class="hljs-built_in">this</span>::downloadDependencies);
</code></pre>
    <p class="normal">Done! Our functional<a id="_idIndexMarker1023"/> approach takes advantage of <code class="inlineCode">Supplier</code>'s laziness and can cache the results.</p>
    <h1 id="_idParaDest-413" class="heading-1">190. Writing a Function&lt;String, T&gt; for parsing data</h1>
    <p class="normal">Let’s assume that we<a id="_idIndexMarker1024"/> have the following text:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">  test, a, 1, 4, 5, 0xf5, 0x5, 4.5d, 6, 5.6, 50000, 345, </span>
<span class="hljs-string">  4.0f, 6$3, 2$1.1, 5.5, 6.7, 8, a11, 3e+1, -11199, 55 </span>
<span class="hljs-string">  """</span>;
</code></pre>
    <p class="normal">The goal is to find a solution that extracts from this text only the numbers. Depending on a given scenario, we may need only the integers, or only the doubles, and so on. Sometimes, we may need to perform some text replacements before extraction (for instance, we may want<a id="_idIndexMarker1025"/> to replace the <code class="inlineCode">xf</code> characters with a dot, <code class="inlineCode">0xf5 = 0.5</code>).</p>
    <p class="normal">A possible solution to this problem is to write a method (let’s name it <code class="inlineCode">parseText()</code>) that takes as an argument a <code class="inlineCode">Function&lt;String, T&gt;</code>. The <code class="inlineCode">Function&lt;String, T&gt;</code> gives us the flexibility to shape any of the following:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Integer&gt; integerValues 
  = parseText(text, Integer::valueOf);
List&lt;Double&gt; doubleValues 
  = parseText(text, Double::valueOf);
...
List&lt;Double&gt; moreDoubleValues 
  = parseText(text, t -&gt; Double.valueOf(t.replaceAll(
      <span class="hljs-string">"\\$"</span>, <span class="hljs-string">""</span>).replaceAll(<span class="hljs-string">"xf"</span>, <span class="hljs-string">"."</span>).replaceAll(<span class="hljs-string">"x"</span>, <span class="hljs-string">"."</span>)));
</code></pre>
    <p class="normal">The <code class="inlineCode">parseText()</code> should perform several steps until it reaches the final result. Its signature can be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title">parseText</span><span class="hljs-params">(</span>
<span class="hljs-params">    String text, Function&lt;String, T&gt; func)</span> {
  ...
}
</code></pre>
    <p class="normal">First, we have to split the received text by the comma delimiter and extract the items in a <code class="inlineCode">String[]</code>. This way, we have access to each item from the text.</p>
    <p class="normal">Second, we can stream the <code class="inlineCode">String[]</code> and filter any empty items.</p>
    <p class="normal">Third, we can call the <code class="inlineCode">Function.apply()</code> to apply the given function to each item (for instance, to apply <code class="inlineCode">Double::valueOf</code>). This can be done via the intermediate operation <code class="inlineCode">map()</code>. Since some items may be invalid numbers, we have to catch and ignore any <code class="inlineCode">Exception</code> (it is bad practice to swallow an exception like this, but in this case, there is really nothing else to do). For any invalid number, we simply return <code class="inlineCode">null</code>.</p>
    <p class="normal">Fourth, we filter all <code class="inlineCode">null</code> values. This means that the remaining stream contains only numbers that passed through <code class="inlineCode">Function.apply()</code>.</p>
    <p class="normal">Fifth, we collect the stream in a <code class="inlineCode">List</code> and return it.</p>
    <p class="normal">Putting these five steps<a id="_idIndexMarker1026"/> together will result in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title">parseText</span><span class="hljs-params">(</span>
<span class="hljs-params">    String text, Function&lt;String, T&gt; func)</span> {
  <span class="hljs-keyword">return</span> Arrays.stream(text.split(<span class="hljs-string">","</span>)) <span class="hljs-comment">// step 1 and 2</span>
    .filter(s -&gt; !s.isEmpty())
    .map(s -&gt; {
       <span class="hljs-keyword">try</span> {
         <span class="hljs-keyword">return</span> func.apply(s.trim());   <span class="hljs-comment">// step 3</span>
       } <span class="hljs-keyword">catch</span> (Exception e) {}
       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    })
    .filter(Objects::nonNull)           <span class="hljs-comment">// step 4</span>
    .collect(Collectors.toList());      <span class="hljs-comment">// step 5</span>
}
</code></pre>
    <p class="normal">Done! You can use this example to solve a wide range of similar problems.</p>
    <h1 id="_idParaDest-414" class="heading-1">191. Composing predicates in a Stream’s filters</h1>
    <p class="normal">A predicate (basically, a condition) can be<a id="_idIndexMarker1027"/> modeled as a Boolean-valued function via the <code class="inlineCode">java.util.function.Predicate</code> functional interface. Its functional method is named <code class="inlineCode">test(T t)</code> and returns a <code class="inlineCode">boolean</code>.</p>
    <p class="normal">Applying predicates in a<a id="_idIndexMarker1028"/> stream pipeline can be done via several stream intermediate operations, but we are interested here only in the <code class="inlineCode">filter(Predicate p)</code> operation. For instance, let’s consider the following class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  <span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(String brand, String fuel, </span><span class="hljs-type">int</span><span class="hljs-params"> horsepower)</span> {
    <span class="hljs-built_in">this</span>.brand = brand;
    <span class="hljs-built_in">this</span>.fuel = fuel;
    <span class="hljs-built_in">this</span>.horsepower = horsepower;
  }
  
  <span class="hljs-comment">// getters, equals(), hashCode(), toString()</span>
}
</code></pre>
    <p class="normal">If we have a <code class="inlineCode">List&lt;Car&gt;</code> and we want to express a filter that produces all the cars that are Chevrolets, then we can<a id="_idIndexMarker1029"/> start by defining the proper <code class="inlineCode">Predicate</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pChevrolets 
  = car -&gt; car.getBrand().equals(<span class="hljs-string">"Chevrolet"</span>);
</code></pre>
    <p class="normal">Next, we can use this <code class="inlineCode">Predicate</code> in a stream pipeline, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; chevrolets = cars.stream() 
  .filter(pChevrolets)
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">A <code class="inlineCode">Predicate</code> can be negated in at least three ways. We can negate the condition via the logical not (<code class="inlineCode">!</code>) operator:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pNotChevrolets 
  = car -&gt; !car.getBrand().equals(<span class="hljs-string">"Chevrolet"</span>);
</code></pre>
    <p class="normal">We can call the <code class="inlineCode">Predicate.negate()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pNotChevrolets = pChevrolets.negate(); 
</code></pre>
    <p class="normal">Or we can call the <code class="inlineCode">Predicate.not()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pNotChevrolets = Predicate.not(pChevrolets);
</code></pre>
    <p class="normal">No matter which of these three approaches you prefer, the following filter will produce all cars that are not Chevrolets:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; notChevrolets = cars.stream() 
  .filter(pNotChevrolets) 
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">In the previous examples, we applied a single predicate in a stream pipeline. However, we can apply multiple predicates as well. For instance, we may want to express a filter that produces all the cars that are not Chevrolets and have at least 150 horsepower. For the first part of this composite predicate, we can arbitrarily use <code class="inlineCode">pChevrolets.negate()</code>, while, for the second<a id="_idIndexMarker1030"/> part, we need the following <code class="inlineCode">Predicate</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pHorsepower 
  = car -&gt; car.getHorsepower() &gt;= <span class="hljs-number">150</span>;
</code></pre>
    <p class="normal">We can obtain a composite predicate by chaining the <code class="inlineCode">filter()</code> calls, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; notChevrolets150 = cars.stream() 
  .filter(pChevrolets.negate())
  .filter(pHorsepower)
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">It is shorter and more expressive to rely on <code class="inlineCode">Predicate.and(Predicate&lt;? super T&gt; other)</code>, which applies the short-circuiting logical AND between two predicates. So the previous example is better expressed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; notChevrolets150 = cars.stream()
  .filter(pChevrolets.negate().and(pHorsepower))
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">If we need to apply the short-circuiting logical OR between two predicates, then relying on <code class="inlineCode">Predicate.or(Predicate&lt;? super T&gt; other)</code> is the proper choice. For instance, if we want to express a filter that produces all Chevrolets or electric cars, then we can do it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pElectric 
  = car -&gt; car.getFuel().equals(<span class="hljs-string">"electric"</span>);
        
List&lt;Car&gt; chevroletsOrElectric = cars.stream() 
  .filter(pChevrolets.or(pElectric))
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">If we are in a scenario that heavily relies on composite predicates, then we can start by creating two helpers that make our job easier:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Predicates</span> {
    
  <span class="hljs-keyword">private</span> <span class="hljs-title">Predicates</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title">asOneAnd</span><span class="hljs-params">(</span>
<span class="hljs-params">      Predicate&lt;T&gt;... predicates)</span> {
    Predicate&lt;T&gt; theOneAnd = Stream.of(predicates)
      .reduce(p -&gt; <span class="hljs-literal">true</span>, Predicate::and);
        
    <span class="hljs-keyword">return</span> theOneAnd;
  }
    
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title">asOneOr</span><span class="hljs-params">(</span>
<span class="hljs-params">      Predicate&lt;T&gt;... predicates)</span> {
    Predicate&lt;T&gt; theOneOr = Stream.of(predicates)
      .reduce(p -&gt; <span class="hljs-literal">false</span>, Predicate::or);
        
    <span class="hljs-keyword">return</span> theOneOr; 
  }
}
</code></pre>
    <p class="normal">The goal of these helpers is to take several predicates and glue them into a single composite predicate, via the<a id="_idIndexMarker1031"/> short-circuiting logical AND and OR. </p>
    <p class="normal">Let’s assume that we want to express a filter that applies the following three predicates via the short-circuiting logical AND:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pLexus = car -&gt; car.getBrand().equals(<span class="hljs-string">"Lexus"</span>);
Predicate&lt;Car&gt; pDiesel = car -&gt; car.getFuel().equals(<span class="hljs-string">"diesel"</span>); 
Predicate&lt;Car&gt; p250 = car -&gt; car.getHorsepower() &gt; <span class="hljs-number">250</span>; 
</code></pre>
    <p class="normal">First, we join these predicates in a single one:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; predicateAnd = Predicates
  .asOneAnd(pLexus, pDiesel, p250);
</code></pre>
    <p class="normal">Afterward, we express the filter:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; lexusDiesel250And = cars.stream() 
  .filter(predicateAnd) 
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">How about expressing a filter that produces a stream containing all cars with horsepower between 100 and 200 or 300 and 400? The predicates are:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; p100 = car -&gt; car.getHorsepower() &gt;= <span class="hljs-number">100</span>;
Predicate&lt;Car&gt; p200 = car -&gt; car.getHorsepower() &lt;= <span class="hljs-number">200</span>;
        
Predicate&lt;Car&gt; p300 = car -&gt; car.getHorsepower() &gt;= <span class="hljs-number">300</span>;
Predicate&lt;Car&gt; p400 = car -&gt; car.getHorsepower() &lt;= <span class="hljs-number">400</span>;
</code></pre>
    <p class="normal">The composite predicate <a id="_idIndexMarker1032"/>can be obtained as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; pCombo = Predicates.asOneOr(
  Predicates.asOneAnd(p100, p200), 
  Predicates.asOneAnd(p300, p400)
);
</code></pre>
    <p class="normal">Expressing the filter is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; comboAndOr = cars.stream() 
  .filter(pCombo) 
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">You can find all these examples in the bundled code.</p>
    <h1 id="_idParaDest-415" class="heading-1">192. Filtering nested collections with Streams</h1>
    <p class="normal">This is a classical problem in interviews <a id="_idIndexMarker1033"/>that usually starts <a id="_idIndexMarker1034"/>from a model, as follows (we assume that the collection is a <code class="inlineCode">List</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Book&gt; books;
  ...
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> {
    
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String title;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LocalDate published;
  ...
}
</code></pre>
    <p class="normal">Having <code class="inlineCode">List&lt;Author&gt;</code> denoted as <code class="inlineCode">authors</code>, write a stream pipeline that returns the <code class="inlineCode">List&lt;Book&gt;</code> published in 2002. You already should recognize this as a typical problem for <code class="inlineCode">flatMap()</code>, so without further <a id="_idIndexMarker1035"/>details, we can write this:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Book&gt; book2002fm = authors.stream()
  .flatMap(author -&gt; author.getBooks().stream())
  .filter(book -&gt; book.getPublished().getYear() == <span class="hljs-number">2002</span>)
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">From <em class="italic">Problem 185</em>, we know that wherever <code class="inlineCode">flatMap()</code> is useful, we should also consider the JDK 16’s <code class="inlineCode">mapMulti()</code>. Before<a id="_idIndexMarker1036"/> checking the following snippet of code, challenge yourself to rewrite the previous code via <code class="inlineCode">mapMulti()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Book&gt; book2002mm = authors.stream()
  .&lt;Book&gt;mapMulti((author, consumer) -&gt; {
     <span class="hljs-keyword">for</span> (Book book : author.getBooks()) {
       <span class="hljs-keyword">if</span> (book.getPublished().getYear() == <span class="hljs-number">2002</span>) {
         consumer.accept(book);
       }
     }
   })
   .collect(Collectors.toList());
</code></pre>
    <p class="normal">OK, that’s crystal clear! How about finding the <code class="inlineCode">List&lt;Author&gt;</code> with books published in 2002? Of course, <code class="inlineCode">mapMulti()</code> can help us again. All we have to do is to loop the books, and when we find a book published in 2002, we simply pass the <code class="inlineCode">author</code> to the <code class="inlineCode">consumer</code> instead of the book. Moreover, after passing the <code class="inlineCode">author</code> to the <code class="inlineCode">consumer</code>, we can break the loop for the current author and take the next one:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Author&gt; author2002mm = authors.stream()
  .&lt;Author&gt;mapMulti((author, consumer) -&gt; {
     <span class="hljs-keyword">for</span> (Book book : author.getBooks()) {
       <span class="hljs-keyword">if</span> (book.getPublished().getYear() == <span class="hljs-number">2002</span>) {
         consumer.accept(author);
         <span class="hljs-keyword">break</span>;
       }
     }
   })
   .collect(Collectors.toList());
</code></pre>
    <p class="normal">Another approach can rely on <code class="inlineCode">anyMatch()</code> and a predicate that produces a stream of books published in 2002, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Author&gt; authors2002am = authors.stream()
  .filter(
     author -&gt; author.getBooks()
                     .stream()
                     .anyMatch(book -&gt; book.getPublished()
                       .getYear() == <span class="hljs-number">2002</span>)
  )
 .collect(Collectors.toList());
</code></pre>
    <p class="normal">Typically, we don’t want to alter<a id="_idIndexMarker1037"/> the given list, but if that is not an issue (or it is exactly what we want), then we can rely on <code class="inlineCode">removeIf()</code> to accomplish the same result directly on the <code class="inlineCode">List&lt;Author&gt;</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">authors.removeIf(author -&gt; author.getBooks().stream()
  .noneMatch(book -&gt; book.getPublished().getYear() == <span class="hljs-number">2002</span>));
</code></pre>
    <p class="normal">Done! Now, you should <a id="_idIndexMarker1038"/>have no issues if a problem like this comes up in your interviews.</p>
    <h1 id="_idParaDest-416" class="heading-1">193. Using BiPredicate</h1>
    <p class="normal">Let’s consider the <code class="inlineCode">Car</code> model<a id="_idIndexMarker1039"/> and a <code class="inlineCode">List&lt;Car&gt;</code> denoted as <code class="inlineCode">cars</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
</code></pre>
    <p class="normal">Our goal is to see if the following <code class="inlineCode">Car</code> is contained in <code class="inlineCode">cars</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Ford"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">80</span>);
</code></pre>
    <p class="normal">We know that the <code class="inlineCode">List</code> API exposes a method named <code class="inlineCode">contains(Object o)</code>. This method returns <code class="inlineCode">true</code> if the given <code class="inlineCode">Object</code> is present in the given <code class="inlineCode">List</code>. So, we can easily write a <code class="inlineCode">Predicate</code>, as follows: </p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; predicate = cars::contains;
</code></pre>
    <p class="normal">Next, we call the <code class="inlineCode">test()</code> method, and we <a id="_idIndexMarker1040"/>should get the expected result:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(predicate.test(car)); <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal">We can obtain the same result in a stream pipeline via <code class="inlineCode">filter()</code>, <code class="inlineCode">anyMatch()</code>, and so on. Here is via <code class="inlineCode">anyMatch()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(
  cars.stream().anyMatch(p -&gt; p.equals(car))
);
</code></pre>
    <p class="normal">Alternatively, we can rely on <code class="inlineCode">BiPredicate</code>. This is a functional interface representing a two-arity specialization of the well-known <code class="inlineCode">Predicate</code>. Its <code class="inlineCode">test(Object o1, Object o2)</code> method gets two arguments, so it is a perfect fit for our case:</p>
    <pre class="programlisting code"><code class="hljs-code">BiPredicate&lt;List&lt;Car&gt;, Car&gt; biPredicate = List::contains;
</code></pre>
    <p class="normal">We can perform the test as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(biPredicate.test(cars, car)); <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal">In the next problem, you’ll see a more practical example of using a <code class="inlineCode">BiPredicate</code>.</p>
    <h1 id="_idParaDest-417" class="heading-1">194. Building a dynamic predicate for a custom model</h1>
    <p class="normal">Let’s<a id="_idIndexMarker1041"/> consider the <code class="inlineCode">Car</code> model and a <code class="inlineCode">List&lt;Car&gt;</code> denoted as cars:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
</code></pre>
    <p class="normal">Also, let’s assume that we need to dynamically produce a wide range of predicates that apply the operators <code class="inlineCode">&lt;</code>, <code class="inlineCode">&gt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;=</code>, <code class="inlineCode">!=</code>, and <code class="inlineCode">==</code> to the <code class="inlineCode">horsepower</code> field. It will be cumbersome to hardcode such predicates, so we have to come up with a solution that can build, on the fly, any predicate that involves this field, and one of the comparison operators listed here.</p>
    <p class="normal">There are a few approaches to<a id="_idIndexMarker1042"/> accomplish this goal, and one of them is to use a Java <code class="inlineCode">enum</code>. We have a fixed list of operators that can be coded as <code class="inlineCode">enum</code> elements, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span> <span class="hljs-title">PredicateBuilder</span> {
  GT((t, u) -&gt; t &gt; u),
  LT((t, u) -&gt; t &lt; u),
  GE((t, u) -&gt; t &gt;= u),
  LE((t, u) -&gt; t &lt;= u),
  EQ((t, u) -&gt; t.intValue() == u.intValue()),
  NOT_EQ((t, u) -&gt; t.intValue() != u.intValue());
  ...
</code></pre>
    <p class="normal">In order to apply any of these <code class="inlineCode">(t, u)</code> lambdas, we need a <code class="inlineCode">BiPredicate</code> constructor (see <em class="italic">Problem 193</em>), as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BiPredicate&lt;Integer, Integer&gt; predicate;
  <span class="hljs-keyword">private</span> <span class="hljs-title">PredicateBuilder</span><span class="hljs-params">(</span>
<span class="hljs-params">      BiPredicate&lt;Integer, Integer&gt; predicate)</span> {
    <span class="hljs-built_in">this</span>.predicate = predicate;
  }
  ...
</code></pre>
    <p class="normal">Now that we can define a <code class="inlineCode">BiPredicate</code>, we can write the method that contains the actual test and returns a <code class="inlineCode">Predicate&lt;T&gt;</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">public</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title">toPredicate</span><span class="hljs-params">(</span>
<span class="hljs-params">      Function&lt;T, Integer&gt; getter, </span><span class="hljs-type">int</span><span class="hljs-params"> u)</span> {
    <span class="hljs-keyword">return</span> obj -&gt; <span class="hljs-built_in">this</span>.predicate.test(getter.apply(obj), u);
  }
  ...
</code></pre>
    <p class="normal">Finally, we have to provide here the <code class="inlineCode">Function&lt;T, Integer&gt;</code>, which is the getter corresponding to <code class="inlineCode">horsepower</code>. We can do this via Java Reflection, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Function&lt;T, Integer&gt; <span class="hljs-title">getFieldByName</span><span class="hljs-params">(</span>
<span class="hljs-params">    Class&lt;T&gt; cls, String field)</span> {
  <span class="hljs-keyword">return</span> object -&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> cls.getDeclaredField(field);
      f.setAccessible(<span class="hljs-literal">true</span>);
      <span class="hljs-keyword">return</span> (Integer) f.get(object);
    } <span class="hljs-keyword">catch</span> (IllegalAccessException | IllegalArgumentException
           | NoSuchFieldException | SecurityException e) { 
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(e);
    }
  };
}
</code></pre>
    <p class="normal">Of course, it can be any <a id="_idIndexMarker1043"/>other class and integer field as well, not only the <code class="inlineCode">Car</code> class and the <code class="inlineCode">horsepower</code> field. Based on this code, we can dynamically create a predicate, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; gtPredicate 
  = PredicateBuilder.GT.toPredicate(
      PredicateBuilder.getFieldByName(
        Car.class, <span class="hljs-string">"horsepower"</span>), <span class="hljs-number">300</span>);
</code></pre>
    <p class="normal">Using this predicate is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .filter(gtPredicate)
    .forEach(System.out::println);
</code></pre>
    <p class="normal">You can use this problem as a source of inspiration to implement more types of dynamic predicates. For example, in the next problem, we use the same logic in another scenario.</p>
    <h1 id="_idParaDest-418" class="heading-1">195. Building a dynamic predicate from a custom map of conditions</h1>
    <p class="normal">Let’s consider the <code class="inlineCode">Car</code> model<a id="_idIndexMarker1044"/> and a <code class="inlineCode">List&lt;Car&gt;</code> denoted as <code class="inlineCode">cars</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
</code></pre>
    <p class="normal">Also, let’s assume that we receive a <code class="inlineCode">Map</code> of conditions of type <em class="italic">field : value,</em> which could be used to build a dynamic <code class="inlineCode">Predicate</code>. An example of such a <code class="inlineCode">Map</code> is listed here:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;String, String&gt; filtersMap = Map.of(
  <span class="hljs-string">"brand"</span>, <span class="hljs-string">"Chevrolet"</span>,
  <span class="hljs-string">"fuel"</span>, <span class="hljs-string">"diesel"</span>
);
</code></pre>
    <p class="normal">As you can see, we have a <code class="inlineCode">Map&lt;String, String&gt;</code>, so we are interested in an <code class="inlineCode">equals()</code> comparison. This is useful to start our development via the following Java <code class="inlineCode">enum</code> (we follow the logic from <em class="italic">Problem 194</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span> <span class="hljs-title">PredicateBuilder</span> {
  EQUALS(String::equals);
  ...
</code></pre>
    <p class="normal">Of course, we can add more operators, such as <code class="inlineCode">startsWith()</code>, <code class="inlineCode">endsWith()</code>, <code class="inlineCode">contains()</code>, and so on. Next, based on the experience gained in <em class="italic">Problems 193</em> and <em class="italic">194</em>, we need to add a <code class="inlineCode">BiPredicate</code> constructor, the <code class="inlineCode">toPredicate()</code> method, and the Java Reflection code to fetch the getters corresponding to the given fields (here, <code class="inlineCode">brand</code> and <code class="inlineCode">fuel</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BiPredicate&lt;String, String&gt; predicate;
  <span class="hljs-keyword">private</span> <span class="hljs-title">PredicateBuilder</span><span class="hljs-params">(</span>
<span class="hljs-params">      BiPredicate&lt;String, String&gt; predicate)</span> {
    <span class="hljs-built_in">this</span>.predicate = predicate;
  }
  <span class="hljs-keyword">public</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title">toPredicate</span><span class="hljs-params">(</span>
<span class="hljs-params">      Function&lt;T, String&gt; getter, String u)</span> {
    <span class="hljs-keyword">return</span> obj -&gt; <span class="hljs-built_in">this</span>.predicate.test(getter.apply(obj), u);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Function&lt;T, String&gt; 
      <span class="hljs-title">getFieldByName</span><span class="hljs-params">(Class&lt;T&gt; cls, String field)</span> {
    <span class="hljs-keyword">return</span> object -&gt; {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> cls.getDeclaredField(field);
        f.setAccessible(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">return</span> (String) f.get(object);
      } <span class="hljs-keyword">catch</span> (
          IllegalAccessException | IllegalArgumentException
          | NoSuchFieldException | SecurityException e) { 
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(e);
      }
    };
  }        
}
</code></pre>
    <p class="normal">Next, we have to define a predicate for each map entry and chain them via the short-circuiting AND operator. This can<a id="_idIndexMarker1045"/> be done in a loop, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Car&gt; filterPredicate = t -&gt; <span class="hljs-literal">true</span>;
<span class="hljs-keyword">for</span>(String key : filtersMap.keySet()) {
  filterPredicate 
    = filterPredicate.and(PredicateBuilder.EQUALS
      .toPredicate(PredicateBuilder.getFieldByName(
        Car.class, key), filtersMap.get(key))); 
}  
</code></pre>
    <p class="normal">Finally, we can use the resulting predicate to filter the cars:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .filter(filterPredicate)
    .forEach(System.out::println);
</code></pre>
    <p class="normal">Done!</p>
    <h1 id="_idParaDest-419" class="heading-1">196. Logging in predicates</h1>
    <p class="normal">We already know that the <code class="inlineCode">Predicate</code> functional interface relies on its <code class="inlineCode">test()</code> method to perform the given check, and it returns a<a id="_idIndexMarker1046"/> Boolean value. Let’s suppose that we want to alter the <code class="inlineCode">test()</code> method to log the failure cases (the cases that lead to the return of a <code class="inlineCode">false</code> value). </p>
    <p class="normal">A quick approach is to write a helper method that sneaks the logging part, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Predicates</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> 
    <span class="hljs-operator">=</span> LoggerFactory.getLogger(LogPredicate.class);
  <span class="hljs-keyword">private</span> <span class="hljs-title">Predicates</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title">testAndLog</span><span class="hljs-params">(</span>
<span class="hljs-params">      Predicate&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T&gt; predicate, String val)</span> {
    <span class="hljs-keyword">return</span> t -&gt; {
      <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> predicate.test(t);
      <span class="hljs-keyword">if</span> (!result) {
        logger.warn(predicate + <span class="hljs-string">" don't match '"</span> + val + <span class="hljs-string">"'"</span>);
      }
      <span class="hljs-keyword">return</span> result;
    };
  }
}
</code></pre>
    <p class="normal">Another approach consists of extending the <code class="inlineCode">Predicate</code> interface and providing a <code class="inlineCode">default</code> method for testing and logging the failure cases, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LogPredicate</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Predicate</span>&lt;T&gt; {
  <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(LogPredicate.class);
   
  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">testAndLog</span><span class="hljs-params">(T t, String val)</span> {
    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.test(t);
    <span class="hljs-keyword">if</span> (!result) {
      logger.warn(t + <span class="hljs-string">" don't match '"</span> + val + <span class="hljs-string">"'"</span>);
    }
    <span class="hljs-keyword">return</span> result;
  }
}
</code></pre>
    <p class="normal">You can practice these examples in<a id="_idIndexMarker1047"/> the bundled code.</p>
    <h1 id="_idParaDest-420" class="heading-1">197. Extending Stream with containsAll() and containsAny()</h1>
    <p class="normal">Let’s assume that we have the<a id="_idIndexMarker1048"/> following code:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; cars = Arrays.asList(
  <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Dacia"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">100</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"gasoline"</span>, <span class="hljs-number">300</span>), 
  ...
  <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Ford"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">200</span>)
);
       
<span class="hljs-type">Car</span> <span class="hljs-variable">car1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">300</span>);
<span class="hljs-type">Car</span> <span class="hljs-variable">car2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Ford"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">80</span>);
<span class="hljs-type">Car</span> <span class="hljs-variable">car3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Chevrolet"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">150</span>);
List&lt;Car&gt; cars123 = List.of(car1, car2, car3);
</code></pre>
    <p class="normal">Next, in the context of a stream pipeline, we <a id="_idIndexMarker1049"/>want to check if <code class="inlineCode">cars</code> contains all/any of <code class="inlineCode">car1</code>, <code class="inlineCode">car2</code>, <code class="inlineCode">car3</code>, or <code class="inlineCode">cars123</code>. </p>
    <p class="normal">The Stream API comes with a rich<a id="_idIndexMarker1050"/> set of intermediate and final operations, but it doesn’t have a built-in <code class="inlineCode">containsAll()</code>/<code class="inlineCode">containsAny()</code>. So, it is our mission to provide the following final operations:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T item)</span>;
<span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(T... items)</span>;
<span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span>;
<span class="code-highlight"><strong class="hljs-type-slc">boolean</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">containsAll</strong><strong class="hljs-params-slc">(Stream&lt;? extends T&gt; items)</strong><strong class="hljs-slc">;</strong></span>
<span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(T... items)</span>;
<span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span>;
<span class="code-highlight"><strong class="hljs-type-slc">boolean</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">containsAny</strong><strong class="hljs-params-slc">(Stream&lt;? extends T&gt; items)</strong><strong class="hljs-slc">;</strong></span>
</code></pre>
    <p class="normal">We highlighted the methods that get a <code class="inlineCode">Stream</code> argument, since these methods provide the main logic, while the<a id="_idIndexMarker1051"/> rest of the methods just<a id="_idIndexMarker1052"/> call these ones after converting their arguments to a <code class="inlineCode">Stream</code>.</p>
    <h2 id="_idParaDest-421" class="heading-2">Exposing containsAll/Any() via a custom interface</h2>
    <p class="normal">The <code class="inlineCode">containsAll(Stream&lt;? extends T&gt; items)</code> relies <a id="_idIndexMarker1053"/>on a <code class="inlineCode">Set</code> to accomplish its job, as follows (as a challenge, try to find <a id="_idIndexMarker1054"/>an alternative implementation):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
  Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
  <span class="hljs-keyword">if</span> (set.isEmpty()) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> stream().filter(item -&gt; set.remove(item))
                 .anyMatch(any -&gt; set.isEmpty());
}
</code></pre>
    <p class="normal">The <code class="inlineCode">containsAny(Stream&lt;? extends T&gt; items)</code> method also relies on a <code class="inlineCode">Set</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
  Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
  <span class="hljs-keyword">if</span> (set.isEmpty()) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> stream().anyMatch(set::contains);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">toSet()</code> method is just a helper that collects the <code class="inlineCode">Stream</code> items into a <code class="inlineCode">Set</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title">toSet</span><span class="hljs-params">(Stream&lt;? extends T&gt; stream)</span> {
  <span class="hljs-keyword">return</span> stream.collect(Collectors.toSet());
}
</code></pre>
    <p class="normal">Next, let’s sneak this code into its final place, which is a custom interface.</p>
    <p class="normal">As you can see, the <code class="inlineCode">containsAll(Stream&lt;? extends T&gt; items)</code> method and <code class="inlineCode">containsAny(Stream&lt;? extends T&gt; items)</code> are declared as <code class="inlineCode">default</code>, which means that they are part of an interface. Moreover, both of them call the <code class="inlineCode">stream()</code> method, which is also part of this interface and hooks the regular <code class="inlineCode">Stream</code>.</p>
    <p class="normal">Basically, a quick approach for solving<a id="_idIndexMarker1055"/> this problem (especially useful in<a id="_idIndexMarker1056"/> interviews) consists of writing this custom interface (let’s arbitrarily name it <code class="inlineCode">Streams</code>) that has access to the original built-in <code class="inlineCode">Stream</code> interface, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Streams</span>&lt;T&gt; {
  Stream&lt;T&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span>;
  <span class="hljs-keyword">static</span> &lt;T&gt; Streams&lt;T&gt; <span class="hljs-title">from</span><span class="hljs-params">(Stream&lt;T&gt; stream)</span> {
    <span class="hljs-keyword">return</span> () -&gt; stream;
  }
  ...
</code></pre>
    <p class="normal">Next, the interface exposes a set of <code class="inlineCode">default</code> methods that represent the <code class="inlineCode">containsAll()</code>/<code class="inlineCode">containsAny()</code> flavors, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T item)</span> {
    <span class="hljs-keyword">return</span> stream().anyMatch(isEqual(item));
  }
  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(T... items)</span> {
    <span class="hljs-keyword">return</span> containsAll(Stream.of(items));
  }
  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> {
    <span class="hljs-keyword">return</span> containsAll(items.stream());
  }
  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
    ...   
  }
  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(T... items)</span> {
    <span class="hljs-keyword">return</span> containsAny(Stream.of(items));
  }
  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> {
    <span class="hljs-keyword">return</span> containsAny(items.stream());
  }
  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
    ...
  }
  <span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title">toSet</span><span class="hljs-params">(Stream&lt;? extends T&gt; stream)</span> {
    ...
  }
}
</code></pre>
    <p class="normal">Done! Now, we can write different <a id="_idIndexMarker1057"/>stream pipelines that use <a id="_idIndexMarker1058"/>the brand-new <code class="inlineCode">containsAll</code>/<code class="inlineCode">Any()</code> operations. For instance, if we want to check if <code class="inlineCode">cars</code> contains all items from <code class="inlineCode">cars123</code>, we express the stream pipeline as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Streams.from(cars.stream())
  .containsAll(cars123);
</code></pre>
    <p class="normal">Here are several more examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Streams.from(cars.stream())
  .containsAll(car1, car2, car3);
<span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Streams.from(cars.stream())
  .containsAny(car1, car2, car3);
</code></pre>
    <p class="normal">Involving more operations can be done as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Car</span> <span class="hljs-variable">car4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Mercedes"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">200</span>); 
<span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Streams.from(cars.stream()
    .filter(car -&gt; car.getBrand().equals(<span class="hljs-string">"Mercedes"</span>))
    .distinct()
    .dropWhile(car -&gt; car.getFuel().equals(<span class="hljs-string">"gasoline"</span>))
  ).contains(car4);
</code></pre>
    <p class="normal">A more expressive and complete solution to this problem consists of extending the <code class="inlineCode">Stream</code> interface. Let’s <a id="_idIndexMarker1059"/>do it!</p>
    <h2 id="_idParaDest-422" class="heading-2">Exposing containsAll/Any() via an extension of Stream</h2>
    <p class="normal">The previous solution can be considered <a id="_idIndexMarker1060"/>more like a hack. A more logical<a id="_idIndexMarker1061"/> and realistic solution consists of extending the built-in Stream API and adding our <code class="inlineCode">containsAll</code>/<code class="inlineCode">Any()</code> methods as teammates next to the <code class="inlineCode">Stream</code> operations. So the implementation starts as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Streams</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Stream</span>&lt;T&gt; { 
  ...
}
</code></pre>
    <p class="normal">Before implementing the <code class="inlineCode">containsAll</code>/<code class="inlineCode">Any()</code> methods, we need to handle some aspects resulting from extending the <code class="inlineCode">Stream</code> interface. First, we need to override in <code class="inlineCode">Streams</code> each of the <code class="inlineCode">Stream</code> methods. Since the <code class="inlineCode">Stream</code> interface has a lot of methods, we only list a few of them here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Streams&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T&gt; predicate)</span>;
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> &lt;R&gt; Streams&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(</span>
<span class="hljs-params">  Function&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T, ? extends R&gt; mapper)</span>;
...
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;
...
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isParallel</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
...
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">parallel</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UnsupportedOperationException</span>(
    <span class="hljs-string">"Not supported yet."</span>); <span class="hljs-comment">// or, return this</span>
}
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">unordered</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UnsupportedOperationException</span>(
    <span class="hljs-string">"Not supported yet."</span>); <span class="hljs-comment">// or, return this</span>
}
...
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">sequential</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
}
</code></pre>
    <p class="normal">Since <code class="inlineCode">Streams</code> can handle only<a id="_idIndexMarker1062"/> sequential streams (parallelism is not supported), we can implement the <code class="inlineCode">isParallel()</code>, <code class="inlineCode">parallel()</code>, <code class="inlineCode">unordered()</code>, and <code class="inlineCode">sequential()</code> methods as <code class="inlineCode">default</code> methods directly in <code class="inlineCode">Streams</code>.</p>
    <p class="normal">Next, in order to use <code class="inlineCode">Streams</code>, we <a id="_idIndexMarker1063"/>need a <code class="inlineCode">from(Stream s)</code> method that is capable of wrapping the given <code class="inlineCode">Stream</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> &lt;T&gt; Streams&lt;T&gt; <span class="hljs-title">from</span><span class="hljs-params">(Stream&lt;? extends T&gt; stream)</span> {
  <span class="hljs-keyword">if</span> (stream == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> from(Stream.empty());
  }
  <span class="hljs-keyword">if</span> (stream <span class="hljs-keyword">instanceof</span> Streams) {
    <span class="hljs-keyword">return</span> (Streams&lt;T&gt;) stream;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StreamsWrapper</span>&lt;&gt;(stream);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">StreamsWrapper</code> is a class that wraps the current <code class="inlineCode">Stream</code> into sequential <code class="inlineCode">Streams</code>. The <code class="inlineCode">StreamsWrapper</code> class implements <code class="inlineCode">Streams</code>, so it has to override all the <code class="inlineCode">Streams</code> methods and properly wrap the <code class="inlineCode">Stream</code> into <code class="inlineCode">Streams</code>. Because <code class="inlineCode">Streams</code> has quite a lot of methods (as a consequence of extending <code class="inlineCode">Stream</code>), we list here only a few of them (the rest are available in the bundled code):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StreamsWrapper</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Streams</span>&lt;T&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stream&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; delegator;
  <span class="hljs-keyword">public</span> <span class="hljs-title">StreamsWrapper</span><span class="hljs-params">(Stream&lt;? extends T&gt; delegator)</span> {
    <span class="hljs-built_in">this</span>.delegator = delegator.sequential();
  }       
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Streams&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T&gt; predicate)</span> { 
    <span class="hljs-keyword">return</span> Streams.from(delegator.filter(predicate));
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;R&gt; Streams&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(</span>
<span class="hljs-params">      Function&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T, ? extends R&gt; mapper)</span> {
    <span class="hljs-keyword">return</span> Streams.from(delegator.map(mapper));
  } 
  ...
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span> {
    <span class="hljs-keyword">return</span> ((Stream&lt;T&gt;) delegator)
      .reduce(identity, accumulator);
  }
  ...
}
</code></pre>
    <p class="normal">Finally, we add <code class="inlineCode">Streams</code> to the <code class="inlineCode">containsAll</code>/<code class="inlineCode">Any()</code> methods, which are quite straightforward (since <code class="inlineCode">Streams</code> extends <code class="inlineCode">Stream</code>, we have access to all the <code class="inlineCode">Stream</code> goodies without the need to write<a id="_idIndexMarker1064"/> a <code class="inlineCode">stream()</code> hack, as in the <a id="_idIndexMarker1065"/>previous solution). First, we add the <code class="inlineCode">containsAll()</code> methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T item)</span> {
  <span class="hljs-keyword">return</span> anyMatch(isEqual(item));
}
<span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(T... items)</span> {
  <span class="hljs-keyword">return</span> containsAll(Stream.of(items));
}
<span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> {
  <span class="hljs-keyword">return</span> containsAll(items.stream());
}
<span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
  Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
  <span class="hljs-keyword">if</span> (set.isEmpty()) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> filter(item -&gt; set.remove(item))
    .anyMatch(any -&gt; set.isEmpty());
}
</code></pre>
    <p class="normal">Second, we <a id="_idIndexMarker1066"/>add the <code class="inlineCode">containsAny()</code> methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(T... items)</span> {
  <span class="hljs-keyword">return</span> containsAny(Stream.of(items));
}
<span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> {
  <span class="hljs-keyword">return</span> containsAny(items.stream());
}
<span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">containsAny</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
  Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
  <span class="hljs-keyword">if</span> (set.isEmpty()) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> anyMatch(set::contains);
}
</code></pre>
    <p class="normal">Finally, we add the <code class="inlineCode">toSet()</code> method, which<a id="_idIndexMarker1067"/> you already know:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title">toSet</span><span class="hljs-params">(Stream&lt;? extends T&gt; stream)</span> {
  <span class="hljs-keyword">return</span> stream.collect(Collectors.toSet());
}
</code></pre>
    <p class="normal">Mission accomplished! Now, let’s write some examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Streams.from(cars.stream())
  .filter(car -&gt; car.getBrand().equals(<span class="hljs-string">"</span><span class="hljs-string">Mercedes"</span>))
  .contains(car1);
<span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Streams.from(cars.stream())
  .containsAll(cars123);
<span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Streams.from(cars123.stream())
  .containsAny(cars.stream());
</code></pre>
    <p class="normal">You can find more <a id="_idIndexMarker1068"/>examples in the bundled <a id="_idIndexMarker1069"/>code.</p>
    <h1 id="_idParaDest-423" class="heading-1">198. Extending Stream with removeAll() and retainAll()</h1>
    <p class="normal">Before reading this problem, I strongly recommend that you read <em class="italic">Problem 197</em>.</p>
    <p class="normal">In <em class="italic">Problem 197</em>, we extended the Stream <a id="_idIndexMarker1070"/>API with two final operations named <code class="inlineCode">containsAll()</code> and <code class="inlineCode">containsAny()</code> via a custom interface<a id="_idIndexMarker1071"/>. In both cases, the resulting interface was named <code class="inlineCode">Streams</code>. In this problem, we follow the same logic to implement two<a id="_idIndexMarker1072"/> intermediate operations, named <code class="inlineCode">removeAll()</code> and <code class="inlineCode">retainAll()</code>, with the following signatures:</p>
    <pre class="programlisting code"><code class="hljs-code">Streams&lt;T&gt; <span class="hljs-title">remove</span><span class="hljs-params">(T item)</span>;
Streams&lt;T&gt; <span class="hljs-title">removeAll</span><span class="hljs-params">(T... items)</span>;
Streams&lt;T&gt; <span class="hljs-title">removeAll</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span>;
<span class="code-highlight"><strong class="hljs-slc">Streams&lt;T&gt; </strong><strong class="hljs-title-slc">removeAll</strong><strong class="hljs-params-slc">(Stream&lt;? extends T&gt; items)</strong><strong class="hljs-slc">;</strong></span>
Streams&lt;T&gt; <span class="hljs-title">retainAll</span><span class="hljs-params">(T... items)</span>;
Streams&lt;T&gt; <span class="hljs-title">retainAll</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span>;
<span class="code-highlight"><strong class="hljs-slc">Streams&lt;T&gt; </strong><strong class="hljs-title-slc">retainAll</strong><strong class="hljs-params-slc">(Stream&lt;? extends T&gt; items)</strong><strong class="hljs-slc">;</strong></span>
</code></pre>
    <p class="normal">Since <code class="inlineCode">removeAll()</code> and <code class="inlineCode">retainAll()</code> are intermediate operations, they have to return <code class="inlineCode">Stream</code>. More precisely, they have to return <code class="inlineCode">Streams</code>, which is our implementation based on a custom interface or an interface that extends <code class="inlineCode">Stream</code>.</p>
    <h2 id="_idParaDest-424" class="heading-2">Exposing removeAll()/retainAll() via a custom interface</h2>
    <p class="normal">The <code class="inlineCode">removeAll(Stream&lt;? extends T&gt; items)</code> method<a id="_idIndexMarker1073"/> relies on a <code class="inlineCode">Set</code> to accomplish<a id="_idIndexMarker1074"/> its job, as follows (as a challenge, try to find an alternative implementation):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">removeAll</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
  Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
  <span class="hljs-keyword">if</span> (set.isEmpty()) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
  }
  <span class="hljs-keyword">return</span> from(stream().filter(item -&gt; !set.contains(item)));
}
</code></pre>
    <p class="normal">The <code class="inlineCode">retainAll(Stream&lt;? extends T&gt; items)</code> method <a id="_idIndexMarker1075"/>also relies on a <code class="inlineCode">Set</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">retainAll</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
  Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
  <span class="hljs-keyword">if</span> (set.isEmpty()) {
    <span class="hljs-keyword">return</span> from(Stream.empty());
  }
  <span class="hljs-keyword">return</span> from(stream().filter(item -&gt; set.contains(item)));
}
</code></pre>
    <p class="normal">The <code class="inlineCode">toSet()</code> method is just a helper<a id="_idIndexMarker1076"/> that collects the <code class="inlineCode">Stream</code> items into a <code class="inlineCode">Set</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title">toSet</span><span class="hljs-params">(Stream&lt;? extends T&gt; stream)</span> {
  <span class="hljs-keyword">return</span> stream.collect(Collectors.toSet());
}
</code></pre>
    <p class="normal">Next, we can sneak these <code class="inlineCode">default</code> methods into a custom interface named <code class="inlineCode">Streams</code>, exactly as we did in <em class="italic">Problem 197</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Streams</span>&lt;T&gt; {
  Stream&lt;T&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span>;
  <span class="hljs-keyword">static</span> &lt;T&gt; Streams&lt;T&gt; <span class="hljs-title">from</span><span class="hljs-params">(Stream&lt;T&gt; stream)</span> {
    <span class="hljs-keyword">return</span> () -&gt; stream;
  }
  <span class="hljs-comment">// removeAll()/retainAll() default methods and toSet()</span>
}
</code></pre>
    <p class="normal">There is a big problem with this implementation. The problem becomes obvious when we try to chain <code class="inlineCode">removeAll()</code>/<code class="inlineCode">retainAll()</code> in a stream pipeline next to other <code class="inlineCode">Stream</code> operations. Because these two methods return <code class="inlineCode">Streams</code> (not <code class="inlineCode">Stream</code>), we cannot chain a <code class="inlineCode">Stream</code> operation after <a id="_idIndexMarker1077"/>them without first calling the Java built-in <code class="inlineCode">stream()</code> before<a id="_idIndexMarker1078"/> them. This is needed to switch from <code class="inlineCode">Streams</code> to <code class="inlineCode">Stream</code>. Here is an example (using <code class="inlineCode">cars</code>, <code class="inlineCode">car1</code>, <code class="inlineCode">car2</code>, <code class="inlineCode">car3</code>, and <code class="inlineCode">car123</code>, as introduced in <em class="italic">Problem 197</em>):</p>
    <pre class="programlisting code"><code class="hljs-code">Streams.from(cars.stream())
  .retainAll(cars123)
  .removeAll(car1, car3)
  <span class="code-highlight"><strong class="hljs-slc">.stream()</strong></span>
  .forEach(System.out::println);
</code></pre>
    <p class="normal">The problem becomes even worse if we have to alternate between <code class="inlineCode">Streams</code> and <code class="inlineCode">Stream</code> multiple times. Check out this zombie:</p>
    <pre class="programlisting code"><code class="hljs-code">Streams.from(Streams.from(cars.stream().distinct())
  .retainAll(car1, car2, car3)
  .stream()
  .filter(car -&gt; car.getFuel().equals(<span class="hljs-string">"electric"</span>)))
  .removeAll(car2)
  .stream()
  .forEach(System.out::println);
</code></pre>
    <p class="normal">This hack is not a happy choice to enrich the Stream API with intermediate operations. However, it works quite well for terminal operations. So, the proper approach is to extend the <code class="inlineCode">Stream</code> interface.</p>
    <h2 id="_idParaDest-425" class="heading-2">Exposing removeAll/retainAll() via an extension of Stream</h2>
    <p class="normal">We already know from <em class="italic">Problem 197</em> how to<a id="_idIndexMarker1079"/> extend the <code class="inlineCode">Stream</code> interface. The implementation of <code class="inlineCode">removeAll()</code> is also <a id="_idIndexMarker1080"/>straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Streams</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Stream</span>&lt;T&gt; {   
    
  <span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">remove</span><span class="hljs-params">(T item)</span> {
    <span class="hljs-keyword">return</span> removeAll(item);
  }
   
  <span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">removeAll</span><span class="hljs-params">(T... items)</span> {
    <span class="hljs-keyword">return</span> removeAll(Stream.of(items));
  }
  <span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">removeAll</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> {
    <span class="hljs-keyword">return</span> removeAll(items.stream());
  }
  <span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">removeAll</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
    Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
    <span class="hljs-keyword">if</span> (set.isEmpty()) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
    }
    <span class="hljs-keyword">return</span> filter(item -&gt; !set.contains(item))
      .onClose(items::close);
  }       
  ...
</code></pre>
    <p class="normal">Then, <code class="inlineCode">retainAll()</code> follows in<a id="_idIndexMarker1081"/> the same<a id="_idIndexMarker1082"/> manner:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">retainAll</span><span class="hljs-params">(T... items)</span> {
    <span class="hljs-keyword">return</span> retainAll(Stream.of(items));
  }
  <span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">retainAll</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> {
    <span class="hljs-keyword">return</span> retainAll(items.stream());
  }
  <span class="hljs-keyword">default</span> Streams&lt;T&gt; <span class="hljs-title">retainAll</span><span class="hljs-params">(Stream&lt;? extends T&gt; items)</span> {
    Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; set = toSet(items);
    <span class="hljs-keyword">if</span> (set.isEmpty()) {
      <span class="hljs-keyword">return</span> from(Stream.empty());
    }
    <span class="hljs-keyword">return</span> filter(item -&gt; set.contains(item))
      .onClose(items::close);
  }
  ...
}    
</code></pre>
    <p class="normal">As you know from <em class="italic">Problem 197</em>, next, we have to override all the <code class="inlineCode">Stream</code> methods to return <code class="inlineCode">Streams</code>. While this part is available in the<a id="_idIndexMarker1083"/> bundled code, here<a id="_idIndexMarker1084"/> is an example of using <code class="inlineCode">removeAll()</code>/<code class="inlineCode">retainAll()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Streams.from(cars.stream())
  .distinct() 
  .retainAll(car1, car2, car3)
  .filter(car -&gt; car.getFuel().equals(<span class="hljs-string">"electric"</span>)) 
  .removeAll(car2) 
  .forEach(System.out::println);
</code></pre>
    <p class="normal">As you can see, this time, the stream pipeline looks quite good. There is no need to perform switches between <code class="inlineCode">Streams</code> and <code class="inlineCode">Stream</code> via <code class="inlineCode">stream()</code> calls. So, mission accomplished!</p>
    <h1 id="_idParaDest-426" class="heading-1">199. Introducing stream comparators</h1>
    <p class="normal">Let’s assume that we have the following<a id="_idIndexMarker1085"/> three lists (a list of numbers, a list of strings, and a list of <code class="inlineCode">Car</code> objects):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Integer&gt; nrs = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
List&lt;String&gt; strs = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
List&lt;Car&gt; cars = List.of(...);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
</code></pre>
    <p class="normal">Next, we want to sort these lists in a stream pipeline. </p>
    <h2 id="_idParaDest-427" class="heading-2">Sorting via natural order</h2>
    <p class="normal">Sorting via natural <a id="_idIndexMarker1086"/>order is very simple. All we have to do is to call the built-in intermediate operation, <code class="inlineCode">sorted()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">nrs.stream()
   .sorted()
   .forEach(System.out::println);
strs.stream()
    .sorted()
    .forEach(System.out::println);
</code></pre>
    <p class="normal">If <code class="inlineCode">nrs</code> contains 1, 6, 3, 8, 2, 3, and 0, then <code class="inlineCode">sorted()</code> will produce 0, 1, 2, 3, 3, 6, and 8. So, for numbers, the natural order is the ascending order by value.</p>
    <p class="normal">If <code class="inlineCode">strs</code> contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then <code class="inlineCode">sorted()</code> will produce “around,” “book,” “new,” “old,” “quiz,” and “tick”. So, for strings, the natural order is the alphabetical order.</p>
    <p class="normal">The same result can be obtained if we explicitly call <code class="inlineCode">Integer.compareTo()</code> and <code class="inlineCode">String.compareTo()</code> via <code class="inlineCode">sorted(Comparator&lt;? super T&gt; comparator)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">nrs.stream()
   .sorted((n1, n2) -&gt; n1.compareTo(n2))
   .forEach(System.out::println);
strs.stream()
    .sorted((s1, s2) -&gt; s1.compareTo(s2))
    .forEach(System.out::println);
</code></pre>
    <p class="normal">Alternatively, we can use the <code class="inlineCode">java.util.Comparator</code> functional interface, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">nrs.stream()
   .sorted(Comparator.naturalOrder())
   .forEach(System.out::println);
strs.stream()
    .sorted(Comparator.naturalOrder())
    .forEach(System.out::println);
</code></pre>
    <p class="normal">All three approaches return the same result.</p>
    <h2 id="_idParaDest-428" class="heading-2">Reversing the natural order</h2>
    <p class="normal">Reversing the natural order can <a id="_idIndexMarker1087"/>be done via <code class="inlineCode">Comparator.reverseOrder()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">nrs.stream()
   .sorted(Comparator.reverseOrder())
   .forEach(System.out::println);
strs.stream()
    .sorted(Comparator.reverseOrder())
    .forEach(System.out::println);
</code></pre>
    <p class="normal">If <code class="inlineCode">nrs</code> contains 1, 6, 3, 8, 2, 3, and 0, then <code class="inlineCode">sorted()</code> will produce 8, 6, 3, 3, 2, 1, and 0. Reversing the natural order of numbers results in descending order by value.</p>
    <p class="normal">If <code class="inlineCode">strs</code> contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then <code class="inlineCode">sorted()</code> will produce “tick,” “quiz,” “old,” “new,” “book,” and “around.” So for strings, reversing the natural order results in reversing the alphabetical order.</p>
    <h2 id="_idParaDest-429" class="heading-2">Sorting and nulls</h2>
    <p class="normal">If <code class="inlineCode">nrs</code>/<code class="inlineCode">strs</code> contains <code class="inlineCode">null</code> values as well, then all the previous examples will throw a <code class="inlineCode">NullPointerException</code>. However, <code class="inlineCode">java.util.Comparator</code> exposes two methods that allow us to sort <code class="inlineCode">null</code> values <a id="_idIndexMarker1088"/>first (<code class="inlineCode">nullsFirst(Comparator&lt;? super T&gt; comparator)</code>) or last (<code class="inlineCode">nullsLast(Comparator&lt;? super T&gt; comparator)</code>). They can be used as shown in the following examples:</p>
    <pre class="programlisting code"><code class="hljs-code">nrs.stream()
   .sorted(Comparator.nullsFirst(Comparator.naturalOrder()))
   .forEach(System.out::println);
        
nrs.stream()
   .sorted(Comparator.nullsLast(Comparator.naturalOrder()))
   .forEach(System.out::println);
nrs.stream()
   .sorted(Comparator.nullsFirst(Comparator.reverseOrder()))
   .forEach(System.out::println);
</code></pre>
    <p class="normal">The third example sorts the <code class="inlineCode">null</code> values first, followed by the numbers in reverse order.</p>
    <h2 id="_idParaDest-430" class="heading-2">Writing custom comparators</h2>
    <p class="normal">Sometimes, we need a<a id="_idIndexMarker1089"/> custom comparator. For instance, if we want to sort <code class="inlineCode">strs</code> ascending by the last character, then we can write a custom comparator, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">strs.stream()
    .sorted((s1, s2) -&gt; 
       Character.compare(s1.charAt(s1.length() - <span class="hljs-number">1</span>), 
                         s2.charAt(s2.length() - <span class="hljs-number">1</span>)))
    .forEach(System.out::println);
</code></pre>
    <p class="normal">If <code class="inlineCode">strs</code> contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then <code class="inlineCode">sorted()</code> will produce “old,” “around,” “book,” “tick,” “new,” and “quiz.”</p>
    <p class="normal">However, custom comparators are typically used to sort our models. For instance, if we need to sort the <code class="inlineCode">cars</code> list, then we need to define a comparator. We cannot just say:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .sorted()
    .forEach(System.out::println);
</code></pre>
    <p class="normal">This will not compile because there is no comparator for <code class="inlineCode">Car</code> objects. An approach consists of implementing the <code class="inlineCode">Comparable</code> interface and overriding the <code class="inlineCode">compareTo(Car c)</code> method. For instance, if we want to sort <code class="inlineCode">cars</code> ascending by <code class="inlineCode">horsepower</code>, then we start by implementing <code class="inlineCode">Comparable</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;Car&gt; {
  ...
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Car c)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getHorsepower() &gt; c.getHorsepower()
      ? <span class="hljs-number">1</span> : <span class="hljs-built_in">this</span>.getHorsepower() &lt; c.getHorsepower() ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  }
}
</code></pre>
    <p class="normal">Now, we can successfully write this:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .sorted()
    .forEach(System.out::println);
</code></pre>
    <p class="normal">Alternatively, if we cannot alter the <code class="inlineCode">Car</code> code, we can try to use one of the existing <code class="inlineCode">Comparator</code> methods, which allow us to push a function that contains the sort key and returns a <code class="inlineCode">Comparator</code> that <a id="_idIndexMarker1090"/>automatically compares by that key. Since <code class="inlineCode">horsepower</code> is an integer, we can use <code class="inlineCode">comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream() 
    .sorted(Comparator.comparingInt(Car::getHorsepower))
    .forEach(System.out::println);
</code></pre>
    <p class="normal">Here it is in reverse order:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .sorted(Comparator.comparingInt(
            Car::getHorsepower).reversed())
    .forEach(System.out::println);
</code></pre>
    <p class="normal">You may also be interested in <code class="inlineCode">comparingLong(ToLongFunction)</code> and <code class="inlineCode">comparingDouble(ToDoubleFunction)</code>.</p>
    <p class="normal"><code class="inlineCode">ToIntFunction</code>, <code class="inlineCode">ToLongFunction</code>, and <code class="inlineCode">ToDoubleFunction</code> are specializations of the <code class="inlineCode">Function</code> method. In this context, we can say that <code class="inlineCode">comparingInt()</code>,<code class="inlineCode">comparingLong()</code>, and <code class="inlineCode">comparingDouble()</code> are specializations of <code class="inlineCode">comparing()</code>, which comes in two flavors: <code class="inlineCode">comparing(Function&lt;? super T,? extends U&gt; keyExtractor)</code> and <code class="inlineCode">comparing(Function&lt;? super T,? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)</code>.</p>
    <p class="normal">Here is an example of using the second flavor of <code class="inlineCode">comparing()</code> to sort <code class="inlineCode">cars</code> ascending by the <code class="inlineCode">fuel</code> type (natural order), with <code class="inlineCode">null</code> values placed at the end:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .sorted(Comparator.comparing(Car::getFuel, 
            Comparator.nullsLast(Comparator.naturalOrder())))
    .forEach(System.out::println);
</code></pre>
    <p class="normal">Also, here is another example of sorting <code class="inlineCode">cars</code> ascending by the last character of the <code class="inlineCode">fuel</code> type, with <code class="inlineCode">null</code> values placed at the end:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .sorted(Comparator.comparing(Car::getFuel, 
            Comparator.nullsLast((s1, s2) -&gt; 
              Character.compare(s1.charAt(s1.length() - <span class="hljs-number">1</span>), 
                                s2.charAt(s2.length() - <span class="hljs-number">1</span>)))))
    .forEach(System.out::println);
</code></pre>
    <p class="normal">Usually, chaining multiple comparators in a functional expression leads to a less readable code. In such cases, you can sustain the readablility of your code by importing statics and assigning the comparators to variables which names starting with “by” as in the following example (the result of this code is the same as the result of the previous example, but is more readable):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Comparator.comparing;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Comparator.nullsLast;
...
Comparator&lt;String&gt; byCharAt = nullsLast(
   (s1, s2) -&gt; Character.compare(s1.charAt(s1.length() - <span class="hljs-number">1</span>), 
    s2.charAt(s2.length() - <span class="hljs-number">1</span>)));
Comparator&lt;Car&gt; byFuelAndCharAt = comparing(
  Car::getFuel, byCharAt);
cars.stream()
    .sorted(byFuelAndCharAt)
    .forEach(System.out::println);
</code></pre>
    <p class="normal">Done! In the next<a id="_idIndexMarker1091"/> problem, we will sort a map.</p>
    <h1 id="_idParaDest-431" class="heading-1">200. Sorting a map</h1>
    <p class="normal">Let’s assume that we<a id="_idIndexMarker1092"/> have the following map:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
Map&lt;Integer, Car&gt; cars = Map.of(
  <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Dacia"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">350</span>),
  <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"gasoline"</span>, <span class="hljs-number">350</span>),
  <span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"</span><span class="hljs-string">Chevrolet"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">150</span>),
  <span class="hljs-number">4</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Mercedes"</span>, <span class="hljs-string">"gasoline"</span>, <span class="hljs-number">150</span>),
  <span class="hljs-number">5</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Chevrolet"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">250</span>),
  <span class="hljs-number">6</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Ford"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">80</span>),
  <span class="hljs-number">7</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Chevrolet"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">450</span>),
  <span class="hljs-number">8</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"</span><span class="hljs-string">Mercedes"</span>, <span class="hljs-string">"electric"</span>, <span class="hljs-number">200</span>),
  <span class="hljs-number">9</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Chevrolet"</span>, <span class="hljs-string">"gasoline"</span>, <span class="hljs-number">350</span>),
  <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">300</span>)
);
</code></pre>
    <p class="normal">Next, we want to sort this map into a <code class="inlineCode">List&lt;String&gt;</code>, as follows:</p>
    <ul>
      <li class="bulletList">If the horsepower values are different, then sort in descending order by horsepower</li>
      <li class="bulletList">If the horsepower values are equal, then sort in ascending order by the map keys</li>
      <li class="bulletList">The result, <code class="inlineCode">List&lt;String&gt;</code>, should contain items of type <em class="italic">key(horsepower)</em></li>
    </ul>
    <p class="normal">Under these statements, sorting the <code class="inlineCode">cars</code> map will result in:</p>
    <pre class="programlisting con"><code class="hljs-con">[7(450), 1(350), 2(350), 9(350), 10(300), 5(250), 
8(200), 3(150), 4(150), 6(80)]
</code></pre>
    <p class="normal">Obviously, this problem requires a custom comparator. Having two map entries <code class="inlineCode">(c1, c2)</code>, we elaborate the following logic:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Check if <code class="inlineCode">c2</code>'s horsepower is equal to <code class="inlineCode">c1</code>'s horsepower</li>
      <li class="numberedList">If they are equal, then compare <code class="inlineCode">c1</code>'s key with <code class="inlineCode">c2</code>'s key</li>
      <li class="numberedList">Otherwise, compare <code class="inlineCode">c2</code>'s horsepower with <code class="inlineCode">c1</code>'s horsepower</li>
      <li class="numberedList">Collect the result into a <code class="inlineCode">List</code> </li>
    </ol>
    <p class="normal">In code lines, this can be <a id="_idIndexMarker1093"/>expressed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; result = cars.entrySet().stream()
  .sorted((c1, c2) -&gt; c2.getValue().getHorsepower() 
        == c1.getValue().getHorsepower()
     ? c1.getKey().compareTo(c2.getKey())
     : Integer.valueOf(c2.getValue().getHorsepower())
        .compareTo(c1.getValue().getHorsepower()))
  .map(c -&gt; c.getKey() + <span class="hljs-string">"("</span> 
                       + c.getValue().getHorsepower() + <span class="hljs-string">")"</span>)
  .toList();
</code></pre>
    <p class="normal">Alternatively, if we rely on <code class="inlineCode">Map.Entry.comparingByValue()</code>, <code class="inlineCode">comparingByKey()</code>, and <code class="inlineCode">java.util.Comparator</code>, then we can write it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; result = cars.entrySet().stream()
  .sorted(Entry.&lt;Integer, Car&gt;comparingByValue(
            Comparator.comparingInt(
              Car::getHorsepower).reversed())
  .thenComparing(Entry.comparingByKey()))
  .map(c -&gt; c.getKey() + <span class="hljs-string">"("</span> 
    + c.getValue().getHorsepower() + <span class="hljs-string">")"</span>)
  .toList();
</code></pre>
    <p class="normal">This approach is more readable and expressive.</p>
    <h1 id="_idParaDest-432" class="heading-1">201. Filtering a map</h1>
    <p class="normal">Let’s consider <a id="_idIndexMarker1094"/>the following map:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
Map&lt;Integer, Car&gt; cars = Map.of(
  <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Dacia"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">100</span>),
  ...
  <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">300</span>)
);
</code></pre>
    <p class="normal">In order to stream a map, we can start from the <code class="inlineCode">entrySet()</code> of the <code class="inlineCode">Map</code>, <code class="inlineCode">values()</code>, or <code class="inlineCode">keyset()</code>, followed by a <code class="inlineCode">stream()</code> call. For instance, if we <a id="_idIndexMarker1095"/>want to express a pipeline as <em class="italic">Map</em> -&gt; <em class="italic">Stream</em> -&gt; <em class="italic">Filter</em> -&gt; <em class="italic">String</em> that returns a <code class="inlineCode">List&lt;String&gt;</code> containing all the electric brands, then we can rely on <code class="inlineCode">entrySet()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">electricBrands</span> <span class="hljs-operator">=</span> cars.entrySet().stream()
  .filter(c -&gt; <span class="hljs-string">"electric"</span>.equals(c.getValue().getFuel()))
  .map(c -&gt; c.getValue().getBrand())
  .collect(Collectors.joining(<span class="hljs-string">", "</span>));
</code></pre>
    <p class="normal">However, as you can see, this stream pipeline doesn’t use the map’s keys. This means that we can better express it via <code class="inlineCode">values()</code> instead of <code class="inlineCode">entrySet()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">electricBrands</span> <span class="hljs-operator">=</span> cars.values().stream()
  .filter(c -&gt; <span class="hljs-string">"electric"</span>.equals(c.getFuel()))
  .map(c -&gt; c.getBrand())
  .collect(Collectors.joining(<span class="hljs-string">", "</span>));
</code></pre>
    <p class="normal">This is more readable, and it clearly expresses its intention. </p>
    <p class="normal">Here is another example that you should be able to follow without further details:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Car</span> <span class="hljs-variable">newCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"No name"</span>, <span class="hljs-string">"gasoline"</span>, <span class="hljs-number">350</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">carsAsNewCar1</span> <span class="hljs-operator">=</span> cars.entrySet().stream()
 .filter(c -&gt; (c.getValue().getFuel().equals(newCar.getFuel())
   &amp;&amp; c.getValue().getHorsepower() == newCar.getHorsepower()))
 .map(map -&gt; map.getValue().getBrand())
 .collect(Collectors.joining(<span class="hljs-string">", "</span>));
        
<span class="hljs-type">String</span> <span class="hljs-variable">carsAsNewCar2</span> <span class="hljs-operator">=</span> cars.values().stream()
 .filter(c -&gt; (c.getFuel().equals(newCar.getFuel())
   &amp;&amp; c.getHorsepower() == newCar.getHorsepower()))
 .map(map -&gt; map.getBrand())
 .collect(Collectors.joining(<span class="hljs-string">", "</span>));
</code></pre>
    <p class="normal">So, when the stream pipeline needs only the map’s values, we can start from <code class="inlineCode">values()</code>; when it needs only the keys, we can start from <code class="inlineCode">keyset()</code>; and when it needs both (the values and the keys), we can start from <code class="inlineCode">entrySet()</code>.</p>
    <p class="normal">For instance, a stream<a id="_idIndexMarker1096"/> pipeline expressed as <em class="italic">Map</em> -&gt; <em class="italic">Stream</em> -&gt; <em class="italic">Filter</em> -&gt; <em class="italic">Map</em> that filters the top five cars by key and collects them into a resulting map needs the <code class="inlineCode">entrySet()</code> starting point, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, Car&gt; carsTop5a = cars.entrySet().stream()
  .filter(c -&gt; c.getKey() &lt;= <span class="hljs-number">5</span>)
  .collect(Collectors.toMap(
     Map.Entry::getKey, Map.Entry::getValue));
  <span class="hljs-comment">//or, .collect(Collectors.toMap(</span>
  <span class="hljs-comment">//      c -&gt; c.getKey(), c -&gt; c.getValue()));</span>
</code></pre>
    <p class="normal">Here is an example that returns a <code class="inlineCode">Map</code> of the top five cars with more than 100 horsepower:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, Car&gt; hp100Top5a = cars.<span class="hljs-built_in">entrySet</span>().<span class="hljs-built_in">stream</span>()
  .<span class="hljs-built_in">filter</span>(c -&gt; c.<span class="hljs-built_in">getValue</span>().<span class="hljs-built_in">getHorsepower</span>() &gt; <span class="hljs-number">100</span>)
  .<span class="hljs-built_in">sorted</span>(Entry.<span class="hljs-built_in">comparingByValue</span>(
          Comparator.<span class="hljs-built_in">comparingInt</span>(Car::getHorsepower)))
  .<span class="hljs-built_in">collect</span>(Collectors.<span class="hljs-built_in">toMap</span>(
     Map.Entry::getKey, Map.Entry::getValue, 
       (c1, c2) -&gt; c2, LinkedHashMap::<span class="hljs-keyword">new</span>));
  <span class="hljs-comment">//or, .collect(Collectors.toMap(</span>
  <span class="hljs-comment">//      c -&gt; c.getKey(), c -&gt; c.getValue(), </span>
  <span class="hljs-comment">//      (c1, c2) -&gt; c2, LinkedHashMap::new));</span>
</code></pre>
    <p class="normal">If we need to express such pipelines quite often, then we may prefer to write some helpers. Here is a set of four generic helpers for filtering and sorting a <code class="inlineCode">Map&lt;K, V&gt;</code> by key:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Filters</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-title">Filters</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title">byKey</span><span class="hljs-params">(</span>
<span class="hljs-params">        Map&lt;K, V&gt; map, Predicate&lt;K&gt; predicate)</span> {
  <span class="hljs-keyword">return</span> map.entrySet()
    .stream()
    .filter(item -&gt; predicate.test(item.getKey()))
    .collect(Collectors.toMap(
       Map.Entry::getKey, Map.Entry::getValue));
  }
    
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title">sortedByKey</span><span class="hljs-params">(</span>
<span class="hljs-params">    Map&lt;K, V&gt; map, Predicate&lt;K&gt; predicate, Comparator&lt;K&gt; c)</span> {
    <span class="hljs-keyword">return</span> map.entrySet()
      .stream()
      .filter(item -&gt; predicate.test(item.getKey()))
      .sorted(Map.Entry.comparingByKey(c))
      .collect(Collectors.toMap(
         Map.Entry::getKey, Map.Entry::getValue,
              (c1, c2) -&gt; c2, LinkedHashMap::<span class="hljs-keyword">new</span>));
  }
  ...
</code></pre>
    <p class="normal">And a set for filtering <a id="_idIndexMarker1097"/>and sorting a <code class="inlineCode">Map</code> by value:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title">byValue</span><span class="hljs-params">(</span>
<span class="hljs-params">      Map&lt;K, V&gt; map, Predicate&lt;V&gt; predicate)</span> {
    <span class="hljs-keyword">return</span> map.entrySet()
      .stream()
      .filter(item -&gt; predicate.test(item.getValue()))
      .collect(Collectors.toMap(
         Map.Entry::getKey, Map.Entry::getValue));
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title">sortedbyValue</span><span class="hljs-params">(Map&lt;K, V&gt; map, </span>
<span class="hljs-params">      Predicate&lt;V&gt; predicate, Comparator&lt;V&gt; c)</span> {
  <span class="hljs-keyword">return</span> map.entrySet()
    .stream()
    .filter(item -&gt; predicate.test(item.getValue()))
    .sorted(Map.Entry.comparingByValue(c))
    .collect(Collectors.toMap(
       Map.Entry::getKey, Map.Entry::getValue,
           (c1, c2) -&gt; c2, LinkedHashMap::<span class="hljs-keyword">new</span>));
  }
}
</code></pre>
    <p class="normal">Now, our code has become much shorter. For instance, we can filter the top five cars by key and collect them into a resulting map, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, Car&gt; carsTop5s 
  = Filters.byKey(cars, c -&gt; c &lt;= <span class="hljs-number">5</span>);
</code></pre>
    <p class="normal">Alternatively, we can filter the top five cars with more than 100 horsepower, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, Car&gt; hp100Top5s 
  = Filters.byValue(cars, c -&gt; c.getHorsepower() &gt; <span class="hljs-number">100</span>); 
Map&lt;Integer, Car&gt; hp100Top5d 
  = Filters.sortedbyValue(cars, c -&gt; c.getHorsepower() &gt; <span class="hljs-number">100</span>,
      Comparator.comparingInt(Car::getHorsepower)); 
</code></pre>
    <p class="normal">Cool, right?! Feel free to<a id="_idIndexMarker1098"/> extend <code class="inlineCode">Filters</code> with more generic helpers to handle <code class="inlineCode">Map</code> processing in stream pipelines.</p>
    <h1 id="_idParaDest-433" class="heading-1">202. Creating a custom collector via Collector.of()</h1>
    <p class="normal">Creating a custom collector is a topic that we covered in detail in <em class="italic">Chapter 9</em>, <em class="italic">Problem 193</em>, of <em class="italic">Java Coding Problem</em>, <em class="italic">First Edition</em>. More precisely, in that problem, you saw how to write a custom collector by<a id="_idIndexMarker1099"/> implementing the <code class="inlineCode">java.util.stream.Collector</code> interface.</p>
    <p class="normal">Don’t worry if you haven’t read that book/problem; you can still follow this problem. First, we will create several custom collectors. This time, we will rely on two <code class="inlineCode">Collector.of()</code> methods that have the following signatures:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> &lt;T,R&gt; Collector&lt;T,R,R&gt; <span class="hljs-title">of</span><span class="hljs-params">(</span>
<span class="hljs-params">  Supplier&lt;R&gt; supplier, </span>
<span class="hljs-params">  BiConsumer&lt;R,T&gt; accumulator, </span>
<span class="hljs-params">  BinaryOperator&lt;R&gt; combiner, </span>
<span class="hljs-params">  Collector.Characteristics... characteristics)</span>
<span class="hljs-keyword">static</span> &lt;T,A,R&gt; Collector&lt;T,A,R&gt; <span class="hljs-title">of</span><span class="hljs-params">(</span>
<span class="hljs-params">  Supplier&lt;A&gt; supplier, </span>
<span class="hljs-params">  BiConsumer&lt;A,T&gt; accumulator, </span>
<span class="hljs-params">  BinaryOperator&lt;A&gt; combiner, </span>
<span class="hljs-params">  Function&lt;A,R&gt; finisher, </span>
<span class="hljs-params">  Collector.Characteristics... characteristics)</span>
</code></pre>
    <p class="normal">In this context, <code class="inlineCode">T</code>, <code class="inlineCode">A</code>, and <code class="inlineCode">R</code> represent the following:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">T</code> represents the type of elements from the <code class="inlineCode">Stream</code> (elements that will be collected)</li>
      <li class="bulletList"><code class="inlineCode">A</code> represents the type of object that was used during the collection process, known as the accumulator, which is used to accumulate the stream elements in a mutable result container</li>
      <li class="bulletList"><code class="inlineCode">R</code> represents the type of the object after the collection process (the final result)</li>
    </ul>
    <p class="normal">Moreover, a <code class="inlineCode">Collector</code> is characterized <a id="_idIndexMarker1100"/>by four functions and an enumeration. Here’s a short note from <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>:</p>
    <p class="normal">“<em class="italic">These functions work together to accumulate entries into a mutable result container, and optionally perform a final transformation on the result. They are as follows:</em></p>
    <ul>
      <li class="bulletList"><em class="italic">Creating a new empty mutable result container (the supplier argument)</em></li>
      <li class="bulletList"><em class="italic">Incorporating a new data element into the mutable result container (the accumulator argument)</em></li>
      <li class="bulletList"><em class="italic">Combining two mutable result containers into one (the combiner argument)</em></li>
      <li class="bulletList"><em class="italic">Performing an optional final transformation on the mutable result container to obtain the final result (the finisher argument)</em>”</li>
    </ul>
    <p class="normal">In addition, we have the <code class="inlineCode">Collector.Characteristics...</code> enumeration that defines the collector behavior. Possible values are <code class="inlineCode">UNORDERED</code> (no order), <code class="inlineCode">CONCURRENT</code> (more threads accumulate elements), and <code class="inlineCode">IDENTITY_FINISH</code> (the finisher is the identity function, so no further transformation will take place).</p>
    <p class="normal">In this context, let’s try to fire up a few examples. But first, let’s assume that we have the following model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Vehicle</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Submersible</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> {
    
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> maxdepth;
  ...
}
</code></pre>
    <p class="normal">Also, some data:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, Car&gt; cars = Map.of(
  <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Dacia"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">100</span>),
  ...
  <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">300</span>)
);
</code></pre>
    <p class="normal">Next, let’s make some <a id="_idIndexMarker1101"/>collectors in a helper class named <code class="inlineCode">MyCollectors</code>.</p>
    <h2 id="_idParaDest-434" class="heading-2">Writing a custom collector that collects into a TreeSet</h2>
    <p class="normal">In a custom collector that <a id="_idIndexMarker1102"/>collects into a <code class="inlineCode">TreeSet</code> and the supplier is <code class="inlineCode">TreeSet::new</code>, the accumulator is <code class="inlineCode">TreeSet.add()</code>, the combiner relies on <code class="inlineCode">TreeSet.addAll()</code>, and the finisher is the identity function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; 
    Collector&lt;T, TreeSet&lt;T&gt;, TreeSet&lt;T&gt;&gt; <span class="hljs-title">toTreeSet</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> Collector.of(TreeSet::<span class="hljs-keyword">new</span>, TreeSet::add,
    (left, right) -&gt; {
       left.addAll(right);
       <span class="hljs-keyword">return</span> left;
    }, Collector.Characteristics.IDENTITY_FINISH);
}
</code></pre>
    <p class="normal">In the following example, we use this collector to collect all electric brands in a <code class="inlineCode">TreeSet&lt;String&gt;</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">TreeSet&lt;String&gt; electricBrands = cars.values().stream()
  .filter(c -&gt; <span class="hljs-string">"electric"</span>.equals(c.getFuel()))
  .map(c -&gt; c.getBrand())
  .collect(MyCollectors.toTreeSet());
</code></pre>
    <p class="normal">That was easy!</p>
    <h2 id="_idParaDest-435" class="heading-2">Writing a custom collector that collects into a LinkedHashSet</h2>
    <p class="normal">In a custom collector that collects into <a id="_idIndexMarker1103"/>a <code class="inlineCode">LinkedHashSet</code> where the supplier is <code class="inlineCode">LinkedHashSet::new</code>, the accumulator is <code class="inlineCode">HashSet::add</code>, the combiner relies on <code class="inlineCode">HashSet.addAll()</code>, and the finisher is the identity function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Collector&lt;T, LinkedHashSet&lt;T&gt;, 
    LinkedHashSet&lt;T&gt;&gt; <span class="hljs-title">toLinkedHashSet</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> Collector.of(LinkedHashSet::<span class="hljs-keyword">new</span>, HashSet::add,
    (left, right) -&gt; {
       left.addAll(right);
       <span class="hljs-keyword">return</span> left;
    }, Collector.Characteristics.IDENTITY_FINISH);
}
</code></pre>
    <p class="normal">In the following example, we use this collector to collect the sorted cars’ horsepower:</p>
    <pre class="programlisting code"><code class="hljs-code">LinkedHashSet&lt;Integer&gt; hpSorted = cars.values().stream()
  .map(c -&gt; c.getHorsepower())
  .sorted()
  .collect(MyCollectors.toLinkedHashSet());
</code></pre>
    <p class="normal">Done! The <code class="inlineCode">LinkedHashSet&lt;Integer&gt;</code> contains the horsepower values in ascending order.</p>
    <h2 id="_idParaDest-436" class="heading-2">Writing a custom collector that excludes elements of another collector</h2>
    <p class="normal">The goal of this section is to provide a<a id="_idIndexMarker1104"/> custom collector that takes, as arguments, a <code class="inlineCode">Predicate</code> and a <code class="inlineCode">Collector</code>. It applies the given <code class="inlineCode">predicate</code> to elements to be collected, in order to exclude the failures from the given <code class="inlineCode">collector</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, A, R&gt; Collector&lt;T, A, R&gt; <span class="hljs-title">exclude</span><span class="hljs-params">(</span>
<span class="hljs-params">    Predicate&lt;T&gt; predicate, Collector&lt;T, A, R&gt; collector)</span> {
  <span class="hljs-keyword">return</span> Collector.of(
    collector.supplier(),
    (l, r) -&gt; {
       <span class="hljs-keyword">if</span> (predicate.negate().test(r)) {
         collector.accumulator().accept(l, r);
       }
    },
    collector.combiner(),
    collector.finisher(),
    collector.characteristics()
     .toArray(Collector.Characteristics[]::<span class="hljs-keyword">new</span>)
  );
}
</code></pre>
    <p class="normal">The custom collector uses the supplier, combiner, finisher, and characteristics of the given collector. It only influences<a id="_idIndexMarker1105"/> the accumulator of the given collector. Basically, it explicitly calls the accumulator of the given collector only for the elements that pass the given predicate.</p>
    <p class="normal">For instance, if we want to obtain the sorted horsepower less than 200 via this custom collector, then we call it as follows (the predicate specifies what should be excluded):</p>
    <pre class="programlisting code"><code class="hljs-code">LinkedHashSet&lt;Integer&gt; excludeHp200 = cars.values().stream()
  .map(c -&gt; c.getHorsepower())
  .sorted()
  .collect(MyCollectors.exclude(c -&gt; c &gt; <span class="hljs-number">200</span>, 
           MyCollectors.toLinkedHashSet()));
</code></pre>
    <p class="normal">Here, we use two custom collectors, but we can easily replace the <code class="inlineCode">toLinkedHashSet()</code> with a built-in collector as well. Challenge yourself to write the counterpart of this custom collector. Write a collector that includes the elements that pass the given predicate.</p>
    <h2 id="_idParaDest-437" class="heading-2">Writing a custom collector that collects elements by type</h2>
    <p class="normal">Let’s suppose that we have<a id="_idIndexMarker1106"/> the following <code class="inlineCode">List&lt;Vehicle&gt;</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Vehicle</span> <span class="hljs-variable">mazda</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Mazda"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">155</span>);
<span class="hljs-type">Vehicle</span> <span class="hljs-variable">ferrari</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Ferrari"</span>, <span class="hljs-string">"gasoline"</span>, <span class="hljs-number">500</span>);
        
<span class="hljs-type">Vehicle</span> <span class="hljs-variable">hov</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Submersible</span>(<span class="hljs-string">"HOV"</span>, <span class="hljs-number">3000</span>);
<span class="hljs-type">Vehicle</span> <span class="hljs-variable">rov</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Submersible</span>(<span class="hljs-string">"</span><span class="hljs-string">ROV"</span>, <span class="hljs-number">7000</span>);
        
List&lt;Vehicle&gt; vehicles = List.of(mazda, hov, ferrari, rov);
</code></pre>
    <p class="normal">Our goal is to collect only the cars or the submersibles, but not both. For this, we can write a custom collector that <a id="_idIndexMarker1107"/>collects by <code class="inlineCode">type</code> into the given supplier, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 
  &lt;T, A <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>, R <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;A&gt;&gt; Collector&lt;T, ?, R&gt; 
    toType(Class&lt;A&gt; type, Supplier&lt;R&gt; supplier) {
  <span class="hljs-keyword">return</span> Collector.of(supplier,
      (R r, T t) -&gt; {
         <span class="hljs-keyword">if</span> (type.isInstance(t)) {
           r.add(type.cast(t));
         }
      },
      (R left, R right) -&gt; {
         left.addAll(right);
         <span class="hljs-keyword">return</span> left;
      },
      Collector.Characteristics.IDENTITY_FINISH
  );
}
</code></pre>
    <p class="normal">Now, we can collect only the cars from <code class="inlineCode">List&lt;Vehicle&gt;</code> into an <code class="inlineCode">ArrayList</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; onlyCars = vehicles.stream()
  .collect(MyCollectors.toType(
    Car.class, ArrayList::<span class="hljs-keyword">new</span>));
</code></pre>
    <p class="normal">Also, we can collect only the submersible into a <code class="inlineCode">HashSet</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Set&lt;Submersible&gt; onlySubmersible = vehicles.stream()
  .collect(MyCollectors.toType(
    Submersible.class, HashSet::<span class="hljs-keyword">new</span>));
</code></pre>
    <p class="normal">Finally, let’s write a custom collector for a custom data structure.</p>
    <h2 id="_idParaDest-438" class="heading-2">Writing a custom collector for SplayTree</h2>
    <p class="normal">In <em class="italic">Chapter 5</em>, <em class="italic">Problem 127</em>, we implemented a<a id="_idIndexMarker1108"/> SplayTree data structure. Now, let’s<a id="_idIndexMarker1109"/> write a custom collector capable of collecting elements into a SplayTree. Obviously, the supplier is <code class="inlineCode">SplayTree::new</code>. Moreover, the accumulator is <code class="inlineCode">SplayTree.insert()</code>, while the combiner is <code class="inlineCode">SplayTree.insertAll()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 
    Collector&lt;Integer, SplayTree, SplayTree&gt; <span class="hljs-title">toSplayTree</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> Collector.of(SplayTree::<span class="hljs-keyword">new</span>, SplayTree::insert,
    (left, right) -&gt; {
       left.insertAll(right);
       <span class="hljs-keyword">return</span> left;
    }, 
    Collector.Characteristics.IDENTITY_FINISH);
}
</code></pre>
    <p class="normal">Here is an example that<a id="_idIndexMarker1110"/> collects the car’s horsepower into a <a id="_idIndexMarker1111"/>SplayTree:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SplayTree</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> cars.values().stream()
  .map(c -&gt; c.getHorsepower())
  .collect(MyCollectors.toSplayTree());
</code></pre>
    <p class="normal">Done! Challenge yourself to implement a custom collector.</p>
    <h1 id="_idParaDest-439" class="heading-1">203. Throwing checked exceptions from lambdas</h1>
    <p class="normal">Let’s suppose that we have <a id="_idIndexMarker1112"/>the following<a id="_idIndexMarker1113"/> lambda:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFiles</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> {
  paths.forEach(p -&gt; {
    <span class="hljs-keyword">try</span> {
      readFile(p);
    } <span class="hljs-keyword">catch</span> (IOException e) {
      <span class="code-highlight"><strong class="hljs-slc">... </strong><strong class="hljs-comment-slc">// what can we throw here?</strong></span>
    }
  });
}
</code></pre>
    <p class="normal">What can we throw in the <code class="inlineCode">catch</code> block? Most of you will know the answer; we can throw an unchecked <a id="_idIndexMarker1114"/>exception such as a <code class="inlineCode">RuntimeException</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFiles</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> {
  paths.forEach(p -&gt; {
    <span class="hljs-keyword">try</span> {
      readFile(p);
    } <span class="hljs-keyword">catch</span> (IOException e) {
      <span class="code-highlight"><strong class="hljs-keyword-slc">throw</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">RuntimeException</strong><strong class="hljs-slc">(e);</strong></span>
    }
  });
}
</code></pre>
    <p class="normal">Also, most people know that we<a id="_idIndexMarker1115"/> cannot throw a checked exception such as an <code class="inlineCode">IOException</code>. The following snippet of code will not compile:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFiles</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> {
  paths.forEach(p -&gt; {
    <span class="hljs-keyword">try</span> {
      readFile(p);
    } <span class="hljs-keyword">catch</span> (IOException e) {
      <span class="code-highlight"><strong class="hljs-keyword-slc">throw</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">IOException</strong><strong class="hljs-slc">(e);</strong></span>
    }
  });
}
</code></pre>
    <p class="normal">Can we change this rule? Can we come up with a hack that allows us to throw checked exceptions from lambdas? Short answer: sure we can!</p>
    <p class="normal">Long answer: sure we can, <em class="italic">if</em> we simply hide the checked exception for the compiler, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Exceptions</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-title">Exceptions</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">throwChecked</span><span class="hljs-params">(Throwable t)</span> {
    Exceptions.&lt;RuntimeException&gt;throwIt(t);
  }
  <span class="hljs-meta">@SuppressWarnings({"unchecked"})</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;X <span class="hljs-keyword">extends</span> <span class="hljs-title">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">throwIt</span><span class="hljs-params">(</span>
<span class="hljs-params">      Throwable t)</span> <span class="hljs-keyword">throws</span> X {
    <span class="hljs-keyword">throw</span> (X) t;
  }
}
</code></pre>
    <p class="normal">That’s all there is to it! Now, we<a id="_idIndexMarker1116"/> can throw any checked exception. Here, we<a id="_idIndexMarker1117"/> throw an <code class="inlineCode">IOException</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFiles</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> <span class="hljs-keyword">throws</span> IOException {
  paths.forEach(p -&gt; {
    <span class="hljs-keyword">try</span> {
      readFile(p);
    } <span class="hljs-keyword">catch</span> (IOException e) { 
      Exceptions.throwChecked(<span class="hljs-keyword">new</span> <span class="hljs-title">IOException</span>(
        <span class="hljs-string">"Some files are corrupted"</span>, e));
    }
  });
}
</code></pre>
    <p class="normal">Also, we can catch it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Path&gt; paths = List.of(...);
<span class="hljs-keyword">try</span> {
  readFiles(paths);
} <span class="hljs-keyword">catch</span> (IOException e) {
  System.out.println(e + <span class="hljs-string">" \n "</span> + e.getCause());
}
</code></pre>
    <p class="normal">If a certain path was not found, then the reported error message will be:</p>
    <pre class="programlisting con"><code class="hljs-con">java.io.IOException: Some files are corrupted 
java.io.FileNotFoundException: ...
(The system cannot find the path specified)
</code></pre>
    <p class="normal">Cool, right?!</p>
    <h1 id="_idParaDest-440" class="heading-1">204. Implementing distinctBy() for the Stream API</h1>
    <p class="normal">Let’s suppose that we have the<a id="_idIndexMarker1118"/> following model <a id="_idIndexMarker1119"/>and data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
List&lt;Car&gt; cars = List.of(
  <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Chevrolet"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">350</span>),
  ...
  <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">300</span>)
);
</code></pre>
    <p class="normal">We know that the Stream API contains the <code class="inlineCode">distinct()</code> intermediate operation, which is capable of keeping only the distinct elements based on the <code class="inlineCode">equals()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .distinct()
    .forEach(System.out::println);
</code></pre>
    <p class="normal">While this code prints the distinct cars, we may want a <code class="inlineCode">distinctBy()</code> intermediate operation that is capable of keeping only the distinct elements based on a given property/key. For instance, we may need all the cars distinct by brand. For this, we can rely on the <code class="inlineCode">toMap()</code> collector and the identity function, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .collect(Collectors.toMap(Car::getBrand, 
             Function.identity(), (c1, c2) -&gt; c1))
    .values()
    .forEach(System.out::println);
</code></pre>
    <p class="normal">We can extract this idea into a helper method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, T&gt; Collector&lt;T, ?, Map&lt;K, T&gt;&gt; 
  distinctByKey(Function&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title">K</span>&gt; function) {
  <span class="hljs-keyword">return</span> Collectors.toMap(
    function, Function.identity(), (t1, t2) -&gt; t1);
}
</code></pre>
    <p class="normal">Also, we can use it as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
  .collect(Streams.distinctByKey(Car::getBrand))
  .values()
  .forEach(System.out::println);
</code></pre>
    <p class="normal">While this is a nice job that<a id="_idIndexMarker1120"/> also works for <code class="inlineCode">null</code> values, we can come <a id="_idIndexMarker1121"/>up with other ideas that don’t work for <code class="inlineCode">null</code> values. For instance, we can rely on <code class="inlineCode">ConcurrentHashMap</code> and <code class="inlineCode">putIfAbsent()</code>, as follows (again, this doesn’t work for <code class="inlineCode">null</code> values):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title">distinctByKey</span><span class="hljs-params">(</span>
<span class="hljs-params">    Function&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T, ?&gt; function)</span> {
  Map&lt;Object, Boolean&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;&gt;();
  <span class="hljs-keyword">return</span> t -&gt; seen.putIfAbsent(function.apply(t), 
    Boolean.TRUE) == <span class="hljs-literal">null</span>;
}
</code></pre>
    <p class="normal">Alternatively, we can optimize this approach a little bit and use a <code class="inlineCode">Set</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title">distinctByKey</span><span class="hljs-params">(</span>
<span class="hljs-params">    Function&lt;? </span><span class="hljs-built_in">super</span><span class="hljs-params"> T, ?&gt; function)</span> {
  Set&lt;Object&gt; seen = ConcurrentHashMap.newKeySet();
  <span class="hljs-keyword">return</span> t -&gt; seen.add(function.apply(t));
}
</code></pre>
    <p class="normal">We can use these two approaches, as shown in the following examples:</p>
    <pre class="programlisting code"><code class="hljs-code">cars.stream()
    .filter(Streams.distinctByKey(Car::getBrand))
    .forEach(System.out::println);
cars.stream()
    .filter(Streams.distinctByKey(Car::getFuel))
    .forEach(System.out::println);
</code></pre>
    <p class="normal">As a challenge, implement<a id="_idIndexMarker1122"/> a <code class="inlineCode">distinctByKeys()</code> operation using<a id="_idIndexMarker1123"/> multiple keys.</p>
    <h1 id="_idParaDest-441" class="heading-1">205. Writing a custom collector that takes/skips a given number of elements</h1>
    <p class="normal">In <em class="italic">Problem 202</em>, we wrote a handful of<a id="_idIndexMarker1124"/> custom collectors grouped in the <code class="inlineCode">MyCollectors</code> class. Now, let’s continue our journey, and let’s try to add two more custom collectors here to take and/or keep a given number of elements from the current stream.</p>
    <p class="normal">Let’s assume the following model and data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String brand;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fuel;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> horsepower;
  ...
}
List&lt;Car&gt; cars = List.of(
  <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Chevrolet"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">350</span>),
  ... <span class="hljs-comment">// 10 more</span>
  <span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(<span class="hljs-string">"Lexus"</span>, <span class="hljs-string">"diesel"</span>, <span class="hljs-number">300</span>)
);
</code></pre>
    <p class="normal">The Stream API provides an intermediate operation named <code class="inlineCode">limit(long n)</code>, which can be used to truncate the stream to <code class="inlineCode">n</code> elements. So, if this is exactly what we want, then we can use it out of the box. For instance, we can limit the resulting stream to the first five cars, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; first5CarsLimit = cars.stream()
  .limit(<span class="hljs-number">5</span>)
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">Moreover, the Stream API provides an intermediate operation named <code class="inlineCode">skip(long n)</code> , which can be used to skip the first <code class="inlineCode">n</code> elements in the stream pipeline. For instance, we can skip the first five cars, as<a id="_idIndexMarker1125"/> follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; last5CarsSkip = cars.stream()
  .skip(<span class="hljs-number">5</span>)
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">However, there are cases when we need to compute different things and collect only the first/last five results. In such cases, a custom collector is welcome. </p>
    <p class="normal">By relying on the <code class="inlineCode">Collector.of()</code> method (as detailed in <em class="italic">Problem 202</em>), we can write a custom collector that keeps/collects the first <code class="inlineCode">n</code> elements, as follows (just for fun, let’s collect these <em class="italic">n</em> elements in an unmodifiable list):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt;    
    <span class="hljs-title">toUnmodifiableListKeep</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> max)</span> {
  <span class="hljs-keyword">return</span> Collector.of(ArrayList::<span class="hljs-keyword">new</span>,
    (list, value) -&gt; {
       <span class="hljs-keyword">if</span> (list.size() &lt; max) {
         list.add(value);
       }
    },
    (left, right) -&gt; {
       left.addAll(right);
       <span class="hljs-keyword">return</span> left;
    },
    Collections::unmodifiableList);
}
</code></pre>
    <p class="normal">So the supplier is <code class="inlineCode">ArrayList::new</code>, the accumulator is <code class="inlineCode">List.add()</code>, the combiner is <code class="inlineCode">List.addAll()</code>, and the finalizer is <code class="inlineCode">Collections::unmodifiableList</code>. Basically, the accumulator’s job is to accumulate elements only until the given <code class="inlineCode">max</code> is reached. From that point forward, nothing gets accumulated. This way, we can keep only the first five cars, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; first5Cars = cars.stream()
  .collect(MyCollectors.toUnmodifiableListKeep(<span class="hljs-number">5</span>));
</code></pre>
    <p class="normal">On the other hand, if we want to skip the first <code class="inlineCode">n</code> elements and collect the rest, then we can try to accumulate <code class="inlineCode">null</code> elements until we reach the given <code class="inlineCode">index</code>. From this point forward, we accumulate the real elements. Finally, the finalizer removes the part of the list containing <code class="inlineCode">null</code> values (from 0 to the given <code class="inlineCode">index</code>) and returns an unmodifiable list from the remaining <a id="_idIndexMarker1126"/>elements (from the given <code class="inlineCode">index</code> to the end):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt; 
    <span class="hljs-title">toUnmodifiableListSkip</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> index)</span> {
  <span class="hljs-keyword">return</span> Collector.of(ArrayList::<span class="hljs-keyword">new</span>,
    (list, value) -&gt; {
       <span class="hljs-keyword">if</span> (list.size() &gt;= index) {
         list.add(value);
       } <span class="hljs-keyword">else</span> {
         list.add(<span class="hljs-literal">null</span>);
       }
    },
    (left, right) -&gt; {
       left.addAll(right);
  
       <span class="hljs-keyword">return</span> left;
    },
    list -&gt; Collections.unmodifiableList(
      list.subList(index, list.size())));
}
</code></pre>
    <p class="normal">Alternatively, we can optimize this approach by using a supplier class that contains the resulting list and a counter. While the given <code class="inlineCode">index</code> is not reached, we simply increase the counter. Once the given <code class="inlineCode">index</code> is reached, we start to accumulate elements:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; 
    toUnmodifiableListSkip(<span class="hljs-type">int</span> index) {
  <span class="hljs-keyword">class</span> <span class="hljs-title">Sublist</span> {
    <span class="hljs-type">int</span> index;
    List&lt;T&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(); 
  }
  <span class="hljs-keyword">return</span> Collector.of(Sublist::<span class="hljs-keyword">new</span>,
    (sublist, value) -&gt; {
       <span class="hljs-keyword">if</span> (sublist.index &gt;= index) {
         sublist.list.add(value);
       } <span class="hljs-keyword">else</span> {
         sublist.index++;
       }
     },
     (left, right) -&gt; {
        left.list.addAll(right.list);
        left.index = left.index + right.index;
 
       <span class="hljs-keyword">return</span> left;
     },
     sublist -&gt; Collections.unmodifiableList(sublist.list));
}
</code></pre>
    <p class="normal">Both of these approaches<a id="_idIndexMarker1127"/> can be used, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Car&gt; last5Cars = cars.stream()
  .collect(MyCollectors.toUnmodifiableListSkip(<span class="hljs-number">5</span>));
</code></pre>
    <p class="normal">Challenge yourself to implement a custom collector that collects in a given range.</p>
    <h1 id="_idParaDest-442" class="heading-1">206. Implementing a Function that takes five (or any other arbitrary number of) arguments</h1>
    <p class="normal">We know that Java already has <code class="inlineCode">java.util.function.Function</code> and the specialization of it, <code class="inlineCode">java.util.function.BiFunction</code>. The <code class="inlineCode">Function</code> interface defines the method <code class="inlineCode">apply(T, t)</code>, while <code class="inlineCode">BiFunction</code> has <code class="inlineCode">apply(T t, U u)</code>.</p>
    <p class="normal">In this context, we can <a id="_idIndexMarker1128"/>define a <code class="inlineCode">TriFunction</code>, <code class="inlineCode">FourFunction</code>, or (why not?) a <code class="inlineCode">FiveFunction</code> functional interface, as follows (all of these are specializations of <code class="inlineCode">Function</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">FiveFunction</span> &lt;T1, T2, T3, T4, T5, R&gt; {
    
  R <span class="hljs-title">apply</span><span class="hljs-params">(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5)</span>;
}
</code></pre>
    <p class="normal">As its name suggests, this functional interface takes five arguments.</p>
    <p class="normal">Now, let’s use it! Let’s assume that we have the following model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PL4</span> {
    
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> a;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> b;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> c;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> d;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> x;
  <span class="hljs-keyword">public</span> <span class="hljs-title">PL4</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> a, </span><span class="hljs-type">double</span><span class="hljs-params"> b, </span>
<span class="hljs-params">             </span><span class="hljs-type">double</span><span class="hljs-params"> c, </span><span class="hljs-type">double</span><span class="hljs-params"> d, </span><span class="hljs-type">double</span><span class="hljs-params"> x)</span> { 
    <span class="hljs-built_in">this</span>.a = a;
    <span class="hljs-built_in">this</span>.b = b;
    <span class="hljs-built_in">this</span>.c = c;
    <span class="hljs-built_in">this</span>.d = d;
    <span class="hljs-built_in">this</span>.x = x;
  }
  <span class="hljs-comment">// getters</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> d + ((a - d) / (<span class="hljs-number">1</span> + (Math.pow(x / c, b))));
  }
  
  <span class="hljs-comment">// equals(), hashCode(), toString()</span>
}
</code></pre>
    <p class="normal">The <code class="inlineCode">compute()</code> method shapes<a id="_idIndexMarker1129"/> a formula known as the Four-Parameter Logistic (4PL - <a href="https://www.myassays.com/four-parameter-logistic-regression.html"><span class="url">https://www.myassays.com/four-parameter-logistic-regression.html</span></a>). Without getting into irrelevant details, we pass, as inputs, four variables (<code class="inlineCode">a</code>, <code class="inlineCode">b</code>, <code class="inlineCode">c</code>, and <code class="inlineCode">d</code>) and, for different values of the <code class="inlineCode">x</code> coordinate, we compute the <code class="inlineCode">y</code> coordinate. The (<code class="inlineCode">x</code>, <code class="inlineCode">y</code>) pair of coordinates describes a curve (linear graphic).</p>
    <p class="normal">We need a <code class="inlineCode">PL4</code> instance for each <code class="inlineCode">x</code> coordinate, and for each such instance, we call the <code class="inlineCode">compute()</code> method. This means that we can use the <code class="inlineCode">FiveFunction</code> interface in <code class="inlineCode">Logistics</code> via the following helper:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logistics</span> {
  ...
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T1, T2, T3, T4, X, R&gt; R <span class="hljs-title">create</span><span class="hljs-params">(</span>
<span class="hljs-params">      T1 t1, T2 t2, T3 t3, T4 t4, X x,</span>
<span class="hljs-params">      FiveFunction&lt;T1, T2, T3, T4, X, R&gt; f)</span> {
         
    <span class="hljs-keyword">return</span> f.apply(t1, t2, t3, t4, x);
  }
  ...
}
</code></pre>
    <p class="normal">This acts as a factory for <code class="inlineCode">PL4</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">PL4</span> <span class="hljs-variable">pl4_1</span> <span class="hljs-operator">=</span> Logistics.create(
    <span class="hljs-number">4.19</span>, -<span class="hljs-number">1.10</span>, <span class="hljs-number">12.65</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">40.3</span>, PL4::<span class="hljs-keyword">new</span>);
<span class="hljs-type">PL4</span> <span class="hljs-variable">pl4_2</span> <span class="hljs-operator">=</span> Logistics.create(
    <span class="hljs-number">4.19</span>, -<span class="hljs-number">1.10</span>, <span class="hljs-number">12.65</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">100.0</span>, PL4::<span class="hljs-keyword">new</span>);
...
<span class="hljs-type">PL4</span> <span class="hljs-variable">pl4_8</span> <span class="hljs-operator">=</span> Logistics.create(
    <span class="hljs-number">4.19</span>, -<span class="hljs-number">1.10</span>, <span class="hljs-number">12.65</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">1400.6</span>, PL4::<span class="hljs-keyword">new</span>);
System.out.println(pl4_1.compute());
System.out.println(pl4_2.compute());
...
System.out.println(pl4_8.compute());
</code></pre>
    <p class="normal">However, if all we need is <a id="_idIndexMarker1130"/>just the list of <code class="inlineCode">y</code> coordinates, then we can write a helper method in <code class="inlineCode">Logistics</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logistics</span> {
  ...
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T1, T2, T3, T4, X, R&gt; List&lt;R&gt; <span class="hljs-title">compute</span><span class="hljs-params">(</span>
<span class="hljs-params">      T1 t1, T2 t2, T3 t3, T4 t4, List&lt;X&gt; allX,</span>
<span class="hljs-params">      FiveFunction&lt;T1, T2, T3, T4, X, R&gt; f)</span> {
    List&lt;R&gt; allY = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (X x : allX) {
      allY.add(f.apply(t1, t2, t3, t4, x));
    }
    <span class="hljs-keyword">return</span> allY;
  }
  ...
}
</code></pre>
    <p class="normal">We can call this method as follows (here, we pass the 4PL formula, but it can be any other formula with five <code class="inlineCode">double</code> parameters):</p>
    <pre class="programlisting code"><code class="hljs-code">FiveFunction&lt;Double, Double, Double, Double, Double, Double&gt; 
    pl4 = (a, b, c, d, x) -&gt; d + ((a - d) / 
                            (<span class="hljs-number">1</span> + (Math.pow(x / c, b)))); 
List&lt;Double&gt; allX = List.of(<span class="hljs-number">40.3</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">250.2</span>, <span class="hljs-number">400.1</span>, 
                            <span class="hljs-number">600.6</span>, <span class="hljs-number">800.4</span>, <span class="hljs-number">1150.4</span>, <span class="hljs-number">1400.6</span>); 
List&lt;Double&gt; allY = Logistics.compute(<span class="hljs-number">4.19</span>, -<span class="hljs-number">1.10</span>, <span class="hljs-number">12.65</span>,
                                      <span class="hljs-number">0.03</span>, allX, pl4);
</code></pre>
    <p class="normal">You can find the <a id="_idIndexMarker1131"/>complete example in the bundled code.</p>
    <h1 id="_idParaDest-443" class="heading-1">207. Implementing a Consumer that takes five (or any other arbitrary number of) arguments</h1>
    <p class="normal">Before continuing with this <a id="_idIndexMarker1132"/>problem, I strongly recommend that you read <em class="italic">Problem 206</em>.</p>
    <p class="normal">Writing a custom <code class="inlineCode">Consumer</code> that takes five arguments can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">FiveConsumer</span> &lt;T1, T2, T3, T4, T5&gt; {
    
  <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span> <span class="hljs-params">(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5)</span>;
}
</code></pre>
    <p class="normal">This is the five-arity specialization of the Java <code class="inlineCode">Consumer,</code> just as the built-in <code class="inlineCode">BiConsumer</code> is the two-arity specialization of the Java <code class="inlineCode">Consumer</code>.</p>
    <p class="normal">We can use <code class="inlineCode">FiveConsumer</code> in conjunction with the PL4 formula, as follows (here, we compute <code class="inlineCode">y</code> for <code class="inlineCode">x</code> = 40.3):</p>
    <pre class="programlisting code"><code class="hljs-code">FiveConsumer&lt;Double, Double, Double, Double, Double&gt; 
  pl4c = (a, b, c, d, x) -&gt; Logistics.pl4(a, b, c, d, x);
        
pl4c.accept(<span class="hljs-number">4.19</span>, -<span class="hljs-number">1.10</span>, <span class="hljs-number">12.65</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">40.3</span>);  
</code></pre>
    <p class="normal">The <code class="inlineCode">Logistics.pl4()</code> is the method that contains the formula and displays the result:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pl4</span><span class="hljs-params">(Double a, Double b, </span>
<span class="hljs-params">                       Double c, Double d, Double x)</span> {
        
  System.out.println(d + ((a - d) / (<span class="hljs-number">1</span> 
                       + (Math.pow(x / c, b)))));
}
</code></pre>
    <p class="normal">Next, let’s see how we can partially apply a <code class="inlineCode">Function</code>.</p>
    <h1 id="_idParaDest-444" class="heading-1">208. Partially applying a Function</h1>
    <p class="normal">A <code class="inlineCode">Function</code> that is partially applied is a <code class="inlineCode">Function</code> that applies only a part of its arguments, returning <a id="_idIndexMarker1133"/>another <code class="inlineCode">Function</code>. For instance, here is a <code class="inlineCode">TriFunction</code> (a functional function with three arguments) that contains the <code class="inlineCode">apply()</code> method, next to two <code class="inlineCode">default</code> methods that partially apply this function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">TriFunction</span> &lt;T1, T2, T3, R&gt; {
    
  R <span class="hljs-title">apply</span><span class="hljs-params">(T1 t1, T2 t2, T3 t3)</span>;
   
  <span class="hljs-keyword">default</span> BiFunction&lt;T2, T3, R&gt; <span class="hljs-title">applyOnly</span><span class="hljs-params">(T1 t1)</span> {
    <span class="hljs-keyword">return</span> (t2, t3) -&gt; apply(t1, t2, t3);
  }
    
  <span class="hljs-keyword">default</span> Function&lt;T3, R&gt; <span class="hljs-title">applyOnly</span><span class="hljs-params">(T1 t1, T2 t2)</span> {
    <span class="hljs-keyword">return</span> (t3) -&gt; apply(t1, t2, t3);
  }
}
</code></pre>
    <p class="normal">As you can see, <code class="inlineCode">applyOnly(T1 t1)</code> applies only the <code class="inlineCode">t1</code> argument and returns a <code class="inlineCode">BiFunction</code>. On the other hand, <code class="inlineCode">applyOnly(T1 t1, T2 t2)</code> applies only <code class="inlineCode">t1</code> and <code class="inlineCode">t2</code>, returning a <code class="inlineCode">Function</code>.</p>
    <p class="normal">Let’s see how we can use these methods. For instance, let’s consider the formula (a+b+c)<sup class="superscript">2</sup> = a<sup class="superscript">2</sup>+b<sup class="superscript">2</sup>+c<sup class="superscript">2</sup>+2ab+2bc+2ca, which can be shaped via the <code class="inlineCode">TriFunction</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">TriFunction&lt;Double, Double, Double, Double&gt; abc2 = (a, b, c)
  -&gt; Math.pow(a, <span class="hljs-number">2</span>) + Math.pow(b, <span class="hljs-number">2</span>) + Math.pow(c, <span class="hljs-number">2</span>) 
     + <span class="hljs-number">2.0</span>*a*b + <span class="hljs-number">2</span>*b*c + <span class="hljs-number">2</span>*c*a;        
System.out.println(<span class="hljs-string">"abc2 (1): "</span> + abc2.apply(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>));
System.out.println(<span class="hljs-string">"abc2 (2): "</span> + abc2.apply(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>));
System.out.println(<span class="hljs-string">"abc2 (3): "</span> + abc2.apply(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>));
</code></pre>
    <p class="normal">Here, we call <code class="inlineCode">apply(T1 t1, T2 t2, T3 t3)</code> three times. As you can see, only the <code class="inlineCode">c</code> term has a different value per call, while <code class="inlineCode">a</code> and <code class="inlineCode">b</code> are constantly equal with 1.0 and 2.0, respectively. This means that we can use <code class="inlineCode">apply(T1 t1, T2 t2)</code> for <code class="inlineCode">a</code> and <code class="inlineCode">b</code>, and <code class="inlineCode">apply(T1 t1)</code> for <code class="inlineCode">c</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Function&lt;Double, Double&gt; abc2Only1 = abc2.applyOnly(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);
        
System.out.println(<span class="hljs-string">"abc2Only1 (1): "</span> + abc2Only1.apply(<span class="hljs-number">1.0</span>));
System.out.println(<span class="hljs-string">"abc2Only1 (2): "</span> + abc2Only1.apply(<span class="hljs-number">2.0</span>));
System.out.println(<span class="hljs-string">"abc2Only1 (3): "</span> + abc2Only1.apply(<span class="hljs-number">3.0</span>));
</code></pre>
    <p class="normal">If we assume that only <code class="inlineCode">a</code> is <a id="_idIndexMarker1134"/>constant (1.0) while <code class="inlineCode">b</code> and <code class="inlineCode">c</code> have different values per call, then we can use <code class="inlineCode">apply(T1 t1)</code> for <code class="inlineCode">a</code> and <code class="inlineCode">apply(T1 t1, T2 t2)</code> for <code class="inlineCode">b</code> and <code class="inlineCode">c</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">BiFunction&lt;Double, Double, Double&gt; abc2Only2 
  = abc2.applyOnly(<span class="hljs-number">1.0</span>);
        
System.out.println(<span class="hljs-string">"abc2Only2 (1): "</span> 
  + abc2Only2.apply(<span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>));
System.out.println(<span class="hljs-string">"abc2Only2 (2): "</span> 
  + abc2Only2.apply(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>));
System.out.println(<span class="hljs-string">"abc2Only2 (3): "</span> 
  + abc2Only2.apply(<span class="hljs-number">3.0</span>, <span class="hljs-number">2.0</span>));
</code></pre>
    <p class="normal">Mission accomplished!</p>
    <h1 id="_idParaDest-445" class="heading-1">Summary</h1>
    <p class="normal">This chapter covered 24 problems. Most of them focused on working with predicates, functions, and collectors, but we also covered the JDK 16 <code class="inlineCode">mapMulti()</code> operation, refactoring imperative code to functional code, and much more.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>