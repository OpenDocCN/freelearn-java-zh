- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a book about refactoring, it may seem a bit strange to talk about metaprogramming.
    More than refactoring per se, in our opinion, talking about metaprogramming and
    tools that use it can be useful concerning clean code, and writing clean code
    means “preventing” the refactoring, which is indeed still relevant to our goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will see shortly, metaprogramming involves writing programs that work
    on programs. In our context, we will endorse the usage of frameworks written by
    others (the first virtue of a good software engineer: laziness) that help us write
    less code (told you!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing less code (or rather, having it written by tools) is a good thing:
    it means less code to maintain, trivially, and it means that those portions of
    code are in charge of dedicated tools that will then write that code in the best
    possible way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is metaprogramming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring compile-time and runtime metaprogramming tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lombok and MapStruct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weighing the pros and cons of metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is metaprogramming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we encounter software designed to create, manipulate, or interact with
    other software in various ways, we are engaging in **metaprogramming**. This technique
    allows computer programs to treat other programs as their data. In my opinion,
    it represents a very powerful instrument in the hands of wise people; as with
    everything in life, it also has some drawbacks that we’ll analyze later.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming means writing software (or, as we’ll see in a moment, using
    software) that can be set up to do things such as read, create, analyze, or change
    other programs. It can even tweak its own code while it’s running. This cool trick
    allows developers to write solutions with less code, saving time. Plus, it makes
    programs more flexible so that they can handle new situations without needing
    a full rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with any programming language, grasping the fundamentals of metaprogramming
    and adopting sound software development practices is crucial for enhancing the
    overall quality of applications, including those that incorporate metaprogramming
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, metaprogramming promotes **code reusability**. It accomplishes
    this by allowing developers to create code generators and templates that eliminate
    redundancy in their code bases. This not only reduces the likelihood of errors
    but also streamlines maintenance efforts. When code is generated automatically,
    developers can make changes in one place, and those changes will propagate throughout
    the code base. This results in more maintainable, cleaner, and less error-prone
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most compelling aspects of metaprogramming is its capacity to enable
    dynamic behavior in programs. This dynamic behavior empowers software systems
    to adapt to changing conditions at runtime. In practical terms, this means that
    the behavior of a program can be adjusted or configured without the need for extensive
    code modifications and recompilation. As a result, metaprogramming is particularly
    valuable in scenarios where a program’s behavior must be flexible, configurable,
    or subject to frequent changes.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, metaprogramming has a direct impact on developer productivity.
    By automating repetitive coding tasks, it allows developers to focus on higher-level
    design and problem-solving. This, in turn, leads to faster development cycles
    and more efficient code bases. The time and effort saved through metaprogramming
    can be channeled into improving the overall quality of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Metaprogramming is not limited to making code more efficient; it also promotes
    the creation of **domain-specific languages** (**DSLs**). These DSLs are tailored
    to specific problem domains, enabling developers to express complex ideas more
    naturally and concisely. DSLs abstract away the intricacies of general-purpose
    programming languages and allow developers to communicate directly with the domain’s
    concepts, significantly improving communication between technical and non-technical
    stakeholders. To illustrate this concept, imagine you are working on a financial
    application, and you need to calculate the interest on a loan. In Java, using
    a general-purpose language, it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this Java code, you are dealing with low-level details such as variable types,
    operators, and calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how a DSL could make this more domain-specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `LoanDSL` is a DSL that’s designed to work with financial calculations.
    It abstracts away the low-level details and provides a higher-level interface
    that directly communicates with the financial domain’s concepts, making it easier
    to understand and work with. This can greatly improve communication between developers
    and domain experts in finance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, metaprogramming helps in building efficient abstractions. These abstractions
    hide the underlying implementation details, making the code more understandable
    and maintainable. By encapsulating complexity and exposing only essential information,
    metaprogramming enhances the code base’s overall clarity and comprehensibility.
    Metaprogramming can be split into two main categories: compile-time and runtime.
    Let’s taste a bit of each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring compile-time metaprogramming tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile-time metaprogramming involves code transformations and generation that
    occur during the compilation phase. In other words, operations, transformations,
    or code generation are performed on a program during the compilation process –
    that is, before the program is executed. Macros, code generators, and annotation
    processors are common tools for compile-time metaprogramming in Java. Given the
    subject of this book, compile-time metaprogramming will be our main focus since
    we think that the instruments and frameworks that fall under this definition are
    the best ways to keep your code clean. In particular, we’ll focus on code generator
    tools: programming languages and tools that provide facilities for generating
    code based on certain specifications or models (in the following section, we will
    focus specifically on Lombok and MapStruct). The code generated by these tools
    can be customized according to the specific requirements of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Lombok
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Project Lombok** (born in 2009) is a popular Java library that simplifies
    Java development by reducing boilerplate code and making the code cleaner and
    more concise.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java (at least until version 14 with the introduction of the `record` keyword),
    there is often a significant amount of boilerplate code that needs to be written
    for basic tasks such as defining getter and setter methods, constructors, and
    the `toString()`, `equals()`, and `hashCode()` methods. This boilerplate code
    can be time-consuming to write and maintain, making the code base longer and harder
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lombok** addresses this issue by providing annotations that automatically
    generate this boilerplate code during compilation. This means developers don’t
    have to write these repetitive code elements themselves, reducing the likelihood
    of errors and making the code base more concise.'
  prefs: []
  type: TYPE_NORMAL
- en: Lombok functions as an annotation processor that enhances your classes by introducing
    additional code during the compilation phase. Annotation processing was introduced
    to the Java compiler in version 5\. The concept involves users placing annotation
    processors, whether self-authored or obtained from third-party dependencies such
    as Lombok, in the build classpath. During the compilation process, as the compiler
    encounters an annotation, it effectively inquires, “Is anyone in the classpath
    concerned with this `@Annotation`?” For those processors answering yes, the compiler
    delegates control to them, along with the compilation context, allowing them to
    perform their respective tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Lombok’s annotation processing involves making adjustments to the compiler’s
    data structures that represent the code, specifically the **abstract syntax tree**
    (**AST**). Think of the AST as a roadmap for the computer program. It shows all
    the necessary steps that must be taken to create the final program. In Java, it
    is created before the actual program code (**bytecode**) is made. The cool thing
    is that you can change and work with this AST in Java. Through these modifications
    to the compiler’s AST, Lombok indirectly influences the generation of the final
    bytecode. To achieve this functionality, Lombok is required to intercept and manage
    calls that are made to the Java compiler for handling the generation of intermediate
    code. This interception process is facilitated using plugins, which can be configured
    within your **integrated development environment** (**IDE**), such as IntelliJ,
    VS Code, or Eclipse, or integrated into your build automation tools, such as Maven,
    Gradle, or Make. It’s important to note that if your IDE or build management system
    lacks compatibility with Lombok, it may result in compilation issues for your
    code; anyway, that simply will not happen with modern versions of the most used
    IDEs (they support Lombok out of the box).
  prefs: []
  type: TYPE_NORMAL
- en: As we already said, Lombok works with a bunch of very simple annotations. Let’s
    see some examples of its magic. We’ll provide you with the basics. However, there’s
    much more to discover in the Lombok official documentation, which you can find
    in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Lombok with an example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the most basic form of a Java class: a `toString()` method,
    an often `equals()` and `hashcode()` to complete the picture. It’s faster to write
    one than to describe it (the following code is intentionally long):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be simple to understand what this class does: nothing! It has three
    fields, all of which are `private`, three constructors (the default one with no
    argument and one with all the fields – one that takes another instance of the
    same object), one getter and one setter for each of the fields, `equals` and `hashcode`
    methods that involve all of the fields, and finally a `toString` method. All of
    this code has been generated from my IDE; this class just represents a piece of
    information. It is what is called a **data class** in other languages. And just
    for this, we have more than 70 lines of code! Let’s see how Lombok can rescue
    us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, add Project Lombok to your classpath. If you are using
    Maven, you just have to add the dependency to your `pom.xml` file (we’re going
    to use the latest version at the time of writing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One funny thing is that if you just start typing Lombok’s annotations into your
    code, some IDEs, such as IntelliJ IDEA, will suggest that you include Lombok in
    your classpath. It is that smooth.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said, Lombok works by adding annotations to the source code, which implement
    some behaviors considered *boilerplate*. For example, in the *copy constructor*
    of the object, we can see an `if` statement that checks for the possible nullity
    of the parameter that’s passed in as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This `if` statement can be replaced with the `@NonNull` annotation next to
    the parameter in the constructor: the null check takes the form of an `if` statement,
    `if (param == null) throw new NullPointerException("param is marked non-null but
    is null")`, and will be placed at the beginning of your method. In the case of
    constructors, the null check will be inserted right after any explicit `this()`
    or `super()` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at the default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the `@NoArgsConstructor` annotation, we can get rid of the default constructor.
    A constructor with no parameters will be automatically generated. However, if
    this isn’t feasible due to the presence of final fields, a compiler error will
    occur. This will happen unless you explicitly annotate with `@NoArgsConstructor(force
    = true)`, in which case all final fields will be initialized with default values
    (`0` for numeric types, `false` for Boolean, and `null` for reference types).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second constructor we can get rid of is the **all-arguments** constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can replace these lines of code with the `@AllArgsConstructor` annotation,
    which produces a constructor that accepts one parameter for each field within
    your class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should any of the arguments be `final`, this means that only some of the fields
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we can use `@RequiredArgsConstructor`, which generates a constructor
    with one parameter for each field that necessitates specific treatment. This includes
    all non-initialized final fields, as well as any fields annotated with `@NonNull`
    that haven’t been initialized where they are declared. For the fields marked with
    `@NonNull`, an explicit null check is also created. If any of the parameters intended
    for `@NonNull` fields contain null, the constructor will throw a `NullPointerException`
    error. The parameter order corresponds to the order in which the fields are defined
    in your class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next features of Lombok are the `@Getter` and/or `@Setter` annotations
    to any field, allowing Lombok to automatically generate default getter and setter
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A default getter method essentially retrieves the field’s value and follows
    the `getName` naming convention if the field is named `name` (or `isName` if the
    field is of the Boolean type). Meanwhile, a default setter method named `setName`
    is used if the field is named `name`, returns `void`, and accepts a single parameter
    of the same type as the field. This setter method simply assigns the field the
    provided value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to apply the `@Getter` and/or `@Setter` annotation to a
    class itself. In such cases, it’s as though you’ve annotated all non-static fields
    within that class with the same annotation. So, the previous code snippet can
    be also written in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the generated getter and setter methods are public, unless you
    explicitly specify `AccessLevel`. The access levels that you can use are `PUBLIC`,
    `PROTECTED`, `PACKAGE`, and `PRIVATE`. For example, you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equals` and `hashcode` methods can be generated by adding the `@EqualsAndHashCode`
    annotation: this allows Lombok to automatically generate implementations for the
    `equals(Object other)` and `hashCode()` methods. By default, it includes all non-static,
    non-transient fields. However, you have the flexibility to customize which fields
    are included (and even specify that the results of certain methods should be considered)
    by annotating type members with `@EqualsAndHashCode.Include` or `@EqualsAndHashCode.Exclude`.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can precisely specify the fields or methods you want to include
    by annotating them with `@EqualsAndHashCode.Include` and using `@EqualsAndHashCode``(onlyExplicitlyIncluded
    =` `true)`.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you have the chance to make Lombok generate a `toString`
    method simply by adding the `@ToString` annotation. Configuration options are
    used to determine whether field names should be included. Otherwise, the format
    follows a fixed structure, which is the class name followed by parentheses containing
    fields separated by commas – as an example, it appears as `Person(name=charlie,
    surname=brown)`. To enhance the clarity (although it may increase the length)
    of the `toString()` method’s output, you can set the `includeFieldNames` parameter
    to `true`. By default, all non-static fields are printed. If you wish to exclude
    certain fields, you can annotate them with `@ToString.Exclude`. Alternatively,
    you can precisely specify which fields to include by using `@ToString(onlyExplicitlyIncluded
    = true)` and then marking each field you want to include with `@ToString.Include`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, our 70-lines-long code is reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Still not satisfied? You can use `@Data`, a convenient shortcut annotation
    that bundles the features of `@ToString`, `@EqualsAndHashCode`, `@Getter` / `@Setter`,
    and `@``RequiredArgsConstructor` together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you want to preserve immutability (and you definitively should!), you can
    use the `@Value` annotation, which is the immutable variant of `@Data`. In this
    case, all fields are automatically set as `private` and `final` by default, and
    no setters are generated. Additionally, the class itself is made `final` by default
    because enforcing immutability on a subclass is not feasible. Similar to the `@Data`
    annotation, it includes helpful `toString()`, `equals()`, and `hashCode()` methods
    generation. Each field is equipped with a getter method, and a constructor is
    generated to encompass all arguments (excluding `final` fields, which are initialized
    in the field declaration).
  prefs: []
  type: TYPE_NORMAL
- en: This is just a general overview of Lombok’s annotations. Using their properties
    (and also some other configurations that can be added to the project through a
    file called `lombok.config` (the link for the official documentation can be found
    in the *Further reading* section)), it is possible to make the behavior of Lombok
    much more granular, acting at the level of a single field, a single method, or
    customizing the implementation generated by this powerful library. This was just
    the proverbial tip of the iceberg.
  prefs: []
  type: TYPE_NORMAL
- en: Lombok’s builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B20912_05.xhtml#_idTextAnchor117), we saw what the builder
    pattern is: a design pattern that helps construct complex objects by separating
    their construction from their representation, making it easier to create objects
    with various configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Builder` annotation lets you create a *builder* class for your type with
    basically no effort. If we take the `Person` class we wrote at the end of the
    previous section and add the `@Builder` annotation on top of it, Lombok will generate
    some code that we can use to instantiate a `Person` instance in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you’re creating an instance of `Person` using a fluent and
    readable builder pattern. You set the values of the fields using the generated
    builder’s methods and then call `.build()` to create the final instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Builder` annotation can also handle optional fields and default values,
    making it a convenient way to create objects with a variable number of properties.
  prefs: []
  type: TYPE_NORMAL
- en: Lombok’s `@Builder` annotation is especially useful in scenarios where you need
    to construct complex objects with many optional parameters or when you want to
    create immutable objects. It eliminates the need to write repetitive, verbose,
    and error-prone boilerplate code for building objects, making your code more concise
    and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Builder` annotation can generate “singular” methods for collection parameters/fields,
    which accept a single element rather than an entire list, and add that element
    to the collection. Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `@Singular` annotation that was put on a collection field. When you
    annotate a parameter in a method or constructor with the `@Singular` annotation
    or a field in a class with the `@Singular` annotation, Lombok treats that builder
    node as a collection. As a result, Lombok generates two **adder** methods instead
    of a **setter** method. The first adder method allows you to add a single element
    to the collection, while the second adder method allows you to add all elements
    from another collection to the existing collection. Lombok does not generate a
    setter method that replaces the entire collection. Additionally, Lombok generates
    a **clear** method for the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could write the following code for the previously shown `Team`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could also write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You will get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a particular field or parameter is not explicitly set during the object
    construction process, it will default to values such as `0`, `null`, or `false`,
    depending on its type. When you use the `@Builder` annotation in a class (rather
    than a method or constructor), you can define a default value directly on the
    field and annotate it with `@Builder.Default`. Look at the following code as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if the created field is not set during object construction,
    it will default to the result of `System.currentTimeMillis()`, ensuring that it
    always has a valid timestamp value.
  prefs: []
  type: TYPE_NORMAL
- en: When used in a sentence, Lombok’s builder feature is particularly useful because
    it simplifies the creation of complex objects with a fluent and concise syntax,
    reducing the need for manual builder pattern implementation in Java. However,
    there are also some drawbacks to using this library, which we will investigate
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Some final considerations about Lombok’s pros and cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By reducing the boilerplate code, Lombok helps improve code cleanliness and
    readability. Developers can focus on writing the essential business logic of their
    classes, making the code base more understandable and maintainable. It also reduces
    the chances of introducing bugs in the manually written boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: With Lombok, maintaining the code becomes more straightforward. When you need
    to add or remove fields from a class, you don’t have to update all the related
    methods manually. Lombok’s annotations take care of these changes automatically
    during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern IDEs support Lombok out of the box. They can recognize Lombok annotations
    and provide code completion, navigation, and refactoring assistance as if the
    code were written manually. This ensures a seamless development experience for
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: In our humble opinion, Project Lombok is a valuable tool in the Java ecosystem
    that simplifies code development by automating the generation of common code elements,
    reducing boilerplate, and improving code readability. It allows developers to
    focus on the core functionality of their classes and reduces the chances of introducing
    errors in repetitive code. This makes Java code cleaner, more concise, and easier
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to give a complete and honest overview, we have to highlight some
    common criticisms about Lombok. Let’s start with the most subjective (almost a
    “gut feeling” some people have) criticism: Lombok’s unique and sometimes forceful
    way of doing things (in particular, modifying the bytecode) has often made people
    see it as a bit of a workaround. We see it as a clever, technically sound, and
    innovative solution rather than a negative hack. However, some developers still
    see it as a workaround and avoid using Lombok for that reason. That’s a valid
    perspective, but in our experience, Lombok’s advantages in terms of productivity
    are more significant than any worries about its approach. We’ve been using it
    happily in real-life projects for many years.'
  prefs: []
  type: TYPE_NORMAL
- en: It is useless to deny that, since Lombok intervenes as a sort of “extra step”
    at the time of compilation, the time to carry out this practice increases. As
    the code base increases, of course, the times increase proportionally. As high
    as the efficiency is and the Lombok team actively working on further improvements,
    it is undeniable that projects compile faster without Lombok.
  prefs: []
  type: TYPE_NORMAL
- en: There could also be problems related to compatibility between different versions
    of Java. With each version change, Java could change the way your AST is generated
    and/or interpreted. Consequently, it is not certain that Lombok can generate the
    code correctly or that it succeeds at all. The code may stop compiling. Unfortunately,
    we would only notice this after upgrading Java, but it is also true that new versions
    of the library are released before the final versions of Java. However, there
    is still one possibility to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: This eventuality leads us to another problematic aspect, namely the fact that
    Lombok makes the code we write non-standard; since we need the Lombok plugin to
    compile, it is undeniable that the code we are writing, in a sense, is not valid.
    We will always depend on tools that are “external” to Java.
  prefs: []
  type: TYPE_NORMAL
- en: The last possible flaw that comes to mind is not a defect in my opinion, but
    something I have often heard. It’s true that Lombok greatly reduces the number
    of lines of code, eliminating the so-called boilerplate, but it is also true that
    all IDEs can generate that boilerplate in a couple of clicks. This is a pseudo-criticism
    of Lombok. While it is certainly true that getters, setters, equals, builders,
    and more are generated in a moment by any IDE worthy of the name, it is also true
    that all of this code must then be maintained. How many times have we added a
    field to a class and forgotten to update the `equals` method? How many times have
    we had to change the getters and setters of a field because we changed its name
    or type? With Lombok, the chances of all these errors occurring simply do not
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: I hope I’ve given you some interesting ideas to think about so far. Unfortunately,
    I don’t have a one-size-fits-all solution for all these considerations. As always,
    we recommend evaluating each situation individually and trying to reach a team
    agreement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will tell you about another library that can save you
    from a lot of manual work, especially when it comes to converting one type into
    another, which is something that unfortunately needs to be done in practically
    every project. MapStruct will free you from this burden or at least make it easier.
  prefs: []
  type: TYPE_NORMAL
- en: MapStruct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it’s not great to say, part of our job as software engineers is shipping
    information from one place to another. Sometimes, this shipping becomes a mere
    translation of a model into another model. Sad, but true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object mapping (sometimes referred to as **object adapting**) refers to the
    process of transforming data between different data models, such as from objects
    in an object-oriented programming language to database tables and vice versa.
    This process also includes objects belonging to different subdomains or even different
    layers of the application. Another notable example of mapping that is done frequently
    is when you have to call an external service (for example, via an HTTP/REST call)
    and you have to map the response you get from that service into your objects or
    your model. This situation is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Mapping between client and service request models and back to
    the client model](img/B20912_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Mapping between client and service request models and back to the
    client model
  prefs: []
  type: TYPE_NORMAL
- en: Writing mapping code can be very boring, and it’s prone to mistakes. But what
    if there was a tool that could do all this grunt work with minimal effort? Luckily
    for us, there are quite a few such tools out there, and our top pick is MapStruct.
  prefs: []
  type: TYPE_NORMAL
- en: '**MapStruct** is an open source Java-based code generation library that simplifies
    the process of mapping between Java beans (POJOs). It is specifically designed
    for generating mapping codes between objects, eliminating the need to write this
    code manually, which can be time-consuming and error-prone. MapStruct’s primary
    purpose is to provide a straightforward and efficient way to convert data between
    different Java bean classes.'
  prefs: []
  type: TYPE_NORMAL
- en: MapStruct serves as an annotation processor that’s seamlessly integrated into
    the Java compiler, making it compatible with command-line build tools such as
    Maven and Gradle, and equally suitable for use within your favorite IDE. While
    MapStruct provides sensible defaults for mapping, it also allows you to configure
    and implement specific behaviors when needed, giving you flexibility without imposing
    rigid constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how MapStruct works. Suppose you have the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to transfer the data from an instance of `PersonDTO` to an instance
    of `Person`. To do it in plain Java, we would need to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That is quite a lot of code for only three fields; it’s boring, time-consuming,
    and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using MapStruct, we could just write an interface and let it do the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The presence of the `@Mapper` annotation designates the interface as a mapping
    interface and triggers the MapStruct processor to engage during the compilation
    process. In the mapping method itself, you can freely select its name, and it
    should accept the `source` object as a parameter while returning the `target`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: To handle attributes with distinct names in the `source` and `target` objects,
    you can employ the `@Mapping` annotation to specify the desired configuration.
    When necessary and feasible, type conversions will be carried out for attributes
    with differing types in the `source` and `target` objects. For instance, an enumeration
    type may be transformed into a string.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that a single interface can host multiple mapping methods,
    each of which will have an implementation auto-generated by MapStruct. You can
    obtain an instance of the interface’s implementation through the `Mappers` class.
    As a convention, the interface typically includes a member called `INSTANCE`,
    offering clients a means to access the mapper implementation.
  prefs: []
  type: TYPE_NORMAL
- en: MapStruct will generate all the needed code for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we’re missing the mapping from `birthdate` to `age`;
    this cannot be done automatically by MapStruct since a little bit of logic is
    involved (to calculate the current age from the birth date). In this case – and
    in any case, we should need it – we can implement specific mappings; also, in
    this case, the method names are not important since MapStruct will choose the
    right one based on the parameter and return types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the auto-generated implementation of the method, MapStruct will choose the
    `calculateCurrentAge` method just because it takes a `LocalDate` parameter and
    returns an `Integer` value. It is also possible to specify Java expressions and
    other stuff in the `@Mapping` annotation, but I recommend reading the documentation
    to dig a little bit deeper.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve seen how MapStruct works and how it can make our lives easier
    by handling time-consuming tasks. As I mentioned, these were static metaprogramming
    tools – they work directly on the code. Now, let’s look at runtime metaprogramming
    tools, which work on the running program instead.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring runtime metaprogramming tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Runtime metaprogramming** operates while the program is being executed. It
    enables the program to inspect and modify its own code and data structures during
    runtime, often using techniques such as reflection, dynamic code generation, and
    dynamic proxy. Learning about runtime metaprogramming tools can empower you to
    manipulate and adapt the behavior of a running program dynamically, enhancing
    flexibility and customization within your software.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about reflection since it is the most used feature in runtime
    metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Reflection** is a feature in programming languages such as Java that allows
    a program to examine or *reflect* upon its structure, data, and behavior during
    runtime. In Java, reflection is primarily used to inspect and manipulate classes,
    objects, methods, fields, and other elements of the program at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflection allows you to perform the following tasks in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inspect classes**: You can obtain information about classes, including their
    name, superclass, implemented interfaces, constructors, methods, and fields'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inspect objects**: You can examine the properties and fields of objects,
    even if their types are not known at compile time'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Invoke methods**: You can invoke methods on objects, even if you don’t know
    the method’s name until runtime'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Access fields**: You can read or modify the values of fields within an object,
    even if you don’t know the field’s name until runtime'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let’s add the following method to the `Person` class (see the
    *MapStruct* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create another class that operates on it using reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We obtain the `Class` object representing the `Person` class using `Class.forName("
    com.example.demo3.mapstruct.Person")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an instance of the `Person` class dynamically using its constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We access the private name field, bypassing the access modifier and modifying
    its value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We invoke the `greet` method of the `Person` instance using reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We verify that the name field has been modified successfully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that while this example demonstrates the use of reflection, it is
    essential to exercise caution when using reflection in practice. Reflection should
    be used judiciously, and you should be aware of the potential risks and performance
    implications associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there could be security risks because reflection can bypass Java’s
    access controls, allowing you to access and modify private members of classes.
    While this flexibility can be beneficial, it can also introduce security vulnerabilities
    if it’s not used with due care. Unauthorized access to sensitive data or the manipulation
    of internal program states can occur, which is why it’s crucial to employ security
    measures to prevent abuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very common problem is type safety: reflection operates at a low level
    and doesn’t provide the same level of type safety as traditional Java code. This
    can lead to unexpected type errors at runtime. For instance, you might call a
    method with the wrong parameters, and the error won’t be discovered until your
    code is running. This lack of compile-time checks can result in hard-to-debug
    runtime exceptions. It is also true that most of the modern IDEs warn the developer
    about this risk at the moment of writing code.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also some other challenges, concerning reflection in association with
    the clean code, that we will expand on in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection and clean code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a chapter about metaprogramming, we felt we had the duty to tell you something
    about runtime metaprogramming and its most (in)famous declination, which is reflection.
    But let’s think a bit about what reflection involves in terms of keeping your
    code base clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflection and **clean code** can sometimes be at odds with each other as reflection
    introduces complexities and potential code readability issues. However, when used
    carefully and thoughtfully, reflection can be employed in a clean and maintainable
    way. Let’s explore how reflection can impact clean code principles and how to
    strike a balance between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readability**: Clean code promotes readability. Reflection can make code
    less readable as it often involves working with class names and method names as
    strings, which are error-prone and can lead to code that is challenging to understand.
    To mitigate this, document your use of reflection thoroughly and provide clear
    comments explaining your intentions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Reflection can make code harder to maintain because it
    bypasses some of the compile-time checks that the Java compiler provides. If you’re
    using reflection to access private members or perform operations that wouldn’t
    be allowed through normal means, it can lead to unexpected behavior or maintenance
    challenges. You should consider alternatives, such as making the necessary changes
    to the code structure, whenever possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Clean code encourages simplicity. Reflection, being a complex
    feature, can introduce unnecessary complexity. It’s essential to ensure that your
    use of reflection is justified and that you are not introducing complexity where
    it’s not needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Clean code aims for consistency and a uniform style. Reflection
    can lead to inconsistent code because different parts of your program might access
    and manipulate elements in a variety of ways. To maintain consistency, consider
    establishing conventions and patterns for your use of reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Clean code emphasizes testability. Reflection can make it challenging
    to write unit tests since it allows you to bypass encapsulation. You might need
    to rely on integration tests or mock objects, which can be less ideal for isolated
    unit testing. Whenever possible, prefer to design your code for easy unit testing
    without relying heavily on reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Clean code should be efficient. Reflection can introduce performance
    overhead due to its dynamic nature. Before using reflection, profile your code
    and ensure that the performance impact is acceptable. In performance-critical
    applications, you might need to explore alternative approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Clean code aims to have no technical documentation at all
    since the code is so clear that it explains itself. However, since reflection
    decreases readability (we just said that a few words ago), the need for clear
    documentation or comments becomes essential. When using reflection, think about
    providing comprehensive documentation explaining the purpose, expected behavior,
    and potential risks associated with your reflective code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, reflection is a powerful but potentially dangerous feature in Java, and
    it should be used sparingly and with caution. It’s essential to weigh the benefits
    of using reflection against the added complexity and potential drawbacks it introduces
    to your code base. If you decide to use reflection, do so thoughtfully and document
    your code thoroughly to maintain clarity and transparency. Clean code principles
    should remain a top priority, even when you’re using reflection, to ensure your
    code base remains maintainable, readable, and efficient (nevertheless, it is worth
    noticing that reflection is often used “under the hood” in many metaprogramming
    frameworks).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned what metaprogramming is, both in its static and runtime
    flavor, let’s add some considerations about the pros and cons of these very powerful
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Weighing the pros and cons of metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaprogramming and clean code are two essential concepts in software development,
    and while they can sometimes appear to be at odds, they can also work in harmony
    when used effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming, in essence, involves dynamically manipulating or generating
    code during compilation or runtime. It offers the ability to automate repetitive
    tasks, create abstractions, and introduce flexibility into software development.
    Clean code, on the other hand, is a coding philosophy that emphasizes writing
    code that is easily readable, understandable, and maintainable. It promotes principles
    such as meaningful naming, eliminating redundancy, small and focused functions,
    and adhering to established coding conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming can aid in generating clean code by automating the creation
    of repetitive code structures and reducing clutter in source code files (for example,
    eliminating some boilerplate code, as we saw in the case of Lombok).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it can facilitate the development of abstractions that hide implementation
    details, leading to cleaner and more maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all that glitters is gold; you must ensure that the generated code
    is clean and adheres to clean code principles. Automation should not result in
    messy or cryptic code. In this sense, using well-known and well-tested frameworks
    with a solid community and a lot of documentation is probably the way to go. We
    don’t endorse reinventing the wheel, never; it’s very unlikely that you will find
    yourself in a situation where metaprogramming from scratch is what you need unless
    it’s for very small and limited use cases.
  prefs: []
  type: TYPE_NORMAL
- en: You also have to balance the advantages of automation with code readability
    and understandability since metaprogramming can introduce complexity. I once found
    myself in front of a Java method that returned a string containing an HTML web
    page! Without getting to sadness peaks like that, be sure that your teammates
    (and don’t forget your future self) can expand or modify your software with only
    a reasonable amount of headaches. We invite you to discuss every metaprogramming
    choice with the team. Avoid excessive “magic” in your code as it can obscure the
    understanding of the underlying processes. This obscurity may result in the emergence
    of bugs or unpredictable performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: If you just have to go for metaprogramming, document complex metaprogramming
    solutions thoroughly, providing clear explanations to assist future developers.
    Provide examples and write comments; in a single word, be merciful.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, we think that clean code’s advantages in terms of testing
    and debugging are notable, especially when dealing with compile-time metaprogramming
    tools such as Lombok and MapStruct. The essence of that advantage is that not
    only do you have cleaner code (because, for instance, the usage of Lombok facilitates
    object immutability) but you have less code. Having as little code as possible
    should be one of your top priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming and clean code can coexist harmoniously. Combining the advantages
    of automation and flexibility with a commitment to writing clean and maintainable
    code ensures that software projects remain both efficient and sustainable in the
    long run.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about metaprogramming’s pros and cons, it is worth mentioning
    the so-called **Not-Invented-Here** (**NIH**) syndrome. NIH syndrome refers to
    the tendency of some development teams or individuals to prefer creating their
    own solutions or tools rather than adopting existing, external solutions. This
    can happen even when existing solutions are well-established, proven, and readily
    available.
  prefs: []
  type: TYPE_NORMAL
- en: NIH syndrome can lead to several issues, including increased development time,
    reinvention of the wheel, and missed opportunities to leverage the expertise and
    contributions of the broader development community. It’s often considered a counterproductive
    behavior, and many software development communities encourage a more open-minded
    approach to adopting existing solutions when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Teams and developers are encouraged to weigh the pros and cons of building something
    in-house versus using external libraries or frameworks while considering factors
    such as time, expertise, maintenance, and the availability of well-established
    solutions in the open source community.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we talked about metaprogramming: what it is, how it works,
    and how it can or cannot be useful concerning clean code and refactoring. In particular,
    we looked at two very popular libraries that involve metaprogramming, especially
    code auto-generation: Lombok and MapStruct.'
  prefs: []
  type: TYPE_NORMAL
- en: We also warned you about the potential risks of using reflection and, in general,
    spoke about the pros and cons of using metaprogramming tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into static analysis, a method of code inspection
    that checks for issues without executing the code, and dynamic analysis, which
    involves evaluating code during its execution to identify problems.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lombok’s official documentation: [https://projectlombok.org/features/](https://projectlombok.org/features/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lombok: The Good, The Bad, and The Controversial*, by Felix Coutinho [https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/](https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MapStruct’s official website: [https://mapstruct.org/](https://mapstruct.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
