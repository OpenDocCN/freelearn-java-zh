<html><head></head><body>
<div id="_idContainer056">
<h1 class="chapter-number" id="_idParaDest-99"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-100"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.2.1">Building the Domain Hexagon</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In previous chapters, we had the opportunity to employ </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">DDD</span></strong><span class="koboSpan" id="kobo.7.1">) techniques, such as</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.8.1"> entities and value objects, to create a domain model. </span><span class="koboSpan" id="kobo.8.2">However, until now, we haven’t touched on organizing packages, classes, and modules to fit the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">architecture purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">Domain hexagon</span></strong><span class="koboSpan" id="kobo.12.1"> is the </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.13.1">place to start developing a hexagonal application. </span><span class="koboSpan" id="kobo.13.2">Based on the domain, we derive all other hexagons. </span><span class="koboSpan" id="kobo.13.3">We can say that the Domain hexagon is the brain of hexagonal systems because the core fundamental business logic resides in such </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">a hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">So, in this chapter, we will start to explore how to structure a hexagonal application project from the bottom using a Java module approach. </span><span class="koboSpan" id="kobo.15.2">This will help us ensure better encapsulation and unit testing to validate our code as we develop the Domain </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">hexagon components.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Bootstrapping the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Domain hexagon</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Understanding the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">problem domain</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Defining </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">value objects</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Defining entities </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">and specifications</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Defining </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">domain services</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Testing the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Domain hexagon</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.31.1">By the end of this chapter, you will have acquired a hands-on perspective on the development of all the Domain hexagon components. </span><span class="koboSpan" id="kobo.31.2">This knowledge will enable you to take care of all the details regarding the structure and arrangement of classes and packages in the </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Domain hexagon.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.33.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.34.1">To compile and run the code examples presented in this chapter, you will need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.36.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.38.1"> installed on your computer. </span><span class="koboSpan" id="kobo.38.2">They are all available for Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.44.1">Bootstrapping the Domain hexagon</span></h1>
<p><span class="koboSpan" id="kobo.45.1">The hexagonal application project that we will start in this chapter is actually a continuation of the topology and</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.46.1"> inventory system that we’ve developed in the last few chapters. </span><span class="koboSpan" id="kobo.46.2">However, the difference here is that we will augment some of the system’s capabilities and use the </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">Java Platform Module System</span></strong><span class="koboSpan" id="kobo.48.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.49.1">JPMS</span></strong><span class="koboSpan" id="kobo.50.1">) to encapsulate the</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.51.1"> Domain hexagon in a </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">Java module.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">To get started with bootstrapping the Domain hexagon, let’s create a multi-module Maven project, </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.55.1">First, we will create a parent project called </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">topology-inventory</span></strong><span class="koboSpan" id="kobo.57.1"> by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">following code:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.59.1">mvn archetype:generate \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.60.1">-DarchetypeGroupId=org.codehaus.mojo.archetypes \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.61.1">-DarchetypeArtifactId=pom-root \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.62.1">-DarchetypeVersion=RELEASE \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.63.1">-DgroupId=dev.davivieira \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.64.1">-DartifactId=topology-inventory \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.65.1">-Dversion=1.0-SNAPSHOT \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.66.1">-DinteractiveMode=false</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.67.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">archetype:generate</span></strong><span class="koboSpan" id="kobo.69.1"> Maven goal to generate a Maven root project for the system. </span><span class="koboSpan" id="kobo.69.2">It creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">pom.xml</span></strong><span class="koboSpan" id="kobo.71.1"> file with the coordinates we pass in the command’s parameters, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">groupId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.73.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">artifactId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.76.1">Then, we create a module for the Domain hexagon, </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">like this:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.78.1">cd topology-inventory</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.79.1">mvn archetype:generate \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.80.1">  -DarchetypeGroupId=de.rieckpil.archetypes  \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.81.1">  -</span></strong><strong class="bold"><span class="koboSpan" id="kobo.82.1">DarchetypeArtifactId=testing-toolkit \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.83.1">  -DarchetypeVersion=1.0.0 \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.84.1">  -DgroupId=dev.davivieira \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.85.1">  -DartifactId=domain \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.86.1">  -Dversion=1.0-SNAPSHOT \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.87.1">  -Dpackage=dev.davivieira.topologyinventory.domain \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.88.1">  -DinteractiveMode=false</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.89.1">We recommend running the preceding command directly on the CMD instead of PowerShell if you use Windows. </span><span class="koboSpan" id="kobo.89.2">If you need to use PowerShell, you’ll need to wrap each command part in double </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">quotation marks.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.91.1">As shown in the </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.92.1">preceding code snippet, we enter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">topology-inventory</span></strong><span class="koboSpan" id="kobo.94.1"> Maven project root directory generated in the first step, and again, we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">archetype:generate</span></strong><span class="koboSpan" id="kobo.96.1"> Maven goal. </span><span class="koboSpan" id="kobo.96.2">The result is a Maven module called </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">domain</span></strong><span class="koboSpan" id="kobo.98.1"> that is part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">topology-inventory</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.100.1">Maven project.</span></span></p></li> <li><span class="koboSpan" id="kobo.101.1">After executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">mvn</span></strong><span class="koboSpan" id="kobo.103.1"> commands to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">topology-inventory</span></strong><span class="koboSpan" id="kobo.105.1"> Maven root project and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">domain</span></strong><span class="koboSpan" id="kobo.107.1"> module, you’ll have a directory tree similar to the one </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">shown here:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.109.1"><img alt="Figure 6.1 – The directory structure of the Domain hexagon" src="image/B19777_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.110.1">Figure 6.1 – The directory structure of the Domain hexagon</span></p>
<p><span class="koboSpan" id="kobo.111.1">Since the release of </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Java 9</span></strong><span class="koboSpan" id="kobo.113.1">, it has been </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.114.1">possible to create modules by putting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">module-info.java</span></strong><span class="koboSpan" id="kobo.116.1"> module descriptor file into a Java project root directory. </span><span class="koboSpan" id="kobo.116.2">When you create a Java module using this file, you close the access to all public packages in that module. </span><span class="koboSpan" id="kobo.116.3">To make public packages </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.117.1">accessible to other modules, you need to export the desired packages in the module descriptor file. </span><span class="koboSpan" id="kobo.117.2">There are other interesting things to say about Java modules, but we have reserved them for </span><a href="B19777_09.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.118.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.119.1">, </span><em class="italic"><span class="koboSpan" id="kobo.120.1">Applying Dependency Inversion with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.121.1">Java Modules</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">To transform the Domain hexagon in a Java module, you need to create a module descriptor file at </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">topology-inventory/domain/src/java/module-info.java</span></strong><span class="koboSpan" id="kobo.125.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
module domain {
}</span></pre> <p><span class="koboSpan" id="kobo.128.1">Because we’re not yet allowing access to any public packages, nor depending on other modules, we will leave the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">module-info.java</span></strong><span class="koboSpan" id="kobo.130.1"> file with </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">no entries.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">In order to make not just the Domain but also all other hexagons with less verbose classes, we’ll add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">lombok</span></strong><span class="koboSpan" id="kobo.134.1"> library to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">pom.xml</span></strong><span class="koboSpan" id="kobo.136.1"> project root, </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
&lt;dependencies&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
      &lt;artifactId&gt;lombok&lt;/artifactId&gt;
      &lt;version&gt;1.18.20&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</span></pre> <p><span class="koboSpan" id="kobo.139.1">It’s also important to configure the annotation processing paths for </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">lombok</span></strong><span class="koboSpan" id="kobo.141.1">; otherwise, there will be compilation</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.142.1"> failures. </span><span class="koboSpan" id="kobo.142.2">You can do this by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
&lt;plugins&gt;
  &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;configuration&gt;
          &lt;source&gt;17&lt;/source&gt;
          &lt;target&gt;17&lt;/target&gt;
          &lt;annotationProcessorPaths&gt;
              &lt;path&gt;
                   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                   &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                   &lt;version&gt;1.18.26&lt;/version&gt;
              &lt;/path&gt;
          &lt;/annotationProcessorPaths&gt;
      &lt;/configuration&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;</span></pre> <p><span class="koboSpan" id="kobo.145.1">It’s inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">maven-compile-plugin</span></strong><span class="koboSpan" id="kobo.147.1"> plugin block that we add the configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">annotationProcessorPaths</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">Because we add the lombok dependency, we need to update the domain’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">module-info.java</span></strong><span class="koboSpan" id="kobo.153.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
module domain {
    requires static lombok;
}</span></pre> <p><span class="koboSpan" id="kobo.156.1">We are now ready to </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.157.1">start developing the Domain hexagon on top of our fully modularized structure. </span><span class="koboSpan" id="kobo.157.2">Let’s move on to understand the problem domain of our enhanced topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">inventory system.</span></span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.159.1">Understanding the problem domain</span></h1>
<p><span class="koboSpan" id="kobo.160.1">We will start modeling the</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.161.1"> problem domain by considering the fact that a core router can connect to both core and edge routers. </span><span class="koboSpan" id="kobo.161.2">Edge routers, in turn, connect to switches and their networks. </span><span class="koboSpan" id="kobo.161.3">The following diagram depicts </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">this scenario:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.163.1"><img alt="Figure 6.2 – A use case for the topology and inventory network system" src="image/B19777_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Figure 6.2 – A use case for the topology and inventory network system</span></p>
<p><span class="koboSpan" id="kobo.165.1">Core routers are faster and deal with high traffic loads, and they don’t deal directly with the traffic generated from a switch and its networks. </span><span class="koboSpan" id="kobo.165.2">Conversely, edge routers deal directly with traffic generated by a switch and its networks. </span><span class="koboSpan" id="kobo.165.3">In our scenario, an edge router is not allowed to connect</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.166.1"> to other edge routers; it can only connect to core routers and switches. </span><span class="koboSpan" id="kobo.166.2">A switch can have </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">multiple networks.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Bear in mind that’s a particular arrangement established for our scenario. </span><span class="koboSpan" id="kobo.168.2">By no means does it represent a strict rule of how to organize network components. </span><span class="koboSpan" id="kobo.168.3">Here is a diagram showing the arrangement of </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">our scenario:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.170.1"><img alt="Figure 6.3 – A use case for the topology and inventory network system (continued)" src="image/B19777_06_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.171.1">Figure 6.3 – A use case for the topology and inventory network system (continued)</span></p>
<p><span class="koboSpan" id="kobo.172.1">The topology and inventory system’s purpose is to allow users to view and manage network assets. </span><span class="koboSpan" id="kobo.172.2">By network assets, we mean routers, switches, and networks – routers and switches being physical</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.173.1"> assets, and networks being logical assets provided by switches. </span><span class="koboSpan" id="kobo.173.2">Those assets are spread across different locations, and the system should show the interconnectivity between assets and their sites. </span><span class="koboSpan" id="kobo.173.3">A location is composed of the complete address, along with its latitude </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">and longitude.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">The management part is based on </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.176.1">nothing more than </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">Create, Read, Update, Delete</span></strong><span class="koboSpan" id="kobo.178.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.179.1">CRUD</span></strong><span class="koboSpan" id="kobo.180.1">)-like operations, allowing users to exert control over the topology and inventory </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">systems’ data.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Our approach to building such a system is to first create a Domain hexagon, using a domain model containing the operations and rules required to fulfill the system’s purpose at its highest level. </span><span class="koboSpan" id="kobo.182.2">Our intention at the highest level is to validate business ideas straight on the Domain hexagon without the aid of things present on the Application and Framework hexagons. </span><span class="koboSpan" id="kobo.182.3">As things move onto these hexagons, they tend to become more technology-specific, operating at a lower level, because technology-specific things are far away from the Domain hexagon. </span><span class="koboSpan" id="kobo.182.4">The degree to which we maintain the core system functionalities within the Domain hexagon heavily influences how loosely coupled the hexagonal system </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">will be.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">To validate the methods and classes of the Domain hexagon, we’ll create unit tests to ensure domain operations work as expected. </span><span class="koboSpan" id="kobo.184.2">This will give us a degree of assurance to move forward and</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.185.1"> use these operations on the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">Application hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Next, we will start to build the hexagonal system foundation with value objects, the architecture components that lets us create a domain model to better express the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">problem domain.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.189.1">Defining value objects</span></h1>
<p><span class="koboSpan" id="kobo.190.1">As we have already seen in </span><a href="B19777_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.191.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.192.1">, </span><em class="italic"><span class="koboSpan" id="kobo.193.1">Wrapping Business Rules inside Domain Hexagon</span></em><span class="koboSpan" id="kobo.194.1">, entities are the elements we use to classify system components that have an identity. </span><span class="koboSpan" id="kobo.194.2">Conversely, the</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.195.1"> value objects don’t have an identity. </span><span class="koboSpan" id="kobo.195.2">We use value objects to describe those system parts where there is no need to define an identity. </span><span class="koboSpan" id="kobo.195.3">Then, we have aggregates that serve to encapsulate the objects’ related entities </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">and values.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">I recommend starting by creating value objects first because they are like the building blocks, the raw material we’ll use to build more elaborate value objects, and – most importantly – the entities. </span><span class="koboSpan" id="kobo.197.2">Now, we’ll add all the volume object classes on the Domain hexagon module, which were created in the previous section when we bootstrapped the Domain hexagon. </span><span class="koboSpan" id="kobo.197.3">We’ll use the following steps to define the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">value objects:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.199.1">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">Id</span></strong><span class="koboSpan" id="kobo.201.1"> value object class, </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
package dev.davivieira.topologyinventory.domain.vo;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import java.util.UUID;
@Getter
@ToString
@EqualsAndHashCode
public class Id {
    private final UUID id;
    private Id(UUID id){
        this.id = id;
    }
    public static Id withId(String id){
        return new Id(UUID.fromString(id));
    }
    public static Id withoutId(){
        return new Id(UUID.randomUUID());
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.204.1">The</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.205.1"> preceding code is very straightforward, with just one </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">UUID</span></strong><span class="koboSpan" id="kobo.207.1"> attribute that we use to store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">id</span></strong><span class="koboSpan" id="kobo.209.1"> value. </span><span class="koboSpan" id="kobo.209.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">withId</span></strong><span class="koboSpan" id="kobo.211.1"> static method to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Id</span></strong><span class="koboSpan" id="kobo.213.1"> instances with a given string. </span><span class="koboSpan" id="kobo.213.2">If we want to create something new, we should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">withoutId</span></strong><span class="koboSpan" id="kobo.215.1"> static method, which randomly </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">generates IDs.</span></span></p></li> <li><span class="koboSpan" id="kobo.217.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Vendor</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.219.1">enum</span></strong><span class="koboSpan" id="kobo.220.1"> value object class, as we’ll see in the </span><em class="italic"><span class="koboSpan" id="kobo.221.1">Defining entities and specifications</span></em><span class="koboSpan" id="kobo.222.1"> section, is used on both router and switch entity classes. </span><span class="koboSpan" id="kobo.222.2">You can see this class in the following</span><a id="_idIndexMarker427"/> <span class="No-Break"><span class="koboSpan" id="kobo.223.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.224.1">
package dev.davivieira.topologyinventory.domain.vo;
public enum Vendor {
    CISCO,
    NETGEAR,
    HP,
    TPLINK,
    DLINK,
    JUNIPER
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.225.1">We will model the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Vendor</span></strong><span class="koboSpan" id="kobo.227.1"> class as </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">enum</span></strong><span class="koboSpan" id="kobo.229.1"> to let us easily illustrate the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">system features.</span></span></p></li> <li><span class="koboSpan" id="kobo.231.1">We will do the same thing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Model</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.233.1">enum</span></strong><span class="koboSpan" id="kobo.234.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.236.1">
package dev.davivieira.topologyinventory.domain.vo;
public enum Model {
    XYZ0001,
    XYZ0002,
    XYZ0003,
    XYZ0004
}</span></pre></li> <li><span class="koboSpan" id="kobo.237.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Protocol</span></strong><span class="koboSpan" id="kobo.239.1">, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">enum</span></strong><span class="koboSpan" id="kobo.241.1"> value object to </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.242.1">represent both the </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">Internet Protocol version 4</span></strong><span class="koboSpan" id="kobo.244.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.245.1">IPv4</span></strong><span class="koboSpan" id="kobo.246.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">IP version 6</span></strong><span class="koboSpan" id="kobo.248.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.249.1">IPv6</span></strong><span class="koboSpan" id="kobo.250.1">) protocols, </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.252.1">
package dev.davivieira.topologyinventory.domain.vo;
public enum Protocol {
    IPV4,
    IPV6;
}</span></pre></li> <li><span class="koboSpan" id="kobo.253.1">To help us clearly define which kind of router we’re dealing with, we’ll create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">RouterType</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.255.1">enum</span></strong><span class="koboSpan" id="kobo.256.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.258.1">
package dev.davivieira.topologyinventory.domain.vo;
public enum RouterType {
    EDGE,
    CORE;
}</span></pre></li> <li><span class="koboSpan" id="kobo.259.1">The same idea is also applied to available switch types, as we can </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">see here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.261.1">
package dev.davivieira.topologyinventory.domain.vo;
public enum SwitchType {
    LAYER2,
    LAYER3;
}</span></pre></li> <li><span class="koboSpan" id="kobo.262.1">As every router and switch has a location, we have to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Location</span></strong><span class="koboSpan" id="kobo.264.1"> value object class, </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.266.1">
package dev.davivieira.topologyinventory.domain.vo;
public record Location (
    String address,
    String city,
    String state,
    int zipCode,
    String country,
    float latitude,
    float longitude
) {}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.267.1">We introduce the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">Location</span></strong><span class="koboSpan" id="kobo.269.1"> value object with attributes that allow us to identify an address</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.270.1"> uniquely. </span><span class="koboSpan" id="kobo.270.2">That’s why we also have </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">latitude</span></strong><span class="koboSpan" id="kobo.272.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">longitude</span></strong><span class="koboSpan" id="kobo.274.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">class attributes.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.276.1">The value objects we just created are the most important ones because they are the basic building blocks for the other value objects and entities that comprise the entire system. </span><span class="koboSpan" id="kobo.276.2">Next, we can create more elaborate value objects based on those we just created, </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.278.1">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">IP</span></strong><span class="koboSpan" id="kobo.280.1"> value object, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
/** Code omitted **/
public class IP {
    private final String ipAddress;
    private final Protocol;
    public IP(String ipAddress){
      if(ipAddress == null)
          throw new IllegalArgumentException(
          "Null IP address");
         this.ipAddress = ipAddress;
      if(ipAddress.length()&lt;=15) {
          this.protocol = Protocol.IPV4;
      } else {
        this.protocol = Protocol.IPV6;
      }
    }
/** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.283.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">IP</span></strong><span class="koboSpan" id="kobo.285.1"> value object class, we can create both IPv4 and IPv6 addresses. </span><span class="koboSpan" id="kobo.285.2">The constraint that checks </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.286.1">which protocol to use is within the value object constructor. </span><span class="koboSpan" id="kobo.286.2">The logic we use to validate the IP address is a simple one, just for the sake of our example. </span><span class="koboSpan" id="kobo.286.3">For a more comprehensive validation, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">InetAddressValidator</span></strong><span class="koboSpan" id="kobo.288.1"> class from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">commons-validator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1"> library.</span></span></p></li> <li><span class="koboSpan" id="kobo.291.1">Then, we create a value object to represent networks that will be added to a switch, </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
package dev.davivieira.topologyinventory.domain.vo;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
@Builder
@Getter
@ToString
@EqualsAndHashCode
public class Network {
    private IP networkAddress;
    private String networkName;
    private int networkCidr;
    public Network(IP networkAddress,
    String networkName, int networkCidr){
        if(networkCidr &lt;1 || networkCidr&gt;32){
            throw new IllegalArgumentException(
            "Invalid CIDR value");
        }
        this.networkAddress = networkAddress;
        this.networkName = networkName;
        this.networkCidr = networkCidr;
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.294.1">We model the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Network</span></strong><span class="koboSpan" id="kobo.296.1"> value object to store the IP address, network name, and </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">Classless Inter-Domain Routing</span></strong><span class="koboSpan" id="kobo.298.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">CIDR</span></strong><span class="koboSpan" id="kobo.300.1">) attributes. </span><span class="koboSpan" id="kobo.300.2">CIDR is a network address notation composed of two numbers. </span><span class="koboSpan" id="kobo.300.3">The first number (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">10.0.0.0</span></strong><span class="koboSpan" id="kobo.302.1">) is the network base IP address. </span><span class="koboSpan" id="kobo.302.2">The second number (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">24</span></strong><span class="koboSpan" id="kobo.304.1">) is used to determine</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.305.1"> the network subnet mask and how many IP addresses will be available in this network. </span><span class="koboSpan" id="kobo.305.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">Network</span></strong><span class="koboSpan" id="kobo.307.1"> class, we refer to the second </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">CIDR number.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.309.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Network</span></strong><span class="koboSpan" id="kobo.311.1"> constructor, we add the constraint to validate whether the CIDR value </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">is valid.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.313.1">Finally, you’ll have a package and class structure similar to the one shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">following screenshot:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.315.1"><img alt="Figure 6.4 – The directory structure of the value objects" src="image/B19777_06_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.316.1">Figure 6.4 – The directory structure of the value objects</span></p>
<p><span class="koboSpan" id="kobo.317.1">Now that we have looked at value objects, which are our Domain hexagon’s building blocks, we can move on to creating entities and </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">their specifications.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.319.1">Defining entities and specifications</span></h1>
<p><span class="koboSpan" id="kobo.320.1">Once we have created all the value objects, we can start to think about how to represent the elements in entities that </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.321.1">have an identity. </span><span class="koboSpan" id="kobo.321.2">Also, we need to develop specifications to define business rules that govern constraints that the entities </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">should obey.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Remember that what </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.324.1">characterizes an entity is its identity and the presence of business rules and data. </span><span class="koboSpan" id="kobo.324.2">In the topology and inventory system, we have as entities </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Equipment</span></strong><span class="koboSpan" id="kobo.326.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Router</span></strong><span class="koboSpan" id="kobo.328.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">domain</span></strong><span class="koboSpan" id="kobo.334.1"> Java module we created previously, we’ll add the entity classes within a package </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">entity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.338.1">The Equipment and Router abstract entities</span></h2>
<p><span class="koboSpan" id="kobo.339.1">Routers and switches are different types of </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.340.1">network equipment, so we’ll start by creating an </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Equipment</span></strong><span class="koboSpan" id="kobo.342.1"> abstract class, </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">as</span></span><span class="No-Break"><a id="_idIndexMarker435"/></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1"> follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.345.1">
package dev.davivieira.topologyinventory.domain.entity;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Id;
import dev.davivieira.topologyinventory.domain.vo.Location;
import dev.davivieira.topologyinventory.domain.vo.Model;
import dev.davivieira.topologyinventory.domain.vo.Vendor;
import lombok.AllArgsConstructor;
import lombok.Getter;
@Getter
@AllArgsConstructor
public abstract sealed class Equipment
permits Router, Switch {
    protected Id id;
    protected Vendor vendor;
    protected Model model;
    protected IP ip;
    protected Location location;
    public static Predicate&lt;Equipment&gt;
    getVendorPredicate(Vendor vendor){
        return r -&gt; r.getVendor().equals(vendor);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.346.1">Most of the value objects created in the previous section are present here in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">Equipment</span></strong><span class="koboSpan" id="kobo.348.1"> entity. </span><span class="koboSpan" id="kobo.348.2">We use the </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.349.1">predicate provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">getVendorTypePredicate</span></strong><span class="koboSpan" id="kobo.351.1"> to apply the filters that only retrieve a </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.352.1">specific </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">vendor’s equipment.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">Deriving from </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">Equipment</span></strong><span class="koboSpan" id="kobo.356.1">, we create </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.357.1">a </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Router</span></strong><span class="koboSpan" id="kobo.359.1"> abstract class, </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
package dev.davivieira.topologyinventory.domain.entity;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Id;
import dev.davivieira.topologyinventory.domain.vo.Location;
import dev.davivieira.topologyinventory.domain.vo.Model;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.361.2">  vo.RouterType;
import dev.davivieira.topologyinventory.domain.vo.Vendor;
import lombok.Getter;
import java.util.function.Predicate;
@Getter
public abstract sealed class Router extends Equipment
permits CoreRouter, EdgeRouter {
    protected final RouterType routerType;
    public static Predicate&lt;Router&gt;
    getRouterTypePredicate(RouterType routerType){
        return r -&gt; r.getRouterType().equals(routerType);
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.362.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Router</span></strong><span class="koboSpan" id="kobo.364.1"> abstract class </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.365.1">defines predicates common to eith</span><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.366.1">er core or edge routers. </span><span class="koboSpan" id="kobo.366.2">We use the predicate </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.367.1">provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">getRouterTypePredicate</span></strong><span class="koboSpan" id="kobo.369.1"> to apply filters that retrieve only routers of a </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">specific type.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Here, we have more two predicates from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Router</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.373.1">abstract class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
public static Predicate&lt;Equipment&gt;
  getModelPredicate(Model model){
    return r -&gt; r.getModel().equals(model);
}
public static Predicate&lt;Equipment&gt;
  getCountryPredicate(Location location){
    return p -&gt;
     p.location.country().equals(location.country());
}</span></pre> <p><span class="koboSpan" id="kobo.375.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">getModelPredicate</span></strong><span class="koboSpan" id="kobo.377.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">getCountryPredicate</span></strong><span class="koboSpan" id="kobo.379.1"> predicates to retrieve routers of a specific model or </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">particular country.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Router</span></strong><span class="koboSpan" id="kobo.383.1"> abstract class</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.384.1"> provides the common attributes shared by core and edge routers. </span><span class="koboSpan" id="kobo.384.2">It’s in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Router</span></strong><span class="koboSpan" id="kobo.386.1"> class that we</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.387.1"> introduce the predicates to serve as filters when querying lists </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">of routers.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.389.1">The core router entity and its specifications</span></h2>
<p><span class="koboSpan" id="kobo.390.1">Moving ahead, let’s</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.391.1"> implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.393.1"> entity </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.394.1">class, </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
/** Imports omitted **/
public final class CoreRouter extends Router {
    /** Code omitted **/
    public Router addRouter(Router anyRouter){
        var sameCountryRouterSpec =
        new SameCountrySpec(this);
        var sameIpSpec =
        new SameIpSpec(this);
        sameCountryRouterSpec.check(anyRouter);
        sameIpSpec.check(anyRouter);
        return this.routers.put(anyRouter.id, anyRouter);
    }
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.397.1">Core routers can be connected to other core and edge routers. </span><span class="koboSpan" id="kobo.397.2">To allow such behavior in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.399.1"> class, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">addRouter</span></strong><span class="koboSpan" id="kobo.401.1"> method receiving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Router</span></strong><span class="koboSpan" id="kobo.403.1"> abstract type as a parameter. </span><span class="koboSpan" id="kobo.403.2">We also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.405.1"> specification to make sure that edge routers are in the same country as the core router. </span><span class="koboSpan" id="kobo.405.2">This rule doesn’t apply when we try to connect a core router to another </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">core router.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Next, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">SameIPSpec</span></strong><span class="koboSpan" id="kobo.409.1"> specification to confirm that routers don’t have the same IP address. </span><span class="koboSpan" id="kobo.409.2">We make the </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.410.1">business rules more explicit and the code easier to read and understand by using specifications. </span><span class="koboSpan" id="kobo.410.2">You can write this code without any specification and just throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">if</span></strong><span class="koboSpan" id="kobo.412.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">else</span></strong><span class="koboSpan" id="kobo.414.1"> conditions with the necessary variables, but the mental load required to understand the code for anyone not acquainted with it would probably </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">be higher.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Here, we have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">removeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
public Router removeRouter(Router anyRouter){
    var emptyRoutersSpec = new EmptyRouterSpec();
    var emptySwitchSpec = new EmptySwitchSpec();
    switch (anyRouter.routerType) {
        case CORE → {
            var coreRouter = (CoreRouter)anyRouter;
            emptyRoutersSpec.check(coreRouter);
        }
        case EDGE → {
            var edgeRouter = (EdgeRouter)anyRouter;
            emptySwitchSpec.check(edgeRouter);
        }
    }
    return this.routers.remove(anyRouter.id);
}</span></pre> <p><span class="koboSpan" id="kobo.420.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">removeRouter</span></strong><span class="koboSpan" id="kobo.422.1"> method, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">EmptyRouterSpec</span></strong><span class="koboSpan" id="kobo.424.1"> specification, which prevents us from removing a router that has any other routers connected to it. </span><span class="koboSpan" id="kobo.424.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">EmptySwitchSpec</span></strong><span class="koboSpan" id="kobo.426.1"> specification checks whether a router has any switch connected </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Core routers deal only with other routers. </span><span class="koboSpan" id="kobo.428.2">That’s why there is no reference to switches in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">CoreRouter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.430.1">entity class.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Note that the two methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">addRouter</span></strong><span class="koboSpan" id="kobo.433.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">removeRouter</span></strong><span class="koboSpan" id="kobo.435.1">, operate directly on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">Router</span></strong><span class="koboSpan" id="kobo.437.1"> type parameter, using domain specifications to check that there are no constraint violations before making any changes. </span><span class="koboSpan" id="kobo.437.2">Let’s closely examine the specifications used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.439.1"> entity, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.441.1"> specification. </span><span class="koboSpan" id="kobo.441.2">This specification makes sure</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.442.1"> that edge routers are always from the same country as their </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">core routers.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">package</span></strong><span class="koboSpan" id="kobo.446.1"> specification is where we’ll put all the specifications, so that’s the package in which we’ll put the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.448.1"> specification, </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.450.1">
/** Imports omitted **/
public final class SameCountrySpec extends AbstractSpecifi
  cation&lt;Equipment&gt; {
    private final Equipment equipment;
    public SameCountrySpec(Equipment equipment){
        this.equipment = equipment;
    }
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.451.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.453.1"> constructor</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.454.1"> receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">Equipment</span></strong><span class="koboSpan" id="kobo.456.1"> object, which we use to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">equipment</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.458.1">private field.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Continuing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.461.1"> implementation, we override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">isSatisfiedBy</span></strong><span class="koboSpan" id="kobo.463.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
@Override
public boolean isSatisfiedBy(Equipment anyEquipment) {
    if(anyEquipment instanceof CoreRouter) {
        return true;
    } else if (
    anyEquipment != null &amp;&amp; this.equipment != null) {
        return this
        .equipment
        .getLocation()
        .country()
        .equals(
           anyEquipment.getLocation().country());
    } else{
        return false;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.466.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.468.1"> implementation does not apply to core routers. </span><span class="koboSpan" id="kobo.468.2">That’s why we always return </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">true</span></strong><span class="koboSpan" id="kobo.470.1"> when the object is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.472.1"> entity. </span><span class="koboSpan" id="kobo.472.2">Otherwise, we proceed with the validation to check that the equipment is not in a </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">different country.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">Next, we override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">check</span></strong><span class="koboSpan" id="kobo.476.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.478.1">
@Override
public void check(Equipment equipment) {
    if(!isSatisfiedBy(equipment))
        throw new GenericSpecificationException(
        "The equipments should be in the same country");
}</span></pre> <p><span class="koboSpan" id="kobo.479.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">check</span></strong><span class="koboSpan" id="kobo.481.1"> method</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.482.1"> to run the specification. </span><span class="koboSpan" id="kobo.482.2">Other classes can call this method to verify whether the specification is met </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">It’s possible to connect two core routers from different countries. </span><span class="koboSpan" id="kobo.484.2">What’s not possible, as stated previously, is to connect edge and core routers that are not present in the same country. </span><span class="koboSpan" id="kobo.484.3">Note that this specification is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Equipment</span></strong><span class="koboSpan" id="kobo.486.1"> type, allowing us to reuse this specification not just with routers but also </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">on switches.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">The following </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">SameIpSpec</span></strong><span class="koboSpan" id="kobo.490.1"> specification ensures that no equipment has the same </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">IP address:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.492.1">
/** Imports omitted **/
public final class SameIpSpec extends AbstractSpecification
  &lt;Equipment&gt;{
    private final Equipment equipment;
    public SameIpSpec(Equipment equipment){
        this.equipment = equipment;
    }
    @Override
    public boolean isSatisfiedBy(Equipment anyEquipment) {
        return
       !equipment.getIp().equals(anyEquipment.getIp());
    }
    @Override
    public void check(Equipment equipment) {
        if(!isSatisfiedBy(equipment))
            throw new GenericSpecificationException("It's
              not possible to attach routers with the same
              IP");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.493.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.495.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">SameIpSpec</span></strong><span class="koboSpan" id="kobo.497.1"> specifications are used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">addRouter</span></strong><span class="koboSpan" id="kobo.499.1"> method to ensure that no constraints are violated before adding any router to a </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">core router.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">Moving on, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">EmptyRouterSpec</span></strong><span class="koboSpan" id="kobo.503.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">EmptySwitchSpec</span></strong><span class="koboSpan" id="kobo.505.1"> specifications. </span><span class="koboSpan" id="kobo.505.2">Before a router is removed, we</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.506.1"> must make sure that no other routers or switches are connected to such a router. </span><span class="koboSpan" id="kobo.506.2">These are very simple specifications. </span><span class="koboSpan" id="kobo.506.3">Let’s start by looking at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">EmptyRouterSpec</span></strong><span class="koboSpan" id="kobo.508.1"> specification, </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
/** Imports omitted **/
public final class EmptyRouterSpec extends AbstractSpecification
  &lt;CoreRouter&gt; {
    @Override
    public boolean isSatisfiedBy(CoreRouter coreRouter) {
        return coreRouter.getRouters()==null||
                coreRouter.getRouters().isEmpty();
    }
    @Override
    public void check(CoreRouter coreRouter) {
        if(!isSatisfiedBy(coreRouter))
            throw new GenericSpecificationException("It
              isn't allowed to remove a core router with
              other routers attached to it");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.511.1">This specification is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.513.1"> type because only core routers can be connected to other core and </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">edge routers.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">EmptySwitchSpec</span></strong><span class="koboSpan" id="kobo.517.1"> class</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.518.1"> is given </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
/** Imports omitted **/
public final class EmptySwitchSpec extends AbstractSpecification
  &lt;EdgeRouter&gt; {
    @Override
    public boolean isSatisfiedBy(EdgeRouter edgeRouter) {
        return edgeRouter.getSwitches()==null ||
                edgeRouter.getSwitches().isEmpty();
    }
    @Override
    public void check(EdgeRouter edgeRouter) {
        if(!isSatisfiedBy(edgeRouter))
            throw new GenericSpecificationException("It
              isn't allowed to remove an edge router with a
              switch attached to it");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.521.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">EmptySwitchSpec</span></strong><span class="koboSpan" id="kobo.523.1"> class is very similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">EmptyRouterSpec</span></strong><span class="koboSpan" id="kobo.525.1"> class. </span><span class="koboSpan" id="kobo.525.2">The difference, though, is that only edge routers can have switches. </span><span class="koboSpan" id="kobo.525.3">That’s why this specification is based</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.526.1"> on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">EdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.528.1"> type.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.529.1">Edge router entity and its specifications</span></h2>
<p><span class="koboSpan" id="kobo.530.1">Now that we’re done</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.531.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.533.1"> entity and its </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.534.1">specifications, we can move on to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.536.1"> entity class, </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
/** Imports omitted **/
public final class EdgeRouter extends Router {
    /**Code omitted **/
    private final Map&lt;Id, Switch&gt; switches;
    public void addSwitch(Switch anySwitch){
        var sameCountryRouterSpec =
        new SameCountrySpec(this);
        var sameIpSpec = new SameIpSpec(this);
        sameCountryRouterSpec.check(anySwitch);
        sameIpSpec.check(anySwitch);
        this.switches.put(anySwitch.id,anySwitch);
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.539.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">addSwitch</span></strong><span class="koboSpan" id="kobo.541.1"> method’s purpose is to connect switches to edge routers. </span><span class="koboSpan" id="kobo.541.2">Also, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.543.1"> class, we reuse the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.545.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">SameIpSpec</span></strong><span class="koboSpan" id="kobo.547.1"> specifications used when implementing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">CoreRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Next, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">removeSwitch</span></strong><span class="koboSpan" id="kobo.552.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.554.1"> class, as illustrated in the following </span><a id="_idIndexMarker454"/><span class="No-Break"><span class="koboSpan" id="kobo.555.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.556.1">
public Switch removeSwitch(Switch anySwitch){
    var emptyNetworkSpec = new EmptyNetworkSpec();
    emptyNetworkSpec.check(anySwitch);
    return this.switches.remove(anySwitch.id);
}</span></pre> <p><span class="koboSpan" id="kobo.557.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">removeSwitch</span></strong><span class="koboSpan" id="kobo.559.1"> method, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">EmptyNetworkSpec</span></strong><span class="koboSpan" id="kobo.561.1"> specification to ensure that a switch has no networks connected </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">As we did in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.565.1"> class, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">SameCountrySpec</span></strong><span class="koboSpan" id="kobo.567.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">SameIpSpec</span></strong><span class="koboSpan" id="kobo.569.1"> specifications. </span><span class="koboSpan" id="kobo.569.2">However, the context is different because we’re adding a switch to a router. </span><span class="koboSpan" id="kobo.569.3">The only new specification used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.571.1"> class is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">EmptyNetworkSpec</span></strong><span class="koboSpan" id="kobo.573.1"> specification, which is used to ensure all networks are removed from a switch before it can be removed from an </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">edge router.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.575.1">Switch entity and its specifications</span></h2>
<p><span class="koboSpan" id="kobo.576.1">What’s left now is</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.577.1"> the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Switch</span></strong><span class="koboSpan" id="kobo.579.1"> entity class and its </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.580.1">related specifications. </span><span class="koboSpan" id="kobo.580.2">The ideas we use here are similar to what we applied in core and edge router entities. </span><span class="koboSpan" id="kobo.580.3">Let’s start by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">Switch</span></strong><span class="koboSpan" id="kobo.582.1"> entity class, </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
/** Imports omitted **/
public final class Switch extends Equipment {
    private final SwitchType switchType;
    private final     List&lt;Network&gt; switchNetworks;
    /** Code omitted **/
    public static Predicate&lt;Switch&gt;getSwitchTypePredicate
      (SwitchType switchType){
        return s -&gt; s.switchType.equals(switchType);
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.585.1">We start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">Switch</span></strong><span class="koboSpan" id="kobo.587.1"> class</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.588.1"> implementation by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">getSwitchTypePredicate</span></strong><span class="koboSpan" id="kobo.590.1"> method predicate, which we used to filter switch collections by</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.591.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">switch type.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">Next, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">addNetwork</span><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.595.1">ToSwitch</span></strong><span class="koboSpan" id="kobo.596.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
public boolean addNetworkToSwitch(Network network) {
    var availabilitySpec =
    new NetworkAvailabilitySpec(network);
    var cidrSpec = new CIDRSpecification();
    var amountSpec = new NetworkAmountSpec();
    cidrSpec.check(network.getNetworkCidr());
    availabilitySpec.check(this);
    amountSpec.check(this);
    return this.switchNetworks.add(network);
}</span></pre> <p><span class="koboSpan" id="kobo.599.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.601.1"> method receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Network</span></strong><span class="koboSpan" id="kobo.603.1"> type parameter, which we use to add a network to a switch. </span><span class="koboSpan" id="kobo.603.2">However, before adding the network, we need to check some constraints expressed by the specifications. </span><span class="koboSpan" id="kobo.603.3">The first one is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">NetworkAvailabilitySpec</span></strong><span class="koboSpan" id="kobo.605.1"> specification, which verifies whether the network already exists on the switch. </span><span class="koboSpan" id="kobo.605.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">CIDRSpecification</span></strong><span class="koboSpan" id="kobo.607.1"> specification to check whether the network CIDR is</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.608.1"> valid. </span><span class="koboSpan" id="kobo.608.2">Finally, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">NetworkAmountSpec</span></strong><span class="koboSpan" id="kobo.610.1"> specification to validate whether we have surpassed the maximum networks allowed on </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">the switch.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">Next, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">removeNetworkFromSwitch</span></strong><span class="koboSpan" id="kobo.614.1"> method, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
public boolean removeNetworkFromSwitch(
  Network network){
    return this.switchNetworks.remove(network);
}</span></pre> <p><span class="koboSpan" id="kobo.617.1">As there are no constraints to </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.618.1">remove networks from a switch, this method does not use </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">any specifications.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">To summarize, right at the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">Switch</span></strong><span class="koboSpan" id="kobo.622.1"> class, we declared a predicate to allow us to filter switch collections based on switch types (</span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">LAYER2</span></strong><span class="koboSpan" id="kobo.624.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">LAYER3</span></strong><span class="koboSpan" id="kobo.626.1">). </span><span class="koboSpan" id="kobo.626.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">addNetworktoSwitch</span></strong><span class="koboSpan" id="kobo.628.1"> method uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">NetworkAvailabilitySpec</span></strong><span class="koboSpan" id="kobo.630.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">NetworkAmountSpec</span></strong><span class="koboSpan" id="kobo.632.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">CIDRSpecification</span></strong><span class="koboSpan" id="kobo.634.1"> specifications that we already defined in </span><a href="B19777_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.635.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.636.1">, </span><em class="italic"><span class="koboSpan" id="kobo.637.1">Wrapping Business Rules inside Domain Hexagon</span></em><span class="koboSpan" id="kobo.638.1">. </span><span class="koboSpan" id="kobo.638.2">If none of these specifications’ constraints are violated, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Network</span></strong><span class="koboSpan" id="kobo.640.1"> object will be added to </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">the switch.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">Finally, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">removeNetworkFromSwitch</span></strong><span class="koboSpan" id="kobo.644.1"> method, which doesn’t look at any specification to remove networks from </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">a switch.</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">Switch</span></strong><span class="koboSpan" id="kobo.648.1"> entity implementation, we conclude the modeling of the entities and specifications required to fulfill the topology and inventory </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">system’s purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">For all the entities, you should have a package and class structure similar </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">to this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.652.1"><img alt="Figure 6.5 – The directory structure of entities" src="image/B19777_06_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.653.1">Figure 6.5 – The directory structure of entities</span></p>
<p><span class="koboSpan" id="kobo.654.1">As we can see in</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.655.1"> the preceding screenshot, we put all the</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.656.1"> entities inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">entity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">And for all the specifications, the package and class structure should look </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.661.1"><img alt="Figure 6.6 – The directory structure of specifications" src="image/B19777_06_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.662.1">Figure 6.6 – The directory structure of specifications</span></p>
<p><span class="koboSpan" id="kobo.663.1">Some of the specifications </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.664.1">used by the topology and inventory system were already created in </span><a href="B19777_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.665.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.666.1">, </span><em class="italic"><span class="koboSpan" id="kobo.667.1">Wrapping Business Rules inside Domain Hexagon</span></em><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">The remaining specifications are the ones we created in </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Based on the entities we have just created, we can now think of tasks that are not directly related to such</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.671.1"> entities. </span><span class="koboSpan" id="kobo.671.2">That is the case of services that work as an alternative to providing capabilities outside domain entities. </span><span class="koboSpan" id="kobo.671.3">Let’s now see how to implement services that let us f</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.672.1">ind, filter, and retrieve data from </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">the system.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.674.1">Defining domain services</span></h1>
<p><span class="koboSpan" id="kobo.675.1">The topology and inventory system is about the visualization and management of network assets, so we need to enable a user to handle collections of such network assets. </span><span class="koboSpan" id="kobo.675.2">One way to do that</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.676.1"> is through services. </span><span class="koboSpan" id="kobo.676.2">With services, we can define behaviors to deal with system entities and </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">value objects.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">All the services that we’ll create in this section reside in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.680.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">Let’s start by creating a service</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.682.1"> to deal with collections </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">of routers.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.684.1">Router service</span></h2>
<p><span class="koboSpan" id="kobo.685.1">In the previous section, when</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.686.1"> implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">Router</span></strong><span class="koboSpan" id="kobo.688.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.690.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.692.1"> entities, we also created some methods to return predicates to aid us in filtering </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.693.1">collections of routers. </span><span class="koboSpan" id="kobo.693.2">With a domain service, we can use these predicates to filter such collections, </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
package dev.davivieira.topologyinventory.domain.service;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.695.2">  entity.Equipment;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.695.3">  entity.Router;
import dev.davivieira.topologyinventory.domain.vo.Id;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.stream.Collectors;
public class RouterService {
    public static List&lt;Router&gt;
    filterAndRetrieveRouter(List&lt;Router&gt; routers,
    Predicate&lt;Equipment&gt; routerPredicate){
        return routers
                .stream()
                .filter(routerPredicate)
                .collect(Collectors.&lt;Router&gt;toList());
    }
    public static Router findById(
    Map&lt;Id,Router&gt; routers, Id id){
        return routers.get(id);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.696.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">filterAndRetrieveRouter</span></strong><span class="koboSpan" id="kobo.698.1"> method, we pass a list of routers and a predicate, to filter the list, as</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.699.1"> parameters. </span><span class="koboSpan" id="kobo.699.2">Then, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">findById</span></strong><span class="koboSpan" id="kobo.701.1"> method to retrieve a router, using an </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">Id</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.703.1">type parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">Now, let’s see the service operations we can use to </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">handle switches.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.706.1">Switch service</span></h2>
<p><span class="koboSpan" id="kobo.707.1">This service follows the</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.708.1"> same idea we applied to the router service. </span><span class="koboSpan" id="kobo.708.2">It’s primarily based on the predicate provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">getSwitchTypePredicate</span></strong><span class="koboSpan" id="kobo.710.1"> method to filter collections </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.711.1">of switches based on their type. </span><span class="koboSpan" id="kobo.711.2">As new predicates arise, we can use them as new criteria to filter switch collections. </span><span class="koboSpan" id="kobo.711.3">Also, note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">findById</span></strong><span class="koboSpan" id="kobo.713.1"> method is used again to allow switch retrieval based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">Id</span></strong><span class="koboSpan" id="kobo.715.1"> type parameter. </span><span class="koboSpan" id="kobo.715.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.717.1">
package dev.davivieira.topologyinventory.domain.service;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.717.2">  entity.Switch;
import dev.davivieira.topologyinventory.domain.vo.Id;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.stream.Collectors;
public class SwitchService {
    public static List&lt;Switch&gt; filterAndRetrieveSwitch
      (List&lt;Switch&gt;   switches, Predicate&lt;Switch&gt;
       switchPredicate){
     return switches
                .stream()
                .filter(switchPredicate)
                .collect(Collectors.&lt;Switch&gt;toList());
    }
    public static Switch findById(Map&lt;Id,Switch&gt; switches,
      Id id){
     return switches.get(id);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.718.1">Although we don’t </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.719.1">model the network as entities in the domain model, there is no issue in creating service classes to handle collections of network </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">value objects.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">Let’s create a last service class for the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">inventory system.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.723.1">Network service</span></h2>
<p><span class="koboSpan" id="kobo.724.1">This service is based </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.725.1">primarily on a need to filter network collections based on the IP protocol. </span><span class="koboSpan" id="kobo.725.2">We can have collections of both IPv4 and IPv6 networks. </span><span class="koboSpan" id="kobo.725.3">This service provides the</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.726.1"> capacity to filter such collections based on the network IP protocol. </span><span class="koboSpan" id="kobo.726.2">The following code is used to create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">NetworkService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.729.1">
package dev.davivieira.topologyinventory.domain.service;
import dev.davivieira.topologyinventory.domain.vo.Network;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;
public class NetworkService {
    public static List&lt;Network&gt; filterAndRetrieveNetworks
      (List&lt;Network&gt; networks, Predicate&lt;Network&gt;
       networkPredicate){
        return networks
                .stream()
                .filter(networkPredicate)
                .collect(Collectors.&lt;Network&gt;toList());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.730.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">filterAndRetrieveNetworks</span></strong><span class="koboSpan" id="kobo.732.1"> method receives a list of networks and a predicate, to filter the list, as parameters. </span><span class="koboSpan" id="kobo.732.2">It returns a filtered list </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">of networks.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">NetworkService</span></strong><span class="koboSpan" id="kobo.736.1">, we conclude creating </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">domain services.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">After creating all these services, you’ll have a package and class structure like the one </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.740.1"><img alt="Figure 6.7 – The directory structure of domain services" src="image/B19777_06_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.741.1">Figure 6.7 – The directory structure of domain services</span></p>
<p><span class="koboSpan" id="kobo.742.1">To drive the development</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.743.1"> of value objects, entities, specifications, and services, you can adopt a </span><strong class="bold"><span class="koboSpan" id="kobo.744.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.745.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.746.1">TDD</span></strong><span class="koboSpan" id="kobo.747.1">) approach, where you can start creating </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.748.1">broken tests and then implement the correct classes and methods to make those tests pass. </span><span class="koboSpan" id="kobo.748.2">We did the contrary here to provide a big picture of the components we needed to create to build the Domain hexagon for the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">inventory system.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">In this section, we created services that operate under the Domain hexagon level. </span><span class="koboSpan" id="kobo.750.2">Instead of putting more behaviors directly on entities, we created separate service classes to enable behaviors that we don’t consider inherently part of the entities. </span><span class="koboSpan" id="kobo.750.3">These services allow us to handle collections of routers, switches, </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">and networks.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">Before we move on to the development of the Application hexagon, we need to ensure the operations we created in the Domain hexagon work as expected; otherwise, the upstream hexagons will break when performing these operations. </span><span class="koboSpan" id="kobo.752.2">So, in the next section, we’ll see how to test the </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">Domain hexagon.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.754.1">Testing the Domain hexagon</span></h1>
<p><span class="koboSpan" id="kobo.755.1">To test the Domain hexagon appropriately, we should rely only on its components, ignoring anything </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.756.1">coming from other hexagons. </span><span class="koboSpan" id="kobo.756.2">After all, these hexagons should depend on the Domain hexagon and not the other way around. </span><span class="koboSpan" id="kobo.756.3">As we have already seen, the Domain hexagon concentrates on the core system logic. </span><span class="koboSpan" id="kobo.756.4">It is from that logic that we derive the structure and behavior of the Application and Framework hexagons. </span><span class="koboSpan" id="kobo.756.5">By building a robust and well-tested Domain hexagon, we build a solid foundation for the </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">entire system.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">Among the operations performed by the topology and inventory system, we can consider adding, removing, and searching network assets as the most important ones. </span><span class="koboSpan" id="kobo.758.2">We’ll use the following steps to test </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">these operations:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.760.1">Let’s start by seeing how we can test the addition of network equipment, </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.762.1">
@Test
public void addNetworkToSwitch(){
    var location = createLocation("US");
    var newNetwork = createTestNetwork("30.0.0.1", 8);
    var networkSwitch =
    createSwitch("30.0.0.0", 8, location);
    assertTrue(
    networkSwitch.addNetworkToSwitch(newNetwork));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.763.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.765.1"> method checks the successful path when the system can add a network to a switch. </span><span class="koboSpan" id="kobo.765.2">The following test checks the unhappy path </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">for this:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.767.1">@Test
public void
addNetworkToSwitch_failBecauseSameNetworkAddress(){
    var location = createLocation("US");
    var newNetwork = createTestNetwork("30.0.0.0", 8);
    var networkSwitch = createSwitch(
    "30.0.0.0", 8, location);
    assertThrows(GenericSpecificationException.class,
      () -&gt;
      networkSwitch.addNetworkToSwitch(newNetwork));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.768.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">addNetworkToSwitch_failBecauseSameNetworkAddress</span></strong><span class="koboSpan" id="kobo.770.1"> method checks the</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.771.1"> unsuccessful path when we try to add a network that already exists in </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">the switch.</span></span></p></li> <li><span class="koboSpan" id="kobo.773.1">Then, we have test scenarios where we want to add a switch to an edge router, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.775.1">
@Test
public void addSwitchToEdgeRouter(){
    edgeRouter.addSwitch(networkSwitch);
    assertEquals(1,edgeRouter.getSwitches().size());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.776.1">We added a switch to an edge router with no switches attached; such an edge router should have exactly one switch attached to it. </span><span class="koboSpan" id="kobo.776.2">The following code snippet has the unhappy path for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">addSwitchToEdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.778.1"> method:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.779.1">@Test
public void addSwitchToEdgeRouter
  _failBecauseEquipmentOfDifferentCountries(){
    var locationUS = createLocation("US");
    var locationJP = createLocation("JP");
    var networkSwitch =
    createSwitch("30.0.0.0", 8, locationUS);
    var edgeRouter =
    createEdgeRouter(locationJP,"30.0.0.1");
    assertThrows(GenericSpecificationException.class,
    () -&gt; edgeRouter.addSwitch(networkSwitch));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.780.1">When we try to add a </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.781.1">switch that is for a different country than the edge router, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">addSwitchToEdgeRouter</span></strong><span class="koboSpan" id="kobo.783.1"> method checks the successful path while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">addSwitchToEdgeRouter_failBecauseEquipmentOfDifferentCountries</span></strong><span class="koboSpan" id="kobo.785.1"> method checks the </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">unsuccessful one.</span></span></p></li> <li><span class="koboSpan" id="kobo.787.1">Then, we have test scenarios where we want to add an edge router to a core router, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.789.1">
@Test
public void addEdgeToCoreRouter(){
    coreRouter.addRouter(edgeRouter);
    assertEquals(1,coreRouter.getRouters().size());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.790.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">addEdgeToCoreRouter</span></strong><span class="koboSpan" id="kobo.792.1"> method checks the successful path when we try to add an edge router that is for a different country than the core router. </span><span class="koboSpan" id="kobo.792.2">The next code snippet has the unhappy path for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">addEdgeToCoreRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.794.1"> method:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.795.1">@Test
public void addEdgeToCoreRouter
  _failBecauseRoutersOfDifferentCountries(){
    var locationUS = createLocation("US");
    var locationJP = createLocation("JP");
    var edgeRouter =
    createEdgeRouter(locationUS,"30.0.0.1");
    var coreRouter =
    createCoreRouter(locationJP, "40.0.0.1");
    assertThrows(GenericSpecificationException.class,
    () -&gt; coreRouter.addRouter(edgeRouter));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.796.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">addEdgeToCoreRouter_failBecauseRoutersOfDifferentCountries</span></strong><span class="koboSpan" id="kobo.798.1"> method checks the unsuccessful path when the edge and core routers are in </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">different countries.</span></span></p></li> <li><span class="koboSpan" id="kobo.800.1">Then, we have test</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.801.1"> scenarios where we want to add a core router to another core router, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.803.1">
@Test
public void addCoreToCoreRouter(){
    coreRouter.addRouter(newCoreRouter);
    assertEquals(2,coreRouter.getRouters().size());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.804.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">addCoreToCoreRouter</span></strong><span class="koboSpan" id="kobo.806.1"> method checks the successful path when we can add a core router to another one. </span><span class="koboSpan" id="kobo.806.2">In the following code snippet, we have the unhappy path for </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">this method:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.808.1">@Test
public void addCoreToCoreRouter
  _failBecauseRoutersOfSameIp(){
    var location = createLocation("US");
    var coreRouter = createCoreRouter(
    location, "30.0.0.1");
    var newCoreRouter = createCoreRouter(
    location, "30.0.0.1");
    assertThrows(GenericSpecificationException.class,
    () -&gt; coreRouter.addRouter(newCoreRouter));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.809.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">addCoreToCoreRouter_failBecauseRoutersOfSameIp</span></strong><span class="koboSpan" id="kobo.811.1"> method checks the unsuccessful</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.812.1"> path when we try to add core routers with the same </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">IP address.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.814.1">With these tests, we can also check whether the specifications work </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">as expected.</span></span></p></li> <li><span class="koboSpan" id="kobo.816.1">Then, there are other scenarios where it’s necessary to remove any router from a core router, a switch from an edge router, and a network from a switch, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.818.1">
@Test
public void removeRouter(){
    var location = createLocation("US");
    var coreRouter = createCoreRouter(
    location, "30.0.0.1");
    var edgeRouter = createEdgeRouter(
    location, "40.0.0.1");
    var expectedId = edgeRouter.getId();
    coreRouter.addRouter(edgeRouter);
    var actualId =
    coreRouter.removeRouter(edgeRouter).getId();
    assertEquals(expectedId, actualId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.819.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">removeRouter</span></strong><span class="koboSpan" id="kobo.821.1"> test method checks whether we can remove an edge router from a core router. </span><span class="koboSpan" id="kobo.821.2">In the</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.822.1"> following code snippet, we test the removal with </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">a switch:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.824.1">@Test
public void removeSwitch(){
    var location = createLocation("US");
    var network = createTestNetwork("30.0.0.0", 8);
    var networkSwitch =
    createSwitch("30.0.0.0", 8, location);
    var edgeRouter = createEdgeRouter(
    location, "40.0.0.1");
    edgeRouter.addSwitch(networkSwitch);
    networkSwitch.removeNetworkFromSwitch(network);
    var expectedId =
    Id.withId(
    "f8c3de3d-1fea-4d7c-a8b0-29f63c4c3490");
    var actualId=
    edgeRouter.removeSwitch(networkSwitch).getId();
    assertEquals(expectedId, actualId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.825.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">removeSwitch</span></strong><span class="koboSpan" id="kobo.827.1"> test method checks whether we can remove a switch from an edge router. </span><span class="koboSpan" id="kobo.827.2">In the following </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.828.1">code snippet, we test removal with </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">a network:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.830.1">@Test
public void removeNetwork(){
    var location = createLocation("US");
    var network = createTestNetwork("30.0.0.0", 8);
    var networkSwitch =
    createSwitch("30.0.0.0", 8, location);
    assertEquals(
    1, networkSwitch.getSwitchNetworks().size());
    assertTrue(
    networkSwitch.removeNetworkFromSwitch(network));
    assertEquals(
    0, networkSwitch.getSwitchNetworks().size());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.831.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">removeNetwork</span><a id="_idTextAnchor145"/></strong><span class="koboSpan" id="kobo.833.1"> test method checks whether we can remove a network from </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">a switch.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.835.1">After the adding and removing operations, we have to test the filter and </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">retrieve operations.</span></span></p></li> <li><span class="koboSpan" id="kobo.837.1">To filter routers by type, we</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.838.1"> implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">following test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.840.1">
@Test
public void filterRouterByType(){
    List&lt;Router&gt; routers = new ArrayList&lt;&gt;();
    var location = createLocation("US");
    var coreRouter = createCoreRouter(
    location, "30.0.0.1");
    var edgeRouter = createEdgeRouter(
    location, "40.0.0.1");
    routers.add(coreRouter);
    routers.add(edgeRouter);
    var coreRouters =
    RouterService.filterAndRetrieveRouter(routers,
    Router.getRouterTypePredicate(RouterType.CORE));
    var actualCoreType =
    coreRouters.get(0).getRouterType();
    assertEquals(RouterType.CORE, actualCoreType);
    var edgeRouters =
    RouterService.filterAndRetrieveRouter(routers,
    Router.getRouterTypePredicate(RouterType.EDGE));
    var actualEdgeType =
    edgeRouters.get(0).getRouterType();
    assertEquals(RouterType.EDGE, actualEdgeType);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.841.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">filterRouterByType</span></strong><span class="koboSpan" id="kobo.843.1"> method tests the operations available on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">RouterService</span></strong><span class="koboSpan" id="kobo.845.1"> class. </span><span class="koboSpan" id="kobo.845.2">In the preceding case, we check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">filterAndRetrieveRouter</span></strong><span class="koboSpan" id="kobo.847.1"> method can really filter and retrieve </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">CORE</span></strong> <a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.849.1">or </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">EDGE</span></strong><span class="koboSpan" id="kobo.851.1"> routers from a list</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.852.1"> containing different types </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">of routers.</span></span></p></li> <li><span class="koboSpan" id="kobo.854.1">To filter routers by vendor, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">following test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.856.1">
@Test
public void filterRouterByVendor(){
    List&lt;Router&gt; routers = new ArrayList&lt;&gt;();
    var location = createLocation("US");
    var coreRouter = createCoreRouter(
    location, "30.0.0.1");
    var edgeRouter = createEdgeRouter(
    location, "40.0.0.1");
    routers.add(coreRouter);
    routers.add(edgeRouter);
    var actualVendor =
    RouterService.
</span><span class="koboSpan" id="kobo.856.2">      filterAndRetrieveRouter(routers,
    Router.getVendorPredicate(
    Vendor.HP)).get(0).getVendor();
    assertEquals(Vendor.HP, actualVendor);
    actualVendor =
    RouterService.filterAndRetrieveRouter(routers,
    Router.getVendorPredicate(
    Vendor.CISCO)).get(0).getVendor();
    assertEquals(Vendor.CISCO, actualVendor);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.857.1">By using a predicate provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">getVendorPredicate</span></strong><span class="koboSpan" id="kobo.859.1"> method, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">filterAndRetrieveRouter</span></strong><span class="koboSpan" id="kobo.861.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">RouterService</span></strong><span class="koboSpan" id="kobo.863.1"> class. </span><span class="koboSpan" id="kobo.863.2">Then, we check whether the</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.864.1"> retrieved router model is what we are </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">looking for.</span></span></p></li> <li><span class="koboSpan" id="kobo.866.1">Next, we test the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">filterRouterByLocation</span></strong><span class="koboSpan" id="kobo.868.1"> method but with a different predicate, </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.870.1">
@Test
public void filterRouterByLocation(){
    List&lt;Router&gt; routers = new ArrayList&lt;&gt;();
    var location = createLocation("US");
    var coreRouter = createCoreRouter(
    location, "30.0.0.1");
    routers.add(coreRouter);
    var actualCountry =
    RouterService.filterAndRetrieveRouter(routers,
    Router.getCountryPredicate(
    location)).get(0).getLocation().getCountry();
    assertEquals(
    location.getCountry(), actualCountry);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.871.1">By calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">getCountryPredicate</span></strong><span class="koboSpan" id="kobo.873.1"> method, we receive the predicate to filter routers by country. </span><span class="koboSpan" id="kobo.873.2">The result of this method is stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">actualCountry</span></strong><span class="koboSpan" id="kobo.875.1"> variable, which</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.876.1"> we use in the </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">test assertion.</span></span></p></li> <li><span class="koboSpan" id="kobo.878.1">Next, we test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">filterRouterByModel</span></strong><span class="koboSpan" id="kobo.880.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.882.1">
@Test
public void filterRouterByModel(){
    List&lt;Router&gt; routers = new ArrayList&lt;&gt;();
    var location = createLocation("US");
    var coreRouter = createCoreRouter(
    location, "30.0.0.1");
    var newCoreRouter = createCoreRouter(
    location, "40.0.0.1");
    coreRouter.addRouter(newCoreRouter);
    routers.add(coreRouter);
    var actualModel=
    RouterService.filterAndRetrieveRouter(routers,
    Router.getModelPredicate(
    Model.XYZ0001)).get(0).getModel();
    assertEquals(Model.XYZ0001, actualModel);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.883.1">The goal here is to confirm whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">filterAndRetrieveRouter</span></strong><span class="koboSpan" id="kobo.885.1"> method works as expected </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.886.1">when we need to filter router lists based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">router model.</span></span></p></li> <li><span class="koboSpan" id="kobo.888.1">Here, we have a test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">filterAndRetrieveSwitch</span></strong><span class="koboSpan" id="kobo.890.1"> method from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">SwitchService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.892.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.893.1">
@Test
public void filterSwitchByType(){
    List&lt;Switch&gt; switches = new ArrayList&lt;&gt;();
    var location = createLocation("US");
    var networkSwitch = createSwitch(
    "30.0.0.0", 8, location);
    switches.add(networkSwitch);
    var actualSwitchType =
    SwitchService.filterAndRetrieveSwitch(switches,
    Switch.getSwitchTypePredicate(
    SwitchType.LAYER3)).get(0).getSwitchType();
    assertEquals(
    SwitchType.LAYER3, actualSwitchType);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.894.1">The goal here is to check whether it is possible to filter switch lists using the predicate provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">getSwitchTypePredicate</span></strong><span class="koboSpan" id="kobo.896.1"> method. </span><span class="koboSpan" id="kobo.896.2">This is the predicate we use to filter </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.897.1">switch lists by type. </span><span class="koboSpan" id="kobo.897.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">assertEquals</span></strong><span class="koboSpan" id="kobo.899.1"> method checks whether the expected switch type matches what </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">we expect.</span></span></p></li> <li><span class="koboSpan" id="kobo.901.1">Then, we test the operations to retrieve routers and switches by using their IDs, </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.903.1">
@Test
public void findRouterById() {
    List&lt;Router&gt; routers = new ArrayList&lt;&gt;();
    Map&lt;Id, Router&gt; routersOfCoreRouter =
    new HashMap&lt;&gt;();
    var location = createLocation("US");
    var coreRouter = createCoreRouter(
    location, "30.0.0.1");
    var newCoreRouter = createCoreRouter(
    location, "40.0.0.1");
    coreRouter.addRouter(newCoreRouter);
    routersOfCoreRouter.put(
    newCoreRouter.getId(), newCoreRouter);
    var expectedId = newCoreRouter.getId();
    var actualId =
    RouterService.findById(
    routersOfCoreRouter, expectedId).getId();
    assertEquals(expectedId, actualId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.904.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">findRouterById</span></strong><span class="koboSpan" id="kobo.906.1">, we test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">findById</span></strong><span class="koboSpan" id="kobo.908.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">RouterService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.912.1">Finall</span><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.913.1">y, we</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.914.1"> implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">findSwitchById</span></strong><span class="koboSpan" id="kobo.916.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.918.1">
@Test
public void findSwitchById(){
    List&lt;Switch&gt; switches = new ArrayList&lt;&gt;();
    Map&lt;Id, Switch&gt; switchesOfEdgeRouter =
    new HashMap&lt;&gt;();
    var location = createLocation("US");
    var networkSwitch = createSwitch(
    "30.0.0.0", 8, location);
    switchesOfEdgeRouter.put(
    networkSwitch.getId(), networkSwitch);
    var expectedId =
    Id.withId("f8c3de3d-1fea-4d7c-a8b0-29f63c4c3490");
    var actualId =
    SwitchService.findById(
    switchesOfEdgeRouter, expectedId).getId();
    assertEquals(expectedId, actualId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.919.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">findSwitchById</span></strong><span class="koboSpan" id="kobo.921.1">, we test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">findById</span></strong><span class="koboSpan" id="kobo.923.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">SwitchService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.927.1">After implementing and executing</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.928.1"> these tests, you should see the following output, showing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">19</span></strong><span class="koboSpan" id="kobo.930.1"> tests were </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">executed successfully:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.932.1">
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running dev.davivieira.topologyinventory.domain.DomainTest
[INFO] Tests run: 19, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.04 s - in dev.daviv</span><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.933.1">ieira.topologyinventory.domain.DomainTest
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 19, Failures: 0, Errors: 0, Skipped: 0</span></pre> <p><span class="koboSpan" id="kobo.934.1">The successful execution of these tests assures us that the most fundamental operations from the Domain hexagon work </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">That’s the green light we need to move ahead and start the development of the </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">Application hexagon.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.938.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.939.1">Based on the topology and inventory system we developed in previous chapters, this chapter provided a hands-on approach to the early steps of developing a hexagonal system. </span><span class="koboSpan" id="kobo.939.2">We started by bootstrapping the Domain hexagon as a modularized Maven project and using </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">the JPMS.</span></span></p>
<p><span class="koboSpan" id="kobo.941.1">We briefly analyzed and understood the problem domain as it relates to the management of network assets. </span><span class="koboSpan" id="kobo.941.2">Then, we translated the problem domain into a domain model based on value objects, entities, specifications, and services. </span><span class="koboSpan" id="kobo.941.3">Finally, we tested everything we’ve done to ensure things won’t break when we start to develop the Application hexagon on top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">Domain one.</span></span></p>
<p><span class="koboSpan" id="kobo.943.1">By learning how to develop a robust Domain hexagon, we lay a solid foundation that the Application and Framework hexagons can rely on. </span><span class="koboSpan" id="kobo.943.2">In the next chapter, we will learn how to build the Application hexagon by assembling the useful features and everything else we’ve created on the </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">Domain hexagon.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.945.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.946.1">Which technologies are used to bootstrap the Domain hexagon as a </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">modularized application?</span></span></li>
<li><span class="koboSpan" id="kobo.948.1">Why did we start developing the Domain hexagon by creating value </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">objects first?</span></span></li>
<li><span class="koboSpan" id="kobo.950.1">Once we understand the problem domain, what’s the </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">next step?</span></span></li>
<li><span class="koboSpan" id="kobo.952.1">Why is it so important to develop a robust and well-tested </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">Domain hexagon?</span></span></li>
</ol>
<h1 id="_idParaDest-117"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.954.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.955.1">Maven and </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">the JPMS.</span></span></li>
<li><span class="koboSpan" id="kobo.957.1">Because value objects are used to compose other value objects </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">and entities.</span></span></li>
<li><span class="koboSpan" id="kobo.959.1">We need to translate that problem domain into a </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">domain model.</span></span></li>
<li><span class="koboSpan" id="kobo.961.1">Because a robust Domain hexagon provides a solid foundation to develop the Application and </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">Framework hexagons.</span></span></li>
</ol>
</div>
</body></html>