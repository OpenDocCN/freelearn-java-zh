- en: Chapter 7. Macros in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will get to know one of Clojure''s most complicated facilities:
    macros. We will learn what they are for, how to write them, and how to use them.
    It can be a little challenging, but there is good news too. You should be aware
    of some tools from your knowledge of the Java language that can help you understand
    macros better. We will progress little by little with comparisons to other JVM
    languages, and in the end, we will write some macros and understand that we have
    been using them for a while.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Lisp's foundational ideas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros as code modification tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying code in Groovy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your first macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros in the real world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp's foundational ideas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lisp is a very different beast from what you used to know. According to Paul
    Graham, there are nine ideas that make Lisp different (these ideas have existed
    since the late 1950s), and they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals (remember, we are talking 1950s–1960s)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions as first-class citizens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic typing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programs as sequences of expressions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The symbol type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lisp's syntax
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The whole language is there all the time: at compilation, runtime—always!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you can, read Paul Graham's essay *Revenge of the Nerds* ([http://www.paulgraham.com/icad.html](http://www.paulgraham.com/icad.html)),
    where he talks about Lisp, what makes it different, and why the language is important.
  prefs: []
  type: TYPE_NORMAL
- en: These ideas have thrived even after the Lisp age; most of them are common nowadays
    (can you imagine a language without conditionals?). But the last couple of ideas
    are what makes us Lisp lovers love the syntax (we will fully understand what they
    mean through this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Common languages are trying to achieve the very same things now with a slightly
    different approach, and you, as a Java developer, have probably seen this.
  prefs: []
  type: TYPE_NORMAL
- en: Macros as code modification tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first and most common uses of macros is to be able to modify code;
    they work on the code level, as you will see. Why should we do that? Let's try
    to understand the problem with something that you are more familiar with—Java.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying code in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever used AspectJ or Spring AOP? Have you ever had problems with tools
    such as ASM or Javassist?
  prefs: []
  type: TYPE_NORMAL
- en: You have probably used code modification in Java. It is common in Java EE applications,
    just not explicit. (Have you ever thought about what the `@Transactional` annotation
    does in Java EE or Spring applications?)
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we try to automate everything we can, so how could we leave out
    our own devtools?
  prefs: []
  type: TYPE_NORMAL
- en: We have tried to create ways to modify the bytecode at runtime so that we don't
    have to remember to open and close resources, or so that we can decouple dependencies
    and get dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Spring, you probably know about the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Transactional` annotation modifies the annotated method to ensure that
    your code is wrapped in a database transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Autowired` annotation looks for the required bean and injects it into
    the annotated property or method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Value` annotation looks for a configuration value and then injects it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could probably think of several other annotations that modify the way your
    classes work.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing here is that you understand why we want to modify code,
    and you probably already know a few mechanisms for doing it, including AspectJ
    and Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how it is done in the Java world; this is what an aspect
    in Java looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Aspects have the advantage that you can modify any code you like without having
    to touch it. This also has its drawbacks since you could modify the code in ways
    the original author didn't expect and thus cause bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback is that you have an extremely limited field of action; you
    can wrap your modifications around some code or execute something before or after.
  prefs: []
  type: TYPE_NORMAL
- en: The libraries that generate this code are extremely complex and they can either
    create a proxy around your objects or modify the bytecode, at runtime or compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, there are lots of things that you must be aware of, and
    anything could go wrong. Hence, debugging could prove complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying code in Groovy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Groovy has gone further down the road and it provides us with more solutions
    and more macro-like features.
  prefs: []
  type: TYPE_NORMAL
- en: Since Groovy 1.8, we have got a lot of AST transformations. What does AST stand
    for? It stands for **abstract syntax tree**—sounds complicated, right?
  prefs: []
  type: TYPE_NORMAL
- en: Before explaining it all, let's check what some of them do.
  prefs: []
  type: TYPE_NORMAL
- en: The @ToString annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@ToString` annotation generates a simple `toString` method that includes
    information about the class of the object and the value of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: The @TupleConstructor annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@TupleConstructor` creates a constructor that is able to take all of the
    values of your class at once. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The @Slf4j annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Slf4j` annotation adds an instance of a logger, called log by default,
    to your class, so you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This can be done without having to manually declare the log instance, the class
    name, and so on. There are lots of other things that you can do with this type
    of annotation, but how do they work?
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is AST and what does it have to do with Clojure macros? Come to think
    of it, it actually has a lot to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: To answer that last question, you'll have to understand a little bit about how
    compilers work.
  prefs: []
  type: TYPE_NORMAL
- en: We all know that machines (your machine, the JVM, the Erlang BEAM machine) are
    not capable of understanding human code, so we need a process to convert whatever
    developers write into what machines understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important steps of the process is to create a syntax tree,
    something similar to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The @Slf4j annotation](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a very simple example of the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This tree is what we call the abstract syntax tree. Let''s see the tree of
    something that''s a bit more complicated, such as this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the tree will look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The @Slf4j annotation](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the figure is still pretty straightforward, and you can probably
    understand how someone would execute code from a structure like this one.
  prefs: []
  type: TYPE_NORMAL
- en: Groovy's AST transformation is a way to meddle with such generated code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this is a much more powerful approach, but you are now messing
    with what the compiler generated; the probable downside to this is the complexity
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check, for instance, the code of the `@Slf4j` AST. It should be pretty
    simple, right? It just adds a log property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can check the complete code at [https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java](https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java),
    and it's also included with the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't look simple at all. It is just a fragment and still looks very
    complicated. What happens here is that you have to deal with the Java bytecode
    format and with compiler complications.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should remember point number 8that Paul Graham made about the syntax
    of Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our last code example in Clojure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s something peculiar about this piece of code: it feels very similar
    to the AST! This is not a coincidence. Actually, in Clojure and Lisp, you are
    directly writing the AST. This is one of the features that make Lisp a very simple
    language; you directly write what the computer understands. This might help you
    understand a little more about why code is data and data is code.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if you could modify the AST the same way that you modify any other data
    structure in your programs. But you can, and that's what macros are for!
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a clear understanding of how macros work and what they are
    for, let's start working with Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me present you with a challenge: write an `unless` function in Clojure,
    something that works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give it a first try; maybe with something like the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you know what would happen if you wrote this code and then ran it? If you
    test it, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here? Let''s modify it a bit so that we get a value and we
    can understand what''s happening. Let''s define it a bit differently, and let''s
    return a value so that we see something different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What's going on here?
  prefs: []
  type: TYPE_NORMAL
- en: When you pass parameters to a function, everything is evaluated before the actual
    code of the function runs, so over here, before the body of your function runs,
    you execute both of the `println` methods. After that, the `if` runs correctly
    and you get `:bigger`, but we still got an output for the positive and negative
    cases of our `if`. It looks like our code is not working!
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we fix this? With our current tools, we probably need to write closures
    and change the `my-if` code to accept functions as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but there are several disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of constraints now for the code (both clauses should now be
    functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't work for every single case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very complicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to solve this problem, Clojure gives us macros. Let''s have a look
    at how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is great! It works, but what just happened? Why did we just use a macro
    and why did it work?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Macros are not normal Clojure functions; they are supposed to generate code
    and should return a Clojure form. This means that they should return a list that
    we can use as normal Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros return code that will be executed later. And here is where point number
    nine of Paul Graham''s list comes into play: you have all of the language all
    the time.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++, you have a mechanism called a macro; when you use it, you have a very
    limited set of things that you can do compared to actual C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, you can manipulate the Clojure code any way you want, and you can
    use the full language here too! Since Clojure code is data, manipulating the code
    is as easy as manipulating any other data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Macros are run at compile time, which means that at the time of running the
    code, there is no trace of macros; every macro call is replaced with the generated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your first macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, as you can imagine, since things can get complicated when using macros,
    there should be some way to debug them. We have two functions to accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`macroexpand`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`macroexpand-1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between them has to do with recursive macros. There is no rule
    telling you that you can't use a macro from a macro (the whole language is there
    all the time, remember?). If you wish to go all the way through any macro, you
    can use `macroexpand`; if you wish to go a single step forward, you can use `macroexpand-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Both of them show you the code generated by a macro call; this is what happens
    when you compile your Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give this a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is not much more to macros than this; you now understand them to a good
    level of detail.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, many common problems that you will come across and tools
    for solving them that you should know about. Let's have a look.
  prefs: []
  type: TYPE_NORMAL
- en: Quote, syntax quote, and unquoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see, the `my-if` macro uses a quote in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This happens because you need the `if` symbol as the first element in the resulting
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Quoting is very common in macros, since we need to build code instead of evaluating
    it on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another type of quoting very common in macros—syntax quoting—that
    makes it easier to write code similar to the final code you want to generate.
    Let''s change the implementation of our macro to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what happens here. For one,`(if test positive negative)` looks much
    more beautiful than the `list` function we had before, but the code generated
    with `macroexpand-1` looks pretty strange. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: We just used a different form of quoting that allows us to quote full expressions.
    It does some interesting things. As you can see, it changes the parameters to
    fully qualified `var` names (`clojure.core/test`, `user/positive`, `user/negative`).
    This is something that you'll be grateful for in the future, but you don't need
    this for now.
  prefs: []
  type: TYPE_NORMAL
- en: What you need are the values of test, positive, and negative. How can you get
    them in this macro?
  prefs: []
  type: TYPE_NORMAL
- en: 'Using syntax quotes, you can ask for something to be evaluated inline with
    the unquote operator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try our macro expansion again and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quote, syntax quote, and unquoting](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unquote splicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some other cases that become common in macros. Let's imagine we want
    to reimplement the `>` function as a macro and retain the ability to compare several
    numbers; what would that look like?
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe a first attempt could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unquote splicing](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Do you see the problem here?
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that we are trying to pass a list of values to `clojure.core/>`
    instead of passing the values themselves.
  prefs: []
  type: TYPE_NORMAL
- en: This is easily solved with something called **unquote splicing**. Unquote splicing
    takes a vector or list of parameters and expands it as if you had used the `as`
    parameter on a function or macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unquote splicing](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will use unquote splicing almost every time you have a variable number of
    arguments to a macro.
  prefs: []
  type: TYPE_NORMAL
- en: gensym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating code can be troublesome, and we end up discovering common issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'See if you can find the issue in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common issue when generating code. You overwrite another value, Clojure
    doesn''t even let you run this, and it displays something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![gensym](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'But don''t worry; there''s another way in which you can make sure you are not
    messing with your environment, which is the `gensym` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gensym` function creates a new `var-name` each time the macro is run,
    which guarantees that there is no other `var-name` that it obscures. If you try
    the macro expansion now, you will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![gensym](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Macros in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you want to know when it is that macros are used extensively? Think about
    `defn`; what''s more, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Did you know that `defn` is a macro in `clojure.core` that creates a function
    and binds it to a `var` in the current namespace?
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is filled with macros; if you want some samples, you can look at Clojure
    core, but what else can you do with macros?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at some interesting libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yesql`: The `yesql` library is a very interesting sample of code generation.
    It reads SQL code from a SQL file and generates the Clojure functions accordingly.
    Look for the `defquery` and `defqueries` macros in the `yesql` project on GitHub;
    it can be very enlightening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core.async`: If you are familiar with the `go` language and `goroutines`,
    you would probably like to have that same functionality in the Clojure language.
    This isn''t necessary since you could have provided them yourself! The `core.async`
    library is just `goroutines` for Clojure, and it is provided as a library (no
    obscure language change is needed). This shows a great example of the power of
    macros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core.typed`: With macros, you can even change the dynamic nature of Lisp.
    The `core.typed` library is an effort that allows you to define type constraints
    for your Clojure code; macros are extensively used here to generate boilerplate
    code and checks. This is probably much more complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need further references, you can look at the following list. There are
    entire books committed to the topic of macros. I recommend two in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Clojure Macros ([https://pragprog.com/book/cjclojure/](https://pragprog.com/book/cjclojure/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let over Lambda ([http://letoverlambda.com/](http://letoverlambda.com/)).It
    talks about common Lisp, but the knowledge is very valuable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now understand the power of macros and have a very strong grasp of how they
    work, but we just touched the tip of the iceberg when it comes to macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of how macros work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying your code in Groovy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relation of macros to other tools in the Java world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am sure you've enjoyed working with Clojure so far, and moving forward, I'd
    recommend you to keep reading and exploring this amazing language.
  prefs: []
  type: TYPE_NORMAL
