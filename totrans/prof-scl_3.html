<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Functions</h1></div></div></div><p>In the previous chapter, we covered the object-oriented aspects of Scala, such as classes, objects, pattern matching, self-types, case classes, and so on. We also implemented object-oriented concepts that we learned in our chatbot application.</p><p>In this chapter, we will cover
<a class="indexterm" id="id129"/> functional programming with Scala and how object-oriented and functional approaches complete each other. We will also cover generic classes, which are often used with pattern matching. We will also cover how to create user-defined pattern matching and why is it useful.
</p><p>By the end of this chapter, you will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the basics of functional programming</li><li class="listitem" style="list-style-type: disc">Identify the basics of generic types in Scala</li><li class="listitem" style="list-style-type: disc">Implement user-defined pattern matching</li><li class="listitem" style="list-style-type: disc">Recognize and use functional compositional patterns</li></ul></div><div class="section" title="Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Functions</h1></div></div></div><p>In this section, we 
<a class="indexterm" id="id130"/>will introduce the fundamentals of functional programming, such as function values and high-order functions.
</p><div class="section" title="Function Values"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Function Values</h2></div></div></div><p>What is a function? We are familiar with methods, which must be defined in a scope (class or objects):</p><div class="informalexample"><pre class="programlisting">  def f1(x:Int, y:Int): Int =  x + y</pre></div><p>In Scala, we can also define a function value:</p><div class="informalexample"><pre class="programlisting">   val f2: (Int,Int) =&gt; Int = (x,y) =&gt; (x+y).</pre></div><p>Here, we 
<a class="indexterm" id="id131"/>define the function value, with a type of 
<code class="literal">(Int,Int) =&gt; Int</code>. Of course, as with all type declarations, the type can be omitted if it can be deduced from the context. So, an alternative syntax for this can be:
</p><div class="informalexample"><pre class="programlisting">   val f2 = (x:Int,y:Int) =&gt; (x+y).</pre></div><p>Both 
<code class="literal">f1(1,2)</code> and 
<code class="literal">f2(1,2)</code> will force evaluation. The difference between 
<code class="literal">f1</code> and 
<code class="literal">f2 </code>is that the second is a value, which can be stored in a variable or passed to another function.  
</p><p>Functions which accept other functions as parameters are named high-order functions, for example:</p><div class="informalexample"><pre class="programlisting">def twice(f: Int =&gt; Int): Int =&gt; Int = x =&gt; f(f(x))</pre></div><p>This function returns functions, which apply parameters twice. An example of this usage is as follows:</p><div class="informalexample"><pre class="programlisting">
val incr2 = (x:Int) =&gt; x+2val incr4 = twice(incr2)
incr4(2)   //==6
twice(x=&gt;x+2)(3)   // 7</pre></div><p>In general, the
<a class="indexterm" id="id132"/> syntax for function definitions is as follows:
</p><div class="informalexample"><pre class="programlisting">val fname: (X1 … XN)  =&gt; Y = (x1:X1, … x2:XN) =&gt; expression</pre></div><p>The type signature can be omitted if it is possible to deduce types from the context.</p><p>Now, let's look at how to define a function variable.</p><p>Define the
<a class="indexterm" id="id133"/> function variable in the REPL of IDE worksheet:
</p><div class="informalexample"><pre class="programlisting">  val f:  Int=&gt;Int = x =&gt; x+1</pre></div></div><div class="section" title="Function from an OO Point of View"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Function from an OO Point of View</h2></div></div></div><p>When looking
<a class="indexterm" id="id134"/> at Scala sources, we will see the following definition:
</p><div class="informalexample"><pre class="programlisting">trait Function1[-T1, +R] {
def apply(v1: T1): R
  ….
}</pre></div><p>Here, 
<code class="literal">Function1</code> is a base trait for a function with one argument. 
<code class="literal">Function1</code> has one abstract method: 
<code class="literal">apply</code>. Scala provides syntax sugar for the call of the 
<code class="literal">apply</code> method with syntax.
</p><p>
<code class="literal">T1</code> and 
<code class="literal">R</code> are type parameters of 
<code class="literal">Function1</code>.  
<code class="literal">T1</code> is a type of the first argument, while 
<code class="literal">R</code> is a result type.
</p><p>Symbols 
<a class="indexterm" id="id135"/>before type parameters [
<code class="literal"> -T1, +R </code>] mean 
<code class="literal">contravariance</code> and 
<code class="literal">covariance</code> of parameters; we will speak about one in detail later. For now, let's write a definition:
</p><div class="informalexample"><pre class="programlisting"> F[T]  covariant,  iff   A &lt;: B =&gt;  F[A]  &lt;:  F[B]
  F[T]   contravariant  iff  A &gt;: B =&gt; F[A] &lt;: F[B]</pre></div><p>The value of a function with one argument, 
<code class="literal">f: A =&gt; B</code>, is just an instance of a trait, 
<code class="literal">Function1[A,B]</code>. For functions with two arguments, we have 
<code class="literal">Function2[T1,T2,R]</code> and so on. We can rewrite an example with 
<code class="literal">twice</code> using OO facilities in the next form:
</p><div class="informalexample"><pre class="programlisting">//   val twice(f:Int=&gt;Int):Int=&gt;Int = x =&gt; f(f(x))
object  Twice extends Function1[Function1[Int,Int],Function1[Int,Int]] 
{
	def apply(f: Function1[Int,Int]): Function1[Int,Int] =new Function1[Int,Int] 
	{
		def apply(x:Int):Int =   f.apply(f.apply(x))
	}
}</pre></div><p>Here, we define the 
<code class="literal">Twice</code> object with the same behavior of the previously described function:
</p><div class="informalexample"><pre class="programlisting">val incr2 = (x:Int) =&gt; x+2
val incr4 = Twice(incr2)
incr4(2)  //=6
Twice(x=&gt;x+2)(5) //=9</pre></div><p>To 
<a class="indexterm" id="id136"/>summarize, we can say:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The function value is an instance of an appropriative function trait.</li><li class="listitem" style="list-style-type: disc">The call of a function value is a call of the <code class="literal">apply()</code> method in a function trait.</li></ul></div><p>Now, it's time to create a few functions.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open a blank worksheet in your project.</li><li class="listitem">Define<a class="indexterm" id="id137"/> the function which accepts the binary function and arguments, and return an application of such a function:<div class="informalexample"><pre class="programlisting">g(f: (Int,Int)=&gt;Int, x: Int, y:Int): Int = f(x,y)</pre></div></li><li class="listitem">Make the syntax better by reformulating the function using currying: <div class="informalexample"><pre class="programlisting">g(f: (Int,Int)=&gt;Int)( x: Int, y:Int): Int = f(x,y)</pre></div></li><li class="listitem">Partial application: Write the <code class="literal">fix</code> function, which accepts  binary function and an argument and returns an unary function, which will apply the placed function and argument. For example, with definition <code class="literal">g</code> as : <code class="literal">val g = fix1((x,y)=&gt;x+y,3)</code>.</li><li class="listitem"><code class="literal">g(2)</code> should be evaluated to <code class="literal">5</code>.<div class="informalexample"><pre class="programlisting">fix(f: (Int,Int)=&gt;Int)( x: Int): Int =&gt; Int = y =&gt; f(x,y)</pre></div></li></ol></div></div><div class="section" title="Conversions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Conversions</h2></div></div></div><p>We have methods and functional values, which can do the same thing. It is logical to expect a 
<a class="indexterm" id="id138"/>conversion between them, for example, the ability to assign a method to a functional variable or pass a function as an OO interface.
</p><p>Scala provides a special syntax for converting a method to a value. We just need to add the underscore (_) after the name of the method.</p><p>For example:</p><div class="informalexample"><pre class="programlisting">val printFun = Console.print _</pre></div><p>Also, a functional value can be implicitly converted to a so-called SAM (Single Abstract Method) trait. A SAM trait has only one abstract method, and we can pass a function in its context, where the SAM trait is required (and the function type conforms to the method signature).: </p><div class="informalexample"><pre class="programlisting">val th = new Thread(()=&gt; println(s"threadId=${Thread.currentThread().getId}"))
th.start()</pre></div><p>Here, we pass the function with zero parameters to the 
<code class="literal">Thread</code> constructor, which accepts the 
<code class="literal">Runnable</code> interface.
</p><p>In Scala, we have three different ways of implementing deferred call functionality.</p></div><div class="section" title="Defining and Measuring the Time of a Unit Function"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Defining and Measuring the Time of a Unit Function</h2></div></div></div><p>Define a function which accepts a function which runs a unit function and measures the time in nanoseconds. How long does this take? Implement this in three different ways.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a function which accepts other functions. Run one and measure the execution time:<div class="informalexample"><pre class="programlisting">
def measure1(f: Unit =&gt; Unit): Long = {
	val startTime = System.nanoTime()
f()
	val endTime = System.nanoTime()
endTime – startTime
}
</pre></div></li><li class="listitem">Write a <a class="indexterm" id="id139"/>function which accepts the by-name parameter. Run one and measure the execution time:<div class="informalexample"><pre class="programlisting">
def measure2(f: =&gt; Unit): Long = {
	val startTime = System.nanoTime()
	f
	val endTime = System.nanoTime()
	endTime – startTime
}
</pre></div></li><li class="listitem">Write an object which extends the <code class="literal">Function1</code> trait and do the same in the <code class="literal">apply</code> method:<div class="informalexample"><pre class="programlisting">
object Measure3 extends Function1[Unit=&gt;Unit,Long]
{
	override def apply(f: Unit=&gt;Unit) = {
		val startTime = System.nanoTime()
		f()
		val endTime = System.nanoTime()
    endTime – startTime
   }
}</pre></div></li></ol></div></div><div class="section" title="Syntax Sugar in a Function Definition"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Syntax Sugar in a Function Definition</h2></div></div></div><p>Sometimes, writing
<a class="indexterm" id="id140"/> expressions such as 
<code class="literal">x =&gt; x+1</code> look too verbose. To solve this, syntax sugar exists, which allows you to write small functional expressions in a compact and idiomatic way. Don't write the 
<a class="indexterm" id="id141"/>left part at all, and, while writing, use _ (underscore) instead of an argument. The first underscore means the first argument, the second underscore means the second argument, and so on:
</p><div class="informalexample"><pre class="programlisting">_ + 1   is a shortcut for  x =&gt;  x+1,   _ + _  -- for (x,y) =&gt; x + y.</pre></div><p>Some functions such as 
<code class="literal">(x,y) =&gt; x*x + y</code> can't be represented in such a notation.
</p></div><div class="section" title="Partial Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Partial Functions</h2></div></div></div><p>Partial functions 
<a class="indexterm" id="id142"/>are better known as partially defined functions—some values exist in the domain of the function input, where this 
<a class="indexterm" id="id143"/>function is undefined.
</p><p>Let's look at a simplified definition:</p><div class="informalexample"><pre class="programlisting">trait PartialFunction[-A, +B] extends (A =&gt; B) { 
/** Checks if a value is contained in the function's domain.
*
*@param  x   the value to test
*  @return `'''true'''`, iff `x` is in the domain of this function, `'''false'''` otherwise.*/
def isDefinedAt(x: A): Boolean
}</pre></div><p>Along with the apply method we have a 
<code class="literal">isDefinedAt</code> method, which returns 
<code class="literal">true</code> if our function is applicable for an argument, and a special syntax:
</p><div class="informalexample"><pre class="programlisting">val pf: PartialFunction[Int,String] = {
case 0 =&gt; "zero"
case 1 =&gt; "one"
case 2 =&gt; "two"
case x:Int if x&gt;0 =&gt; "many"}

pf.isDefinedAt(1)  - true
pf.isDefinedAt(-1)  - false

pf(-1)  throws exceptions.</pre></div><p>We can combine a few partial functions into a new set of standard combinators—
<code class="literal">orElse</code>:
</p><div class="informalexample"><pre class="programlisting">val pf1: PartialFunction[Int,String] = pf orElse { case _ =&gt; "other" }</pre></div><p>Note that 
<a class="indexterm" id="id144"/>type annotation is needed to give a correct context for type deduction. Otherwise, the compiler will not be able to deduce the type of inline function argument.
</p><p>One useful combinator—
<code class="literal">andThen</code>, which allows building pipelines, is also necessary:
</p><div class="informalexample"><pre class="programlisting">pf andThen (_.length)(1)  </pre></div><p>Now, define a 
<a class="indexterm" id="id145"/>function which accepts a function and provides a transformed function. For example, let the input function be 
<code class="literal">f</code>: 
<code class="literal">Int =&gt; Int</code>, and let's build 
<code class="literal">g(f)</code>: 
<code class="literal">g(f)(x) = f(x) + x.</code> If 
<code class="literal">f</code> is not defined at 
<code class="literal">x</code>, 
<code class="literal">g(f)</code> must not be defined either.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy the following class:<div class="informalexample"><pre class="programlisting">
class g1(f:PartialFunction[Int,Int]) extends 
PartialFunction[Int,Int] {
	override def isDefinedAt(x: Int) =
		f.isDefinedAt(x)
	override def apply(x: Int) =
		f(x) + x 
}</pre></div></li><li class="listitem">Or as a case-expression with an <code class="literal">if</code> clause:<div class="informalexample"><pre class="programlisting">
               def g2(f:PartialFunction[Int,Int]):PartialFunction[Int,Int] = {
case x if f.isDefinedAt(x) =&gt; f(x)+x
                }</pre></div></li></ol></div><p>We'll now implement a partial function for constructing an association between names and values.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a function for a pair as a class with parameters (name,value), which is defined only if the argument is equal to name:<div class="informalexample"><pre class="programlisting">
class NVPair(name: String, value: String) extends 
PartialFunction[String,String] {
	override def isDefinedAt(x: String): Boolean = (x==name)
	override def apply(x: String): String = {
		if (x==name) value else throw new MatchError()
	}
}</pre></div></li><li class="listitem">Use the <code class="literal">orElse</code> combinator to combine such pairs into a bigger function:<div class="informalexample"><pre class="programlisting">val f = new NVPair("aa","bb") orElse new NVPair("cc","dd")</pre></div></li></ol></div></div></div></div>
<div class="section" title="Exploring Pattern Matching"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Exploring Pattern Matching</h1></div></div></div><p>Now we will return to pattern matching and learn about extending capabilities behind case classes. As you will remember from the previous chapter, we can
<a class="indexterm" id="id146"/> use pattern matching against case classes, where fields of a class can be bound to the variables in the scope of an appropriative case clause. Can we do this for our non-case classes and embed our own custom logic for matching?
</p><p>In this section, we will learn how to write our own pattern matcher and get acquainted with some standard generic classes which are often used with pattern matching.</p><p>Now, let's get started with the minimal example.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we <a class="indexterm" id="id147"/>write the following code in the IDE:<div class="informalexample"><pre class="programlisting">case class Wrapper(x:Int)

w match {case Wrapper(x) =&gt; doSomething(x)}</pre></div></li><li class="listitem">Under the hood, the compiler compiled this to the next intermediate form:<div class="informalexample"><pre class="programlisting">val container = Wrapper.unapply(w)
if (container.isDefined) {
	val x = container.get
	doSomething(x)
}</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">unapply</code> method of the companion object is called, which must return the class with the methods get and <code class="literal">isDefined</code>.</li></ul></div></li><li class="listitem">When we<a class="indexterm" id="id148"/> have more than one binding variable, the resulting container should contain a tuple. For example, for the point intermediate form, this will be the resulting code:<div class="informalexample"><pre class="programlisting">val container = Point.unapply(p)
if (container.isDefined) 
{
  val (x,y) = container.getdoSomething(x,y)
}</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The standard Scala library provides the <code class="literal">Option</code> type, although it is possible to define your own type with such methods (which can be useful in some heavy optimization scenarios).</li></ul></div></li><li class="listitem">Define the class:<div class="informalexample"><pre class="programlisting">sealed abstract class Option[+A]  {
 
 def isEmpty: Boolean
 def isDefined: Boolean = !isEmpty
 def get: A

  // …  other methods

}

final case class Some[+A](value: A) extends Option[A] {
  def isEmpty = false
  def get = value
}

case object None extends Option[Nothing] {
  def isEmpty = true
  def get = throw new NoSuchElementException("None.get")
}</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Here, we see the algebraic type (such as the hierarchy of case classes/objects) with the generic type parameter: A. You may have heard of the  abbreviation GADT (Generic Algebraic Data Type) when referring to such constructs.</li><li class="listitem" style="list-style-type: disc">Informal value of <code class="literal">Option[A]</code> – the container from one or zero elements, or elements which can or cannot exist. Some(a) – when an element exists, None – for its absence.</li><li class="listitem" style="list-style-type: disc"><code class="literal">None</code> extends <code class="literal">Option[Nothing]</code>. Nothing is a <code class="literal">minimal</code> type in the Scala typesystem, which is a subtype of any type.</li></ul></div></li><li class="listitem">So, to <a class="indexterm" id="id149"/>define the custom pattern matcher, we need to create an object with the <code class="literal">unapply</code> method and put logic inside of it which returns a binding variable (or a tuple with binding variables) in an option container:<div class="informalexample"><pre class="programlisting">case class Point(x:Int, y:Int)</pre></div></li><li class="listitem">Let's define the pattern matcher <code class="literal">Diagonal</code>, which will match only points situated in the diagonal:<div class="informalexample"><pre class="programlisting">object Diagonal {
def unapply(p:Point): Option[Int] =if (p.x == p.y) Some(p.x) else None
}</pre></div></li></ol></div><p>We'll now implement
<a class="indexterm" id="id150"/> the 
<code class="literal">unapply</code> custom.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define object <code class="literal">Axis</code> (Numbered Bullet)</li><li class="listitem">Define method <code class="literal">unapply</code> (Numbered Bullet END)</li><li class="listitem">Determinate, if object is on X axis(Apply BULLET INSIDE BULLET to all three points) </li><li class="listitem">Determinate, if object is on Y axis </li><li class="listitem">Otherwise, return <code class="literal">None</code>.</li></ol></div><div class="section" title="Binding a Sequence of Variables in the Pattern Matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Binding a Sequence of Variables in the Pattern Matcher</h2></div></div></div><p>Sometimes, we 
<a class="indexterm" id="id151"/>need a particular type of pattern matcher where the number of binding variables can vary. For example, regular expressions in standard Scala library are as follows:
</p><div class="informalexample"><pre class="programlisting">
val r1 = "([\\d]+)".r
val r2 = "([\\d]+)  ([^\\W]*)".r

v match {case r1(x) =&gt; "1"case r2(x,y) =&gt; "2"
}</pre></div><p>Here, we can see that that 
<code class="literal">r1</code> is matched with one variable, but 
<code class="literal">r2</code> uses two binding variables. Another convention exists for this case: a companion object should provide the 
<code class="literal">unapplySeq</code> method instead of 
<code class="literal">unapply</code>, which returns a sequence wrapped in an option.
</p><p>We will learn 
<a class="indexterm" id="id152"/>more about sequences during the next chapter, but for now we can say that 
<code class="literal">Seq[A]</code> – is a generic trait for sequences. The 
<code class="literal">apply</code> operator in sequences works as index access (for example,  
<code class="literal">seq(n)</code> returns the nth element of the sequence, and it is possible to create default sequence using the 
<code class="literal">Seq</code> companion class, 
<code class="literal">Seq(1,2,3)</code>.
</p><p>Let's now implement the custom 
<code class="literal">unapplySeq</code> method. This is defined on strings and returns a sequence of words.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the <code class="literal">Words</code> object.</li><li class="listitem">Define <a class="indexterm" id="id153"/>the <code class="literal">unapplySeq </code>method. Transform the array to <code class="literal">seq</code>, using the .<code class="literal">toSeq</code> method in Scala Array:<div class="informalexample"><pre class="programlisting">object Words {def unapplySeq(arg: String):Option[Seq[String]] = {
val array = arg.split("\\W+")
if (array.size == 1 &amp;&amp; array(0).isEmpty ) {
      None} else {
  Some(array.toSeq)
  }
  }
}</pre></div></li><li class="listitem">Write a test which compares words for the following strings: <div class="informalexample"><pre class="programlisting">    "1",    "AA AA",  "AA   AA",   "ABC CBA",  "A B C D E     F G X-L",""    
"AAA     AAA" match {case Words(x,y) =&gt; (x,y)
}</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sometimes, when binding variables into sequence, we don't need var for each value in the sequence, but only the first value and the rest of the sequence.</li></ul></div></li><li class="listitem">We can<a class="indexterm" id="id154"/> use the pattern with the syntax for a variable function call in a pattern, for example:<div class="informalexample"><pre class="programlisting">
object AsSeq
{
def unapplySeq(x:Array[Int]):Option[Seq[Int]] = {Some(x)
}
}Array(1,2,3,6) match {case AsSeq(h, _*) =&gt; h 
}</pre></div></li></ol></div></div></div>
<div class="section" title="Partial Functions in Practice"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Partial Functions in Practice</h1></div></div></div><p>Now that we have
<a class="indexterm" id="id155"/> learned a lot about functions and pattern matching, let's apply our theoretical knowledge to practical programming.
</p><p>Let's get our chatbot, which we developed during the previous chapter, and change the modes to partial functions instead of classes.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Open <code class="literal">/Lesson 3/5-project</code> in the supplement materials and import the project into the IDE.
</p></div></div><div class="section" title="Representing ChatbotMode as a Partial Function"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Representing ChatbotMode as a Partial Function</h2></div></div></div><p>Let's navigate to 
<a class="indexterm" id="id156"/>the 
<code class="literal">scala</code> file
<a class="indexterm" id="id157"/> package in 
<code class="literal">com.packt.courseware.l4</code>:
</p><div class="informalexample"><pre class="programlisting">package com.packt.courseware.l4

package object modes {
  type ChatbotMode = PartialFunction[(String,EffectsProvider),Processed]

     …
}</pre></div><p>Here, we see the 
<code class="literal">package</code> object, which was not mentioned previously in our chapters. 
</p><p>The <code class="literal">package</code> object is an object which is associated with a package. When you import a package with a wildcard, then you import the current scope content of the package object if one exists.
</p><p>So, the 
<code class="literal">package</code> object is a good way to store some utility definitions and functions, which
<a class="indexterm" id="id158"/> should be available in a package.
</p><p>The
<a class="indexterm" id="id159"/> next sentence is a type alias for 
<code class="literal">ChatbotMode</code>: we define one as a partial function from (
<code class="literal">String</code>, 
<code class="literal">EffectsProvider</code>) to 
<code class="literal">Processed</code>.
</p><p>As you will remember, 
<code class="literal">Processed</code> is a 
<code class="literal">LineStepResult</code> which is a trait, united with Processed or Failed. With partial functions, we don't need a 
<code class="literal">Failed</code> variant; instead, 
<code class="literal">isDefined</code> in our mode will be set to 
<code class="literal">false</code>.
</p><p>Now let's look at some simple mode:</p><div class="informalexample"><pre class="programlisting">val bye: ChatbotMode = { 
case ("bye", eff) =&gt; Processed("bye", bye, true) 
}</pre></div><p>So, we can write partial functions just as we do 
<code class="literal">vars</code>.
</p><p>In the previous version, we have 
<code class="literal">OrMode</code>, which combines modes in combination. Can we do the same with partial functions?
</p><div class="informalexample"><pre class="programlisting">def or(frs:ChatbotMode, snd: ChatbotMode): ChatbotMode = {
val frsPost = frs.andThen(p =&gt; p.copy(nextMode = or(p.nextMode,snd)))
val sndPost = snd.andThen(p =&gt; p.copy(nextMode = or(p.nextMode,frs)))
frsPost orElse sndPost
}</pre></div><p>We use the 
<code class="literal">andThen</code> combinator for postprocessing the result of applying 
<code class="literal">frs</code> and 
<code class="literal">snd</code> in order to insert 
<code class="literal">nextMode</code> in the or chain and return those functions in the 
<code class="literal">orElse</code> combinator.
</p><p>So, as we can see, modes can be described with the help of partial functions. The resultant code is a little shorter, but we only lose the fancy syntax for combining modes.</p><p>The main mode now looks like this:</p><div class="informalexample"><pre class="programlisting">import modes._
def createInitMode() = otherwise (
or(StoreRemindCommand.empty, or(bye,or(currentDate,currentTime))),
  interestingIgnore)</pre></div><p>Let's now implement partial functions. In l4, some modes are removed from the source code. Can you move them back, in the form of partial functions?</p><p>
<span class="strong"><strong>Steps for Completion:</strong></span>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">Lesson 3/5-project.</code></li><li class="listitem">Implement the <code class="literal">currentTime</code>, <code class="literal">otherwise,</code> and <code class="literal">interestingIgnore </code>modes.</li><li class="listitem">Ensure that the tests are running.</li></ol></div></div><div class="section" title="Implementing RemindStore as a Set of Partial Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Implementing RemindStore as a Set of Partial Functions </h2></div></div></div><p>Let's look at 
<a class="indexterm" id="id160"/>the implementation of 
<code class="literal">RemindStore</code>. Navigate to 
<code class="literal">com/packt/courseware/l4/RemindCommand.scala</code>.
</p><p>Look at
<a class="indexterm" id="id161"/> using regular expressions in patterns:
</p><div class="informalexample"><pre class="programlisting">val StorePattern = raw"store ([^\W]+) (.*)".r;
val RemindPattern = raw"remind ([^\W]+)".r;

def process(state:RemindedState): ChatbotMode =
{
  case (StorePattern(n,v),effects) =&gt; Processed("ok",process(state.store(n,v)),false)
  case (RemindPattern(n),effects) if state.isDefinedAt(n) =&gt; Processed(state(n),process(state),false)
}</pre></div><p>Note 
<a class="indexterm" id="id162"/>that 
<code class="literal">RemindedState</code> has a memory leak: what will be the behavior of the function 
<a class="indexterm" id="id163"/>when we ask our chatbot to store the same word a few times?
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>
</p><p>A memory leak is
<a class="indexterm" id="id164"/> a situation where we allocate an object but keep it accessible after usage.
</p></div></div><p>Let's now find and fix a memory leak in 
<code class="literal">StoreRemindCommand</code>.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">Lesson 3/5-project</code>.</li><li class="listitem">Analyze<a class="indexterm" id="id165"/> the case where we stored the same work a few times.</li><li class="listitem">Consider<a class="indexterm" id="id166"/> how it's possible to write a unit test for this (<code class="literal">***</code>)?</li><li class="listitem">Fix the memory leak.</li></ol></div><p>As we have seen, it is possible to build modes in chatbot as partial functions.</p></div><div class="section" title="Using Lifting for Conversations between Total and Partial Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Using Lifting for Conversations between Total and Partial Functions</h2></div></div></div><p>Such a design has drawbacks:</p><p>The first 
<a class="indexterm" id="id167"/>drawback is that our partial function always accepts one parameter: a tuple of input and effects. This can be a source of confusion.
</p><p>Also note that a decision where we process input or reject (and it will be passed to the next chain by a combinator) should be written twice: first in 
<code class="literal">isDefinedAt</code>, then in apply. In simple cases, this is hidden from us by case syntax, where 
<code class="literal">isDefinedAt</code> is produced automatically.
</p><p>It looks like
<a class="indexterm" id="id168"/> a loss of a binary operator syntax is the third problem. However, this is not a real problem. We will learn how it is possible to define our own syntax on third-party classes in 
<a class="link" href="ch05.html" title="Chapter 5. Scala Type System">Chapter 5</a>, 
<span class="emphasis"><em>Scala Type System</em></span>.
</p><p>Can we have one point of decision and work with a partially defined value?</p><p>Let's look at the next method from the standard library:</p><div class="informalexample"><pre class="programlisting">trait PartialFunction[-A, +B] extends (A =&gt; B) {
 ….

  /** Turns this partial function into a plain function returning an `Option` result.
  *  @see     Function.unlift
  *  @return  a function that takes an argument `x` to `Some(this(x))` if `this`
  *           is defined for `x`, and to `None` otherwise.
  */
  def lift: A =&gt; Option[B]

}</pre></div><p>We can represent
<a class="indexterm" id="id169"/> a partial function as a total function with the result wrapped in 
<code class="literal">Option</code>. For a combinator of partial functions, we have very similar methods to 
<code class="literal">Option</code>.
</p><p>Let's change the design of our modes again.</p><p>Look at 
<code class="literal">Lesson 3/6-project</code>.
</p><p>
<code class="literal">ChatbotMode</code> is a trait once more:
</p><div class="informalexample"><pre class="programlisting">trait ChatbotMode {
def process(line:String,effects:EffectsProvider):Option[Processed]
def or(other: ChatbotMode) = OrMode(this,other)
def otherwise(other: ChatbotMode) = OtherwiseMode(this,other)}</pre></div><p>But we can 
<a class="indexterm" id="id170"/>define simple modes with the help of partial functions and transform one to our traits using the 
<code class="literal">helper</code> constructor:
</p><div class="informalexample"><pre class="programlisting">object ChatbotMode{
def partialFunction(f:PartialFunction[String,Processed]): ChatbotMode =
{(line,effects) =&gt; f.lift(line) }}</pre></div><p>After that, we can do this:</p><div class="informalexample"><pre class="programlisting">val bye: ChatbotMode = ChatbotMode.partialFunction(
                       { case "bye" =&gt; Processed("bye", bye, true) })</pre></div><p>Also note that we can initialize 
<code class="literal">ChatbotMode</code> from the function because 
<code class="literal">ChatbotMode</code> is a SAM type: 
</p><div class="informalexample"><pre class="programlisting">val interestingIgnore: ChatbotMode = ( line, effects ) =&gt; 
                       Some(Processed("interesting...",interestingIgnore,false))</pre></div><p>Also, we can
<a class="indexterm" id="id171"/> compare the
<a class="indexterm" id="id172"/> implementation of 
<code class="literal">OrMode</code> with the previous variant, based on partial function combinators:
</p><div class="informalexample"><pre class="programlisting">
case class OrMode(frs:ChatbotMode, snd:ChatbotMode) extends ChatbotMode {
	override def process(line: String, effects: EffectsProvider): Option[Processed] = {
		frs.process(line,effects).map(p =&gt; p.copy(nextMode = OrMode(p.nextMode,snd))
)orElse snd.process(line,effects).map(
p =&gt; p.copy(nextMode = OrMode(p.nextMode,frs))
		)
	}
}
</pre></div><p>As you can see, that structure is very similar: map used 
<code class="literal">andThen</code> instead in the partial function, and Option also uses 
<code class="literal">orElse</code>.  We can say that the domains 
<code class="literal">PartialFunction[A,B]</code> and 
<code class="literal">Function[A,Option[B]]</code> are isomorphic.
</p><p>There is a default transformer from a partial function to a function of an option, and it is named 
<code class="literal">lift</code>.
</p><p>This is a 
<a class="indexterm" id="id173"/>method of a partial function:
</p><div class="informalexample"><pre class="programlisting">{ case "bye" =&gt; Processed("bye", bye, true) }.lift
</pre></div><p>This will have the same effect as this:</p><div class="informalexample"><pre class="programlisting">          x =&gt; if (x=="bye") Some(Processed("bye", bye, true)) else None</pre></div><p>Let's write 
<a class="indexterm" id="id174"/>an inverse transformer, 
<code class="literal">unlift</code>:
</p><div class="informalexample"><pre class="programlisting">def unlift[X,Y](f: X =&gt; Option[Y]):PartialFunction[X,Y] = new PartialFunction[X,Y] {
	override def isDefinedAt(x: X) =
	f(x).isDefined
	override def apply(x: X) =
	f(x) match {
		case Some(y) =&gt; y
	}
}</pre></div><p>It is a good practice to provide more efficient chain operations, for example:</p><div class="informalexample"><pre class="programlisting">override def applyOrElse[A1 &lt;: X, B1 &gt;: Y](x: A1, default: A1 =&gt; B1): B1 =
	f(x) match {
		case Some(y) =&gt;y
		case None =&gt; default(x)  
}</pre></div><p>Here, we call the underlying 
<code class="literal">f</code> once.
</p><p>Let's now add a simple TODO list to our chatbot.</p><p>We will 
<a class="indexterm" id="id175"/>change our model of evaluation by allowing more than one mode to evaluate input. A combinator will choose the best evaluation.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">Lesson 3/6-project.</code></li><li class="listitem">Add the <code class="literal">Processed</code>, <code class="literal">relevance</code> parameter between 0 and 1.</li><li class="listitem">Modify the <code class="literal">or</code> combinator to evaluate both of the child modes and select answer, based on its relevance.</li><li class="listitem">Add a test to the <code class="literal">test</code> cases.</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we have covered functional programming with Scala and how object-oriented and functional approaches complete each other. We also covered generic classes, which are often used with pattern matching. Finally, we covered how to create user-defined pattern matching and learned why is it useful.</p><p>In the next chapter, we'll cover important Scala collections such as 
<code class="literal">Sets</code> and 
<code class="literal">Maps</code>. We'll also discuss mutable and immutable collections and their applicability in Scala code.
</p></div></body></html>