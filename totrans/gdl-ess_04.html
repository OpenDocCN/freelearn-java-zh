<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Demystifying Build Scripts"><div class="book" id="QMFO2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Demystifying Build Scripts</h1></div></div></div><p class="calibre8">In the first three chapters, we saw many interesting functionalities that Gradle can add to our builds merely by adding a few lines in the build file. However, this was just the tip of the iceberg. What we explored was mostly the tasks that were added by plugins shipped with Gradle. From our experiences, we know that project builds are never this simple. They will have customizations no matter how hard we try to avoid them. That's why the ability to add custom logic is extremely important for a build tool.</p><p class="calibre8">Also, the beauty of Gradle lies exactly there. It doesn't come into our way whenever we decide to either extend the existing functionality or deviate completely from the convention and want to do something unconventional. We are not required to write the XML soup or the bunch of Java code if we wish to add some logic to our build. We can create our own tasks or extend the existing tasks to do more.</p><p class="calibre8">This flexibility comes with a very gentle learning curve in the form of learning Groovy DSL. In this chapter, we are going to understand the syntax of the Gradle build scripts and some of the key concepts of Gradle. We will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A Groovy primer that will help us understand the Gradle build script syntax</li><li class="listitem">The two important objects available in our build, namely, the <code class="literal">project</code> object and the <code class="literal">task</code> object(s)</li><li class="listitem">Build phases and life cycle callbacks</li><li class="listitem">Some details of the tasks (tasks execution and task dependencies)</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Demystifying Build Scripts">
<div class="book" title="Groovy for Gradle build scripts"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec21" class="calibre1"/>Groovy for Gradle build scripts</h1></div></div></div><p class="calibre8">To be <a id="id108" class="calibre1"/>proficient with Gradle and write effective build scripts, we need to understand some basics of Groovy, which is a fantastic dynamic language in itself. If we have any experience with dynamic languages such as Ruby or Python, in addition to Java, we will feel right at home with Groovy. If not, still knowing that most of the Java syntax is also the valid Groovy syntax should make us feel happy about Groovy, because we can start writing Groovy code and be productive from day one without having to learn anything.</p><p class="calibre8">To an unprepared <a id="id109" class="calibre1"/>eye, Gradle scripts may look a little difficult to comprehend at first. Gradle build scripts do not merely use the Groovy syntax, but also use a rich and expressive DSL that provides high-level abstractions to represent common build-related logics. Let's take a quick look at what makes Groovy a great choice for writing build files.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">Using Groovy for writing build logics is not new. Gant and GMaven have already used Groovy to write the build logic in order to harness Groovy's syntactic terseness and expressiveness. GMavenPlus is a successor of GMaven. The tools they are built upon, namely Ant and Maven, limit both Gant and GMaven respectively.</p><p class="calibre8">Instead of piggybacking on the existing tools to just add syntactic enhancements, Gradle is designed by leveraging the learning from the past tools.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Demystifying Build Scripts">
<div class="book" title="Groovy for Gradle build scripts">
<div class="book" title="Why Groovy?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec32" class="calibre1"/>Why Groovy?</h2></div></div></div><p class="calibre8">Gradle's <a id="id110" class="calibre1"/>core is written mostly in Java (see the information below). Java is a great language, but it is not the best fit for writing scripts. Just imagine scripting in Java, we would perhaps be writing another project for defining the build of our main project because of the verbosity and ceremony of Java. XML, which was heavily used in the previous generation of build tools (Ant and Maven), is okay for the declarative part but is not great for writing logic.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre8">We can view and <a id="id111" class="calibre1"/>download Gradle's source code from GitHub at <a class="calibre1" href="https://github.com/gradle/gradle">https://github.com/gradle/gradle</a>.</p></div><p class="calibre8">Groovy is<a id="id112" class="calibre1"/> a dynamic avatar of Java. As mentioned earlier, most of the Java syntax is the valid Groovy syntax too. If we know Java, we can already write Groovy code. This is a big plus provided that the sheer number of people who can write Java today.</p><p class="calibre8">Groovy's syntax is concise, expressive, and powerful. Groovy is a great mix of dynamic flavor, while still being able to use types. It is one of few languages that sport optional typing, that is, the flexibility to provide type information if we want to and leave type information aside when we don't want to. Groovy is an excellent language to build internal DSLs into because of the first class lambda support and metaprogramming capabilities. All of the above factors make it one of the most suitable candidates for writing build scripts.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Demystifying Build Scripts">
<div class="book" title="Groovy for Gradle build scripts">
<div class="book" title="Groovy primer"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec33" class="calibre1"/>Groovy primer</h2></div></div></div><p class="calibre8">Although <a id="id113" class="calibre1"/>we can write Java style code in Groovy, if we invest some time in learning the dynamic nature of the language and some of the syntactical enhancements that Groovy offers, we will be able to write better Gradle build scripts and plugins. This is going to be fun if we don't already know Groovy.</p><p class="calibre8">Let's learn just enough of Groovy so that we can understand the Gradle scripts properly. We will take a quick look at a few language features of Groovy.</p><p class="calibre8">It is highly recommended to try and execute the code in the subsections that follow. Also, writing and trying out more code on our own to explore Groovy would help us strengthen our understanding of the language fundamentals. This guide is not exhaustive by any means and is included just to set the Groovy ball rolling.</p><div class="book" title="Running Groovy code"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec10" class="calibre1"/>Running Groovy code</h3></div></div></div><p class="calibre8">The <a id="id114" class="calibre1"/>easiest and recommended way is to install the latest Groovy SDK locally. Groovy code snippets can be executed using any of the following options:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Save the snippets to the <code class="literal">.groovy</code> script and run from the command line using the following code:<div class="informalexample"><pre class="programlisting">groovy scriptname.groovy</pre></div></li><li class="listitem">We can use the Groovy console GUI that comes packaged with the Groovy installation to edit and run the scripts</li><li class="listitem">We can also use Groovy shell, which is an interactive shell for executing or evaluating Groovy statements and expressions</li></ul></div><p class="calibre8">If we don't want to install Groovy locally, then:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We can run Groovy code online in a browser using Groovy console at <a class="calibre1" href="http://groovyconsole.appspot.com">http://groovyconsole.appspot.com</a></li><li class="listitem">We can also run Groovy code in the build script by creating tasks and putting code snippets in them (we can also put them outside any task and it will still run it in the configuration phase)</li></ul></div></div><div class="book" title="Variables"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec11" class="calibre1"/>Variables</h3></div></div></div><p class="calibre8">In a <a id="id115" class="calibre1"/>Groovy script, the <code class="literal">def</code> keyword can define a variable (depending on the context):</p><div class="informalexample"><pre class="programlisting">def a = 10</pre></div><p class="calibre8">However, <a id="id116" class="calibre1"/>the type of <code class="literal">a</code> is decided at the runtime depending on what type of object it points to. Roughly speaking, a reference declared as <code class="literal">def</code> can refer to any <code class="literal">Object</code> or its subclasses.</p><p class="calibre8">Declaring a more specific type is equally valid and should be used whenever we want to have type safety:</p><div class="informalexample"><pre class="programlisting">Integer b = 10</pre></div><p class="calibre8">We can also use Java primitive data types, but keep in mind that they are not actually primitives in Groovy. They are still first-class objects and are actually Java wrapper classes for corresponding data type. Let's confirm with an example, as follows:</p><div class="informalexample"><pre class="programlisting">int c = 10
println c.getClass()</pre></div><p class="calibre8">It prints the following output:</p><div class="informalexample"><pre class="programlisting">class java.lang.Integer</pre></div><p class="calibre8">This shows that <code class="literal">c</code> is an object as we can call a method on it, and the type of <code class="literal">c</code> is <code class="literal">Integer</code>.</p><p class="calibre8">We recommend using specific types wherever possible as this adds to the readability and helps the Groovy compiler to detect errors early by catching invalid assignments. It also helps IDEs with code completion.</p><div class="book" title="Strings"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec04" class="calibre1"/>Strings</h4></div></div></div><p class="calibre8">Unlike <a id="id117" class="calibre1"/>Java, the single quotes are (<code class="literal">''</code>) string literals and not a <code class="literal">char</code>:</p><div class="informalexample"><pre class="programlisting">String s = 'hello'</pre></div><p class="calibre8">Of course, regular Java string literals (<code class="literal">""</code>) can also be used, but they are called GStrings in Groovy. They have an additional capability of string interpolation or inline expansion of variables or expressions:</p><div class="informalexample"><pre class="programlisting">def name = "Gradle"
println "$name is an awesome build tool"</pre></div><p class="calibre8">This prints the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">Gradle is an awesome build tool</strong></span>
</pre></div><p class="calibre8">Both <code class="literal">${var}</code> and <code class="literal">$var</code> are valid, but wrapping (<code class="literal">${}</code>) is more suitable and required for complex or longer expressions. For example:</p><div class="informalexample"><pre class="programlisting">def number = 4
println "number is even ? ${number % 2 == 0 }"</pre></div><p class="calibre8">It will print the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">number is even ? true</strong></span>
</pre></div><p class="calibre8">All of us <a id="id118" class="calibre1"/>would remember adding <code class="literal">+ "\\n"</code> at the end of every line in order to produce multiline strings in Java. Gone are those days, as Groovy supports multiline string literals. The multiline literal starts off with three single or double quotes (the same string versus the GString functionality) and ends with three single or double quotes:</p><div class="informalexample"><pre class="programlisting">def multilineString = '''\
    Hello
    World
'''
println multilineString</pre></div><p class="calibre8">It will print the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">    Hello</strong></span>
<span class="strong"><strong class="calibre9">    World</strong></span>
</pre></div><p class="calibre8">The forward slash on line number 1 is optional and is used to exclude the first new line. If we do not put the forward slash, we would have an additional new line in the beginning of the output.</p><p class="calibre8">Also, look at the <code class="literal">stripMargin</code> and <code class="literal">stripIndent</code> methods for the special handling of leading whitespaces.</p><p class="calibre8">If our literal contains a lot of escape characters (for example, regex), then we are better off using a "slashy" string literal, which starts and ends with a single forward slash (<code class="literal">/</code>):</p><div class="informalexample"><pre class="programlisting">def r = /(\d)+/
println r.class</pre></div><p class="calibre8">It will prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">class java.lang.String</strong></span>
</pre></div><p class="calibre8">In the above example, if we had to use a regular string, then we would have to escape the backslash before the character class <code class="literal">d</code>. It would have looked as follows:</p><div class="informalexample"><pre class="programlisting">"(\\d)+"</pre></div></div><div class="book" title="Regular expressions"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec05" class="calibre1"/>Regular expressions</h4></div></div></div><p class="calibre8">Groovy<a id="id119" class="calibre1"/> supports a pattern operator (<code class="literal">~</code>), which when applied to a string, gives a pattern object:</p><div class="informalexample"><pre class="programlisting">def pattern = ~/(\d)+/
println pattern.class</pre></div><p class="calibre8">It prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">class java.util.regex.Pattern</strong></span>
</pre></div><p class="calibre8">We can also use the find operator to directly match a string to a pattern:</p><div class="informalexample"><pre class="programlisting">if ("groovy" ==~ /gr(.*)/)
  println "regex support rocks"</pre></div><p class="calibre8">It will print the following:</p><div class="informalexample"><pre class="programlisting">regex support rocks</pre></div></div><div class="book" title="Closures"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec06" class="calibre1"/>Closures</h4></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre9">Closure</strong></span>
<a id="id120" class="calibre1"/> in Groovy<a id="id121" class="calibre1"/> is a block of code that can be assigned to a reference or passed around just like any other variable. The concept is known as <span class="strong"><strong class="calibre9">lambda</strong></span>
<a id="id122" class="calibre1"/> in many other languages, including Java 8 or function pointers.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">Lambdas have been supported since Java 8, but the syntax is a bit different than that of Groovy's closures. You don't need to be on Java 8 to use closure in Groovy.</p></div><p class="calibre8">If we have no exposure to any of the above, then some detailed reading will be required to understand the concept well because it lays the foundation for many other advanced topics going forward. Closure is a huge topic in itself and an in-depth discussion is beyond the scope of this book.</p><p class="calibre8">Closure is almost like a regular method or function, but it can also be assigned to a variable. Also, as it can be assigned to a variable, it must be an object as well; hence, it will have methods on itself:</p><div class="informalexample"><pre class="programlisting">def cl1 = {
    println "hello world!"
}</pre></div><p class="calibre8">Here, the code block is being assigned to a variable called <code class="literal">cl1</code>. Now the code block can be executed using the call method in the future or the <code class="literal">cl1</code> variable can be passed around and executed later:</p><div class="informalexample"><pre class="programlisting">cl1.call()</pre></div><p class="calibre8">No wonder it prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">hello world!</strong></span>
</pre></div><p class="calibre8">As closures are like methods, they can also accept parameters:</p><div class="informalexample"><pre class="programlisting">def cl2 = { n -&gt;
    println "value of param : $n"
}
cl2.call(101)</pre></div><p class="calibre8">It prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">value of param : 101</strong></span>
</pre></div><p class="calibre8">Just like <a id="id123" class="calibre1"/>methods, they can also return values. The last expression of closure is automatically returned if no explicit <code class="literal">return</code> statement is declared.</p><p class="calibre8">Closures start shining when we have methods that accept closures. For example, the <code class="literal">times</code> method is available on integer, which takes in a closure and executes it as many number times as the value of the integer itself; with every call, it passes the current value as if we were looping up to the value from <code class="literal">0</code>:</p><div class="informalexample"><pre class="programlisting">3.times(cl2)</pre></div><p class="calibre8">It prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">value of param : 0</strong></span>
<span class="strong"><strong class="calibre9">value of param : 1</strong></span>
<span class="strong"><strong class="calibre9">value of param : 2</strong></span>
</pre></div><p class="calibre8">We can also inline the block and pass it directly to a method:</p><div class="informalexample"><pre class="programlisting">3.times { println it * it }</pre></div><p class="calibre8">It prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">0</strong></span>
<span class="strong"><strong class="calibre9">1</strong></span>
<span class="strong"><strong class="calibre9">4</strong></span>
</pre></div><p class="calibre8">There is a special variable called <code class="literal">it</code>, which is available in the blocks scope if the closure doesn't define its parameter. In the preceding example, we accessed the number being passed to the block using <code class="literal">it</code> and multiplied it by itself to obtain its square.</p><p class="calibre8">Closures are extremely useful in situations such as callback handling, whereas in Java 7 and lower, we would have to use anonymous interface implementation to achieve the same result.</p></div></div><div class="book" title="Data structures"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec12" class="calibre1"/>Data structures</h3></div></div></div><p class="calibre8">Groovy <a id="id124" class="calibre1"/>supports literal declaration of the often-used<a id="id125" class="calibre1"/> data structures, which makes the code a lot more terse without sacrificing readability.</p><div class="book" title="List"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec07" class="calibre1"/>List</h4></div></div></div><p class="calibre8">Groovy <a id="id126" class="calibre1"/>backs on the thoroughly tested Java Collection API and uses the same classes under the hood, but with some extra methods and syntactic sugar:</p><div class="informalexample"><pre class="programlisting">def aList = []
println aList.getClass()</pre></div><p class="calibre8">It prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">class java.util.ArrayList</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">In Groovy, <code class="literal">[]</code> is actually a Java's <code class="literal">List</code> instance and not an array.</p></div><p class="calibre8">Let's create another list with some initial content:</p><div class="informalexample"><pre class="programlisting">def anotherList = ['a','b','c']</pre></div><p class="calibre8">Thanks to operator overloading, we can use many of the operators intuitively on the list. For example, using <code class="literal">anotherList[1]</code> will give us <code class="literal">b</code>.</p><p class="calibre8">The following are some more examples of handy operators. This adds two lists and assigns the result to the list variable:</p><div class="informalexample"><pre class="programlisting">def list = [10, 20, 30] + [40, 50]</pre></div><p class="calibre8">This appends <code class="literal">60</code> to the list:</p><div class="informalexample"><pre class="programlisting">list  &lt;&lt;  60 </pre></div><p class="calibre8">The following two examples simply subtracts a list from another list:</p><div class="informalexample"><pre class="programlisting">list = list – [20, 30, 40] 
list  -= [20,30,40]</pre></div><p class="calibre8">Iterating over a list is equally simple and intuitive:</p><div class="informalexample"><pre class="programlisting">list.each {println it}</pre></div><p class="calibre8">It will print the following</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">10</strong></span>
<span class="strong"><strong class="calibre9">50</strong></span>
<span class="strong"><strong class="calibre9">60</strong></span>
</pre></div><p class="calibre8">The closure passed to <code class="literal">each</code> is executed for each element of the list, with the element as a parameter <a id="id127" class="calibre1"/>to closure. So, the preceding code iterates over the list and prints the value of each element. Notice the usage of <code class="literal">it</code>, which is a handle to the current element of the list.</p></div><div class="book" title="Set"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec08" class="calibre1"/>Set</h4></div></div></div><p class="calibre8">Defining a <a id="id128" class="calibre1"/>set is similar to that of a list, but in addition, we have to use <code class="literal">as Set</code>:</p><div class="informalexample"><pre class="programlisting">def aSet = [1,2,3] <span class="strong"><strong class="calibre9">as Set</strong></span>
println aSet.class</pre></div><p class="calibre8">This will print the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">class java.util.LinkedHashSet</strong></span>
</pre></div><p class="calibre8">As the implementation class selected is <code class="literal">LinkedHashSet</code>, <code class="literal">aSet</code> will maintain the insertion order.</p><p class="calibre8">Alternatively, declare the type of variable to get the correct implementation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">TreeSet</strong></span> anotherSet = [1,2,3]
println anotherSet.class</pre></div><p class="calibre8">This prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">class java.util.TreeSet</strong></span>
</pre></div><p class="calibre8">Adding elements to a set is just like a list using an indirection operator. Other set interface methods are also available:</p><div class="informalexample"><pre class="programlisting">aSet &lt;&lt; 4
aSet &lt;&lt; 3
println aSet</pre></div><p class="calibre8">This prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[1, 2, 3, 4]</strong></span>
</pre></div><p class="calibre8">We don't see the entry <code class="literal">4</code> twice as the collection is a set implementation, which by definition eliminates duplicates.</p></div><div class="book" title="Map"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec09" class="calibre1"/>Map</h4></div></div></div><p class="calibre8">Map is one <a id="id129" class="calibre1"/>of the most important data structures for any dynamic language. Hence, it gets a deserved place in Groovy's syntax. Map can be declared using the map literal <code class="literal">[:]</code>:</p><div class="informalexample"><pre class="programlisting">def a = [:]</pre></div><p class="calibre8">The implementation chosen by default is <code class="literal">java.util.LinkedHashMap</code>, which preserves the insertion order:</p><div class="informalexample"><pre class="programlisting">def tool = [version:'2.8', name:'Gradle', platform:'all']</pre></div><p class="calibre8">Note that the keys are not string literals, but they get automatically converted to a string:</p><div class="informalexample"><pre class="programlisting">println tool.name
println tool["version"]
println tool.get("platform")</pre></div><p class="calibre8">We can access<a id="id130" class="calibre1"/> the values by using both the subscript and dot operator, in addition to the plain old <code class="literal">get()</code> method.</p><p class="calibre8">We can put and update data in map using the subscript and dot operator and, of course, the good old <code class="literal">put()</code>:</p><div class="informalexample"><pre class="programlisting">tool.version = "2.9"
tool["releaseDate"] = "2015-11-17"
tool.put("platform", "ALL")</pre></div></div></div><div class="book" title="Methods"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec13" class="calibre1"/>Methods</h3></div></div></div><p class="calibre8">The <a id="id131" class="calibre1"/>following<a id="id132" class="calibre1"/> is more of a Java-like method, which is of course a valid Groovy method:</p><div class="informalexample"><pre class="programlisting">int sum(int a, int b) {
  return a + b;
}</pre></div><p class="calibre8">The preceding method can be succinctly rewritten as follows:</p><div class="informalexample"><pre class="programlisting">def sum(a, b) {
  a + b
}</pre></div><p class="calibre8">Instead of specifying the return type, we just declared <code class="literal">def</code>, which effectively means the method can return any <code class="literal">Object</code> or subclass reference. Then, we omitted the type of the formal parameter, as declaring <code class="literal">def</code> is optional for formal parameters to a method. On line number 2, we omitted the <code class="literal">return</code> statement as the evaluation of the last expression is automatically returned by a method. We also omitted the semicolon as it's optional.</p><p class="calibre8">Both the examples are valid Groovy method declarations. However, readers are advised to choose types<a id="id133" class="calibre1"/> wisely as they provide type safety and act as a living documentation for methods. If we don't declare types of parameters, as in the preceding method, the sum (1,"2") will also become a valid method call, and worse, it returns an unexpected result without any exceptions.</p><div class="book" title="Calling methods"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec10" class="calibre1"/>Calling methods</h4></div></div></div><p class="calibre8">A method call<a id="id134" class="calibre1"/> in Groovy can omit the parenthesis is many cases. Both of the following cases are valid method calls.</p><div class="informalexample"><pre class="programlisting">sum(1,2)  
sum 1, 2  </pre></div></div><div class="book" title="Default values of parameters"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec11" class="calibre1"/>Default values of parameters</h4></div></div></div><p class="calibre8">Many<a id="id135" class="calibre1"/> a time, we want to make a parameter optional by providing a default value so that if the caller does not provide the value, the default value will be used. Take a look at the following example:</p><div class="informalexample"><pre class="programlisting">def divide(number, by=2) {
    number/by
}

println divide (10, 5)
println divide (10)</pre></div><p class="calibre8">It prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">2</strong></span>
<span class="strong"><strong class="calibre9">5</strong></span>
</pre></div><p class="calibre8">If we provide the value of the <code class="literal">by</code> parameter that will be used, the default value <code class="literal">2</code> will be assumed for the parameter.</p></div><div class="book" title="Methods with map parameters/named parameters"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec12" class="calibre1"/>Methods with map parameters/named parameters</h4></div></div></div><p class="calibre8">Groovy<a id="id136" class="calibre1"/> does not support named parameters such as Python, but Map provides a very close approximation to the same functionality:</p><div class="informalexample"><pre class="programlisting">def method(Map options) {
    def a = options.a ?: 10
    def b = options.b ?: 20
}</pre></div><p class="calibre8">In the preceding code, we expect the map to contain keys <code class="literal">a</code> and <code class="literal">b</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">On line number 2 and 3, notice the elvis operator <code class="literal">?:</code>, which returns the left hand side value, if value exists and is <span class="strong"><em class="calibre10">truthy</em></span>; otherwise returns the right hand side (default) value. It is basically short hand for the following code:</p><div class="informalexample"><pre class="programlisting">options.a ? options.a : 10</pre></div></div><p class="calibre8">Now, this method <a id="id137" class="calibre1"/>can be called as follows:</p><div class="informalexample"><pre class="programlisting">method([a:10,b:20])</pre></div><p class="calibre8">We can omit the square brackets (<code class="literal">[]</code>) because maps have special support in the method call:</p><div class="informalexample"><pre class="programlisting">method(a:10, b:20)</pre></div><p class="calibre8">Now, it clearly looks like the named parameters. The order of parameters is not important and all the parameters need not be passed. Also, the parenthesis wrapping is optional, just like any method call:</p><div class="informalexample"><pre class="programlisting">method b:30, a:40
method b:30</pre></div></div><div class="book" title="Methods with varags"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec13" class="calibre1"/>Methods with varags</h4></div></div></div><p class="calibre8">Like in<a id="id138" class="calibre1"/> Java, varags are denoted by <code class="literal">...</code>, but providing the type is optional:</p><div class="informalexample"><pre class="programlisting">def sumSquares(...numbers) {
    numbers.collect{ it * it }.sum()
}
sumSquares 1, 2, 3</pre></div><p class="calibre8">In the preceding examples, numbers are arrays, which have the <code class="literal">collect</code> method that accepts a closure and transforms each element of the collection in order to produce a new collection. In this case, we transform numbers in the collection of squares. Finally, we use the in-built sum method to sum all the squares.</p></div><div class="book" title="Methods with closure params"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec14" class="calibre1"/>Methods with closure params</h4></div></div></div><p class="calibre8">Closures<a id="id139" class="calibre1"/> are important and, hence, Groovy has a special syntax for closures if the closure is the last parameter of a method signature:</p><div class="informalexample"><pre class="programlisting">def myMethod (param, cls) {
    ...
}</pre></div><p class="calibre8">Then, this method can be called as follows:</p><div class="informalexample"><pre class="programlisting">myMethod(1,{ ... })
myMethod 2, {... }
myMethod(3) {...}</pre></div><p class="calibre8">Out of these, the <a id="id140" class="calibre1"/>third one is the special syntactical support in which the parenthesis just wraps the other parameters, while the closure is written outside the parenthesis, as if it were a method body.</p></div></div><div class="book" title="Classes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec14" class="calibre1"/>Classes</h3></div></div></div><p class="calibre8">Classes<a id="id141" class="calibre1"/> in Groovy are declared just like Java classes, but with a lot <a id="id142" class="calibre1"/>lesser ceremony. Classes are public by default. They can inherit from other classes using <code class="literal">extends</code> or implementing interfaces using <code class="literal">implmenets</code>.</p><p class="calibre8">The following is the definition of a very simple class, <code class="literal">Person</code>, having two properties, <code class="literal">name</code> and <code class="literal">age</code>:</p><div class="informalexample"><pre class="programlisting">class Person {
  def name, age
}</pre></div><p class="calibre8">Instead of using the <code class="literal">def</code> for properties, we can use more specific types.</p><div class="book" title="Constructors"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec15" class="calibre1"/>Constructors</h4></div></div></div><p class="calibre8">In addition<a id="id143" class="calibre1"/> to the default constructor, classes in Groovy get a special constructor, which takes the map of properties of the class. Here is how we use it:</p><div class="informalexample"><pre class="programlisting">def person = new Person(name:"John Doe", age:35)</pre></div><p class="calibre8">In the preceding code, we have created the <code class="literal">person</code> object using the special constructor. The parameters are key-value pairs where the keys are the name of the properties in the class. The values provided for the keys will be set for the corresponding properties.</p></div><div class="book" title="Properties"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec16" class="calibre1"/>Properties</h4></div></div></div><p class="calibre8">Groovy <a id="id144" class="calibre1"/>has language-level support for properties. In the preceding class, <code class="literal">name</code> and <code class="literal">age</code>, unlike Java, are not just fields, but are also properties of the class with their getters and setters in place. Fields are private by default and their public accessors and mutators (getters and setters) are generated automatically.</p><p class="calibre8">We can call the <code class="literal">getAge()</code>/<code class="literal">setAge()</code> and <code class="literal">getName()</code>/<code class="literal">setName()</code> methods on the <code class="literal">person</code> object that we created above. However, there is an even more succinct way to do so. We can access <a id="id145" class="calibre1"/>properties just as if they were public fields, but behind the scenes, Groovy routes it through the getters and setters. Let's try:</p><div class="informalexample"><pre class="programlisting">println person.age
person.age = 36
println person.age</pre></div><p class="calibre8">It prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">35</strong></span>
<span class="strong"><strong class="calibre9">36</strong></span>
</pre></div><p class="calibre8">In the preceding code, on line number 1, <code class="literal">person.age</code> is actually a call to <code class="literal">person.getAge()</code> and, hence, it returns the age of the person. Then, we updated the age using <code class="literal">person.age</code> with an assignment operator and value on the right-hand side. We did not update the field, but it internally passes through the setter <code class="literal">setAge()</code>. This is only possible because groovy offers syntactical support for properties.</p><p class="calibre8">We can provide our own getters and/or setter for the desired fields, which will take precedence over the generated one, but it is only necessary if we have some logic to write in those. For example, if we want to have one positive value of age to be set, then we can provide our own <code class="literal">setAge()</code> implementation, and this will be used whenever the property is updated:</p><div class="informalexample"><pre class="programlisting">  void setAge(age){
    if (age &lt; 0) 
      throw new IllegalArgumentException("age must be a positive number")
    else
      this.age = age
  }</pre></div><p class="calibre8">The support for properties results in the significant reduction of the boilerplate code from class definitions and enhances readability.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip20" class="calibre1"/>Tip</h3><p class="calibre8">Properties are first-class citizens in Groovy. Going forward, whenever we refer to property, do not get confused between properties and fields.</p></div></div><div class="book" title="Instance methods"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec17" class="calibre1"/>Instance methods</h4></div></div></div><p class="calibre8">We can <a id="id146" class="calibre1"/>add an instance and static methods to classes just like we do in Java:</p><div class="informalexample"><pre class="programlisting">def speak(){
  println "${this.name} speaking"
}</pre></div><div class="informalexample"><pre class="programlisting">static def now(){
  new Date().format("yyyy-MM-dd HH:mm:ss")
}</pre></div><p class="calibre8">The methods <a id="id147" class="calibre1"/>section, as we discussed above, did not use classes, but applied as-is for the methods inside classes.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre9">Scripts are classes</strong></span>
</p><p class="calibre8">In fact, the methods that we discussed above were inside a class and they were not free-floating functions. As scripts get translated to classes transparently, it feels as if we were using functions.</p></div><p class="calibre8">I am sure you have enjoyed Groovy so far. There is a lot more to cover in Groovy, but we have to switch back our focus to Gradle. However, I hope to have generated enough curiosity about Groovy so that you can appreciate it as a language and explore more of it on your own. There are a few good resources included in the references section.</p></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Demystifying Build Scripts">
<div class="book" title="Groovy for Gradle build scripts">
<div class="book" title="Another look at applying plugins"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec34" class="calibre1"/>Another look at applying plugins</h2></div></div></div><p class="calibre8">Now that we <a id="id148" class="calibre1"/>have learned about basic Groovy, let's put it to use in the context of the Gradle build script. In earlier chapters, we have already seen the syntax of applying a plugin. It looked something as follows:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'</pre></div><p class="calibre8">If we look carefully, <code class="literal">apply</code> is a method call. We can wrap the parameters in the parenthesis:</p><div class="informalexample"><pre class="programlisting">apply(plugin: 'java')</pre></div><p class="calibre8">A method that takes in a map can pass key values just like named arguments. However, for a more clear representation of Map, we can wrap the parameters in <code class="literal">[]</code>:</p><div class="informalexample"><pre class="programlisting">apply([plugin: 'java'])</pre></div><p class="calibre8">Finally, the <code class="literal">apply</code> method is implicitly applied on the <code class="literal">project</code> object (we will soon see this in the upcoming sections in this chapter). So, we can also call it on the <code class="literal">project</code> object's reference:</p><div class="informalexample"><pre class="programlisting">project.apply([plugin: 'java'])</pre></div><p class="calibre8">So, from the <a id="id149" class="calibre1"/>preceding example, we can see that the statement that applies a plugin to project is merely a syntactic sugar to what is a method call on the <code class="literal">project</code> object. We are just writing Groovy code using Gradle API. Also, once we realize that, our perspective towards understanding the build script syntax changes for good.</p></div></div></div>
<div class="book" title="Gradle &#x2013; an object-oriented build tool" id="RL0A1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec22" class="calibre1"/>Gradle – an object-oriented build tool</h1></div></div></div><p class="calibre8">If we were to think of <a id="id150" class="calibre1"/>a build system in an object-oriented way, the following classes will immediately come to our minds:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A <code class="literal">project</code> that represents a system that is being built</li><li class="listitem">A <code class="literal">task</code> that encapsulates pieces of build logics that need to be performed</li></ul></div><p class="calibre8">Well, we are lucky. As we might expect, Gradle creates objects of both <code class="literal">project</code> and <code class="literal">task</code> types. These objects are accessible in our build script for us to customize. Of course, the underlying implementation is non-trivial and the API is very sophisticated.</p><p class="calibre8">A <code class="literal">project</code> object is a central piece of API that is exposed to and configured via the build scripts. A <code class="literal">project</code> object is available in the script such that the methods without object reference are intelligently invoked on the <code class="literal">project</code> object. We have just seen an example of this in the last section. Most of the build script syntax can be understood by just reading the project API.</p><p class="calibre8">The <code class="literal">task</code> objects are created for each task declared directly in the build file and also for plugins. We have already created a very simple task in <a class="calibre1" title="Chapter 1. Running Your First Gradle Task" href="part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 1</a>, <span class="strong"><em class="calibre10">Running Your First Gradle Task</em></span> and used tasks coming from plugins in <a class="calibre1" title="Chapter 2. Building Java Projects" href="part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 2</a>, <span class="strong"><em class="calibre10">Building Java Projects</em></span>, and <a class="calibre1" title="Chapter 3. Building a Web Application" href="part0024_split_000.html#MSDG2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 3</a>, <span class="strong"><em class="calibre10">Building a Web Application</em></span>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre8">As we have seen, some tasks are already available in our build without us having to add a single line to our build file (such as the <code class="literal">help</code> task and the <code class="literal">tasks</code> task, and so on). Even for these tasks, we would have task objects.</p></div><p class="calibre8">We will soon see how and when these objects are created.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Build phases" id="SJGS1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>Build phases</h1></div></div></div><p class="calibre8">A <a id="id151" class="calibre1"/>Gradle build follows a very simple life cycle on every invocation. The <a id="id152" class="calibre1"/>build passes through three stages: initialization, configuration, and execution. When a <code class="literal">gradle</code> command is invoked, not all the code written in our build file executes sequentially from top to bottom. Only the blocks of code that are relevant to the current phase of the build are executed. Also, the build phase's order determines when the block of code will execute. An example is the task configuration versus task execution. Understanding of these phases is important to correctly configure our build.</p></div>

<div class="book" title="Build phases" id="SJGS1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Initialization"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec35" class="calibre1"/>Initialization</h2></div></div></div><p class="calibre8">Gradle <a id="id153" class="calibre1"/>first figures out whether the current project has child projects or if it is the only project in the build. For multiprojects build, Gradle figures out which projects (or sub-module, as many prefer to call them) have to be included in the build. We will see multiproject builds in the next chapter. Gradle then creates a <code class="literal">Project</code> instance for the root project and for each of the child projects of a project. For single module projects that we have seen so far, there is not much to configure in this phase.</p></div></div>

<div class="book" title="Build phases" id="SJGS1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Configuration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec36" class="calibre1"/>Configuration</h2></div></div></div><p class="calibre8">In this<a id="id154" class="calibre1"/> phase, the build scripts of participating projects are evaluated against the corresponding project object that was created during the initialization phase. In the case of multimodule projects, evaluation happens in breadth-wise fashion, that is, all the sibling projects will be evaluated and configured before child projects. However, this behavior is configurable.</p><p class="calibre8">Note that executing the scripts does not mean that the tasks are also executed. To quickly verify this, we can just put a <code class="literal">println</code> statement in the <code class="literal">build.gradle</code> file and also create a task that prints a message:</p><div class="informalexample"><pre class="programlisting">task myTask &lt;&lt; {
  println "My task is executed"
}
// The following statement will execute before any task 
println "build script is evaluated"</pre></div><p class="calibre8">If we execute the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q myTask</strong></span>
</pre></div><p class="calibre8">We would see the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">build script is evaluated</strong></span>
<span class="strong"><strong class="calibre9">My task is executed</strong></span>
</pre></div><p class="calibre8">In fact, choose any in-built task as well, such as <code class="literal">help</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q help</strong></span>
</pre></div><p class="calibre8">We would still see our <code class="literal">build script is evaluated</code> message before any task is executed. Why is that?</p><p class="calibre8">When a script <a id="id155" class="calibre1"/>is evaluated, all the statements in the script are executed sequentially. That's why the <code class="literal">println</code> statement at the root level gets executed. A task action, if you notice, is actually a closure; hence, it is only attached to a task during the statement execution. However, the closure itself is not executed yet. The statements inside the action closure executes only if the task is executed, which happens only in the next phase.</p><p class="calibre8">Tasks are only configured during this stage. No matter what tasks are going to be called, all tasks will be configured. Gradle prepares a <a id="id156" class="calibre1"/>
<span class="strong"><strong class="calibre9">Directed Acyclic Graph</strong></span> (<span class="strong"><strong class="calibre9">DAG</strong></span>) representation of the tasks to determine the task dependency and execution order.</p></div></div>

<div class="book" title="Build phases" id="SJGS1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Execution"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec37" class="calibre1"/>Execution</h2></div></div></div><p class="calibre8">In this<a id="id157" class="calibre1"/> phase, Gradle figures out which tasks need to be run based on the parameters such as task names passed as command line arguments and the current directory. This is where tasks' actions will be performed. Hence, here, the action closures will actually execute if the task is to run.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre8">On subsequent invocations, Gradle intelligently determines which tasks need to actually run and which can be skipped. For example, for a compile task, there is no point in compiling again if there is no change in the source file after the last build. In such a case, the execution may be skipped. We can see such tasks in the output tagged as <code class="literal">UP-TO-DATE</code>:</p><div class="informalexample"><pre class="programlisting">:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:compileTestJava UP-TO-DATE
:processTestResources UP-TO-DATE
:testClasses UP-TO-DATE
:test UP-TO-DATE</pre></div><p class="calibre8">In the preceding output, as there was no change from the previous build, Gradle actually skipped every task. However, this will not happen for a custom task that we write, unless we tell Gradle the logic for figuring out whether the task needs execution or not.</p></div></div></div>

<div class="book" title="Build phases" id="SJGS1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Life cycle callbacks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec38" class="calibre1"/>Life cycle callbacks</h2></div></div></div><p class="calibre8">Gradle<a id="id158" class="calibre1"/> provides various hooks for executing code at various points during life cycle events. We can implement callback interfaces or provide callback closure to DSL in the build script. For example, we can listen for events such as the before and after project evaluation using the <code class="literal">beforeEvaluate</code> and <code class="literal">afterEvaluate</code> methods on <code class="literal">project</code>. We are not going to look at them individually, but the <code class="literal">Project</code> and <code class="literal">Gradle</code> (the interface name is not to be confused with the tool's name itself) APIs and the DSL documentation is the right place to check out the available callbacks, if we feel the need to implement life cycle callbacks.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Gradle Project API" id="TI1E1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Gradle Project API</h1></div></div></div><p class="calibre8">As discussed earlier, Gradle <a id="id159" class="calibre1"/>creates a <code class="literal">project</code> object for each <code class="literal">build.gradle</code> for us during the initialization phase. This object is available in our build scripts using the <code class="literal">project</code> reference. Being a central piece of API, there are numerous methods and properties available on this object.</p></div>

<div class="book" title="Gradle Project API" id="TI1E1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Project methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec39" class="calibre1"/>Project methods</h2></div></div></div><p class="calibre8">We have been using the <a id="id160" class="calibre1"/>project API even without realizing that we are calling methods on the <code class="literal">project</code> object. Based on a few governing rules, all the top-level method calls in the build scripts are called on a project object if no explicit reference is provided.</p><p class="calibre8">Let's rewrite the very simple build file from <a class="calibre1" title="Chapter 1. Running Your First Gradle Task" href="part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 1</a>, <span class="strong"><em class="calibre10">Running Your First Gradle Task</em></span> to use the project reference for method calls:</p><div class="informalexample"><pre class="programlisting">project.apply plugin: 'java'

project.repositories {
    mavenCentral()
}

project.dependencies {
    testCompile 'junit:junit:4.11'
}</pre></div><p class="calibre8">As we saw earlier in this chapter, <code class="literal">apply</code> <a id="id161" class="calibre1"/>is the method on the <code class="literal">project</code>. The so-called <code class="literal">dependencies</code> block is actually a method named <code class="literal">dependencies()</code> on <code class="literal">project</code> that accepts a closure. It is true for the <code class="literal">repositories</code> section as well. We can add parenthesis around the closure block to make it look like a plain old method call:</p><div class="informalexample"><pre class="programlisting">project.repositories({...})
project.dependencies({...})</pre></div><p class="calibre8">There are many more interesting methods on this object, which we will see in the upcoming sections and chapters, again, with or without explicit reference to the <code class="literal">project</code> object.</p><div class="book" title="Project properties"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec15" class="calibre1"/>Project properties</h3></div></div></div><p class="calibre8">There <a id="id162" class="calibre1"/>are several properties available on the <code class="literal">project</code> object. Some properties are read-only properties, such as <code class="literal">name</code>, <code class="literal">path</code>, <code class="literal">parent</code>, and so on, while others are both readable and writable.</p><p class="calibre8">For example, we can set <code class="literal">project.description</code> to provide a description of our project. We can use the <code class="literal">project.version</code> property to set the version of the project. This version will be used by other tasks such as <code class="literal">Jar</code> to include a version number in the produced artifact.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre8">We cannot change the <code class="literal">project.name</code> from the <code class="literal">build.gradle</code> file, but we can use <code class="literal">settings.gradle</code> in the same project to set the project name. We will see this file in more detail when we learn about multi-project builds.</p></div><p class="calibre8">Apart from directly accessing a property by its name, we can access properties using the following methods on the <code class="literal">project</code> object.</p><p class="calibre8">To check whether a property exists, use the following method:</p><div class="informalexample"><pre class="programlisting">boolean hasProperty(String propertyName)</pre></div><p class="calibre8">To get the value of a property for a given property name, use the following method:</p><div class="informalexample"><pre class="programlisting">Object property(String propertyName)</pre></div><p class="calibre8">To set the value of a property for a given property name, use the following method:</p><div class="informalexample"><pre class="programlisting">void setProperty(String name, Object value)</pre></div><p class="calibre8">For example, let's create a <code class="literal">build.gradle</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">description = "a sample project"
version = "1.0"

task printProperties &lt;&lt; {
    println project.version
    println project.property("description")
}</pre></div><p class="calibre8">Execute the following task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q printProperties</strong></span>
<span class="strong"><strong class="calibre9">1.0</strong></span>
<span class="strong"><strong class="calibre9">a sample project</strong></span>
</pre></div><p class="calibre8">As seen<a id="id163" class="calibre1"/> earlier, in Groovy, we can use the <code class="literal">property = value</code> syntax to call a setter. We are setting the <code class="literal">description</code> and <code class="literal">version</code> properties on the <code class="literal">project</code> object. Then, we add a task with the task action that prints the version using the <code class="literal">project</code> reference and <code class="literal">description</code> using the <code class="literal">property()</code> method on the <code class="literal">project</code> object.</p><p class="calibre8">The properties that we have seen above must exist on the project, otherwise build fails with a <code class="literal">Could not find property … </code> message.</p></div><div class="book" title="Extra properties on a project"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec16" class="calibre1"/>Extra properties on a project</h3></div></div></div><p class="calibre8">Gradle <a id="id164" class="calibre1"/>makes it very easy to store user-defined properties on a project, while still being able to enjoy the niceties of project properties' syntax. All we have to do is to use the <code class="literal">ext</code> namespace to assign a value to a custom property. Then, this property can be accessed on a project just like regular project properties. Here is an example:</p><div class="informalexample"><pre class="programlisting">ext.abc = "123"
task printExtraProperties &lt;&lt; {
    println project.abc
    println project.property("abc")
    println project.ext.abc
}</pre></div><p class="calibre8">Execute the following task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q printExtraProperties</strong></span>
<span class="strong"><strong class="calibre9">123</strong></span>
<span class="strong"><strong class="calibre9">123</strong></span>
<span class="strong"><strong class="calibre9">123</strong></span>
</pre></div><p class="calibre8">In the preceding example, we declared a custom property called <code class="literal">abc</code> and assigned it the value <code class="literal">123</code>. We did not use the <code class="literal">project</code> reference as it is implicitly available at the script root level. In the task action, we printed it first using a project reference directly, just as if it were a property on <code class="literal">Project</code>. Then, we accessed using the <code class="literal">property()</code> method and also using the <code class="literal">project.ext</code> reference. Note that inside tasks' action closure, we should use the <code class="literal">project</code> reference to avoid any ambiguity.</p><p class="calibre8">Extra properties<a id="id165" class="calibre1"/> will be accessible in the sub-projects (modules). Extra properties can be set on other objects as well.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre8">We could have just used the local variable by declaring it with <code class="literal">def</code>. However, such variables are not accessible outside the lexical scope. Also, they are not queriable.</p></div><p class="calibre8">Although we have looked at a few methods and properties, it's impractical to cover all of those here; hence, it is worth spending some time reading the API and the DSL documentation of the <code class="literal">project</code> interface.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Tasks"><div class="book" id="UGI02-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec25" class="calibre1"/>Tasks</h1></div></div></div><p class="calibre8">As we <a id="id166" class="calibre1"/>have seen so far, a <code class="literal">task</code> is a named action that performs some build logic. It's a unit of build work. For example, <code class="literal">clean</code>, <code class="literal">compile</code>, <code class="literal">dist</code>, and so on, are typical build tasks that easily come to our mind if we have to write tasks for our project. Tasks are more or less analogous to Ant's targets.</p><p class="calibre8">The simplest way to create a task is as follows:</p><div class="informalexample"><pre class="programlisting">task someTask</pre></div><p class="calibre8">Before we go any further with tasks, let's take a moment to ponder about task creation.</p><p class="calibre8">We used the <code class="literal">taskName</code> task form of a statement.</p><p class="calibre8">If we rewrite it as a <code class="literal">task (taskName)</code>, it will immediately look like the method call.</p><p class="calibre8">The preceding method, as we might have already guessed by now, is available on the project object.</p><p class="calibre8">So, we could write one of the following as well:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">project.task "myTask"</code></li><li class="listitem"><code class="literal">project.task("myTask")</code> </li></ul></div><p class="calibre8">Notice that in the later examples we had to pass the task name as a string. The <code class="literal">task taskName</code> is a special form where we can use <code class="literal">taskName</code> as a literal instead of string. This is done by Groovy AST transformation magic.</p><p class="calibre8">The project has several flavors of a task method to create a task object:</p><div class="informalexample"><pre class="programlisting">Task task(String name)

Task task(String name, Closure configureClosure)

Task task(Map&lt;String, ?&gt; args, String name)

Task task(Map&lt;String, ?&gt; args, String name, Closure configureClosure)</pre></div><p class="calibre8">However, in <a id="id167" class="calibre1"/>essence, we may pass some key values as named parameters while creating a task and a configuration closure to configure the task.</p><p class="calibre8">We are essentially creating an object of the type <code class="literal">Task</code> (the exact class name is not important right now). We can query the properties and call methods on this object. Gradle nicely makes this <code class="literal">task</code> object available for use. Behind the nice DSL, we are actually writing a script that creates the build logic in a nice object-oriented way.</p></div>

<div class="book" title="Tasks">
<div class="book" title="Attaching actions to a task"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec40" class="calibre1"/>Attaching actions to a task</h2></div></div></div><p class="calibre8">A <code class="literal">Task</code> object, <a id="id168" class="calibre1"/>such as the one created above, does not do much. In fact, there is no action attached to it. We need to attach actions to a <code class="literal">Task</code> object for Gradle to perform those actions when a task is run.</p><p class="calibre8">A <code class="literal">Task</code> object has a method called <code class="literal">doLast</code>, which accepts a closure. Gradle ensures that all the closures passed to this methods are executed in the order they were passed:</p><div class="informalexample"><pre class="programlisting">someTask.doLast({
    println "this should be printed when the task is run"
})</pre></div><p class="calibre8">What we can do now is call <code class="literal">doLast</code> once more:</p><div class="informalexample"><pre class="programlisting">someTask.doLast({
    println "this should ALSO be printed when the task is run"
})</pre></div><p class="calibre8">Also, in an alternate syntax:</p><div class="informalexample"><pre class="programlisting">someTask {
    doLast {
        println "third line that should be printed"
    }
}</pre></div><p class="calibre8">There are multiple ways to add a <code class="literal">doLast</code> logic to a task, but the most idiomatic, and perhaps a terse way is as follows:</p><div class="informalexample"><pre class="programlisting">someTask &lt;&lt; {
    println "the action of someTask"
}</pre></div><p class="calibre8">Just like <a id="id169" class="calibre1"/>the <code class="literal">Project</code> object, we have the <code class="literal">Task</code> object on which methods and properties are accessible. However, unlike the <code class="literal">Project</code> object, it is not implicitly available at the top level in the script, but only inside the task’s configuration scope. Also, intuitively, we can say that there will be multiple <code class="literal">Task</code> objects per <code class="literal">build.gradle</code>. We will see the various ways to access the <code class="literal">Task</code> object later.</p></div></div>

<div class="book" title="Tasks">
<div class="book" title="Task flow control"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec41" class="calibre1"/>Task flow control</h2></div></div></div><p class="calibre8">Tasks<a id="id170" class="calibre1"/> within a <a id="id171" class="calibre1"/>project may have a dependency on each other. In this section, we will see different kinds of relationships that may exist within tasks of a project.</p><div class="book" title="dependsOn"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec17" class="calibre1"/>dependsOn</h3></div></div></div><p class="calibre8">There are<a id="id172" class="calibre1"/> tasks whose execution is dependent on the other task's successful completion. For example, for creating a distributable JAR file, the code should have been compiled first and the "class" files should already exist. In such a case, we don't want the user to explicitly specify all the tasks and their order from the command line, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle compile dist</strong></span>
</pre></div><p class="calibre8">This is error-prone. We may forget to include one task, or the ordering may become complicated if there are multiple tasks that are dependent on the successful completion of the previous tasks. It is desirable to be able to specify if a:</p><div class="informalexample"><pre class="programlisting">task compile &lt;&lt; {
    println 'compling the source'
}

task dist(dependsOn: compile) &lt;&lt; {
    println "preparing a jar dist"
}</pre></div></div><div class="book" title="finalizedBy"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec18" class="calibre1"/>finalizedBy</h3></div></div></div><p class="calibre8">We can also <a id="id173" class="calibre1"/>declare that, if a task is called, it should be followed by another task, even if another task is not explicitly called. This is in contrast to <code class="literal">dependsOn</code>, where another task is executed before the called task. In the case of <code class="literal">finalizedBy</code>, another task is executed after the execution of the called task:</p><div class="informalexample"><pre class="programlisting">task distUsingTemp &lt;&lt; {
  println ("preapring dist using a temp dir")
}

task cleanup &lt;&lt; {
  println("removing tmp dir")
}

distUsingTemp.finalizedBy cleanup</pre></div></div><div class="book" title="onlyIf"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec19" class="calibre1"/>onlyIf</h3></div></div></div><p class="calibre8">We can <a id="id174" class="calibre1"/>specify a condition and if it is satisfied, the task will be executed:</p><div class="informalexample"><pre class="programlisting">cleanup.onlyIf { file("/tmp").exists()}</pre></div></div><div class="book" title="mustRunAfter and shouldRunAfter"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec20" class="calibre1"/>mustRunAfter and shouldRunAfter</h3></div></div></div><p class="calibre8">There are <a id="id175" class="calibre1"/>times when we just want to order tasks in a particular fashion if this relationship is not exactly the same as <code class="literal">dependsOn</code>. For example, if we execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle build clean</strong></span>
</pre></div><p class="calibre8">Then, unrelated <a id="id176" class="calibre1"/>tasks will be executed in the order they were specified on the command line, which in this case doesn't make sense.</p><p class="calibre8">In such a case, we may add the following line of code:</p><div class="informalexample"><pre class="programlisting">build.mustRunAfter clean</pre></div><p class="calibre8">This tells Gradle that, if both the tasks are there in the task graph, then the <code class="literal">build</code> must run after the <code class="literal">clean</code> is run. Here, build does not depend on clean.</p><p class="calibre8">The difference between <code class="literal">shouldRunAfter</code> and <code class="literal">mustRunAfter</code> is that the former is more suggestive to Gradle, but doesn't enforce Gradle to follow the ordering all the time. In the following two cases, <code class="literal">shouldRunAfter</code> may not be honored by Gradle:</p><div class="book"><ul class="itemizedlist"><li class="listitem">In the case when it introduces cyclic ordering.</li><li class="listitem">In the case of parallel execution, when only the <code class="literal">shouldRunAfter</code> task has not yet successfully completed and other dependencies are satisfied, then <code class="literal">shouldRunAfter</code> will be ignored.</li></ul></div></div></div></div>

<div class="book" title="Tasks">
<div class="book" title="Creating tasks dynamically"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec42" class="calibre1"/>Creating tasks dynamically</h2></div></div></div><p class="calibre8">One <a id="id177" class="calibre1"/>of the beauties of Gradle is that we can create tasks dynamically as well. What this means is that the name and the logic of task is not completely known while writing the build, but depending on some variable parameter, the tasks will be automatically added to our Gradle project.</p><p class="calibre8">Let's try to understand with an example:</p><div class="informalexample"><pre class="programlisting">10.times { number -&gt;
  task "dynamicTask$number" &lt;&lt; {
    println "this is dynamic task number # $number "
  }
}</pre></div><p class="calibre8">In the preceding contrived examples, we are creating and adding ten tasks dynamically to our build. Although all of them just print the task number, the ability to dynamically create and add tasks to our project is extremely powerful.</p></div></div>

<div class="book" title="Tasks">
<div class="book" title="Setting default tasks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec43" class="calibre1"/>Setting default tasks</h2></div></div></div><p class="calibre8">So far, we<a id="id178" class="calibre1"/> have always been calling the <code class="literal">gradle</code> command line interface with the task name(s). This is kind of repetitive in nature, especially during development, and a tool such as Gradle gets us covered:</p><div class="informalexample"><pre class="programlisting">defaultTasks "myTaskName", "myOtherTask"</pre></div><p class="calibre8">It is wise to set default tasks so that if we don't specify any task name, the set tasks are executed by default.</p><p class="calibre8">In the preceding example, running <code class="literal">gradle</code> from the command line without any arguments runs the default tasks one after another in the sequence specified in the <code class="literal">defaultTasks</code>.</p></div></div>

<div class="book" title="Tasks">
<div class="book" title="Task types"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec44" class="calibre1"/>Task types</h2></div></div></div><p class="calibre8">The<a id="id179" class="calibre1"/> tasks that we have seen so far were ad-hoc in nature. We had to write the code for the task action that needs to be performed whenever the task executes. However, no matter which project we are building, there are many tasks for which the logic of task action need not change if we have the capability to make some configuration changes to the existing logic. For example, when you copy files, only the source, target, and inclusion/exclusion patterns change, but the actual logic of how to copy files from one location to another honoring the inclusion/exclusion patterns stays the same. So, if there are two copy-like tasks required in a project, let's say <code class="literal">copyDocumentation</code> and <code class="literal">deployWar</code>, would we really want to write an entire logic to copy the selected files twice?</p><p class="calibre8">This would<a id="id180" class="calibre1"/> be okay for very small builds (such as the examples in our chapter), but the approach does not scale well. If we keep on writing task actions to perform these mundane operations, then our build scripts will quickly bloat into an unmanageable state.</p><p class="calibre8">Custom task type is Gradle's solution to abstract out reusable build logic into custom task classes, which expose the input/output configuration variables on the task object. This helps us tune a typed task to suit our specific needs. This helps us keep the common build logic reusable and testable.</p><p class="calibre8">Another problem with ad-hoc task action is that it's imperative in nature. For the sake of flexibility of the tool, Gradle allows us to imperatively script custom logic in build scripts. However, excessive usage of imperative code in our build scripts makes the build script unmaintainable. Gradle should be used in a declarative manner as much as possible. An imperative logic should be encapsulated within a custom task class while exposing the task configuration for the user to configure. In <a id="id181" class="calibre1"/>Gradle's terminology, custom task classes are called <a id="id182" class="calibre1"/>
<span class="strong"><strong class="calibre9">enhanced tasks</strong></span>.</p><p class="calibre8">Custom task types act as a template with some sensible defaults for a common build logic. We still need to declare a task in our build, but we just tell Gradle the type of this task and configure the settings of this task type, instead of writing the entire task action block again. Gradle already ships with many custom task types; for example, <code class="literal">Copy</code>, <code class="literal">Exec</code>, <code class="literal">Delete</code>, <code class="literal">Jar</code>, <code class="literal">Sync</code>, <code class="literal">Test</code>, <code class="literal">JavaCompile</code>, <code class="literal">Zip</code>, and so on. We can easily write our own enhanced tasks as well. We will very briefly see both the scenarios.</p><div class="book" title="Using task types"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec21" class="calibre1"/>Using task types</h3></div></div></div><p class="calibre8">We can<a id="id183" class="calibre1"/> configure a task that is of type <code class="literal">Copy</code> using the following syntax:</p><div class="informalexample"><pre class="programlisting">task copyDocumentation(<span class="strong"><strong class="calibre9">type:Copy</strong></span>) {
from file("src/docs/html")
into file("$buildDir/docs")
}</pre></div><p class="calibre8">In the preceding example, the first important difference is that we are passing a key <code class="literal">type</code> with the value as the custom task's class name, which is <code class="literal">Copy</code> in this case. Also, notice that there is <a id="id184" class="calibre1"/>no <code class="literal">doLast</code> or indirection (<code class="literal">&lt;&lt;</code>) operator. The closure that we are passing to this task actually gets executed in the configuration phase of build. The method calls inside the closure are delegated to the implicitly available <code class="literal">task</code> object, which is being configured. We have not written any logic here, but have just provided the configuration to a task whose type is <code class="literal">Copy</code>. It is always worth taking a look at the available custom tasks before we go ahead with writing ad-hoc task actions.</p></div><div class="book" title="Creating task types"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec22" class="calibre1"/>Creating task types</h3></div></div></div><p class="calibre8">If we<a id="id185" class="calibre1"/> look back now, the code we have been writing for our task actions for our sample tasks was mostly a <code class="literal">println</code> statement that would print the given message on <code class="literal">System.out</code>. Now, just imagine that we found <code class="literal">System.out</code> doesn't fit our bill, and we should rather use text files to print the message from the tasks. We would need to go through all the tasks and change the implementation to write to a file instead of <code class="literal">println</code>.</p><p class="calibre8">There is a better way to handle such changing requirement. We can leverage the capability of the task type here by providing our own task type. Let's put the following code in our <code class="literal">build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">class Print extends DefaultTask {
  @Input
  String message = "Welcome to Gradle"

  @TaskAction
  def print() {
    println "$message"
  }
}

task welcome(type: Print)

task thanks(type: Print) {
  message = "Thanks for trying custom tasks"
}

task bye(type: Print)
bye.message = "See you again"

thanks.dependsOn welcome
thanks.finalizedBy bye</pre></div><p class="calibre8">In the preceding code sample:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We first created a class (which will be our task type) that extends <code class="literal">DefaultTask</code>, which is already defined in Gradle.</li><li class="listitem">Next, we declared a configurable input to our task using <code class="literal">@Input</code> on the property named <code class="literal">message</code>. The consumer of our task can configure this property.</li><li class="listitem">Then, we used the <code class="literal">@TaskAction</code> annotation on the <code class="literal">print</code> method. This method is executed when our task is called. It just uses <code class="literal">println</code> to print the <code class="literal">message</code>.</li><li class="listitem">Then, we declared the three tasks; all using different ways to configure our task. Notice the absence of any task action.</li><li class="listitem">Finally, we applied task flow control techniques to declare task dependencies.</li></ul></div><p class="calibre8">If we run<a id="id186" class="calibre1"/> the <code class="literal">thanks</code> task now, we can see the expected output, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q thanks</strong></span>
<span class="strong"><strong class="calibre9">Welcome to Gradle</strong></span>
<span class="strong"><strong class="calibre9">Thanks for trying custom tasks</strong></span>
<span class="strong"><strong class="calibre9">See you again</strong></span>
</pre></div><p class="calibre8">A few points to note here are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If we want to change the implementation of our printing logic, there is only one place where we need to do the change, the <code class="literal">print</code> method of our custom task class.</li><li class="listitem">The tasks using task types are used and they work just like any other tasks. They can also have task actions closure using <code class="literal">doLast {}</code>, <code class="literal">&lt;&lt; {}</code>, but it is usually not required.</li></ul></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="References" id="VF2I1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec26" class="calibre1"/>References</h1></div></div></div><p class="calibre8">The next sections mention some of the useful <a id="id187" class="calibre1"/>references for Groovy.</p></div>

<div class="book" title="References" id="VF2I1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Groovy"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec45" class="calibre1"/>Groovy</h2></div></div></div><p class="calibre8">There is a plethora of online reference material available for Groovy. We could start at:</p><div class="book"><ul class="itemizedlist"><li class="listitem">For further reading, refer to Groovy's online documentation at <a class="calibre1" href="http://www.groovy-lang.org/documentation.html">http://www.groovy-lang.org/documentation.html</a></li><li class="listitem">More references of Groovy resources are available at <a class="calibre1" href="https://github.com/kdabir/awesome-groovy">https://github.com/kdabir/awesome-groovy</a></li></ul></div><p class="calibre8">Here is a list of <a id="id188" class="calibre1"/>books on Groovy:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Groovy in Action</em></span> book is available at <a class="calibre1" href="https://www.manning.com/books/groovy-in-action-second-edition">https://www.manning.com/books/groovy-in-action-second-edition</a>.</li><li class="listitem">The <span class="strong"><em class="calibre10">Groovy Cookbook</em></span> is available at <a class="calibre1" href="https://www.packtpub.com/application-development/groovy-2-cookbook">https://www.packtpub.com/application-development/groovy-2-cookbook</a>.</li><li class="listitem">The <span class="strong"><em class="calibre10">Programming Groovy 2</em></span> book is available at <a class="calibre1" href="https://pragprog.com/book/vslg2/programming-groovy-2">https://pragprog.com/book/vslg2/programming-groovy-2</a>.</li></ul></div></div></div>

<div class="book" title="References" id="VF2I1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Gradle API and DSL used in this chapter"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec46" class="calibre1"/>Gradle API and DSL used in this chapter</h2></div></div></div><p class="calibre8">Gradle's official API and DSL<a id="id189" class="calibre1"/> documentation is a good place to explore and learn more about various classes discussed in this chapter. These APIs and DSLs are very rich and deserve our reading time.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">Project</code>:<div class="book"><ul class="itemizedlist1"><li class="listitem">The API documentation: <a class="calibre1" href="http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html">http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html</a></li><li class="listitem">The DSL documentation: <a class="calibre1" href="http://gradle.org/docs/current/dsl/org.gradle.api.Project.html">http://gradle.org/docs/current/dsl/org.gradle.api.Project.html</a></li></ul></div></li><li class="listitem"><code class="literal">Gradle</code> (the interface):<div class="book"><ul class="itemizedlist1"><li class="listitem">The API documentation: <a class="calibre1" href="http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html">http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html</a></li><li class="listitem">The DSL documentation: <a class="calibre1" href="http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html">http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html</a></li></ul></div></li><li class="listitem"><code class="literal">Task</code>:<div class="book"><ul class="itemizedlist1"><li class="listitem">The API documentation: <a class="calibre1" href="http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html">http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html</a></li><li class="listitem">The DSL documentation: <a class="calibre1" href="http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html">http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html</a></li></ul></div></li></ul></div></div></div>
<div class="book" title="Summary" id="10DJ41-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec27" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">We started this chapter with a quick feature overview of Groovy language, covering some of the topics that would be helpful for us to understand Gradle's syntax and write better build scripts. Then, we looked at the API that Gradle exposes to our build scripts and how to consume the API via the DSL. We also covered the Gradle build phases. Then, we looked at the way in which tasks can be created, configured, have dependencies between, and run by default.</p><p class="calibre8">After reading this chapter, we should be able to comprehend the Gradle DSL, rather than just trying to remember the syntax. We are now in a position to read and understand any given Gradle build file, and we should now be able to write custom tasks with ease.</p><p class="calibre8">This chapter might feel a little long and complex. We should take some time out to practise and reread the sections that are not clear and also look up the online references given throughout the chapter. The chapters ahead will be smooth sailing.</p></div></body></html>