<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Unit Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Unit Testing</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit testing with JUnit 4</li><li class="listitem" style="list-style-type: disc">Unit testing with TestNG 6</li><li class="listitem" style="list-style-type: disc">Simulating dependencies with mocks using Mockito</li><li class="listitem" style="list-style-type: disc">Unit testing with JUnit 4 using Spring's application context</li><li class="listitem" style="list-style-type: disc">Unit testing with TestNG 6 using Spring's application context</li><li class="listitem" style="list-style-type: disc">Unit testing with transactions</li><li class="listitem" style="list-style-type: disc">Unit testing controller methods</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Introduction</h1></div></div></div><p>We often skip unit testing because we don't know how to do it or we believe that testing web applications is difficult. In fact, unit testing is easy and Spring makes web application testing effortless.</p><p>In this chapter, you will first learn how to write unit tests using JUnit, TestNG, and Mockito. Then, we will use Spring context, dependency injection, and transactions in our tests. Finally, we will test Spring controller methods using only a few lines of code.</p></div></div>
<div class="section" title="Unit testing with JUnit 4"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Unit testing with JUnit 4</h1></div></div></div><p><span class="strong"><strong>JUnit</strong></span>, first released<a id="id304" class="indexterm"/> in 2000, is the most widely used Java unit testing framework. Eclipse <a id="id305" class="indexterm"/>supports it out of the box.</p><p>In this recipe, we will <a id="id306" class="indexterm"/>write and execute a JUnit 4 test.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec147"/>Getting ready</h2></div></div></div><p>In this recipe, we'll test this simple method (located in the <code class="literal">NumberUtil</code> class), which adds two integers:</p><div class="informalexample"><pre class="programlisting">public static int add(int a, int b) {
  return a + b;
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec148"/>How to do it…</h2></div></div></div><p>Follow <a id="id307" class="indexterm"/>these steps to test a method with JUnit 4:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add<a id="id308" class="indexterm"/> the <code class="literal">junit</code> Maven dependency in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;4.10&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">Create a Java package for your test classes. The standard practice is to keep the test classes in a separate folder with the same package structure. For example, the class we test, <code class="literal">NumberUtil</code>, is in the <code class="literal">src/main/java</code> folder, in the <code class="literal">com.spring_cookbook.util</code> package. Our corresponding test class will be in the <code class="literal">src/test/java</code> folder, which is also in a <code class="literal">com.spring_cookbook.util</code> package.</li><li class="listitem">Create the test class; in Eclipse, in the <span class="strong"><strong>File</strong></span> menu, select <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>JUnit Test Case</strong></span>. We will use <code class="literal">NumberUtilTest</code> as class name.</li><li class="listitem">Create the unit test method by replacing the default <code class="literal">test()</code> method with:<div class="informalexample"><pre class="programlisting">@Test
public void testAdd() {
  assertEquals(NumberUtil.add(5, 3), 8);
  assertEquals(NumberUtil.add(1500, 32), 1532);
}</pre></div></li><li class="listitem">Run the test in Eclipse; right-click somewhere in the class and choose <span class="strong"><strong>Run As</strong></span> | <span class="strong"><strong>JUnit Test</strong></span>.</li><li class="listitem">You can also run the test with Maven if you used the folder and package structure described in step 2:<div class="informalexample"><pre class="programlisting">mvn test</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec149"/>How it works…</h2></div></div></div><p>A JUnit class is<a id="id309" class="indexterm"/> a normal Java class with some methods annotated <a id="id310" class="indexterm"/>with <code class="literal">@Test</code>.</p><p><code class="literal">assertEquals(x, y)</code> is a JUnit method that makes a test method fail if <code class="literal">x</code> is not equal to <code class="literal">y</code>.</p><p>In the <code class="literal">testAdd()</code>method, we check whether the method works for different sets of data.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec150"/>There's more…</h2></div></div></div><p>Some other <a id="id311" class="indexterm"/>useful JUnit method annotations are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@Test(expected=Exception.class)</code>: This method is expected to throw this<a id="id312" class="indexterm"/> exception. For example, to make sure that some code throws this exception in a given situation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Before</code>: This<a id="id313" class="indexterm"/> method is executed before each test method of the test class is executed. For example, to reinitialize some class attributes used by the methods.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@After</code>: This <a id="id314" class="indexterm"/>method is executed after each test method of the test class is executed. For example, to roll back database modifications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@BeforeClass</code>: This <a id="id315" class="indexterm"/>method is executed once before all test methods of the class are executed. For example, this method could contain some initialization code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@AfterClass</code>: This <a id="id316" class="indexterm"/>method is executed once after all test methods of the class are executed. For example, this method could contain some cleanup code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Test(timeout=1000)</code>: The test fails if this method takes longer than 1 second. For<a id="id317" class="indexterm"/> example, to make sure that the execution time of some code stays under a certain duration.</li></ul></div><p>Having a naming convention for test methods helps the code to be more maintainable and readable. To get <a id="id318" class="indexterm"/>some ideas about different naming conventions, you can visit</p><p><a class="ulink" href="http://java.dzone.com/articles/7-popular-unit-test-naming">http://java.dzone.com/articles/7-popular-unit-test-naming</a>.</p></div></div>
<div class="section" title="Unit testing with TestNG 6"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Unit testing with TestNG 6</h1></div></div></div><p><span class="strong"><strong>TestNG</strong></span>, first <a id="id319" class="indexterm"/>released<a id="id320" class="indexterm"/> in 2004, is the second <a id="id321" class="indexterm"/>most popular Java unit testing framework. With most of JUnit features, it also offers parameterized testing (executing a test method with different sets of data) and convenient features for integration testing.</p><p>In this recipe, we will write a parameterized test to test the same method as in the previous recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec151"/>Getting ready</h2></div></div></div><p>In this recipe, we'll test this simple method (located in the <code class="literal">NumberUtil</code> class), which adds two integers:</p><div class="informalexample"><pre class="programlisting">public static int add(int a, int b) {
  return a + b;
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec152"/>How to do it…</h2></div></div></div><p>Follow these steps to test a method with TestNG 6:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">testng</code> Maven dependency in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.testng&lt;/groupId&gt;
  &lt;artifactId&gt;testng&lt;/artifactId&gt;
  &lt;version&gt;6.1.1&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">In Eclipse, install the TestNG plugin. In the <span class="strong"><strong>Help</strong></span> menu, select <span class="strong"><strong>Install New Software...</strong></span>. In the <span class="strong"><strong>Work with:</strong></span> field, enter <code class="literal">http://beust.com/eclipse</code> and press the <span class="emphasis"><em>Enter</em></span> key. Select <span class="strong"><strong>TestNG</strong></span> below the <span class="strong"><strong>Work with:</strong></span> field.</li><li class="listitem">Create a Java package for your test classes. The standard practice is to have test classes in a separate folder with the same package structure. For example, the class we test, <code class="literal">NumberUtil</code>, is in the <code class="literal">src/main/java</code> folder, in the <code class="literal">com.spring_cookbook.util</code> package. Our corresponding test class will be in the <code class="literal">src/test/java</code> folder, also in a <code class="literal">com.spring_cookbook.util</code> package.</li><li class="listitem">Create the <code class="literal">NumberUtilTest</code> TestNG test class:<div class="informalexample"><pre class="programlisting">import static org.testng.Assert.*;

public class NumberUtilTest {
  
}</pre></div></li><li class="listitem">Add a <code class="literal">@DataProvider</code> method with multiple datasets:<div class="informalexample"><pre class="programlisting">@DataProvider
public Object[][] values() {  
return new Object[][] {
  new Object[] { 1, 2, 3 },
  new Object[] { 4, 5, 9 },
  new Object[] { 3000, 2000, 5000 },
  new Object[] { 25, 50, 75 },
 };</pre></div></li><li class="listitem">Add the unit test method, which takes three integers and checks whether the addition of the first two gives the third:<div class="informalexample"><pre class="programlisting">@Test(dataProvider = "values")
public void testAdd(int a, int b, int c) {
  assertEquals(NumberUtil.add(a, b), c);
}</pre></div></li><li class="listitem">Run the test in Eclipse; right-click somewhere in the class and choose <span class="strong"><strong>Run As</strong></span> | <span class="strong"><strong>TestNG Test</strong></span>.</li><li class="listitem">You can also run the test with Maven if you used the folder and package structure described in step3:<div class="informalexample"><pre class="programlisting">mvn test</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec153"/>How it works…</h2></div></div></div><p>The <code class="literal">dataProvider</code> attribute<a id="id322" class="indexterm"/> of the <code class="literal">@Test</code> method will be used to test the <a id="id323" class="indexterm"/>method with the arrays from the <code class="literal">@DataProvider</code> method.</p><p>In the console, verify that the test method has been executed for each dataset:</p><div class="informalexample"><pre class="programlisting">PASSED: testAdd(1, 2, 3)
PASSED: testAdd(4, 5, 9)
PASSED: testAdd(3000, 2000, 5000)</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec154"/>There's more…</h2></div></div></div><p>Some other useful<a id="id324" class="indexterm"/> TestNG method annotations are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@Test(expectedExceptions=Exception.class)</code>: This method is expected<a id="id325" class="indexterm"/> to throw this exception. For example, to make sure some code throws this exception in a given situation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@BeforeMethod</code>: This method is executed before each test method of the test class is <a id="id326" class="indexterm"/>executed. For example, to reinitialize some class attributes used by the methods.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@AfterMethod</code>: This <a id="id327" class="indexterm"/>method is executed after each test method of the test class is executed. For example, to roll back database modifications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@BeforeClass</code>: This <a id="id328" class="indexterm"/>method is executed once before the test methods of the class are executed. For example, this method could contain some initialization code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@AfterClass</code>: This <a id="id329" class="indexterm"/>method is executed once after all test methods of the class are executed. For example, this method could contain some cleanup code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Test(invocationTimeOut=1000)</code>: The test fails if this method takes longer<a id="id330" class="indexterm"/> than 1 second. For example, to make sure that <a id="id331" class="indexterm"/>the execution time of some code stays under a certain duration.</li></ul></div><p>It's possible to <a id="id332" class="indexterm"/>execute a test only if another test was successful (useful for integration testing):</p><div class="informalexample"><pre class="programlisting">@Test
public void connectToDatabase() {}
 
@Test(dependsOnMethods = { "connectToDatabase" })
public void testMyFancySQLQuery() {
  ...
}</pre></div><p>Other advanced <a id="id333" class="indexterm"/>features are well explained in TestNG's documentation at <a class="ulink" href="http://testng.org/doc/documentation-main.html#parameters-dataproviders">http://testng.org/doc/documentation-main.html#parameters-dataproviders</a>.</p><p>For more reasons to choose TestNG over JUnit, refer to <a class="ulink" href="http://kaczanowscy.pl/tomek/sites/default/files/testng_vs_junit.txt.slidy_.html">http://kaczanowscy.pl/tomek/sites/default/files/testng_vs_junit.txt.slidy_.html</a>.</p><p>Having a naming convention for test methods helps the code to be more maintainable and readable. You can find some ideas about different naming conventions at:</p><p><a class="ulink" href="http://java.dzone.com/articles/7-popular-unit-test-naming">http://java.dzone.com/articles/7-popular-unit-test-naming</a>.</p></div></div>
<div class="section" title="Simulating dependencies with mocks using Mockito"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Simulating dependencies with mocks using Mockito</h1></div></div></div><p>With unit testing, as <a id="id334" class="indexterm"/>opposed<a id="id335" class="indexterm"/> to integration testing, we aim to test each class independently. However, many classes have dependencies that we don't want to rely on. So we use mocks.</p><p><span class="strong"><strong>Mocks</strong></span> are smart objects whose output can vary depending on the input. <span class="strong"><strong>Mockito</strong></span> is the most popular <a id="id336" class="indexterm"/>mocking <a id="id337" class="indexterm"/>framework with a concise, yet easy to grasp, syntax.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec155"/>Getting ready</h2></div></div></div><p>We'll mock the <code class="literal">StringUtil</code> class with its <code class="literal">concat()</code>method concatenating two <code class="literal">String</code> objects:</p><div class="informalexample"><pre class="programlisting">public class StringUtil {
  public String concat(String a, String b) {
    return a + b;
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Note that there's no good reason to mock this class, as it's just a convenient example, to show you how to use Mockito.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec156"/>How to do it…</h2></div></div></div><p>Follow these steps for simulating dependencies with mocks using Mockito:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">mockito-core</code> Maven dependency in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.mockito&lt;/groupId&gt;
  &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
  &lt;version&gt;1.10.8&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">In a test method, use Mockito to create a <code class="literal">mock</code> instance of <code class="literal">StringUtil</code>:<div class="informalexample"><pre class="programlisting">StringUtil stringUtilMock = Mockito.mock(StringUtil.class);</pre></div></li><li class="listitem">Program the mock:<div class="informalexample"><pre class="programlisting">Mockito.when(stringUtilMock.concat("a", "b")).thenReturn("ab");
Mockito.when(stringUtilMock.concat("aa", "bb")).thenReturn("aabb");</pre></div></li><li class="listitem">That's it. Let's check how the mock actually works now:<div class="informalexample"><pre class="programlisting">assertEquals(stringUtilMock.concat("a", "b"), "ab");    
assertEquals(stringUtilMock.concat("aa", "bb"), "aabb");    </pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec157"/>How it works…</h2></div></div></div><p>With the mock, we don't need the actual <code class="literal">StringUtil</code> class to execute our test method. Mockito creates and uses, behind the scenes, a proxy class.</p><p>Again, in the real world, creating a mock for this class would be overkill. Mocks are useful to simulate complicated dependencies, such as an SMTP method, the SMTP server behind it, or a REST service.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec158"/>There's more…</h2></div></div></div><p>It's<a id="id338" class="indexterm"/> easy to test whether the method<a id="id339" class="indexterm"/> was called exactly twice with <code class="literal">String</code> parameters:</p><div class="informalexample"><pre class="programlisting">Mockito.verify(stringUtilMock, VerificationModeFactory.times(2)).concat(Mockito.anyString(), Mockito.anyString());</pre></div><p>Mockito offers many other similar methods:</p><div class="informalexample"><pre class="programlisting">VerificationModeFactory.atLeastOnce()
VerificationModeFactory.atLeast(minNumberOfInvocations)
VerificationModeFactory.atMost(maxNumberOfInvocations)

Mockito.anyObject()
Mockito.any(class)
Mockito.anyListOf(class)</pre></div><p>It's also possible, at a given point, to reset the mock object's programmed behavior:</p><div class="informalexample"><pre class="programlisting">Mockito.reset(stringUtilMock);</pre></div><p>For a <a id="id340" class="indexterm"/>more extensive list of Mockito's features, refer to <a class="ulink" href="http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html">http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html</a>.</p></div></div>
<div class="section" title="Unit testing with JUnit 4 using Spring's application context"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Unit testing with JUnit 4 using Spring's application context</h1></div></div></div><p>JUnit <a id="id341" class="indexterm"/>tests<a id="id342" class="indexterm"/> are run outside<a id="id343" class="indexterm"/> Spring; Spring is not initialized before the tests are run. To be able to use the beans defined in the configuration files and dependency injection, some bootstrapping code needs to be added to the test class.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec159"/>How to do it…</h2></div></div></div><p>Follow these steps to test a method using the Spring's application context with JUnit 4:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add <a id="id344" class="indexterm"/>the <code class="literal">spring-test</code> Maven dependency in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
  &lt;version&gt;4.1.1.RELEASE&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">Add <a id="id345" class="indexterm"/>these annotations to the test class:<div class="informalexample"><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {AppConfig.class})
@WebAppConfiguration
public class TestControllerTest {
…</pre></div></li><li class="listitem">Use <a id="id346" class="indexterm"/>Spring beans as usual, for example, as <code class="literal">@Autowired</code> fields:<div class="informalexample"><pre class="programlisting">@Autowired
private UserDAO userDAO;

@Test
public void testListUsers() {
  List&lt;User&gt; users = userDAO.findAll();
  ...
}  </pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec160"/>How it works…</h2></div></div></div><p><code class="literal">@RunWith(SpringJUnit4ClassRunner.class)</code> executes the test with the Spring runner instead of the default JUnit runner. A runner is a class that runs a JUnit test.</p><p><code class="literal">@ContextConfiguration(classes = {AppConfig.class})</code> loads the Spring configuration class and makes the class's beans available.</p><p><code class="literal">@WebAppConfiguration</code> prevents exceptions from being raised. Without it, <code class="literal">@EnableWebMvc</code> (in the Spring configuration) would raise the "<span class="strong"><strong>A ServletContext is required to configure default servlet handling</strong></span>" exception.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec161"/>There's more…</h2></div></div></div><p>You can <a id="id347" class="indexterm"/>choose to use a <a id="id348" class="indexterm"/>separate Spring configuration <a id="id349" class="indexterm"/>class to run your tests:</p><div class="informalexample"><pre class="programlisting">@ContextConfiguration(classes = {AppTestConfig.class})</pre></div><p>You can also use the Spring main configuration class in combination with a test-specific configuration class:</p><div class="informalexample"><pre class="programlisting">@ContextConfiguration(classes = {AppConfig.class, AppTestConfig.class})</pre></div><p>The order in which the classes are declared matters. In this example, beans from <code class="literal">AppConfig</code> can be overridden in <code class="literal">AppTestConfig</code>. For example, you could choose to override a MySQL datasource by an in-memory database datasource for your tests.</p></div></div>
<div class="section" title="Unit testing with TestNG 6 using Spring's application context"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Unit testing with TestNG 6 using Spring's application context</h1></div></div></div><p>TestNG tests are run outside Spring; Spring is not initialized before the tests are run. To be able to <a id="id350" class="indexterm"/>use the<a id="id351" class="indexterm"/> beans defined in the<a id="id352" class="indexterm"/> configuration files and dependency injection, some bootstrapping code needs to be added to the test class.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec162"/>How to do it…</h2></div></div></div><p>Follow these steps to test a method using the Spring application context with TestNG 6:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">spring-test</code> Maven dependency in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
  &lt;version&gt;4.1.1.RELEASE&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">Make the test class extend <code class="literal">AbstractTestNGSpringContextTests</code> and add these annotations to it:<div class="informalexample"><pre class="programlisting">@ContextConfiguration(classes = {AppConfig.class})
@WebAppConfiguration
public class TestControllerTest extends AbstractTestNGSpringContextTests {
…</pre></div></li><li class="listitem">Use Spring beans as usual, for example, as <code class="literal">@Autowired</code> fields:<div class="informalexample"><pre class="programlisting">@Autowired
private UserDAO userDAO;

@Test
public void testListUsers() {
  List&lt;User&gt; users = userDAO.findAll();
  ...
}  </pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec163"/>How it works…</h2></div></div></div><p>Extending <code class="literal">AbstractTestNGSpringContextTests</code> initializes Spring's context and makes<a id="id353" class="indexterm"/> it available<a id="id354" class="indexterm"/> to the test class.</p><p><code class="literal">@ContextConfiguration(classes = {AppConfig.class})</code> loads the Spring configuration<a id="id355" class="indexterm"/> file in Spring's context.</p><p><code class="literal">@WebAppConfiguration</code> prevents exceptions from being raised. Without it, <code class="literal">@EnableWebMvc</code> (in the Spring configuration) would raise the "<span class="strong"><strong>A ServletContext is required to configure default servlet handling</strong></span>" exception.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec164"/>There's more…</h2></div></div></div><p>You can choose to use a separate Spring configuration class to run your tests:</p><div class="informalexample"><pre class="programlisting">@ContextConfiguration(classes = {AppTestConfig.class})</pre></div><p>You can also use Spring's main configuration in combination with a test-specific configuration:</p><div class="informalexample"><pre class="programlisting">@ContextConfiguration(classes = {AppConfig.class, AppTestConfig.class})</pre></div><p>The order in which the classes are declared matters. In this example, beans from <code class="literal">AppConfig</code> can be overridden in <code class="literal">AppTestConfig</code>. For example, you could choose to override a MySQL datasource by an in-memory database datasource for your tests.</p></div></div>
<div class="section" title="Unit testing with transactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Unit testing with transactions</h1></div></div></div><p>To test a DAO class, for example, you will need to perform database queries that won't be persisted. For example, to test the DAO method to add a user, you want to make sure that the <a id="id356" class="indexterm"/>user is actually created in the database, but you don't <a id="id357" class="indexterm"/>want that test user to remain in the database. Transactions help you to do this with minimum effort.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec165"/>How to do it…</h2></div></div></div><p>Follow these steps to automatically revert the database modifications performed by a test method:</p><p>With TestNG, make the test class extend:</p><div class="informalexample"><pre class="programlisting">public class UserDAOTest extends AbstractTransactionalTestNGSpringContextTests  {
...</pre></div><p>With JUnit, add the <code class="literal">@Transactional</code> annotation to the test class:</p><div class="informalexample"><pre class="programlisting">@Transactional
public class UserDAOTest {
...</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec166"/>How it works…</h2></div></div></div><p>Each test method of the class will automatically:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Start a new transaction</li><li class="listitem" style="list-style-type: disc">Execute as normal</li><li class="listitem" style="list-style-type: disc">Rollback the transaction (so any modifications to a database will be reverted)</li></ul></div></div></div>
<div class="section" title="Unit testing controller methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Unit testing controller methods</h1></div></div></div><p>Unit testing the logic of controller methods is usually difficult, but Spring makes it easy by <a id="id358" class="indexterm"/>providing methods to simulate a request and test the <a id="id359" class="indexterm"/>response generated by Spring.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec167"/>Getting ready</h2></div></div></div><p>We'll test this controller method which concatenates two parameters and passes the result to the <code class="literal">concat.jsp</code> JSP file:</p><div class="informalexample"><pre class="programlisting">@RequestMapping("concat")
public String concat(@RequestParam String a, @RequestParam String b, Model model) {
  String result = a + b;
  model.addAttribute("result", result);
  return "concat";
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec168"/>How to do it…</h2></div></div></div><p>To test a <a id="id360" class="indexterm"/>controller method, build and execute an HTTP request and then perform tests on the response returned by the controller method. We <a id="id361" class="indexterm"/>will test that for a given set of parameters, the correct attribute is passed to the JSP and the user is redirected to the proper URL. Here are the steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">spring-test</code> and <code class="literal">hamcrest-all</code> Maven dependencies in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
  &lt;version&gt;4.1.1.RELEASE&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
    &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
    &lt;version&gt;1.3&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
 &lt;/dependency&gt;</pre></div></li><li class="listitem">Add the <code class="literal">@WebAppConfiguration</code> and <code class="literal">@ContextConfiguration</code> (with the Spring configuration class as a parameter) annotations to the test class:<div class="informalexample"><pre class="programlisting">@ContextConfiguration(classes = {AppConfig.class})
@WebAppConfiguration
public class StringControllerTest {
...</pre></div></li><li class="listitem">In the test class, add a<code class="literal"> WebApplicationContext</code> attribute:<div class="informalexample"><pre class="programlisting">@Autowired
private WebApplicationContext wac;</pre></div></li><li class="listitem">In the test class, add a <code class="literal">MockMvc</code> attribute and initialize it in a <code class="literal">setup()</code> method using the <code class="literal">WebApplicationContext</code> attribute:<div class="informalexample"><pre class="programlisting">private MockMvc mockMvc;

@BeforeMethod
public void setup() {
    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>If you are using JUnit, use the <code class="literal">@Before</code> annotation.</p></div></div></li><li class="listitem">Add these <code class="literal">static</code> imports to the test class:<div class="informalexample"><pre class="programlisting">import static org.springframework.test.web.servlet.request. MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result. MockMvcResultMatchers.*;</pre></div></li><li class="listitem">In the<a id="id362" class="indexterm"/> test method, we will build a POST request with the parameters <code class="literal">a</code> and <code class="literal">b</code>, execute that request, and test whether the web application responds to that URL, if the proper <code class="literal">String</code> is set in the model, and whether the right JSP is used:<div class="informalexample"><pre class="programlisting">@Test
public void testTest1() throws Exception {
    this.mockMvc.perform(post("/concat").param("a", "red").param("b", "apple"))
    .andExpect(status().isOk())
    .andExpect(model().attribute("result", "redapple"))
    .andExpect(forwardedUrl("/WEB-INF/jsp/concat.jsp"));
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec169"/>How it works…</h2></div></div></div><p>The <code class="literal">setup()</code> method is executed before each test method is executed.</p><p>In the <code class="literal">setup()</code> method, <code class="literal">MockMvcBuilders.webAppContextSetup</code> performs a full initialization of the controllers and their dependencies, allowing <code class="literal">this.mockMvc.perform()</code> to retrieve the right controller for a given URL.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec170"/>There's more…</h2></div></div></div><p>For debugging, use <code class="literal">andDo(MockMvcResultHandlers.print())</code> to print the detailed information about the request and the response:</p><div class="informalexample"><pre class="programlisting">this.mockMvc.perform(...)
    ...
        .andDo(MockMvcResultHandlers.print());</pre></div><p>The <a id="id363" class="indexterm"/>output for<a id="id364" class="indexterm"/> this recipe looks like:</p><div class="informalexample"><pre class="programlisting">MockHttpServletRequest:
         HTTP Method = <span class="strong"><strong>POST</strong></span>
         Request URI = <span class="strong"><strong>/concat</strong></span>
          Parameters = <span class="strong"><strong>{a=[red], b=[apple]}</strong></span>
             Headers = {}

             Handler:
                Type = com.spring_cookbook.controllers.StringController
              Method = public java.lang.String com.spring_cookbook.controllers.<span class="strong"><strong>StringController.concat </strong></span>(java.lang.String,java.lang.String,org.springframework.ui.Model)

               Async:
   Was async started = false
        Async result = null

  Resolved Exception:
                Type = null

        ModelAndView:
           View name = <span class="strong"><strong>concat</strong></span>
                View = null
           Attribute = result
               value = <span class="strong"><strong>redapple</strong></span>

            FlashMap:

MockHttpServletResponse:
              Status = 200
       Error message = null
             Headers = {}
        Content type = null
                Body = 
       Forwarded URL = <span class="strong"><strong>/WEB-INF/jsp/concat.jsp</strong></span>
      Redirected URL = null
             Cookies = []</pre></div><p>Explore<a id="id365" class="indexterm"/> the <code class="literal">MockMvcRequestBuilders</code> class to find more elements that can be tested at <a class="ulink" href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.html">http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.html</a>.</p><p>For <a id="id366" class="indexterm"/>example, you can test that a GET request gets some JSON content as response, and check the value of a specific element of the response.</p><div class="informalexample"><pre class="programlisting">this.mockMvc.perform(get("/user/5"))
    .andExpect(content().contentType("application/json"))
    .andExpect(jsonPath("$.firstName").value("Scott."));</pre></div></div></div></body></html>