<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Spring Framework 5.0 and Design Patterns</h1>
                </header>
            
            <article>
                
<p>This chapter will help you gain a better understanding of the Spring Framework with modules, and use the design patterns that are responsible for the success of Spring. This chapter will cover every major module of the Spring Framework. We begin with an introduction to the Spring Framework. We will have a look at the new features and enhancement introduced in Spring 5. We will also understand the design patterns used in the major modules of the Spring Framework.</p>
<p>At the end of this chapter, you will understand how Spring works, and how Spring solves the common problems of the design level of the enterprise application by using design patterns. You will know how to improve loose coupling between the components of applications and how to simplify application development by using Spring with design patterns.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Introduction of the Spring Framework</li>
<li>Simplifying application development using Spring and its pattern
<ul>
<li>Using the power of the POJO pattern</li>
<li>Injecting dependencies</li>
<li>Applying aspects to address cross-cutting concerns</li>
<li>Applying a template pattern to eliminate boilerplate code</li>
</ul>
</li>
<li>Creating a Spring container for containing beans using the Factory pattern
<ul>
<li>Creating a container with an application context</li>
<li>The life of a bean in the container</li>
</ul>
</li>
<li>Spring modules</li>
<li>New features in Spring Framework 5.0</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Spring Framework</h1>
                </header>
            
            <article>
                
<p>In the early days of Java, there were lots of heavier enterprise Java technologies for enterprise applications that provided enterprise solutions to programmers. However, it was not easy to maintain the applications because it was tightly coupled with the framework. A couple of years ago, apart from Spring, all Java technologies were heavier, like EJB. At the time, Spring was introduced as an alternative technology especially made for EJB because Spring provided a very simple, leaner, and lighter programming model compared with other existing Java technologies. Spring makes this possible by using many available design patterns, but it focused on the <strong>Plain Old Java Object</strong> (<strong>POJO</strong>) programming model. This model provided the simplicity to the Spring Framework. It also empowered ideas such as the <strong>dependency injection</strong> (<strong>DI</strong>) pattern and <strong>Aspect-Oriented Programming</strong> (<strong>AOP</strong>) by using the Proxy pattern and Decorator pattern.</p>
<p class="mce-root"><span>The Spring Framework is an open source application framework and a Java-based platform that provides comprehensive infrastructure support for developing enterprise Java applications. So developers don't need to care about the infrastructure of the application; they should be focused on the business logic of the application rather than handling the configuration of the application. All infrastructure, configuration, and meta-configuration files, either Java-based configuration or XML-based configuration, both are handled by the Spring Framework. So this framework makes you more flexible in building an application with a POJOs programming model rather than a non-invasive programming model.</span></p>
<p>The Spring <strong>Inversion of Control</strong> (<strong>IoC</strong>) container is the heart of the entire framework. It helps glue together the different parts of the application, thus forming a coherent architecture. Spring MVC components can be used to build a very flexible web tier. The IOC container simplifies the development of the business layer with POJOs.</p>
<p>Spring simplifies the application development and removes a lot of the dependency on the other APIs. Let's see some examples of how you, as an application developer, can benefit from the Spring platform:</p>
<ul>
<li>All application classes are simple POJO classes--Spring is not invasive. It does not require you to extend framework classes or implement framework interfaces for most use cases.</li>
<li>Spring applications do not require a Java EE application server, but they can be deployed on one.</li>
<li>You can execute a method in a database transaction by using transaction management in Spring Framework without having any third-party transactional API.</li>
<li>Using Spring, you can use a Java method as a request handler method or remote method, like a <kbd>service()</kbd> method of a servlet API, but without dealing with the servlet API of the servlet container.</li>
<li>Spring enables you to use a local <kbd>java</kbd> method as a message handler method without using a <strong>Java Message Service</strong> (<strong>JMS</strong>) API in the application.</li>
<li>Spring also enables you to use the local <kbd>java</kbd> method as a management operation without using a <strong>Java Management Extensions</strong> (<strong>JMX</strong>) API in the application.</li>
<li>Spring serves as a container for your application objects. Your objects do not have to worry about finding and <em>establishing</em> connections with each other.</li>
<li>Spring instantiates the beans and injects the dependencies of your objects into the application--it serves as a life cycle manager of the beans.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplifying application development using Spring and its pattern</h1>
                </header>
            
            <article>
                
<p>Developing an enterprise application using the traditional Java platform has a lot of limitations when it comes to organizing the basic building blocks as individual components for reusability in your application. Creating reusable components for basic and common functionality is best design practice, so you cannot ignore it. To address the reusability problem in your application, you can use various design patterns, such as the Factory pattern, Abstract Factory pattern, Builder pattern, Decorator pattern, and Service Locator pattern, to compose the basic building blocks into a coherent whole, such as class and object instances, to promote the reusability of components. These patterns address the common and recursive application problems. Spring Framework simply implements these patterns internally, providing you with an infrastructure to use in a formalized way.</p>
<p>There are lots of complexities in enterprise application development, but Spring was created to address these, and makes it possible to simplify the process for developers. Spring isn't only limited to server-side development--it also helps simplifies things regarding building projects, testability, and loose coupling. Spring follows the POJO pattern, that is, a Spring component can be any type of POJO. A component is a self-contained piece of code that ideally could be reused in multiple applications.</p>
<p>Since this book is focused on all <strong>design patterns</strong> that are adopted by the Spring Framework to simplify Java development, we need to discuss or at least provide some basic implementation and consideration of design patterns and the best practices to design the infrastructure for enterprise application development. Spring uses the following strategies to make java development easy and testable:</p>
<ul>
<li>Spring uses the power of the <em>POJO pattern</em> for lightweight and minimally invasive development of enterprise applications</li>
<li>It uses the power of the <strong>dependency injection pattern</strong> (<strong>DI pattern</strong>) for loose coupling and makes a system interface oriented</li>
<li>It uses the power of the <em>Decorator and Proxy design pattern</em> for declarative programming through aspects and common conventions</li>
<li>It uses the power of the <em>Template Design pattern</em> for eliminating boilerplate code with aspects and templates</li>
</ul>
<p>In this chapter, I'll explain each of these ideas, and also show concrete examples of how Spring simplifies Java development. Let's start with exploring how Spring remains minimally invasive by encouraging POJO-oriented development by using the POJO pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the power of the POJO pattern</h1>
                </header>
            
            <article>
                
<p>There are many other frameworks for Java development that lock you in by forcing you to extend or implement one of their existing classes or interfaces; Struts, Tapestry, and earlier versions of EJB had this approach. The programming model of these frameworks is based on the invasive model. This makes it harder for your code to find bugs in the system, and sometimes it will render your code unintelligible. However, if you are working with Spring Framework, you don't need to implement or extend its existing classes and interfaces, so this is simply POJO-based implementation, following a non-invasive programming model. It makes it easier for your code to find bugs in the system, and keeps the code understandable.</p>
<p>Spring allows you to do programming with very simple non Spring classes, which means there is no need to implement Spring-specific classes or interfaces, so all classes in the Spring-based application are simply POJOs. That means you can compile and run these files without dependency on Spring libraries; you cannot even recognize that these classes are being used by the Spring Framework. In Java-based configuration, you will use Spring annotations, which is the worst case of the Spring-based application.</p>
<p>Let's look at this with the help of the following example:</p>
<pre>    package com.packt.chapter1.spring; 
    public class HelloWorld { 
      public String hello() { 
        return "Hello World"; 
      } 
    } </pre>
<p>The preceding class is a simple POJO class with no special indication or implementation related to the framework to make it a Spring component. So this class could function equally well in a Spring application as it could in a non-Spring application. This is the beauty of Spring's non-invasive programming model. Another way that Spring empowers POJO is by collaborating with other POJOs using the DI pattern. Let's see how DI works to help decouple components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting dependencies between POJOs</h1>
                </header>
            
            <article>
                
<p>The term <em>dependency injection</em> is not new-it is used by PicoContainer. Dependency injection is a design pattern that promotes loose coupling between the Spring components--that is, between the different collaborating POJOs. So by applying DI to your complex programming, your code will become simpler, easier to understand, and easier to test.</p>
<p>In your application, many objects are working together for a particular functionality as per your requirement. This collaboration between the objects is actually known as dependency injection. Injecting dependency between the working components helps you to unit test every component in your application without tight coupling.</p>
<p>In a working application, what the end user wants is to see the output. To create the output, a few objects in the application work together and are sometimes coupled. So when you are writing these complex application classes, consider the reusability of these classes and make these classes as independent as possible. This is a best practice of coding that will help you in unit testing these classes independently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How DI works and makes things easy for development and testing</h1>
                </header>
            
            <article>
                
<p>Let's look at DI pattern implementation in your application. It makes things easy to understand, loosely coupled, and testable across the application. Suppose we have a simple application (something more complex than a <em>Hello World</em> example that you might make in your college classes). Every class is working together to perform some business task and help build business needs and expectations. That means that each class in the application has its measure of responsibility for a business task, together with other collaborating objects (its dependencies). Let's look at the following <span>image</span>. This dependency between the objects can create complexity and tight coupling between the dependent objects:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="151" width="301" class=" image-border" src="assets/b2c99bac-e188-4ce7-b22f-1a3a4c6219f4.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The TransferService component is traditionally dependent on two other components: TransferRepository and AccountRepository</div>
<p>A typical application system consists of several parts working together to carry out a use case. For example, consider the <kbd>TransferService</kbd> class, shown next.</p>
<p><kbd>TransferService</kbd> using direct instantiation:</p>
<pre>    package com.packt.chapter1.bankapp.transfer; 
    public class TransferService { 
      private AccountRepository accountRepository; 
      public TransferService () { 
        this.accountRepository = new AccountRepository(); 
      } 
      public void transferMoney(Account a, Account b) { 
        accountRepository.transfer(a, b); 
      } 
    } </pre>
<p>The <kbd>TransferService</kbd> object needs an <kbd>AccountRepository</kbd> object to make money transfer from account <kbd>a</kbd> to account <kbd>b</kbd>. Hence, it creates an instance of the <kbd>AccountRepository</kbd> object directly and uses it. But direct instantiation increases coupling and scatters the object creation code across the application, making it hard to maintain and difficult to write a unit test for <kbd>TransferService</kbd>, because, in this case, whenever you want to test the <kbd>transferMoney()</kbd> method of the <kbd>TransferService</kbd> class by using the <kbd>assert</kbd> to unit test, then the <kbd>transfer()</kbd> method of the <kbd>AccountRepository</kbd> class is also called unlikely by this test. But the developer is not aware about the dependency of <kbd>AccountRepository</kbd> on the <kbd>TransferService</kbd> class; at least, the developer is not able to test the <kbd>transferMoney()</kbd> method of the <kbd>TransferService</kbd> class using unit testing.</p>
<p>In enterprise applications, coupling is very dangerous, and it pushes you to a situation where you will not be able to do any enhancement in the application in the future, where any further changes in such an application can create a lot of bugs, and where fixing these bugs can create new bugs. Tightly coupled components are one of the reasons for major problems in these applications. Unnecessary tightly coupled code makes your application non-maintainable, and as time goes by, its code will not be reused, as it cannot be understood by other developers. But sometimes a certain amount of coupling is required for an enterprise application because completely uncoupled components are not possible in real-world cases. Each component in the application has some responsibility for a role and business requirement, to the extent that all components in the application have to be aware of the responsibility of the other components. That means coupling is necessary sometimes, but we have to manage the coupling between required components very carefully.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using factory helper pattern for dependent components</h1>
                </header>
            
            <article>
                
<p>Let's try another method for dependent objects using the Factory pattern. This design pattern is based on the GOF factory design pattern to create object instances by using a factory method. So this method actually centralizes the use of the new operator. It creates the object instances based on the information provided by the client code. This pattern is widely used in the dependency injection strategy.</p>
<p><kbd>TransferService</kbd> using factory helper:</p>
<pre>    package com.packt.chapter1.bankapp.transfer; 
    public class TransferService { 
      private AccountRepository accountRepository; 
      public TransferService() { 
        this.accountRepository = <br/>          AccountRepositoryFactory.getInstance("jdbc"); 
      } 
      public void transferMoney(Account a, Account b) { 
        accountRepository.transfer(a, b); 
      } 
    } </pre>
<p>In the preceding code, we use the Factory pattern to create an object of <kbd>AccountRepository</kbd>. In software engineering, one of the best practices of application design and development is <strong>program-to-interface</strong> (<strong>P2I</strong>). According to this practice, concrete classes must implement an interface that is used in the client code for the caller rather than using a concrete class. By using P2I, you can improve the preceding code. Therefore, we can easily replace it with a different implementation of the interface with little impact on the client code. So programming-to-interface provides us with a method involving low coupling. In other words, there is no direct dependency on a concrete implementation leading to low coupling. Let's look at the following code. Here, <kbd>AccountRepository</kbd> is an interface rather than a class:</p>
<pre>    public interface AccountRepository{ 
      void transfer(); 
      //other methods 
    } </pre>
<p>So we can implement it as per our requirement, and it is dependent upon the client's infrastructure. Suppose we want an <kbd>AccountRepository</kbd> during the development phase with JDBC API. We can provide a <kbd>JdbcAccountRepositry</kbd> concrete implementation of the <kbd>AccountRepositry</kbd> interface, as shown here:</p>
<pre>    public class JdbcAccountRepositry implements AccountRepositry{ 
      //...implementation of methods defined in AccountRepositry 
      // ...implementation of other methods 
    } </pre>
<p>In this pattern, objects are created by factory classes to make it easy to maintain, and this avoids scattering the code of object creation across other business components. With a factory helper, it is also possible to make object creation configurable. This technique provides a solution for tight coupling, but we are still adding factory classes to the business component for fetching collaborating components. So let's see the DI pattern in the next section and look at how to solve this problem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using DI pattern for dependent components</h1>
                </header>
            
            <article>
                
<p>According to the DI pattern, dependent objects are given their dependencies at the time of the creation of the objects by some factory or third party. This factory coordinates each object in the system in such a way that each dependent object is not expected to create their dependencies. This means that we have to focus on defining the dependencies instead of resolving the dependencies of collaborating objects in the enterprise application. Let's look at the following <span>image</span>. You will learn that dependencies are injected into the objects that need them:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="125" width="383" src="assets/6e7a8be2-2737-49b0-902d-4131797bb0d5.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Dependency injection between the different collaborating components in the application</div>
<p>To illustrate this point, let's look at <kbd>TransferService</kbd> in the next section--a <kbd>TransferService</kbd> has dependency with <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>. Here, <kbd>TransferService</kbd> is capable of transferring money by any kind implementation of <kbd>TransferRepository</kbd>, that is, we can either use <kbd>JdbcTransferRepository</kbd> or <kbd>JpaTransferRepository</kbd>, depending on whichever comes along according to the deployment environment.</p>
<p><kbd>TransferServiceImpl</kbd> is flexible enough to take on any <kbd>TransferRepository</kbd> it's given:</p>
<pre>    package com.packt.chapter1.bankapp; 
    public class TransferServiceImpl implements TransferService { 
      private TransferRepository transferRepository; 
      private AccountRepository  accountRepository; 
      public TransferServiceImpl(TransferRepository transferRepository,<br/>       AccountRepository  accountRepository) { 
         this.transferRepository =<br/>          transferRepository;//TransferRepository is injected 
         this.accountRepository  = accountRepository; <br/>         //AccountRepository is injected 
       } 
       public void transferMoney(Long a, Long b, Amount amount) { 
         Account accountA = accountRepository.findByAccountId(a); 
         Account accountB = accountRepository.findByAccountId(b); 
         transferRepository.transfer(accountA, accountB, amount); 
       } 
    } </pre>
<p>Here you can see that <kbd>TransferServiceImpl</kbd> doesn't create its own repositories implementation. Instead, we have given the implementation of repositories at the time of construction as a constructor argument. This is a type of DI known as <em>constructor injection</em>. Here we have passed the repository interface type as an argument of the constructor. Now <kbd>TransferServiceImpl</kbd> could use any implementation of repositories, either JDBC, JPA, or mock objects. The point is that <kbd>TransferServiceImpl</kbd> isn't coupled to any specific implementation of repositories. It doesn't matter what kind of repository is used to transfer an amount from one account to another account, as long as it implements the repositories interfaces. If you are using the DI pattern of the Spring Framework, loose coupling is one of the key benefits. The DI pattern always promotes P2I, so each object knows about its dependencies by their associated interface rather than associated implementation, so the dependency can easily be swapped out with another implementation of that interface instead of changing to its dependent class implementation.</p>
<p>Spring provides support for assembling such an application system from its parts:</p>
<ul>
<li>Parts do not worry about finding each other</li>
<li>Any part can easily be swapped out</li>
</ul>
<p>The method for assembling an application system by creating associations between application parts or components is known as <strong>wiring</strong>. In Spring, there are many ways to wire collaborating components together to make an application system. For instance, we could use either an XML configuration file or a Java configuration file.</p>
<p>Now let's look at how to inject the dependencies of <kbd>TransferRepository</kbd> and <kbd>AccountRepository</kbd> into a <kbd>TransferService</kbd> with Spring:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
     
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 
    &lt;bean id="transferService"  <br/>     class="com.packt.chapter1.bankapp.service.TransferServiceImpl"&gt; 
         &lt;constructor-arg ref="accountRepository"/&gt; 
         &lt;constructor-arg ref="transferRepository"/&gt; 
    &lt;/bean&gt; 
    &lt;bean id="accountRepository" class="com.<br/>     packt.chapter1.bankapp.repository.JdbcAccountRepository"/&gt; 
    &lt;bean id="transferRepository" class="com.  <br/>     packt.chapter1.bankapp.repository.JdbcTransferRepository"/&gt;     
    
    &lt;/beans&gt; </pre>
<p>Here, <kbd>TransferServiceImpl</kbd>, <kbd>JdbcAccountRepository</kbd>, and <kbd>JdbcTransferRepository</kbd> are declared as beans in Spring. In the case of the <kbd>TransferServiceImpl</kbd> bean, it's constructed, passing a reference to the <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> beans as constructor arguments. You might like to know that Spring also allows you to express the same configuration using Java.</p>
<p>Spring offers Java-based configuration as an alternative to XML:</p>
<pre>    package com.packt.chapter1.bankapp.config; 
 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.Configuration; 
 
    import com.packt.chapter1.bankapp.repository.AccountRepository; 
    import com.packt.chapter1.bankapp.repository.TransferRepository; 
    import <br/>     com.packt.chapter1.bankapp.repository.jdbc.JdbcAccountRepository; 
    import <br/>     com.packt.chapter1.bankapp.repository.jdbc.JdbcTransferRepository; 
    import com.packt.chapter1.bankapp.service.TransferService; 
    import com.packt.chapter1.bankapp.service.TransferServiceImpl; 
 
    @Configuration 
    public class AppConfig { 
    
     @Bean 
     public TransferService transferService(){ 
       return new TransferServiceImpl(accountRepository(),<br/>       transferRepository()); 
     } 
     @Bean 
     public AccountRepository accountRepository() { 
       return new JdbcAccountRepository(); 
     } 
     @Bean 
     public TransferRepository transferRepository() { 
       return new JdbcTransferRepository(); 
     } 
    } </pre>
<p>The benefits of the dependency injection pattern are the same whether you are using an XML-based or a Java-based configuration:</p>
<ul>
<li>Dependency injection promotes loose coupling. You can remove hard-coded dependencies with best practice P2I<em>,</em> and you could provide dependencies from outside the application by using the Factory pattern and its built-in swappable and pluggable implementation</li>
<li>The DI pattern promotes the composition design of object-oriented programming rather than inheritance programming</li>
</ul>
<p>Although <kbd>TransferService</kbd> depends on an <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>, it doesn't care about what type (JDBC or JPA) of implementations of <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> are used in the application. Only Spring, through its configuration (XML- or Java-based), knows how all the components come together and are instantiated with their required dependencies using the DI pattern. DI makes it possible to change those dependencies with no changes to the dependent classes--that is, we could use either a JDBC implementation or a JPA implementation without changing the implementation of <kbd>AccountService</kbd>.</p>
<p>In a Spring application, an implementation of the application context (Spring offers <kbd>AnnotationConfigApplicationContext</kbd> for Java-based and <kbd>ClassPathXmlApplicationContext</kbd> for XML-based implementations) loads bean definitions and wires them together into a Spring container. The application context in Spring creates and wires the Spring beans for the application at startup. Look into the implementation of the Spring application context with Java-based configuration--It loads the Spring configuration files (<kbd>AppConfig.java</kbd> for Java and <kbd>Sprig.xml</kbd> for XML) located in the application's classpath. In the following code, the <kbd>main()</kbd> method of the <kbd>TransferMain</kbd> class uses a <kbd>AnnotationConfigApplicationContext</kbd> class to load the configuration class <kbd>AppConfig.java</kbd> and get an object of the <kbd>AccountService</kbd> class.</p>
<p>Spring offers Java-based configuration as an alternative to XML:</p>
<pre>    package com.packt.chapter1.bankapp; 
 
    import org.springframework.context.ConfigurableApplicationContext; 
    import <br/>     org.springframework.context.annotation<br/>     .AnnotationConfigApplicationContext; 
 
    import com.packt.chapter1.bankapp.config.AppConfig; 
    import com.packt.chapter1.bankapp.model.Amount; 
    import com.packt.chapter1.bankapp.service.TransferService; 
 
    public class TransferMain { 
 
      public static void main(String[] args) { 
        //Load Spring context 
        ConfigurableApplicationContext applicationContext = <br/>          new AnnotationConfigApplicationContext(AppConfig.class); 
         //Get TransferService bean 
         TransferService transferService = <br/>          applicationContext.getBean(TransferService.class); 
           //Use transfer method 
         transferService.transferAmmount(100l, 200l,<br/>          new Amount(2000.0)); 
         applicationContext.close(); 
      } 
 
    }    </pre>
<p>Here we have a quick introduction to the dependency injection pattern. You'll learn a lot more about the DI pattern in the coming chapters of this book. Now let's look at another way of simplifying Java development using Spring's declarative programming model through aspects and proxy patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying aspects for cross cutting concerns</h1>
                </header>
            
            <article>
                
<p>In a Spring application, the DI pattern provides us with loose coupling between collaborating software components, but <strong>Aspect-Oriented Programming</strong> in Spring (Spring <strong>AOP</strong>) enables you to capture common functionalities that are repetitive throughout your application. So we can say that Spring AOP promotes loose coupling and allows cross-cutting concerns, listed as follows, to be separated in a most elegant fashion. It allows these services to be applied transparently through declaration. With Spring AOP, it is possible to write custom aspects and configure them declaratively.</p>
<p>The generic functionalities that are needed in many places in your application are:</p>
<ul>
<li>Logging and tracing</li>
<li>Transaction management</li>
<li>Security</li>
<li>Caching</li>
<li>Error handling</li>
<li>Performance monitoring</li>
<li>Custom business rules</li>
</ul>
<p>The components listed here are not part of your core application, but these components have some additional responsibilities, commonly referred to as cross-cutting concerns because they tend to cut across multiple components in a system beyond their core responsibilities. If you put these components with your core functionalities, thereby implementing cross-cutting concerns without modularization, it will have two major problems:</p>
<ul>
<li><strong>Code tangling</strong>: A coupling of concerns means that a cross-cutting concern code, such as a security concern, a transaction concern, and a logging concern, is coupled with the code for business objects in your application.</li>
<li><strong>Code scattering</strong>: Code scattering refers to the same concern being spread across modules. This means that your concern code of security, transaction, and logging is spread across all modules of the system. In other words, you can say there is a duplicity of the same concern code across the system.</li>
</ul>
<p>The following diagramÂ illustrates this complexity. The business objects are too intimately involved with the cross-cutting concerns. Not only does each object know that it's being logged, secured, and involved in a transactional context, but each object is also responsible for performing those services assigned only to it:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="188" width="360" class=" image-border" src="assets/1ae8b16e-1e89-4134-88ac-dd5741964a3e.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Cross-cutting concerns, such as logging, security and transaction, are often scattered about in modules where those tasks are not their primary concern</div>
<p>Spring AOP enables the modularization of cross-cutting concerns to avoid tangling and scattering. You can apply these modularized concerns to the core business components of the application declaratively without affecting the aforementioned the above components. The aspects ensure that the POJOs remain plain. Spring AOP makes this magic possible by using the Proxy Design Pattern. We will discuss the Proxy Design pattern more in the coming chapters of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Spring AOP works</h1>
                </header>
            
            <article>
                
<p>The following points describe the work of Spring AOP:</p>
<ul>
<li><strong>Implement your mainline application logic</strong>: Focusing on the core problem means that, when you are writing the application business logic, you don't need to worry about adding additional functionalities, such as logging, security, and transaction, between the business codes-Spring AOP takes care of it.</li>
<li><strong>Write aspects to implement your cross-cutting concerns</strong>: Spring provides many aspects out of the box, which means you can write additional functionalities in the form of the aspect as independent units in Spring AOP. These aspects have additional responsibilities as cross-cutting concerns beyond the application logic codes.</li>
<li><strong>Weave the aspects into your application</strong>: Adding the cross-cutting behaviors to the right places, that is, after writing the aspects for additional responsibilities, you could declaratively inject them into the right places in the application logic codes.</li>
</ul>
<p>Let's look at an illustration of AOP in Spring:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/cc447143-bff6-4bd0-bc4a-705954178b5e.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">AOP-based system evolution--this leaves the application components to focus on their specific business functionalities</div>
<p class="packt_figure">In the preceding diagram, Spring AOP separates the cross-cutting concerns, for example, security, transaction, and logging, from the business modules, that is, <kbd>BankService</kbd>, <kbd>CustomerService</kbd>, and <kbd>ReportingService</kbd>. These cross-cutting concerns are applied to predefined points (stripes in the preceding diagram) of the business modules at the running time of the application.</p>
<p>Suppose that you want to log the messages before and after calling the <kbd>transferAmmount()</kbd> method of <kbd>TransferService</kbd> using the services of a <kbd>LoggingAspect</kbd>. The following listing shows the <kbd>LoggingAspect</kbd> class you might use.</p>
<p><kbd>LoggingAspect</kbd> call is used for logging the system for <kbd>TransferService</kbd>:</p>
<pre>    package com.packt.chapter1.bankapp.aspect; 
 
    import org.aspectj.lang.annotation.After; 
    import org.aspectj.lang.annotation.Aspect; 
    import org.aspectj.lang.annotation.Before; 
 
    @Aspect 
    public class LoggingAspect { 
    
     @Before("execution(* *.transferAmount(..))") 
     public void logBeforeTransfer(){ 
       System.out.println("####LoggingAspect.logBeforeTransfer() <br/>       method called before transfer amount####"); 
     } 
    
     @After("execution(* *.transferAmount(..))") 
     public void logAfterTransfer(){ 
       System.out.println("####LoggingAspect.logAfterTransfer() method<br/>       called after transfer amount####"); 
     } 
    } </pre>
<p>To turn <kbd>LoggingAspect</kbd> into an aspect bean, all you need to do is declare it as one in the Spring configuration file. Also, to make it an aspect, you have to add the <kbd>@Aspect</kbd> annotation to this class. Here's the updated <kbd>AppConfig.java</kbd> file, revised to declare <kbd>LoggingAspect</kbd> as an aspect.</p>
<p>Declaring <kbd>LoggingAspect</kbd> as an aspect and enabling the <kbd>Apsect</kbd> proxy feature of Spring AOP:</p>
<pre>    package com.packt.chapter1.bankapp.config; 
 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.Configuration; 
    import<br/>     org.springframework.context.annotation.EnableAspectJAutoProxy; 
 
    import com.packt.chapter1.bankapp.aspect.LoggingAspect; 
    import com.packt.chapter1.bankapp.repository.AccountRepository; 
    import com.packt.chapter1.bankapp.repository.TransferRepository; 
    import<br/>     com.packt.chapter1.bankapp.repository.jdbc.JdbcAccountRepository; 
    import<br/>     com.packt.chapter1.bankapp.repository.jdbc.JdbcTransferRepository; 
    import com.packt.chapter1.bankapp.service.TransferService; 
    import com.packt.chapter1.bankapp.service.TransferServiceImpl; 
 
    @Configuration 
    @EnableAspectJAutoProxy 
    public class AppConfig { 
    
      @Bean 
      public TransferService transferService(){ 
        return new TransferServiceImpl(accountRepository(),<br/>        transferRepository()); 
      } 
      @Bean 
      public AccountRepository accountRepository() { 
        return new JdbcAccountRepository(); 
      } 
      @Bean 
      public TransferRepository transferRepository() { 
        return new JdbcTransferRepository(); 
      } 
      @Bean 
      public LoggingAspect loggingAspect() { 
        return new LoggingAspect(); 
      } 
    } </pre>
<p>Here, we're using Spring's AOP configuration based on Java to declare the <kbd>LoggingAspect</kbd> bean as an aspect. First, we declare <kbd>LoggingAspect</kbd> as a bean. Then we annotate that bean with the <kbd>@Aspect</kbd> annotation.</p>
<p>We annotate <kbd>logBeforeTransfer()</kbd> of <kbd>LoggingAspect</kbd> with the <kbd>@Before</kbd> annotation so that this method is called before the <kbd>transferAmount()</kbd> is executed. This is called <strong>before advice</strong>. Then, we annotate another method of <kbd>LoggingAspect</kbd> with the <kbd>@After</kbd> annotation to declare that the <kbd>logAfterTransfer()</kbd> method should be called after <kbd>transferAmount()</kbd> has executed. This is known as <strong>after advice</strong>.</p>
<p><kbd>@EnableAspectJAutoProxy</kbd> is used to enable Spring AOP features in the application. This annotation actually forces you to apply proxy to some of the components that are defined in the spring configuration file. We'll talk more about Spring AOP later, in <a href="64590e34-2cb4-498b-a576-7a328e683632.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Spring Aspect Oriented Programming with Proxy and Decorator Pattern</em>. For now, it's enough to know that you've asked Spring to call <kbd>logBeforeTransfer()</kbd> and <kbd>logAferTransfer()</kbd> of <kbd>LoggingAspect</kbd> before and after the <kbd>transferAmount()</kbd> method of the <kbd>TransferService</kbd> class. For now, there are two important points to take away from this example:</p>
<ul>
<li><kbd>LoggingAspect</kbd> is still a POJO (if you ignore the <kbd>@Aspect</kbd> annotation or are using XML-based configuration)--nothing about it indicates that it's to be used as an aspect.</li>
<li>It is important to remember that <kbd>LoggingAspect</kbd> can be applied to <kbd>TransferService</kbd> without <kbd>TransferService</kbd> needing to explicitly call it. In fact, <kbd>TransferService</kbd> remains completely unaware of the existence of <kbd>LoggingAspect</kbd>.</li>
</ul>
<p>Let's move to another way that Spring simplifies Java development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying the template pattern to eliminate boilerplate code</h1>
                </header>
            
            <article>
                
<p>At one point in the enterprise application, we saw some code that looked like code we had already written before in the same application. That is actually boilerplate code. It is code that we often have to write again and again in the same application to accomplish common requirements in different parts of the application. Unfortunately, there are a lot of places where Java APIs involve a bunch of boilerplate code. A common example of boilerplate code can be seen when working with JDBC to query data from a database. If you've ever worked with JDBC, you've probably written something in code that deals with the following:</p>
<ul>
<li>Retrieving a connection from the connection pool</li>
<li>Creating a <kbd>PreparedStatement</kbd> object</li>
<li>Binding SQL parameters</li>
<li>Executing the <kbd>PreparedStatement</kbd> object</li>
<li>Retrieving data from the <kbd>ResultSet</kbd> object and populating data container objects</li>
<li>Releasing all database resources</li>
</ul>
<p>Let's look at the following code, it contains boilerplate code with the JDBC API of the Java:</p>
<pre>    public Account getAccountById(long id) { 
      Connection conn = null; 
      PreparedStatement stmt = null; 
      ResultSet rs = null; 
      try { 
        conn = dataSource.getConnection(); 
        stmt = conn.prepareStatement( 
          "select id, name, amount from " + 
          "account where id=?"); 
        stmt.setLong(1, id); 
        rs = stmt.executeQuery(); 
        Account account = null; 
        if (rs.next()) { 
          account = new Account(); 
          account.setId(rs.getLong("id")); 
          account.setName(rs.getString("name")); 
          account.setAmount(rs.getString("amount")); 
        } 
        return account; 
      } catch (SQLException e) { 
      } finally { 
          if(rs != null) { 
            try { 
              rs.close(); 
            } catch(SQLException e) {} 
          } 
          if(stmt != null) { 
            try { 
              stmt.close(); 
            } catch(SQLException e) {} 
          } 
          if(conn != null) { 
            try { 
              conn.close(); 
            } catch(SQLException e) {} 
          } 
        } 
      return null; 
    } </pre>
<p>In the preceding code, we can see that the JDBC code queries the database for an account name and amount. For this simple task, we have to create a connection, then create a statement, and finally query for the results. We also have to catch <kbd>SQLException</kbd>, a checked exception, even though there's not a lot you can do if it's thrown. Lastly, we have to clean up the mess, closing down the connection statement and result set. This could also force it to handle JDBC's exception, so you must catch <kbd>SQLException</kbd> here as well. This kind of boilerplate code seriously hurts reusability.</p>
<p>Spring JDBC solves the problem of boilerplate code by using the Template Design pattern, and it makes life very easy by removing the common code in templates. This makes the data access code very clean and prevents nagging problems, such as connection leaks, because the Spring Framework ensures that all database resources are released properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Template Design pattern in Spring</h1>
                </header>
            
            <article>
                
<p>Let's see how to go about using the Template Design pattern in spring:</p>
<ul>
<li>Define the outline or skeleton of an algorithm</li>
</ul>
<ol>
<li>Leave the details for specific implementations until later.</li>
<li>Hide away large amounts of boilerplate code.</li>
</ol>
<ul>
<li>Spring provides many template classes:</li>
<li><kbd>JdbcTemplate</kbd></li>
<li><kbd>JmsTemplate</kbd></li>
<li><kbd>RestTemplate</kbd></li>
<li><kbd>WebServiceTemplate</kbd></li>
<li>Most hide low-level resource management</li>
</ul>
<p>Let's look at the same code that we used earlier with Spring's <kbd>JdbcTemplate</kbd> and how it removes the boilerplate code.</p>
<p>Use <kbd>JdbcTemplates</kbd> to let your code the focus on the task:</p>
<pre>    public Account getAccountById(long id) { 
      return jdbcTemplate.queryForObject( 
        "select id, name, amoount" + 
        "from account where id=?", 
         new RowMapper&lt;Account&gt;() { 
           public Account mapRow(ResultSet rs, 
            int rowNum) throws SQLException { 
              account = new Account(); 
              account.setId(rs.getLong("id")); 
              account.setName(rs.getString("name")); 
              account.setAmount(rs.getString("amount")); 
              return account; 
            } 
         }, 
      id); 
    } </pre>
<p>As you can see in the preceding code, this new version of <kbd>getAccountById()</kbd> is much simpler as compared to the boiler plate code, and here the method is focused on selecting an account from the database rather than creating a database connection, creating a statement, executing the query, handling the SQL exception, and finally closing the connection as well. With the template, you have to provide the SQL query and a <kbd>RowMapper</kbd> used for mapping the resulting set data to the domain object in the template's <kbd>queryForObject()</kbd> method. The template is responsible for doing everything for this operation, such as database connection and so on. It also hides a lot of boilerplate code behind the framework.</p>
<p>We have seen in this section how Spring attacks the complexities of Java development with the power of POJO-oriented development and patterns such as the DI pattern, the Aspect-using Proxy pattern, and the Template method design pattern.</p>
<p>In the next section, we will look at how to use a Spring container to create and manage the Spring beans in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a Spring container to manage beans with the Factory pattern</h1>
                </header>
            
            <article>
                
<p>Spring provides us with a container, and our application objects live in this Spring container. As shown in the following diagram, this container is responsible for creating and managing the objects:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="222" width="350" class=" image-border" src="assets/f104d80b-e7c3-4be5-8407-8f61d8d3dc87.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">In a Spring application, our application objects live in this Spring container</div>
<p>The <strong>Spring Container</strong> also wires the many <strong>Object</strong> together according to its configuration. It is configured with some initialized parameters, and manages their complete life cycle from start to finish.</p>
<p>Basically, there are two distinct types of Spring container:</p>
<ul>
<li>Bean factory</li>
<li>Application contexts</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bean factory</h1>
                </header>
            
            <article>
                
<p>In the Spring Framework, the <kbd>org.springframework.beans.factory.BeanFactory</kbd> interface provides the bean factory, which is a Spring IoC container. <kbd>XmlBeanFactory</kbd> is an implementation class for this interface. This container reads the configuration metadata from an XML file. It is based on the GOF factory method design pattern--it creates, manages, caches, and wires the application objects in a sophisticated manner. The bean factory is merely an object pool where objects are created and managed by configuration. For small applications, this is sufficient, but enterprise applications demand more, so spring provides another version of the spring container with more features.</p>
<p>In the next section, we will learn about the application context and how Spring creates it in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application contexts</h1>
                </header>
            
            <article>
                
<p>In the Spring Framework, the <kbd>org.springframework.context.ApplicationContext</kbd> interface also provides Spring's IoC container. It is simply a wrapper of the bean factory, providing some extra application context services, such as support for AOP and, hence, declarative transaction, security, and instrumentation support such as support for message resources required for internationalization, and the ability to publish application events to interested event listeners.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a container with an application context</h1>
                </header>
            
            <article>
                
<p>Spring provides several flavors of application context as a bean container. There are multiple core implementations of the <kbd>ApplicationContext</kbd> interface, as shown here:</p>
<ul>
<li><kbd>FileSystemXmlApplicationContext</kbd>: This class is an implementation of <kbd>ApplicationContext</kbd> that loads application context bean definitions from the configuration files (XML) located in the file system.</li>
<li><kbd>ClassPathXmlApplicationContext</kbd>: This class is an implementation of <kbd>ApplicationContext</kbd> that loads application context bean definitions from the configuration files (XML) located in the classpath of the application.</li>
<li><kbd>AnnotationConfigApplicationContext</kbd>: This class is an implementation of <kbd>ApplicationContext</kbd> that loads application context bean definitions from the configuration classes (Java based) from the class path of the application.</li>
</ul>
<p>Spring provides you with a web-aware implementation of the <kbd>ApplicationContext</kbd> interface, as shown here:</p>
<ul>
<li><kbd>XmlWebApplicationContext</kbd>: This class is a web-aware implementation of <kbd>ApplicationContext</kbd> that loads application context bean definitions from the configuration files (XML) contained in a web application.</li>
<li><kbd>AnnotationConfigWebApplicationContext</kbd>: This class is a web-aware implementation of <kbd>ApplicationContext</kbd> that loads Spring web application context bean definitions from one or more Java-based configuration classes.</li>
</ul>
<p>We can use either one of these implementations to load beans into a bean factory. It depends upon our application configuration file locations. For example, if you want to load your configuration file <kbd>spring.xml</kbd> from the file system in a specific location, Spring provides you with a <kbd>FileSystemXmlApplicationContext</kbd>, <span>class</span> that looks for the configuration file <kbd>spring.xml</kbd> in a specific location within the file system:</p>
<pre>    ApplicationContext context = new<br/>     FileSystemXmlApplicationContext("d:/spring.xml"); </pre>
<p>In the same way, you can also load your application configuration file <kbd>spring.xml</kbd> from the classpath of your application by using a <kbd>ClassPathXmlApplicationContext</kbd> class provided by Spring. It looks for the configuration file <kbd>spring.xml</kbd> anywhere in the classpath (including JAR files):</p>
<pre>    ApplicationContext context = new <br/>     ClassPathXmlApplicationContext("spring.xml"); </pre>
<p>If you are using a Java configuration instead of an XML configuration, you can use <kbd>AnnotationConfigApplicationContext</kbd>:</p>
<pre>    ApplicationContext context = new <br/>     AnnotationConfigApplicationContext(AppConfig.class); </pre>
<p>After loading the configuration files and getting an application context, we can fetch beans from the Spring container by calling the <kbd>getBean()</kbd> method of the application context:</p>
<pre>    TransferService transferService = <br/>     context.getBean(TransferService.class); </pre>
<p>In the following section, we will learn about the Spring bean life cycle, and how a Spring container reacts to the Spring bean to create and manage it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Life of a bean in the container</h1>
                </header>
            
            <article>
                
<p>The Spring application context uses the Factory method design pattern to create Spring beans in the container in the correct order according to the given configuration. So the Spring container has the responsibility of managing the life cycle of the bean from creation to destruction. In the normal java application, Java's <kbd>new</kbd> keyword is used to instantiate the bean, and it's ready to use. Once the bean is no longer in use, it's eligible for garbage collection. But in the Spring container, the life cycle of the bean is more elaborate. The following image shows the life cycle of a typical Spring bean:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="397" width="483" class=" image-border" src="assets/4d82146c-4b42-40ac-be72-3de7fd446161.png"/></div>
<p>The life cycle of a Spring bean in the Spring container is as follows:</p>
<ol>
<li>Load all bean definitions, creating an ordered graph.</li>
<li>Instantiate and run <kbd>BeanFactoryPostProcessors</kbd> (you can update bean definitions here).</li>
<li>Instantiate each bean.</li>
</ol>
<ol start="4">
<li>Spring injects the values and bean references into the beans' properties.</li>
<li>Spring passes the ID of the bean to the <kbd>setBeanName()</kbd> method of the <kbd>BeanNameAware</kbd> interface if any bean implements it.</li>
<li>Spring passes the reference of the bean factory itself to the <kbd>setBeanFactory()</kbd> method of <kbd>BeanFactoryAware</kbd> if any bean implements it.</li>
<li>Spring passes the reference of the application context itself to the <kbd>setApplicationContext()</kbd> method of <kbd>ApplicationContextAware</kbd> if any bean implements it.</li>
<li><kbd>BeanPostProcessor</kbd> is an interface, and Spring allows you to implement it with your bean, and modifies the instance of the bean before the initializer is invoked in the Spring bean container by calling its <kbd>postProcessBeforeInitialization()</kbd>.</li>
<li>If your bean implements the <kbd>InitializingBean</kbd> interface, Spring calls its <kbd>afterPropertiesSet()</kbd> method to initialize any process or loading resource for your application. It's dependent on your specified initialization method. There are other methods to achieve this step, for example, you can use the <kbd>init-method</kbd> of the <kbd>&lt;bean&gt;</kbd> tag, the <kbd>initMethod</kbd> attribute of the <kbd>@Bean</kbd> annotation, and JSR 250's <kbd>@PostConstruct</kbd> annotation.</li>
<li><kbd>BeanPostProcessor</kbd> is an interface, and spring allows you to implement it with your bean. It modifies the instance of the bean after the initializer is invoked in the spring bean container by calling its <kbd>postProcessAfterInitialization()</kbd>.</li>
<li>Now your bean is ready to use in the step, and your application can access this bean by using the <kbd>getBean()</kbd> method of the application context. Your beans remain live in the application context until it is closed by calling the <kbd>close()</kbd> method of the application context.</li>
<li>If your bean implements the <kbd>DisposibleBean</kbd> interface, Spring calls its <kbd>destroy()</kbd> method to destroy any process or clean up the resources of your application. There are other methods to achieve this step-for example, you can use the <kbd>destroy-method</kbd> of the <kbd>&lt;bean&gt;</kbd> tag, the <kbd>destroyMethod</kbd> attribute of the <kbd>@Bean</kbd> annotation, and JSR 250's <kbd>@PreDestroy</kbd> annotation.</li>
<li>These steps show the life cycle of Spring beans in the container.</li>
<li>The next section describes the modules that are provided by the Spring Framework.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring modules</h1>
                </header>
            
            <article>
                
<p>Spring Framework has several distinct modules for a specific set of functionalities, and they work more or less independently of the others. This system is very flexible, so the developer can choose only those required for the enterprise application. For example, a developer can just use the Spring DI module and build the rest of the application with non-Spring components. So, Spring provides integration points to work with other frameworks and APIs--for example, you can use the Spring Core DI pattern only with the Struts application. In case the development team is more proficient in using Struts, it can be used instead of Spring MVC while the rest of the application uses Spring components and features, such as JDBC and transactions. So while the developers need to deploy the required dependencies with the Struts application, there is no need to add a whole Spring Framework.</p>
<p>Here is an overview of the entire module structure:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="315" width="456" class=" image-border" src="assets/8ffd496c-8122-4b1c-8392-ec78d0961c87.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The various modules of the Spring Framework</div>
<p>Let's look at each of Spring's modules and see how each fits in to the bigger picture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core Spring container</h1>
                </header>
            
            <article>
                
<p>This module of the Spring Framework uses lot of the design pattern such as the Factory method design pattern, DI pattern, Abstract Factory Design pattern, Singleton Design pattern, Prototype Design pattern, and so on. All other Spring modules are dependent on this module. You'll implicitly use these classes when you configure your application. It is also called the IoC container and is central to Spring's support for dependency injection, which manages how the beans in a Spring application are created, configured, and managed. You can create Spring container either by using the implementations of <kbd>BeanFactory</kbd> or the implementations of the <kbd>ApplicationContext</kbd>. This module contains the Spring bean factory, which is the portion of Spring that provides the DI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring's AOP module</h1>
                </header>
            
            <article>
                
<p>Spring AOP is a Java-based AOP Framework with AspectJ integration. It uses dynamic proxies for aspect weaving and focuses on using AOP to solve enterprise problems. This module is based on Proxy and Decorator Design patterns. This module enables the modularization of cross-cutting concerns to avoid tangling and eliminate scattering. Like DI, it supports loose coupling between the core business service and cross-cutting concerns. You can implement your custom aspects and configure them declaratively in your application without impacting on the code of business objects. It provides much flexibility in the code; you could remove or change the aspect logic without touching the code of the business objects. This is a very important module of the spring framework, so I will discuss it in detail in <a href="64590e34-2cb4-498b-a576-7a328e683632.xhtml" target="_blank">Chapter 6</a>, <em>Spring Aspect Oriented Programming with Proxy and Decorator Pattern</em> of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring DAO - data access and integration</h1>
                </header>
            
            <article>
                
<p>Spring DAO and Spring JDBC make life very easy by using templates to remove the common code. The templates implement the GOF template method design pattern and provide suitable extension points to plug in custom code. If you are working with a traditional JDBC application, you have to write lots of boilerplate code to, for example, create a database connection, create a statement, find a result set, handle SQLException, and finally close the connection. If you are working with a Spring JDBC Framework with a DAO layer, then you do not have to write boilerplate code, unlike a traditional JDBC application. That means that Spring allows you to keep your application code clean and simple.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring's ORM</h1>
                </header>
            
            <article>
                
<p>Spring also provides support to ORM solutions, and it provides integration with ORM tools for easy persistence of POJO objects in relational databases. This module actually provides an extension to the Spring DAO module. Like JDBC-based templates, Spring provides ORM templates to work with leading ORM products, such as Hibernate, JPA, OpenJPA, TopLink, iBATIS, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring web MVC</h1>
                </header>
            
            <article>
                
<p>Spring provides a web and remote module for the enterprise web application. This module helps build highly flexible web applications, leveraging the complete benefits of the Spring IOC container. This module of Spring uses the patterns such as the MVC architectural pattern, Front Controller pattern, and the DispatcherServlet Pattern, and it seamlessly integrates with the servlet API. The Spring web module is very pluggable and flexible. We can add any of the view technologies, such as JSP, FreeMarker, Velocity, and so on. We can also integrate it with other frameworks, such as Struts, Webwork, and JSF, using spring IOC and DI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New features in Spring Framework 5.0</h1>
                </header>
            
            <article>
                
<p>Spring 5.0 is the freshest release of Spring available. There are a lot of exciting new features in Spring 5.0, including the following:</p>
<ul>
<li>Support for JDK 8 + 9 and Java EE 7 Baseline:</li>
</ul>
<p style="padding-left: 90px">Spring 5 supports Java 8 as a minimum requirement, as the entire framework codebase is based on Java 8.</p>
<p style="padding-left: 90px">Spring Framework required at least Java EE 7 to run Spring Framework 5.0 applications. That means it requires Servlet 3.1, JMS 2.0, JPA 2.1.</p>
<ul>
<li>Deprecated and removed packages, classes, and methods:</li>
</ul>
<p style="padding-left: 90px">In Spring 5.0, some packages have been either removed or deprecated. It has had a package called <kbd>mock.static</kbd> removed from the spring-aspects module, and hence there is no support for <kbd>AnnotationDrivenStaticEntityMockingControl</kbd>.</p>
<p style="padding-left: 90px">Packages such as <kbd>web.view.tiles2</kbd> and <kbd>orm.hibernate3/hibernate4</kbd> have also been removed as of Spring 5.0. Now, in the latest spring framework, Tiles 3 and Hibernate 5 are being used.</p>
<p style="padding-left: 90px">The Spring 5.0 framework doesn't support Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava (and so on) anymore.</p>
<p style="padding-left: 90px">Some deprecated classes and methods of earlier versions of Spring have been removed as of Spring 5.0.</p>
<ul>
<li>Adding the new reactive programming model:</li>
</ul>
<p style="padding-left: 90px">This model of programming has been introduced in the Spring 5.0 Framework. Let's look at the following listed point about the reactive programming model.</p>
<p style="padding-left: 90px">Spring 5 introduced the Spring-core module <kbd>DataBuffer</kbd> and encoder/decoder abstractions with non-blocking semantics into the reactive programming model.</p>
<p style="padding-left: 90px">Using the reactive model, Spring 5.0 provides the Spring-web module for HTTP message codec implementations with <strong>JSON</strong> (<strong>Jackson</strong>) and <strong>XML</strong> (<strong>JAXB</strong>) support.</p>
<p style="padding-left: 90px">The Spring reactive programming model added a new <kbd>spring-web-reactive</kbd> module with reactive support for the <kbd>@Controller</kbd> programming model, adapting reactive streams to Servlet 3.1 containers, as well as non-Servlet runtimes, such as Netty and Undertow.</p>
<p style="padding-left: 90px">Spring 5.0 also introduced a new <kbd>WebClient</kbd> with reactive support on the client side to access services.</p>
<p>As listed here, you can see that there are a lot of exciting new features and enhancements in the Spring Framework 5. So in this book, we will look at many of these new features with examples and their adopted design patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>After reading this chapter, you should now have a good overview of the Spring Framework and its most-used design patterns. I highlighted the problem with the J2EE traditional application, and how Spring solves these problems and simplifies Java development by using lots of design patterns and good practices to create an application. Spring aims to make enterprise Java development easier and to promote loosely coupled code. We have also discussed Spring AOP for cross-cutting concerns and the DI pattern for use with loose coupling and pluggable Spring components so that the objects don't need to know where their dependencies come from or how they're implemented. Spring Framework is an enabler for best practices and effective object design. Spring Framework has two important features--First it has a Spring container to create and manage the life of beans and second it provides support to several modules and integration to help simplify Java development.</p>


            </article>

            
        </section>
    </body></html>