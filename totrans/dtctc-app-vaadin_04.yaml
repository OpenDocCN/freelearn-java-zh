- en: Implementing Authentication and Authorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现认证和授权
- en: Authentication is the process that ensures the identity of a user, usually done
    by providing a set of identifying credentials (username and password). Authorization
    is the security process that determines the access levels a user has in the application.
    In this chapter, we will continue with the development of the login form implemented
    in [Chapter 3](f992404d-986b-42b9-893e-3667c122030f.xhtml), *Implementing Server-Side
    Components with Internationalization*, by adding authentication and authorization
    features. We'll also learn how to implement the *remember me* option in the login
    form.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是确保用户身份的过程，通常通过提供一组识别凭证（用户名和密码）来完成。授权是确定用户在应用程序中访问级别的安全过程。在本章中，我们将继续开发在[第3章](f992404d-986b-42b9-893e-3667c122030f.xhtml)中实现的登录表单，*使用国际化实现服务器端组件*，通过添加认证和授权功能。我们还将学习如何在登录表单中实现*记住我*选项。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: The HTTP session
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP会话
- en: Cookies management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie管理
- en: Authorization and authentication mechanisms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权和认证机制
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要具备Java SE开发工具包和Java EE SDK版本8或更高版本。您还需要Maven版本3或更高版本。建议使用具有Maven支持的Java IDE，例如IntelliJ
    IDEA、Eclipse或NetBeans。最后，为了使用本书的Git仓库，您需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：
- en: '[https://goo.gl/RM8KNY](https://goo.gl/RM8KNY)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/RM8KNY](https://goo.gl/RM8KNY)'
- en: Implementing public and private views
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现公共和私有视图
- en: 'Frequently, web applications have two main screens. One for visitors who are
    not authenticated, and one for users who are authenticated. It makes sense to
    implement the UI in a way that reflects this exactly. The idea is to create two
    custom components (using the `Composite` class); one for public access, and one
    for authenticated users. So, for now, let''s suppose we have a custom `PublicComponent`
    class that shows the login form and a `PrivateComponent` that shows something
    like the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web应用程序有两个主要屏幕。一个用于未认证的访客，另一个用于已认证的用户。以这种方式实现UI以反映这一点是有意义的。想法是创建两个自定义组件（使用`Composite`类）；一个用于公开访问，另一个用于已认证用户。所以，现在让我们假设我们有一个自定义的`PublicComponent`类，它显示登录表单，以及一个`PrivateComponent`，它显示如下内容：
- en: '![](img/2cee696c-3b6c-46f3-8d88-383c48c6e40f.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cee696c-3b6c-46f3-8d88-383c48c6e40f.png)'
- en: When the user is successfully authenticated, the `PrivateComponent` is shown.
    When the Logout button is clicked, the user should be redirected to the `PublicComponent`.
    The Vaadin `UI` implementation (`VaadinUI` in this chapter's example) should reflect
    the fact that there are two main screens that can be shown depending on whether
    the user is authenticated or not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户成功认证后，将显示`PrivateComponent`。当点击注销按钮时，用户应被重定向到`PublicComponent`。在本章示例中，Vaadin
    `UI`实现（`VaadinUI`）应反映这样一个事实：根据用户是否已认证，可以显示两个主要屏幕。
- en: 'The `init` method of the `UI` implementation should verify whether a user is
    authenticated already, and if so, show the `PrivateComponent`. Otherwise, it should
    show the `PublicComponent`. This is necessary to cover the case when the user
    reloads the page in the browser: we don''t want the user to have to re-authenticate
    after a page reload. In plain Java, this functionality looks like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`UI`实现的`init`方法应验证用户是否已经认证，如果是，则显示`PrivateComponent`。否则，应显示`PublicComponent`。这是必要的，以覆盖用户在浏览器中重新加载页面的情况：我们不希望用户在页面重新加载后需要重新认证。在纯Java中，此功能看起来如下：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll develop the `AuthService` class in a bit, but the point in this section
    is to show you how simple the `UI` implementation can be. Always try to keep your
    `UI` implementation simple! Delegate to other classes the actual functionality
    of your application. Reflect only the essence of the top-level workflow of the
    application in your `UI` implementation. In our case, a simple class that shows
    one of two main screens, plus a sensible default depending on the authentication
    state, is enough.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后开发 `AuthService` 类，但本节的重点是向你展示 `UI` 实现可以多么简单。始终尝试保持你的 `UI` 实现简单！将应用程序的实际功能委托给其他类。在你的
    `UI` 实现中仅反映应用程序顶级工作流程的本质。在我们的案例中，一个简单的类显示两个主要屏幕之一，以及根据认证状态的一个合理的默认值，就足够了。
- en: One of the security features of Vaadin Framework is the fact that, by default,
    there's no way to access the execution of code by requesting different URLs. In
    the previous example, requesting `http://localhost:8080` will always invoke the
    `init` method, which gives us the chance to check whether the user is authenticated
    or not by asking a service class. You might be wondering how the authentication
    state is kept on the server. The answer is the HTTP session.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Vaadin 框架的一个安全特性是默认情况下，无法通过请求不同的 URL 来访问代码的执行。在先前的示例中，请求 `http://localhost:8080`
    总是会调用 `init` 方法，这给了我们机会通过询问一个服务类来检查用户是否已认证。你可能想知道认证状态是如何在服务器上保持的。答案是 HTTP 会话。
- en: You can learn more about security in Vaadin Framework applications at [https://vaadin.com/security](https://vaadin.com/security).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://vaadin.com/security](https://vaadin.com/security) 上了解更多关于 Vaadin
    框架应用中的安全信息。
- en: Using the HTTP session and cookies to identify users
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 会话和 cookies 来识别用户
- en: 'One way of keeping track of the state of a web application is by making use
    of the HTTP session. The currently authenticated user is part of the state of
    the application and can be stored in the HTTP session. In Vaadin applications,
    you can store values in the HTTP session by using the `VaadinSession.setAttribute(String,
    Object)` method. The first parameter is a custom identifier for the value which
    is specified using the second parameter. For example, we can store the number
    `777` in an attribute with the name `number` in the HTTP session as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪 Web 应用程序状态的一种方式是利用 HTTP 会话。当前认证的用户是应用程序状态的一部分，可以存储在 HTTP 会话中。在 Vaadin 应用程序中，你可以使用
    `VaadinSession.setAttribute(String, Object)` 方法在 HTTP 会话中存储值。第一个参数是值的自定义标识符，它使用第二个参数指定。例如，我们可以在
    HTTP 会话中按以下方式将数字 `777` 存储在名为 `number` 的属性中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can remove the value from the session by passing `null`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递 `null` 来从会话中移除值：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keeping track of authenticated users
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪认证用户
- en: 'Following this approach, we can store the `username` in the HTTP session when
    a user is successfully authenticated. We can also check whether the user has been
    authenticated by checking whether a value exists in the HTTP session. This can
    be implemented as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们可以在用户成功认证时在 HTTP 会话中存储 `username`。我们还可以通过检查 HTTP 会话中是否存在值来检查用户是否已认证。这可以按以下方式实现：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few things to notice here. First, for simplicity in this example,
    the code checks whether `username` and `password` are both equal to the string
    `"admin"`. In a real application, this should query a database or delegate to
    any other authentication process. For example, if you have a class that provides
    functionality to query user data, the Boolean check could look something like
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要注意的地方。首先，为了简化这个示例，代码检查 `username` 和 `password` 是否都等于字符串 `"admin"`。在实际应用中，这应该查询数据库或委托给任何其他认证过程。例如，如果你有一个提供查询用户数据功能的类，布尔检查可能看起来像以下这样：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Never store passwords in a way that they can be retrieved. In other words,
    always store *salted hashes* of passwords instead of the password itself. This
    can protect not only your users but also yourself! If you store a password as
    a hash of it, you can be sure that nobody, including you, can get to know the
    real password. If the database is compromised, at least the passwords are going
    to be garbage. Suppose you have a `hash` method that uses SHA or any other secure
    algorithm. When setting a password, you can save an entity with something like
    the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要以可以恢复的方式存储密码。换句话说，总是存储密码的**盐值哈希**而不是密码本身。这不仅可以保护你的用户，也可以保护你自己！如果你将密码存储为其哈希值，你可以确信没有人，包括你自己，能够知道真正的密码。如果数据库被破坏，至少密码将会是垃圾。假设你有一个使用SHA或其他任何安全算法的`hash`方法。在设置密码时，你可以保存一个实体，如下所示：
- en: '`user.setPassword(hash(theActualPassword));`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.setPassword(hash(theActualPassword));`'
- en: 'In order to check whether a password is correct (for example, during authentication),
    you can compare the hash of the given password with the value stored in the database.
    Something like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查密码是否正确（例如，在认证过程中），你可以将给定密码的哈希值与数据库中存储的值进行比较。如下所示：
- en: '`String stored = user.getPassword();`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String stored = user.getPassword();`'
- en: '`String hash = hash(attemptedPassword);`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String hash = hash(attemptedPassword);`'
- en: '`if (stored.equals(hash) {...}`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (stored.equals(hash) {...}`'
- en: Second, the `AuthService` class has Vaadin stuff in it. Service classes should
    be decoupled from the presentation technology, but in our case, that's okay, since
    there's not much chance of us changing the web framework! And that's usually the
    case in real-life applications anyway. Additionally, reusing this class out of
    the context of a Vaadin application doesn't seem very likely, but if it becomes
    necessary, you can decouple it from Vaadin by directly using the HTTP session.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`AuthService`类中包含了一些Vaadin相关的内容。服务类应该与表示技术解耦，但就我们而言，这是可以的，因为我们不太可能改变我们的Web框架！在现实生活中的应用程序中通常也是这种情况。此外，在Vaadin应用程序之外重用这个类似乎不太可能，但如果有必要，你可以通过直接使用HTTP会话将其从Vaadin中解耦。
- en: If your application allows third-party developers to add new functionality to
    your application and it exposes the HTTP session, developers might be able to
    impersonate a user if they know their username. Since the only condition for declaring
    a user as authenticated is to have an entry in the HTTP session with the corresponding
    username as its key, a malicious developer could add such a username and invoke
    other functionality on their behalf. In such cases, consider symmetrically encrypting
    the key (username) or even using an alternative storage mechanism for the HTTP
    session.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序允许第三方开发者向你的应用程序添加新功能，并且它公开了HTTP会话，那么如果开发者知道用户的用户名，他们可能能够冒充用户。由于将用户声明为已认证的唯一条件是在HTTP会话中有一个条目，其键为相应的用户名，恶意开发者可以添加这样的用户名并代表他们调用其他功能。在这种情况下，考虑对称加密键（用户名）或者甚至使用HTTP会话的替代存储机制。
- en: Implementing the login/logout process
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录/注销过程
- en: Let's recap what we have implemented at this point. We have a multi-language
    `LoginFormComponent` ready for use (developed in [Chapter 3](f992404d-986b-42b9-893e-3667c122030f.xhtml)*,
    Implementing Server-Side Components with Internationalization*), a `UI` implementation
    that shows a `PublicComponent` or a `PrivateComponent`, depending on whether a
    user is authenticated, and an `AuthService` class that allows us to authenticate
    a user (if their login credentials are correct) and check whether there is an
    authenticated user in the session or not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止我们已经实现的内容。我们有一个多语言的`LoginFormComponent`准备使用（在[第3章](f992404d-986b-42b9-893e-3667c122030f.xhtml)*，使用国际化实现服务器端组件*中开发），一个`UI`实现，根据用户是否认证显示`PublicComponent`或`PrivateComponent`，以及一个`AuthService`类，允许我们验证用户（如果他们的登录凭证正确）并检查会话中是否有已认证的用户。
- en: 'It''s time to complete the login/logout process by implementing the `PublicComponent`
    and `PrivateComponent` classes. Let''s start with the `PublicComponent` class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过实现`PublicComponent`和`PrivateComponent`类来完成登录/注销过程了。让我们从`PublicComponent`类开始：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This component extends `Composite` and uses the `LoginFormComponent` as its
    composition root. The `loginClicked` method is called when the user clicks the
    respective button, and it''s inside this method where we try to authenticate the
    user. If the credentials are correct, we show an error notification, but if they
    are correct, we are not doing anything at all! And actually, we don''t really
    need to do anything else in this class. Do you remember how we implemented the
    `VaadinUI` class so that it would show one screen or the other according to the
    authentication state? Well, all we need to do in order to make this work is add
    a simple page reload to the `AuthService.authenticate` method for when the authentication
    succeeds:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件扩展了`Composite`，并使用`LoginFormComponent`作为其组合根。当用户点击相应的按钮时，会调用`loginClicked`方法，并且就在这个方法中我们尝试验证用户。如果凭据正确，我们显示一个错误通知，但如果它们是正确的，我们实际上根本不需要做任何事情！实际上，我们在这个类中真的不需要做其他任何事情。你还记得我们是如何实现`VaadinUI`类，以便根据认证状态显示一个屏幕或另一个屏幕的吗？好吧，为了使这个功能正常工作，我们只需要在认证成功时将简单的页面刷新添加到`AuthService.authenticate`方法中：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's right! Since the `VaadinUI.init` method is called when the user refreshes
    the browser and our implementation checks whether there's an authenticated user
    in the HTTP session (via the `AuthService` class), we don't need to do anything
    else.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此！因为当用户刷新浏览器时，会调用`VaadinUI.init`方法，并且我们的实现会检查HTTP会话中是否存在已认证的用户（通过`AuthService`类），所以我们不需要做其他任何事情。
- en: 'How about the other way around? When the user logs out, we should perform two
    actions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那反过来呢？当用户登出时，我们应该执行两个操作：
- en: Remove all the data in the HTTP session (invalidate the session).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除HTTP会话中的所有数据（使会话无效）。
- en: Refresh the browser (in order to invoke the `VaadinUI.init` method and automatically
    show the `PublicComponent`).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器（以调用`VaadinUI.init`方法并自动显示`PublicComponent`）。
- en: 'It''s just reasonable to implement this functionality in the `AuthService`
    class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AuthService`类中实现这个功能是合理的：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `invalidate` method removes any values from the HTTP session and invalidates
    it. The server will create a new session if the application is requested again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`invalidate`方法会从HTTP会话中删除任何值并使其无效。如果再次请求应用程序，服务器将创建一个新的会话。'
- en: Servers maintain sessions in several ways, such as through cookies or URL rewriting.
    Depending on your specific server, you might have to call `VaadinService.reinitializeSession(VaadinService.getCurrentRequest())`
    to ensure a new session key is generated after you invalidate a session.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通过多种方式维护会话，例如通过cookie或URL重写。根据您的特定服务器，您可能需要调用`VaadinService.reinitializeSession(VaadinService.getCurrentRequest())`以确保在使会话无效后生成新的会话密钥。
- en: Notice how we reloaded the browser this time. Instead of calling the `Page.reload()`
    method, we are making sure that the URL in the browser requests the starting URL
    for the web application. This will also remove, for example, any fragments or
    parameters from the URL that may contain *sensitive information*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们这次是如何重新加载浏览器的。我们不是调用`Page.reload()`方法，而是确保浏览器中的URL请求Web应用程序的起始URL。这也会删除例如可能包含*敏感信息*的任何片段或参数。
- en: '*Sensitive information* refers to any kind of data, information, or knowledge
    that must be protected against unauthorized access.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*敏感信息*指的是任何必须保护免受未经授权访问的数据、信息或知识。'
- en: 'Finally, the `PrivateComponent` class should be pretty straightforward to implement.
    For the sake of completeness, here''s the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`PrivateComponent`类的实现应该相当直接。为了完整性，以下是代码：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice the `AuthService.getAuthenticatedUser()` method. You can implement that
    method with one line of code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`AuthService.getAuthenticatedUser()`方法。您可以使用一行代码实现该方法：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember to use HTTPS (HTTP Secure) any time you have a web application with
    a login form that sends user credentials through the network. By enabling HTTPS,
    the data is encrypted, preventing man-in-the-middle attacks. You can learn more
    about how to enable HTTPS at [https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate](https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在拥有发送用户凭据通过网络登录表单的Web应用程序时，始终使用HTTPS（HTTP安全）。通过启用HTTPS，数据会被加密，防止中间人攻击。您可以在[https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate](https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate)了解更多关于如何启用HTTPS的信息。
- en: Implementing the remember me feature
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现记住我功能
- en: The *remember me* feature allows users to automatically authenticate themselves
    with the web application even after they have closed the browser, or the HTTP
    session has been destroyed, without having to enter their usernames and passwords.
    If a user has previously authenticated themselves and chose to be remembered,
    the web application will, remember the user using HTTP cookies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: “记住我”功能允许用户在关闭浏览器或HTTP会话被销毁后，无需输入用户名和密码，自动通过Web应用程序进行身份验证。如果用户之前已经进行了身份验证并选择被记住，Web应用程序将使用HTTP
    cookie记住用户。
- en: 'Essentially, with the *remember me* feature, your application can consume two
    kinds of *login credentials*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用“记住我”功能，您的应用程序可以消耗两种类型的“登录凭证”：
- en: A username and password combination
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名和密码组合
- en: A valid HTTP cookie previously created by the web application
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前由Web应用程序创建的有效HTTP cookie
- en: Let's think of the login/logout process, putting the *remember me* functionality
    into play this time. When a user requests the web application for the first time,
    the `VaadinUI.init` method is invoked. This method will check whether the user
    is authenticated or not in order to show the corresponding `UI` component. This
    is delegated to the `AuthService` class in our example. The `AuthService.isAuthenticated`
    method checks whether or not there's an authenticated user in the HTTP session.
    At first, there is none, so it should check whether the user was *remembered*
    before. Ignoring the details, we know the user was not remembered before. So the
    `PublicComponent` is shown and the user can log in with, username and password.
    But this time, the user checks the Remember me checkbox.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑登录/注销过程，这次将“记住我”功能付诸实践。当用户第一次请求Web应用程序时，会调用`VaadinUI.init`方法。此方法将检查用户是否已认证，以便显示相应的`UI`组件。在我们的示例中，这被委托给`AuthService`类。`AuthService.isAuthenticated`方法检查HTTP会话中是否有已认证的用户。一开始，没有用户，因此它应该检查用户之前是否被“记住”。忽略细节，我们知道用户之前没有被记住。因此，显示`PublicComponent`，用户可以使用用户名和密码登录。但这次，用户勾选了“记住我”复选框。
- en: We need to tell this choice to the `AuthService.authenticate` method (by passing
    a Boolean value from the checkbox), which in turn will check if the username and
    password are correct and, if so, perform the logic to *remember* the user. This
    is the interesting part.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这个选择告诉`AuthService.authenticate`方法（通过从复选框传递一个布尔值），然后它将检查用户名和密码是否正确，如果是，则执行记住用户的逻辑。这是有趣的部分。
- en: A user is remembered by creating an HTTP cookie with the name, say `remember-me`,
    and storing a value that allows us to identify the user later. We could be tempted
    to simply store the plain username in this cookie, but that would lead to a serious
    security issue; if a malicious user has access to the browser and gets the value
    of a `remember-me` cookie, they will be able to sign in as that user by simply
    creating a cookie with the stolen value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个名为，例如`remember-me`的HTTP cookie并存储一个允许我们以后识别用户的值，用户会被记住。我们可能会被诱惑简单地在这个cookie中存储纯用户名，但这会导致一个严重的安全问题；如果恶意用户能够访问浏览器并获取`remember-me`
    cookie的值，他们只需创建一个带有被盗值的cookie，就能以该用户身份登录。
- en: Instead of storing *sensitive information* in the cookie, we can store a randomly
    generated string and store the username in the server using a Java `Map`, where
    the key is the random string and the value is the username.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将敏感信息存储在cookie中，而是存储一个随机生成的字符串，并使用Java `Map`在服务器上存储用户名，其中键是随机字符串，值是用户名。
- en: Using a Java `Map` is good enough for the example in this chapter. However,
    keep in mind that if you restart the server, remembered users are no longer remembered
    (pun intended). A real-life application should use a persistent `Map`, such as
    an SQL table, but the principle is exactly the same. Additionally, you might want
    to store a hash of the random key, in the same way as you should do with user
    passwords. This will protect users if data in this table is compromised.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，使用Java `Map`就足够了。然而，请记住，如果您重新启动服务器，被记住的用户将不再被记住（有意为之）。现实生活中的应用程序应该使用持久`Map`，例如SQL表，但原理完全相同。此外，您可能还想以与用户密码相同的方式存储随机键的散列。这将保护用户，如果此表中的数据被泄露。
- en: So, let's recap. The user logged in by providing their username and password
    and checking the Remember me option, and the web application created a cookie
    containing a random key and stored the username in a `Map` using that key. Now,
    let's see what happens when the user closes the browser (or waits until the HTTP
    session is closed) and requests the web application again.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一下。用户通过提供用户名和密码并勾选“记住我”选项来登录，Web应用程序创建了一个包含随机密钥的cookie，并使用该密钥在 `Map`
    中存储用户名。现在，让我们看看当用户关闭浏览器（或等待HTTP会话关闭）并再次请求Web应用程序时会发生什么。
- en: As usual, the `VaadinUI.init` method is invoked and the `AuthService.isAuthenticated`
    method checks whether there's an authenticated user in the HTTP session. Of course,
    there isn't, and it proceeds with the cookie check. This time, there is a `remember-me`
    cookie, so the method just searches for the username in the `Map` of remembered
    users and gets the value of the username. Now, it should just store the username
    in the HTTP session and return `true`. The user was automatically authenticated!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，`VaadinUI.init` 方法被调用，`AuthService.isAuthenticated` 方法检查HTTP会话中是否有已认证的用户。当然，没有，它继续进行cookie检查。这次，有一个
    `remember-me` cookie，所以该方法只是在记住用户的 `Map` 中搜索用户名并获取用户名的值。现在，它应该将用户名存储在HTTP会话中并返回
    `true`。用户已被自动认证！
- en: The last part we need to consider is the logout action. When the user logs out,
    the `remember-me` cookie should be destroyed, along with the corresponding entry
    in the Java `Map` of remembered users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的最后一部分是注销操作。当用户注销时，`remember-me` cookie应该被销毁，同时也会销毁Java `Map` 中记住的用户对应的条目。
- en: 'I would urge you to try and implement all this by yourself. I have created
    a branch with the name `remember-me-exercise` in the source code that accompanies
    this book. You can use this branch as a starting point if you want to do the exercise.
    You can check it out by running:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您自己尝试实现所有这些。我已经在本书所附源代码中创建了一个名为 `remember-me-exercise` 的分支。如果您想进行练习，可以使用这个分支作为起点。您可以通过运行以下命令来检出它：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you prefer to see the solution, just check the code in the `master` branch.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看解决方案，只需检查 `master` 分支中的代码。
- en: 'Let''s see some snippets of code you could use for the exercise. Let''s begin
    with HTTP cookies management. You can send a new cookie to the browser by using
    the `VaadinRequest.addCookie` method. The following snippet of code creates a
    new cookie with the name `remember-me` and the value `admin` and sends it to the
    browser:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些可用于练习的代码片段。让我们从HTTP cookie管理开始。您可以通过使用 `VaadinRequest.addCookie` 方法向浏览器发送一个新的cookie。以下代码片段创建了一个名为
    `remember-me` 且值为 `admin` 的新cookie并将其发送到浏览器：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `setPath` defines the path for the cookie. The browser sends the cookies
    associated with that path in subsequent requests to the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPath` 定义了cookie的路径。浏览器会在随后的请求中将与该路径关联的cookie发送到服务器。'
- en: Note that the path should include the servlet's context path. You can get it
    by calling `VaadinServlet.getCurrent().getServletContext().getContextPath()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，路径应包括servlet的上下文路径。您可以通过调用 `VaadinServlet.getCurrent().getServletContext().getContextPath()`
    来获取它。
- en: The `setMaxAge` method allows you to set the time for which the cookie will
    be valid. The time is given in seconds, which means that the previous snippet
    creates a cookie valid for 15 days.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMaxAge` 方法允许您设置cookie有效的时长。时间以秒为单位，这意味着前面的代码片段创建了一个有效期为15天的cookie。'
- en: 'To delete a cookie, set its age to zero. For example, the following code removes
    the `remember-me` cookie:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除cookie，将其年龄设置为零。例如，以下代码删除了 `remember-me` cookie：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can get all the cookies reported by the browser by using the `VaadinRequest.getCookies`
    method. You can get an instance of `VaadinRequest` via `VaadinService.getCurrent()`.
    The following snippet of code retrieves an `Optional` of a cookie with the name
    `remember-me`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `VaadinRequest.getCookies` 方法获取浏览器报告的所有cookie。您可以通过调用 `VaadinService.getCurrent()`
    获取 `VaadinRequest` 的实例。以下代码片段检索名为 `remember-me` 的cookie的 `Optional` 实例：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, here there''s a tip to generate a random string suitable for the `Map`
    of remembered users:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个提示，用于生成适合记住用户 `Map` 的随机字符串：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In short, this converts a randomly generated `BigInteger` consisting of `130`
    bits and converts them into a sequence of base-32 characters. Although 128 bits
    is secure enough, a base-32 character can take five bits. *128/5 = 25.6*, so we
    need a couple of extra bits to get the next multiple of 5, which leads to *130/5=26*.
    In conclusion, we get 26 random characters. Keep in mind that UUIDs are not designed
    to be unpredictable and should not be used to identify sessions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这会将由`130`位组成的随机生成的`BigInteger`转换为一系列基于32的字符。尽管`128`位已经足够安全，但一个基于32的字符可以占用五个比特。*128/5
    = 25.6*，因此我们需要额外的几个比特来得到下一个5的倍数，这导致*130/5=26*。总之，我们得到26个随机字符。请记住，UUID不是设计成不可预测的，不应该用于标识会话。
- en: A good implementation should also periodically clean the `Map` of remembered
    users. This can be achieved by adding a custom data type that stores not only
    the username but the expiry date. A background process can run every day, checking
    for expired entries and removing them from the `Map`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的实现应该定期清理存储已记住用户的`Map`。这可以通过添加一个自定义数据类型来实现，该数据类型不仅存储用户名，还存储过期日期。一个后台进程可以每天运行，检查过期的条目并将它们从`Map`中删除。
- en: Enabling features according to a user's roles
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据用户的角色启用功能
- en: This section discusses authorization implementation strategies. Authorization
    is the process of granting access to resources according to a defined policy.
    Keep in mind that *authentication* is the process of verifying if a user or another
    system is who they claim they are, *authorization* deals with what a certain user
    can do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论授权实现策略。授权是根据定义的政策授予资源访问权限的过程。请记住，*认证*是验证用户或其他系统是否是他们所声称的身份的过程，*授权*处理特定用户可以做什么。
- en: Authorization mechanisms can be implemented in many ways depending on the specific
    requirements of an application. Some applications use a basic public/private approach
    (like the one we have used so far in this chapter) where the policy is as simple
    as checking if a user is authenticated in order to grant access to a certain UI
    component. Other applications may require multiple roles, each one with a different
    set of permissions. Moreover, a user may have multiple roles at the same time
    and those roles could change at runtime. And to make it a bit more complicated,
    a role could define a set of permissions that could also change at runtime.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 授权机制可以根据应用程序的具体要求以多种方式实现。一些应用程序使用基本的公共/私有方法（就像我们在本章中迄今为止所使用的那样），其中策略很简单，即检查用户是否已认证，以便授予对某个UI组件的访问权限。其他应用程序可能需要多个角色，每个角色都有不同的权限集。此外，用户可能同时拥有多个角色，并且这些角色可能在运行时发生变化。而且，为了使事情更加复杂，一个角色可以定义一组权限，这些权限也可能在运行时发生变化。
- en: Depending on the complexity of the authentication rules that your application
    must support, you would use one or another approach to authorization. Let's discuss
    some of them, which, hopefully, will inspire you and give you ideas about how
    to implement an authorization mechanism suitable for your application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的应用程序必须支持的认证规则复杂度，您将使用一种或另一种授权方法。让我们讨论一些方法，希望它们能给您以启发，并为您提供关于如何实现适合您应用程序的授权机制的想法。
- en: Coding authorization logic in UI components
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UI组件中编码授权逻辑
- en: 'The first approach we will discuss is including the authorization logic in
    the UI components themselves. This is what we have done in the example application,
    where we show a `PrivateComponent` if the user is authenticated or a `PublicComponent`
    if they are not. You can extrapolate this and use it with, for example, roles.
    Suppose there were two roles: *employee* and *admin*. You have to show a hypothetical
    `AdminComponent` to users with the role admin and an `EmployeeComponent` to users
    with the *employee* role. You can easily code a method that returns the right
    component according to the role as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一种方法是将授权逻辑包含在UI组件本身中。这就是我们在示例应用程序中所做的，其中如果用户已认证，则显示`PrivateComponent`，如果没有认证，则显示`PublicComponent`。你可以扩展这个方法，例如使用角色。假设有两个角色：*员工*和*管理员*。你必须向具有管理员角色的用户显示假设的`AdminComponent`，向具有*员工*角色的用户显示`EmployeeComponent`。你可以轻松编写一个方法，根据角色返回正确的组件，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If a new `Role` appears in future, you can simply add another `if` clause to
    cover the case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来出现新的`Role`，你可以简单地添加另一个`if`子句来处理该情况。
- en: 'What if there''s no need for a completely new UI component for a role? For
    example, let''s say the `EmployeeComponent` must show a *delete* button only for
    users with the *employee* role, and sonot for users with the *trainee* role. The
    easier solution is to code this logic inside the `EmployeeComponent` class itself,
    using something like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要为某个角色创建一个全新的 UI 组件，会怎样呢？例如，假设 `EmployeeComponent` 必须只为具有 `employee` 角色的用户显示
    `delete` 按钮，而不是为具有 `trainee` 角色的用户显示。一个更简单的解决方案是在 `EmployeeComponent` 类内部编码这个逻辑，如下所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A good thing about this approach is that you can follow the code to understand
    what's visible and what's not. However, you might end up with authorization code
    all over the source code. Well, at least over the UI-related classes. This is,
    however, a valid approach and you should at least consider it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是你可以通过代码来了解哪些内容可见，哪些不可见。然而，你可能会在源代码的各个地方看到授权代码。至少在 UI 相关的类中是这样。然而，这是一个有效的方法，你应该至少考虑它。
- en: A disadvantage of this way of implementing authorization is that it couples
    UI code with authorization code. This makes it a bit more difficult for software
    reuse. The preceding class, for example, cannot be used in a different application
    without carrying the `AuthService` class. Fortunately, we can easily decouple
    this class from the authentication stuff. The key is the *principle of least privilege*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现授权方式的一个缺点是它将 UI 代码与授权代码耦合在一起。这使得软件重用变得稍微困难一些。例如，前面的类如果没有携带 `AuthService`
    类就无法在另一个应用程序中使用。幸运的是，我们可以轻松地将这个类从认证相关的内容中解耦。关键是**最小权限原则**。
- en: 'The principle of least privilege states that a software entity should have
    access to the least or minimum amount of data it requires to perform its function.
    Can you see how the `EmployeeComponent` class violates this principle? All the
    class needs to know is whether to show the `delete` button or not. It doesn''t
    really care about roles and authentication logic. We are passing way too much
    information to it. What''s the minimal amount of information this class needs
    to fulfill its requirements? A simple Boolean telling it whether to show the `delete`
    button or not. That''s it. A possible implementation can include a parameter in
    the constructor for this purpose. Here''s an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最小权限原则指出，一个软件实体应该只访问它执行其功能所需的最少或最小量的数据。你能看到 `EmployeeComponent` 类是如何违反这个原则的吗？这个类只需要知道是否显示
    `delete` 按钮。它并不真正关心角色和认证逻辑。我们向它传递了过多的信息。这个类需要的最小信息量是多少？一个简单的布尔值，告诉它是否显示 `delete`
    按钮。就是这样。可能的实现可以包括一个构造函数参数来达到这个目的。以下是一个例子：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We just removed the coupling between this class and the authentication logic.
    However, we moved the authentication logic somewhere else. Now the client of the
    `EmployeeComponent` class must configure it depending on the authorization rules.
    It''s not such a bad thing considering that such a client is already coupled to
    the `AuthService` class, right? Take a look at the new implementation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚解除了这个类与认证逻辑之间的耦合。然而，我们将认证逻辑移动到了其他地方。现在，`EmployeeComponent` 类的客户端必须根据授权规则进行配置。考虑到这样的客户端已经与
    `AuthService` 类耦合，这并不是一件坏事，对吧？看看新的实现：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Optional` class serves as a container for a value that may or may not be
    `null` (we are not talking about a Vaadin `Container` here; the `Container` interface
    was removed in Vaadin Framework 8.0). `Optional` helps to decrease the number
    of null checks in your code. Instead of returning a null value from a method,
    you can return an `Optional`, which is empty when the enclosing value is null.
    This way, the client of the method knows that the returned value might be null.
    Bear in mind that the original purpose of the `Optional` class is to serve as
    an *optional return value*. Avoid using `Optional` in method parameters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 类用作可能为 `null` 或不为 `null` 的值的容器（我们这里不是在谈论 Vaadin 的 `Container`；`Container`
    接口在 Vaadin 框架 8.0 中已被移除）。`Optional` 有助于减少代码中的空值检查。你不需要从方法中返回一个 `null` 值，而是可以返回一个
    `Optional`，当封装的值是 `null` 时，它将是空的。这样，方法的客户端就知道返回的值可能为 `null`。记住，`Optional` 类的原始目的是作为**可选返回值**。避免在方法参数中使用
    `Optional`。'
- en: The main takeaway of this discussion is to keep in mind that you can provide
    configuration options for your UI components. Don't just unnecessarily couple
    them with authentication classes. Provide parameters in the constructors, setters,
    or even configuration classes if the complexity requires it in order to tell the
    UI component how it should look and behave.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论的主要收获是要记住，你可以为你的 UI 组件提供配置选项。不要仅仅无谓地将它们与认证类耦合在一起。在构造函数、设置器或甚至在需要时使用配置类提供参数，以便告诉
    UI 组件它应该如何看起来以及如何表现。
- en: Coding authorization using request data
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求数据编码授权
- en: 'Let''s study a strategy to implement authorization outside UI components. Web
    frameworks can be classified as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究一种在 UI 组件外部实现授权的策略。Web 框架可以分为：
- en: Component-based frameworks
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于组件的框架
- en: Request/response-based frameworks
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于请求/响应的框架
- en: Vaadin Framework is a component-based framework. It abstracts away the concept
    of request and response. You don't have to think much about it when developing
    a Vaadin application, and that's one of the key features of the framework. Thanks
    to its ability to allow developers to implement a web application by directly
    using the Java programming language, developers can use any object-oriented technique
    to implement features such as authorization. In fact, in the previous section,
    we explored how to do so using simple Java `if` statements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Vaadin 框架是一个基于组件的框架。它抽象掉了请求和响应的概念。在开发 Vaadin 应用程序时，你不需要过多地考虑它，这也是框架的关键特性之一。得益于其允许开发者直接使用
    Java 编程语言实现 Web 应用程序的能力，开发者可以使用任何面向对象的技术来实现诸如授权等特性。实际上，在前一节中，我们探讨了如何使用简单的 Java
    `if` 语句来实现这一点。
- en: Request/response based frameworks, on the other hand, usually make it a bit
    harder to use the approach we discussed in the previous section (coding the authorization
    logic directly in the UI component), in part because the UI layer runs in the
    client side. Coding authentication rules in the client side is a no-go. How do
    request/response based frameworks implement authorization? Typically, these frameworks
    include a *front controller*, a software entity that processes all the requests
    and decides which portion of your code should be invoked. It's then easy to add
    a *filter* to secure the requested resources according to a set of rules. In short,
    authorization is implemented with a combination of server-side code (which decides
    what to show in the browser) and a filter securing URLs according to authorization
    rules.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于请求/响应的框架通常会使我们在前一节中讨论的方法（直接在 UI 组件中编码授权逻辑）的使用变得有些困难，部分原因是因为 UI 层运行在客户端。在客户端编码认证规则是不可行的。基于请求/响应的框架是如何实现授权的？通常，这些框架包括一个
    *前端控制器*，这是一个处理所有请求并决定你的代码中哪一部分应该被调用的软件实体。然后很容易添加一个 *过滤器* 来根据一组规则保护请求的资源。简而言之，授权是通过服务器端代码（决定在浏览器中显示什么）和根据授权规则保护
    URL 的过滤器相结合来实现的。
- en: Can we use something similar with Vaadin? Let's explore the capabilities of
    Vaadin regarding *request information* to see how we can take advantage of it
    in order to design an authentication mechanism that is completely decoupled from
    the actual UI components.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否在 Vaadin 中使用类似的东西？让我们探索 Vaadin 在 *请求信息* 方面的能力，看看我们如何利用它来设计一个完全与实际 UI 组件解耦的认证机制。
- en: Getting request information
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取请求信息
- en: 'When we talk about a *request* made to a web application, we are talking about
    an HTTP request that a client, typically, a browser, makes to the web server.
    The server takes the *context path* and routes the request to the appropriate
    web application (for example, a Vaadin application). An important part of the
    HTTP request is the URL used to access the application and its resources. The
    following screenshot shows the most important parts of a URL:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论对 Web 应用程序的 *请求* 时，我们是在谈论客户端（通常是浏览器）向 Web 服务器发出的 HTTP 请求。服务器获取 *上下文路径*
    并将请求路由到适当的 Web 应用程序（例如，Vaadin 应用程序）。HTTP 请求的一个重要部分是用于访问应用程序及其资源的 URL。以下截图显示了 URL
    的最重要的部分：
- en: '![](img/0a9e9017-03a0-410a-ba27-eba4252c93a2.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a9e9017-03a0-410a-ba27-eba4252c93a2.png)'
- en: 'With Vaadin Framework you can get access to all these parts. For example, in
    order to get the *path info* part of the URL, you can call:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vaadin 框架，你可以访问所有这些部分。例如，为了获取 URL 的 *路径信息* 部分，你可以调用：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To get a *parameter* value, you can call:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 *参数* 值，你可以调用：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Routing requests to a UI component
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求路由到 UI 组件
- en: 'Using the *path info* part and *parameters*, you can already implement a mechanism
    that *routes* a request to a specific component, similarly to what a front controller
    does in a request/response-based framework. For example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*路径信息*部分和*参数*，你就可以实现一个机制，将请求*路由*到特定的组件，这类似于在基于请求/响应的框架中前端控制器所做的工作。例如：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the corresponding `UI` implementation could look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`UI`实现可能看起来像这样：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `FrontController` class can invoke any authorization logic in order to
    decide whether the current user can see a `UI` component or not before routing
    the request to a `UI` component. For example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrontController`类可以在将请求路由到UI组件之前，调用任何授权逻辑，以决定当前用户是否可以看到`UI`组件。例如：'
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `AuthService.userCanAccess` method can be implemented in various ways:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthService.userCanAccess`方法可以以各种方式实现：'
- en: A set of `if`/`else` statements checking each path/role combination
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组检查每个路径/角色组合的`if`/`else`语句
- en: A check on a Java `Map` where each key is a path and each value is a `Set` of
    the allowed roles for that path
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一个Java `Map`进行检查，其中每个键是一个路径，每个值是该路径允许的角色`Set`。
- en: A check with an external resource (such as an SQL database, web service, or
    `properties` file)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用外部资源（如SQL数据库、Web服务或`properties`文件）进行检查
- en: An algorithm combining the previous alternatives
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合先前替代方案的算法
- en: Implementing each of these solutions would take too much space in the book,
    and it's also more related to Java than Vaadin itself, so I'll let you decide
    how to implement this method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些解决方案中的每一个都会占用本书太多的空间，而且它们更多地与Java相关，而不是Vaadin本身，所以我会让你决定如何实现这个方法。
- en: Coding authorization with the help of a Navigator
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Navigator的帮助下进行授权编码
- en: 'You might have heard about the `Navigator` class in Vaadin Framework. In short,
    the `Navigator` class allows you to pair URI fragments with UI components. When
    the fragment part changes in the browser, the associated UI component is rendered.
    It also allows you to programmatically *navigate* to a specific UI component by
    specifying its associated fragment. For example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过Vaadin Framework中的`Navigator`类。简而言之，`Navigator`类允许你将URI片段与UI组件配对。当浏览器中的片段部分发生变化时，相关的UI组件将被渲染。它还允许你通过指定其关联的片段来程序性地*导航*到特定的UI组件。例如：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you create a `Navigator`, you specify the `UI` to which the `Navigator`
    is attached and a `ComponentContainer` (such as `VerticalLayout`, for example),
    whose content will be replaced when the view is made visible (when changing the
    fragment in the browser, for example). You associate *view names* to UI components
    by using the `addView` method. In the previous example, we passed instances of
    the UI components (using the `new` keyword). The `Navigator` class will use these
    instances throughout the session, so the state of each view is maintained even
    after navigating away from a view. You can let the `Navigator` class create a
    new instance of the UI component each time the view is requested by using the
    overloaded `addView(String, Class<? extends View>)` method. Here''s an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`Navigator`时，你指定`Navigator`附加到的`UI`以及一个`ComponentContainer`（例如`VerticalLayout`），其内容将在视图可见时（例如在浏览器中更改片段时）被替换。你通过使用`addView`方法将*视图名称*与UI组件关联。在先前的例子中，我们传递了UI组件的实例（使用`new`关键字）。`Navigator`类将在整个会话中使用这些实例，因此即使导航离开一个视图，每个视图的状态也会得到保持。你可以通过使用重载的`addView(String,
    Class<? extends View>)`方法让`Navigator`类在每次请求视图时创建UI组件的新实例。以下是一个示例：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The UI components you can add to a `Navigator` must implement the `View` interface,
    as shown in the following class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加到`Navigator`中的UI组件必须实现`View`接口，如下面的类所示：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since Vaadin Framework 8.0, the `View` interface includes a Java 8 *default*
    `enter` method so you don''t have to implement it. Vaadin Framework 8.1 includes
    some additional default methods you can implement if needed. Take a look at the
    reference API of the `View` interface for more information: `https://vaadin.com/api/8.3.2/com/vaadin/navigator/View.html`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Vaadin Framework 8.0以来，`View`接口包含了一个Java 8 *默认*的`enter`方法，因此你不必实现它。Vaadin
    Framework 8.1包含了一些额外的默认方法，如果你需要的话可以实施。查看`View`接口的参考API以获取更多信息：`https://vaadin.com/api/8.3.2/com/vaadin/navigator/View.html`。
- en: 'But let''s get back to the discussion of authorization strategies. The `Navigator`
    class allows you to add a `ViewChangeListener`. We can use this listener to introduce
    authorization rules and *secure* UI components. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们回到授权策略的讨论。`Navigator`类允许你添加一个`ViewChangeListener`。我们可以使用这个监听器来引入授权规则和*安全*的UI组件。例如：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `beforeViewChange` method must return `true` to allow the view change and
    `false` to block it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeViewChange`方法必须返回`true`以允许视图更改，返回`false`以阻止它。'
- en: Vaadin Framework 8.0 added support for the *HTML 5 History API*. With it, you
    can avoid having *hashbangs* in the URL (that little `!#` sequence). Vaadin Framework
    8.2 added support for the HTML 5 History API with the `Navigator` class. You can
    activate this support by annotating the `UI` implementation with `@PushStateNavigation`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Vaadin框架8.0增加了对*HTML 5历史API*的支持。有了它，你可以避免在URL中包含*hashbangs*（那个小的`!#`序列）。Vaadin框架8.2通过`Navigator`类增加了对HTML
    5历史API的支持。你可以通过在`UI`实现上使用`@PushStateNavigation`注解来激活这项支持。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to keep track of authenticated users by using
    the HTTP session. We also learned how to implement the *remember me* feature by
    using cookies in a secure way. Finally, we discussed authorization strategies,
    including coding authorization logic directly in UI components and coding it by
    using request data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过使用HTTP会话来跟踪认证用户。我们还学习了如何通过安全地使用cookie来实现“记住我”功能。最后，我们讨论了授权策略，包括直接在UI组件中编码授权逻辑以及通过请求数据进行编码。
- en: In the next chapter, you will learn about how to connect to SQL databases using
    multiple Java persistence frameworks with Vaadin.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用多个Java持久化框架通过Vaadin连接到SQL数据库。
