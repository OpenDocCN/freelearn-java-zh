- en: Implementing Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the process that ensures the identity of a user, usually done
    by providing a set of identifying credentials (username and password). Authorization
    is the security process that determines the access levels a user has in the application.
    In this chapter, we will continue with the development of the login form implemented
    in [Chapter 3](f992404d-986b-42b9-893e-3667c122030f.xhtml), *Implementing Server-Side
    Components with Internationalization*, by adding authentication and authorization
    features. We'll also learn how to implement the *remember me* option in the login
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization and authentication mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/RM8KNY](https://goo.gl/RM8KNY)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing public and private views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Frequently, web applications have two main screens. One for visitors who are
    not authenticated, and one for users who are authenticated. It makes sense to
    implement the UI in a way that reflects this exactly. The idea is to create two
    custom components (using the `Composite` class); one for public access, and one
    for authenticated users. So, for now, let''s suppose we have a custom `PublicComponent`
    class that shows the login form and a `PrivateComponent` that shows something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cee696c-3b6c-46f3-8d88-383c48c6e40f.png)'
  prefs: []
  type: TYPE_IMG
- en: When the user is successfully authenticated, the `PrivateComponent` is shown.
    When the Logout button is clicked, the user should be redirected to the `PublicComponent`.
    The Vaadin `UI` implementation (`VaadinUI` in this chapter's example) should reflect
    the fact that there are two main screens that can be shown depending on whether
    the user is authenticated or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` method of the `UI` implementation should verify whether a user is
    authenticated already, and if so, show the `PrivateComponent`. Otherwise, it should
    show the `PublicComponent`. This is necessary to cover the case when the user
    reloads the page in the browser: we don''t want the user to have to re-authenticate
    after a page reload. In plain Java, this functionality looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll develop the `AuthService` class in a bit, but the point in this section
    is to show you how simple the `UI` implementation can be. Always try to keep your
    `UI` implementation simple! Delegate to other classes the actual functionality
    of your application. Reflect only the essence of the top-level workflow of the
    application in your `UI` implementation. In our case, a simple class that shows
    one of two main screens, plus a sensible default depending on the authentication
    state, is enough.
  prefs: []
  type: TYPE_NORMAL
- en: One of the security features of Vaadin Framework is the fact that, by default,
    there's no way to access the execution of code by requesting different URLs. In
    the previous example, requesting `http://localhost:8080` will always invoke the
    `init` method, which gives us the chance to check whether the user is authenticated
    or not by asking a service class. You might be wondering how the authentication
    state is kept on the server. The answer is the HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about security in Vaadin Framework applications at [https://vaadin.com/security](https://vaadin.com/security).
  prefs: []
  type: TYPE_NORMAL
- en: Using the HTTP session and cookies to identify users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way of keeping track of the state of a web application is by making use
    of the HTTP session. The currently authenticated user is part of the state of
    the application and can be stored in the HTTP session. In Vaadin applications,
    you can store values in the HTTP session by using the `VaadinSession.setAttribute(String,
    Object)` method. The first parameter is a custom identifier for the value which
    is specified using the second parameter. For example, we can store the number
    `777` in an attribute with the name `number` in the HTTP session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove the value from the session by passing `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keeping track of authenticated users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following this approach, we can store the `username` in the HTTP session when
    a user is successfully authenticated. We can also check whether the user has been
    authenticated by checking whether a value exists in the HTTP session. This can
    be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to notice here. First, for simplicity in this example,
    the code checks whether `username` and `password` are both equal to the string
    `"admin"`. In a real application, this should query a database or delegate to
    any other authentication process. For example, if you have a class that provides
    functionality to query user data, the Boolean check could look something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Never store passwords in a way that they can be retrieved. In other words,
    always store *salted hashes* of passwords instead of the password itself. This
    can protect not only your users but also yourself! If you store a password as
    a hash of it, you can be sure that nobody, including you, can get to know the
    real password. If the database is compromised, at least the passwords are going
    to be garbage. Suppose you have a `hash` method that uses SHA or any other secure
    algorithm. When setting a password, you can save an entity with something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user.setPassword(hash(theActualPassword));`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to check whether a password is correct (for example, during authentication),
    you can compare the hash of the given password with the value stored in the database.
    Something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String stored = user.getPassword();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String hash = hash(attemptedPassword);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (stored.equals(hash) {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the `AuthService` class has Vaadin stuff in it. Service classes should
    be decoupled from the presentation technology, but in our case, that's okay, since
    there's not much chance of us changing the web framework! And that's usually the
    case in real-life applications anyway. Additionally, reusing this class out of
    the context of a Vaadin application doesn't seem very likely, but if it becomes
    necessary, you can decouple it from Vaadin by directly using the HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: If your application allows third-party developers to add new functionality to
    your application and it exposes the HTTP session, developers might be able to
    impersonate a user if they know their username. Since the only condition for declaring
    a user as authenticated is to have an entry in the HTTP session with the corresponding
    username as its key, a malicious developer could add such a username and invoke
    other functionality on their behalf. In such cases, consider symmetrically encrypting
    the key (username) or even using an alternative storage mechanism for the HTTP
    session.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login/logout process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recap what we have implemented at this point. We have a multi-language
    `LoginFormComponent` ready for use (developed in [Chapter 3](f992404d-986b-42b9-893e-3667c122030f.xhtml)*,
    Implementing Server-Side Components with Internationalization*), a `UI` implementation
    that shows a `PublicComponent` or a `PrivateComponent`, depending on whether a
    user is authenticated, and an `AuthService` class that allows us to authenticate
    a user (if their login credentials are correct) and check whether there is an
    authenticated user in the session or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to complete the login/logout process by implementing the `PublicComponent`
    and `PrivateComponent` classes. Let''s start with the `PublicComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This component extends `Composite` and uses the `LoginFormComponent` as its
    composition root. The `loginClicked` method is called when the user clicks the
    respective button, and it''s inside this method where we try to authenticate the
    user. If the credentials are correct, we show an error notification, but if they
    are correct, we are not doing anything at all! And actually, we don''t really
    need to do anything else in this class. Do you remember how we implemented the
    `VaadinUI` class so that it would show one screen or the other according to the
    authentication state? Well, all we need to do in order to make this work is add
    a simple page reload to the `AuthService.authenticate` method for when the authentication
    succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's right! Since the `VaadinUI.init` method is called when the user refreshes
    the browser and our implementation checks whether there's an authenticated user
    in the HTTP session (via the `AuthService` class), we don't need to do anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the other way around? When the user logs out, we should perform two
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove all the data in the HTTP session (invalidate the session).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the browser (in order to invoke the `VaadinUI.init` method and automatically
    show the `PublicComponent`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s just reasonable to implement this functionality in the `AuthService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `invalidate` method removes any values from the HTTP session and invalidates
    it. The server will create a new session if the application is requested again.
  prefs: []
  type: TYPE_NORMAL
- en: Servers maintain sessions in several ways, such as through cookies or URL rewriting.
    Depending on your specific server, you might have to call `VaadinService.reinitializeSession(VaadinService.getCurrentRequest())`
    to ensure a new session key is generated after you invalidate a session.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we reloaded the browser this time. Instead of calling the `Page.reload()`
    method, we are making sure that the URL in the browser requests the starting URL
    for the web application. This will also remove, for example, any fragments or
    parameters from the URL that may contain *sensitive information*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sensitive information* refers to any kind of data, information, or knowledge
    that must be protected against unauthorized access.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `PrivateComponent` class should be pretty straightforward to implement.
    For the sake of completeness, here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `AuthService.getAuthenticatedUser()` method. You can implement that
    method with one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember to use HTTPS (HTTP Secure) any time you have a web application with
    a login form that sends user credentials through the network. By enabling HTTPS,
    the data is encrypted, preventing man-in-the-middle attacks. You can learn more
    about how to enable HTTPS at [https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate](https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the remember me feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *remember me* feature allows users to automatically authenticate themselves
    with the web application even after they have closed the browser, or the HTTP
    session has been destroyed, without having to enter their usernames and passwords.
    If a user has previously authenticated themselves and chose to be remembered,
    the web application will, remember the user using HTTP cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, with the *remember me* feature, your application can consume two
    kinds of *login credentials*:'
  prefs: []
  type: TYPE_NORMAL
- en: A username and password combination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A valid HTTP cookie previously created by the web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's think of the login/logout process, putting the *remember me* functionality
    into play this time. When a user requests the web application for the first time,
    the `VaadinUI.init` method is invoked. This method will check whether the user
    is authenticated or not in order to show the corresponding `UI` component. This
    is delegated to the `AuthService` class in our example. The `AuthService.isAuthenticated`
    method checks whether or not there's an authenticated user in the HTTP session.
    At first, there is none, so it should check whether the user was *remembered*
    before. Ignoring the details, we know the user was not remembered before. So the
    `PublicComponent` is shown and the user can log in with, username and password.
    But this time, the user checks the Remember me checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: We need to tell this choice to the `AuthService.authenticate` method (by passing
    a Boolean value from the checkbox), which in turn will check if the username and
    password are correct and, if so, perform the logic to *remember* the user. This
    is the interesting part.
  prefs: []
  type: TYPE_NORMAL
- en: A user is remembered by creating an HTTP cookie with the name, say `remember-me`,
    and storing a value that allows us to identify the user later. We could be tempted
    to simply store the plain username in this cookie, but that would lead to a serious
    security issue; if a malicious user has access to the browser and gets the value
    of a `remember-me` cookie, they will be able to sign in as that user by simply
    creating a cookie with the stolen value.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of storing *sensitive information* in the cookie, we can store a randomly
    generated string and store the username in the server using a Java `Map`, where
    the key is the random string and the value is the username.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Java `Map` is good enough for the example in this chapter. However,
    keep in mind that if you restart the server, remembered users are no longer remembered
    (pun intended). A real-life application should use a persistent `Map`, such as
    an SQL table, but the principle is exactly the same. Additionally, you might want
    to store a hash of the random key, in the same way as you should do with user
    passwords. This will protect users if data in this table is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's recap. The user logged in by providing their username and password
    and checking the Remember me option, and the web application created a cookie
    containing a random key and stored the username in a `Map` using that key. Now,
    let's see what happens when the user closes the browser (or waits until the HTTP
    session is closed) and requests the web application again.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the `VaadinUI.init` method is invoked and the `AuthService.isAuthenticated`
    method checks whether there's an authenticated user in the HTTP session. Of course,
    there isn't, and it proceeds with the cookie check. This time, there is a `remember-me`
    cookie, so the method just searches for the username in the `Map` of remembered
    users and gets the value of the username. Now, it should just store the username
    in the HTTP session and return `true`. The user was automatically authenticated!
  prefs: []
  type: TYPE_NORMAL
- en: The last part we need to consider is the logout action. When the user logs out,
    the `remember-me` cookie should be destroyed, along with the corresponding entry
    in the Java `Map` of remembered users.
  prefs: []
  type: TYPE_NORMAL
- en: 'I would urge you to try and implement all this by yourself. I have created
    a branch with the name `remember-me-exercise` in the source code that accompanies
    this book. You can use this branch as a starting point if you want to do the exercise.
    You can check it out by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer to see the solution, just check the code in the `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some snippets of code you could use for the exercise. Let''s begin
    with HTTP cookies management. You can send a new cookie to the browser by using
    the `VaadinRequest.addCookie` method. The following snippet of code creates a
    new cookie with the name `remember-me` and the value `admin` and sends it to the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `setPath` defines the path for the cookie. The browser sends the cookies
    associated with that path in subsequent requests to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the path should include the servlet's context path. You can get it
    by calling `VaadinServlet.getCurrent().getServletContext().getContextPath()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `setMaxAge` method allows you to set the time for which the cookie will
    be valid. The time is given in seconds, which means that the previous snippet
    creates a cookie valid for 15 days.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete a cookie, set its age to zero. For example, the following code removes
    the `remember-me` cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get all the cookies reported by the browser by using the `VaadinRequest.getCookies`
    method. You can get an instance of `VaadinRequest` via `VaadinService.getCurrent()`.
    The following snippet of code retrieves an `Optional` of a cookie with the name
    `remember-me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here there''s a tip to generate a random string suitable for the `Map`
    of remembered users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In short, this converts a randomly generated `BigInteger` consisting of `130`
    bits and converts them into a sequence of base-32 characters. Although 128 bits
    is secure enough, a base-32 character can take five bits. *128/5 = 25.6*, so we
    need a couple of extra bits to get the next multiple of 5, which leads to *130/5=26*.
    In conclusion, we get 26 random characters. Keep in mind that UUIDs are not designed
    to be unpredictable and should not be used to identify sessions.
  prefs: []
  type: TYPE_NORMAL
- en: A good implementation should also periodically clean the `Map` of remembered
    users. This can be achieved by adding a custom data type that stores not only
    the username but the expiry date. A background process can run every day, checking
    for expired entries and removing them from the `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling features according to a user's roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses authorization implementation strategies. Authorization
    is the process of granting access to resources according to a defined policy.
    Keep in mind that *authentication* is the process of verifying if a user or another
    system is who they claim they are, *authorization* deals with what a certain user
    can do.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization mechanisms can be implemented in many ways depending on the specific
    requirements of an application. Some applications use a basic public/private approach
    (like the one we have used so far in this chapter) where the policy is as simple
    as checking if a user is authenticated in order to grant access to a certain UI
    component. Other applications may require multiple roles, each one with a different
    set of permissions. Moreover, a user may have multiple roles at the same time
    and those roles could change at runtime. And to make it a bit more complicated,
    a role could define a set of permissions that could also change at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of the authentication rules that your application
    must support, you would use one or another approach to authorization. Let's discuss
    some of them, which, hopefully, will inspire you and give you ideas about how
    to implement an authorization mechanism suitable for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Coding authorization logic in UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first approach we will discuss is including the authorization logic in
    the UI components themselves. This is what we have done in the example application,
    where we show a `PrivateComponent` if the user is authenticated or a `PublicComponent`
    if they are not. You can extrapolate this and use it with, for example, roles.
    Suppose there were two roles: *employee* and *admin*. You have to show a hypothetical
    `AdminComponent` to users with the role admin and an `EmployeeComponent` to users
    with the *employee* role. You can easily code a method that returns the right
    component according to the role as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If a new `Role` appears in future, you can simply add another `if` clause to
    cover the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if there''s no need for a completely new UI component for a role? For
    example, let''s say the `EmployeeComponent` must show a *delete* button only for
    users with the *employee* role, and sonot for users with the *trainee* role. The
    easier solution is to code this logic inside the `EmployeeComponent` class itself,
    using something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A good thing about this approach is that you can follow the code to understand
    what's visible and what's not. However, you might end up with authorization code
    all over the source code. Well, at least over the UI-related classes. This is,
    however, a valid approach and you should at least consider it.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of this way of implementing authorization is that it couples
    UI code with authorization code. This makes it a bit more difficult for software
    reuse. The preceding class, for example, cannot be used in a different application
    without carrying the `AuthService` class. Fortunately, we can easily decouple
    this class from the authentication stuff. The key is the *principle of least privilege*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle of least privilege states that a software entity should have
    access to the least or minimum amount of data it requires to perform its function.
    Can you see how the `EmployeeComponent` class violates this principle? All the
    class needs to know is whether to show the `delete` button or not. It doesn''t
    really care about roles and authentication logic. We are passing way too much
    information to it. What''s the minimal amount of information this class needs
    to fulfill its requirements? A simple Boolean telling it whether to show the `delete`
    button or not. That''s it. A possible implementation can include a parameter in
    the constructor for this purpose. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We just removed the coupling between this class and the authentication logic.
    However, we moved the authentication logic somewhere else. Now the client of the
    `EmployeeComponent` class must configure it depending on the authorization rules.
    It''s not such a bad thing considering that such a client is already coupled to
    the `AuthService` class, right? Take a look at the new implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Optional` class serves as a container for a value that may or may not be
    `null` (we are not talking about a Vaadin `Container` here; the `Container` interface
    was removed in Vaadin Framework 8.0). `Optional` helps to decrease the number
    of null checks in your code. Instead of returning a null value from a method,
    you can return an `Optional`, which is empty when the enclosing value is null.
    This way, the client of the method knows that the returned value might be null.
    Bear in mind that the original purpose of the `Optional` class is to serve as
    an *optional return value*. Avoid using `Optional` in method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway of this discussion is to keep in mind that you can provide
    configuration options for your UI components. Don't just unnecessarily couple
    them with authentication classes. Provide parameters in the constructors, setters,
    or even configuration classes if the complexity requires it in order to tell the
    UI component how it should look and behave.
  prefs: []
  type: TYPE_NORMAL
- en: Coding authorization using request data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s study a strategy to implement authorization outside UI components. Web
    frameworks can be classified as:'
  prefs: []
  type: TYPE_NORMAL
- en: Component-based frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request/response-based frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vaadin Framework is a component-based framework. It abstracts away the concept
    of request and response. You don't have to think much about it when developing
    a Vaadin application, and that's one of the key features of the framework. Thanks
    to its ability to allow developers to implement a web application by directly
    using the Java programming language, developers can use any object-oriented technique
    to implement features such as authorization. In fact, in the previous section,
    we explored how to do so using simple Java `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Request/response based frameworks, on the other hand, usually make it a bit
    harder to use the approach we discussed in the previous section (coding the authorization
    logic directly in the UI component), in part because the UI layer runs in the
    client side. Coding authentication rules in the client side is a no-go. How do
    request/response based frameworks implement authorization? Typically, these frameworks
    include a *front controller*, a software entity that processes all the requests
    and decides which portion of your code should be invoked. It's then easy to add
    a *filter* to secure the requested resources according to a set of rules. In short,
    authorization is implemented with a combination of server-side code (which decides
    what to show in the browser) and a filter securing URLs according to authorization
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Can we use something similar with Vaadin? Let's explore the capabilities of
    Vaadin regarding *request information* to see how we can take advantage of it
    in order to design an authentication mechanism that is completely decoupled from
    the actual UI components.
  prefs: []
  type: TYPE_NORMAL
- en: Getting request information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about a *request* made to a web application, we are talking about
    an HTTP request that a client, typically, a browser, makes to the web server.
    The server takes the *context path* and routes the request to the appropriate
    web application (for example, a Vaadin application). An important part of the
    HTTP request is the URL used to access the application and its resources. The
    following screenshot shows the most important parts of a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a9e9017-03a0-410a-ba27-eba4252c93a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With Vaadin Framework you can get access to all these parts. For example, in
    order to get the *path info* part of the URL, you can call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a *parameter* value, you can call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Routing requests to a UI component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the *path info* part and *parameters*, you can already implement a mechanism
    that *routes* a request to a specific component, similarly to what a front controller
    does in a request/response-based framework. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And the corresponding `UI` implementation could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FrontController` class can invoke any authorization logic in order to
    decide whether the current user can see a `UI` component or not before routing
    the request to a `UI` component. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AuthService.userCanAccess` method can be implemented in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of `if`/`else` statements checking each path/role combination
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A check on a Java `Map` where each key is a path and each value is a `Set` of
    the allowed roles for that path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A check with an external resource (such as an SQL database, web service, or
    `properties` file)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An algorithm combining the previous alternatives
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing each of these solutions would take too much space in the book,
    and it's also more related to Java than Vaadin itself, so I'll let you decide
    how to implement this method.
  prefs: []
  type: TYPE_NORMAL
- en: Coding authorization with the help of a Navigator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have heard about the `Navigator` class in Vaadin Framework. In short,
    the `Navigator` class allows you to pair URI fragments with UI components. When
    the fragment part changes in the browser, the associated UI component is rendered.
    It also allows you to programmatically *navigate* to a specific UI component by
    specifying its associated fragment. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a `Navigator`, you specify the `UI` to which the `Navigator`
    is attached and a `ComponentContainer` (such as `VerticalLayout`, for example),
    whose content will be replaced when the view is made visible (when changing the
    fragment in the browser, for example). You associate *view names* to UI components
    by using the `addView` method. In the previous example, we passed instances of
    the UI components (using the `new` keyword). The `Navigator` class will use these
    instances throughout the session, so the state of each view is maintained even
    after navigating away from a view. You can let the `Navigator` class create a
    new instance of the UI component each time the view is requested by using the
    overloaded `addView(String, Class<? extends View>)` method. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI components you can add to a `Navigator` must implement the `View` interface,
    as shown in the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Vaadin Framework 8.0, the `View` interface includes a Java 8 *default*
    `enter` method so you don''t have to implement it. Vaadin Framework 8.1 includes
    some additional default methods you can implement if needed. Take a look at the
    reference API of the `View` interface for more information: `https://vaadin.com/api/8.3.2/com/vaadin/navigator/View.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s get back to the discussion of authorization strategies. The `Navigator`
    class allows you to add a `ViewChangeListener`. We can use this listener to introduce
    authorization rules and *secure* UI components. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeViewChange` method must return `true` to allow the view change and
    `false` to block it.
  prefs: []
  type: TYPE_NORMAL
- en: Vaadin Framework 8.0 added support for the *HTML 5 History API*. With it, you
    can avoid having *hashbangs* in the URL (that little `!#` sequence). Vaadin Framework
    8.2 added support for the HTML 5 History API with the `Navigator` class. You can
    activate this support by annotating the `UI` implementation with `@PushStateNavigation`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to keep track of authenticated users by using
    the HTTP session. We also learned how to implement the *remember me* feature by
    using cookies in a secure way. Finally, we discussed authorization strategies,
    including coding authorization logic directly in UI components and coding it by
    using request data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about how to connect to SQL databases using
    multiple Java persistence frameworks with Vaadin.
  prefs: []
  type: TYPE_NORMAL
