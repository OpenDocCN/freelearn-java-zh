- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Deploying APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署API
- en: Throughout our journey of mastering RESTful APIs with Java, we have explored
    various crucial aspects of development. From writing efficient code to implementing
    robust design principles and following industry best practices, we have built
    a solid foundation for creating high-quality APIs. However, the path to delivering
    production-ready software extends beyond development alone.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握Java RESTful API的旅程中，我们已经探索了开发的各种关键方面。从编写高效的代码到实施稳健的设计原则和遵循行业最佳实践，我们为创建高质量的API奠定了坚实的基础。然而，交付生产就绪软件的道路并不仅限于开发本身。
- en: While our accumulated knowledge of API development is invaluable, it represents
    only part of the complete software delivery life cycle. The critical bridge between
    development and production deployment remains to be crossed. This final stage—the
    deployment process—transforms our well-crafted API into a production-ready service
    that delivers real value to end users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们对API开发的积累知识非常有价值，但它仅代表完整软件交付生命周期的一部分。开发与生产部署之间的关键桥梁仍需跨越。这一最终阶段——部署过程——将我们精心打造的API转化为一个生产就绪的服务，为最终用户提供真实的价值。
- en: 'For that, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将涵盖以下主题：
- en: Preparing APIs for deployment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备API进行部署
- en: Containerization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化
- en: '**Platform as a Service** ( **PaaS** )'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台即服务**（**PaaS**）'
- en: Deployment best practices and patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署最佳实践和模式
- en: Practical examples throughout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际示例贯穿始终
- en: Preparing APIs for deployment
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备API进行部署
- en: Before deploying your RESTful API to production, you need to complete several
    important preparation steps. This preparation ensures your API will run properly,
    securely, and reliably in a production environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在将您的RESTful API部署到生产环境之前，您需要完成几个重要的准备步骤。这些准备确保您的API将在生产环境中正常运行、安全可靠。
- en: In this section, we will cover some of the key elements required to make your
    Java API ready for deployment. First, we will examine configuration management—how
    to structure your application settings to work across different environments without
    changing code. Then, we will discuss implementing health checks that monitor your
    API’s status and help maintain system reliability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍使您的Java API为部署做好准备的一些关键要素。首先，我们将检查配置管理——如何构建您的应用程序设置以在不同环境中工作而无需更改代码。然后，我们将讨论实施健康检查，以监控API的状态并帮助维护系统可靠性。
- en: These preparation steps form the foundation of a successful deployment process.
    They help prevent common problems and create a stable base for your API in production.
    By following these practices, you’ll reduce deployment issues and make your API
    easier to maintain as it grows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些准备步骤构成了成功部署流程的基础。它们有助于防止常见问题，并为您的API在生产环境中提供一个稳定的平台。通过遵循这些实践，您将减少部署问题，并使您的API在扩展时更容易维护。
- en: Let’s now explore these preparation elements in detail, beginning with effective
    configuration management.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细探讨这些准备元素，从有效的配置管理开始。
- en: Configuration management
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理
- en: In modern RESTful API development, proper configuration management is essential
    for maintaining flexible, secure, and maintainable applications. In this section,
    we will explore the aspects of configuration management and its benefits.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代RESTful API开发中，适当的配置管理对于维护灵活、安全和可维护的应用至关重要。在本节中，我们将探讨配置管理的各个方面及其益处。
- en: Externalized configurations
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部化配置
- en: Externalized configurations separate your application’s core functionality from
    its configuration setting, avoiding the necessity of placing hardcoded configurations
    inside of the code. This approach allows you to modify application settings without
    needing to change the code. By keeping configuration data outside of the code
    base, you can easily adjust environment-specific settings—such as database URLs,
    security keys, or API endpoints—without recompiling or redeploying your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 外部化配置将应用程序的核心功能与其配置设置分离，避免了在代码中放置硬编码配置的必要性。这种方法允许您在不更改代码的情况下修改应用程序设置。通过将配置数据保留在代码库之外，您可以轻松调整特定于环境的设置，例如数据库URL、安全密钥或API端点，而无需重新编译或重新部署您的应用程序。
- en: 'For example, using Spring Boot, you can externalize configuration by defining
    properties in an external `Properties` or YAML file rather than hardcoding them
    in your Java code. To externalize configuration in a Spring Boot application and
    bind it to a Java class, follow these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用Spring Boot，您可以通过在外部`Properties`或YAML文件中定义属性来外部化配置，而不是在Java代码中硬编码它们。要在Spring
    Boot应用程序中外部化配置并将其绑定到Java类，请按照以下步骤操作：
- en: 'Create an external configuration file ( `application.yml` ):'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个外部配置文件（`application.yml`）：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use application configurations from `application.yml` :'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`application.yml`中的应用程序配置：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the API timeout setting is externalized in the `application.yml`
    file. The `ApiProperties` class binds to the `"api"` section, ensuring that any
    changes to the configuration file—such as adjusting the timeout—will take effect
    without modifying the application code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，API超时设置在`application.yml`文件中进行了外部化。`ApiProperties`类绑定到`"api"`部分，确保对配置文件的任何更改（如调整超时）都将生效，而无需修改应用程序代码。
- en: This approach promotes flexibility and agility during deployment, enabling rapid
    adjustments to configuration values based on the deployment environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在部署期间促进了灵活性和敏捷性，使得可以根据部署环境快速调整配置值。
- en: Benefits of externalized configurations
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外部化配置的好处
- en: 'Separating configuration from your application code represents a foundational
    best practice in modern software architecture, particularly for RESTful APIs that
    must operate across diverse environments. By externalizing configuration, development
    teams gain tremendous flexibility in how applications are deployed, secured, and
    maintained throughout their life cycle. This approach fundamentally transforms
    how we manage application settings, moving from hardcoded values embedded in source
    code to dynamic, environment-specific variables that can be modified without recompilation.
    The strategic advantages of this approach extend across multiple dimensions of
    your development and operational processes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置与您的应用程序代码分离是现代软件架构中的基础最佳实践，尤其是对于必须在各种环境中运行的RESTful API。通过外部化配置，开发团队在应用程序的部署、安全性和维护整个生命周期中获得了巨大的灵活性。这种方法从根本上改变了我们管理应用程序设置的方式，从源代码中嵌入的硬编码值转变为动态的、特定于环境的变量，这些变量可以在不重新编译的情况下进行修改。这种方法的战略优势贯穿于您的开发和运营流程的多个维度：
- en: '**Environment independence** : Developers benefit from seamless transitions
    between different environments without changing code. For example, your Order
    API can connect to a test product catalog during development that contains sample
    products, but automatically switch to the production catalog with real inventory
    when deployed to production. This allows developers to create and test orders
    with test data locally without affecting real inventory or sending notifications
    to actual customers.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境独立性**：开发者可以在不更改代码的情况下无缝地在不同环境之间进行切换。例如，您的订单API可以在开发期间连接到包含样本产品的测试产品目录，但在部署到生产环境时自动切换到包含真实库存的生产目录。这允许开发者使用测试数据本地创建和测试订单，而不会影响真实库存或向实际客户发送通知。'
- en: '**Simplified maintenance** : Operations teams gain the ability to modify application
    behavior without requiring developer intervention. For instance, when your Product
    API needs to increase the product image cache size from 100 MB to 500 MB due to
    new high-resolution images, operations staff can simply update the externalized
    configuration value rather than requesting code changes and redeployment. Similarly,
    the timeout settings for third-party shipping provider integrations in your Order
    API can be adjusted based on their performance characteristics without development
    team involvement.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化维护**：运维团队获得在不需开发者干预的情况下修改应用程序行为的能力。例如，当您的产品API因新的高分辨率图片需要将产品图片缓存大小从100
    MB增加到500 MB时，运维人员可以简单地更新外部化配置值，而不是请求代码更改和重新部署。同样，您的订单API中第三方物流提供商集成的超时设置可以根据其性能特征进行调整，而不需要开发团队的参与。'
- en: '**Enhanced security** : Security is significantly strengthened by removing
    sensitive credentials from source code. For example, instead of hardcoding the
    payment gateway API key like `paymentGateway.setApiKey("sk_live_51MlkA...")` in
    your Order API code (where it would remain visible in commit history), you can
    use `paymentGateway.setApiKey(environment.getProperty("payment.api.key"))` and
    securely store the actual keys in environment variables. This allows different
    keys to be used for development versus production without exposing sensitive credentials.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：通过从源代码中移除敏感凭证，安全性得到了显著增强。例如，你可以在你的订单API代码中（它会在提交历史中保持可见）避免像这样硬编码支付网关API密钥
    `paymentGateway.setApiKey("sk_live_51MlkA...")`，而是使用 `paymentGateway.setApiKey(environment.getProperty("payment.api.key"))`
    并在环境变量中安全地存储实际密钥。这允许开发环境和生产环境使用不同的密钥，而不会暴露敏感凭证。'
- en: '**Easier DevOps integration** : Continuous integration and deployment pipelines
    become more powerful with externalized configuration. For example, you can deploy
    the same Order API Docker container to testing and production environments using
    different settings:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的DevOps集成**：外部化配置使持续集成和部署管道更加强大。例如，你可以使用不同的设置将相同的订单API Docker容器部署到测试和生产环境：'
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the testing environment, you might set `INVENTORY_CHECK_ENABLED=false` to
    skip actual inventory verification, while enabling it in production to prevent
    orders for out-of-stock products.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中，你可能将 `INVENTORY_CHECK_ENABLED=false` 设置为跳过实际的库存验证，而在生产环境中启用它以防止缺货产品的订单。
- en: As we have seen, externalizing configuration provides critical advantages for
    building robust, maintainable, and secure RESTful APIs. By decoupling configuration
    from code, we gain the flexibility to deploy across environments, simplify operational
    updates, enhance security, and streamline DevOps processes. Let us now take a
    look at how to handle profile-based configurations that will allow developers
    to have the flexibility to work and deploy automatically, selecting a specific
    set of configurations for each environment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，外部化配置为构建健壮、可维护和安全的RESTful API提供了关键优势。通过将配置与代码解耦，我们获得了在各个环境中部署、简化操作更新、增强安全性和简化DevOps流程的灵活性。现在让我们看看如何处理基于配置文件的配置，这将允许开发者具有灵活性和自动选择每个环境特定配置集的能力。
- en: Profile-based configurations
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于配置文件
- en: When deploying your RESTful APIs across different environments—from a developer’s
    local machine to test servers and ultimately to production—managing environment-specific
    settings becomes a critical challenge. Profile-based configuration provides an
    elegant solution that directly addresses deployment complexities by allowing your
    API to adapt its behavior based on where it’s running, all without changing a
    single line of code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在不同的环境中部署RESTful API——从开发者的本地机器到测试服务器，最终到生产环境——管理特定环境的设置成为一个关键挑战。基于配置文件的配置提供了一个优雅的解决方案，它通过允许API根据其运行位置调整其行为，直接解决了部署复杂性，而无需更改任何代码行。
- en: For your Order API and Product API, this approach means you can maintain a single
    code base and deployment artifact while automatically adjusting crucial settings
    such as database connections, external service endpoints, security parameters,
    and feature toggles based on the target environment. This capability streamlines
    your CI/CD pipeline and dramatically reduces configuration-related deployment
    failures.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的订单API和产品API，这种方法意味着你可以在保持单一代码库和部署工件的同时，根据目标环境自动调整关键设置，如数据库连接、外部服务端点、安全参数和功能开关。这种能力简化了你的CI/CD管道，并大大减少了与配置相关的部署故障。
- en: Common profiles
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见配置文件
- en: 'Imagine your Order API needs different database connections and behavior settings
    across environments. You can structure your configuration files as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的订单API需要在不同的环境中使用不同的数据库连接和行为设置。你可以按照以下方式结构化你的配置文件：
- en: '**Development** : In the development environment—often referred to by the “dev”
    profile—developers focus on writing and testing code either locally or in shared
    development servers. This stage of the software life cycle typically sees very
    frequent code changes, constant experimentation, and rapid deployments. Because
    reliability is not yet critical, developers often use lightweight databases such
    as H2 or other embedded options and may rely on simulated services to stand in
    for external dependencies. Verbose logging is enabled so that any issues can be
    quickly diagnosed, and debugging features are turned up to gain deeper insight
    into the code. Because no actual customer data is involved and real transactions
    are not processed, there is minimal risk to the business at this stage. A practical
    example in the Order API might involve running an in-memory database for orders
    to facilitate speedy local testing, calling a locally running instance of the
    Product API, and simulating payment and shipping services to move faster without
    waiting on real integrations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：在开发环境（通常称为“开发”配置文件）中，开发者专注于在本地或共享开发服务器上编写和测试代码。这个软件生命周期阶段通常看到非常频繁的代码更改、持续的实验和快速部署。由于可靠性尚未成为关键，开发者通常使用轻量级数据库，如H2或其他嵌入式选项，并可能依赖模拟服务来替代外部依赖。启用了详尽的日志记录，以便可以快速诊断任何问题，并提高调试功能以获得对代码的更深入了解。由于没有涉及实际客户数据且不处理真实交易，这个阶段对业务的风险最小。一个实际的订单API示例可能包括运行内存数据库以加快本地测试，调用本地运行的产品API实例，并模拟支付和物流服务以加快速度，而无需等待真实集成。'
- en: '**Testing** : When it’s time to verify that everything works together seamlessly,
    the testing environment—aligned with the “test” profile—comes into play. This
    environment is generally more stable than development, as changes are introduced
    less often and are usually more refined. It mirrors production more closely by
    leveraging databases and external service configurations that resemble real-world
    conditions while still using test data. Throughout this phase, teams carry out
    integration tests, automated user interface tests, performance validations, and
    other checks to ensure the system behaves as expected. Here, the Order API might
    connect to a dedicated test version of MySQL for managing orders, call a testing
    instance of the Product API, and possibly generate shipping labels via a test
    shipping service endpoint. To prevent real charges, payments are typically handled
    by a simulated gateway. This controlled environment allows QA teams and automated
    pipelines to validate complete workflows without jeopardizing real customer data
    or incurring unnecessary costs.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：当需要验证所有组件无缝协作时，与“测试”配置文件对齐的测试环境就发挥作用了。这个环境通常比开发环境更稳定，因为变更引入的频率较低，且通常更加精细。它通过利用类似真实世界条件的数据库和外部服务配置来更接近生产环境，同时仍然使用测试数据。在整个这个阶段，团队执行集成测试、自动化用户界面测试、性能验证和其他检查，以确保系统按预期运行。在这里，订单API可能连接到一个专用的测试MySQL版本来管理订单，调用产品API的测试实例，并通过测试物流服务端点生成物流标签。为了防止实际收费，支付通常由模拟网关处理。这个受控环境允许质量保证团队和自动化管道验证完整的工作流程，而不会危及真实客户数据或产生不必要的成本。'
- en: '**Production** : Once the application has passed all the necessary checks,
    it graduates to the production environment—commonly known by the “prod” profile.
    In this live environment, your APIs serve genuine end users and handle real-world
    interactions. Uptime, security, and performance become paramount. Code running
    here is thoroughly tested and generally changes less frequently, as stability
    takes priority over rapid iteration. The Order API in production will connect
    to robust, secure, and often clustered databases designed to handle large transactions
    at scale, while simultaneously integrating with authentic external services such
    as real payment providers and shipping carriers. Logs are carefully managed to
    collect essential information without adversely affecting performance. Given the
    high stakes and real customer data, asynchronous order fulfillment is frequently
    employed to ensure reliable processing under heavy loads. This environment demands
    close monitoring and swift response to any issues to maintain a seamless customer
    experience.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境**：一旦应用程序通过了所有必要的检查，它就会升级到生产环境——通常被称为“prod”配置文件。在这个实时环境中，您的API为真实用户提供服务并处理现实世界的交互。上线时间、安全和性能变得至关重要。在这里运行的代码经过彻底测试，并且通常更改频率较低，因为稳定性比快速迭代更重要。生产环境中的订单API将连接到强大、安全且通常集群化的数据库，这些数据库旨在处理大规模交易，同时与真实的第三方服务（如真实支付提供商和运输承运人）集成。日志被精心管理，以收集必要的信息，同时不会对性能产生不利影响。鉴于高风险和真实客户数据，异步订单履行通常被采用，以确保在重负载下可靠的处理。这个环境需要密切监控和对任何问题的快速响应，以保持无缝的客户体验。'
- en: 'We can express this structure in Spring Boot. To take advantage of this approach,
    we need to organize all the variables used in each environment that receives the
    suffix of the file with its environment name, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Spring Boot中表达这种结构。为了利用这种方法，我们需要组织每个环境中使用的所有变量，这些变量以文件的环境名称后缀命名，如下所示：
- en: '![Figure 12.1 – File structure of Spring profile-based configuration](img/B21843_12_1.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 基于Spring配置文件的文件结构](img/B21843_12_1.png)'
- en: Figure 12.1 – File structure of Spring profile-based configuration
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 基于Spring配置文件的文件结构
- en: Activating profiles during deployment
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署期间激活配置文件
- en: 'When deploying your Order API to different environments, you activate the appropriate
    profile through environment variables or command-line arguments:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将订单API部署到不同的环境时，您可以通过环境变量或命令行参数激活适当的配置文件：
- en: '**Local development** :'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地开发** :'
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Automated test environment** :'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试环境** :'
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Production deployment with Docker** :'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Docker进行生产部署** :'
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This approach ensures that when your Order API is deployed to production, it
    automatically connects to the production database, uses the live payment gateway,
    communicates with the production Product API instance, and applies appropriate
    performance and security settings—all without any code changes or manual configuration
    steps.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保当您的订单API部署到生产环境时，它会自动连接到生产数据库，使用实时支付网关，与生产产品API实例通信，并应用适当的性能和安全设置——所有这些都不需要任何代码更改或手动配置步骤。
- en: Profile-based configuration directly addresses the challenges of deploying the
    same API across multiple environments, making your deployment process more reliable,
    maintainable, and adaptable to changing infrastructure requirements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于配置文件的配置直接解决了在多个环境中部署相同API的挑战，使您的部署过程更加可靠、可维护，并能够适应不断变化的基础设施需求。
- en: Environment variables
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: Environment variables provide a secure and flexible way to manage configuration
    values, especially for sensitive data. When deploying your API, you can set sensitive
    configurations such as database credentials, API keys, and service endpoints as
    environment variables on your server. This approach keeps critical information
    out of your code base while making it accessible to your application at runtime.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量提供了一种安全且灵活的方式来管理配置值，特别是对于敏感数据。当您部署API时，您可以将敏感配置，如数据库凭据、API密钥和服务端点，作为服务器上的环境变量设置。这种方法将关键信息从代码库中移除，同时在运行时使应用程序能够访问这些信息。
- en: 'In Spring Boot applications, the most elegant way to leverage environment variables
    is through the `application.yml` file, where you can reference these variables
    directly in your configuration:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot应用程序中，利用环境变量的最优雅方式是通过`application.yml`文件，您可以直接在配置中引用这些变量：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While reviewing our examples, you may have noticed that both the profile-based
    configuration and environment variables sections use an `application.yml` file,
    yet they represent different approaches to configuration management. In the externalized
    configuration example, we focused on creating separate physical configuration
    files for different environments (such as `application-dev.yml` and `application-prod.yml`
    ), which Spring Boot loads based on the active profile. The environment variables
    approach, by contrast, uses placeholder syntax, `${VARIABLE_NAME:default_value}`
    , within a single configuration file to dynamically inject values at runtime.
    This distinction is important: file-based externalization requires managing complete
    configuration files for each environment and deploying the correct file alongside
    your application, while environment variables allow you to maintain a single configuration
    template where only specific values are overridden at runtime through your deployment
    platform. The environment variable approach offers greater flexibility in containerized
    environments such as Docker and cloud platforms, simplifies secret management
    integration, and enables fine-grained configuration updates without replacing
    entire files. Many production systems leverage both patterns together—using profile-specific
    files for substantial configuration differences between environments while employing
    environment variables for sensitive credentials and frequently changed values.
    This hybrid approach gives development teams the ability to handle both structural
    configuration differences and dynamic value injection within a unified framework.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查我们的示例时，您可能已经注意到，基于配置文件和环境变量部分都使用了`application.yml`文件，但它们代表了不同的配置管理方法。在外部化配置示例中，我们专注于为不同的环境（如`application-dev.yml`和`application-prod.yml`）创建单独的物理配置文件，Spring
    Boot根据活动配置文件加载这些文件。相比之下，环境变量方法在单个配置文件中使用占位符语法`${VARIABLE_NAME:default_value}`，在运行时动态注入值。这种区别很重要：基于文件的外部化需要为每个环境管理完整的配置文件，并在部署应用程序时部署正确的文件，而环境变量允许您维护单个配置模板，其中仅在运行时通过您的部署平台覆盖特定值。环境变量方法在容器化环境（如Docker和云平台）中提供了更大的灵活性，简化了秘密管理集成，并允许在不替换整个文件的情况下进行细粒度的配置更新。许多生产系统同时利用这两种模式——使用特定配置文件的文件来处理环境之间的实质性配置差异，同时使用环境变量来处理敏感凭证和经常更改的值。这种混合方法使开发团队能够在统一框架内处理结构配置差异和动态值注入。
- en: Health checks implementation
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健康检查实施
- en: Health checks are vital for monitoring the operational status of your API. They
    allow you to verify that your application is running and ready to respond to the
    requests after that checkpoint. Implementing health checks can help you detect
    issues before they impact users, enabling proactive maintenance and quick recovery.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查对于监控您的API的运行状态至关重要。它们允许您验证在检查点之后，您的应用程序正在运行并准备好响应请求。实施健康检查可以帮助您在问题影响用户之前发现它们，从而实现主动维护和快速恢复。
- en: 'Consider this real-world scenario: An e-commerce company deployed a new version
    of its Order Management API on Friday afternoon. The deployment seemed successful—all
    services started without errors, and initial manual tests passed. However, by
    Monday morning, the customer service team was flooded with complaints about missing
    orders and inventory discrepancies. Investigation revealed that while the API
    was technically running, it could not properly connect to the product inventory
    database due to a configuration issue.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个真实场景：一家电子商务公司在周五下午部署了其订单管理API的新版本。部署看起来很成功——所有服务都启动无误，初步的手动测试也通过了。然而，到了周一早上，客户服务团队收到了大量关于订单缺失和库存差异的投诉。调查发现，尽管API在技术上正在运行，但由于配置问题，它无法正确连接到产品库存数据库。
- en: Without proper health checks in place, the deployment was considered successful
    despite this critical failure. Health checks serve as your application’s vital
    signs monitoring system—much like how a doctor checks your pulse, blood pressure,
    and temperature to assess your overall health. For containerized applications
    especially, these checks are crucial because they inform orchestration tools whether
    your containers should receive traffic, be restarted, or be replaced entirely.
    A well-designed health check system distinguishes between temporary glitches and
    serious failures, preventing unnecessary restarts while ensuring genuine problems
    are addressed promptly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有适当的健康检查的情况下，尽管存在这种关键故障，部署仍被视为成功。健康检查充当您应用程序的生命体征监控系统——就像医生检查您的脉搏、血压和体温以评估您的整体健康状况一样。对于容器化应用程序尤其如此，这些检查至关重要，因为它们会告知编排工具您的容器是否应该接收流量、重启或完全替换。一个设计良好的健康检查系统可以区分暂时性故障和严重故障，防止不必要的重启，同时确保真正的问题得到及时解决。
- en: For our Order Management and Product API, implementing comprehensive health
    checks means we can confidently automate deployments, knowing that our monitoring
    will catch issues that might otherwise go undetected until customers are affected.
    Let’s explore how to implement these critical safeguards in our application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的订单管理和产品API，实施全面的健康检查意味着我们可以自信地自动化部署，因为我们知道我们的监控将捕获可能否则未被检测到的问题，直到客户受到影响。让我们探讨如何在我们的应用程序中实施这些关键的安全措施。
- en: 'Case scenario: weekend system maintenance'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例场景：周末系统维护
- en: 'Imagine this scenario: Your team performs routine database maintenance on Saturday
    morning. After the maintenance is completed, all services appear to restart normally.
    However, without proper health checks, you might not discover until Monday that
    while the application is running, it cannot connect to the database properly.
    This would result in lost orders and frustrated customers.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下场景：您的团队在周六早上进行常规数据库维护。维护完成后，所有服务似乎都正常重启。然而，如果没有适当的健康检查，您可能直到周一才会发现，尽管应用程序正在运行，但它无法正确连接到数据库。这会导致订单丢失和客户不满。
- en: With effective health checks, you would immediately know whether the database
    connection was properly restored after maintenance, allowing you to fix issues
    before they impact business operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效的健康检查，您会立即知道维护后数据库连接是否已正确恢复，这样您就可以在这些问题影响业务运营之前修复它们。
- en: Implementing basic health checks with Spring Boot Actuator
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Spring Boot Actuator实现基本健康检查
- en: 'For our Order Management and Product API, let’s implement a simple but effective
    health check system:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的订单管理和产品API，让我们实施一个简单但有效的健康检查系统：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this dependency added to your project, Spring Boot automatically exposes
    a `/actuator/health` endpoint that returns the application’s status.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将此依赖项添加到您的项目中后，Spring Boot会自动公开一个`/actuator/health`端点，该端点返回应用程序的状态。
- en: Custom health indicators for order management
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单管理的自定义健康指标
- en: 'Let’s create a simple health check for our order repository:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的订单存储库创建一个简单的健康检查：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, create a health check for products:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为产品创建一个健康检查：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Multi-level health checks
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多级健康检查
- en: For our Order Management and Product API, implementing multi-level health checks
    helps distinguish between different types of operational states.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的订单管理和产品API，实施多级健康检查有助于区分不同的操作状态。
- en: Liveness checks
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 活跃性检查
- en: 'Liveness checks answer a simple question: “Is the application running?” These
    checks should be lightweight and avoid dependencies on external systems:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃性检查回答一个简单的问题：“应用程序是否正在运行？”这些检查应该是轻量级的，并避免依赖于外部系统：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Configure this in your `application.yml` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`application.yml`文件中配置此内容：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Readiness checks
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准备就绪检查
- en: 'Readiness checks answer: “Can the application accept and process requests?”
    These checks should verify external dependencies:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪检查回答：“应用程序能否接受和处理请求？”这些检查应验证外部依赖项：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Configure this in `application.yml` :'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application.yml`中配置此内容：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Component health checks
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组件健康检查
- en: 'Component health checks provide detailed status for specific parts of your
    system:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 组件健康检查提供了您系统特定部分的详细状态：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Practical usage of multi-level health checks
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多级健康检查的实际应用
- en: 'With these levels defined, you can use them for different purposes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些级别后，您可以使用它们用于不同的目的：
- en: '**Liveness checks** : Used by Docker to determine whether the container should
    be restarted'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃性检查**：由Docker用于确定容器是否应该重启'
- en: '**Readiness checks** : Used to determine whether the API can receive traffic'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**就绪性检查**：用于确定API是否可以接收流量'
- en: '**Component checks** : Used by operators to diagnose specific system issues'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件检查**：由操作员用于诊断特定系统问题'
- en: 'Update your Docker Compose configuration to use these specific endpoints:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的Docker Compose配置以使用这些特定的端点：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Basic configuration in application.properties
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在application.properties中进行基本配置
- en: 'Configure the health check endpoints:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配置健康检查端点：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While health checks provide essential visibility into your application’s operational
    status, they become even more powerful when integrated with modern deployment
    approaches. Now that we have established robust health monitoring for our Order
    Management and Product API, the next logical step is to package our application
    in a way that leverages these health checks effectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然健康检查提供了对应用程序操作状态的必要可见性，但当它们与现代部署方法集成时，它们变得更加强大。现在我们已经为我们的订单管理和产品API建立了稳健的健康监控，下一步合乎逻辑的步骤是以一种可以利用这些健康检查的有效方式打包我们的应用程序。
- en: Containerization offers the perfect complement to our health check strategy.
    By encapsulating our application and its dependencies in lightweight, portable
    containers, we can ensure consistent behavior across different environments while
    making the most of our monitoring capabilities. Docker containers can be configured
    to automatically restart based on our health check results, providing a first
    line of defense against service disruptions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是我们健康检查策略的完美补充。通过将我们的应用程序及其依赖项封装在轻量级、可移植的容器中，我们可以在不同环境中确保一致的行为，同时充分利用我们的监控能力。Docker容器可以根据我们的健康检查结果自动重启，为服务中断提供第一道防线。
- en: In the next section, we will explore how to containerize our Order Management
    and Product API using Docker, creating a deployment pipeline that ensures our
    application runs reliably in any environment. We’ll see how our health checks
    integrate seamlessly with Docker’s built-in monitoring, creating a self-healing
    system that can detect and recover from many common failure scenarios automatically.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用Docker容器化我们的订单管理和产品API，创建一个确保我们的应用程序在任何环境中可靠运行的部署管道。我们将看到我们的健康检查如何与Docker内置的监控无缝集成，创建一个可以自动检测和从许多常见故障场景中恢复的自愈系统。
- en: Containerization
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化
- en: '**Containerization** has revolutionized the way applications are deployed by
    providing a method to package an application along with all its dependencies.
    This ensures that the application runs consistently across different environments,
    whether it be development, testing, or production. Unlike traditional **virtual
    machines** ( **VMs** ), containers share the host operating system kernel, making
    them lightweight and efficient.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器化**通过提供一种打包应用程序及其所有依赖项的方法，彻底改变了应用程序的部署方式。这确保了应用程序在不同环境中的一致运行，无论是开发、测试还是生产。与传统**虚拟机**（**VMs**）不同，容器共享宿主操作系统的内核，使它们轻量级且高效。'
- en: 'Containerization has revolutionized how we deploy and manage APIs in modern
    software development. At its core, containerization is the process of packaging
    an application and all its dependencies—libraries, configuration files, and runtime
    environments—into a standardized, self-contained unit called a **container** .
    This approach addresses one of the most persistent challenges in software deployment:
    “It works on my machine, why doesn’t it work in production?”'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化彻底改变了我们在现代软件开发中部署和管理API的方式。其核心是，容器化是将应用程序及其所有依赖项——库、配置文件和运行时环境——打包成一个标准化的、自包含的单元，称为**容器**。这种方法解决了软件部署中最持久的挑战之一：“在我的机器上它运行正常，为什么在生产环境中不工作？”
- en: 'This process has several key benefits:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程有几个关键优势：
- en: '**Portability** : Applications can be moved seamlessly across various environments
    without modification'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：应用程序可以在各种环境中无缝移动而无需修改'
- en: '**Scalability** : Containers can be rapidly scaled up or down based on demand'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：容器可以根据需求快速扩展或缩减'
- en: '**Isolation** : Each container runs independently, preventing conflicts between
    applications'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：每个容器独立运行，防止应用程序之间的冲突'
- en: '**Resource efficiency** : Containers share OS resources, making them more lightweight
    than VMs'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源效率**：容器共享操作系统资源，比虚拟机更轻量级'
- en: '**Consistency** : Developers and operations teams work with identical environments'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：开发人员和运维团队使用相同的环境'
- en: '**Rapid deployment** : New versions can be deployed in seconds rather than
    hours or days'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速部署**：新版本可以在几秒钟内部署，而不是几个小时或几天'
- en: '**Self-healing** : Failed containers can be automatically restarted based on
    health checks'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自愈**：失败的容器可以根据健康检查自动重启'
- en: '![Figure 12.2 – Containerization vs. VMs](img/B21843_12_2.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 容器化与虚拟机](img/B21843_12_2.png)'
- en: Figure 12.2 – Containerization vs. VMs
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 容器化与虚拟机
- en: How containers work
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的工作原理
- en: 'Containers encapsulate an application and its dependencies into a single unit
    that can be executed anywhere, providing a consistent environment across various
    systems. They achieve this by leveraging the host operating system’s kernel while
    maintaining isolation from other containers. This isolation is achieved through
    namespaces and **control groups** ( **cgroups** ) in the Linux operating system,
    which provide the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将应用程序及其依赖项封装成一个单一单元，可以在任何地方执行，为各种系统提供一致的环境。它们通过利用宿主操作系统的内核同时保持与其他容器的隔离来实现这一点。这种隔离是通过Linux操作系统的命名空间和**控制组**（**cgroups**）实现的，它们提供以下功能：
- en: '**Namespaces** : These create separate environments for containers. Each container
    has its own filesystem, **process ID** ( **PID** ) space, user IDs, and network
    interfaces, preventing them from interfering with one another.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：这些为容器创建单独的环境。每个容器都有自己的文件系统、**进程ID**（**PID**）空间、用户ID和网络接口，防止它们相互干扰。'
- en: '**Control groups (cgroups)** : These limit and prioritize resource usage (CPU,
    memory, and disk I/O) for containers, ensuring that no single container can monopolize
    system resources.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制组（cgroups）**：这些限制并优先处理容器的资源使用（CPU、内存和磁盘I/O），确保没有单个容器可以垄断系统资源。'
- en: Layers of a container
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的层
- en: 'Containers are built from images, which are composed of a series of layers.
    Each layer represents a set of changes or additions to the base image. This layered
    architecture provides several advantages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是由镜像构建的，这些镜像由一系列层组成。每一层代表对基础镜像的更改或添加。这种分层架构提供了以下优势：
- en: '**Shared layers** : Multiple containers can share the same underlying layers,
    reducing disk space usage and speeding up deployment'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享层**：多个容器可以共享相同的底层层，减少磁盘空间使用并加快部署'
- en: '**Version control** : Each layer can be versioned, allowing for easy rollbacks
    to previous versions of the application'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：每个层都可以进行版本控制，允许轻松回滚到应用程序的先前版本'
- en: '**Efficient builds** : When building a new image, Docker uses caching to only
    rebuild layers that have changed, resulting in faster build times'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效构建**：当构建新的镜像时，Docker使用缓存机制仅重建已更改的层，从而实现更快的构建时间'
- en: Common containerization tools
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的容器化工具
- en: 'There are several tools available for containerization, each with its own unique
    features and benefits. Some of the most common tools are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于容器化的工具有多种，每种工具都有其独特的功能和优势。以下是一些最常见的工具：
- en: '**Docker** : Currently the most popular containerization platform, Docker provides
    a comprehensive set of tools for building, managing, and running containers. It
    simplifies the entire container life cycle and has a large ecosystem of community
    support and resources.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：目前最受欢迎的容器化平台，Docker提供了一套全面的工具，用于构建、管理和运行容器。它简化了整个容器生命周期，并拥有庞大的社区支持和资源生态系统。'
- en: '**Kubernetes** : While not a containerization tool itself, Kubernetes is a
    powerful orchestration platform that manages containerized applications at scale,
    automating deployment, scaling, and operations for applications.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：虽然Kubernetes本身不是容器化工具，但它是一个强大的编排平台，可以大规模管理容器化应用程序，自动化应用程序的部署、扩展和操作。'
- en: '**OpenShift** : Based on Kubernetes, OpenShift adds additional features and
    tools specifically designed for enterprise environments, providing a PaaS experience
    for developers.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift**：基于Kubernetes，OpenShift为企业环境添加了额外的功能和工具，为开发者提供PaaS体验。'
- en: '**Podman** : An alternative to Docker that allows container management without
    requiring a daemon. Podman offers a similar command-line interface to Docker,
    making it easy for users to transition.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Podman**：Docker的替代品，允许在不需要守护进程的情况下进行容器管理。Podman提供了与Docker类似的命令行界面，使用户过渡变得容易。'
- en: '**Rancher** : A complete container management platform that makes it easy to
    deploy and manage multiple Kubernetes clusters.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rancher**：一个完整的容器管理平台，使得部署和管理多个Kubernetes集群变得容易。'
- en: For this chapter, we will focus primarily on Docker, as it is the most widely
    adopted containerization solution today. Its ease of use, extensive documentation,
    and vibrant community make it an ideal choice for developers looking to implement
    containerization in their projects.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将主要关注 Docker，因为它是目前最广泛采用的容器化解决方案。其易用性、广泛的文档和活跃的社区使其成为希望在其项目中实现容器化的开发人员的理想选择。
- en: 'The typical structure of a Docker image consists of the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像的典型结构如下：
- en: '**Base layer** : The foundation of the image, such as an operating system or
    runtime'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础层**：镜像的基础，例如操作系统或运行时'
- en: '**Application layer** : The actual application code and dependencies added
    on top of the base layer'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：在基础层之上添加的实际应用程序代码和依赖项'
- en: '**Configuration layers** : Any additional configurations or environment variables
    specified in the Dockerfile'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置层**：在 Dockerfile 中指定的任何附加配置或环境变量'
- en: Docker architecture
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker 架构
- en: 'To understand containerization fully, we must explore the architecture of Docker,
    the most widely used containerization platform. Docker operates on a client-server
    architecture that consists of several key components:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解容器化，我们必须探索最广泛使用的容器化平台 Docker 的架构。Docker 在客户端-服务器架构上运行，该架构由几个关键组件组成：
- en: '**Docker Engine** : This is the core component that allows users to build,
    run, and manage containers. It consists of the **Docker daemon** ( **dockerd**
    ), which runs in the background and manages images, containers, networking, and
    storage, and the Docker **command-line interface** ( **CLI** ), which allows users
    to interact with the Docker daemon.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 引擎**：这是允许用户构建、运行和管理容器的核心组件。它包括在后台运行的 **Docker 守护进程**（ **dockerd**
    ），它管理镜像、容器、网络和存储，以及 Docker 的 **命令行界面**（ **CLI** ），它允许用户与 Docker 守护进程交互。'
- en: '**Docker components** :'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 组件**：'
- en: '**Images** : Immutable templates used to create containers'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：用于创建容器的不可变模板'
- en: '**Containers** : Running instances of Docker images'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：Docker 镜像的运行实例'
- en: '**Volumes** : Persistent storage for containers'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**：容器的持久化存储'
- en: '**Networks** : Enables communication between containers and external services'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：使容器和外部服务之间能够通信'
- en: '**Registry** : A repository for storing and distributing Docker images, such
    as Docker Hub'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册表**：用于存储和分发 Docker 镜像的仓库，例如 Docker Hub'
- en: '**Docker workflow** : The workflow begins when developers create a Dockerfile,
    which defines the application environment. Docker Engine builds an image from
    this Dockerfile, which is then stored in a registry. A container is instantiated
    from the image, and the container runs, providing the application service.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 工作流程**：工作流程从开发人员创建 Dockerfile 开始，该文件定义了应用程序环境。Docker 引擎从这个 Dockerfile
    构建一个镜像，然后将其存储在注册表中。从镜像实例化一个容器，容器运行并提供应用程序服务。'
- en: '![Figure 12.3 – Docker architecture](img/B21843_12_3.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – Docker 架构](img/B21843_12_3.png)'
- en: Figure 12.3 – Docker architecture
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – Docker 架构
- en: The diagram in *Figure 12.3* illustrates the Docker architecture we just described,
    showing how the various components interact to create the environment where our
    containers run. Understanding this architecture is crucial as we move forward
    to containerize our Order Management API. The diagram shows the layered structure
    of Docker, from the host operating system at the bottom to the individual containers
    at the top, highlighting how Docker efficiently manages resources while providing
    isolation between applications. Let us implement an example of creating a Docker
    container based on an image that provides us the **JRE (Java Runtime Environment)**
    and run it on our machine as described in the next topic.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.3* 中的图示展示了我们刚刚描述的 Docker 架构，展示了各种组件如何相互作用以创建我们的容器运行的环境。理解这个架构对于我们进一步将订单管理
    API 容器化至关重要。该图显示了 Docker 的分层结构，从底部的宿主操作系统到顶部的单个容器，突出了 Docker 如何高效地管理资源，同时为应用程序提供隔离。让我们通过下一个主题中描述的方法，实现一个基于提供
    **JRE (Java 运行时环境**) 的镜像创建 Docker 容器的示例。'
- en: 'Example: containerizing a RESTful API'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：将 RESTful API 容器化
- en: 'To illustrate the containerization process, let us consider a practical example
    based on a RESTful API similar to the one found in the following GitHub repository:
    *RESTful API Book Example* . This example will guide you through the steps to
    create a Docker container for a Java/Maven-based RESTful API.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明容器化过程，让我们考虑一个基于类似以下 GitHub 仓库的 RESTful API 的实际示例：*RESTful API 书籍示例*。此示例将指导你完成创建
    Java/Maven 基础 RESTful API 的 Docker 容器的步骤。
- en: 'Step 1: Project structure'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：项目结构
- en: 'First, ensure your project is structured correctly. A typical structure for
    a Java/Maven-based RESTful API might look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你的项目结构正确。基于 Java/Maven 的 RESTful API 的典型结构可能如下所示：
- en: '![Figure 12.4 – Structure of directories of product-api](img/B21843_12_4.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – product-api 目录结构](img/B21843_12_4.png)'
- en: Figure 12.4 – Structure of directories of product-api
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – product-api 目录结构
- en: 'Regarding the structure, the essential points are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于结构，以下是一些关键点：
- en: The `target/` folder containing the JAR file
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 JAR 文件的 `target/` 文件夹
- en: The main source structure under `src/main/java/`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `src/main/java/` 下的主要源结构
- en: The Dockerfile at the root level
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根目录下的 Dockerfile
- en: In the next steps, we will create the Dockerfile and run commands that require
    the structure that we presented here in *Figure 12.4* .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将创建 Dockerfile 并运行需要我们在此处展示的 *图12.4* 中的结构的命令。
- en: 'Step 2: Creating the Dockerfile'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：创建 Dockerfile
- en: 'Inside the root of your project directory, create a file named `Dockerfile`
    with the following content:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录根目录下，创建一个名为 `Dockerfile` 的文件，内容如下：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Step 3: Building the Docker image'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：构建 Docker 镜像
- en: 'Before building the image, ensure your project is packaged correctly. If you
    are using Maven, you can build the JAR file by running the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像之前，确保你的项目已正确打包。如果你使用 Maven，可以通过运行以下命令来构建 JAR 文件：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After the build is complete, you can create the Docker image with the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，你可以使用以下命令创建 Docker 镜像：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `-t` flag tags the image with the name `my-restful-api` .
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 标志将镜像标记为 `my-restful-api` 名称。'
- en: 'Step 4: Running the Docker container'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：运行 Docker 容器
- en: 'Now that you have built the Docker image, you can run a container from it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经构建了 Docker 镜像，你可以从它运行一个容器：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s break down this command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个命令：
- en: '`-d` runs the container in detached mode (in the background)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 以分离模式（在后台）运行容器'
- en: '`-p 8080:8080` maps port `8080` on the host to port `8080` in the container'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 8080:8080` 将主机上的端口 `8080` 映射到容器中的端口 `8080`'
- en: '`--name restful-api-container` assigns a name to the container for easier management'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name restful-api-container` 为容器分配一个名称，以便更容易管理'
- en: 'Step 5: Testing the API'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：测试 API
- en: 'Once the container is running, you can test the API by sending a request to
    it. Open your web browser or use a tool such as `curl` or Postman to send a request:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，你可以通过向其发送请求来测试 API。打开你的网页浏览器或使用 `curl` 或 Postman 等工具发送请求：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Replace `/api/endpoint` with the actual endpoint you want to test. If everything
    is set up correctly, you should receive a response from your API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `/api/endpoint` 替换为你想要测试的实际端点。如果一切设置正确，你应该会收到来自你的API的响应。
- en: Best practices for container deployment
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器部署的最佳实践
- en: 'To ensure effective container deployment, adhering to best practices is crucial:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保有效的容器部署，遵循最佳实践至关重要：
- en: '**Optimize image size** : Use lightweight base images such as `alpine` or `openjdk:21-slim`
    to minimize the final image size'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化镜像大小**：使用轻量级的基础镜像，如 `alpine` 或 `openjdk:21-slim`，以最小化最终镜像大小'
- en: '**Minimize layers** : Combine multiple commands into a single `RUN` command
    in the Dockerfile to reduce the number of layers in the image'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化层**：在 Dockerfile 中将多个命令合并为一个 `RUN` 命令，以减少镜像中的层数'
- en: '**Use multi-stage builds** : Build the application in one stage and copy only
    the necessary artifacts to the final image, reducing the overall size'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用多阶段构建**：在一个阶段构建应用程序，并将必要的工件复制到最终镜像中，以减少整体大小'
- en: '**Implement health checks** : Use Docker’s `HEALTHCHECK` feature to ensure
    that containerized applications are running properly'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现健康检查**：使用 Docker 的 `HEALTHCHECK` 功能来确保容器化应用程序正常运行'
- en: '**Secure images** : Regularly scan images for vulnerabilities using tools such
    as Trivy or Docker Scout to maintain security standards'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保镜像安全**：使用 Trivy 或 Docker Scout 等工具定期扫描镜像以查找漏洞，以维护安全标准'
- en: Challenges and considerations
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战和考虑因素
- en: 'While Docker simplifies deployment, it also presents challenges that need to
    be addressed:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Docker 简化了部署，但也带来了需要解决的问题：
- en: '**Security vulnerabilities** : Images can contain vulnerabilities that need
    to be managed proactively.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全漏洞**：镜像可能包含需要主动管理的漏洞。'
- en: '**Networking complexity** : Understanding and configuring container networking
    can be complex and requires careful planning.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络复杂性**：理解和配置容器网络可能很复杂，需要周密规划。'
- en: '**Storage management** : Properly managing storage for persistent data can
    present challenges in containerized environments.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储管理**：在容器化环境中，正确管理持久数据可能带来挑战。'
- en: '**Monitoring and logging** : Integrating monitoring and logging solutions is
    essential for maintaining visibility into container performance.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和日志记录**：集成监控和日志记录解决方案对于保持对容器性能的可见性至关重要。'
- en: '**Cloud-specific requirements** : Each cloud provider implements container
    orchestration differently, with unique services and configurations. Even within
    the AWS ecosystem alone, effective container deployment requires familiarity with
    several interconnected services such as ECR, ECS/EKS, IAM roles, VPC networking,
    and load balancing. While this chapter introduces containerization fundamentals,
    comprehensive coverage of provider-specific deployment workflows would extend
    beyond our scope. The preceding example offers a practical starting point, but
    production deployments typically require deeper platform-specific knowledge and
    expertise. Organizations often develop specialized DevOps teams focused on these
    deployment pipelines and infrastructure management concerns.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云特定要求**：每个云提供商对容器编排的实现方式不同，拥有独特的服务和配置。仅就AWS生态系统而言，有效的容器部署需要熟悉多个相互关联的服务，如ECR、ECS/EKS、IAM角色、VPC网络和负载均衡。虽然本章介绍了容器化的基础知识，但针对特定提供商的部署工作流的全面覆盖将超出我们的范围。前面的示例提供了一个实用的起点，但生产部署通常需要更深入的平台特定知识和专业技能。组织通常开发专门的DevOps团队，专注于这些部署管道和基础设施管理问题。'
- en: Containerization enables modern, scalable, and portable API deployments. By
    understanding Docker’s architecture, image life cycle, and best practices, developers
    can efficiently deploy RESTful APIs in cloud and on-premises environments. This
    foundational knowledge equips you with the skills necessary to navigate the complexities
    of modern deployment strategies.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化技术使得现代的、可扩展的以及可移植的API部署成为可能。通过理解Docker的架构、镜像生命周期和最佳实践，开发者可以高效地在云和本地环境中部署RESTful
    API。这种基础性知识使你具备应对现代部署策略复杂性的技能。
- en: In the next section, we will explore **platform as a service** ( **PaaS** )
    using AWS Elastic Beanstalk, an enterprise-grade platform for deploying and managing
    containerized applications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用AWS Elastic Beanstalk探索**平台即服务**（**PaaS**），这是一个用于部署和管理容器化应用程序的企业级平台。
- en: PaaS
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PaaS
- en: PaaS represents a cloud computing model that provides developers with a complete
    platform—including hardware, software, and infrastructure—to develop, deploy,
    and manage applications without the complexity of building and maintaining the
    infrastructure typically associated with such processes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS代表了一种云计算模型，它为开发者提供了一个完整的平台——包括硬件、软件和基础设施——以便在不涉及构建和维护通常与这些过程相关的基础设施复杂性的情况下开发、部署和管理应用程序。
- en: During this evolution of cloud computing services, PaaS is on the middle ground
    between **infrastructure as a service** ( **IaaS** ), which provides only the
    basic computing infrastructure, and **software as a service** ( **SaaS** ), which
    provides ready-to-use applications. This convenience makes PaaS particularly valuable
    for development teams focused on creating and deploying applications rather than
    managing servers and infrastructure.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算服务的这一演变过程中，PaaS位于仅提供基本计算基础设施的**基础设施即服务**（**IaaS**）和提供现成应用程序的**软件即服务**（**SaaS**）之间。这种便利性使得PaaS对于专注于创建和部署应用程序而不是管理服务器和基础设施的开发团队尤其有价值。
- en: Key components of PaaS
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PaaS的关键组件
- en: 'A typical PaaS offering includes the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的PaaS服务包括以下内容：
- en: '**Runtime environment** : Preconfigured platforms where your application runs'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时环境**：预配置的平台，你的应用程序在此运行'
- en: '**Development tools** : Integrated development environments, debugging tools,
    and version control systems'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发工具**：集成开发环境、调试工具和版本控制系统'
- en: '**Middleware** : Database management systems, application servers, and messaging
    queues'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**：数据库管理系统、应用服务器和消息队列'
- en: '**Operating system** : Managed by the provider and regularly updated for security'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：由提供商管理，并定期更新以保障安全'
- en: '**Networking infrastructure** : Load balancers, firewalls, and security features'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络基础设施**：负载均衡器、防火墙和安全功能'
- en: '**Scaling capabilities** : Automatic or manual scaling options to handle traffic
    fluctuations'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展能力**：自动或手动扩展选项以处理流量波动'
- en: Benefits of PaaS for API deployment
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PaaS在API部署中的优势
- en: 'For RESTful API developers, PaaS offers several significant advantages:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTful API开发者，PaaS提供了几个重要的优势：
- en: '**Reduced development time** : By eliminating infrastructure setup and management
    tasks, developers can focus exclusively on API development, significantly reducing
    time to market'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少的开发时间**：通过消除基础设施设置和管理任务，开发者可以专注于API开发，显著缩短上市时间'
- en: '**Simplified deployment pipeline** : Most PaaS providers offer integrated CI/CD
    capabilities or seamless integration with popular CI/CD tools, streamlining the
    deployment process'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的部署管道**：大多数PaaS提供商提供集成的CI/CD功能或与流行的CI/CD工具的无缝集成，简化了部署过程'
- en: '**Built-in scalability** : APIs can be scaled horizontally or vertically with
    minimal configuration, accommodating traffic spikes without performance degradation'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置的可扩展性**：API可以水平或垂直扩展，配置最小化，适应流量高峰而不会降低性能'
- en: '**Enhanced security** : PaaS providers implement robust security measures,
    including regular updates, encryption, and compliance certifications, reducing
    the security burden on development teams'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的安全性**：PaaS提供商实施强大的安全措施，包括定期更新、加密和合规认证，减轻了开发团队的安全负担'
- en: '**Global availability** : Leading PaaS providers operate data centers worldwide,
    enabling the deployment of APIs closer to end users for improved performance'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全球可用性**：领先的PaaS提供商在全球运营数据中心，使得API的部署更靠近终端用户，从而提高性能'
- en: Common PaaS providers for Java applications
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java应用程序的常见PaaS提供商
- en: 'Several PaaS providers offer excellent support for Java/Maven-based RESTful
    APIs:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 几个PaaS提供商为基于Java/Maven的RESTful API提供出色的支持：
- en: '**AWS Elastic Beanstalk** : Amazon’s PaaS solution that simplifies the deployment
    of Java applications on AWS infrastructure'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Elastic Beanstalk**：亚马逊的PaaS解决方案，简化了在AWS基础设施上部署Java应用程序的过程'
- en: '**Microsoft Azure App Service** : Provides a managed platform for building,
    deploying, and scaling Java web applications'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Azure App Service**：提供构建、部署和扩展Java Web应用程序的托管平台'
- en: '**Google App Engine** : Google’s PaaS offering with specific support for Java
    applications'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google App Engine**：谷歌的PaaS服务，针对Java应用程序提供特定支持'
- en: '**Heroku** : A cloud platform that supports multiple programming languages,
    including Java'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heroku**：支持多种编程语言（包括Java）的云平台'
- en: '**Red Hat OpenShift** : An enterprise Kubernetes platform with strong Java
    support'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Red Hat OpenShift**：一个具有强大Java支持的Kubernetes企业平台'
- en: PaaS versus traditional deployment
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PaaS与传统的部署方式比较
- en: 'Compared to traditional on-premises deployment or basic IaaS solutions, PaaS
    offers the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的本地部署或基本IaaS解决方案相比，PaaS提供以下优势：
- en: '| **Feature** | **Traditional deployment** | **PaaS** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **传统部署** | **PaaS** |'
- en: '| Infrastructure management | Manual, time-consuming | Automated, minimal effort
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 基础设施管理 | 手动，耗时 | 自动，最小化努力 |'
- en: '| Scaling | Complex, requires planning | Simple, often automatic |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 扩展 | 复杂，需要规划 | 简单，通常自动 |'
- en: '| Updates and patches | Manual process | Managed by provider |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 更新和补丁 | 手动过程 | 由提供商管理 |'
- en: '| Development focus | Split between code and infrastructure | Primarily on
    application code |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 开发重点 | 代码和基础设施之间的分割 | 主要在应用代码上 |'
- en: '| Time to market | Longer | Significantly shorter |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 上市时间 | 较长 | 显著缩短 |'
- en: '| Initial cost | High | Low |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 初始成本 | 高 | 低 |'
- en: Table 12.1 – Traditional deployment vs PaaS
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1 – 传统部署与PaaS对比
- en: Considerations when choosing PaaS
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择PaaS时的考虑因素
- en: 'While PaaS offers numerous benefits, developers should consider several factors
    before adoption:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PaaS提供了许多好处，但在采用之前，开发者应考虑几个因素：
- en: '**Vendor lock-in** : Dependency on provider-specific features may complicate
    future migrations. This consideration is crucial because many PaaS providers offer
    proprietary services and tools that can significantly enhance your API development—but
    at a cost. For example, if you deeply integrate with AWS Elastic Beanstalk’s specific
    deployment mechanisms or Azure App Service’s built-in authentication features,
    you may find your application becomes tightly coupled to that platform. Should
    business needs change or pricing structures become unfavorable, migrating to another
    provider could require substantial code refactoring and architectural changes.
    To mitigate this risk, consider implementing abstraction layers for provider-specific
    services and maintaining infrastructure as code that could be adapted for different
    environments.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商锁定**：依赖供应商特定的功能可能会使未来的迁移复杂化。这一考虑因素至关重要，因为许多PaaS供应商提供专有服务和工具，这些服务和工具可以显著提高您的API开发效率——但代价不菲。例如，如果您与AWS
    Elastic Beanstalk的特定部署机制或Azure App Service的内置身份验证功能深度集成，您可能会发现您的应用程序变得与该平台紧密耦合。如果业务需求发生变化或定价结构变得不利，迁移到另一个供应商可能需要大量的代码重构和架构变更。为了降低这种风险，考虑实现针对特定供应商服务的抽象层，并维护基础设施即代码，以便适应不同的环境。'
- en: '**Customization limitations** : Less control over the underlying infrastructure
    can impact specific optimization needs. This is especially relevant for APIs with
    unique performance profiles or security requirements. While PaaS platforms handle
    most infrastructure concerns automatically, this convenience comes with reduced
    flexibility. For instance, if your Order Management API needs specific database
    configurations to handle complex inventory queries efficiently, or custom network
    settings to interact with legacy systems, a PaaS solution may not allow these
    fine-grained adjustments. Organizations should carefully assess whether their
    API requirements fall within the parameters of what the PaaS platform allows,
    or whether more control through IaaS or container orchestration would be necessary.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制限制**：对底层基础设施的控制较少可能会影响特定的优化需求。这对于具有独特性能配置文件或安全要求的API尤其相关。虽然PaaS平台自动处理大多数基础设施问题，但这种便利性伴随着灵活性的降低。例如，如果您的订单管理API需要特定的数据库配置来高效处理复杂的库存查询，或者需要自定义网络设置以与旧系统交互，PaaS解决方案可能不允许这些细粒度的调整。组织应仔细评估其API需求是否在PaaS平台允许的参数范围内，或者是否需要通过IaaS或容器编排来获得更多控制。'
- en: '**Compliance requirements** : Ensuring the PaaS provider meets your industry’s
    regulatory standards is non-negotiable for many industries. For an order management
    system that processes customer information and payment data, compliance with standards
    such as PCI DSS, GDPR, or HIPAA might be mandatory. Not all PaaS providers offer
    the same level of compliance certifications or security controls. Some may provide
    comprehensive compliance documentation and built-in controls, while others might
    leave more responsibility to the developer. Thoroughly investigate a provider’s
    compliance offerings, data residency options, and security practices before committing
    your business-critical APIs to their platform.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规要求**：确保PaaS供应商符合您所在行业的监管标准对于许多行业来说是不可协商的。对于一个处理客户信息和支付数据的订单管理系统，遵守PCI DSS、GDPR或HIPAA等标准可能是强制性的。并非所有PaaS供应商都提供相同级别的合规认证或安全控制。一些可能提供全面的合规文档和内置控制，而另一些可能将更多责任留给开发者。在将您的业务关键API提交给其平台之前，彻底调查供应商的合规服务、数据驻留选项和安全实践。'
- en: '**Cost structure** : Understanding the pricing model is essential to avoid
    unexpected expenses as your API usage grows. PaaS platforms typically charge based
    on resource consumption—CPU usage, memory allocation, storage, and data transfer.
    For an Order Management API that might experience seasonal spikes (such as holiday
    shopping periods), costs could fluctuate dramatically. Some providers offer auto-scaling
    capabilities that automatically adjust resources based on demand, which can be
    efficient but also potentially expensive if not properly configured. Carefully
    analyze the pricing structure, set up monitoring and alerts for resource usage,
    and consider implementing cost optimization strategies such as resource scheduling
    for non-production environments.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本结构**：了解定价模型对于避免随着API使用量的增长而出现意外费用至关重要。PaaS平台通常根据资源消耗——CPU使用率、内存分配、存储和数据传输——来收费。对于可能经历季节性波动的订单管理API（例如假日购物期间），成本可能会大幅波动。一些提供商提供自动扩展功能，可以根据需求自动调整资源，这可能是高效的，但如果配置不当，也可能非常昂贵。仔细分析定价结构，设置资源使用的监控和警报，并考虑实施成本优化策略，如非生产环境中的资源调度。'
- en: '**Performance needs** : Evaluating whether the PaaS can meet your specific
    performance requirements is critical for maintaining user satisfaction. Your Order
    Management API may need to handle thousands of concurrent requests during peak
    periods while maintaining low latency for inventory checks and order processing.
    Different PaaS providers offer varying levels of performance capabilities, from
    basic shared environments to dedicated premium tiers. Consider aspects such as
    geographic distribution of data centers (to reduce latency for global customers),
    available instance sizes, database performance options, and caching capabilities.
    Conduct load testing on your chosen platform to verify it can handle your expected
    traffic patterns before fully committing to a provider.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能需求**：评估PaaS是否能够满足您的特定性能要求对于维持用户满意度至关重要。在高峰期间，您的订单管理API可能需要处理数千个并发请求，同时保持库存检查和订单处理的低延迟。不同的PaaS提供商提供不同级别的性能能力，从基本的共享环境到专用的
    premium 级别。考虑以下方面：数据中心的地域分布（以减少全球客户的延迟）、可用的实例大小、数据库性能选项和缓存能力。在完全承诺于某个提供商之前，对所选平台进行负载测试，以验证其是否能够处理您预期的流量模式。'
- en: By thoroughly evaluating these considerations in the context of your specific
    API requirements, you can make an informed decision about whether PaaS is the
    right approach for your project, and if so, which provider best aligns with your
    needs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在您特定的API需求背景下彻底评估这些考虑因素，您可以做出明智的决定，关于PaaS是否是您项目的正确方法，如果是的话，哪个提供商最适合您的需求。
- en: Having carefully evaluated the considerations we just discussed—vendor lock-in,
    customization limitations, compliance requirements, cost structure, and performance
    needs—we have selected AWS Elastic Beanstalk for our practical example. This choice
    provides an excellent balance between abstraction and control, making it ideal
    for demonstrating PaaS deployment of our Order Management and Product API.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 经过仔细评估我们刚才讨论的考虑因素——供应商锁定、定制限制、合规要求、成本结构和性能需求——我们选择了AWS Elastic Beanstalk作为我们的实际示例。这个选择在抽象和控制之间提供了极佳的平衡，使其非常适合演示我们的订单管理和产品API的PaaS部署。
- en: Additionally, my greater familiarity with AWS allows me to share practical insights
    that go beyond theoretical implementation, helping you navigate potential challenges
    that might arise when deploying your own Order Management API.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我对AWS的深入了解使我能够分享超越理论实现的实用见解，帮助您导航在部署自己的订单管理API时可能出现的潜在挑战。
- en: Let’s now walk through a complete deployment of our Java RESTful API on AWS
    Elastic Beanstalk, showing how these considerations translate into practical implementation
    decisions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来详细说明如何在AWS Elastic Beanstalk上部署我们的Java RESTful API，展示这些考虑因素如何转化为实际实施决策。
- en: 'Practical example: Deploying a RESTful API on AWS Elastic Beanstalk'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际示例：在AWS Elastic Beanstalk上部署RESTful API
- en: Let’s walk through a complete deployment of a Java RESTful API on AWS Elastic
    Beanstalk. This example assumes you have a Spring Boot application ready for deployment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明如何在AWS Elastic Beanstalk上部署一个Java RESTful API。此示例假设您有一个准备就绪的Spring Boot应用程序等待部署。
- en: 'The first step involves preparing your application. First, ensure your application
    is properly packaged:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步涉及准备您的应用程序。首先，确保您的应用程序已正确打包：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This creates a JAR file in the target directory. For Elastic Beanstalk deployment,
    this JAR should be self-contained with an embedded server.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在目标目录中创建一个JAR文件。对于Elastic Beanstalk部署，此JAR应该是一个包含嵌入式服务器的自包含文件。
- en: 'Next, you need to set up the AWS **Elastic Beanstalk** ( **EB** ) environment.
    Install the AWS CLI and the EB CLI:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要设置AWS **Elastic Beanstalk**（**EB**）环境。安装AWS CLI和EB CLI：
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, initialize the EB CLI in your project. Navigate to your project’s root
    directory and run the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的项目中初始化EB CLI。导航到您的项目根目录并运行以下命令：
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This launches an interactive setup where you’ll need to do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个交互式设置，您需要执行以下操作：
- en: Select a Region
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择区域
- en: Create or select an AWS credential profile
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或选择AWS凭证配置文件
- en: Enter an application name
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入应用程序名称
- en: Choose Java as the platform
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择Java作为平台
- en: Select the Java version
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择Java版本
- en: Set up SSH for instance access (optional)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置实例访问的SSH（可选）
- en: 'To create an environment, use the following:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建环境，请使用以下命令：
- en: '[PRE25]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This command triggers several processes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会触发几个过程：
- en: Creates an environment named `my-api-environment`
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`my-api-environment`的环境
- en: Sets up necessary AWS resources (EC2 instances, load balancer, etc.)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置必要的AWS资源（EC2实例、负载均衡器等）
- en: Deploys your application
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署您的应用程序
- en: Configures health monitoring
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置健康监控
- en: 'During creation, you can also specify the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建过程中，您还可以指定以下内容：
- en: Environment type (load balanced or single instance)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境类型（负载均衡或单实例）
- en: Instance type
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例类型
- en: EC2 key pair for SSH access
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于SSH访问的EC2密钥对
- en: VPC settings
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VPC设置
- en: 'Next is the application configuration. Create a file named `.ebextensions/java-options.config`
    in your project root:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是应用程序配置。在您的项目根目录中创建一个名为`.ebextensions/java-options.config`的文件：
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This configuration sets the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置设置以下内容：
- en: Environment variables for your application
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的环境变量
- en: JVM memory settings
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM内存设置
- en: Auto-scaling parameters
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展参数
- en: Service role for your environment
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境服务角色
- en: 'After making changes to your application, deploy the updates with the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在对您的应用程序进行更改后，使用以下命令部署更新：
- en: '[PRE27]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The EB CLI will automatically upload the new version and perform a rolling update.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: EB CLI将自动上传新版本并执行滚动更新。
- en: 'Finally, you need to monitor your application. Access monitoring data through
    the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要监控您的应用程序。通过以下方式访问监控数据：
- en: '[PRE28]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or view detailed metrics and logs via the AWS Management Console:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过AWS管理控制台查看详细的指标和日志：
- en: Navigate to Elastic Beanstalk.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Elastic Beanstalk。
- en: Select your environment.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的环境。
- en: Click on the **Monitoring** tab.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**监控**选项卡。
- en: View logs through the **Logs** section.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**日志**部分查看日志。
- en: Advantages and disadvantages of AWS Elastic Beanstalk (EB)
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk（EB）的优势和劣势
- en: AWS Elastic Beanstalk is a service that makes deploying applications easier
    by handling the infrastructure work for you. When you upload your code, Elastic
    Beanstalk automatically sets up servers, load balancers, and monitoring without
    requiring you to configure these components manually.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk是一种服务，通过为您处理基础设施工作，使部署应用程序变得更加容易。当您上传代码时，Elastic Beanstalk会自动设置服务器、负载均衡器和监控，而无需您手动配置这些组件。
- en: 'This approach sits between two extremes: fully managed services that give you
    little control, and manual server management that requires deep infrastructure
    knowledge. Elastic Beanstalk provides a balanced solution where you can focus
    on writing code while still having access to AWS features when needed.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法介于两个极端之间：完全托管的服务，您几乎没有控制权，以及需要深入了解基础设施知识的手动服务器管理。Elastic Beanstalk提供了一个平衡的解决方案，您可以专注于编写代码，同时当需要时仍可访问AWS功能。
- en: However, like any deployment option, Elastic Beanstalk has both benefits and
    drawbacks. Some teams find it perfect for their needs, while others discover it
    doesn’t fit their specific requirements. Understanding these pros and cons will
    help you decide whether Elastic Beanstalk is the right choice for your RESTful
    API project.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像任何部署选项一样，Elastic Beanstalk既有优点也有缺点。一些团队发现它非常适合他们的需求，而其他团队则发现它不符合他们的特定要求。了解这些优缺点将帮助您决定Elastic
    Beanstalk是否是您RESTful API项目的正确选择。
- en: Let’s explore what makes Elastic Beanstalk useful and where it might fall short
    for API deployment.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索Elastic Beanstalk的用途及其在API部署中可能存在的不足之处。
- en: 'Here are the advantages:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是优势：
- en: '**Simplified operations** : Elastic Beanstalk abstracts away infrastructure
    complexities, automatically handling provisioning, load balancing, auto-scaling,
    and monitoring. This allows developers to focus on application code rather than
    infrastructure management.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated development workflow** : The EB CLI provides a streamlined workflow
    for deployment, making it easy to push updates, monitor health, and manage environments
    directly from your development environment.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS service integration** : Elastic Beanstalk seamlessly integrates with
    other AWS services, including the following:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RDS for database management
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudWatch for monitoring and alerting
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S3 for storage
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IAM for security
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation for infrastructure definition
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform flexibility** : While abstracting away complexity, Elastic Beanstalk
    still allows customization through configuration files ( `.ebextensions` ), enabling
    fine-grained control over the environment.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning and rollbacks** : The platform maintains versions of your deployed
    application, making it easy to roll back to previous versions if issues occur.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost management** : You only pay for the underlying resources (EC2 instances,
    load balancers, etc.) with no additional charge for Elastic Beanstalk itself.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s look at the disadvantages:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited control in some areas** : While Elastic Beanstalk provides customization
    options, you have less control over certain infrastructure aspects compared to
    direct EC2 or container-based deployments'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment delays** : The provisioning and deployment process can take several
    minutes, which may be slower than more container-focused services such as ECS
    or EKS'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cold starts** : New environment creation can take 5 to 10 minutes, making
    it less suitable for ephemeral or rapid test environment creation'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration complexity** : As applications grow more complex, managing
    `.ebextensions` files can become challenging, potentially leading to configuration
    drift or inconsistencies'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor lock-in risk** : Heavy dependence on Elastic Beanstalk-specific configuration
    can make it challenging to migrate to other platforms in the future'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom container limitations** : While supporting Docker, Elastic Beanstalk
    offers less flexibility in container orchestration compared to dedicated container
    services like ECS or EKS'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging challenges** : When issues occur, the abstraction layer can sometimes
    make troubleshooting more difficult, requiring deeper AWS knowledge to diagnose
    problems'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to choose Elastic Beanstalk
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Elastic Beanstalk is particularly well-suited for the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Teams new to AWS or cloud deployment
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications with standard infrastructure requirements
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects requiring rapid initial deployment
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs with predictable scaling patterns
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development and testing environments
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small to medium-sized development teams
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more complex architectures, microservices with custom requirements, or applications
    requiring fine-grained infrastructure control, solutions such as ECS, EKS, or
    direct EC2 management might be more appropriate.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for Elastic Beanstalk deployments
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To maximize the benefits of Elastic Beanstalk while mitigating its limitations
    follow these best practices:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**Use environment-specific configuration files** : Maintaining separate configuration
    files for development, staging, and production environments is crucial for ensuring
    consistency and reliability across your deployment pipeline. When your Order Management
    API moves through these environments, it encounters different infrastructure requirements,
    security needs, and performance expectations. By creating environment-specific
    configurations, you prevent issues such as exposing development debugging tools
    in production or overloading lower-tier development environments with production-scale
    resources. This practice also facilitates easier troubleshooting since you can
    pinpoint whether an issue is environment-specific or inherent to your application
    code.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement blue-green deployments** : Blue-green deployments using Elastic
    Beanstalk’s **swap URL** feature allow you to maintain two identical production
    environments, deploying new code to the inactive environment before switching
    traffic over. This approach is invaluable for your Order Management API because
    it eliminates downtime during deployments—customers can continue placing orders
    without interruption. It also provides an instant rollback mechanism; if a critical
    issue is discovered after deployment, you can immediately switch back to the previous
    environment. This practice is particularly important for high-availability applications
    where even minutes of downtime can result in lost revenue or damaged customer
    trust.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate deployments** : Integrating with CI/CD pipelines using AWS CodePipeline
    and CodeBuild transforms your deployment process from error-prone manual steps
    to a consistent, repeatable workflow. For an Order Management API, this automation
    ensures that every deployment follows the same testing, validation, and deployment
    sequence. This reduces human errors, enforces quality gates before production
    deployment, and creates auditable records of all changes. Automated deployments
    also enable more frequent, smaller updates, reducing the risk associated with
    each deployment while allowing your team to deliver new features and fixes more
    rapidly.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor resource usage** : Setting up CloudWatch alarms to alert on abnormal
    resource consumption provides early warning of potential issues before they impact
    customers. Your Order Management API’s resource needs will fluctuate with business
    cycles—holiday shopping periods may drive significantly higher order volumes than
    normal. Without proper monitoring, these spikes could lead to degraded performance
    or even outages. CloudWatch alarms allow you to detect trends such as gradually
    increasing memory usage (potentially indicating a memory leak) or CPU spikes during
    specific operations. This practice enables proactive scaling decisions and helps
    identify optimization opportunities in your application.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement proper health checks** : Designing comprehensive health check endpoints
    for your API goes beyond simply confirming the application is running—it verifies
    that all critical components are functioning correctly. For an order management
    system, this might include checking database connectivity, verifying that inventory
    services are responsive, and ensuring that payment processing systems are available.
    Well-designed health checks allow Elastic Beanstalk to make accurate decisions
    about when to replace failing instances and when to route traffic to healthy ones.
    This practice directly impacts availability and resilience, preventing scenarios
    where technically “running” but functionally impaired instances continue to receive
    customer traffic.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control configuration** : Keeping `.ebextensions` files in your source
    code repository ensures configuration consistency and provides a historical record
    of infrastructure changes alongside code changes. This practice prevents configuration
    drift between environments and makes it possible to correlate application issues
    with specific infrastructure changes. For your Order Management API, this means
    you can easily trace whether an order processing problem began after a code change
    or an infrastructure configuration change. It also simplifies compliance audits
    by providing clear documentation of how your infrastructure has evolved over time.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Elastic Beanstalk environment properties** : Leveraging environment properties
    for configuration rather than hardcoding values enables you to change application
    behavior without redeployment. This is particularly valuable for your Order Management
    API when you need to adjust throttling limits during high-volume periods, modify
    integration endpoints, or temporarily disable features. Environment properties
    also enhance security by keeping sensitive information such as API keys or database
    credentials out of your source code. This practice increases operational flexibility
    while maintaining security and reducing the need for rapid code deployments to
    make configuration changes.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular database backups** : Implementing regular automated backups for RDS
    instances used by your Order Management API protects against data loss and corruption.
    Order history, customer information, and inventory data are the lifeblood of your
    business—losing this data could be catastrophic. Regular backups with appropriate
    retention policies ensure you can recover from database failures, accidental data
    deletion, or even malicious attacks. This practice also supports compliance requirements
    that may mandate specific data protection measures and retention periods.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security group management** : Carefully configuring security groups to allow
    only necessary inbound traffic forms a critical security boundary for your Order
    Management API. By restricting network access to only required ports and source
    IP ranges, you significantly reduce the attack surface available to potential
    intruders. For instance, your database should only accept connections from your
    application servers, not from the public internet. This practice helps prevent
    unauthorized access to sensitive customer and order data while still ensuring
    legitimate traffic flows smoothly.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log rotation and management** : Configuring proper log rotation prevents
    storage issues that could impact application availability. Without proper rotation,
    logs from high-volume periods could consume all available storage, potentially
    crashing your Order Management API servers. Well-managed logs also provide valuable
    troubleshooting information when investigating order processing issues or performance
    problems. This practice balances the need for operational insights with resource
    constraints, ensuring you maintain visibility into application behavior without
    risking stability.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PaaS evolution and future trends
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As cloud technologies rapidly advance and enterprise requirements become increasingly
    sophisticated, the PaaS landscape is undergoing a transformative evolution that
    promises to revolutionize how Java RESTful APIs are developed, deployed, and managed
    across the digital ecosystem:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes-based PaaS** : Providers are increasingly offering Kubernetes-based
    PaaS solutions that combine the simplicity of traditional PaaS with the flexibility
    of container orchestration'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless PaaS** : The lines between PaaS and serverless computing are blurring,
    with many platforms now offering hybrid models that combine the best of both worlds'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge computing integration** : PaaS providers are expanding to edge locations,
    enabling RESTful APIs to be deployed closer to end users for reduced latency'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AI-driven operations** : Machine learning is being incorporated into PaaS
    offerings to provide predictive scaling, anomaly detection, and automated optimization'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As these trends develop, Java developers should stay informed about how PaaS
    offerings are evolving to take advantage of new capabilities that can enhance
    API deployment and performance.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamentals of deploying Java RESTful APIs,
    from preparation through configuration management and health checks to containerization
    with Docker and platform services via AWS Elastic Beanstalk. These approaches
    offer practical pathways to move your APIs from development to production.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The deployment methods presented here are deliberately straightforward and suitable
    for individual developers or small teams looking to quickly implement functional
    deployment workflows. They provide a solid starting point for those new to API
    deployment.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: In an environment that involves development across bigger structures and teams,
    it might be necessary to implement a more complex process of deployment that requires
    a better understanding of the DevOps culture and implementation of pipelines for
    CI and CD. However, it would require a study of all the concepts and technologies
    that will pave the way for this goal. It would probably require a new book just
    for this topic.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: As your applications scale and your organizational requirements grow, you’ll
    likely need to adopt more sophisticated deployment strategies—including automated
    testing pipelines, approval workflows, enhanced security scanning, cloud infrastructure,
    and comprehensive monitoring solutions. These advanced practices build upon the
    foundation established in this chapter. Our goal was to provide you with practical,
    implementable knowledge to successfully deploy your Java RESTful APIs, creating
    a springboard for your continued exploration of deployment practices as your needs
    evolve.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/New_Packt_Logo1.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: '[packtpub.com](http://packtpub.com)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A t [www.packtpub.com](http://www.packtpub.com) , you can also read a collection
    of free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[![img](img/9781835880609.jpg)](https://www.amazon.com/dp/1835880606?ref=emc_s_m_5_i_atc)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Architecture with Spring**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Wanderson Xesquevixos
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83588-060-9'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Translate complex business needs into clear and implementable design
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design resilient systems with common architectural styles
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform monolithic applications into microservices following best practices
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement event-driven architecture with Kafka
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor, trace, and ensure robust testing, security, and performance
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify bottlenecks and optimize performance using patterns, caching, and database
    strategies
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate development workflows with CI/CD pipelines, using Jenkins to deploy
    the application to Kubernetes
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![img](img/9781803249018.jpg)](https://www.amazon.com/dp/1803249013?ref=emc_s_m_5_i_atc)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring System Design in Practice**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Rodrigo Santiago
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-80324-901-8'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Implement microservices for scalable, resilient web systems
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break down business goals into well-structured product requirements
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weigh tradeoffs between writing asynchronous vs. synchronous services and SQL
    vs. NoSQL storage
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerate service development and reliability through the adoption of test-driven
    development
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify and eliminate hidden performance bottlenecks to maximize speed and
    efficiency
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieve real-time processing and responsiveness in distributed environments
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](http://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Mastering RESTful Web Services with Java* , we’d love to
    hear your thoughts! Scan the QR code below to go straight to the Amazon review
    page for this book and share your feedback or leave a review on the site that
    you purchased it from.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/r/1835466109](https://packt.link/r/1835466109)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Mastering RESTful Web Services with Java* , we’d love to
    hear your thoughts! If you purchased the book from Amazon, please [click here
    to go straight to the Amazon review page](https://packt.link/r/1835466109) for
    this book and share your feedback or leave a review on the site that you purchased
    it from.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
