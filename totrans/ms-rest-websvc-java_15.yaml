- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout our journey of mastering RESTful APIs with Java, we have explored
    various crucial aspects of development. From writing efficient code to implementing
    robust design principles and following industry best practices, we have built
    a solid foundation for creating high-quality APIs. However, the path to delivering
    production-ready software extends beyond development alone.
  prefs: []
  type: TYPE_NORMAL
- en: While our accumulated knowledge of API development is invaluable, it represents
    only part of the complete software delivery life cycle. The critical bridge between
    development and production deployment remains to be crossed. This final stage—the
    deployment process—transforms our well-crafted API into a production-ready service
    that delivers real value to end users.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing APIs for deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform as a Service** ( **PaaS** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment best practices and patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical examples throughout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing APIs for deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before deploying your RESTful API to production, you need to complete several
    important preparation steps. This preparation ensures your API will run properly,
    securely, and reliably in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover some of the key elements required to make your
    Java API ready for deployment. First, we will examine configuration management—how
    to structure your application settings to work across different environments without
    changing code. Then, we will discuss implementing health checks that monitor your
    API’s status and help maintain system reliability.
  prefs: []
  type: TYPE_NORMAL
- en: These preparation steps form the foundation of a successful deployment process.
    They help prevent common problems and create a stable base for your API in production.
    By following these practices, you’ll reduce deployment issues and make your API
    easier to maintain as it grows.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explore these preparation elements in detail, beginning with effective
    configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern RESTful API development, proper configuration management is essential
    for maintaining flexible, secure, and maintainable applications. In this section,
    we will explore the aspects of configuration management and its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Externalized configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Externalized configurations separate your application’s core functionality from
    its configuration setting, avoiding the necessity of placing hardcoded configurations
    inside of the code. This approach allows you to modify application settings without
    needing to change the code. By keeping configuration data outside of the code
    base, you can easily adjust environment-specific settings—such as database URLs,
    security keys, or API endpoints—without recompiling or redeploying your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using Spring Boot, you can externalize configuration by defining
    properties in an external `Properties` or YAML file rather than hardcoding them
    in your Java code. To externalize configuration in a Spring Boot application and
    bind it to a Java class, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an external configuration file ( `application.yml` ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use application configurations from `application.yml` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the API timeout setting is externalized in the `application.yml`
    file. The `ApiProperties` class binds to the `"api"` section, ensuring that any
    changes to the configuration file—such as adjusting the timeout—will take effect
    without modifying the application code.
  prefs: []
  type: TYPE_NORMAL
- en: This approach promotes flexibility and agility during deployment, enabling rapid
    adjustments to configuration values based on the deployment environment.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of externalized configurations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Separating configuration from your application code represents a foundational
    best practice in modern software architecture, particularly for RESTful APIs that
    must operate across diverse environments. By externalizing configuration, development
    teams gain tremendous flexibility in how applications are deployed, secured, and
    maintained throughout their life cycle. This approach fundamentally transforms
    how we manage application settings, moving from hardcoded values embedded in source
    code to dynamic, environment-specific variables that can be modified without recompilation.
    The strategic advantages of this approach extend across multiple dimensions of
    your development and operational processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Environment independence** : Developers benefit from seamless transitions
    between different environments without changing code. For example, your Order
    API can connect to a test product catalog during development that contains sample
    products, but automatically switch to the production catalog with real inventory
    when deployed to production. This allows developers to create and test orders
    with test data locally without affecting real inventory or sending notifications
    to actual customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified maintenance** : Operations teams gain the ability to modify application
    behavior without requiring developer intervention. For instance, when your Product
    API needs to increase the product image cache size from 100 MB to 500 MB due to
    new high-resolution images, operations staff can simply update the externalized
    configuration value rather than requesting code changes and redeployment. Similarly,
    the timeout settings for third-party shipping provider integrations in your Order
    API can be adjusted based on their performance characteristics without development
    team involvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced security** : Security is significantly strengthened by removing
    sensitive credentials from source code. For example, instead of hardcoding the
    payment gateway API key like `paymentGateway.setApiKey("sk_live_51MlkA...")` in
    your Order API code (where it would remain visible in commit history), you can
    use `paymentGateway.setApiKey(environment.getProperty("payment.api.key"))` and
    securely store the actual keys in environment variables. This allows different
    keys to be used for development versus production without exposing sensitive credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier DevOps integration** : Continuous integration and deployment pipelines
    become more powerful with externalized configuration. For example, you can deploy
    the same Order API Docker container to testing and production environments using
    different settings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the testing environment, you might set `INVENTORY_CHECK_ENABLED=false` to
    skip actual inventory verification, while enabling it in production to prevent
    orders for out-of-stock products.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, externalizing configuration provides critical advantages for
    building robust, maintainable, and secure RESTful APIs. By decoupling configuration
    from code, we gain the flexibility to deploy across environments, simplify operational
    updates, enhance security, and streamline DevOps processes. Let us now take a
    look at how to handle profile-based configurations that will allow developers
    to have the flexibility to work and deploy automatically, selecting a specific
    set of configurations for each environment.
  prefs: []
  type: TYPE_NORMAL
- en: Profile-based configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When deploying your RESTful APIs across different environments—from a developer’s
    local machine to test servers and ultimately to production—managing environment-specific
    settings becomes a critical challenge. Profile-based configuration provides an
    elegant solution that directly addresses deployment complexities by allowing your
    API to adapt its behavior based on where it’s running, all without changing a
    single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: For your Order API and Product API, this approach means you can maintain a single
    code base and deployment artifact while automatically adjusting crucial settings
    such as database connections, external service endpoints, security parameters,
    and feature toggles based on the target environment. This capability streamlines
    your CI/CD pipeline and dramatically reduces configuration-related deployment
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: Common profiles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine your Order API needs different database connections and behavior settings
    across environments. You can structure your configuration files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development** : In the development environment—often referred to by the “dev”
    profile—developers focus on writing and testing code either locally or in shared
    development servers. This stage of the software life cycle typically sees very
    frequent code changes, constant experimentation, and rapid deployments. Because
    reliability is not yet critical, developers often use lightweight databases such
    as H2 or other embedded options and may rely on simulated services to stand in
    for external dependencies. Verbose logging is enabled so that any issues can be
    quickly diagnosed, and debugging features are turned up to gain deeper insight
    into the code. Because no actual customer data is involved and real transactions
    are not processed, there is minimal risk to the business at this stage. A practical
    example in the Order API might involve running an in-memory database for orders
    to facilitate speedy local testing, calling a locally running instance of the
    Product API, and simulating payment and shipping services to move faster without
    waiting on real integrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing** : When it’s time to verify that everything works together seamlessly,
    the testing environment—aligned with the “test” profile—comes into play. This
    environment is generally more stable than development, as changes are introduced
    less often and are usually more refined. It mirrors production more closely by
    leveraging databases and external service configurations that resemble real-world
    conditions while still using test data. Throughout this phase, teams carry out
    integration tests, automated user interface tests, performance validations, and
    other checks to ensure the system behaves as expected. Here, the Order API might
    connect to a dedicated test version of MySQL for managing orders, call a testing
    instance of the Product API, and possibly generate shipping labels via a test
    shipping service endpoint. To prevent real charges, payments are typically handled
    by a simulated gateway. This controlled environment allows QA teams and automated
    pipelines to validate complete workflows without jeopardizing real customer data
    or incurring unnecessary costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production** : Once the application has passed all the necessary checks,
    it graduates to the production environment—commonly known by the “prod” profile.
    In this live environment, your APIs serve genuine end users and handle real-world
    interactions. Uptime, security, and performance become paramount. Code running
    here is thoroughly tested and generally changes less frequently, as stability
    takes priority over rapid iteration. The Order API in production will connect
    to robust, secure, and often clustered databases designed to handle large transactions
    at scale, while simultaneously integrating with authentic external services such
    as real payment providers and shipping carriers. Logs are carefully managed to
    collect essential information without adversely affecting performance. Given the
    high stakes and real customer data, asynchronous order fulfillment is frequently
    employed to ensure reliable processing under heavy loads. This environment demands
    close monitoring and swift response to any issues to maintain a seamless customer
    experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can express this structure in Spring Boot. To take advantage of this approach,
    we need to organize all the variables used in each environment that receives the
    suffix of the file with its environment name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – File structure of Spring profile-based configuration](img/B21843_12_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – File structure of Spring profile-based configuration
  prefs: []
  type: TYPE_NORMAL
- en: Activating profiles during deployment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When deploying your Order API to different environments, you activate the appropriate
    profile through environment variables or command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local development** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Automated test environment** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Production deployment with Docker** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach ensures that when your Order API is deployed to production, it
    automatically connects to the production database, uses the live payment gateway,
    communicates with the production Product API instance, and applies appropriate
    performance and security settings—all without any code changes or manual configuration
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Profile-based configuration directly addresses the challenges of deploying the
    same API across multiple environments, making your deployment process more reliable,
    maintainable, and adaptable to changing infrastructure requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Environment variables provide a secure and flexible way to manage configuration
    values, especially for sensitive data. When deploying your API, you can set sensitive
    configurations such as database credentials, API keys, and service endpoints as
    environment variables on your server. This approach keeps critical information
    out of your code base while making it accessible to your application at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Spring Boot applications, the most elegant way to leverage environment variables
    is through the `application.yml` file, where you can reference these variables
    directly in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While reviewing our examples, you may have noticed that both the profile-based
    configuration and environment variables sections use an `application.yml` file,
    yet they represent different approaches to configuration management. In the externalized
    configuration example, we focused on creating separate physical configuration
    files for different environments (such as `application-dev.yml` and `application-prod.yml`
    ), which Spring Boot loads based on the active profile. The environment variables
    approach, by contrast, uses placeholder syntax, `${VARIABLE_NAME:default_value}`
    , within a single configuration file to dynamically inject values at runtime.
    This distinction is important: file-based externalization requires managing complete
    configuration files for each environment and deploying the correct file alongside
    your application, while environment variables allow you to maintain a single configuration
    template where only specific values are overridden at runtime through your deployment
    platform. The environment variable approach offers greater flexibility in containerized
    environments such as Docker and cloud platforms, simplifies secret management
    integration, and enables fine-grained configuration updates without replacing
    entire files. Many production systems leverage both patterns together—using profile-specific
    files for substantial configuration differences between environments while employing
    environment variables for sensitive credentials and frequently changed values.
    This hybrid approach gives development teams the ability to handle both structural
    configuration differences and dynamic value injection within a unified framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Health checks implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Health checks are vital for monitoring the operational status of your API. They
    allow you to verify that your application is running and ready to respond to the
    requests after that checkpoint. Implementing health checks can help you detect
    issues before they impact users, enabling proactive maintenance and quick recovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this real-world scenario: An e-commerce company deployed a new version
    of its Order Management API on Friday afternoon. The deployment seemed successful—all
    services started without errors, and initial manual tests passed. However, by
    Monday morning, the customer service team was flooded with complaints about missing
    orders and inventory discrepancies. Investigation revealed that while the API
    was technically running, it could not properly connect to the product inventory
    database due to a configuration issue.'
  prefs: []
  type: TYPE_NORMAL
- en: Without proper health checks in place, the deployment was considered successful
    despite this critical failure. Health checks serve as your application’s vital
    signs monitoring system—much like how a doctor checks your pulse, blood pressure,
    and temperature to assess your overall health. For containerized applications
    especially, these checks are crucial because they inform orchestration tools whether
    your containers should receive traffic, be restarted, or be replaced entirely.
    A well-designed health check system distinguishes between temporary glitches and
    serious failures, preventing unnecessary restarts while ensuring genuine problems
    are addressed promptly.
  prefs: []
  type: TYPE_NORMAL
- en: For our Order Management and Product API, implementing comprehensive health
    checks means we can confidently automate deployments, knowing that our monitoring
    will catch issues that might otherwise go undetected until customers are affected.
    Let’s explore how to implement these critical safeguards in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case scenario: weekend system maintenance'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine this scenario: Your team performs routine database maintenance on Saturday
    morning. After the maintenance is completed, all services appear to restart normally.
    However, without proper health checks, you might not discover until Monday that
    while the application is running, it cannot connect to the database properly.
    This would result in lost orders and frustrated customers.'
  prefs: []
  type: TYPE_NORMAL
- en: With effective health checks, you would immediately know whether the database
    connection was properly restored after maintenance, allowing you to fix issues
    before they impact business operations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic health checks with Spring Boot Actuator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our Order Management and Product API, let’s implement a simple but effective
    health check system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this dependency added to your project, Spring Boot automatically exposes
    a `/actuator/health` endpoint that returns the application’s status.
  prefs: []
  type: TYPE_NORMAL
- en: Custom health indicators for order management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a simple health check for our order repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, create a health check for products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Multi-level health checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our Order Management and Product API, implementing multi-level health checks
    helps distinguish between different types of operational states.
  prefs: []
  type: TYPE_NORMAL
- en: Liveness checks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Liveness checks answer a simple question: “Is the application running?” These
    checks should be lightweight and avoid dependencies on external systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure this in your `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Readiness checks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Readiness checks answer: “Can the application accept and process requests?”
    These checks should verify external dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure this in `application.yml` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Component health checks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Component health checks provide detailed status for specific parts of your
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Practical usage of multi-level health checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With these levels defined, you can use them for different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Liveness checks** : Used by Docker to determine whether the container should
    be restarted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readiness checks** : Used to determine whether the API can receive traffic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component checks** : Used by operators to diagnose specific system issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update your Docker Compose configuration to use these specific endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Basic configuration in application.properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Configure the health check endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: While health checks provide essential visibility into your application’s operational
    status, they become even more powerful when integrated with modern deployment
    approaches. Now that we have established robust health monitoring for our Order
    Management and Product API, the next logical step is to package our application
    in a way that leverages these health checks effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization offers the perfect complement to our health check strategy.
    By encapsulating our application and its dependencies in lightweight, portable
    containers, we can ensure consistent behavior across different environments while
    making the most of our monitoring capabilities. Docker containers can be configured
    to automatically restart based on our health check results, providing a first
    line of defense against service disruptions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to containerize our Order Management
    and Product API using Docker, creating a deployment pipeline that ensures our
    application runs reliably in any environment. We’ll see how our health checks
    integrate seamlessly with Docker’s built-in monitoring, creating a self-healing
    system that can detect and recover from many common failure scenarios automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Containerization** has revolutionized the way applications are deployed by
    providing a method to package an application along with all its dependencies.
    This ensures that the application runs consistently across different environments,
    whether it be development, testing, or production. Unlike traditional **virtual
    machines** ( **VMs** ), containers share the host operating system kernel, making
    them lightweight and efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Containerization has revolutionized how we deploy and manage APIs in modern
    software development. At its core, containerization is the process of packaging
    an application and all its dependencies—libraries, configuration files, and runtime
    environments—into a standardized, self-contained unit called a **container** .
    This approach addresses one of the most persistent challenges in software deployment:
    “It works on my machine, why doesn’t it work in production?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'This process has several key benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Portability** : Applications can be moved seamlessly across various environments
    without modification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** : Containers can be rapidly scaled up or down based on demand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation** : Each container runs independently, preventing conflicts between
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource efficiency** : Containers share OS resources, making them more lightweight
    than VMs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency** : Developers and operations teams work with identical environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rapid deployment** : New versions can be deployed in seconds rather than
    hours or days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-healing** : Failed containers can be automatically restarted based on
    health checks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Containerization vs. VMs](img/B21843_12_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Containerization vs. VMs
  prefs: []
  type: TYPE_NORMAL
- en: How containers work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Containers encapsulate an application and its dependencies into a single unit
    that can be executed anywhere, providing a consistent environment across various
    systems. They achieve this by leveraging the host operating system’s kernel while
    maintaining isolation from other containers. This isolation is achieved through
    namespaces and **control groups** ( **cgroups** ) in the Linux operating system,
    which provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespaces** : These create separate environments for containers. Each container
    has its own filesystem, **process ID** ( **PID** ) space, user IDs, and network
    interfaces, preventing them from interfering with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control groups (cgroups)** : These limit and prioritize resource usage (CPU,
    memory, and disk I/O) for containers, ensuring that no single container can monopolize
    system resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layers of a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Containers are built from images, which are composed of a series of layers.
    Each layer represents a set of changes or additions to the base image. This layered
    architecture provides several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared layers** : Multiple containers can share the same underlying layers,
    reducing disk space usage and speeding up deployment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control** : Each layer can be versioned, allowing for easy rollbacks
    to previous versions of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient builds** : When building a new image, Docker uses caching to only
    rebuild layers that have changed, resulting in faster build times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common containerization tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several tools available for containerization, each with its own unique
    features and benefits. Some of the most common tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** : Currently the most popular containerization platform, Docker provides
    a comprehensive set of tools for building, managing, and running containers. It
    simplifies the entire container life cycle and has a large ecosystem of community
    support and resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes** : While not a containerization tool itself, Kubernetes is a
    powerful orchestration platform that manages containerized applications at scale,
    automating deployment, scaling, and operations for applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenShift** : Based on Kubernetes, OpenShift adds additional features and
    tools specifically designed for enterprise environments, providing a PaaS experience
    for developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Podman** : An alternative to Docker that allows container management without
    requiring a daemon. Podman offers a similar command-line interface to Docker,
    making it easy for users to transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rancher** : A complete container management platform that makes it easy to
    deploy and manage multiple Kubernetes clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this chapter, we will focus primarily on Docker, as it is the most widely
    adopted containerization solution today. Its ease of use, extensive documentation,
    and vibrant community make it an ideal choice for developers looking to implement
    containerization in their projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical structure of a Docker image consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base layer** : The foundation of the image, such as an operating system or
    runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer** : The actual application code and dependencies added
    on top of the base layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration layers** : Any additional configurations or environment variables
    specified in the Dockerfile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker architecture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To understand containerization fully, we must explore the architecture of Docker,
    the most widely used containerization platform. Docker operates on a client-server
    architecture that consists of several key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Engine** : This is the core component that allows users to build,
    run, and manage containers. It consists of the **Docker daemon** ( **dockerd**
    ), which runs in the background and manages images, containers, networking, and
    storage, and the Docker **command-line interface** ( **CLI** ), which allows users
    to interact with the Docker daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker components** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images** : Immutable templates used to create containers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers** : Running instances of Docker images'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volumes** : Persistent storage for containers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networks** : Enables communication between containers and external services'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registry** : A repository for storing and distributing Docker images, such
    as Docker Hub'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker workflow** : The workflow begins when developers create a Dockerfile,
    which defines the application environment. Docker Engine builds an image from
    this Dockerfile, which is then stored in a registry. A container is instantiated
    from the image, and the container runs, providing the application service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Docker architecture](img/B21843_12_3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in *Figure 12.3* illustrates the Docker architecture we just described,
    showing how the various components interact to create the environment where our
    containers run. Understanding this architecture is crucial as we move forward
    to containerize our Order Management API. The diagram shows the layered structure
    of Docker, from the host operating system at the bottom to the individual containers
    at the top, highlighting how Docker efficiently manages resources while providing
    isolation between applications. Let us implement an example of creating a Docker
    container based on an image that provides us the **JRE (Java Runtime Environment)**
    and run it on our machine as described in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: containerizing a RESTful API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the containerization process, let us consider a practical example
    based on a RESTful API similar to the one found in the following GitHub repository:
    *RESTful API Book Example* . This example will guide you through the steps to
    create a Docker container for a Java/Maven-based RESTful API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Project structure'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, ensure your project is structured correctly. A typical structure for
    a Java/Maven-based RESTful API might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Structure of directories of product-api](img/B21843_12_4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Structure of directories of product-api
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the structure, the essential points are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `target/` folder containing the JAR file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main source structure under `src/main/java/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dockerfile at the root level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next steps, we will create the Dockerfile and run commands that require
    the structure that we presented here in *Figure 12.4* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Creating the Dockerfile'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the root of your project directory, create a file named `Dockerfile`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Building the Docker image'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before building the image, ensure your project is packaged correctly. If you
    are using Maven, you can build the JAR file by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After the build is complete, you can create the Docker image with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `-t` flag tags the image with the name `my-restful-api` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Running the Docker container'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have built the Docker image, you can run a container from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d` runs the container in detached mode (in the background)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p 8080:8080` maps port `8080` on the host to port `8080` in the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--name restful-api-container` assigns a name to the container for easier management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 5: Testing the API'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the container is running, you can test the API by sending a request to
    it. Open your web browser or use a tool such as `curl` or Postman to send a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Replace `/api/endpoint` with the actual endpoint you want to test. If everything
    is set up correctly, you should receive a response from your API.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for container deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure effective container deployment, adhering to best practices is crucial:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimize image size** : Use lightweight base images such as `alpine` or `openjdk:21-slim`
    to minimize the final image size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize layers** : Combine multiple commands into a single `RUN` command
    in the Dockerfile to reduce the number of layers in the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use multi-stage builds** : Build the application in one stage and copy only
    the necessary artifacts to the final image, reducing the overall size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement health checks** : Use Docker’s `HEALTHCHECK` feature to ensure
    that containerized applications are running properly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure images** : Regularly scan images for vulnerabilities using tools such
    as Trivy or Docker Scout to maintain security standards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges and considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While Docker simplifies deployment, it also presents challenges that need to
    be addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security vulnerabilities** : Images can contain vulnerabilities that need
    to be managed proactively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking complexity** : Understanding and configuring container networking
    can be complex and requires careful planning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage management** : Properly managing storage for persistent data can
    present challenges in containerized environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and logging** : Integrating monitoring and logging solutions is
    essential for maintaining visibility into container performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud-specific requirements** : Each cloud provider implements container
    orchestration differently, with unique services and configurations. Even within
    the AWS ecosystem alone, effective container deployment requires familiarity with
    several interconnected services such as ECR, ECS/EKS, IAM roles, VPC networking,
    and load balancing. While this chapter introduces containerization fundamentals,
    comprehensive coverage of provider-specific deployment workflows would extend
    beyond our scope. The preceding example offers a practical starting point, but
    production deployments typically require deeper platform-specific knowledge and
    expertise. Organizations often develop specialized DevOps teams focused on these
    deployment pipelines and infrastructure management concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerization enables modern, scalable, and portable API deployments. By
    understanding Docker’s architecture, image life cycle, and best practices, developers
    can efficiently deploy RESTful APIs in cloud and on-premises environments. This
    foundational knowledge equips you with the skills necessary to navigate the complexities
    of modern deployment strategies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore **platform as a service** ( **PaaS** )
    using AWS Elastic Beanstalk, an enterprise-grade platform for deploying and managing
    containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: PaaS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PaaS represents a cloud computing model that provides developers with a complete
    platform—including hardware, software, and infrastructure—to develop, deploy,
    and manage applications without the complexity of building and maintaining the
    infrastructure typically associated with such processes.
  prefs: []
  type: TYPE_NORMAL
- en: During this evolution of cloud computing services, PaaS is on the middle ground
    between **infrastructure as a service** ( **IaaS** ), which provides only the
    basic computing infrastructure, and **software as a service** ( **SaaS** ), which
    provides ready-to-use applications. This convenience makes PaaS particularly valuable
    for development teams focused on creating and deploying applications rather than
    managing servers and infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Key components of PaaS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical PaaS offering includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime environment** : Preconfigured platforms where your application runs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development tools** : Integrated development environments, debugging tools,
    and version control systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware** : Database management systems, application servers, and messaging
    queues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system** : Managed by the provider and regularly updated for security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking infrastructure** : Load balancers, firewalls, and security features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling capabilities** : Automatic or manual scaling options to handle traffic
    fluctuations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of PaaS for API deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For RESTful API developers, PaaS offers several significant advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced development time** : By eliminating infrastructure setup and management
    tasks, developers can focus exclusively on API development, significantly reducing
    time to market'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified deployment pipeline** : Most PaaS providers offer integrated CI/CD
    capabilities or seamless integration with popular CI/CD tools, streamlining the
    deployment process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in scalability** : APIs can be scaled horizontally or vertically with
    minimal configuration, accommodating traffic spikes without performance degradation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced security** : PaaS providers implement robust security measures,
    including regular updates, encryption, and compliance certifications, reducing
    the security burden on development teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global availability** : Leading PaaS providers operate data centers worldwide,
    enabling the deployment of APIs closer to end users for improved performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common PaaS providers for Java applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several PaaS providers offer excellent support for Java/Maven-based RESTful
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Elastic Beanstalk** : Amazon’s PaaS solution that simplifies the deployment
    of Java applications on AWS infrastructure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Azure App Service** : Provides a managed platform for building,
    deploying, and scaling Java web applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google App Engine** : Google’s PaaS offering with specific support for Java
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heroku** : A cloud platform that supports multiple programming languages,
    including Java'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red Hat OpenShift** : An enterprise Kubernetes platform with strong Java
    support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PaaS versus traditional deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compared to traditional on-premises deployment or basic IaaS solutions, PaaS
    offers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Traditional deployment** | **PaaS** |'
  prefs: []
  type: TYPE_TB
- en: '| Infrastructure management | Manual, time-consuming | Automated, minimal effort
    |'
  prefs: []
  type: TYPE_TB
- en: '| Scaling | Complex, requires planning | Simple, often automatic |'
  prefs: []
  type: TYPE_TB
- en: '| Updates and patches | Manual process | Managed by provider |'
  prefs: []
  type: TYPE_TB
- en: '| Development focus | Split between code and infrastructure | Primarily on
    application code |'
  prefs: []
  type: TYPE_TB
- en: '| Time to market | Longer | Significantly shorter |'
  prefs: []
  type: TYPE_TB
- en: '| Initial cost | High | Low |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Traditional deployment vs PaaS
  prefs: []
  type: TYPE_NORMAL
- en: Considerations when choosing PaaS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While PaaS offers numerous benefits, developers should consider several factors
    before adoption:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vendor lock-in** : Dependency on provider-specific features may complicate
    future migrations. This consideration is crucial because many PaaS providers offer
    proprietary services and tools that can significantly enhance your API development—but
    at a cost. For example, if you deeply integrate with AWS Elastic Beanstalk’s specific
    deployment mechanisms or Azure App Service’s built-in authentication features,
    you may find your application becomes tightly coupled to that platform. Should
    business needs change or pricing structures become unfavorable, migrating to another
    provider could require substantial code refactoring and architectural changes.
    To mitigate this risk, consider implementing abstraction layers for provider-specific
    services and maintaining infrastructure as code that could be adapted for different
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization limitations** : Less control over the underlying infrastructure
    can impact specific optimization needs. This is especially relevant for APIs with
    unique performance profiles or security requirements. While PaaS platforms handle
    most infrastructure concerns automatically, this convenience comes with reduced
    flexibility. For instance, if your Order Management API needs specific database
    configurations to handle complex inventory queries efficiently, or custom network
    settings to interact with legacy systems, a PaaS solution may not allow these
    fine-grained adjustments. Organizations should carefully assess whether their
    API requirements fall within the parameters of what the PaaS platform allows,
    or whether more control through IaaS or container orchestration would be necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance requirements** : Ensuring the PaaS provider meets your industry’s
    regulatory standards is non-negotiable for many industries. For an order management
    system that processes customer information and payment data, compliance with standards
    such as PCI DSS, GDPR, or HIPAA might be mandatory. Not all PaaS providers offer
    the same level of compliance certifications or security controls. Some may provide
    comprehensive compliance documentation and built-in controls, while others might
    leave more responsibility to the developer. Thoroughly investigate a provider’s
    compliance offerings, data residency options, and security practices before committing
    your business-critical APIs to their platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost structure** : Understanding the pricing model is essential to avoid
    unexpected expenses as your API usage grows. PaaS platforms typically charge based
    on resource consumption—CPU usage, memory allocation, storage, and data transfer.
    For an Order Management API that might experience seasonal spikes (such as holiday
    shopping periods), costs could fluctuate dramatically. Some providers offer auto-scaling
    capabilities that automatically adjust resources based on demand, which can be
    efficient but also potentially expensive if not properly configured. Carefully
    analyze the pricing structure, set up monitoring and alerts for resource usage,
    and consider implementing cost optimization strategies such as resource scheduling
    for non-production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance needs** : Evaluating whether the PaaS can meet your specific
    performance requirements is critical for maintaining user satisfaction. Your Order
    Management API may need to handle thousands of concurrent requests during peak
    periods while maintaining low latency for inventory checks and order processing.
    Different PaaS providers offer varying levels of performance capabilities, from
    basic shared environments to dedicated premium tiers. Consider aspects such as
    geographic distribution of data centers (to reduce latency for global customers),
    available instance sizes, database performance options, and caching capabilities.
    Conduct load testing on your chosen platform to verify it can handle your expected
    traffic patterns before fully committing to a provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By thoroughly evaluating these considerations in the context of your specific
    API requirements, you can make an informed decision about whether PaaS is the
    right approach for your project, and if so, which provider best aligns with your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Having carefully evaluated the considerations we just discussed—vendor lock-in,
    customization limitations, compliance requirements, cost structure, and performance
    needs—we have selected AWS Elastic Beanstalk for our practical example. This choice
    provides an excellent balance between abstraction and control, making it ideal
    for demonstrating PaaS deployment of our Order Management and Product API.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, my greater familiarity with AWS allows me to share practical insights
    that go beyond theoretical implementation, helping you navigate potential challenges
    that might arise when deploying your own Order Management API.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now walk through a complete deployment of our Java RESTful API on AWS
    Elastic Beanstalk, showing how these considerations translate into practical implementation
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practical example: Deploying a RESTful API on AWS Elastic Beanstalk'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s walk through a complete deployment of a Java RESTful API on AWS Elastic
    Beanstalk. This example assumes you have a Spring Boot application ready for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step involves preparing your application. First, ensure your application
    is properly packaged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This creates a JAR file in the target directory. For Elastic Beanstalk deployment,
    this JAR should be self-contained with an embedded server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to set up the AWS **Elastic Beanstalk** ( **EB** ) environment.
    Install the AWS CLI and the EB CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize the EB CLI in your project. Navigate to your project’s root
    directory and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This launches an interactive setup where you’ll need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a Region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create or select an AWS credential profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter an application name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose Java as the platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the Java version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up SSH for instance access (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create an environment, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This command triggers several processes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an environment named `my-api-environment`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets up necessary AWS resources (EC2 instances, load balancer, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploys your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configures health monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During creation, you can also specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment type (load balanced or single instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EC2 key pair for SSH access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPC settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next is the application configuration. Create a file named `.ebextensions/java-options.config`
    in your project root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration sets the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM memory settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-scaling parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service role for your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making changes to your application, deploy the updates with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The EB CLI will automatically upload the new version and perform a rolling update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to monitor your application. Access monitoring data through
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or view detailed metrics and logs via the AWS Management Console:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Elastic Beanstalk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Monitoring** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View logs through the **Logs** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages and disadvantages of AWS Elastic Beanstalk (EB)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AWS Elastic Beanstalk is a service that makes deploying applications easier
    by handling the infrastructure work for you. When you upload your code, Elastic
    Beanstalk automatically sets up servers, load balancers, and monitoring without
    requiring you to configure these components manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach sits between two extremes: fully managed services that give you
    little control, and manual server management that requires deep infrastructure
    knowledge. Elastic Beanstalk provides a balanced solution where you can focus
    on writing code while still having access to AWS features when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: However, like any deployment option, Elastic Beanstalk has both benefits and
    drawbacks. Some teams find it perfect for their needs, while others discover it
    doesn’t fit their specific requirements. Understanding these pros and cons will
    help you decide whether Elastic Beanstalk is the right choice for your RESTful
    API project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore what makes Elastic Beanstalk useful and where it might fall short
    for API deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified operations** : Elastic Beanstalk abstracts away infrastructure
    complexities, automatically handling provisioning, load balancing, auto-scaling,
    and monitoring. This allows developers to focus on application code rather than
    infrastructure management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated development workflow** : The EB CLI provides a streamlined workflow
    for deployment, making it easy to push updates, monitor health, and manage environments
    directly from your development environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS service integration** : Elastic Beanstalk seamlessly integrates with
    other AWS services, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RDS for database management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudWatch for monitoring and alerting
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S3 for storage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IAM for security
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation for infrastructure definition
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform flexibility** : While abstracting away complexity, Elastic Beanstalk
    still allows customization through configuration files ( `.ebextensions` ), enabling
    fine-grained control over the environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning and rollbacks** : The platform maintains versions of your deployed
    application, making it easy to roll back to previous versions if issues occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost management** : You only pay for the underlying resources (EC2 instances,
    load balancers, etc.) with no additional charge for Elastic Beanstalk itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s look at the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited control in some areas** : While Elastic Beanstalk provides customization
    options, you have less control over certain infrastructure aspects compared to
    direct EC2 or container-based deployments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment delays** : The provisioning and deployment process can take several
    minutes, which may be slower than more container-focused services such as ECS
    or EKS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cold starts** : New environment creation can take 5 to 10 minutes, making
    it less suitable for ephemeral or rapid test environment creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration complexity** : As applications grow more complex, managing
    `.ebextensions` files can become challenging, potentially leading to configuration
    drift or inconsistencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor lock-in risk** : Heavy dependence on Elastic Beanstalk-specific configuration
    can make it challenging to migrate to other platforms in the future'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom container limitations** : While supporting Docker, Elastic Beanstalk
    offers less flexibility in container orchestration compared to dedicated container
    services like ECS or EKS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging challenges** : When issues occur, the abstraction layer can sometimes
    make troubleshooting more difficult, requiring deeper AWS knowledge to diagnose
    problems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to choose Elastic Beanstalk
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Elastic Beanstalk is particularly well-suited for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Teams new to AWS or cloud deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications with standard infrastructure requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects requiring rapid initial deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs with predictable scaling patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development and testing environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small to medium-sized development teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more complex architectures, microservices with custom requirements, or applications
    requiring fine-grained infrastructure control, solutions such as ECS, EKS, or
    direct EC2 management might be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for Elastic Beanstalk deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To maximize the benefits of Elastic Beanstalk while mitigating its limitations
    follow these best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use environment-specific configuration files** : Maintaining separate configuration
    files for development, staging, and production environments is crucial for ensuring
    consistency and reliability across your deployment pipeline. When your Order Management
    API moves through these environments, it encounters different infrastructure requirements,
    security needs, and performance expectations. By creating environment-specific
    configurations, you prevent issues such as exposing development debugging tools
    in production or overloading lower-tier development environments with production-scale
    resources. This practice also facilitates easier troubleshooting since you can
    pinpoint whether an issue is environment-specific or inherent to your application
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement blue-green deployments** : Blue-green deployments using Elastic
    Beanstalk’s **swap URL** feature allow you to maintain two identical production
    environments, deploying new code to the inactive environment before switching
    traffic over. This approach is invaluable for your Order Management API because
    it eliminates downtime during deployments—customers can continue placing orders
    without interruption. It also provides an instant rollback mechanism; if a critical
    issue is discovered after deployment, you can immediately switch back to the previous
    environment. This practice is particularly important for high-availability applications
    where even minutes of downtime can result in lost revenue or damaged customer
    trust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate deployments** : Integrating with CI/CD pipelines using AWS CodePipeline
    and CodeBuild transforms your deployment process from error-prone manual steps
    to a consistent, repeatable workflow. For an Order Management API, this automation
    ensures that every deployment follows the same testing, validation, and deployment
    sequence. This reduces human errors, enforces quality gates before production
    deployment, and creates auditable records of all changes. Automated deployments
    also enable more frequent, smaller updates, reducing the risk associated with
    each deployment while allowing your team to deliver new features and fixes more
    rapidly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor resource usage** : Setting up CloudWatch alarms to alert on abnormal
    resource consumption provides early warning of potential issues before they impact
    customers. Your Order Management API’s resource needs will fluctuate with business
    cycles—holiday shopping periods may drive significantly higher order volumes than
    normal. Without proper monitoring, these spikes could lead to degraded performance
    or even outages. CloudWatch alarms allow you to detect trends such as gradually
    increasing memory usage (potentially indicating a memory leak) or CPU spikes during
    specific operations. This practice enables proactive scaling decisions and helps
    identify optimization opportunities in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement proper health checks** : Designing comprehensive health check endpoints
    for your API goes beyond simply confirming the application is running—it verifies
    that all critical components are functioning correctly. For an order management
    system, this might include checking database connectivity, verifying that inventory
    services are responsive, and ensuring that payment processing systems are available.
    Well-designed health checks allow Elastic Beanstalk to make accurate decisions
    about when to replace failing instances and when to route traffic to healthy ones.
    This practice directly impacts availability and resilience, preventing scenarios
    where technically “running” but functionally impaired instances continue to receive
    customer traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control configuration** : Keeping `.ebextensions` files in your source
    code repository ensures configuration consistency and provides a historical record
    of infrastructure changes alongside code changes. This practice prevents configuration
    drift between environments and makes it possible to correlate application issues
    with specific infrastructure changes. For your Order Management API, this means
    you can easily trace whether an order processing problem began after a code change
    or an infrastructure configuration change. It also simplifies compliance audits
    by providing clear documentation of how your infrastructure has evolved over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Elastic Beanstalk environment properties** : Leveraging environment properties
    for configuration rather than hardcoding values enables you to change application
    behavior without redeployment. This is particularly valuable for your Order Management
    API when you need to adjust throttling limits during high-volume periods, modify
    integration endpoints, or temporarily disable features. Environment properties
    also enhance security by keeping sensitive information such as API keys or database
    credentials out of your source code. This practice increases operational flexibility
    while maintaining security and reducing the need for rapid code deployments to
    make configuration changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular database backups** : Implementing regular automated backups for RDS
    instances used by your Order Management API protects against data loss and corruption.
    Order history, customer information, and inventory data are the lifeblood of your
    business—losing this data could be catastrophic. Regular backups with appropriate
    retention policies ensure you can recover from database failures, accidental data
    deletion, or even malicious attacks. This practice also supports compliance requirements
    that may mandate specific data protection measures and retention periods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security group management** : Carefully configuring security groups to allow
    only necessary inbound traffic forms a critical security boundary for your Order
    Management API. By restricting network access to only required ports and source
    IP ranges, you significantly reduce the attack surface available to potential
    intruders. For instance, your database should only accept connections from your
    application servers, not from the public internet. This practice helps prevent
    unauthorized access to sensitive customer and order data while still ensuring
    legitimate traffic flows smoothly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log rotation and management** : Configuring proper log rotation prevents
    storage issues that could impact application availability. Without proper rotation,
    logs from high-volume periods could consume all available storage, potentially
    crashing your Order Management API servers. Well-managed logs also provide valuable
    troubleshooting information when investigating order processing issues or performance
    problems. This practice balances the need for operational insights with resource
    constraints, ensuring you maintain visibility into application behavior without
    risking stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PaaS evolution and future trends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As cloud technologies rapidly advance and enterprise requirements become increasingly
    sophisticated, the PaaS landscape is undergoing a transformative evolution that
    promises to revolutionize how Java RESTful APIs are developed, deployed, and managed
    across the digital ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes-based PaaS** : Providers are increasingly offering Kubernetes-based
    PaaS solutions that combine the simplicity of traditional PaaS with the flexibility
    of container orchestration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless PaaS** : The lines between PaaS and serverless computing are blurring,
    with many platforms now offering hybrid models that combine the best of both worlds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge computing integration** : PaaS providers are expanding to edge locations,
    enabling RESTful APIs to be deployed closer to end users for reduced latency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AI-driven operations** : Machine learning is being incorporated into PaaS
    offerings to provide predictive scaling, anomaly detection, and automated optimization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As these trends develop, Java developers should stay informed about how PaaS
    offerings are evolving to take advantage of new capabilities that can enhance
    API deployment and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamentals of deploying Java RESTful APIs,
    from preparation through configuration management and health checks to containerization
    with Docker and platform services via AWS Elastic Beanstalk. These approaches
    offer practical pathways to move your APIs from development to production.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment methods presented here are deliberately straightforward and suitable
    for individual developers or small teams looking to quickly implement functional
    deployment workflows. They provide a solid starting point for those new to API
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In an environment that involves development across bigger structures and teams,
    it might be necessary to implement a more complex process of deployment that requires
    a better understanding of the DevOps culture and implementation of pipelines for
    CI and CD. However, it would require a study of all the concepts and technologies
    that will pave the way for this goal. It would probably require a new book just
    for this topic.
  prefs: []
  type: TYPE_NORMAL
- en: As your applications scale and your organizational requirements grow, you’ll
    likely need to adopt more sophisticated deployment strategies—including automated
    testing pipelines, approval workflows, enhanced security scanning, cloud infrastructure,
    and comprehensive monitoring solutions. These advanced practices build upon the
    foundation established in this chapter. Our goal was to provide you with practical,
    implementable knowledge to successfully deploy your Java RESTful APIs, creating
    a springboard for your continued exploration of deployment practices as your needs
    evolve.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/New_Packt_Logo1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[packtpub.com](http://packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A t [www.packtpub.com](http://www.packtpub.com) , you can also read a collection
    of free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![img](img/9781835880609.jpg)](https://www.amazon.com/dp/1835880606?ref=emc_s_m_5_i_atc)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Architecture with Spring**'
  prefs: []
  type: TYPE_NORMAL
- en: Wanderson Xesquevixos
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83588-060-9'
  prefs: []
  type: TYPE_NORMAL
- en: Translate complex business needs into clear and implementable design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design resilient systems with common architectural styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform monolithic applications into microservices following best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement event-driven architecture with Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor, trace, and ensure robust testing, security, and performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify bottlenecks and optimize performance using patterns, caching, and database
    strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate development workflows with CI/CD pipelines, using Jenkins to deploy
    the application to Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![img](img/9781803249018.jpg)](https://www.amazon.com/dp/1803249013?ref=emc_s_m_5_i_atc)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring System Design in Practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Rodrigo Santiago
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-80324-901-8'
  prefs: []
  type: TYPE_NORMAL
- en: Implement microservices for scalable, resilient web systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break down business goals into well-structured product requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weigh tradeoffs between writing asynchronous vs. synchronous services and SQL
    vs. NoSQL storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerate service development and reliability through the adoption of test-driven
    development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify and eliminate hidden performance bottlenecks to maximize speed and
    efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieve real-time processing and responsiveness in distributed environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](http://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Mastering RESTful Web Services with Java* , we’d love to
    hear your thoughts! Scan the QR code below to go straight to the Amazon review
    page for this book and share your feedback or leave a review on the site that
    you purchased it from.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/r/1835466109](https://packt.link/r/1835466109)'
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Mastering RESTful Web Services with Java* , we’d love to
    hear your thoughts! If you purchased the book from Amazon, please [click here
    to go straight to the Amazon review page](https://packt.link/r/1835466109) for
    this book and share your feedback or leave a review on the site that you purchased
    it from.
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  prefs: []
  type: TYPE_NORMAL
