- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Hexagonal Architecture –Decoupling External Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 六边形架构——解耦外部系统
- en: We’ve already learned how to write tests using the arrange, act, and assert
    template. We’ve also learned about some software design principles, known as the
    SOLID principles, that help us break our software down into smaller components.
    Finally, we’ve learned how test doubles can stand in for collaborating components
    to make FIRST unit tests easier to write. In this chapter, we’re going to combine
    all those techniques into a powerful design approach known as the hexagonal architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 arrange、act 和 assert 模板编写测试。我们还了解了一些称为 SOLID 原则的软件设计原则，这些原则帮助我们将软件分解成更小的组件。最后，我们学习了如何使用测试替身来代替协作组件，使
    FIRST 单元测试更容易编写。在本章中，我们将结合所有这些技术，形成一种称为六边形架构的强大设计方法。
- en: Using this approach, we will benefit from getting more of our application logic
    under unit tests and reducing the number of integration and end-to-end tests required.
    We will build in a natural resilience to changes outside our application. Development
    chores such as changing a database supplier will be simplified, by having fewer
    places where our code needs to be changed. We will also be able to unit test across
    larger units, bringing some tests that require end-to-end testing in other approaches
    under unit tests instead.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们将从将更多应用程序逻辑置于单元测试中并减少所需的集成和端到端测试数量中受益。我们将构建对应用程序外部变化的自然弹性。例如，更改数据库供应商等开发任务将简化，因为我们的代码需要更改的地方更少。我们还将能够对更大的单元进行单元测试，将其他方法中需要端到端测试的一些测试纳入单元测试。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Why external systems are difficult
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么外部系统难以处理
- en: Dependency inversion to the rescue
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转来拯救
- en: Abstracting out the external system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象化外部系统
- en: Writing the domain code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写领域代码
- en: Substituting test doubles for external systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用测试替身替换外部系统
- en: Unit testing bigger units
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试更大的单元
- en: Wordz – abstracting the database
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wordz – 抽象化数据库
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter09](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter09).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter09](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter09)找到。
- en: Why external systems are difficult
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么外部系统难以处理
- en: In this section, we’re going to review the driving force behind the hexagonal
    architecture approach – the difficulty of working with external systems. Dependencies
    on external systems cause problems in development. The solution leads to a nice
    design approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾推动六边形架构方法背后的驱动力——与外部系统工作的困难。对外部系统的依赖会导致开发中出现问题。解决方案导致了一种很好的设计方法。
- en: 'Let’s look at a simple way of handling external systems. The task of our user
    is to pull a report of this month’s sales from a database. We will write one piece
    of code that does exactly that. The software design looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理外部系统的一种简单方法。我们用户的任务是从一个数据库中拉取本月的销售报告。我们将编写一段代码来完成这项任务。软件设计如下：
- en: '![Figure 9.1 – One piece of code does everything](img/Figure_9.1_B18384.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 一段代码完成所有工作](img/Figure_9.1_B18384.jpg)'
- en: Figure 9.1 – One piece of code does everything
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 一段代码完成所有工作
- en: In this design, we have sales data stored in a database in the usual way. We
    write some code to pull the report on behalf of our user. It is a single piece
    of code that does the whole job as a single step. It will connect to the database,
    send a query, receive the results, do some processing, and format the results
    ready for the user to read.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，我们以通常的方式将销售数据存储在数据库中。我们编写一些代码代表用户拉取报告。这是一段完成整个工作的单一代码步骤。它将连接到数据库，发送查询，接收结果，进行一些处理，并将结果格式化，以便用户阅读。
- en: On the plus side, we know this style of coding works. It will achieve its aim
    of providing that sales report to the user. On the downside, the code combines
    three different responsibilities – accessing a database, performing logic, and
    formatting a report. It might mix up SQL statements to the database with `html5`
    tags to make a formatted report. As we saw in a previous chapter, this can make
    future code changes in one area ripple out and impact the other areas. Ideally,
    that should not happen. But the real challenge is writing a test for this one
    piece of code. We’ll need to parse and understand whatever format we send the
    report to the user in. We’ll also need to work directly with that database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，我们知道这种编码风格是有效的。它将实现其向用户提供销售报告的目标。缺点是，代码结合了三种不同的职责——访问数据库、执行逻辑和格式化报告。它可能会将数据库的SQL语句与`html5`标签混合，以生成格式化的报告。正如我们在前一章中看到的，这可能会使一个区域的未来代码更改波及到其他区域。理想情况下，这种情况不应该发生。但真正的挑战是为这段代码编写测试。我们需要解析和理解我们发送给用户报告的任何格式。我们还需要直接与该数据库交互。
- en: In the following subsections, we’ll review some wider challenges that external
    systems present to testing. These include environmental problems, accidental transactions,
    uncertain data, operating system calls, and third-party libraries.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子节中，我们将回顾一些外部系统对测试提出的更广泛挑战。这包括环境问题、意外事务、不确定数据、操作系统调用和第三方库。
- en: Environmental problems bring trouble
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境问题带来麻烦
- en: 'The environment that our software runs in often causes challenges. Suppose
    our code reads data from a database. Even if the code is correct, it might not
    be able to read that data, due to problems in the environment beyond our control.
    Such problems include the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们软件运行的软件环境常常带来挑战。假设我们的代码从数据库中读取数据。即使代码是正确的，由于我们无法控制的环境问题，它可能无法读取这些数据。以下是一些可能的问题：
- en: '**Network connection dropped**: Many reasons can cause this. Locally, a network
    cable is pulled out by mistake. Maybe the database is hosted over the internet
    somewhere, and our ISP has dropped the connection.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络连接中断**：许多原因可能导致这种情况。本地，可能是由于网络电缆被错误地拔出。也许数据库托管在互联网上的某个地方，我们的ISP已经断开了连接。'
- en: '**Power failures**: A power failure on the database server, or a local network
    switch is enough to put the database out of our reach.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电力故障**：数据库服务器或本地网络交换机的电力故障足以使数据库无法访问。'
- en: '**Equipment limits**: Maybe the database server itself has run out of disk
    space and cannot operate. Maybe the exact query we have written is hitting the
    database in a way that takes a long time to complete, perhaps due to missing indices.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备限制**：可能是数据库服务器本身已经用完了磁盘空间，无法运行。也许我们编写的确切查询以某种方式触发了数据库，导致完成时间过长，可能是由于缺少索引。'
- en: Whatever the cause, if our code cannot access the data in the database, it’s
    not going to work. As this is a possibility, writing a test for our report generation
    code is made much harder.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论原因是什么，如果我们的代码无法访问数据库中的数据，它将无法工作。由于这是一个可能性，为我们的报告生成代码编写测试变得更加困难。
- en: Even when our code can access the data in the database, it’s not that easy to
    work with in testing. Suppose we write a test that verifies that we can read the
    production database correctly, by reading a username. What username would we expect
    to read? We don’t know, because the test is not in control of what data gets added.
    The available usernames will be whatever names were added by real users. We could
    make the test add a known test username to the database – but then, we have just
    created a fake user that real users can interact with. This is not what we want
    at all.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的代码可以访问数据库中的数据，在测试中与之交互也并不容易。假设我们编写了一个测试，验证我们能否通过读取用户名来正确读取生产数据库，那么我们期望读取哪个用户名呢？我们不知道，因为测试并不控制要添加哪些数据。可用的用户名将是真实用户添加的任何名称。我们可以让测试向数据库添加一个已知的测试用户名——但这样，我们就创建了一个真实用户可以与之交互的虚假用户。这根本不是我们想要的。
- en: A database stores data, causing further problems for our tests. Suppose we write
    a test against a test database, which begins by writing a test username. If we
    have run this test before, the test username will already be stored in the database.
    Typically, the database will report a duplicate item error and the test will fail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库存储数据，这给我们的测试带来了更多问题。假设我们针对测试数据库编写了一个测试，该测试首先写入一个测试用户名。如果我们之前已经运行了这个测试，测试用户名将已经存储在数据库中。通常，数据库会报告重复项错误，测试将失败。
- en: Tests against databases need cleaning up. Any test data stored must be deleted
    after the tests have been completed. If we attempt to delete data after the test
    has succeeded, the deletion code may never run if the test fails. We could avoid
    this by always deleting the data before the test runs. Such tests will be slow
    to run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 需要清理针对数据库的测试。测试完成后必须删除存储的所有测试数据。如果我们尝试在测试成功后删除数据，如果测试失败，删除代码可能永远不会运行。我们可以通过在测试运行之前始终删除数据来避免这种情况。这样的测试将运行缓慢。
- en: Accidentally triggering real transactions from tests
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试意外触发真实交易
- en: When our code is limited to only accessing a production system, then every time
    we use that code, something will happen in production. The payment processor may
    issue charges. Real bank accounts may become debited. Alarms may be activated,
    causing real evacuations. In a famous example from Hawaii, a system test triggered
    a real text message saying Hawaii was under missile attack – which it wasn’t.
    This is serious stuff.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码仅限于访问生产系统时，那么每次我们使用该代码，生产系统中都会发生某些事情。支付处理器可能会发出费用。真实的银行账户可能会被扣除。警报可能会被激活，导致真正的疏散。在夏威夷的一个著名例子中，一个系统测试触发了一条真实的短信，说夏威夷正在遭受导弹袭击——但实际上并没有。这是非常严重的事情。
- en: Hawaii false missile attack warning
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 夏威夷误报导弹袭击警告
- en: For details on this example of testing going wrong, see [https://en.wikipedia.org/wiki/2018_Hawaii_false_missile_alert](https://en.wikipedia.org/wiki/2018_Hawaii_false_missile_alert).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关测试出错此例的详细信息，请参阅[https://en.wikipedia.org/wiki/2018_Hawaii_false_missile_alert](https://en.wikipedia.org/wiki/2018_Hawaii_false_missile_alert)。
- en: Accidental real transactions can result in real losses to a company. They could
    end up as losses to the 3Rs of a business – revenue, reputation, and retention.
    None of those are good. Our tests mustn’t accidentally trigger real consequences
    from production systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 意外触发真实交易可能导致公司遭受真实损失。它们可能导致业务的三R（收入、声誉和保留）损失。这些都不好。我们的测试必须不会意外触发来自生产系统的真实后果。
- en: What data should we expect?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该期待什么数据？
- en: In our sales report example, the biggest problem with writing a test is that
    we would need to know what the correct answer is to the monthly sales report in
    advance. How do we do that when we are connected to the production system? The
    answer will be whatever the sales report says it is. We have no other way of knowing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的销售报告示例中，编写测试的最大问题是，我们需要提前知道月度销售报告的正确答案。当我们连接到生产系统时，我们如何做到这一点？答案将是销售报告所说的那样。我们没有其他方式知道。
- en: The fact that we need the sales report code to be working correctly before we
    can test that the sales report code is working correctly is a big problem here!
    This is a circular dependency we cannot break.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够测试销售报告代码是否正常工作之前，必须确保销售报告代码能够正确工作，这是一个大问题！这是一个我们无法打破的循环依赖。
- en: Operating system calls and system time
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统调用和系统时间
- en: Sometimes, our code may need to make calls to the operating system to do its
    job. Perhaps it needs to delete all the files in a directory from time to time
    or it may be dependent on the system time. An example would be a log file cleanup
    utility, which runs every Monday at 02:00 A.M. The utility will delete every file
    in the `/``logfiles/` directory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的代码可能需要调用操作系统来完成其工作。也许它需要不时地删除目录中的所有文件，或者它可能依赖于系统时间。一个例子就是一个日志文件清理工具，它每周一凌晨2点运行。该工具将删除`/logfiles/`目录中的所有文件。
- en: Testing such a utility would be difficult. We would have to wait until 02:00
    A.M. on Monday and verify that all the log files have been deleted. While we could
    make this work, it isn’t very effective. It would be nice to find a better approach
    that allowed us to test anytime we liked, ideally without deleting any files.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 测试此类工具将是困难的。我们必须等到周一凌晨2点，并验证所有日志文件是否已被删除。虽然我们可以使这可行，但这并不非常有效。如果能找到一个更好的方法，允许我们在任何我们想测试的时候进行测试，理想情况下不需要删除任何文件，那就太好了。
- en: Challenges with third-party services
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方服务的挑战
- en: 'A common task in business software is to accept payment from a customer. For
    that, we inevitably use a third-party payment processor such as PayPal or Stripe,
    as two examples. In addition to the challenges of network connectivity, third-party
    APIs provide us with further challenges:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 商业软件中的常见任务是接受客户的付款。为此，我们不可避免地会使用第三方支付处理器，例如PayPal或Stripe，仅举两个例子。除了网络连接的挑战之外，第三方API还给我们带来了更多的挑战：
- en: '**Service downtime**: Many third-party APIs will have a period of scheduled
    maintenance where the service is unavailable for a time. That spells “test failed”
    for us.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务中断时间**：许多第三方API将有一段时间的预定维护，服务将暂时不可用。这对我们来说意味着“测试失败”。'
- en: '**API changes**: Suppose our code uses API version 1 and API version 2 is pushed
    live. Our code will still be using version 1 calls, which might no longer work
    on version 2 of the API. Now, that is considered rather bad practice – it’s called
    breaking a published interface – but it can and does happen. Worse, with our one
    piece of code, the version 2 changes might cause changes everywhere in our code.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API更改**：假设我们的代码使用API版本1，而API版本2已上线。我们的代码仍然会使用版本1的调用，这可能在API的版本2上不再有效。现在，这被认为是一种相当糟糕的做法——被称为破坏已发布的接口——但它确实会发生。更糟糕的是，由于我们的一小块代码，版本2的更改可能会在我们的代码的各个地方引起变化。'
- en: '**Slow responses**: If our code makes an API call to an external service, there
    is always a possibility that the response will come back later than expected by
    our code. Our code will fail in some way usually and cause tests to fail.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**慢响应**：如果我们的代码向外部服务发出API调用，总有可能响应会晚于我们的代码预期返回。我们的代码通常会以某种方式失败，并导致测试失败。'
- en: Plenty of challenges exist when we mix external services and a single monolithic
    piece of code, complicating both maintenance and testing. The question is what
    can we do about it? The next section looks at how the **Dependency Inversion Principle**
    can help us follow a design approach known as a hexagonal architecture, which
    makes external systems easier to deal with.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将外部服务和单一的大型代码块混合时，会存在许多挑战，这会复杂化维护和测试。问题是我们可以做什么？下一节将探讨**依赖倒置原则**如何帮助我们遵循一种称为六边形架构的设计方法，这使得处理外部系统变得更加容易。
- en: Dependency inversion to the rescue
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置来拯救
- en: In this section, we will review a design approach known as the hexagonal architecture,
    based on the SOLID principles we already know. Using this approach allows us to
    use TDD more effectively across more of our code base.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一种基于我们已知的SOLID原则的设计方法，即六边形架构。使用这种方法可以使我们在代码库的更大范围内更有效地使用TDD。
- en: We learned about the **Dependency Inversion Principle** previously in this book.
    We saw that it helps us isolate some code we wanted to test from the details of
    its collaborators. We noted that was useful for testing things that connected
    to external systems that were outside of our control. We saw how the single responsibility
    principle guided us into splitting up software into smaller, more focused tasks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中之前学习了**依赖倒置原则**。我们了解到它有助于我们将想要测试的某些代码与其合作者的细节隔离开来。我们注意到这对于测试连接到我们无法控制的外部系统的事物是有用的。我们看到了单一职责原则如何引导我们将软件拆分成更小、更专注的任务。
- en: 'Applying these ideas to our earlier sales reporting example, we would arrive
    at an improved design, as shown in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些想法应用于我们之前的销售报告示例，我们会得到一个改进的设计，如下面的图表所示：
- en: '![Figure 9.2 – Applying SOLID to our sales report](img/Figure_9.2_B18384.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 将SOLID应用于我们的销售报告](img/Figure_9.2_B18384.jpg)'
- en: Figure 9.2 – Applying SOLID to our sales report
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 将SOLID应用于我们的销售报告
- en: 'The preceding diagram shows how we have applied SOLID principles to splitting
    up our sales report code. We have used the single responsibility principle to
    break down the overall task into three separate tasks:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了我们将SOLID原则应用于拆分我们的销售报告代码的方式。我们使用了单一职责原则，将整体任务分解为三个单独的任务：
- en: Formatting the report
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化报告
- en: Calculating the sales total
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算销售总额
- en: Reading the sales data from the database
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中读取销售数据
- en: This already makes the application a little easier to work with. More importantly,
    we’ve isolated the code that calculates the sales total from both the user and
    the database. This calculation no longer directly accesses the database. It goes
    through another piece of code responsible for doing only that. Likewise, the calculation
    result isn’t directly formatted and sent to the user. Another piece of code is
    responsible for that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经使应用程序更容易使用。更重要的是，我们已经将计算销售总额的代码从用户和数据库中隔离出来。这个计算不再直接访问数据库。它通过另一段只负责这一点的代码进行。同样，计算结果也不再直接格式化并发送给用户。另一段代码负责这一点。
- en: 'We can apply the **Dependency Inversion Principle** here as well. By inverting
    the dependencies on the formatting and database access code, our calculated sales
    total is now free from knowing any of their details. We’ve made a significant
    breakthrough:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里应用**依赖倒置原则**。通过倒置对格式化和数据库访问代码的依赖，我们的计算销售总额现在不再需要了解它们的任何细节。我们取得了重大突破：
- en: The calculation code is now fully isolated from the database and formatting
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算代码现在完全与数据库和格式化隔离
- en: We can swap in any piece of code that can access any database
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以替换任何可以访问任何数据库的代码片段
- en: We can swap in any piece of code that can format a report
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以替换任何可以格式化报告的代码片段
- en: We can use test doubles in place of the formatting and database access code
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用测试替身代替格式化和数据库访问代码
- en: The biggest benefit is that we can swap in any piece of code that can access
    any database, without changing the calculation code. For example, we could change
    from a Postgres SQL database to a Mongo NoSQL database without changing the calculation
    code. We can use a test double for the database so that we can test the calculation
    code as a FIRST unit test. These are very significant advantages, not just in
    terms of TDD and testing, but also in terms of how our code is organized. Considering
    the one-piece sales report solution to this one, we have moved from pure writing
    code to software engineering. We’re thinking beyond just getting code to work
    and focusing on making code easy to work with. The next few subsections will look
    at how we can generalize this approach, resulting in the hexagonal architecture.
    We will understand how this approach delivers a logical organization of code that
    helps us apply TDD more effectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的好处是我们可以在不更改计算代码的情况下，替换任何可以访问任何数据库的代码片段。例如，我们可以从Postgres SQL数据库切换到Mongo NoSQL数据库，而不需要更改计算代码。我们可以使用数据库的测试替身，以便我们可以将计算代码作为一个**首次单元测试**来测试。这些优势非常显著，不仅在于TDD和测试方面，还在于我们代码的组织方式。考虑到这个单件销售报告解决方案，我们已经从纯代码编写过渡到软件工程。我们思考的不仅仅是让代码工作，而是让代码易于工作。接下来的几个小节将探讨我们如何将这种方法推广到六边形架构，我们将了解这种方法如何提供一种逻辑的代码组织，帮助我们更有效地应用TDD。
- en: Generalizing this approach to the hexagonal architecture
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将这种方法推广到六边形架构
- en: 'This combination of the single responsibility principle and dependency inversion
    seems to have brought us some benefits. Could we extend this approach to the entire
    application and get the same benefits? Could we find a way to separate all our
    application logic and data representations from the constraints of external influence?
    We most certainly can, and the general form of this design is shown in the following
    diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单一责任原则和依赖倒置的组合似乎给我们带来了一些好处。我们能否将这种方法扩展到整个应用程序并得到相同的好处？我们能否找到一种方法，将所有应用程序逻辑和数据表示从外部影响的约束中分离出来？我们当然可以，这种设计的一般形式如下所示：
- en: '![Figure 9.3 – Hexagonal architecture](img/Figure_9.3_B18384.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 六边形架构](img/Figure_9.3_B18384.jpg)'
- en: Figure 9.3 – Hexagonal architecture
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 六边形架构
- en: The preceding diagram shows what happens when we generalize the use of dependency
    inversion and single responsibility to an entire application. It is called the
    hexagonal architecture, also known as ports and adapters after the original term
    used by Alastair Cockburn, who first described this approach. The benefit is that
    it completely isolates the core logic of our application from the details of external
    systems. This helps us with testing that core logic. It also provides a reasonable
    template for a well-engineered design for our code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了当我们将依赖倒置和单一责任原则推广到整个应用程序时会发生什么。它被称为六边形架构，也称为端口和适配器，这是Alastair Cockburn最初描述这种方法时使用的术语。好处是它完全隔离了应用程序的核心逻辑与外部系统的细节。这有助于我们测试核心逻辑。它还为我们代码的精心设计提供了一个合理的模板。
- en: Overview of the hexagonal architecture’s components
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 六边形架构组件概述
- en: 'To provide us with this isolation of our core application logic, the hexagonal
    architecture divides the whole program into four spaces:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供我们核心应用程序逻辑的隔离，六边形架构将整个程序划分为四个空间：
- en: External systems, including web browsers, databases, and other computing services
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部系统，包括网络浏览器、数据库和其他计算服务
- en: Adapters implement the specific APIs required by the external systems
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器实现了外部系统所需的特定API
- en: Ports are the abstraction of what our application needs from the external system
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口是我们应用程序从外部系统需要的抽象
- en: The domain model contains our application logic, free of external system details
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型包含我们的应用程序逻辑，不包含外部系统的细节
- en: The central core of our application is the domain model, surrounded by the support
    it needs from external systems. It indirectly uses but is not defined by those
    external systems. Let’s walk through each component in the hexagonal architecture
    in more detail, to understand what each one is and is not responsible for.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的核心是领域模型，周围是它从外部系统需要的支持。它间接使用但不由这些外部系统定义。让我们更详细地了解六边形架构中的每个组件，以了解每个组件负责什么和什么不负责。
- en: External systems connect to adapters
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部系统连接到适配器
- en: External systems are all the things that live outside of our code base. They
    include things that the user directly interacts with, such as the web browser
    and the console application in the preceding diagram. They also include data stores,
    such as both the SQL database and the NoSQL database. Other examples of common
    external systems include desktop graphical user interfaces, filesystems, downstream
    web service APIs, and hardware device drivers. Most applications will need to
    interact with systems like these.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 外部系统是我们代码库之外的所有事物。它们包括用户直接与之交互的事物，例如前面图中的网络浏览器和控制台应用程序。它们还包括数据存储，如SQL数据库和NoSQL数据库。其他常见的系统示例包括桌面图形用户界面、文件系统、下游Web服务API和硬件设备驱动程序。大多数应用程序都需要与这些系统交互。
- en: In the hexagonal architecture, the core of our application code does not know
    any details about how the external systems are interacted with. The responsibility
    of communicating with external systems is given to a piece of code known as an
    adapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构中，我们应用程序代码的核心不知道任何关于如何与外部系统交互的细节。与外部系统通信的责任被赋予了一块被称为适配器的代码。
- en: 'As an example, the following diagram shows how a web browser would connect
    to our code via a REST adapter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图示展示了网络浏览器如何通过REST适配器连接到我们的代码：
- en: '![Figure 9.4 – Browser connecting to a REST adapter](img/Figure_9.4_B18384.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 浏览器连接到REST适配器](img/Figure_9.4_B18384.jpg)'
- en: Figure 9.4 – Browser connecting to a REST adapter
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 浏览器连接到REST适配器
- en: In the preceding diagram, we can see the web browser connecting to a REST adapter.
    This adapter understands HTTP requests and responses, which are the very core
    of the web. It also understands the JSON data format, often using libraries to
    convert the JSON data into some internal representation for our code. This adapter
    will also understand the specific protocol that we will have designed for our
    application’s REST API – the precise sequence of HTTP verbs, responses, status
    codes, and JSON-encoded payload data we come up with as an API.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到网络浏览器连接到一个REST适配器。这个适配器理解HTTP请求和响应，这是网络的根本。它还理解JSON数据格式，通常使用库将JSON数据转换为我们的代码的一些内部表示。这个适配器还将理解我们为应用程序的REST
    API设计的特定协议——我们作为API提出的精确的HTTP动词、响应、状态码和JSON编码的有效负载数据。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Adapters encapsulate all the knowledge our system needs to interact with an
    external system – and nothing else. This knowledge is defined by the external
    system’s specifications. Some of those may be designed by ourselves.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器封装了我们系统与外部系统交互所需的所有知识——没有其他知识。这种知识由外部系统的规范定义。其中一些可能是由我们自己设计的。
- en: Adapters have the single responsibility of knowing how to interact with an external
    system. If that external system changes its public interface, only our adapter
    will need to change.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器有单一的责任，即知道如何与外部系统交互。如果该外部系统更改其公共接口，只有我们的适配器需要更改。
- en: Adapters connect to ports
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器连接到端口
- en: 'Moving toward the domain model, adapters connect to ports. Ports are part of
    the domain model. They abstract away the details of the adapter’s intricate knowledge
    of its external system. Ports answer a slightly different question: what do we
    need that external system for? The ports use the **Dependency Inversion Principle**
    to isolate our domain code from knowing any details about the adapters. They are
    written purely in terms of our domain model:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 向领域模型迈进，适配器连接到端口。端口是领域模型的一部分。它们抽象掉了适配器对其外部系统复杂知识的细节。端口回答了一个稍微不同的问题：我们为什么需要这个外部系统？端口使用**依赖倒置原则**来隔离我们的领域代码，使其不知道任何关于适配器的细节。它们完全用我们的领域模型来编写：
- en: '![Figure 9.5 – Adapters connect to ports](img/Figure_9.5_B18384.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 适配器连接到端口](img/Figure_9.5_B18384.jpg)'
- en: Figure 9.5 – Adapters connect to ports
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 适配器连接到端口
- en: 'The REST adapter described previously encapsulates the details of running a
    REST API, using knowledge of HTTP and JSON. It connects to a commands port, which
    provides our abstraction of commands coming in from the web – or anywhere else,
    for that matter. Given our sales report example earlier, the commands port would
    include a technology-free way of requesting a sales report. In code, it might
    look as simple as this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的 REST 适配器封装了运行 REST API 的细节，使用了 HTTP 和 JSON 的知识。它连接到一个命令端口，为我们提供了从网络或其他地方传入命令的抽象。鉴于我们之前的销售报告示例，命令端口将包括一种无技术请求销售报告的方式。在代码中，它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code fragment features the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段具有以下特点：
- en: No references to `HttpServletRequest` or anything to do with HTTP
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有对 `HttpServletRequest` 或任何与 HTTP 相关的引用
- en: No references to JSON formats
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有对 JSON 格式的引用
- en: References to our domain model – `SalesReport` and `java.time.LocalDate`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的领域模型（`SalesReport` 和 `java.time.LocalDate`）的引用
- en: The `public` access modifier, so it can be called from the REST adapter
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 访问修饰符，因此可以从 REST 适配器调用'
- en: This interface is a port. It gives us a general-purpose way to get a sales report
    from our application. Referring to *Figure 9**.3*, we can see that the console
    adapter also connects to this port, providing the user with a command-line interface
    to our application. The reason is that while users can access our application
    using different kinds of external systems – the web and the command line – our
    application does the same thing in either case. It only supports one set of commands,
    no matter where those commands are requested from. Fetching a `SalesReport` object
    is just that, no matter which technology you request it from.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口是一个端口。它为我们提供了一个通用方法，可以从应用程序中获取销售报告。参照 *图 9**.3*，我们可以看到控制台适配器也连接到这个端口，为用户提供命令行界面访问我们的应用程序。原因是尽管用户可以使用不同类型的系统（如网页和命令行）访问我们的应用程序，但我们的应用程序在两种情况下都做同样的事情。它只支持一组命令，无论这些命令从哪里请求。获取
    `SalesReport` 对象就是这样，无论你从哪种技术请求它。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Ports provide a logical view of what our application needs from an external
    system, without constraining how those needs should be met technically.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 端口提供了对外部系统所需逻辑视图，而不限制如何从技术上满足这些需求。
- en: Ports are where we invert dependencies. Ports represent the reason our domain
    model needs those external systems. If the adapters represent the how, ports represent
    the why.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是我们反转依赖的地方。端口代表领域模型需要那些外部系统的原因。如果适配器代表“如何”，端口则代表“为什么”。
- en: Ports connect to our domain model
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口连接到我们的领域模型
- en: 'The final step in the chain is connecting to the domain model itself. This
    is where our application logic lives. Think of it as pure logic for the problem
    our application is solving. Because of the ports and adapters, the domain logic
    is unconstrained by details of external systems:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 链接到领域模型的最终步骤。这是我们的应用程序逻辑所在之处。把它想象成解决我们应用程序所面临问题的纯逻辑。由于端口和适配器，领域逻辑不受外部系统细节的限制：
- en: '![Figure 9.6 – Ports connect to the domain model](img/Figure_9.6_B18384.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 端口连接到领域模型](img/Figure_9.6_B18384.jpg)'
- en: Figure 9.6 – Ports connect to the domain model
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 端口连接到领域模型
- en: The domain model represents the things our users want to do, in code. Every
    user story is described by code here. Ideally, the code in this layer uses the
    language of the problem we are solving, instead of technology details. When we
    do this well, this code becomes storytelling – it describes actions our users
    care about in terms they have told us about. It uses their language – the language
    of our users – not obscure computer language.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型代表用户想要做的事情，在代码中。每个用户故事都由这里的代码描述。理想情况下，这一层的代码使用我们正在解决的问题的语言，而不是技术细节。当我们做得很好时，这段代码就变成了故事讲述——它用用户告诉我们的术语描述用户关心的动作。它使用他们的语言——用户的语言——而不是晦涩的计算机语言。
- en: The domain model can contain code written in any paradigm. It might use **functional
    programming** (**FP**) ideas. It may even use **object-oriented programming**
    (**OOP**) ideas. It might be procedural. It might even use an off-the-shelf library
    that we configure declaratively. My current style is to use OOP for the overall
    structure and organization of a program, then use FP ideas inside the object methods
    to implement them. It makes no difference to either the hexagonal architecture
    or TDD how we implement this domain model. Whatever way suits your coding style
    is just fine here, so long as you use the ideas of ports and adapters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型可以包含用任何范式编写的代码。它可能使用**函数式编程**（**FP**）的思想。它甚至可能使用**面向对象编程**（**OOP**）的思想。它可能是过程式的。它甚至可能使用我们通过声明性配置的现成库。我目前的风格是使用面向对象来构建程序的整体结构和组织，然后在对象方法内部使用函数式编程思想来实现它们。这对六边形架构或TDD来说都没有影响。只要使用端口和适配器的思想，任何适合你的编码风格都是可以的。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The domain model contains code that describes how the user’s problem is being
    solved. This is the essential logic of our application that creates business value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型包含描述用户问题如何被解决的代码。这是我们应用程序的必要逻辑，它创造了商业价值。
- en: At the center of the entire application is the domain model. It contains the
    logic that brings the user’s stories to life.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序的中心是领域模型。它包含将用户的用例故事变为现实生活的逻辑。
- en: The golden rule – the domain never connects directly to adapters
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金规则——领域从不直接连接到适配器
- en: 'To preserve the benefits of isolating the domain model from adapters and external
    systems, we follow one simple rule: the domain model never connects directly to
    any of the adapters. This is always done through a port.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留将领域模型从适配器和外部系统隔离的好处，我们遵循一条简单的规则：领域模型从不直接连接到任何适配器。这始终是通过端口来完成的。
- en: 'When our code follows this design approach, it is straightforward to check
    whether we’ve got the ports and adapters split right. We can make two high-level
    structural decisions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码遵循这种设计方法时，检查我们是否正确地分割了端口和适配器就变得简单直接。我们可以做出两个高级结构决策：
- en: The domain model lives in a `domain` package (and sub packages)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型位于`domain`包（及其子包）中
- en: The adapters live in an `adapters` package (and sub packages)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器位于`adapters`包（及其子包）中
- en: We can analyze the code to check that anything in the `domain` package contains
    no import statements from the `adapters` package. Import checks can be done visually
    in code reviews or pairing/mobbing. Static analysis tools such as SonarQube can
    automate import checks as part of the build pipeline.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分析代码来检查`domain`包中是否没有任何从`adapters`包导入的语句。导入检查可以在代码审查或结对/群体编程中进行。像SonarQube这样的静态分析工具可以将导入检查自动化，作为构建管道的一部分。
- en: The golden rules of the hexagonal architecture
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构的金规则
- en: The domain model never connects directly to anything in the adapter layer so
    that our application logic does not depend on details of external systems.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型从不直接连接到适配器层中的任何内容，这样我们的应用程序逻辑就不依赖于外部系统的细节。
- en: The adapters connect to ports so that code connecting to external systems is
    isolated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器连接到端口，以便将连接到外部系统的代码隔离。
- en: Ports are part of the domain model to create abstractions of external systems.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是领域模型的一部分，用于创建外部系统的抽象。
- en: The domain model and the adapters depend on the ports only. This is dependency
    inversion at work.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型和适配器只依赖于端口。这是依赖倒置在起作用。
- en: These simple rules keep our design in line and preserve the isolation of the
    domain model.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的规则使我们的设计保持一致，并保留了领域模型的隔离性。
- en: Why the hexagon shape?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么是六边形形状？
- en: The idea behind the hexagon shape used in the diagram is that each face represents
    one external system. In terms of a graphical representation of a design, having
    up to six external systems represented is usually sufficient. The idea of the
    inner and outer hexagons to represent the domain model and adapter layer shows
    graphically how the domain model is the core of our application and that it is
    isolated from external systems by the ports and adapter layer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图中使用的六边形形状背后的思想是，每个面代表一个外部系统。在设计的图形表示中，通常表示多达六个外部系统就足够了。内六边形和外六边形代表领域模型和适配器层，图形化地显示了领域模型是如何成为我们应用程序的核心，以及它是如何通过端口和适配器层与外部系统隔离的。
- en: The critical idea behind the hexagonal architecture is the ports and adapters
    technique. The actual number of sides depends on how many external systems there
    are. The number of those is not important.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 六角架构背后的关键思想是端口和适配器技术。实际边数取决于有多少外部系统。这些数量并不重要。
- en: In this section, we introduced the hexagonal architecture and the benefits it
    provides, and provided a general overview of how all the essential pieces fit
    together. Let’s turn to the next section and look specifically at the decisions
    we need to make to abstract out an external system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了六角架构及其提供的优势，并提供了所有基本组成部分如何组合的一般概述。让我们转向下一节，具体看看我们需要做出哪些决策来抽象外部系统。
- en: Abstracting out the external system
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象外部系统
- en: 'In this section, we will consider some of the decisions we need to make when
    applying the hexagonal architecture approach. We’ll take a step-by-step approach
    to handling external systems, where we will first decide what the domain model
    needs, then work out the right abstractions that hide their technical details.
    We will consider two common external systems: web requests and database access.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑在应用六角架构方法时需要做出的某些决策。我们将逐步处理外部系统，首先决定领域模型需要什么，然后制定合适的抽象来隐藏其技术细节。我们将考虑两个常见的外部系统：Web请求和数据库访问。
- en: Deciding what our domain model needs
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定我们的领域模型需要什么
- en: The place to begin our design is with our domain model. We need to devise a
    suitable port for our domain model to interact with. This port has to be free
    from any details of our external system, and at the same time, it must answer
    the question of what our application needs this system for. We are creating an
    abstraction.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计开始的地方是领域模型。我们需要为领域模型设计一个合适的端口以与之交互。这个端口必须摆脱任何外部系统的细节，同时，它必须回答我们的应用程序为什么需要这个系统的问题。我们正在创建一个抽象。
- en: A good way to think about abstractions is to think about what would stay the
    same if we changed how we performed a task. Suppose we want to eat warm soup for
    lunch. We might warm it in a pan on the stove or perhaps warm it in the microwave.
    No matter how we choose to do it, what we are doing stays the same. We are warming
    the soup and that is the abstraction we’re looking for.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 思考抽象的一个好方法是想如果我们改变执行任务的方式，什么会保持不变。假设我们想在午餐时吃热汤。我们可能在炉灶上的平底锅里加热，或者可能在微波炉里加热。无论我们选择哪种方式，我们正在做的事情保持不变。我们在加热汤，这就是我们寻找的抽象。
- en: We don’t often warm soup in software systems unless we are building an automated
    soup vending machine. But there are several common kinds of abstractions we will
    be using. This is because common kinds of external systems are used when building
    a typical web application. The first and most obvious is the connection to the
    web itself. In most applications, we will encounter some kind of data store, typically
    a third-party database system. For many applications, we will also be calling
    out to another web service. In turn, this service may call others in a fleet of
    services, all internal to our company. Another typical web service call is to
    a third-party web service provider, such as a credit card payment processor, as
    an example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在软件系统中很少加热汤，除非我们正在构建一个自动售汤机。但我们将使用几种常见的抽象。这是因为当构建典型的Web应用程序时，会使用一些常见的外部系统。第一个也是最明显的是与Web本身的连接。在大多数应用程序中，我们都会遇到某种类型的数据存储，通常是第三方数据库系统。对于许多应用程序，我们还会调用另一个Web服务。反过来，这个服务可能会调用我们公司内部的一群服务。另一个典型的Web服务调用是调用第三方Web服务提供商，例如，作为一个信用卡支付处理器的例子。
- en: Let’s look at ways of abstracting these common external systems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何抽象这些常见的外部系统。
- en: Abstracting web requests and responses
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象Web请求和响应
- en: Our application will respond to HTTP requests and responses. The port we need
    to design represents the request and the response in terms of our domain model,
    stripping away the web technology.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将响应HTTP请求和响应。我们需要设计的端口代表领域模型中的请求和响应，去除Web技术。
- en: 'Our sales report example could introduce these ideas as two simple domain objects.
    These requests can be represented by a `RequestSalesReport` class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的销售额报告示例可以作为两个简单的领域对象引入这些概念。这些请求可以通过一个`RequestSalesReport`类来表示：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we can see the critical pieces of our domain model of the request:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们请求领域模型的关键部分：
- en: What we are requesting – that is, a sales report, captured in the class name
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们请求的内容——即销售报告，体现在类名中
- en: The parameters of that request – that is, the start and end dates of the reporting
    period
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个请求的参数——即报告期的开始和结束日期
- en: 'We can see how the response is represented:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到响应是如何表示的：
- en: The `SalesReport` class will contain the raw information requested
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SalesReport` 类将包含所需的基本信息'
- en: 'We can also see what is not present:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到什么没有包含：
- en: The data formats used in the web request
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络请求中使用的数据格式
- en: HTTP status codes, such as 200 OK
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP状态码，例如200 OK
- en: '`HTTPServletRequest` and `HttpServletResponse` or equivalent framework objects'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPServletRequest` 和 `HttpServletResponse` 或等效的框架对象'
- en: This is a pure domain model representation of a request for a sales report between
    two dates. There is no hint of this having come from the web, a fact that is very
    useful as we can request it from other input sources, such as a desktop GUI or
    a command line. Even better, we can create these domain model objects very easily
    in a unit test.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个纯粹的业务模型表示，用于在两个日期之间请求销售报告。没有任何迹象表明它是从网络上来的，这是一个非常有用的事实，因为我们可以从其他输入源请求它，例如桌面GUI或命令行。更好的是，我们可以在单元测试中非常容易地创建这些业务模型对象。
- en: The preceding example shows an object-oriented, tell-don’t-ask approach. We
    could just as easily choose an FP approach. If we did, we would represent the
    request and response as pure data structures. The record facility that was added
    to Java 17 is well suited to representing such data structures. What’s important
    is that the request and response are written purely in domain model terms – nothing
    of the web technology should be present.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了面向对象、告知而非询问的方法。我们同样可以选择函数式编程（FP）方法。如果我们这样做，我们会将请求和响应表示为纯数据结构。Java 17中添加的记录功能非常适合表示此类数据结构。重要的是，请求和响应应完全用业务模型术语编写——不应该包含任何网络技术。
- en: Abstracting the database
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象数据库
- en: Without data, most applications aren’t particularly useful. Without data storage,
    they become rather forgetful of the data we supply. Accessing data stores such
    as relational databases and NoSQL databases is a common task in web application
    development.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数据，大多数应用程序并不特别有用。没有数据存储，它们会变得相当健忘，忘记我们提供的数据。访问数据存储，如关系数据库和NoSQL数据库，是网络应用程序开发中的常见任务。
- en: In a hexagonal architecture, we start by designing the port that the domain
    model will interact with, again in pure domain terms. The way to create a database
    abstraction is to think about what data needs storing and not how it will be stored.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构中，我们首先设计业务模型将与之交互的端口，再次在纯业务术语中。创建数据库抽象的方法是考虑需要存储什么数据，而不是如何存储数据。
- en: 'A database port has two components:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库端口有两个组成部分：
- en: An interface to invert the dependency on the database.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口来反转对数据库的依赖。
- en: The interface is often known as a repository. It has also been termed a data
    access object. Whatever the name, it has the job of isolating the domain model
    from any part of our database and its access technology.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口通常被称为存储库。它也被称作数据访问对象。无论名称如何，它的任务是隔离业务模型与数据库的任何部分及其访问技术。
- en: Value objects representing the data itself, in domain model terms.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用业务模型术语表示数据本身的值对象。
- en: A value object exists to transfer data from place to place. Two value objects
    that each hold the same data values are considered equal. They are ideal for transferring
    data between the database and our code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 存在的值对象用于在各个地方传输数据。两个包含相同数据值的值对象被认为是相等的。它们非常适合在数据库和我们的代码之间传输数据。
- en: 'Returning to our sales report example, one possible design for our repository
    would be this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的销售报告示例，我们仓库的一个可能的设计如下：
- en: '[PRE2]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have a method called `allWithinDateRange()` that allows us to fetch
    a set of individual sales transactions falling within a particular date range.
    The data is returned as `java.util.List` of simple `Sale` value objects. These
    are fully featured domain model objects. They may well have methods on them that
    perform some of the critical application logic. They may be little more than basic
    data structures, perhaps using a Java 17 `record` structure. This choice is part
    of our job in deciding what a well-engineered design looks like in our specific
    case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为 `allWithinDateRange()` 的方法，允许我们获取特定日期范围内的一系列单独的销售交易。数据作为 `java.util.List`
    的简单 `Sale` 值对象返回。这些是功能齐全的业务模型对象。它们可能包含执行某些关键应用逻辑的方法。它们可能只是基本的数据结构，可能使用Java 17的
    `record` 结构。这种选择是我们决定在特定情况下良好设计的外观的一部分。
- en: 'Again, we can see what is not present:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以看到什么没有包含：
- en: Database connection strings
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接字符串
- en: '`JDBC` or `JPA` API details – the standard Java Database Connectivity library'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JDBC`或`JPA` API细节——标准的Java数据库连接库'
- en: '`SQL` queries (or NoSQL queries)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQL`查询（或NoSQL查询）'
- en: Database schema and table names
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式和表名
- en: Database stored procedure details
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库存储过程细节
- en: Our repository designs focus on what our domain model needs our database to
    provide but does not constrain how it provides. As a result, some interesting
    decisions have to be taken in designing our repository, concerning how much work
    we put into the database and how much we do in the domain model itself. Examples
    of this include deciding whether we will write a complex query in the database
    adapter, or whether we will write simpler ones and perform additional work in
    the domain model. Likewise, will we make use of stored procedures in the database?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据存储库设计侧重于我们的领域模型需要数据库提供的内容，但并不限制其提供方式。因此，在设计我们的存储库时，我们必须做出一些有趣的决策，关于我们在数据库中投入多少工作量，以及我们在领域模型本身中做多少工作。这包括决定我们是否会在数据库适配器中编写复杂的查询，或者是否编写更简单的查询并在领域模型中执行额外的工作。同样，我们是否会使用数据库中的存储过程？
- en: Whatever trade-offs we decide in these decisions, once again, the database adapter
    is where all those decisions reside. The adapter is where we see the database
    connection strings, query strings, table names, and so on. The adapter encapsulates
    the design details of our data schema and database technology.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '无论我们在这类决策中做出何种权衡，数据库适配器都是所有这些决策的所在地。适配器是我们看到数据库连接字符串、查询字符串、表名等地方。适配器封装了我们的数据模式设计细节和数据库技术。 '
- en: Abstracting calls to web services
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对网络服务的调用抽象
- en: Making calls to other web services is a frequent development task. Examples
    include calls to payment processors and address lookup services. Sometimes, these
    are third-party external services, and sometimes, they live inside our web service
    fleet. Either way, they generally require some HTTP calls to be made from our
    application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 调用其他网络服务是一个常见的发展任务。这包括对支付处理器和地址查找服务的调用。有时，这些是第三方外部服务，有时它们存在于我们的网络服务舰队中。无论如何，它们通常需要从我们的应用程序中发出一些HTTP调用。
- en: Abstracting these calls proceeds along similar lines to abstracting the database.
    Our port is made up of an interface that inverts the dependency on the web service
    we are calling, and some value objects that transfer data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用的抽象过程与抽象数据库类似。我们的端口由一个接口组成，它反转了对我们正在调用的网络服务的依赖，以及一些用于传输数据的价值对象。
- en: 'An example of abstracting a call to a mapping API such as Google Maps, for
    example, might look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，抽象对映射API的调用，如Google Maps，可能看起来像这样：
- en: '[PRE3]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have an interface representing `MappingService` as a whole. We’ve added a
    method to add a review of a particular location on whichever service provider
    we end up using. We’re using `GeographicLocation` to represent a place, defined
    in our terms. It may well have a latitude and longitude pair in it or it may be
    based on postal code. That’s another design decision. Again, we see no sign of
    the underlying map service or its API details. That code lives in the adapter,
    which would connect to the real external mapping web service.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个接口代表整个`MappingService`。我们添加了一个方法，可以在我们最终使用的任何服务提供商上添加特定位置的评论。我们使用`GeographicLocation`来表示一个地方，按照我们的定义。它可能包含一对纬度和经度，或者可能基于邮政编码。这是另一个设计决策。同样，我们没有看到底层地图服务或其API细节的任何迹象。这段代码位于适配器中，它会连接到真正的外部映射网络服务。
- en: This abstraction offers us benefits in being able to use a test double for that
    external service and being able to change service providers in the future. You
    never know when an external service might shut down or become too costly to use.
    It’s nice to keep our options open by using the hexagonal architecture.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象使我们能够使用测试替身来处理该外部服务，并且能够在未来更改服务提供商。你永远不知道一个外部服务何时会关闭或变得过于昂贵而无法使用。使用六边形架构来保持我们的选择是件好事。
- en: This section has presented some ideas for the most common tasks in working with
    external systems in a hexagonal architecture. In the next section, we’ll discuss
    general approaches to writing code in the domain model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提出了一些在六边形架构中处理外部系统最常见任务的思路。在下一节中，我们将讨论在领域模型中编写代码的一般方法。
- en: Writing the domain code
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写领域代码
- en: In this section, we will look at some of the things we need to think about as
    we write the code for our domain model. We’ll cover what kinds of libraries we
    should and should not use in the domain model, how we deal with application configuration
    and initialization, and we’ll also think about what impact popular frameworks
    have.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨我们在编写领域模型代码时需要考虑的一些事情。我们将涵盖在领域模型中我们应该使用和不应该使用哪些类型的库，我们如何处理应用程序配置和初始化，我们还将思考流行框架的影响。
- en: Deciding what should be in our domain model
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定我们的领域模型中应该包含什么
- en: Our domain model is the very core of our application and the hexagonal architecture
    puts it up front and center. A good domain model is written using the language
    of our users’ problem domain; that’s where the name comes from. We should see
    the names of program elements that our users would recognize. We should recognize
    the problem being solved over and above the mechanisms we are using to solve it.
    Ideally, we will see terms from our user stories being used in our domain model.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域模型是应用程序的核心，六边形架构将其置于最前沿和中心位置。一个好的领域模型是用用户问题域的语言编写的；这就是名字的由来。我们应该看到用户会认识到的程序元素的名字。我们应该认识到我们正在解决的问题，而不仅仅是解决它的机制。理想情况下，我们将看到用户故事中的术语在我们的领域模型中被使用。
- en: Applying the hexagonal architecture, we choose our domain model to be independent
    of those things that are not essential to solving the problem. That’s why external
    systems are isolated. We may initially think that creating a sales report means
    that we must read a file and we must create an HTML document. But that’s not the
    essential heart of the problem. We simply need to get sales data from somewhere,
    perform some calculations to get totals for our report, then format it somehow.
    The somewhere and somehow can change, without affecting the essence of our solution.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应用六边形架构，我们选择我们的领域模型独立于那些对解决问题不是本质的东西。这就是为什么外部系统是隔离的。我们最初可能会认为创建销售报告意味着我们必须读取文件，我们必须创建一个HTML文档。但这并不是问题的核心。我们只需要从某个地方获取销售数据，进行一些计算以获取报告的总数，然后以某种方式格式化它。某个地方和某种方式可以改变，而不会影响我们解决方案的本质。
- en: Bearing this constraint in mind, we can take any standard analysis and design
    approach. We are free to choose objects or decompose them into functions as we
    normally do. We only have to preserve that distinction between the essence of
    the problem and the implementation details.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个限制，我们可以采取任何标准的分析和设计方法。我们可以自由选择对象或像通常那样将它们分解成函数。我们只需要保留问题本质和实现细节之间的区别。
- en: We need to exercise judgment in these decisions. In our sales report example,
    the source of the sales data is of no consequence. As a counter-example, suppose
    we are making a linter for our Java program files – it’s quite reasonable to have
    the concept of files represented directly in our domain model. This problem domain
    is all about working with Java files, so we should make that clear. We may still
    decouple the domain model of a file from the OS-specific details of reading and
    writing it, but the concept would be in the domain model.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些决策中，我们需要运用判断力。在我们的销售报告示例中，销售数据的来源无关紧要。作为一个反例，假设我们正在为我们的Java程序文件创建一个代码检查器——在领域模型中直接表示文件的概念是相当合理的。这个问题域完全是关于处理Java文件，所以我们应该明确这一点。我们仍然可以将文件领域模型与读取和写入它的特定于操作系统的细节解耦，但这个概念将包含在领域模型中。
- en: Using libraries and frameworks in the domain model
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在领域模型中使用库和框架
- en: The domain model can use any pre-written library or framework to help do its
    job. Popular libraries such as Apache Commons or the Java Standard Runtime library
    generally present no problems here. However, we need to be aware of frameworks
    that bind us to the world of external systems and our adapter layer. We need to
    invert dependencies on those frameworks, leaving them to be just an implementation
    detail of the adapter layer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型可以使用任何预先编写的库或框架来帮助完成其工作。像Apache Commons或Java标准运行时库这样的流行库通常在这里不会引起问题。然而，我们需要意识到那些将我们绑定到外部系统和我们适配器层的框架。我们需要反转对这些框架的依赖，让它们只是适配器层的一个实现细节。
- en: An example might be the `@RestController` annotation of Spring Boot. It looks
    like pure domain code at first sight, but it ties the class tightly to generated
    code that is specific to the web adapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是Spring Boot的`@RestController`注解。乍一看，它看起来像是纯领域代码，但它将类紧密地绑定到特定于Web适配器的生成代码。
- en: Deciding on a programming approach
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定编程方法
- en: 'The domain model can be written using any programming paradigm. This flexibility
    means that we will need to decide on which approach to use. This is never a purely
    technical decision, like with so many things in software. We should consider the
    following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型可以使用任何编程范式来编写。这种灵活性意味着我们需要决定使用哪种方法。这从来不是一个纯粹的技术决策，就像软件中的许多事情一样。我们应该考虑以下因素：
- en: '**Existing team skills and preferences**: What paradigm does the team know
    best? Which paradigm would they like to use, given the chance?'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现有团队技能和偏好**：团队最擅长哪种范式？如果有机会，他们希望使用哪种范式？'
- en: '**Existing libraries, frameworks, and code bases**: If we are going to be using
    pre-written code – and let’s face it, we almost certainly will – then what paradigm
    would best suit that code?'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现有库、框架和代码库**：如果我们将要使用预写的代码——让我们面对现实，我们几乎肯定会这样做——那么哪种范式最适合那代码？'
- en: '**Style guides and other code mandates**: Are we working with an existing style
    guide or paradigm? If we are being paid for our work – or we are contributing
    to an existing open source project – we will need to adopt the paradigm set out
    for us.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风格指南和其他代码规范**：我们是否在与现有的风格指南或范式合作？如果我们为我们的工作付费——或者我们正在为现有的开源项目做出贡献——我们需要采用为我们设定的范式。'
- en: The good news is that whatever paradigm we choose, we will be able to write
    our domain model successfully. While the code may look different, equivalent functionality
    can be written using any of the paradigms.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，无论我们选择哪种范式，我们都能够成功地编写领域模型。虽然代码可能看起来不同，但可以使用任何范式编写等效的功能。
- en: Substituting test doubles for external systems
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用测试替身替换外部系统
- en: 'In this section, we’ll discuss one of the biggest advantages that the hexagonal
    architecture brings to TDD: high testability. It also brings some workflow advantages.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论六边形架构为TDD带来的最大优势之一：高可测试性。它还带来了一些工作流程优势。
- en: Replacing the adapters with test doubles
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用测试替身替换适配器
- en: 'The key advantage the hexagonal architecture brings to TDD is that it is trivially
    easy to replace all the adapters with test doubles, giving us the ability to test
    the entire domain model with FIRST unit tests. We can test the entire application
    core logic without test environments, test databases, or HTTP tools such as Postman
    or curl – just fast, repeatable unit tests. Our testing setup looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构为TDD带来的关键优势是，替换所有适配器为测试替身非常容易，这使我们能够使用FIRST单元测试来测试整个领域模型。我们可以测试整个应用程序核心逻辑，而无需测试环境、测试数据库或Postman或curl等HTTP工具——只需快速、可重复的单元测试。我们的测试设置如下所示：
- en: '![Figure 9.7 – Testing the domain model](img/Figure_9.7_B18384.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 测试领域模型](img/Figure_9.7_B18384.jpg)'
- en: Figure 9.7 – Testing the domain model
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 测试领域模型
- en: We can see that all the adapters have been replaced by test doubles, completely
    freeing us from our environment of external systems. Unit tests can now cover
    the whole domain model, reducing the need for integration tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有适配器都已替换为测试替身，完全使我们摆脱了外部系统的环境。单元测试现在可以覆盖整个领域模型，减少了对集成测试的需求。
- en: 'We gain several benefits by doing this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们获得几个好处：
- en: '**We can write TDD tests first with ease**: There’s no friction in writing
    a simple test double that lives entirely in memory and has no dependencies on
    the test environment.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们可以轻松地首先编写 TDD 测试**：编写一个完全存在于内存中且不依赖于测试环境的简单测试替身没有任何摩擦。'
- en: '**We gain FIRST unit test benefits**: Our tests run very fast indeed and are
    repeatable. Typically, testing an entire domain model takes the order of seconds,
    not hours. The tests will repeatably pass or fail, meaning we are never wondering
    whether a build failure was due to a flaky integration test failure.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们获得了 FIRST 单元测试的好处**：我们的测试确实非常快，并且是可重复的。通常，测试整个领域模型只需要几秒钟，而不是几个小时。测试将可重复地通过或失败，这意味着我们永远不会怀疑构建失败是否是由于不可靠的集成测试失败。'
- en: '**It unlocks our team**: We can do useful work building the core logic of our
    system, without having to wait for test environments to be designed and built.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它释放了我们的团队**：我们可以构建系统核心逻辑的有用工作，而无需等待测试环境的设计和构建。'
- en: The techniques for creating the test doubles were outlined in [*Chapter 8*](B18384_08.xhtml#_idTextAnchor149),
    *Test Doubles – Stubs and Mocks*. There is nothing new required in terms of implementing
    these doubles.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 8 章*](B18384_08.xhtml#_idTextAnchor149)“测试替身 – 模拟和存根”中概述了创建测试替身的技术。在实现这些替身方面不需要任何新的要求。
- en: One consequence of being able to test the whole domain model is that we can
    apply TDD and FIRST unit tests to much larger program units. The next section
    discusses what that means for us.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 能够测试整个领域模型的一个后果是，我们可以将TDD和FIRST单元测试应用于更大的程序单元。下一节将讨论这对我们意味着什么。
- en: Unit testing bigger units
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试更大的单元
- en: The previous section introduced the idea of surrounding our domain model with
    test doubles for every port. This gives us some interesting opportunities to discuss
    in this section. We can test units that are as large as a user story.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节介绍了围绕我们的领域模型为每个端口使用测试替身的想法。这为我们提供了在本节中讨论的一些有趣的机会。我们可以测试与用户故事一样大的单元。
- en: We’re familiar with unit tests as being things that test in the small. There’s
    a good chance you’ll have heard somebody say that a unit test should only ever
    apply to a single function, or that every class should have one unit test for
    every method. We’ve already seen how that’s not the best way to use unit tests.
    Tests like those miss out on some advantages. We are better served by thinking
    of tests as covering behavior instead.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉单元测试作为测试小规模事物。有很大可能性你听说过有人说单元测试应该只应用于单一函数，或者每个类应该为每个方法有一个单元测试。我们已经看到那种方式并不是使用单元测试的最佳方式。像那样的测试会错过一些优势。我们更倾向于将测试视为覆盖行为。
- en: The combined approach of designing with the hexagonal architecture and testing
    behaviors instead of implementation details leads to an interesting system layering.
    Instead of having traditional layers, as we might do in a three-tier architecture,
    we have circles of increasingly higher-level behavior. Inside our domain model,
    we will find those tests-in-the-small. But as we move outward, toward the adapter
    layer, we will find bigger units of behavior.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用六边形架构进行设计和测试行为而不是实现细节的联合方法导致了一个有趣的结构分层。而不是像在三层架构中那样有传统层，我们有越来越高层次行为的圆圈。在我们的领域模型内部，我们将找到那些小规模测试。但随着我们向外移动，向适配器层移动，我们将找到更大的行为单元。
- en: Unit testing entire user stories
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试整个用户故事
- en: 'The ports in the domain model form a natural high-level boundary of the domain
    model. If we review what we’ve learned in this chapter, we’ll see that this boundary
    consists of the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型中的端口构成了领域模型的自然高级边界。如果我们回顾本章学到的内容，我们会看到这个边界由以下内容组成：
- en: The essence of requests from users
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户请求的本质
- en: The essence of a response from our application
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序响应的本质
- en: The essence of how data needs storing and accessing
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据需要存储和访问的本质
- en: All using technology-free code
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有使用无技术代码
- en: This layer is the essence of what our application does, free from the details
    of how it does it. It is nothing less than the original user stories themselves.
    The most significant thing about this domain model is that we can write FIRST
    unit tests against it. We have all we need to replace difficult-to-test external
    systems with simple test doubles. We can write unit tests that cover entire user
    stories, confirming that our core logic is correct.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层是我们应用程序本质的体现，不受其如何做的细节影响。这不仅仅是原始用户故事本身。这个领域模型最显著的事情是我们可以针对它编写FIRST单元测试。我们有所有需要用简单的测试替身替换难以测试的外部系统的工具。我们可以编写覆盖整个用户故事的单元测试，以确认我们的核心逻辑是正确的。
- en: Faster, more reliable testing
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更快、更可靠的测试
- en: Traditionally, testing user stories involved slower integration tests in a test
    environment. The hexagonal architecture enables unit tests to replace some of
    these integration tests, speeding up our builds and providing greater repeatability
    of our testing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，测试用户故事涉及在测试环境中进行的较慢的集成测试。六边形架构使得单元测试可以替代一些这些集成测试，加快我们的构建速度，并提高测试的可重复性。
- en: 'We can now test-drive at three granularities against our domain model:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在领域模型上以三个粒度进行测试驱动：
- en: Against a single method or function
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单一方法或函数相反
- en: Against the public behaviors of a class and any collaborators it has
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与类的公共行为及其任何协作者相反
- en: Against the core logic of an entire user story
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与整个用户故事的核心逻辑相反
- en: 'This is a big benefit of the hexagonal architecture. The isolation from external
    services has the effect of pushing the essential logic of a user story into the
    domain model, where it interacts with ports. As we’ve seen, those ports – by design
    – are trivially easy to write test doubles for. It’s worth restating the key benefits
    of FIRST unit tests:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是六边形架构的一个大好处。外部服务的隔离效果是将用户故事的基本逻辑推入领域模型，在那里它与端口交互。正如我们所看到的，那些端口——按照设计——非常容易编写测试替身。重申FIRST单元测试的关键好处是值得的：
- en: They are very fast, so testing our user stories will be very fast
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常快，所以测试我们的用户故事将会非常快
- en: They are highly repeatable, so we can trust test passes and failures
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们高度可重复，所以我们可以信任测试的通过和失败
- en: As we cover wide areas of functionality with unit tests, we blur the line between
    integration and unit testing. We remove friction from developers testing more
    of the user stories by making that testing easier. Using more unit tests improves
    build times, as the tests run quickly and give reliable pass/fail results. Fewer
    integration tests are needed, which is good as they run more slowly and are more
    prone to incorrect results.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过单元测试覆盖广泛的功能区域，我们模糊了集成测试和单元测试之间的界限。通过使测试更容易，我们减少了开发者测试更多用户故事时的摩擦。使用更多的单元测试可以提高构建时间，因为测试运行得快，并且给出可靠的通过/失败结果。需要的集成测试更少，这是好事，因为它们运行得更慢，更容易出现错误结果。
- en: In the next section, we’ll apply what we’ve learned to our Wordz application.
    We will write a port that abstracts out the details of fetching a word for our
    users to guess.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把所学知识应用到Wordz应用程序中。我们将编写一个端口，抽象出为用户猜测单词的检索细节。
- en: Wordz – abstracting the database
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wordz – 抽象数据库
- en: In this section, we will apply what we’ve learned to our Wordz application and
    create a port suitable for fetching the words to present to a user. We will write
    the adapters and integration tests in [*Chapter 14*](B18384_14.xhtml#_idTextAnchor293),
    *Driving the* *Database Layer*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把所学知识应用到Wordz应用程序中，并创建一个适合检索单词以展示给用户的端口。我们将在[*第14章*](B18384_14.xhtml#_idTextAnchor293)，“驱动数据库层”中编写适配器和集成测试。
- en: Designing the repository interface
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计存储库界面
- en: The first job in designing our port is to decide what it should be doing. For
    a database port, we need to think about the split between what we want our domain
    model to be responsible for and what we will push out to the database. The ports
    we use for a database are generally called repository interfaces.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 设计我们的端口的第一项工作是决定它应该做什么。对于一个数据库端口，我们需要考虑我们希望领域模型负责的部分和我们将推送到数据库的部分之间的分割。我们用于数据库的端口通常被称为存储库接口。
- en: 'Three broad principles should guide us:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有三个广泛的原则来指导我们：
- en: Think about what the domain model needs – why do we need this data? What will
    it be used for?
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考领域模型需要什么——我们为什么需要这些数据？它将用于什么？
- en: Don’t simply echo an assumed database implementation – don’t think in terms
    of tables and foreign keys at this stage. That comes later when we decide how
    to implement the storage. Sometimes, database performance considerations mean
    we have to revisit the abstraction we create here. We would then trade off leaking
    some database implementation details here if it allowed the database to function
    better. We should defer such decisions as late as we can.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要简单地重复假设的数据库实现——在这个阶段，不要从表和外键的角度思考。那是在我们决定如何实现存储时的事情。有时，数据库性能的考虑意味着我们必须重新审视我们在这里创建的抽象。如果我们这样做能让数据库运行得更好，我们可能会牺牲一些数据库实现细节。我们应该尽可能晚地做出这样的决定。
- en: Consider when we should leverage the database engine more. Perhaps we intend
    to use complex stored procedures in the database engine. Reflect this split of
    behavior in the repository interface. It may suggest a higher-level abstraction
    in the repository interface.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑我们应该何时更多地利用数据库引擎。也许我们打算在数据库引擎中使用复杂的存储过程。在存储库界面中反映这种行为分割。这可能表明存储库界面需要更高层次的抽象。
- en: 'For our running example application, let’s consider the task of fetching a
    word at random for the user to guess. How should we divide the work between the
    domain and database? There are two broad options:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的运行示例应用程序，让我们考虑为用户随机检索一个单词的任务。我们应该如何在领域和数据库之间分配工作？有两种广泛的选择：
- en: Let the database choose a word at random
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让数据库随机选择一个单词
- en: Let the domain model generate a random number and let the database supply a
    numbered word
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让领域模型生成一个随机数，并让数据库提供编号的单词
- en: In general, letting the database do more work results in faster data handling;
    the database code is closer to the data and isn’t dragging it over a network connection
    into our domain model. But how do we persuade a database to choose something at
    random? We know that for relational databases, we can issue a query that will
    return results in no guaranteed order. That’s sort of random. But would it be
    random enough? Across all possible implementations? Seems unlikely.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is to let the domain model code decide which word to pick by
    generating a random number. We can then issue a query to fetch the word associated
    with that number. This also suggests that each word has an associated number with
    it – something we can provide when we design the database schema later.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This approach implies we need the domain model to pick a random number from
    all the numbers associated with the words. That implies the domain model needs
    to know the full set of numbers to choose from. We can make another design decision
    here. The numbers used to identify a word will start at 1 and increase by one
    for each word. We can provide a method on our port that returns the upper bound
    of these numbers. Then, we are all set to define that repository interface – with
    a test.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class starts with the package declaration and library imports we need:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We enable Mockito integration with an annotation provided by the `junit-jupiter`
    library. We add the annotation at the class level:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will ensure that Mockito is initialized on each test run. The next part
    of the test defines some integer constants for readability:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need two test doubles, which we want Mockito to generate. We need a stub
    for the word repository and a stub for a random number generator. We must add
    fields for these stubs. We will mark the fields with the Mockito `@Mock` annotation
    so that Mockito will generate the doubles for us:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Mockito sees no difference between a mock or stub when we use the `@Mock` annotation.
    It simply creates a test double that can be configured for use either as a mock
    or a stub. This is done later in the test code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'We will name the test method `selectsWordAtRandom()`. We want to drive out
    a class that we will call `WordSelection` and make it responsible for choosing
    one word at random from `WordRepository`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding test was written in the normal way, adding lines to capture each
    design decision:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The `WordSelection` class encapsulates the algorithm, which selects a word to
    guess
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `WordSelection` constructor takes two dependencies:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WordRepository` is the port for stored words'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RandomNumbers` is the port for random number generation'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `chooseRandomWord()` method will return a randomly chosen word as a String
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `arrange` section is moved out to the `beforeEachTest()` method:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will set up the test data in the stub for our `WordRepository` at the start
    of each test. The word identified by number 2 is defined as `SHINE`, so we can
    check that in the assert.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of that test code flows the following definition of two interface methods:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `WordRepository` interface defines our application’s view of the database.
    We only need two facilities for our current needs:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: A `fetchWordByNumber()` method to fetch a word, given its identifying number
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `highestWordNumber()` method to say what the highest word number will be
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The test has also driven out the interface needed for our random number generator:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The single `next()` method returns `int` in the range of 1 to the `upperBoundInclusive`
    number.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'With both the test and port interfaces defined, we can write the domain model
    code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how this code does not import anything from outside the `com.wordz.domain`
    package. It is pure application logic, relying only on the port interfaces to
    access stored words and random numbers. With this, our production code for the
    domain model of `WordSelection` is complete.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Designing the database and random numbers adapters
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next job is to implement the `RandomNumbers` port and database access code
    that implements our `WordRepository` interface. In outline, we’ll choose a database
    product, research how to connect to it and run database queries, then test-drive
    that code using an integration test. We will defer doing these tasks to part three
    of this book, in [*Chapter 13*](B18384_13.xhtml#_idTextAnchor275), *Driving the
    Domain Layer*, and [*Chapter 14*](B18384_14.xhtml#_idTextAnchor293), *Driving
    the* *Database Layer*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to apply the SOLID principles to decouple external
    systems completely, leading to an application architecture known as the hexagonal
    architecture. We saw how this allows us to use test doubles in place of external
    systems, making our tests simpler to write, with repeatable results. This, in
    turn, allows us to test entire user stories with a FIRST unit test. As a bonus,
    we isolate ourselves from future changes in those external systems, limiting the
    amount of rework that would be required to support new technologies. We’ve seen
    how the hexagonal architecture combined with dependency injection allows us to
    support several different external systems choices and select the one we want
    at runtime via configuration.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at the different styles of automated testing that
    apply to the different sections of a hexagonal architecture application. This
    approach is summarized as the Test Pyramid, and we shall learn more about it there.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following questions and answers regarding this chapter’s
    content:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Can we add the hexagonal architecture later?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not always. We can refactor it. The challenge can be too much code that directly
    depends on details of external systems. If that’s the starting point, this refactoring
    will be challenging. There will be a lot of rework to do. This implies that some
    degree of up-front design and architectural discussion is required before we start
    work.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Is the hexagonal architecture specific to OOP?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. It is a way of organizing dependencies in our code. It can be applied to
    OOP, FP, procedural programming, or anything else – so long as those dependencies
    are managed correctly.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: When should we not use the hexagonal architecture?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we have no real logic in our domain model. This is common for very small
    CRUD microservices that typically frontend a database table. With no logic to
    isolate, putting in all this code has no benefit. We may as well do TDD with integration
    tests only and accept that we won’t be able to use FIRST unit tests.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Can we only have one port for an external system?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. It is often better if we have more ports. Suppose we have a single Postgres
    database connected to our application, holding data on users, sales, and product
    inventory. We could simply have a single repository interface, with methods to
    work with those three datasets. But it will be better to split that interface
    up (following ISP) and have `UserRepository`, `SalesRepository`, and `InventoryRepository`.
    The ports provide a view of what our domain model wants from external systems.
    Ports are not a one-to-one mapping to hardware.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexagonal architecture, Alastair Cockburn: [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original description of the hexagonal architecture in terms of ports and
    adapters.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[https://medium.com/pragmatic-programmers/unit-tests-are-first-fast-isolated-repeatable-self-verifying-and-timely-a83e8070698e](https://medium.com/pragmatic-programmers/unit-tests-are-first-fast-isolated-repeatable-self-verifying-and-timely-a83e8070698e)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credits the original inventors of the term FIRST, Tim Ottinger and Brett Schuchert.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[https://launchdarkly.com/blog/testing-in-production-for-safety-and-sanity/](https://launchdarkly.com/blog/testing-in-production-for-safety-and-sanity/)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guide to testing code deployed on production systems, without accidentally triggering
    unintended consequences.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
