<html><head></head><body>
		<div id="_idContainer046">
			<h1 class="chapter-number" id="_idParaDest-308"><a id="_idTextAnchor307"/>16</h1>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor308"/>Code Monitoring and Maintenance</h1>
			<p>Writing efficient code is not enough to ensure that our Java applications perform at a high level after the initial launch of our systems. We must adopt a robust strategy of coding monitoring and maintenance to ensure that our systems continue to perform at desired levels even as data and use volumes increase and environments change. This chapter focuses on the critical practices, and associated tools, of code monitoring <span class="No-Break">and maintenance.</span></p>
			<p>Our chapter starts with an exploration of <strong class="bold">Application Performance Management</strong> (<strong class="bold">APM</strong>) tools that we can use to conduct<a id="_idIndexMarker857"/> real-time monitoring and obtain diagnostic data to help us keep our applications running efficiently. Our APM tool exploration will include use cases and <span class="No-Break">implementation strategies.</span></p>
			<p>The importance of <strong class="bold">code reviews</strong> is also covered with the goal<a id="_idIndexMarker858"/> of instilling a dedication to continual process improvement, specifically to continually maintain code quality. Insights into best practices and automation tools will provide you with knowledge on how you use selected tools and practices to identify potential issues in your code before they cause undesired system behavior and negatively impact the <span class="No-Break">user experience.</span></p>
			<p>The chapter also introduces the concept of logging and shares how effective it can be for monitoring applications. We will explore best practices, logging frameworks, and how to analyze log data. Our goal is to log the correct data and learn to use the logged data to identify optimization opportunities without introducing excessive <span class="No-Break">system overhead.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">APM tools</span></li>
				<li><span class="No-Break">Code reviews</span></li>
				<li><span class="No-Break">Logging</span></li>
				<li>Monitoring <span class="No-Break">and alerting</span></li>
				<li><span class="No-Break">Maintenance strategies</span></li>
			</ul>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor309"/>APM tools</h1>
			<p>Java developers spend more<a id="_idIndexMarker859"/> time maintaining their systems than they do developing them. This is because our systems are in production longer than it takes to write and test our code. It stands to reason that we should approach <strong class="bold">Application Performance Management</strong> (<strong class="bold">APM</strong>) seriously and appreciate the crucial role it has in our ability to ensure our systems continue to perform optimally and maximize the <span class="No-Break">user experience</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor310"/>APM tool overview</h2>
			<p>APM tools are designed to help<a id="_idIndexMarker860"/> us monitor our systems to manage their performance. These tools provide real-time insights into how our applications are performing. They can help us identify potential bottlenecks and possible optimization opportunities such as with resource use. The metrics generated by APM tools can be measured against baselines and give us a true picture of our system’s <span class="No-Break">overall health.</span></p>
			<p>The primary objectives<a id="_idIndexMarker861"/> of APM tools include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Ensuring <span class="No-Break">application reliability</span></li>
				<li>Ensuring <span class="No-Break">application scalability</span></li>
				<li>Identifying <span class="No-Break">performance issues</span></li>
				<li>Providing <span class="No-Break">actionable insights</span></li>
				<li>Real-time <span class="No-Break">application monitoring</span></li>
				<li>User <span class="No-Break">interaction</span><span class="No-Break"><a id="_idIndexMarker862"/></span><span class="No-Break"> tracking</span></li>
			</ul>
			<p>Let’s next look at the key features of <span class="No-Break">APM tools.</span></p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor311"/>APM tool key features</h2>
			<p>AMP tools range from basic<a id="_idIndexMarker863"/> to robust and can have a varied array of features. The top 10 key features of AMP tools are as follows, in no <span class="No-Break">specific order:</span></p>
			<ul>
				<li>Provide configurable alerts based on <span class="No-Break">performance thresholds</span></li>
				<li>Monitor system <span class="No-Break">resource usage</span></li>
				<li>Continuously monitor application performance such as <span class="No-Break">response times</span></li>
				<li>Identify performance bottlenecks by tracing <span class="No-Break">individual transactions</span></li>
				<li>Identify and log exceptions and errors with sufficient detail to <span class="No-Break">support troubleshooting</span></li>
				<li>Track and measure user interactions such as transaction durations and <span class="No-Break">load times</span></li>
				<li>Conduct <span class="No-Break">in-depth analysis</span></li>
				<li>Provide numeric and visual reporting of <span class="No-Break">analytic data</span></li>
				<li>Integrate with other tools such as <span class="No-Break">CI/CD pipelines</span></li>
				<li>Automate performance <span class="No-Break">management processes</span></li>
			</ul>
			<p>Now that we have an appreciation for the importance of APM tools, their objectives, and their key features, let’s review five common APM tools used for Java <span class="No-Break">application monitoring.</span></p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor312"/>Popular APM tools</h2>
			<p>There is a plethora of AMP tools available to Java application developers. The table that follows lists five common tools<a id="_idIndexMarker864"/> and provides a brief description and URL <span class="No-Break">for each.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Tool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">URL</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">AppDynamics</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Strong<a id="_idIndexMarker865"/> performance<a id="_idIndexMarker866"/> monitor with great visibility into <span class="No-Break">Java applications</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://www.appdynamics.com/product/application-performance-monitoring"><span class="No-Break">https://www.appdynamics.com/product/application-performance-monitoring</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Datadog</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Cloud-based<a id="_idIndexMarker867"/> monitoring and <span class="No-Break">analytics</span><span class="No-Break"><a id="_idIndexMarker868"/></span><span class="No-Break"> tool</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://www.dynatrace.com/monitoring/solutions/cloud-monitoring-cio-report/"><span class="No-Break">https://www.dynatrace.com/monitoring/solutions/cloud-monitoring-cio-report/</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Dynatrace</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Advanced<a id="_idIndexMarker869"/> tool that leverages AI<a id="_idIndexMarker870"/> for <span class="No-Break">performance monitoring</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://www.dynatrace.com/monitoring/platform/application-observability/"><span class="No-Break">https://www.dynatrace.com/monitoring/platform/application-observability/</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Elastic APM</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Open source<a id="_idIndexMarker871"/> performance <span class="No-Break">monitoring</span><span class="No-Break"><a id="_idIndexMarker872"/></span><span class="No-Break"> tool</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://www.elastic.co/observability/application-performance-monitoring"><span class="No-Break">https://www.elastic.co/observability/application-performance-monitoring</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">New Relic</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Perhaps<a id="_idIndexMarker873"/> the most commonly<a id="_idIndexMarker874"/> used tool, with extensive monitoring and <span class="No-Break">analytics capabilities</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://www.newrelic.com"><span class="No-Break">https://www.newrelic.com</span></a></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.1: Popular APM tools for Java applications</p>
			<p class="callout-heading">Note on URLs</p>
			<p class="callout">The URLs listed in the preceding table were valid at the time of this book’s initial publication date. If you find a link that is no longer valid, you can search for the tool name along with <em class="italic">APM tool for Java applications</em> (for example, <em class="italic">Dynatrace APM tool for Java applications</em>) to find the <span class="No-Break">new link.</span></p>
			<p>You should take the time to experiment with each APM tool to determine which one or ones you’d like to work with. Once you have an idea of which one(s) you will use, you can review the best practices presented in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor313"/>APM tool best practices</h2>
			<p>Regardless of which APM tool<a id="_idIndexMarker875"/> you adopt, there are several best practices that can help you leverage your selected tool to support your monitoring efforts. Here are several best practices for you <span class="No-Break">to consider:</span></p>
			<ul>
				<li>Regularly analyze your performance data. This can help you identify trends <span class="No-Break">and anomalies.</span></li>
				<li>Schedule and conduct periodic reviews of your APM configurations and <span class="No-Break">performance data.</span></li>
				<li>Establish clear performance monitoring goals, aligning them with your <span class="No-Break">organization’s objectives.</span></li>
				<li>Create your <strong class="bold">Key Performance Indicators</strong> (<strong class="bold">KPIs</strong>) and periodically review<a id="_idIndexMarker876"/> them <span class="No-Break">for relevancy.</span></li>
				<li>Establish a culture of performance awareness among <span class="No-Break">your teams.</span></li>
				<li>Implement a comprehensive approach to instrumentation to ensure that everything that can be <span class="No-Break">monitored is.</span></li>
				<li>Integrate APM tools with your <span class="No-Break">DevOps processes.</span></li>
				<li>Prioritize monitoring your most critical metrics such as error rates, response times, resource use, and <span class="No-Break">so on.</span></li>
				<li>Configure your APM tool to provide<a id="_idIndexMarker877"/> you with alerts and notifications for <span class="No-Break">greater efficiency.</span></li>
			</ul>
			<p>Following the best practices presented here can help you maximize the benefits of using <span class="No-Break">APM tools.</span></p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor314"/>Code reviews</h1>
			<p>Code reviews are a fundamental component<a id="_idIndexMarker878"/> of software development. As we previously suggested, code quality does not remain constant after it goes live. Environments change, new data is introduced, scaling can occur, and user behavior can change. This underscores the importance of conducting <span class="No-Break">code reviews.</span></p>
			<p>The purposes of code reviews<a id="_idIndexMarker879"/> are <span class="No-Break">listed here:</span></p>
			<ul>
				<li>Ensuring consistency in adherence to standards <span class="No-Break">and guidelines</span></li>
				<li><span class="No-Break">Encouraging collaboration</span></li>
				<li>Facilitating knowledge transfer among teams and increasing individual buy-in to <span class="No-Break">code quality</span></li>
				<li><span class="No-Break">Increasing optimization</span></li>
				<li>Identifying defects and security vulnerabilities with <span class="No-Break">quality assurance</span></li>
			</ul>
			<p>Next, let’s review some best practices when conducting <span class="No-Break">code reviews.</span></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor315"/>Best practices</h2>
			<p>Here are some self-descriptive best practices<a id="_idIndexMarker880"/> to consider when conducting <span class="No-Break">code reviews:</span></p>
			<ul>
				<li>Automate <span class="No-Break">where possible</span></li>
				<li>Encourage <span class="No-Break">constructive feedback</span></li>
				<li>Establish <span class="No-Break">coding standards</span></li>
				<li>Limit the size of <span class="No-Break">code changes</span></li>
				<li>Prioritize critical <span class="No-Break">code sections</span></li>
				<li>Set code review <span class="No-Break">time limits</span></li>
				<li>Use checklists for <span class="No-Break">reviewer consistency</span></li>
			</ul>
			<p>The first best practice suggests that you automate where possible. There are automated code review tools worth your independent research and analysis. Here is a list of these <span class="No-Break">to review:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Checkstyle</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Code Climate</strong></span></li>
				<li><strong class="bold">FindBugs</strong> and its <span class="No-Break">successor, </span><span class="No-Break"><strong class="bold">SpotBugs</strong></span></li>
				<li><span class="No-Break"><strong class="bold">PMD</strong></span></li>
				<li><span class="No-Break"><strong class="bold">SonarQube</strong></span></li>
			</ul>
			<p>Take your time reviewing the automation<a id="_idIndexMarker881"/> tools. Once you have selected the one you like best, experiment with it before officially adopting it for live projects. Next, let’s look at peer <span class="No-Break">review processes.</span></p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor316"/>Peer review processes</h2>
			<p>Code review is often done<a id="_idIndexMarker882"/> by peers and it can be awkward if not approached properly. Here are some tips for conducting proper and efficient <span class="No-Break">peer reviews:</span></p>
			<ul>
				<li>Assign reviewers who have the appropriate expertise <span class="No-Break">and experience</span></li>
				<li>Rotate reviewers to <span class="No-Break">mitigate complacency</span></li>
				<li>Prepare for reviews by mandating in-code <span class="No-Break">commenting standards</span></li>
				<li>Use code review tools (such as GitHub pull requests) to streamline <span class="No-Break">the process</span></li>
				<li>Encourage an atmosphere of mutual respect and <span class="No-Break">open communication</span></li>
				<li>Follow up on <span class="No-Break">all feedback</span></li>
			</ul>
			<p>Following these tips can ease the awkwardness and improve the efficiency of peer reviews. Next, let’s look at some common pitfalls regarding <span class="No-Break">code reviews.</span></p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor317"/>Common pitfalls</h2>
			<p>There are several pitfalls<a id="_idIndexMarker883"/> when conducting code reviews, although they are overshadowed by the benefits we get from the process. This section examines the top five pitfalls experienced when conducting code reviews and <span class="No-Break">suggests solutions.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Pitfall</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Solution</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Delayed reviews</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Set clear timelines and integrate them into your <span class="No-Break">development workflow.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Inconsistent standards</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Establish clear guidelines and <span class="No-Break">use checklists.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Lack of <span class="No-Break">constructive feedback</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Focus on providing constructive feedback. Be specific and ensure that feedback <span class="No-Break">is actionable.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Neglecting <span class="No-Break">automation tools</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Use automation tools to your advantage. They can catch routine issues while your developers review more <span class="No-Break">complex issues.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Overly <span class="No-Break">long reviews</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Keep reviews short <span class="No-Break">and frequent.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.2: Common code review pitfalls with solutions</p>
			<p>An understanding of these pitfalls can help ensure that your code reviews are seamlessly integrated into <span class="No-Break">your workflows.</span></p>
			<p>In the next section, we will <span class="No-Break">review logging.</span></p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor318"/>Logging</h1>
			<p>Logging data is a fundamental component<a id="_idIndexMarker884"/> of code monitoring and maintenance. This data can reveal information about how our code performs, where it is failing, what security concerns there might be, and more. It involves recording information about how our program runs. We can use<a id="_idIndexMarker885"/> this information for audits, debugging, <span class="No-Break">and monitoring.</span></p>
			<p>The key aspects<a id="_idIndexMarker886"/> of logging include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Log levels</strong>: Logs are categorized based on their importance and the severity of what is being logged. Examples include <strong class="source-inline">DEBUG</strong>, <strong class="source-inline">ERROR</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">INFO</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Log messages</strong>: These are the narrative descriptions of <span class="No-Break">application events.</span></li>
				<li><strong class="bold">Log rotation</strong>: We rotate logs by archiving old logs and starting new ones. This prevents singular, large logs that can be difficult to manage and result in <span class="No-Break">storage issues.</span></li>
				<li><strong class="bold">Log targets</strong>: Targets are the storage destinations for <span class="No-Break">the logs.</span></li>
			</ul>
			<p>Now that we have a fundamental understanding of logging, let’s review some <span class="No-Break">best practices.</span></p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor319"/>Best practices</h2>
			<p>Our logging implementations<a id="_idIndexMarker887"/> should be focused on the relevancy of what is captured and on the efficiency of the system. With those goals in mind, here are some best practices <span class="No-Break">regarding logging:</span></p>
			<ul>
				<li>Adopt a concise but descriptive mentality for logs. You will want them to be clear and not <span class="No-Break">overly verbose.</span></li>
				<li>Centralize your logs to facilitate aggregated and <span class="No-Break">comprehensive processing.</span></li>
				<li>Consider using a structured logging format such as JSON so they are easier to parse <span class="No-Break">and analyze.</span></li>
				<li>Focus on log levels that are aligned with your systems’ most <span class="No-Break">critical processes.</span></li>
				<li>Formalize your logging practices to include formats and <span class="No-Break">naming conventions.</span></li>
				<li>Protect individually identifiable or other sensitive data from being included <span class="No-Break">in logs.</span></li>
				<li>Review your <span class="No-Break">logs regularly.</span></li>
			</ul>
			<p>Next, we will review useful <span class="No-Break">logging frameworks.</span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor320"/>Logging frameworks</h2>
			<p>There are several logging frameworks<a id="_idIndexMarker888"/> that we can use for our Java applications. Developers typically select one after reviewing their options. Here is a list of some of the more <span class="No-Break">popular frameworks:</span></p>
			<ul>
				<li><strong class="bold">Java Util Logging</strong> (<strong class="bold">JUL</strong>): This is a logging framework<a id="_idIndexMarker889"/> built into Java (<strong class="source-inline">java.util.logging</strong>). While it only provides basic logging capabilities, we can use it without the need for additional libraries. It is a good framework to use if you are just getting started <span class="No-Break">with logging.</span></li>
				<li><strong class="bold">Log4j2</strong>: This is an advanced framework<a id="_idIndexMarker890"/> that supports various configurations, log levels, types, <span class="No-Break">and destinations.</span></li>
				<li><strong class="bold">Logback</strong>: This framework provides<a id="_idIndexMarker891"/> a high-performance<a id="_idIndexMarker892"/> option compatible with <strong class="bold">Simple Logging Facade for </strong><span class="No-Break"><strong class="bold">Java</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SLF4J</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">SLF4J</strong>: This framework provides an abstraction<a id="_idIndexMarker893"/> to support multiple logging frameworks such <span class="No-Break">as Logback.</span></li>
				<li><strong class="bold">Tinylog</strong>: As the name suggests, this is a lightweight <a id="_idIndexMarker894"/>framework with low overhead. It is ideal for <span class="No-Break">small applications.</span></li>
			</ul>
			<p>These frameworks can help simplify our implementation and management of logging. Next, let’s look at key strategies for analyzing our <span class="No-Break">logged data.</span></p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor321"/>Analyzing log data</h2>
			<p>One of the primary reasons<a id="_idIndexMarker895"/> for logging systems data is to provide us with the ability to analyze it for the betterment of our system’s overall performance. Here are some strategies you can use for analyzing and managing your <span class="No-Break">log data:</span></p>
			<ul>
				<li><strong class="bold">Aggregate</strong>: Feed your logs into a central repository for more<a id="_idIndexMarker896"/> efficient<a id="_idIndexMarker897"/> analysis. There are several tools (such as <strong class="bold">Logstash</strong> and <strong class="bold">Elasticsearch</strong>) that can be used to help with <span class="No-Break">this strategy.</span></li>
				<li><strong class="bold">Analyze</strong>: Use tools (such as <strong class="bold">Datadog</strong> and <strong class="bold">Graylog</strong>) to help analyze<a id="_idIndexMarker898"/> and visualize<a id="_idIndexMarker899"/> logged data. Use statistical analysis to gain <span class="No-Break">deep insights.</span></li>
				<li><strong class="bold">Automate</strong>: Use automated alerts to inform you of activity based on thresholds <span class="No-Break">you set.</span></li>
				<li><strong class="bold">Archive</strong>: Archive logs to avoid <span class="No-Break">log bloat.</span></li>
			</ul>
			<p>Following the best practices<a id="_idIndexMarker900"/> and leveraging selected frameworks and tools can help ensure your logging efforts are purposeful and efficient. Next, let’s look at how to set up monitoring <span class="No-Break">and alerts.</span></p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor322"/>Monitoring and alerting</h1>
			<p>Our log data is always<a id="_idIndexMarker901"/> available when we want<a id="_idIndexMarker902"/> to review it, but more importantly, it can be used to provide us with automated alerts based on how we set things up. Effective monitoring and alerting are key operations for maintaining our Java applications and ensuring their high performance <span class="No-Break">and security.</span></p>
			<p>Monitoring and alerting can provide us with real-time insights into how our application is performing and promptly alert us to anything that requires <span class="No-Break">immediate action.</span></p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor323"/>Monitoring system setup</h2>
			<p>The steps involved in setting up<a id="_idIndexMarker903"/> your monitoring system will depend on the frameworks and tools you select. Here is a six-step process that can be used irrespective of the frameworks and tools <span class="No-Break">you select:</span></p>
			<ol>
				<li><strong class="bold">Identify key metrics</strong>: You need to know what you want to collect so that what is collected is useful. Your critical metrics might include CPU usage, memory use, error rates, response times, and so on. Once you have identified your key metrics, you can establish <span class="No-Break">performance goals.</span></li>
				<li><strong class="bold">Select monitoring tools</strong>: Select the monitoring tools (such as <strong class="bold">Grafana</strong>, <strong class="bold">New Relic</strong>, or <strong class="bold">Prometheus</strong>) that are the most<a id="_idIndexMarker904"/> appropriate<a id="_idIndexMarker905"/> for your application’s architecture <a id="_idIndexMarker906"/><span class="No-Break">and requirements.</span></li>
				<li><strong class="bold">Integrate monitoring agents</strong>: Integrate monitoring agents into your Java application to collect performance data. Depending on your solution, you might add specific monitoring code, leverage built-in capabilities of existing frameworks, or <span class="No-Break">use APIs.</span></li>
				<li><strong class="bold">Set up data collection</strong>: Configure your monitoring system to collect and store performance data. Be mindful and ensure that the data collection operation is efficient and does not result in significant <span class="No-Break">application overhead.</span></li>
				<li><strong class="bold">Visualize</strong>: Create or use dashboards provided by your monitoring tools to visually represent the collected data. You can use tools such as Grafana to build interactive dashboards that can help you quickly understand your application’s <span class="No-Break">performance status.</span></li>
				<li><strong class="bold">Review and adjust</strong>: Periodically review the effectiveness of your monitoring setup and make necessary adjustments. Reassess this each time you introduce a new component<a id="_idIndexMarker907"/> <span class="No-Break">or service.</span></li>
			</ol>
			<p>Once your monitoring system has been set up, you will be ready to configure it to provide <span class="No-Break">informative alerts.</span></p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor324"/>Alert configuration</h2>
			<p>Configuring alerts involves<a id="_idIndexMarker908"/> setting thresholds and rules that trigger notifications when certain performance conditions are met. Follow these steps to set up an effective <span class="No-Break">alert schema:</span></p>
			<ol>
				<li><strong class="bold">Define criteria</strong>: Identify the conditions that you want alerts for and be specific. For example, you might choose 92% CPU usage, increased response times, spikes in errors, and so on. You can base your thresholds on historical application data and <span class="No-Break">performance benchmarks.</span></li>
				<li><strong class="bold">Set levels</strong>: Categorize your alerts by severity (that is, <strong class="bold">information</strong>, <strong class="bold">warning</strong>, <strong class="bold">critical</strong>) so your team can prioritize their <span class="No-Break">response efforts.</span></li>
				<li><strong class="bold">Configure channels</strong>: Set up channels for alert notifications so your team is informed. You might simply use <strong class="bold">SMS</strong>, email, <strong class="bold">Slack</strong>, or <strong class="bold">Discord</strong>, or implement an incident<a id="_idIndexMarker909"/> management platform such <span class="No-Break">as </span><span class="No-Break"><strong class="bold">PagerDuty</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Fine-tune thresholds</strong>: When setting up alerts, you want to avoid alert fatigue. This will require you to fine-tune your alert thresholds. Overwhelming your team with unnecessary alerts will negate the efficacy of your <span class="No-Break">alert system.</span></li>
				<li><strong class="bold">Test</strong>: Regularly test your alert setup to ensure it works. You can even conduct drills to simulate performance<a id="_idIndexMarker910"/> situations to verify your <span class="No-Break">system’s efficacy.</span></li>
			</ol>
			<p>Once your alert system has been set up, you need to determine your <span class="No-Break">response approach.</span></p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor325"/>Alert and incident response</h2>
			<p>It is important to establish a formal approach<a id="_idIndexMarker911"/> to incident response. When establishing your alert response schema, consider the <span class="No-Break">following questions:</span></p>
			<ul>
				<li>Which alerts warrant <span class="No-Break">a response?</span></li>
				<li>Who responds to <span class="No-Break">which alerts?</span></li>
				<li>What internal communication <span class="No-Break">is necessary?</span></li>
				<li>What external communication <span class="No-Break">is required?</span></li>
				<li>What follow-up actions <span class="No-Break">are necessary?</span></li>
			</ul>
			<p>A structured approach to responding to alerts and incidents can help ensure that critical issues are appropriately addressed. This can lead to rapid resolution and <span class="No-Break">minimum downtime.</span></p>
			<p>Key components of an effective alert <a id="_idIndexMarker912"/>and incident response approach include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Alert acknowledgment</strong>: When an alert is received, acknowledge it promptly. You may establish maximum response times for your team <span class="No-Break">to follow.</span></li>
				<li><strong class="bold">Assessment</strong>: Investigate each alert to understand the root causes. The goal is not only to fix a current issue but also to prevent the issue from repeating in <span class="No-Break">the future.</span></li>
				<li><strong class="bold">Execution of plans</strong>: Ensure that your team follows predefined incident response plans through issue resolution. These plans should consist of documented step-by-step procedures for common issues and <span class="No-Break">complex problems.</span></li>
				<li><strong class="bold">Communication</strong>: Keep internal and external stakeholders informed about the incident status and resolution progress using predefined <span class="No-Break">communication channels.</span></li>
				<li><strong class="bold">Documentation</strong>: After resolving the incident, the root cause(s), resolution steps, and lessons learned should be documented. When appropriate, conduct a post-incident review with your <a id="_idIndexMarker913"/>team to identify <span class="No-Break">improvement opportunities.</span></li>
			</ul>
			<p>When we set up a robust and purposeful monitoring and alerting system, we significantly increase our ability to effectively maintain and improve the performance of our Java applications, even as <span class="No-Break">they scale.</span></p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor326"/>Maintenance strategies</h1>
			<p>We need a strategy to maintain <a id="_idIndexMarker914"/>our application’s code that goes beyond simply responding to system alerts. When we take a purposeful approach to code maintenance, we can ensure the sustained reliability, availability, and performance of our <span class="No-Break">Java applications.</span></p>
			<p>The main concept is to maintain a balance between scheduled maintenance and reactive maintenance. The table that follows provides insights into each approach and includes their advantages<a id="_idIndexMarker915"/> and <span class="No-Break">best </span><span class="No-Break"><a id="_idIndexMarker916"/></span><span class="No-Break">practices.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Scheduled maintenance</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Reactive maintenance</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Approach details</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A planned approach to update code on <span class="No-Break">scheduled intervals</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Addressing issues as <span class="No-Break">they arise</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Advantages</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li><span class="No-Break">Predictable downtimes</span></li>
								<li>Reduced risks <span class="No-Break">of failures</span></li>
								<li><span class="No-Break">Continual optimization</span></li>
							</ul>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Immediate <span class="No-Break">issue resolution</span></li>
								<li>Requires fewer resources compared to the scheduled <span class="No-Break">maintenance approach</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Best practices</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Establish and follow the <span class="No-Break">maintenance schedule</span></li>
								<li>Test changes during <span class="No-Break">maintenance windows</span></li>
								<li>Communicate the plan to internal and <span class="No-Break">external stakeholders</span></li>
							</ul>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Implement robust monitoring and <span class="No-Break">alerting systems</span></li>
								<li>Create incident <span class="No-Break">response plans</span></li>
								<li>Create documentation to <span class="No-Break">support troubleshooting</span></li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.3: Comparison of scheduled maintenance and reactive maintenance approaches</p>
			<p>Once you have established<a id="_idIndexMarker917"/> your maintenance approach, you should<a id="_idIndexMarker918"/> consider documentation and knowledge management. Let’s look at that in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor327"/>Documentation and knowledge management</h2>
			<p>Effective documentation and knowledge management<a id="_idIndexMarker919"/> is undeniably vital for maintaining a healthy code base. It can also help ensure smooth transitions during <span class="No-Break">maintenance activities.</span></p>
			<p>Documentation should be<a id="_idIndexMarker920"/> comprehensive, especially for large systems. Comprehensive documentation should consist of the following <span class="No-Break">main components:</span></p>
			<ul>
				<li><span class="No-Break">API documentation</span></li>
				<li><span class="No-Break">Code documentation</span></li>
				<li><span class="No-Break">Configuration documentation</span></li>
			</ul>
			<p>It is also important to have<a id="_idIndexMarker921"/> a knowledge-sharing component, which can include internal wikis and training for new team members. As systems are updated, the knowledge-sharing artifacts should be updated to ensure that they remain relevant. How knowledge<a id="_idIndexMarker922"/> is shared<a id="_idIndexMarker923"/> is almost<a id="_idIndexMarker924"/> as important as what is shared. Collaboration tools such as <strong class="bold">Teams</strong>, <strong class="bold">SharePoint</strong>, <strong class="bold">Confluence</strong>, and <strong class="bold">GitHub wikis</strong> can be used to facilitate<a id="_idIndexMarker925"/> collaborative document and <span class="No-Break">knowledge sharing.</span></p>
			<p>Maintenance strategies often include <strong class="bold">refactoring</strong>, which we will review in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor328"/>Refactoring strategies</h2>
			<p>Refactoring is the process <a id="_idIndexMarker926"/>of repurposing<a id="_idIndexMarker927"/> existing code without changing its external behavior. The purpose of refactoring is to improve the code’s readability, maintainability, <span class="No-Break">and performance.</span></p>
			<p>We can identify the need<a id="_idIndexMarker928"/> for refactoring through <strong class="bold">code smells</strong>, which are signs of poorly designed code, duplicate code, and large or long classes and methods. Performance bottlenecks and complex logic are additional indicators that code should <span class="No-Break">be refactored.</span></p>
			<p>The following techniques<a id="_idIndexMarker929"/> can be used for refactoring <span class="No-Break">your code:</span></p>
			<ul>
				<li>Break down large classes and methods into smaller, more <span class="No-Break">manageable components.</span></li>
				<li>Rename classes, methods, and variables so they are meaningful and self-describing. This added code clarity improves overall readability <span class="No-Break">and maintainability.</span></li>
				<li>Remove <span class="No-Break">unused code.</span></li>
				<li>Simplify complex conditional<a id="_idIndexMarker930"/> logic into clearer, more <span class="No-Break">readable constructs.</span></li>
			</ul>
			<p>When refactoring our code, we should strive to refactor in small, incremental steps. This will minimize the risks of introducing new bugs. We should always write <strong class="bold">unit tests</strong> (see <a href="B21942_17.xhtml#_idTextAnchor331"><span class="No-Break"><em class="italic">Chapter 17</em></span></a>, <em class="italic">Unit and Performance Testing</em>) before and after refactoring. This helps us ensure that the functionality remains unchanged. Lastly, we should<a id="_idIndexMarker931"/> use a version control system to track<a id="_idIndexMarker932"/> our changes<a id="_idIndexMarker933"/> and support code <strong class="bold">rollback</strong> <span class="No-Break">if necessary.</span></p>
			<p>Sometimes we inherit systems and must maintain legacy code. That is covered in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor329"/>Legacy code</h2>
			<p>Legacy code refers to older<a id="_idIndexMarker934"/> code bases. They are typically difficult to maintain<a id="_idIndexMarker935"/> due to outdated practices, lack of documentation, or deprecated<a id="_idIndexMarker936"/> technologies (that is, systems coded with the <strong class="bold">Common Business Oriented </strong><span class="No-Break"><strong class="bold">Language</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">COBOL</strong></span><span class="No-Break">)).</span></p>
			<p>When inheriting a legacy code base, we should first conduct a thorough code review to identify problematic areas, outdated dependencies, and security vulnerabilities. Armed with knowledge from the code review, we can prioritize critical sections of the code that require immediate attention or pose significant risks or <span class="No-Break">security vulnerabilities.</span></p>
			<p>When feasible, we should adopt a modernization strategy for the legacy code. This could include the <span class="No-Break">following components:</span></p>
			<ul>
				<li>Implementing <span class="No-Break">incremental updates</span></li>
				<li>Using code wrappers for <span class="No-Break">new features</span></li>
				<li>Automating testing <span class="No-Break">for changes</span></li>
				<li>Documenting legacy code and changes <span class="No-Break">to it</span></li>
				<li>Implementing a <span class="No-Break">backup schema</span></li>
				<li>Using a version <span class="No-Break">control system</span></li>
				<li>Isolating legacy components from the rest of <span class="No-Break">the system</span></li>
				<li>Training your developers on the legacy code and your <span class="No-Break">maintenance plan</span></li>
			</ul>
			<p>Implementing these maintenance strategies<a id="_idIndexMarker937"/> can help you ensure the ongoing<a id="_idIndexMarker938"/> stability and performance of your Java applications. The strategies are aimed at making the code easier to update, maintain, and scale <span class="No-Break">over time.</span></p>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor330"/>Summary</h1>
			<p>This chapter explored the essential practices and tools for effective code monitoring and maintenance, focusing on ensuring long-term performance, reliability, security, and scalability. We began with an overview of APM tools, detailing their key features such as real-time monitoring, transaction tracing, error tracking, and user experience monitoring. Popular APM tools for Java were reviewed, along with best practices for their implementation <span class="No-Break">and use.</span></p>
			<p>We emphasized the importance of code reviews for the goal of maintaining high-quality code. We covered best practices, detailed the peer review process, and shared common pitfalls, offering <span class="No-Break">avoidance solutions.</span></p>
			<p>The concept of logging was examined, starting with the fundamentals, including log levels, messages, and targets. We outlined best practices for effective logging, such as using appropriate levels, avoiding sensitive information, and centralizing logs. We also introduced popular logging frameworks for Java and discussed techniques for analyzing and managing <span class="No-Break">log data.</span></p>
			<p>Monitoring and alerting were highlighted. We covered how to set up a comprehensive monitoring system, as well as alert configuration and incident response strategies. We concluded the chapter by covering maintenance strategies. We compared scheduled and reactive maintenance approaches, stressing the importance of proactive planning. We emphasized the role of documentation and knowledge management in maintaining healthy code bases. Finally, we explored effective refactoring strategies and provided guidance on how to deal with <span class="No-Break">legacy code.</span></p>
			<p>In the next chapter, we will introduce strategies for creating and using unit and performance tests to help create and maintain high-performance Java applications. Specifically, we will look at unit testing, performance testing, and <span class="No-Break">overarching strategies.</span></p>
		</div>
	</body></html>