- en: Data Classes and Their Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concerning the data classes in Project Amber, work is in progress. It proposes
    to provide developers with a simplified method for modeling data, introducing
    special classes with the `record` keyword. The state of a data class could be
    captured by using the class header, which is in stark contrast to the existing
    **Plain Old Java Objects** (**POJOs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for data classes, and their limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aggregate and exploded forms of data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance with abstract data classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding variables and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding default behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know of two versions of data classes—POJO (the old, existing form) and the
    newly proposed data classes. To understand the data classes that are being worked
    on in Project Amber, you'll need to know the capabilities and limitations of the
    existing POJO classes and why we need the newly proposed classes.
  prefs: []
  type: TYPE_NORMAL
- en: POJO is not implemented using a language construct. The proposed data classes
    would include changes or additions to the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: What is a data class?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a Java developer, you have probably used and created POJOs in some (or all)
    of your projects. A POJO is a class that encapsulates a set of data, without any
    additional behavior to manipulate its state. It usually includes constructors,
    accessors, mutators, and the overridden methods from the object class (`hashCode()`,
    `equals()`, and `toString()`). The accessors and mutators allow access and assignment
    to state variables. Additionally, the mutators might include code to check the
    range of values that are assigned to the instance state. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One scenario is using the `Emp` class to save employee data to your database.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can use the `Emp` class to be passed in a message, sent over
    the network, inserted into a JSON object, and more.
  prefs: []
  type: TYPE_NORMAL
- en: All of this looks good. Most importantly, it has been working fine since Java
    was introduced to developers. So, what is the problem?
  prefs: []
  type: TYPE_NORMAL
- en: The need to add data classes to the language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine securing the borders of a country, which are normally guarded by defense
    forces. Will the level of security change based on the relationships with the
    neighboring countries (cordial, neutral, or tense)? What happens if the borders
    are porous (for example, the borders in Western Europe, for the Schengen countries)?
    Now, compare guarding the borders of a country with guarding our homes or securing
    the contents of a cabinet in a room.
  prefs: []
  type: TYPE_NORMAL
- en: Although each instance in the preceding example concerns the security of an
    entity and its protection from a physical attack, the instances have varying requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, until now, the classes in Java have been used to model a wide range
    of requirements. While this works well for a lot of cases, it doesn't work for
    some. If you want to make the same size fit all, you'll need a lot of adjustments,
    for most of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this to using the same trouser size for individuals with varying heights
    and waist sizes, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff9fc26c-c236-4f13-864d-12e26d343d9d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the past, enums were added to the Java language (version 5). Even though
    a class can be programmed to create an enumeration of primitives or objects, enums
    simplified the process for a developer.
  prefs: []
  type: TYPE_NORMAL
- en: Enums reduced the coding for developers. At the same time, they made the intent
    of each enum explicit to the users.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, the `Emp` POJO is just a carrier of its data. However,
    seasoning a class to behave like a data class requires a developer to define multiple
    methods—constructs, accessors, mutators, and other methods from the object class.
    You might argue that you can use an IDE to easily generate all of these methods
    for your class. You are right! And it's quite simple to do so.
  prefs: []
  type: TYPE_NORMAL
- en: However, that only takes care of the writing part of the code. What happens
    to the reading part of the code, for the users of the class? Us developers understand
    that a piece of code might be written just once, but will be read multiple times.
    That is why experienced programmers stress good coding practices, for comprehending,
    reading, and maintaining code.
  prefs: []
  type: TYPE_NORMAL
- en: When the definition of data classes is induced in the language, the readers
    of the code will know its explicit intent of being a data class. The developers
    need not dig their claws deep into finding the code that was in addition to being
    a data class, so that they don't miss any important information.
  prefs: []
  type: TYPE_NORMAL
- en: This will also prevent the developers from using half-baked classes as data
    classes. At times, developers use such classes as a data class, which do not include
    all of the relevant methods (such as `equals()` or `hashCode()`). This will surely
    lead to inserting subtle bugs in your applications. A collection class, such as `Map`,
    requires a class to implement its `equals()` and `hashCode()` methods to function
    properly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing data classes with a change in the language would decrease the verbosity
    of the language, broadcasting the intent of the structure to all.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax to define a data class looks simple. However, both the syntax and
    semantics are important. Let's get started by looking at some examples, in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Example of syntax and semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s redefine the `Emp` class, which we used at the beginning of the chapter,
    as a data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `record` keyword to define a data class, accepting
    a comma-separated variable `name` and type, required to store the state. The compiler
    automatically generates default implements for the object methods (`equals()`,
    `hashCode()`, and `toString()`) for data classes.
  prefs: []
  type: TYPE_NORMAL
- en: The code looks clear and compact. A reader would immediately know the intent
    of this single line of code—a carrier of the data `name` (type `String`) and `age`
    (type `int`). Another advantage for a reader is that they wouldn't have to read
    through constructors, accessors, mutators, or methods of the object class, just
    to ascertain that they are doing what they are supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, the record class, `Emp`, is converted to the following code
    by the Java compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding data class is an example of a non-abstract data class. A data
    class can also be defined as an abstract data class. A non-abstract data class
    is implicitly final. In both cases, a data class will get default implementations
    of `hashCode()`, `equals()`, and `toString()`, and accessor methods. For an abstract
    data class, the constructors would be protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, the compiler looks happy to convert the one line
    code for the data class to a full-fledged class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/597d2162-3fb1-4aa5-8812-2e596c742a27.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, a data class is `final`; you can't extend it.
  prefs: []
  type: TYPE_NORMAL
- en: The aggregate and exploded forms of data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aggregate form of a data class will be the name of the data class. Its exploded
    form would refer to the variables used to store its data. The conversion from
    aggregate to exploded form is referred to as the **deconstruction pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code refers to the example that we used in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Emp` is the aggregate form of the `Emp` data class. Its exploded form would
    be `String name` and `int age`. The language would need easy conversion between
    the two, so that they can be used with other language constructs, such as `switch`.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the `record` keyword to define your data class, you'll be limited
    by what the language allows you to do. You'll no longer have fine control over
    whether your data class is extensible, whether its state is mutable, the range
    of values that can be assigned to your fields, the accessibility to your fields,
    and so on. You might also be limited when it comes to having additional fields
    or multiple constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes are still in progress at Oracle. The finer details are still being
    worked on. In March 2018, the `datum` keyword was used to define a data class
    but has now been changed to `record`.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, developers aren't limited to working with a single programming language.
    Java programmers usually work with or are aware of, other programming languages
    that work on the JVM, such as Scala, Kotlin, or Groovy. The experience of working
    with varied languages brings a lot of expectations and assumptions about the capabilities
    and limitations of the data classes (defined using `record`).
  prefs: []
  type: TYPE_NORMAL
- en: Examples from the past – changes to define enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to the introduction of enums, developers often used `public`, `static`,
    and `final` variables to define constants. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The major drawback of using `public`, `static`, `final`, and `int` variables
    is type safety; any `int` value could be assigned to a variable of the type `int`,
    instead of the `Size.SMALL`, `Size.MEDIUM`, or `Size.LARGE` constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 5 introduced enums, an addition to the language construct, to enable developers
    to define an enumeration of constants. Here''s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With a variable of the type `Size`, an assignment is limited to the constants
    defined in `Size`. An enum is a perfect example of how language can simplify the
    implementation of a model, at the cost of certain constraints. Enums limit the
    extensibility to interfaces. Other than that, enums are full-fledged classes.
    As a developer, you can add states and behaviors to them. Another benefit is that
    an enum can also `switch` constructs, which was previously limited to primitives
    and a `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: A new language construct is like a new human relationship, biological or otherwise.
    It has its own share of joys and sorrows.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you define your data classes using the `record` keyword, you get the added
    advantage of the conversion of aggregate and exploded forms of your data class.
    For example, the following code shows how the `switch` statement might explode
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `switch` statement can use a data class, without using its exploded form.
    The following code is also effective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulating the state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The record classes encapsulate the fields, providing default implementations
    of JavaBean-style accessor methods (public methods to set the values of fields).
    The values can be assigned during the initialization of data class instances,
    using their constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s revisit the `Emp` data class and its decompiled version
    from a previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Abstract and non-abstract data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data classes can be abstract or non-abstract. An abstract data class is defined
    by using the keyword `abstract` in its declaration. As an abstract class, you
    can''t use abstract data classes directly. Here''s an example of an abstract data
    class, `JVMLanguage`, and a non-abstract data class, `Conference`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Data classes and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the proposal is to drop the following inheritance cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A data class extends a regular class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular class extends a data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data class extends another data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowing for any of the preceding cases would violate the contract of a data
    class being a carrier of data. At present, the following restrictions are proposed
    for data classes and inheritance, with interfaces and abstract data classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-abstract and abstract data classes can extend other abstract data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract or non-abstract data class can extend any interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure sums up these inheritance rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/068c5647-5d02-4461-907a-d2f6da929031.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's get started by extending an abstract data class.
  prefs: []
  type: TYPE_NORMAL
- en: Extending an abstract data class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, the `Emp` abstract data class is being extended by
    the non-abstract `Manager` data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When a non-abstract data class extends an abstract data class, it accepts all
    of the data in its header—the ones that are required for itself, and for its base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: A data class can extend a single abstract data class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A data class can implement an interface and its abstract methods, or just inherit
    its default methods. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a tagging interface, `Organizer` (without any methods),
    and an interface, `Speaker`, with an abstract method, `conferenceTalk()`. We have
    two cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A data class extending another data class, implementing an interface—the data
    class `Manager` extends the abstract `Emp` data class and implements the `Organizer` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data class extending another data class and implementing multiple interfaces—the `Programmer` 
    data class extends the abstract `Emp` data class and implements two interfaces—`Organizer`
    and `Speaker`. The `Programmer` data class must implement the abstract `conferenceTalk()`
    method from the `Speaker` interface  to qualify as a non-abstract data class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data class can implement a single or multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Additional variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it is allowed, before adding variables or fields to a data class,
    ask yourself, *Are the fields derived from the state?* Fields that are not derived
    from the state pose a serious violation of the initial concept of the data classes.
    The following code is an example that defines an additional field, `style`, derived
    from the state of the `Emp` data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works well because the state of the `Emp` data class is still
    derived from its state (the `name` and `age` fields). The `getStyle` method doesn't
    interfere with the state of `Emp`; it is purely an implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding implicit behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose that you want to limit the values that can be passed to a field in
    your data class during its instantiation. This is feasible; just override the
    default constructor. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can override the default implementations of object methods, such
    as `equals()`, `hashCode()`, and `toString()`, and other methods, such as the
    accessor methods.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the default behaviors of the methods of your data class doesn't defeat
    the purpose of their creation. They are still working as data classes, with finer
    control of their functionality. Let's compare this with POJOs, which were used
    to model data classes previously. The compiler doesn't auto-generate any methods
    for a POJO. So, a user still needs to read all of the code, looking for code that
    isn't the default implementation of its methods. In the case of data classes,
    this overridden behavior is very explicit. So, a user doesn't have to worry about
    reading all of the code; they can assume default implementation of the behavior,
    which hasn't been overridden by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding behavior explicitly states the places where a data class diverts
    from its default behavior, reducing the amount of code that must be read by a
    user to understand its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Additional methods and constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compiler generates a default constructor for a data class, along with accessor
    methods and the default implementation of the methods from the object class. A
    developer can overload the constructors and add more methods to a data class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concerning whether the data classes should be designated as mutable or immutable,
    work is still in progress. Both options have advantages and disadvantages. Immutable
    data works well in multithreaded, parallel, or concurrent systems. On the other
    hand, mutable data works well with cases that require frequent modifications to
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning thread safety, since the data classes are not yet designated to be
    immutable, it is the responsibility of the developers to use them in thread-safe
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the challenges of using POJOs to model data. We
    covered how data classes provide a simple and concise way to model data. Implementation
    of data classes will include language changes, with the introduction of the `record` keyword.
    The main goal of using data classes is to model data as data, not to reduce the
    boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the aggregate and exploded forms of data classes. The data classes
    can be used with other language constructs, such as `switch`. By default, the
    data classes are not mutable, including the arrays defined as the data members.
    Since these structures are not immutable, a developer must include code to ensure
    thread safety when working with them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn more about an exciting language enhancement—raw
    string literals. Does this mean a pure, or untouched, string? Find out for yourself
    by reading on.
  prefs: []
  type: TYPE_NORMAL
