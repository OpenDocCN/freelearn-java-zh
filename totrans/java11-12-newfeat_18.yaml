- en: Data Classes and Their Usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类及其用法
- en: Concerning the data classes in Project Amber, work is in progress. It proposes
    to provide developers with a simplified method for modeling data, introducing
    special classes with the `record` keyword. The state of a data class could be
    captured by using the class header, which is in stark contrast to the existing
    **Plain Old Java Objects** (**POJOs**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Project Amber中的数据类，工作正在进行中。它提议为开发者提供一个简化的数据建模方法，引入带有`record`关键字的特殊类。数据类的状态可以通过使用类头来捕捉，这与现有的**普通Java对象**（**POJOs**）形成鲜明对比。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to data classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类的介绍
- en: The need for data classes, and their limitations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类的需求及其局限性
- en: The aggregate and exploded forms of data classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类的聚合形式和展开形式
- en: Pattern matching with data classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据类进行模式匹配
- en: Inheritance with abstract data classes and interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象数据类和接口进行继承
- en: Adding variables and methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加变量和方法
- en: Overriding default behaviors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖默认行为
- en: An introduction to data classes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类的介绍
- en: We know of two versions of data classes—POJO (the old, existing form) and the
    newly proposed data classes. To understand the data classes that are being worked
    on in Project Amber, you'll need to know the capabilities and limitations of the
    existing POJO classes and why we need the newly proposed classes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道有两种数据类版本——POJO（旧的形式）和刚刚提出的新的数据类。为了理解Project Amber中正在工作的数据类，你需要了解现有POJO类的功能和局限性，以及为什么我们需要新提出的类。
- en: POJO is not implemented using a language construct. The proposed data classes
    would include changes or additions to the programming language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: POJO不是通过语言结构实现的。提出的数据类将包括对编程语言的修改或添加。
- en: What is a data class?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是数据类？
- en: 'As a Java developer, you have probably used and created POJOs in some (or all)
    of your projects. A POJO is a class that encapsulates a set of data, without any
    additional behavior to manipulate its state. It usually includes constructors,
    accessors, mutators, and the overridden methods from the object class (`hashCode()`,
    `equals()`, and `toString()`). The accessors and mutators allow access and assignment
    to state variables. Additionally, the mutators might include code to check the
    range of values that are assigned to the instance state. The following is an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，你可能已经在你的某些（或所有）项目中使用和创建了POJOs。POJO是一个封装了一组数据的类，没有额外的行为来操作其状态。它通常包括构造函数、访问器、修改器以及从对象类中重写的的方法（`hashCode()`、`equals()`和`toString()`）。访问器和修改器允许访问和分配状态变量。此外，修改器可能包括检查分配给实例状态的值范围的代码。以下是一个示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One scenario is using the `Emp` class to save employee data to your database.
    Here''s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一种场景是使用`Emp`类将员工数据保存到你的数据库中。以下是一个示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similarly, you can use the `Emp` class to be passed in a message, sent over
    the network, inserted into a JSON object, and more.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以使用`Emp`类来传递消息，通过网络发送，插入到JSON对象中，等等。
- en: All of this looks good. Most importantly, it has been working fine since Java
    was introduced to developers. So, what is the problem?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都看起来很好。最重要的是，自从Java被引入开发者以来，它一直运行良好。那么，问题是什么？
- en: The need to add data classes to the language
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在语言中添加数据类的需求
- en: Imagine securing the borders of a country, which are normally guarded by defense
    forces. Will the level of security change based on the relationships with the
    neighboring countries (cordial, neutral, or tense)? What happens if the borders
    are porous (for example, the borders in Western Europe, for the Schengen countries)?
    Now, compare guarding the borders of a country with guarding our homes or securing
    the contents of a cabinet in a room.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下保卫一个国家的边境，这些边境通常由防御部队守卫。安全水平是否会根据与邻国的（友好、中立或紧张）关系而改变？如果边境是渗透性的（例如，西欧的边境，对于申根国家而言），会发生什么？现在，比较保卫一个国家的边境与保卫我们的家园或确保房间内柜子的内容安全。
- en: Although each instance in the preceding example concerns the security of an
    entity and its protection from a physical attack, the instances have varying requirements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前一个示例中的每个实例都涉及实体的安全及其对物理攻击的保护，但这些实例有不同的需求。
- en: Similarly, until now, the classes in Java have been used to model a wide range
    of requirements. While this works well for a lot of cases, it doesn't work for
    some. If you want to make the same size fit all, you'll need a lot of adjustments,
    for most of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，到目前为止，Java中的类被用来模拟广泛的需求。虽然这对于很多情况来说效果很好，但对于某些情况则不适用。如果你想使所有大小都适合，你需要做很多调整，对于大多数情况来说。
- en: 'Compare this to using the same trouser size for individuals with varying heights
    and waist sizes, as shown in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下图中所示的使用相同裤子尺寸来适应不同身高和腰围的人进行比较：
- en: '![](img/ff9fc26c-c236-4f13-864d-12e26d343d9d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff9fc26c-c236-4f13-864d-12e26d343d9d.png)'
- en: In the past, enums were added to the Java language (version 5). Even though
    a class can be programmed to create an enumeration of primitives or objects, enums
    simplified the process for a developer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，枚举被添加到Java语言中（版本5）。尽管可以通过编程创建原始类型或对象的枚举，但枚举简化了开发者的过程。
- en: Enums reduced the coding for developers. At the same time, they made the intent
    of each enum explicit to the users.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举减少了开发者的编码工作。同时，它们使每个枚举的意图对用户来说更加明确。
- en: In the preceding section, the `Emp` POJO is just a carrier of its data. However,
    seasoning a class to behave like a data class requires a developer to define multiple
    methods—constructs, accessors, mutators, and other methods from the object class.
    You might argue that you can use an IDE to easily generate all of these methods
    for your class. You are right! And it's quite simple to do so.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，`Emp` POJO只是一个其数据的载体。然而，要让一个类表现得像数据类，需要开发者定义多个方法——构造函数、访问器、修改器以及来自对象类的其他方法。你可能会争辩说，你可以使用IDE轻松地为你的类生成所有这些方法。你说得对！这样做很简单。
- en: However, that only takes care of the writing part of the code. What happens
    to the reading part of the code, for the users of the class? Us developers understand
    that a piece of code might be written just once, but will be read multiple times.
    That is why experienced programmers stress good coding practices, for comprehending,
    reading, and maintaining code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅仅解决了代码的编写部分。对于类的用户来说，代码的阅读部分会发生什么？我们这些开发者明白，一段代码可能只写一次，但会被阅读多次。这就是为什么经验丰富的程序员强调良好的编码实践，以便理解、阅读和维护代码。
- en: When the definition of data classes is induced in the language, the readers
    of the code will know its explicit intent of being a data class. The developers
    need not dig their claws deep into finding the code that was in addition to being
    a data class, so that they don't miss any important information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当语言中引入数据类的定义时，代码的读者将知道其作为数据类的明确意图。开发者不需要深入挖掘以找到除了是数据类之外还包含的代码，这样他们就不会错过任何重要信息。
- en: This will also prevent the developers from using half-baked classes as data
    classes. At times, developers use such classes as a data class, which do not include
    all of the relevant methods (such as `equals()` or `hashCode()`). This will surely
    lead to inserting subtle bugs in your applications. A collection class, such as `Map`,
    requires a class to implement its `equals()` and `hashCode()` methods to function
    properly and efficiently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将防止开发者使用半成品的类作为数据类。有时，开发者会将这样的类用作数据类，而这些类并不包含所有相关的方法（例如`equals()`或`hashCode()`）。这无疑会导致在应用程序中插入微小的错误。例如，`Map`这样的集合类需要类实现其`equals()`和`hashCode()`方法才能正常高效地工作。
- en: Introducing data classes with a change in the language would decrease the verbosity
    of the language, broadcasting the intent of the structure to all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过语言的变化引入数据类将减少语言的冗长，将结构的意图广播给所有人。
- en: Diving into data classes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入数据类
- en: The syntax to define a data class looks simple. However, both the syntax and
    semantics are important. Let's get started by looking at some examples, in the
    following sections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义数据类的语法看起来很简单。然而，语法和语义都很重要。让我们通过查看以下章节中的示例来开始。
- en: Example of syntax and semantics
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法和语义示例
- en: 'Let''s redefine the `Emp` class, which we used at the beginning of the chapter,
    as a data class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新定义本章开头使用的`Emp`类，将其作为数据类：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code uses the `record` keyword to define a data class, accepting
    a comma-separated variable `name` and type, required to store the state. The compiler
    automatically generates default implements for the object methods (`equals()`,
    `hashCode()`, and `toString()`) for data classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`record`关键字来定义数据类，接受逗号分隔的变量`name`和类型，这些变量是存储状态所必需的。编译器会自动为数据类生成对象方法的默认实现（`equals()`、`hashCode()`和`toString()`）。
- en: The code looks clear and compact. A reader would immediately know the intent
    of this single line of code—a carrier of the data `name` (type `String`) and `age`
    (type `int`). Another advantage for a reader is that they wouldn't have to read
    through constructors, accessors, mutators, or methods of the object class, just
    to ascertain that they are doing what they are supposed to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来清晰且紧凑。读者会立即知道这一行代码的意图——携带数据`name`（类型`String`）和`age`（类型`int`）。对于读者来说，另一个优点是他们不必阅读构造函数、访问器、修改器或对象类的方法，只需确认他们正在做他们应该做的事情。
- en: 'Behind the scenes, the record class, `Emp`, is converted to the following code
    by the Java compiler:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Java编译器将记录类`Emp`转换为以下代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding data class is an example of a non-abstract data class. A data
    class can also be defined as an abstract data class. A non-abstract data class
    is implicitly final. In both cases, a data class will get default implementations
    of `hashCode()`, `equals()`, and `toString()`, and accessor methods. For an abstract
    data class, the constructors would be protected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数据类是一个非抽象数据类的示例。数据类也可以定义为抽象数据类。非抽象数据类隐式地是最终的。在两种情况下，数据类都将获得`hashCode()`、`equals()`和`toString()`以及访问器方法的默认实现。对于抽象数据类，构造函数将是受保护的。
- en: 'In the following diagram, the compiler looks happy to convert the one line
    code for the data class to a full-fledged class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，编译器看起来很高兴将数据类的单行代码转换为完整的类：
- en: '![](img/597d2162-3fb1-4aa5-8812-2e596c742a27.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/597d2162-3fb1-4aa5-8812-2e596c742a27.png)'
- en: By default, a data class is `final`; you can't extend it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数据类是`final`的；你不能扩展它。
- en: The aggregate and exploded forms of data classes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类的聚合形式和展开形式
- en: The aggregate form of a data class will be the name of the data class. Its exploded
    form would refer to the variables used to store its data. The conversion from
    aggregate to exploded form is referred to as the **deconstruction pattern**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的聚合形式将是数据类的名称。其展开形式将指用于存储其数据的变量。从聚合形式到展开形式的转换被称为**解构模式**。
- en: 'The following code refers to the example that we used in the preceding section:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码引用了我们在上一节中使用的示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Emp` is the aggregate form of the `Emp` data class. Its exploded form would
    be `String name` and `int age`. The language would need easy conversion between
    the two, so that they can be used with other language constructs, such as `switch`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emp`是`Emp`数据类的聚合形式。其展开形式将是`String name`和`int age`。语言需要在这两者之间提供简单的转换，以便它们可以与其他语言构造一起使用，例如`switch`。'
- en: Limitations
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局限性
- en: When you use the `record` keyword to define your data class, you'll be limited
    by what the language allows you to do. You'll no longer have fine control over
    whether your data class is extensible, whether its state is mutable, the range
    of values that can be assigned to your fields, the accessibility to your fields,
    and so on. You might also be limited when it comes to having additional fields
    or multiple constructors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`record`关键字来定义你的数据类时，你将受到语言允许你做什么的限制。你将不再能够精细控制你的数据类是否可扩展，其状态是否可变，可以分配给字段值的范围，字段的可访问性等等。在添加额外字段或多个构造函数方面，你也可能受到限制。
- en: Data classes are still in progress at Oracle. The finer details are still being
    worked on. In March 2018, the `datum` keyword was used to define a data class
    but has now been changed to `record`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类在Oracle中仍在开发中。更详细的内容仍在完善中。2018年3月，`datum`关键字被用来定义数据类，但现在已改为`record`。
- en: Nowadays, developers aren't limited to working with a single programming language.
    Java programmers usually work with or are aware of, other programming languages
    that work on the JVM, such as Scala, Kotlin, or Groovy. The experience of working
    with varied languages brings a lot of expectations and assumptions about the capabilities
    and limitations of the data classes (defined using `record`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开发者不再局限于使用单一编程语言。Java程序员通常与或了解在JVM上工作的其他编程语言，例如Scala、Kotlin或Groovy。使用不同语言的经验带来了许多对数据类（使用`record`定义）的能力和限制的期望和假设。
- en: Examples from the past – changes to define enums
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过去的一些例子——定义枚举的变化
- en: 'Prior to the introduction of enums, developers often used `public`, `static`,
    and `final` variables to define constants. The following is an example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举引入之前，开发者经常使用`public`、`static`和`final`变量来定义常量。以下是一个示例：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The major drawback of using `public`, `static`, `final`, and `int` variables
    is type safety; any `int` value could be assigned to a variable of the type `int`,
    instead of the `Size.SMALL`, `Size.MEDIUM`, or `Size.LARGE` constants.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`public`、`static`、`final`和`int`变量的主要缺点是类型安全；任何`int`值都可以分配给类型为`int`的变量，而不是`Size.SMALL`、`Size.MEDIUM`或`Size.LARGE`常量。
- en: 'Java 5 introduced enums, an addition to the language construct, to enable developers
    to define an enumeration of constants. Here''s a quick example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5引入了枚举，这是一种语言结构的补充，使开发者能够定义常量的枚举。以下是一个快速示例：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With a variable of the type `Size`, an assignment is limited to the constants
    defined in `Size`. An enum is a perfect example of how language can simplify the
    implementation of a model, at the cost of certain constraints. Enums limit the
    extensibility to interfaces. Other than that, enums are full-fledged classes.
    As a developer, you can add states and behaviors to them. Another benefit is that
    an enum can also `switch` constructs, which was previously limited to primitives
    and a `String` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型为`Size`的变量，赋值仅限于`Size`中定义的常量。枚举是语言如何简化模型实现的一个完美例子，代价是某些约束。枚举限制了接口的可扩展性。除此之外，枚举是完整的类。作为开发者，你可以向它们添加状态和行为。另一个好处是枚举也可以使用`switch`构造，这之前仅限于原始类型和`String`类。
- en: A new language construct is like a new human relationship, biological or otherwise.
    It has its own share of joys and sorrows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语言结构就像是一种新的人类关系，无论是生物的还是其他类型的。它有自己的快乐和悲伤。
- en: Pattern matching with data classes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据类的模式匹配
- en: 'When you define your data classes using the `record` keyword, you get the added
    advantage of the conversion of aggregate and exploded forms of your data class.
    For example, the following code shows how the `switch` statement might explode
    the data:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`record`关键字定义你的数据类时，你将获得转换数据类聚合和展开形式的额外优势。例如，以下代码展示了`switch`语句如何展开数据：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `switch` statement can use a data class, without using its exploded form.
    The following code is also effective:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句可以使用数据类，而不使用其展开形式。以下代码也是有效的：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Encapsulating the state
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装状态
- en: The record classes encapsulate the fields, providing default implementations
    of JavaBean-style accessor methods (public methods to set the values of fields).
    The values can be assigned during the initialization of data class instances,
    using their constructors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类封装字段，提供JavaBean风格的访问器方法的默认实现（设置字段值的公共方法）。值可以在数据类实例的初始化期间分配，使用它们的构造函数。
- en: 'For example, let''s revisit the `Emp` data class and its decompiled version
    from a previous section:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回顾一下前一个部分中的`Emp`数据类及其反编译版本：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Abstract and non-abstract data classes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象和非抽象数据类
- en: 'Data classes can be abstract or non-abstract. An abstract data class is defined
    by using the keyword `abstract` in its declaration. As an abstract class, you
    can''t use abstract data classes directly. Here''s an example of an abstract data
    class, `JVMLanguage`, and a non-abstract data class, `Conference`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可以是抽象的或非抽象的。一个抽象数据类是通过在其声明中使用`abstract`关键字来定义的。作为一个抽象类，你不能直接使用抽象数据类。以下是一个抽象数据类`JVMLanguage`和一个非抽象数据类`Conference`的示例：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Data classes and inheritance
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类和继承
- en: 'Currently, the proposal is to drop the following inheritance cases:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，建议取消以下继承情况：
- en: A data class extends a regular class
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类可以扩展普通类
- en: A regular class extends a data class
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通类可以扩展数据类
- en: A data class extends another data class
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类扩展了另一个数据类
- en: 'Allowing for any of the preceding cases would violate the contract of a data
    class being a carrier of data. At present, the following restrictions are proposed
    for data classes and inheritance, with interfaces and abstract data classes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 允许上述任何一种情况都会违反数据类作为数据载体的契约。目前，针对数据类和继承、接口以及抽象数据类，提出了以下限制：
- en: Non-abstract and abstract data classes can extend other abstract data classes
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非抽象和抽象数据类可以扩展其他抽象数据类
- en: An abstract or non-abstract data class can extend any interface
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象或非抽象数据类可以扩展任何接口
- en: 'The following figure sums up these inheritance rules:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图总结了这些继承规则：
- en: '![](img/068c5647-5d02-4461-907a-d2f6da929031.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/068c5647-5d02-4461-907a-d2f6da929031.png)'
- en: Let's get started by extending an abstract data class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从扩展一个抽象数据类开始。
- en: Extending an abstract data class
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展一个抽象数据类
- en: 'In the following example, the `Emp` abstract data class is being extended by
    the non-abstract `Manager` data class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Emp` 抽象数据类正被非抽象的 `Manager` 数据类扩展：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a non-abstract data class extends an abstract data class, it accepts all
    of the data in its header—the ones that are required for itself, and for its base
    class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当非抽象数据类扩展抽象数据类时，它接受其头部的所有数据——那些为自己和其基类所必需的。
- en: A data class can extend a single abstract data class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可以扩展单个抽象数据类。
- en: Implementing interfaces
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: 'A data class can implement an interface and its abstract methods, or just inherit
    its default methods. The following is an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可以实现接口及其抽象方法，或者只是继承其默认方法。以下是一个示例：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code defines a tagging interface, `Organizer` (without any methods),
    and an interface, `Speaker`, with an abstract method, `conferenceTalk()`. We have
    two cases, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个标记接口 `Organizer`（没有方法）和一个具有抽象方法 `conferenceTalk()` 的接口。我们有以下两种情况：
- en: A data class extending another data class, implementing an interface—the data
    class `Manager` extends the abstract `Emp` data class and implements the `Organizer` interface.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展另一个数据类并实现接口的数据类——`Manager` 数据类扩展了抽象的 `Emp` 数据类并实现了 `Organizer` 接口。
- en: A data class extending another data class and implementing multiple interfaces—the `Programmer` 
    data class extends the abstract `Emp` data class and implements two interfaces—`Organizer`
    and `Speaker`. The `Programmer` data class must implement the abstract `conferenceTalk()`
    method from the `Speaker` interface  to qualify as a non-abstract data class.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展另一个数据类并实现多个接口的数据类——`Programmer` 数据类扩展了抽象的 `Emp` 数据类并实现了两个接口——`Organizer` 和
    `Speaker`。`Programmer` 数据类必须实现 `Speaker` 接口中的抽象 `conferenceTalk()` 方法，才能作为非抽象数据类。
- en: A data class can implement a single or multiple interfaces.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可以实现单个或多个接口。
- en: Additional variables
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外变量
- en: 'Although it is allowed, before adding variables or fields to a data class,
    ask yourself, *Are the fields derived from the state?* Fields that are not derived
    from the state pose a serious violation of the initial concept of the data classes.
    The following code is an example that defines an additional field, `style`, derived
    from the state of the `Emp` data class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是允许的，但在向数据类添加变量或字段之前，请自问，*字段是否来自状态？* 不是来自状态的字段会对数据类初始概念的严重违反。以下代码是一个定义额外字段
    `style` 的示例，该字段来自 `Emp` 数据类的状态：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code works well because the state of the `Emp` data class is still
    derived from its state (the `name` and `age` fields). The `getStyle` method doesn't
    interfere with the state of `Emp`; it is purely an implementation detail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码运行良好，因为 `Emp` 数据类的状态仍然来自其状态（`name` 和 `age` 字段）。`getStyle` 方法不会干扰 `Emp` 的状态；它纯粹是实现细节。
- en: Overriding implicit behaviors
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖隐式行为
- en: 'Suppose that you want to limit the values that can be passed to a field in
    your data class during its instantiation. This is feasible; just override the
    default constructor. The following is an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要限制在数据类实例化期间可以传递给字段的值。这是可行的；只需覆盖默认构造函数。以下是一个示例：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similarly, you can override the default implementations of object methods, such
    as `equals()`, `hashCode()`, and `toString()`, and other methods, such as the
    accessor methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以覆盖对象方法的默认实现，例如 `equals()`、`hashCode()` 和 `toString()`，以及其他方法，如访问器方法。
- en: Overriding the default behaviors of the methods of your data class doesn't defeat
    the purpose of their creation. They are still working as data classes, with finer
    control of their functionality. Let's compare this with POJOs, which were used
    to model data classes previously. The compiler doesn't auto-generate any methods
    for a POJO. So, a user still needs to read all of the code, looking for code that
    isn't the default implementation of its methods. In the case of data classes,
    this overridden behavior is very explicit. So, a user doesn't have to worry about
    reading all of the code; they can assume default implementation of the behavior,
    which hasn't been overridden by the developer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖数据类方法的默认行为并不会削弱其创建的目的。它们仍然作为数据类工作，对它们的功能有更精细的控制。让我们将其与之前用于建模数据类的POJOs进行比较。编译器不会为POJO自动生成任何方法。因此，用户仍然需要阅读所有代码，寻找不是其方法默认实现的代码。在数据类的情况下，这种覆盖行为非常明确。因此，用户不必担心阅读所有代码；他们可以假设行为有默认实现，而这种实现尚未被开发者覆盖。
- en: Overriding behavior explicitly states the places where a data class diverts
    from its default behavior, reducing the amount of code that must be read by a
    user to understand its behavior.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 明确地覆盖行为说明了数据类偏离其默认行为的地方，从而减少了用户为了理解其行为而必须阅读的代码量。
- en: Additional methods and constructors
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的方法和构造函数
- en: 'The compiler generates a default constructor for a data class, along with accessor
    methods and the default implementation of the methods from the object class. A
    developer can overload the constructors and add more methods to a data class,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为数据类生成默认构造函数，以及访问器方法和对象类方法的默认实现。开发者可以重载构造函数并向数据类添加更多方法，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Mutability
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性
- en: Concerning whether the data classes should be designated as mutable or immutable,
    work is still in progress. Both options have advantages and disadvantages. Immutable
    data works well in multithreaded, parallel, or concurrent systems. On the other
    hand, mutable data works well with cases that require frequent modifications to
    data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据类是否应指定为可变或不可变，工作仍在进行中。两种选项都有优点和缺点。不可变数据在多线程、并行或并发系统中表现良好。另一方面，可变数据在需要频繁修改数据的情况中表现良好。
- en: Concerning thread safety, since the data classes are not yet designated to be
    immutable, it is the responsibility of the developers to use them in thread-safe
    configurations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程安全，由于数据类尚未指定为不可变，使用它们进行线程安全配置是开发者的责任。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the challenges of using POJOs to model data. We
    covered how data classes provide a simple and concise way to model data. Implementation
    of data classes will include language changes, with the introduction of the `record` keyword.
    The main goal of using data classes is to model data as data, not to reduce the
    boilerplate code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用POJOs来建模数据的挑战。我们介绍了数据类如何提供一种简单且简洁的方式来建模数据。数据类的实现将包括语言的变化，引入`record`关键字。使用数据类的主要目标是建模数据，而不是减少样板代码。
- en: We also covered the aggregate and exploded forms of data classes. The data classes
    can be used with other language constructs, such as `switch`. By default, the
    data classes are not mutable, including the arrays defined as the data members.
    Since these structures are not immutable, a developer must include code to ensure
    thread safety when working with them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了数据类的聚合和展开形式。数据类可以与其他语言结构一起使用，例如`switch`。默认情况下，数据类是不可变的，包括定义为数据成员的数组。由于这些结构不是不可变的，开发者在处理它们时必须包含代码以确保线程安全。
- en: In the next chapter, you'll learn more about an exciting language enhancement—raw
    string literals. Does this mean a pure, or untouched, string? Find out for yourself
    by reading on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解更多关于一个令人兴奋的语言增强功能——原始字符串字面量。这难道意味着一个纯净的、未触动的字符串吗？通过继续阅读来找出答案。
