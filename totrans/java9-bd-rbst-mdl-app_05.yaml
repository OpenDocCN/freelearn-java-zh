- en: Building Modular Applications with Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we covered changes in Java 9 with regards to variable handlers
    and how they related to the AtoMiC Toolkit. We also covered depreciation warnings
    and why they are now suppressed under specific circumstances. Five enhancements
    to changes introduced with Java 7 as part of *Project Coin* were also reviewed.
    Finally, we explored the improvements to import statement processing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine the structure of a Java module as specified
    by *Project Jigsaw*. We will take a deep-dive into how *Project Jigsaw* is implemented
    as part of the Java platform. We will also review key internal changes to the
    Java platform as they relate to the modular system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover here are:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Java modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review of the Java platform's module system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing JDK source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular runtime images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the module system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular Java application packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java linker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation of internal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modular primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the Java 9 enhancements in this chapter, let's examine what
    modularity is in the context of Java.
  prefs: []
  type: TYPE_NORMAL
- en: We can define the term **modular** as a type of design or construction, in our
    context, of computer software. This type of software design involves a set of
    modules that collectively comprise the whole. A house, for example, can be built
    as a single structure or in a modular fashion where each room is constructed independently
    and joined to create a home. With this analogy, you could selectively add or not
    add modules in the creation of your home. The collection of modules, in our analogy,
    becomes the design of your home. Your design does not need to use every module,
    only the ones you want. So, for example, if there are basement and bonus room
    modules and your design does not include those modular rooms, those modules are
    not used to build your home. The alternative would be that every home would include
    every room, not just the ones that are used. This, of course, would be wasteful.
    Let's see how that correlates to software.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept can be applied to computer architecture and software systems.
    Our systems can be comprised of several components instead of one behemoth system.
    As you can likely imagine, this provides us with some specific benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: We should be able to scale our Java applications to run on small devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our Java applications will be smaller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our modular code can be more targeted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased use of the object-oriented programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional opportunities for encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code will be more efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java applications will have increased performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall system complexity is reduced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and debugging is easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code maintenance is easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shift to a modular system for Java was necessary for several reasons. Here
    are the primary conditions of the Java platform as of Java 9 that led to the creation
    of the module system for the Java 9 platform:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Development Kit** (**JDK**) was simply too big. This made it difficult
    to support small devices. Even with the compact profiles discussed in the next
    section, supporting some small devices was difficult at best and, in some cases,
    not possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the over-sized JDK, it was difficult to support truly optimized performance
    with our Java applications. In this case, smaller is better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java Runtime Environment** (**JRE**) was too large to efficiently test
    and maintain our Java applications. This results in time consuming, inefficient
    testing, and maintenance operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java Archive** (**JAR**) files were also too large. This made supporting
    small devices problematic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the JDK and JRE were all encompassing, security was of great concern.
    Internal APIs, for example, that were not used by the Java application, were still
    available due to the nature of the public access modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, our Java applications were unnecessarily large.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modular systems have the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: There must be a common interface to permit interoperability among all connected
    modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolated and connected testing must be supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile time operations must be able to identify which modules are in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime support for modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A module is a new concept and component in Java 9; it is a named collection
    of data and code. Specifically, modules are a collection of:'
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Key to successful implementation, a module in Java 9 is self-described in its
    modular declaration. Module names must be unique and typically use the reverse
    domain name schema. Here is an example declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Module declarations are contained in a `module-info.java` file that should be
    in the module's root folder. As one might expect, this file is compiled into a
    `module-info.class` file and will be placed in the appropriate output directory.
    These output directories are established in the module source code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will look at specific changes for Java 9 in regards
    to modularity.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Java's platform module system [JEP-200]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core aim of JEP-200 was to modularize the **Java Development Kit** (**JDK**)
    using the **Java Platform Module System** (**JPMS**). Prior to Java 9, our familiarity
    with the JDK includes awareness of its major components:'
  prefs: []
  type: TYPE_NORMAL
- en: Java runtime environment (JRE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter (java)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler (javac)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The archiver (jar)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document generator (javadoc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The task of modularizing the JDK was to break it into components that could
    be combined at compile time or runtime. The modular structure is based on the
    following modular profiles established as compact profiles in Java 8\. Each of
    the three profiles is detailed in the following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compact profile 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `java.io` | `java.lang.annotation` | `java.lang.invoke` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.ref` | `lava.lang.reflect` | `java.math` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.net` | `java.nio` | `java.nio.channels` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.nio.channels.spi` | `java.nio.charset` | `java.nio.charset.spi` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.nio.file` | `java.nio.file.attribute` | `java.nio.file.spi` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.security` | `java.security.cert` | `java.security.interfaces` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.security.spec` | `java.text` | `java.text.spi` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time` | `java.time.chrono` | `java.time.format` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.temporal` | `java.time.zone` | `java.util` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent` | `java.util.concurrent.atomic` | `java.util.concurrent.locks`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.function` | `java.util.jar` | `java.util.logging` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.regex` | `java.util.spi` | `java.util.stream` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.zip` | `javax.crypto` | `javax.crypto.interfaces` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.crypto.spec` | `javax.net` | `javax.net.ssl` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.script` | `javax.security.auth` | `javax.security.auth.callback` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.security.auth.login` | `javax.security.auth.spi` | `javax.security.auth.spi`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.security.auth.x500` | `javax.security.cert` |  |'
  prefs: []
  type: TYPE_TB
- en: '**Compact profile 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `java.rmi` | `java.rmi.activation` | `java.rmi.dgc` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.rmi.registry` | `java.rmi.server` | `java.sql` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.rmi.ssl` | `javax.sql` | `javax.transaction` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.transaction.xa` | `javax.xml` | `javax.xml.database` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.xml.namespace` | `javax.xml.parsers` | `javax.xml.stream` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.xml.stream.events` | `javax.xml.stream.util` | `javax.xml.transform`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.xml.transform.dom` | `javax.xml.transform.sax` | `javax.xml.transform.stax`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.xml.transform.stream` | `javax.xml.validation` | `javax.xml.xpath`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.w3c.dom` | `org.w3c.dom.bootstrap` | `org.w3c.dom.events` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.w3c.dom.ls` | `org.xml.sax` | `org.xml.sax.ext` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.xml.sax.helpers` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '**Compact profile 3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `java.lang.instrument` | `java.lang.management` | `java.security.acl` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.prefs` | `javax.annotation.processing` | `javax.lang.model` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.lang.model.element` | `javax.lang.model.type` | `javax.lang.model.util`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.management` | `javax.management.loading` | `javax.management.modelmbean`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.management.monitor` | `javax.management.openmbean` | `javax.management.relation`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.management.remote` | `javax.management.remote.rmi` | `javax.management.timer`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.naming` | `javax.naming.directory` | `javax.naming.event` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.naming.ldap` | `javax.naming.spi` | `javax.security.auth.kerberos`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.security.sasl` | `javax.sql.rowset` | `javax.sql.rowset.serial` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.sql.rowest.spi` | `javax.tools` | `javax.xml.crypto` |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.xml.crypto.dom` | `javax.xml.crypto.dsig` | `javax.xml.crypto.dsig.dom`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.xml.crypto.dsig.keyinfo` | `javax.xml.crypto.dsig.spec` | `org.ieft.jgss`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The three compact module profiles represent the basis for the standardized
    modular system in Java 9\. The effectiveness of this standardization relies on
    the following six principles:'
  prefs: []
  type: TYPE_NORMAL
- en: All JCP-governed modules must start with the string `java.`. So, if a module
    on spatial utilities was being developed it would have a name such as `java.spatial.util`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JCP** refers to the **Java Community Process**. JCP allows developers to
    create technical specifications for Java. You can learn more about JCP and become
    a member at the official JCP website--[http://www.jcp.org](http://www.jcp.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Non-JCP modules are considered part of the JDK and their names must start with
    the string `jdk.`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensure method invocation chaining works properly. This is best illustrated
    with the following flowchart:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/88848edf-300b-4222-920c-d507982fd6a8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding flowchart, it only applies to modules that export
    a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth principle deals with both standard and non-standard API packages
    being used in a standard module. The following flowchart illustrates the implementation
    of this principle''s covenants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/725694d1-88e1-4bc1-8295-e3b852a7c67c.png)'
  prefs: []
  type: TYPE_IMG
- en: The fifth design principle is that standard modules can be dependent upon more
    than one non-standard module. While this dependency is permitted, implied readability
    access to non-standard modules is not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final design principle ensures non-standard modules do not export standard
    API packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing JDK source code [JEP-201]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, Project Jigsaw had the goal of modularization. The
    envisioned standard modular system would be applied to the Java SE platform and
    the JDK. In addition to efficiency gains, the modular shift would result in better
    security and ease maintainability. The enhancement detailed in JEP-201 focused
    on JDK source code reorganization. Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reorganizing the JDK''s source code is a significant task and was accomplished
    with the following subset of goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide JDK developers insights and familiarity with the new Java 9 modular
    system. So, this goal was aimed at developers of the JDK, not mainstream developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure modular boundaries are established and maintained throughout the JDK
    build process. This was a necessary precaution so the modular system would be
    stable throughout Java 9's enhancements and, more specifically, in implementing
    the modular system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third goal was to ensure future enhancements, specifically with *Project
    Jigsaw*, could be easily integrated into the new modular system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significance of this source code reorganization cannot be overstated. The
    pre-Java 9 source code organization is 20 years old. This overdue JDK source code
    reorganization will make the code much easier to maintain. Let's look at the previous
    organization of the JDK source code and then examine the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-Java 9 JDK source code organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JDK is a compilation of code files, tools, libraries, and more. The following
    illustration provides an overview of the JDK components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64a9f5ea-6310-4974-9517-b2b66c1ea67e.png)'
  prefs: []
  type: TYPE_IMG
- en: The pre-Java 9 organization of the JDK components in the preceding illustration
    are detailed in the next seven subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development tools are located in the `bin` directory. These tools include
    seven broad categorizations, each detailed in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a set of tools intended to help deploy Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appletviewer`: This tool gives you the ability to run and debug Java applets
    without the need for a web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extcheck`: This tool allows you to find conflicts in JAR files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar`: This tool is used for creating and manipulating JAR files. JAR files
    are Java Archive files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java`: This is the Java application launcher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javac`: This is the Java Compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javadoc`: This tool generates API documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javah`: This tool allows you to write native methods; it generates C header
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javap`: This tool disassembles class files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javapackager`: For signing and packaging Java applications, including JavaFX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdb`: This is the Java debugger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdeps`: This is an analyzer for Java class dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pack200`: This is a tool that compresses JAR files into `pack200` files. The
    compression ratio using this tool is impressive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unpack200`: This tool unpacks `pack200` files resulting in JAR files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in creating localizable applications, the following tool
    might come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`native2ascii`: This tool creates Unicode Latin-1 from normal text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Monitoring tools used for providing JVM performance data include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jps`: This is the **JVM process status tool** (**jps**). It provides a list
    of HotSpot JVMs on a specific system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jstat`: This is the JVM statistics monitoring tool. It collects log data and
    performance information from a machine with a HotSpot JVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jstatd`: This is the **jstat** daemon tool. It runs an RMI server app for
    monitoring HotSpot JVM operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RMI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RMI** tools are **Remote Method Invocation** tools. They help developers
    create applications that operate over a network to include the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rmic`: This tool can generate stubs and skeletons for objects over a network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rmiregistry`: This is a registry service for remote objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rmid`: This tool is an activation system daemon for RMI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialver`: This tool returns the class `serialVersionUID` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This set of security tools empowers developers to create security policies
    that can be enforced on the developer''s computer system as well as on remote
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keytool`: This tool manages security certificates and keystores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jarsigner`: This tool generates and verifies JAR signatures for creating/opening
    JAR files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`policytool`: This tool has a graphical user interface that helps developers
    manage their security policy files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These experimental troubleshooting tools are useful for very specific troubleshooting.
    They are experimental and, therefore, not officially supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jinfo`: This tool provides configuration information for specific processes,
    files, or servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jhat`: This is a heap dump tool. It instantiates a web server so that a heap
    can be viewed with a browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jmap`: This displays heap and shared object memory maps from a process, file,
    or server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsadebugd`: This is Java''s Serviceability Agent Debug Daemon. It acts as
    a debug server for a process or file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jstack`: This is a Java Stack Trace tool that provides a thread stack trace
    for a process, file, or server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This set of tools provides a utility that can be used with **Java Web Start**
    and other web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javaws`: This is a command line tool that launches Java Web Start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schemagen`: This tool generates schemas for Java architecture. These schemas
    are used for XML binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsgen`: This tool is used for generating JAX-WS artifacts that are portable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsimport`: This tool is used for importing portable JAX-WS artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xjc`: This is the binding compiler that is used for XML binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaFX tools are located in a few different places including `bin`, `man`,
    and `lib` directories.
  prefs: []
  type: TYPE_NORMAL
- en: Java runtime environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java runtime environment** (**JRE**) is located in the `jre` directory.
    Key contents include the **Java Virtual Machine** (**JVM**) and class libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JDK''s source code, pre-Java 9, has the following basic organizational
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at this a bit closer. After the source code, we have two options.
    If the code is cross-platform, then it is a shared directory; otherwise, it is
    operating system specific. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the classes directory or a native language directory. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the name of the Java API package followed by the file extension.
    The file extensions depend on content such as `.java`, `.c`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lib` directory houses class libraries that are needed by one or more of
    the development tools in the `bin` directory. Here is a list of files in a typical
    Java 8 `lib` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e67259d8-c847-4cec-b143-ad635911a3e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Reviewing the directory listing does not provide a great level of granular
    insight. We can list the classes contained in any of the `.jar` files with the
    following command--`jar tvf fileName.jar`. As an example, here is the class listing
    generated from executing `jar tvf javafx-mx.jar` at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff17c34-02a8-49c6-9f3c-76cf6253473d.png)'
  prefs: []
  type: TYPE_IMG
- en: C header files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `/include` directory contains C header files. These files primarily support
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Native Interface** (**JNI**): This is used for native-code programming
    support. The JNI is used to embed Java native methods and the JVM into native
    apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVM Tool Interface** (**JVM TI**): This is used by tools for state inspections
    and execution control for apps running the JVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Apache Derby relational database is stored in the `/db` directory. You
    can learn more about Java DB at the following sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javadb/support/overview.html](http://docs.oracle.com/javadb/support/overview.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://db.apache.org/derby/manuals/#docs_10.11](http://db.apache.org/derby/manuals/#docs_10.11)'
  prefs: []
  type: TYPE_NORMAL
- en: JDK source code reorganized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a previous section, you learned that the pre-Java 9 source code organization
    schema was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java 9, we have a new modular schema. That schema follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are a few differences in the new schema, most notably the module name.
    After the shared or OS-specific directory, there is either the classes directory,
    the native directory for C or C++ source files, or a configuration directory.
    This seemingly rudimentary organization schema changes results in a much more
    maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modular run-time images [JEP-220]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 9''s modular system required changes to the runtime images for compatibility.
    Benefits of these changes include enhancements in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core to these changes was a new URI schema used for resource naming. These resources
    include modules and classes.
  prefs: []
  type: TYPE_NORMAL
- en: A **Uniform Resource Identifier** (**URI**) is similar to a **URL** (**Uniform
    Resource Locator**) in that it identifies the name and location of something.
    For a URL, that something is a web page; for a URI, it is a resource.
  prefs: []
  type: TYPE_NORMAL
- en: There were five primary goals for JEP-220 and these are detailed in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime format adoption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A run-time format was created for Java 9, for adoption by stored classes and
    other resource files. This format is applicable for stored classes and resources
    under the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: When the new run-time format has greater efficiencies (time and space) than
    the pre-Java 9 JAR format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **JAR** file is a **Java ARchieve** file. This is a compressed file format
    based on the legacy ZIP format.
  prefs: []
  type: TYPE_NORMAL
- en: When stored classes and other resources can be individually isolated and loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When JDK and library classes and resources can be stored. This includes app
    modules as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When they are devised in such a way as to promote future enhancements. This
    requires them to be extensible, documented, and flexible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime image restructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of runtime images in Java--JDK and JRE. With Java 9, both
    of these image types were restructured to differentiate between files that can
    be used and modified by users to internal files that can be used but not modified
    by developers and their apps.
  prefs: []
  type: TYPE_NORMAL
- en: The JDK build system, prior to Java 9, produces both a JRE and a JDK. The JRE
    is a complete implementation of the Java platform. The JDK includes the JRE as
    well as other tools and libraries. A notable change in Java 9 is that the JRE
    subdirectory is no longer part of the JDK image. This change was made, in part,
    to ensure both image types (JDK and JRE) have identical image structures. With
    a common and reorganized structure, future changes will be more efficiently integrated.
  prefs: []
  type: TYPE_NORMAL
- en: If you created custom plugins prior to Java 9 that address a specific structure,
    your app might not work in Java 9\. This is also true if you are explicitly addressing
    `tools.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides a high-level view of the contents of each image
    before Java 9''s release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb499c12-6ba9-4a59-b68e-2745b1118f0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Java 9 runtime images are illustrated in the following diagram. As shown,
    a full JDK image contains the same directories as a modular runtime image as well
    as demo, sample, man, and includes directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7a55d59-4214-487a-a0ac-b4868a1d56d8.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no longer a difference between a JRE or JDK image. Now, with Java 9,
    a JDK image is a JRE image that contains a full set of dev tools.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting common operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers occasionally must write code that performs operations requiring access
    to the runtime image. Java 9 includes support for these common operations. This
    is possible due to the restructuring and standardized JDK and JRE runtime image
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: De-privileging JDK classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 allows privilege revocation for individual JDK classes. This change strengthens
    system security in that it ensures JDK classes only receive the permissions required
    for system operations.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving existing behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final goal of the JEP-220 was to ensure currently existing classes are not
    negatively impacted. This refers to applications that do not have dependencies
    on internal JDK or JRE runtime images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the module system [JEP-261]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of this JEP was the implementation of the new module system for
    the Java platform. You will recall that the modular system was created to provide
    reliable configuration and strong encapsulation for Java programs. Key to this
    implementation was the concept of link time. As illustrated here, link time is
    an optional phase in between compile time and runtime. This phase allows the assembly
    of the appropriate modules into an optimized runtime image. This is possible,
    in part, due to the jlink linking tool which you will learn more about later in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8ef012a-ce1d-41a7-82fb-d632953b5227.png)'
  prefs: []
  type: TYPE_IMG
- en: Module paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to organize modules so that they can be easily located. The
    module path, a sequence of module components or directories, provides the organizational
    structure used by searches. These path components are searched for in order, returning
    the first path component that comprises a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules and their paths should not be considered to be the same as packages
    or class paths. They are indeed different and have a greater level of fidelity.
    The key difference is that, with classpaths, a singular component is searched
    for. Module path searches return complete modules. This type of search is possible
    by searching the following paths, in the presented order, until a module is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: Compilation module path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade module path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application module path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly review each of these paths. The compilation module path is only
    applicable at compile time and contains the module definitions. The upgrade module
    path has the compiled module definitions. The system modules are built-in and
    include Java SE and JDK modules. The final path, the application module path,
    has the compiled module definitions from the application modules as well as the
    library modules.
  prefs: []
  type: TYPE_NORMAL
- en: Access-control boundary violations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a professional developer, you always want your code to be secure, portable,
    and bug-free, which requires strict adherence to Java constructs such as encapsulation.
    There are occasions, such as with white box testing, that you need to break the
    encapsulation that the JVM mandates. This mandate permits cross-modular access.
  prefs: []
  type: TYPE_NORMAL
- en: 'To permit breaking the encapsulation, you can add an `add-exports` option in
    your module declaration. Here is the syntax you will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a closer look at the preceding syntax. The `<source-module>` and
    `<target-module>` are module names and `<package>` is the name of the package.
    Using the `add-exports` option permits us to violate access-control boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two rules regarding using the add-exports option:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be used multiple times in a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each use must be of a unique pairing of `<source-module>` and `<target-module>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not recommended that the add-exports option be used unless absolutely
    necessary. Its use permits dangerous access to a library module's internal API.
    This type of use makes your code dependent on the internal API not changing, which
    is beyond your control.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HotSpot virtual machine implements the `<options>` for the `jmod` and `jlink`
    command-line tools. Here is the list of `<options>` for the `jmod` command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/686173c7-3215-410b-bfa8-4955f8ff882e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the list of `<options>` for the `jlink` command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a73dc6a-c25a-400a-bbcf-ae063d32b324.png)'
  prefs: []
  type: TYPE_IMG
- en: Modular Java application packaging [JEP-275]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great improvements in Java 9 is the size of the runtime binaries
    generated by the **Java Packager**. This is possible in part due to the **Java
    Linker**, which is covered in the next section. The Java Packager's workflow has
    essentially remained the same in Java 9 as it was in Java 8\. There have been,
    as you will see later in this section, new tools added to the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Packager solely creates JDK 9 applications. This change to the Java
    Packager is intended to streamline and make the process of generating runtime
    images more efficient. So, the Java Packager will only create runtime images for
    the SDK version that it is associated with.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced look at the Java Linker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to the Java Linker tool, `jlink`, introduced in Java 9, runtime image
    creation included copying the entire JRE. Then, unused components are removed.
    Simply put, `jlink` facilitates the creation of runtime images with only the required
    modules. `jlink` is used by the Java Packager to generate an embedded runtime
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Java Packager options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the Java Packager is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are five different commands (`-command`) that can be used. They are described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `-createbss` | This command is used for converting files from CSS to binary
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-createjar` | This command, used along with additional parameters, creates
    a JAR archive file |'
  prefs: []
  type: TYPE_TB
- en: '| `-deploy` | This command is used to generate jnlp and HTML files |'
  prefs: []
  type: TYPE_TB
- en: '| `-makeall` | Combines the `-createjar`, `-deploy`, and compilation steps
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-signJar` | This command creates and signs a JAR file |'
  prefs: []
  type: TYPE_TB
- en: 'The `[-options]` for the `-createbss` command include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de012b83-ea8c-4efd-8f9f-d6dfe9e136d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `[-options]` for the `-createjar` command include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f4976de-0d36-4971-9606-35c6d1381bea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `[-options]` for the `-deploy` command include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/193cd6df-e5fc-4ecb-a4d9-bb5277af0e3f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the remaining `[-options]` for the `-deploy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fc716cf-2bc1-416c-9f32-b0bd9556ad72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `[-options]` for the `-makeall` command include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68c695e3-8357-4b04-beeb-842591fea01c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `[-options]` for the `-signJar` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fba3922c-bf9f-4f7e-82a3-c394846054ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Java Packager is divided into two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: JLink - The Java Linker [JEP-282]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Linker, commonly referred to as JLink, is a tool that was created to
    create custom runtime images. This tool collects the appropriate modules along
    with their dependencies, then optimizes them to create the image. This represents
    a big change for Java, with the release of Java 9\. Before the Java Linker tool,
    `jlink`, was available, runtime image creation included initially copying the
    entire JRE. In a subsequent step, the unused components were removed. In Java
    9, `jlink` creates runtime images with only the needed modules. `jlink` is used
    by the Java Packager to generate an embedded runtime image.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in a previous section, JEP-282 resulted in link time as an optional
    phase between compile time and runtime. It is in this phase that the appropriate
    modules are assembled into an optimized runtime image.
  prefs: []
  type: TYPE_NORMAL
- en: 'JLink is a command-line linking tool that permits the creation of runtime images
    containing a smaller subset of the JDK modules. This results in smaller runtime
    images. The following syntax consists of four components--the `jlink` command,
    options, the module path, and the output path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a list of the options that can be used with the `jlink` tool along
    with brief descriptions of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44554514-2deb-468c-9e99-6f4118b42b58.png)'
  prefs: []
  type: TYPE_IMG
- en: The module path tells the linker where to find the modules. The linker will
    not use exploded modules or JAR/JMOD files.
  prefs: []
  type: TYPE_NORMAL
- en: The output path simply informs the linker where to save the custom run-time
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating most internal APIs [JEP-260]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JEP-260 was implemented to make the Java platform more secure. The core of this
    JEP's goal was to encapsulate the majority of internal APIs. Specifically, most
    of the JDK's internal APIs are no longer accessible by default. Currently, internal
    APIs deemed to be *critical* and *widely-used* remain accessible. In the future,
    we are likely to see functionality to replace them, and at that time, those internal
    APIs will not be accessible by default.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is this change necessary? There are a few widely-used APIs that are
    unstable and, in some cases, not standardized. Unsupported APIs should not have
    access to internal details of the JDK. Therefore, JEP-260 resulted in increased
    security of the Java platform. Generally speaking, you should not use unsupported
    APIs in your development projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned critical APIs (internal to the JDK) are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sun.misc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.misc.Unsafe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.reflect.Reflection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned critical internal APIs are still accessible in JDK 9\. They
    will be accessible with the `jdk.unsupported` JDK module. Full JRE and JDK images
    will contain the `jdk.unsupported` module.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the Java Dependency Analysis Tool, `jdeps`, to help determine if
    your Java program has any dependencies on JDK internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: This is an interesting change to watch. It is likely that the currently accessible
    internal APIs will not be accessible by default when Java 10 is released.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the structure of Java modules as specified by *Project
    Jigsaw* and took an in-depth look at how *Project Jigsaw* was implemented to improve
    the Java platform. We also reviewed key internal changes to the Java platform
    as they relate to the modular system. Our review started with a modular primer
    where we learned about Java 9's modular system in terms of benefits and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how Java 9 introduced modularity to the JDK including its source
    code and organization of the same. The seven primary tool categories that make
    up the JDK were also explored. As we learned, modularity in Java 9 also extends
    to runtime images resulting in more maintainability, better performance, and increased
    security. The concept of **link time** was introduced as an optional phase between
    compile-time and runtime. We concluded the chapter with a look at the Java Linker
    and how Java 9 encapsulates internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to migrate our existing applications
    to the Java 9 platform. We will look at both manual and semi-automated migration
    processes.
  prefs: []
  type: TYPE_NORMAL
