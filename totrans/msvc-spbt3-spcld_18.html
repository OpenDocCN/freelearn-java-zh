<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer466" class="Basic-Text-Frame">
    <h1 class="chapterNumber">18</h1>
    <h1 id="_idParaDest-437" class="chapterTitle">Using a Service Mesh to Improve Observability and Management</h1>
    <p class="normal">In this chapter, you will be introduced to the concept of a service mesh and see how its capabilities can be used to handle challenges in a system landscape of microservices, in areas including security, policy enforcement, resilience, and traffic management. A service mesh can also be used to provide observability, the capability to visualize how traffic flows between microservices.</p>
    <p class="normal">A service mesh overlaps partly with the capabilities of Spring Cloud and Kubernetes that we learned about earlier in this book. But most of the functionality in a service mesh complements Spring Cloud and Kubernetes, as we will see in this chapter.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">An introduction to the service mesh concept and Istio, a popular open source implementation</li>
      <li class="bulletList">Deploying Istio in Kubernetes</li>
      <li class="bulletList">Creating, observing, and securing a service mesh</li>
      <li class="bulletList">Ensuring that a service mesh is resilient</li>
      <li class="bulletList">Performing zero-downtime updates</li>
      <li class="bulletList">Testing the microservice landscape using Docker Compose to ensure that the source code in the microservices is not locked into either Kubernetes or Istio</li>
    </ul>
    <h1 id="_idParaDest-438" class="heading-1">Technical requirements</h1>
    <p class="normal">For instructions on how to install the tools used in this book and how to access the source code for this book, see:</p>
    <ul>
      <li class="bulletList"><em class="chapterRef">Chapter 21</em>, <em class="italic">Installation Instructions for macOS</em></li>
      <li class="bulletList"><em class="chapterRef">Chapter 22</em>, <em class="italic">Installation Instructions for Microsoft Windows with WSL 2 and Ubuntu</em></li>
    </ul>
    <p class="normal">The code examples in this chapter all come from the source code in <code class="inlineCode">$BOOK_HOME/Chapter18</code>.</p>
    <p class="normal">If you want to view the changes applied to the source code in this chapter, that is, see what it took to create a service mesh using Istio, you can compare it with the source code for <em class="chapterRef">Chapter 17</em>, <em class="italic">Implementing Kubernetes Features to Simplify the System Landscape</em>. You can use your favorite <code class="inlineCode">diff</code> tool and compare the two folders, <code class="inlineCode">$BOOK_HOME/Chapter17</code> and <code class="inlineCode">$BOOK_HOME/Chapter18</code>.</p>
    <h1 id="_idParaDest-439" class="heading-1">Introducing service meshes using Istio</h1>
    <p class="normal">A service mesh is an infrastructure layer that controls and observes the communication between services, for <a id="_idIndexMarker1255"/>example, microservices. The capabilities in a service mesh, for example, observability, security, policy enforcement, resilience, and traffic management, are implemented by controlling and monitoring all internal communication inside the<a id="_idIndexMarker1256"/> service mesh, that is, between the microservices in the service mesh.</p>
    <p class="normal">One of the core components in a service mesh is <a id="_idIndexMarker1257"/>a lightweight <strong class="keyWord">proxy</strong> component, which is injected into each microservice that will be part of the service mesh. All traffic in and out of a microservice is <a id="_idIndexMarker1258"/>configured to go through its proxy component. The proxy components are configured at runtime by a <strong class="keyWord">control plane</strong> in the service mesh, using APIs exposed by the proxy. The control plane also collects telemetry data through these APIs from the proxies to visualize how the traffic flows in the service mesh.</p>
    <p class="normal">A service mesh also contains a <strong class="keyWord">data plane</strong>, consisting<a id="_idIndexMarker1259"/> of the proxy components together with separate components for handling external traffic to and from the service mesh, known <a id="_idIndexMarker1260"/>as an <strong class="keyWord">ingress gateway</strong> and an <strong class="keyWord">egress gateway</strong>, respectively. The gateway components also <a id="_idIndexMarker1261"/>communicate with the control plane using a proxy component. This is illustrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_01.png" alt="A picture containing text, screenshot, rectangle, diagram  Description automatically generated" width="877" height="353"/></figure>
    <p class="packt_figref">Figure 18.1: Service mesh with a control plane and a data plane</p>
    <p class="normal">The first publicly available implementation of a <a id="_idIndexMarker1262"/>service mesh was the open source project <strong class="keyWord">Linkerd</strong>, managed by Buoyant (<a href="https://linkerd.io"><span class="url">https://linkerd.io</span></a>), having its origins in Twitter’s Finagle project (<a href="http://twitter.github.io/finagle"><span class="url">http://twitter.github.io/finagle</span></a>). It was<a id="_idIndexMarker1263"/> launched in 2016 and, one year later, in 2017, IBM, Google, and Lyft launched the open source project <strong class="keyWord">Istio</strong> (<a href="https://istio.io"><span class="url">https://istio.io</span></a>). Since then, several service mesh projects have been launched. </p>
    <p class="normal">For an overview of available implementations, see the <strong class="screenText">service mesh</strong> category in CNCF’s cloud-native landscape map: <a href="https://landscape.cncf.io/card-mode?category=service-mesh&amp;grouping=category"><span class="url">https://landscape.cncf.io/card-mode?category=service-mesh&amp;grouping=category</span></a>. In this book, we will use Istio.</p>
    <h2 id="_idParaDest-440" class="heading-2">Introducing Istio</h2>
    <p class="normal">Istio can be deployed on a number <a id="_idIndexMarker1264"/>of Kubernetes distributions and platforms using various installation tools as described in <a href="https://istio.io/docs/setup"><span class="url">https://istio.io/docs/setup</span></a>. We will use Istio’s CLI tool, <code class="inlineCode">istioctl</code>, to install<a id="_idIndexMarker1265"/> Istio in our minikube-based, single-node Kubernetes cluster.</p>
    <p class="normal">Istio is, as explained previously, divided into a control plane and a data plane. As an operator, we will define the desired state by creating Istio objects in the Kubernetes API server, for example, declaring routing rules. The control plane will read these objects and send commands to the proxies in the data plane to take actions according to the desired state, for example, configuring routing rules. The proxies handle the actual communication between the microservices and report back telemetry data to the control plane. The telemetry data is used in the control plane to visualize what’s going on in the service mesh.</p>
    <p class="normal">When deploying Istio on Kubernetes, most of its runtime components are deployed in a separate Kubernetes namespace, <code class="inlineCode">istio-system</code>. For the configuration we will use in this book, we will find the following Deployments in this Namespace:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">istiod</code>, Istio’s daemon that runs the whole control plane.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">Fun fact</strong>: Up until Istio v1.4, the control plane was divided into a set of cooperating microservices. Starting with v1.5, they were consolidated into a single binary run by <code class="inlineCode">istiod</code>, simplifying the installation and configuration of the control plane at runtime. Also, runtime characteristics such as startup time, resource usage, and responsiveness improved. This evolution of Istio’s control plane is, to me, an interesting lesson learned when it comes to the use of fine-grained microservices.</p>
    </div>
    <ul>
      <li class="bulletList"><code class="inlineCode">istio-ingressgateway</code> and <code class="inlineCode">istio-egressgateway</code>, Istio’s ingress and egress gateway components, are part of the data plane.</li>
      <li class="bulletList">A number of integrations with other popular open source projects are supported by Istio to bring in extra functionality to the control plane. In this book, we will integrate the following components:<ul>
          <li class="bulletList"><strong class="keyWord">Kiali</strong>: Provides observability<a id="_idIndexMarker1266"/> to the service mesh, visualizing what is going on in the mesh. For more information, see <a href="https://www.kiali.io"><span class="url">https://www.kiali.io</span></a>.</li>
          <li class="bulletList"><strong class="keyWord">Tracing</strong>: Handles and<a id="_idIndexMarker1267"/> visualizes distributed tracing information, based on either Jaeger or Zipkin. We will use Jaeger. For more information, see <a href="https://www.jaegertracing.io"><span class="url">https://www.jaegertracing.io</span></a>.</li>
          <li class="bulletList"><strong class="keyWord">Prometheus</strong>: Performs data ingestion and storage for time-series-based data, for example, performance <a id="_idIndexMarker1268"/>metrics. For more information, see <a href="https://prometheus.io"><span class="url">https://prometheus.io</span></a>.</li>
          <li class="bulletList"><strong class="keyWord">Grafana</strong>: Visualizes performance <a id="_idIndexMarker1269"/>metrics and other time-series-related data collected by Prometheus. For more information, see <a href="https://grafana.com"><span class="url">https://grafana.com</span></a>.</li>
        </ul>
        <div class="packt_tip">
          <p class="normal">In <em class="chapterRef">Chapter 20</em>, <em class="italic">Monitoring Microservices</em>, we will explore performance monitoring capabilities using Prometheus and Grafana.</p>
        </div>
      </li>
      <li class="bulletList">For more information on the integration available in Istio, see <a href="https://istio.io/latest/docs/ops/integrations/"><span class="url">https://istio.io/latest/docs/ops/integrations/</span></a>.</li>
    </ul>
    <p class="normal">The only Istio components<a id="_idIndexMarker1270"/> that are deployed outside of the <code class="inlineCode">istio-system</code> Namespace are the proxy components, which are injected into the microservices that are part of the service mesh. The proxy <a id="_idIndexMarker1271"/>component is based on Lyft’s Envoy proxy (<a href="https://www.envoyproxy.io"><span class="url">https://www.envoyproxy.io</span></a>).</p>
    <p class="normal">The runtime components in Istio’s control plane and data plane are summarized in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_02.png" alt="A picture containing text, screenshot, rectangle  Description automatically generated" width="878" height="449"/></figure>
    <p class="packt_figref">Figure 18.2: Istio runtime components</p>
    <p class="normal">Now that we’ve had an introduction, we will look into how these proxy objects can be injected into the microservices.</p>
    <h2 id="_idParaDest-441" class="heading-2">Injecting Istio proxies into microservices</h2>
    <p class="normal">The microservices we have<a id="_idIndexMarker1272"/> deployed in Kubernetes in the<a id="_idIndexMarker1273"/> previous chapters run as a single container in a Kubernetes Pod (refer to the <em class="italic">Introducing Kubernetes API objects</em> section in <em class="chapterRef">Chapter 15</em>, <em class="italic">Introduction to Kubernetes</em>, for a recap).</p>
    <p class="normal">To make a microservice join an Istio-based service mesh, an Istio proxy is injected into each microservice. This is done by adding an extra container to the Pod that runs the Istio proxy.</p>
    <div class="note">
      <p class="normal">A container added to a Pod with the aim of supporting the main<a id="_idIndexMarker1274"/> container, such as an Istio proxy, is referred to as a <strong class="keyWord">sidecar</strong>.</p>
    </div>
    <p class="normal">The following diagram shows <a id="_idIndexMarker1275"/>how an Istio proxy has been injected into <a id="_idIndexMarker1276"/>a sample Pod, <strong class="screenText">Pod A</strong>, as a sidecar:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_03.png" alt="A picture containing text, screenshot, number, font  Description automatically generated" width="483" height="526"/></figure>
    <p class="packt_figref">Figure 18.3: Istio proxy injected into Pod A</p>
    <p class="normal">The main container in the Pod, <strong class="screenText">Container A</strong>, is configured to route all its traffic through the Istio proxy.</p>
    <p class="normal">Istio proxies can be injected either automatically when a Pod object is created or manually using the <code class="inlineCode">istioctl</code> tool. To tell Istio to automatically inject an Istio proxy into new Pods in a Namespace, the Namespace can be labeled with <code class="inlineCode">istio-injection: enabled</code>. If some Pods in the Namespace are to be excluded from the auto-injection, they can be annotated with <code class="inlineCode">sidecar.istio.io/inject: "false"</code>.</p>
    <p class="normal">To inject an Istio proxy manually into the Pods of an existing Deployment object, the following command can be used:</p>
    <pre class="programlisting con"><code class="hljs-con">kubectl get deployment sample-deployment -o yaml | istioctl kube-inject -f - | kubectl apply -f -
</code></pre>
    <p class="normal">This command may, at first glance, appear somewhat daunting, but it is actually just three separate commands. The previous command sends its output to the next command using pipes, that is, the <code class="inlineCode">|</code> character. Let’s go through each command:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">kubectl get deployment</code> command gets the current definition of a Deployment named <code class="inlineCode">sample-deployment</code> from the Kubernetes API server and returns its definition in the YAML format.</li>
      <li class="bulletList">The <code class="inlineCode">istioctl kube-inject</code> command reads the definition from the <code class="inlineCode">kubectl get deployment</code> command and <a id="_idIndexMarker1277"/>adds an extra container for an Istio proxy in Pods that the Deployment handles. The configuration for the existing<a id="_idIndexMarker1278"/> container in the <code class="inlineCode">Deployment</code> object is updated so that incoming and outgoing traffic goes through the Istio proxy.</li>
      <li class="bulletList">The <code class="inlineCode">istioctl</code> command returns the new definition of the Deployment object, including a container for the Istio proxy.</li>
      <li class="bulletList">The <code class="inlineCode">kubectl apply</code> command reads the updated configuration from the <code class="inlineCode">istioctl kube-inject</code> command and applies the updated configuration. An upgrade of the Pods belonging to the Deployment will start up in the same way as we have seen before (refer to the <em class="italic">Trying out a sample deployment</em> section in <em class="chapterRef">Chapter 15</em>, <em class="italic">Introduction to Kubernetes</em>).</li>
    </ul>
    <p class="normal">In this book, we will inject the Istio proxies automatically by applying the following definition of the <code class="inlineCode">hands-on</code> Namespace:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hands-on</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">istio-injection:</span> <span class="hljs-string">enabled</span>
</code></pre>
    <p class="normal">From the preceding definition, we can see how the Namespace is given the label <code class="inlineCode">istio-injection</code> with the value <code class="inlineCode">enabled</code>.</p>
    <p class="normal">At the time of writing, Istio is not fully capable of acting as a proxy for MySQL, MongoDB, and RabbitMQ, so they will be excluded from the service mesh by adding the following annotation to their Helm charts’ <code class="inlineCode">values.yaml</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">annotations:</span>
  <span class="hljs-attr">sidecar.istio.io/inject:</span> <span class="hljs-string">"false"</span>
</code></pre>
    <p class="normal">After this introduction to how Istio proxies can be injected into Pods, we can now learn about the Istio API objects used in this book.</p>
    <h2 id="_idParaDest-442" class="heading-2">Introducing Istio API objects</h2>
    <p class="normal">Istio also comes with a set of Kubernetes <strong class="keyWord">Custom Resource Definitions</strong> (<strong class="keyWord">CRDs</strong>). CRDs are used in Kubernetes to extend its API, that is, to <a id="_idIndexMarker1279"/>add new objects to its API. Refer to the <em class="italic">Introducing Kubernetes API objects</em> section in <em class="chapterRef">Chapter 15</em>, <em class="italic">Introduction to Kubernetes</em>, for a recap of the Kubernetes API. </p>
    <p class="normal">In this book, we will<a id="_idIndexMarker1280"/> use the following Istio objects:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Gateway</strong> is used to configure how to handle incoming traffic to, and outgoing traffic from, the service mesh. A gateway depends on a virtual service routing the incoming traffic to Kubernetes <a id="_idIndexMarker1281"/>Services. We will use a <code class="inlineCode">gateway</code> object to accept incoming traffic to DNS names ending with <code class="inlineCode">minikube.me</code>, using HTTPS. The Istio gateway objects will replace the <strong class="keyWord">Ingress</strong> objects used in the previous chapter. Refer to the <em class="italic">Replacing Kubernetes Ingress Controller with Istio ingress gateway</em> section for details.</li>
      <li class="bulletList"><strong class="keyWord">VirtualService</strong> is used to define<a id="_idIndexMarker1282"/> routing rules in the service mesh. We will use virtual Services to describe how to route incoming traffic from an Istio gateway to the Kubernetes Services and between Services. We will also use virtual Services to inject faults and delays to test the reliability and resilience capabilities of the service mesh.</li>
      <li class="bulletList"><strong class="keyWord">DestinationRule</strong> is used to define<a id="_idIndexMarker1283"/> policies and rules for traffic that is routed (using a virtual service) to a specific service (that is, a destination). We will use destination rules to set up encryption policies to encrypt internal HTTP traffic and define service subsets that describe available versions of the services. We will use service subsets when performing zero-downtime (blue-green) deployments from an existing version of a microservice to a new version.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">The division of responsibility between <code class="inlineCode">VirtualService</code> and <code class="inlineCode">DestinationRule</code> might seem a bit unclear in the beginning. A <code class="inlineCode">VirtualService</code> object is used to configure routing <strong class="keyWord">to</strong> a service and <code class="inlineCode">DestinationRule</code> is used to configure how to handle traffic <strong class="keyWord">for</strong> a selected service. So, first are <code class="inlineCode">VirtualService</code> objects, used to determine where to send a request. Once that is decided, the receiving service’s <code class="inlineCode">DestinationRule</code> is applied.</p>
    </div>
    <ul>
      <li class="bulletList"><strong class="keyWord">PeerAuthentication</strong> is used to control service-to-service authentication inside the service mesh. Istio can protect <a id="_idIndexMarker1284"/>communication between services in a service mesh by automatically <a id="_idIndexMarker1285"/>provisioning <strong class="keyWord">mutual TLS</strong> (<strong class="keyWord">mTLS</strong>) for transport authentication, where client services are authenticated by using a client certificate that is provided by Istio. To allow Kubernetes to call liveness and readiness probes using plain HTTP, we will configure Istio to allow a mix of mTLS and plain HTTP, called <code class="inlineCode">PERMISSIVE</code> mode.</li>
      <li class="bulletList"><strong class="keyWord">RequestAuthentication</strong> is used to <a id="_idIndexMarker1286"/>authenticate end users based on the credentials provided in a request. Istio supports using <strong class="keyWord">JSON Web Tokens</strong> (<strong class="keyWord">JWTs</strong>) in general and specifically <a id="_idIndexMarker1287"/>when used according to the <strong class="keyWord">OpenID Connect </strong>(<strong class="keyWord">OIDC</strong>) specification. Istio supports the use of the standard discovery endpoint in OIDC to specify <a id="_idIndexMarker1288"/>where Istio can fetch the public key set <strong class="keyWord">JSON Web Key Set</strong> (JWKS) to validate the signatures of the JWTs. We will configure Istio to authenticate external requests using the auth server by specifying its JWKS discovery endpoint. For a recap, see <em class="italic">Chapter 11</em>, <em class="italic">Securing Access to APIs</em>.</li>
      <li class="bulletList"><strong class="keyWord">AuthorizationPolicy</strong> is used to<a id="_idIndexMarker1289"/> provide access control in Istio. We will not use Istio’s access control in this book. Instead, we will reuse the existing access control implemented in the <code class="inlineCode">product-composite</code> microservice. We will therefore configure an <code class="inlineCode">AuthorizationPolicy</code> object that allows access to the <code class="inlineCode">product-composite</code> microservice for any authenticated user, that is, for requests that contain a valid JWT in the form of an OIDC access token.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">For more information on these API objects, see <a href="https://istio.io/v1.17/docs/reference/config/networking/"><span class="url">https://istio.io/v1.17/docs/reference/config/networking/</span></a> and <a href="https://istio.io/v1.17/docs/reference/config/security/"><span class="url">https://istio.io/v1.17/docs/reference/config/security/</span></a>.</p>
    </div>
    <p class="normal">Now that we have introduced the API objects we will use, we will go through the changes applied to the microservice<a id="_idIndexMarker1290"/> landscape arising from the introduction of Istio.</p>
    <h1 id="_idParaDest-443" class="heading-1">Simplifying the microservice landscape</h1>
    <p class="normal">As we have seen in the preceding section, Istio comes with components that overlap with components currently<a id="_idIndexMarker1291"/> used in the microservice landscape in terms of functionality:</p>
    <ul>
      <li class="bulletList">The Istio ingress gateway can act as an edge server, an alternative to a Kubernetes Ingress controller</li>
      <li class="bulletList">The Jaeger component that comes bundled with Istio can be used for distributed tracing instead of the Zipkin server that we deploy together with the microservices</li>
    </ul>
    <p class="normal">In the following two subsections, we will get an overview of why and how the Kubernetes Ingress controller is replaced with an Istio ingress gateway, and our Zipkin server is replaced with the Jaeger component that comes integrated with Istio.</p>
    <h2 id="_idParaDest-444" class="heading-2">Replacing the Kubernetes Ingress controller with an Istio ingress gateway</h2>
    <p class="normal">In the previous chapter, we introduced the <a id="_idIndexMarker1292"/>Kubernetes <a id="_idIndexMarker1293"/>Ingress controller as an edge server (refer to the <em class="italic">Replacing Spring Cloud Gateway</em> section in <em class="chapterRef">Chapter 17</em>, <em class="italic">Implementing Kubernetes Features to Simplify the System Landscape</em>). An Istio ingress gateway has a number of advantages over a Kubernetes Ingress controller:</p>
    <ul>
      <li class="bulletList">It can report telemetry data to the control plane for the traffic that flows through it</li>
      <li class="bulletList">It can be used for more fine-grained routing</li>
      <li class="bulletList">It can both authenticate and authorize requests before routing them into the service mesh</li>
    </ul>
    <p class="normal">To benefit from these advantages, we will replace the Kubernetes Ingress controller with the Istio ingress gateway. The Istio ingress gateway is used by creating <code class="inlineCode">Gateway</code> and <code class="inlineCode">VisualService</code> objects, as described previously in the <em class="italic">Introducing Istio API objects</em> section.</p>
    <p class="normal">The definition of the previously used Ingress objects has been removed from the <code class="inlineCode">dev-env</code> and <code class="inlineCode">prod-env</code> Helm charts in <code class="inlineCode">kubernetes/helm/environments</code>. The definition files for Istio <code class="inlineCode">Gateway</code> and <code class="inlineCode">VirtualService</code> objects will be explained in the <em class="italic">Creating the service mesh</em> section.</p>
    <p class="normal">The Istio ingress gateway is reached using a different IP address from the IP address used to access the Kubernetes Ingress controller, so we also need to update the IP address mapped to the hostname, <code class="inlineCode">minikube.me</code>, which we use when running tests. This is handled in the <em class="italic">Setting up access to Istio services</em> section.</p>
    <h2 id="_idParaDest-445" class="heading-2">Replacing the Zipkin server with Istio’s Jaeger component</h2>
    <p class="normal">As mentioned in the <em class="italic">Introducing Istio</em> section, Istio comes with built-in support for distributed tracing using Jaeger. Using Jaeger, we can<a id="_idIndexMarker1294"/> offload and simplify the microservice landscape in Kubernetes by removing the Zipkin server we introduced in <em class="chapterRef">Chapter 14</em>, <em class="italic">Understanding Distributed Tracing</em>. We will also change the way trace and span IDs are propagated<a id="_idIndexMarker1295"/> between the <a id="_idIndexMarker1296"/>microservices, from using the default W3C trace context headers to using OpenZipkin’s <code class="inlineCode">B3</code> headers. See the <em class="italic">Introducing distributed tracing with Micrometer Tracing and Zipkin</em> section in <em class="chapterRef">Chapter 14</em>, <em class="italic">Understanding Distributed Tracing,</em> for more information.</p>
    <p class="normal">The following changes have been applied to the source code:</p>
    <ul>
      <li class="bulletList">The following dependencies have been replaced in all microservice build files, <code class="inlineCode">build.gradle</code>:
        <pre class="programlisting code"><code class="hljs-code">implementation <span class="hljs-string">'io.micrometer:micrometer-tracing-bridge-otel'</span>
implementation <span class="hljs-string">'io.opentelemetry:opentelemetry-exporter-zipkin'</span>
</code></pre>
      
    <p class="normal">The dependencies have been replaced with the following:</p>
    <pre class="programlisting code"><code class="hljs-code">implementation <span class="hljs-string">'io.micrometer:micrometer-tracing-bridge-brave'</span>
implementation <span class="hljs-string">'io.zipkin.reporter2:zipkin-reporter-brave'</span>
</code></pre></li>
    </ul>
    <ul>
      <li class="bulletList">The <code class="inlineCode">management.zipkin.tracing.endpoint</code> property in the common configuration file <code class="inlineCode">config-repo/application.yml</code> points to the Jaeger component in Istio. It has the hostname <code class="inlineCode">jaeger-collector.istio-system</code>.</li>
      <li class="bulletList">The definition of the Zipkin<a id="_idIndexMarker1297"/> server in the three Docker Compose files, <code class="inlineCode">docker-compose.yml</code>, <code class="inlineCode">docker-compose-partitions.yml</code>, and <code class="inlineCode">docker-compose-kafka.yml</code>, has been retained to be able to use distributed tracing outside of Kubernetes and Istio, but the Zipkin server has been <a id="_idIndexMarker1298"/>given the same hostname as the Jaeger component in Istio, <code class="inlineCode">jaeger-collector.istio-system</code>.</li>
      <li class="bulletList">The Helm chart for the Zipkin server has been removed.</li>
    </ul>
    <p class="normal">Jaeger will be installed in the <em class="italic">Deploying Istio in a Kubernetes cluster</em> section coming up.</p>
    <p class="normal">With these simplifications of the microservice landscape explained, we are ready to deploy Istio in the Kubernetes cluster.</p>
    <h1 id="_idParaDest-446" class="heading-1">Deploying Istio in a Kubernetes cluster</h1>
    <p class="normal">In this section, we will learn <a id="_idIndexMarker1299"/>how to deploy Istio in a Kubernetes cluster and how to access the<a id="_idIndexMarker1300"/> Istio services in it.</p>
    <p class="normal">We will use Istio’s CLI tool, <code class="inlineCode">istioctl</code>, to install Istio using a <code class="inlineCode">demo</code> configuration of Istio that is suitable for testing Istio in a development environment, that is, with most features enabled but configured for minimalistic resource usage.</p>
    <div class="packt_tip">
      <p class="normal">This configuration is unsuitable for production usage and for performance testing.</p>
    </div>
    <p class="normal">For other installation options, see <a href="https://istio.io/latest/docs/setup/install/"><span class="url">https://istio.io/latest/docs/setup/install/</span></a>.</p>
    <p class="normal">To deploy Istio, perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Ensure that your Minikube instance from the previous chapter is up and running with the following command:
        <pre class="programlisting con"><code class="hljs-con">minikube status
</code></pre>
      
    <p class="normal">Expect a response along the lines of the following, provided it is up and running:</p></li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_04.png" alt="A screen shot of a computer  Description automatically generated with medium confidence" width="333" height="246"/></figure>
    <p class="packt_figref">Figure 18.4: Minikube status OK</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Run a precheck to verify that the<a id="_idIndexMarker1301"/> Kubernetes cluster is ready for<a id="_idIndexMarker1302"/> Istio to be installed in it:
        <pre class="programlisting con"><code class="hljs-con">istioctl experimental precheck
</code></pre>
      
    <p class="normal">Expect a response like the following:</p></li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_05.png" alt="A screen shot of a computer  Description automatically generated with medium confidence" width="496" height="146"/></figure>
    <p class="packt_figref">Figure 18.5: Istio precheck OK</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Install Istio using the <code style="font-weight: bold;" class="codeHighlighted">demo</code> profile with the following command:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter18
istioctl install --skip-confirmation \
  --set profile=demo \
  --set meshConfig.accessLogFile=/dev/stdout \
  --set meshConfig.accessLogEncoding=JSON \
  --set values.pilot.env.PILOT_JWT_PUB_KEY_REFRESH_INTERVAL=15s \
  -f kubernetes/istio-tracing.yml
</code></pre>
      
    <p class="normal">The command parameters do the following:</p></li>
    </ol>
    <ul>
      <li class="bulletList">The <code class="inlineCode">accessLog</code> parameters are used to enable the Istio proxies to log requests that are processed. Once Pods are up and running with Istio proxies installed, the access logs can be inspected with the command <code class="inlineCode">kubectl logs &lt;MY-POD&gt; -c istio-proxy</code>.</li>
      <li class="bulletList">The <code class="inlineCode">PILOT_JWT_PUB_KEY_REFRESH_INTERVAL</code> parameter<a id="_idIndexMarker1303"/> configures Istio’s daemon, <code class="inlineCode">istiod</code>, to refresh the fetched <a id="_idIndexMarker1304"/>JWKS public keys every 15 seconds. The usage of this parameter will be explained in the <em class="italic">Deploying v1 and v2 versions of the microservices with routing to the v1 version</em> section.</li>
      <li class="bulletList">The configuration file <code class="inlineCode">kubernetes/istio-tracing.yml</code> enables the creation of trace spans used for distributed tracing. It also configures Istio to create trace spans for all requests. It looks like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">install.istio.io/v1alpha1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">IstioOperator</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">meshConfig:</span>
    <span class="hljs-attr">enableTracing:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">defaultConfig:</span>
      <span class="hljs-attr">tracing:</span>
        <span class="hljs-attr">sampling:</span> <span class="hljs-number">100</span>
</code></pre>
      </li>
    </ul>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Wait for the Deployment objects and their Pods to be available with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl -n istio-system wait --timeout=600s --for=condition=available deployment --all
</code></pre>
      </li>
      <li class="numberedList">Next, install the extra components described in the <em class="italic">Introducing Istio</em> section – Kiali, Jaeger, Prometheus, and Grafana – with these commands:
        <pre class="programlisting con"><code class="hljs-con">istio_version=$(istioctl version --short --remote=false)
echo "Installing integrations for Istio v$istio_version"
kubectl apply -n istio-system -f https://raw.githubusercontent.com/istio/istio/${istio_version}/samples/addons/kiali.yaml
kubectl apply -n istio-system -f https://raw.githubusercontent.com/istio/istio/${istio_version}/samples/addons/jaeger.yaml
kubectl apply -n istio-system -f https://raw.githubusercontent.com/istio/istio/${istio_version}/samples/addons/prometheus.yaml
kubectl apply -n istio-system -f https://raw.githubusercontent.com/istio/istio/${istio_version}/samples/addons/grafana.yaml
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">If any of these commands fail, try rerunning the failing command. Errors can occur due to timing issues, which can be resolved by running commands again. Specifically, the installation of Kiali can result in error messages starting with <code class="inlineCode">unable to recognize</code>. Rerunning the command makes these error messages go away.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Wait a second time for the<a id="_idIndexMarker1305"/> extra components to be available<a id="_idIndexMarker1306"/> with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl -n istio-system wait --timeout=600s --for=condition=available deployment --all
</code></pre>
      </li>
      <li class="numberedList">Finally, run the following command to see what we got installed:
        <pre class="programlisting con"><code class="hljs-con">kubectl -n istio-system get deploy
</code></pre>
     
    <p class="normal">Expect an output similar to this:</p> </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_06.png" alt="A screen shot of a black screen  Description automatically generated with low confidence" width="812" height="292"/></figure>
    <p class="packt_figref">Figure 18.6: Deployments in the Istio Namespace</p>
    <p class="normal">Istio is now deployed in Kubernetes, but before we move on and create the service mesh, we need to learn a bit about how to access the Istio services in a Minikube environment.</p>
    <h2 id="_idParaDest-447" class="heading-2">Setting up access to Istio services</h2>
    <p class="normal">The <code class="inlineCode">demo</code> configuration used in the <a id="_idIndexMarker1307"/>previous section to install Istio comes with a few connectivity-related issues that we need to resolve. The Istio ingress gateway is configured as a load-balanced Kubernetes service; that is, its type is <code class="inlineCode">LoadBalancer</code>. To be able to access the gateway, we need to run a load balancer in front of the Kubernetes cluster.</p>
    <p class="normal">Minikube contains a command that can be used to simulate a local load balancer, <code class="inlineCode">minikube tunnel</code>. This command assigns an external IP address to each load-balanced Kubernetes service, including the Istio ingress gateway. The hostname, <code class="inlineCode">minikube.me</code>, that we use in our tests needs to be translated into the external IP address of the Istio ingress gateway. To simplify access to the web UIs of components like Kiali and Jaeger, we will also add hostnames dedicated to these services, for example, <code class="inlineCode">kiali.minikube.me</code>.</p>
    <p class="normal">We will also register a hostname to the external <code class="inlineCode">health</code> endpoint as described in the <em class="italic">Observing the service mesh</em> section. Finally, a few hostnames for services installed and used in subsequent chapters will also be registered so we don’t need to add new hostnames in the following chapters. The services that we will install in the next chapters are Kibana, Elasticsearch, and a mail server.</p>
    <p class="normal">To enable external access using these hostnames to the Istio services, a Helm chart has been created; see <code class="inlineCode">kubernetes/helm/environments/istio-system</code>. The chart contains a <code class="inlineCode">Gateway</code>, <code class="inlineCode">VirtualService</code>, and <code class="inlineCode">DestinationRule</code> object for each Istio component. To protect requests to these hostnames from eavesdropping, only HTTPS requests are allowed. The <code class="inlineCode">cert-manager</code>, which was introduced in the previous chapter, is used by the chart to automatically provision a TLS certificate for the hostnames and store it in a Secret named <code class="inlineCode">hands-on-certificate</code>. All gateway objects are configured to use this Secret in their configuration of the HTTPS protocol. All definition files can be found in the Helm charts <code class="inlineCode">templates</code> folder.</p>
    <p class="normal">The use of these API objects will be described in more detail in the <em class="italic">Creating the service mesh</em> and <em class="italic">Protecting external endpoints with HTTPS and certificates</em> sections below.</p>
    <p class="normal">Run the following command to apply the Helm chart:</p>
    <pre class="programlisting con"><code class="hljs-con">helm upgrade --install istio-hands-on-addons kubernetes/helm/environments/istio-system -n istio-system --wait
</code></pre>
    <p class="normal">This will result in the gateway being able to route requests for the following hostnames to the corresponding Kubernetes Service:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">kiali.minikube.me</code> requests are routed to <code class="inlineCode">kiali:20001</code></li>
      <li class="bulletList"><code class="inlineCode">tracing.minikube.me</code> requests are routed to <code class="inlineCode">tracing:80</code></li>
      <li class="bulletList"><code class="inlineCode">prometheus.minikube.me</code> requests are routed to <code class="inlineCode">prometheus:9000</code></li>
      <li class="bulletList"><code class="inlineCode">grafana.minikube.me</code> requests are routed to <code class="inlineCode">grafana:3000</code></li>
    </ul>
    <p class="normal">To verify that the <code class="inlineCode">certificate</code> and <code class="inlineCode">secret</code> objects have been created, run the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con">kubectl -n istio-system get secret hands-on-certificate
kubectl -n istio-system get certificate  hands-on-certificate
</code></pre>
    <p class="normal">Expect an output like this:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_07.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="627" height="167"/></figure>
    <p class="packt_figref">Figure 18.7: The cert-manager has delivered both a TLS Secret and a certificate</p>
    <p class="normal">The following diagram <a id="_idIndexMarker1308"/>summarizes how the components can be accessed:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_08.png" alt="A picture containing text, screenshot, font, line  Description automatically generated" width="878" height="359"/></figure>
    <p class="packt_figref">Figure 18.8: Hostnames to be used for accessing components through the Minikube tunnel</p>
    <p class="normal">Perform the following steps to set up the Minikube tunnel and register the hostnames:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Run the following command in a separate terminal window (the command locks the terminal window when the tunnel is up and running):
        <pre class="programlisting con"><code class="hljs-con">minikube tunnel
</code></pre>
      
    <div class="packt_tip">
      <p class="normal">Note that this command requires that your user has <code class="inlineCode">sudo</code> privileges and that you enter your password during startup. It can take a couple of seconds before the command asks for the password, so it is easy to miss!</p>
    </div>
    <p class="normal">Once the tunnel is up <a id="_idIndexMarker1309"/>and running, it will list the <code class="inlineCode">istio-ingressgateway</code> as one of the services it exposes (the only one in our case).</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Configure the hostnames to be resolved to the IP address of the Istio ingress gateway. Start by getting the IP address exposed by the <code class="inlineCode">minikube tunnel</code> command for the Istio ingress gateway and save it in an environment variable named <code class="inlineCode">INGRESS_IP</code>:
        <pre class="programlisting con"><code class="hljs-con">INGRESS_IP=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
echo $INGRESS_IP
</code></pre>
        <p class="normal">The <code class="inlineCode">echo</code> command will print an IP address. Since we use Minikube’s Docker driver, it will always be <code class="inlineCode">127.0.0.1</code>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Update <code class="inlineCode">/etc/hosts</code> so that all <code class="inlineCode">minikube.me</code> hostnames will use the IP address of the Istio ingress gateway:
        <pre class="programlisting con"><code class="hljs-con">MINIKUBE_HOSTS="minikube.me grafana.minikube.me kiali.minikube.me prometheus.minikube.me tracing.minikube.me kibana.minikube.me elasticsearch.minikube.me mail.minikube.me health.minikube.me"
echo <code class="inlineCode">127.0.0.1 </code>$MINIKUBE_HOSTS" | sudo tee -a /etc/hosts
</code></pre>
      </li>
      <li class="numberedList">On Windows, we also need to update the Windows <code class="inlineCode">hosts</code> file:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">In Windows, open a <code class="inlineCode">PowerShell</code> terminal.</li>
          <li class="alphabeticList">Open the Windows <code class="inlineCode">hosts</code> file in Visual Code Studio with the command:
            <pre class="programlisting con"><code class="hljs-con">code C:\Windows\System32\drivers\etc\hosts
</code></pre>
          </li>
          <li class="alphabeticList">Add a similar line to the Window <code class="inlineCode">hosts</code> file:
            <pre class="programlisting con"><code class="hljs-con">127.0.0.1 minikube.me grafana.minikube.me kiali.minikube.me prometheus.minikube.me tracing.minikube.me kibana.minikube.me elasticsearch.minikube.me mail.minikube.me health.minikube.me
</code></pre>
          </li>
          <li class="alphabeticList">When you try to save it, you will get an error regarding <code class="inlineCode">Insufficient permissions</code>. Click on the <strong class="keyWord">Retry as Admin...</strong> button to update the <code class="inlineCode">hosts</code> file as an administrator.</li>
          <li class="alphabeticList">Verify the update:
            <pre class="programlisting con"><code class="hljs-con">cat C:\Windows\System32\drivers\etc\hosts
</code></pre>
          </li>
        </ol>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">By default, the <code class="inlineCode">/etc/hosts</code> file is overwritten by the content in the Windows <code class="inlineCode">hosts</code> file when WSL is restarted. Restarting WSL takes a long time as it also restarts Docker. Restarting Docker, in turn, results in the Minikube instance being stopped, so it needs to be restarted manually. To avoid this slow and tedious restart process, we simply updated both files.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Remove the line in <code class="inlineCode">/etc/hosts</code> where <code class="inlineCode">minikube.me</code> points <a id="_idIndexMarker1310"/>to only the IP address of the Minikube instance (<code class="inlineCode">127.0.0.1</code>). Verify that <code class="inlineCode">/etc/hosts</code> only contains one line that translates <code class="inlineCode">minikube.me</code> and that it points to the IP address of the Istio ingress gateway, <code style="font-weight: bold;" class="codeHighlighted">127.0.0.1</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_09.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="812" height="232"/></figure>
    <p class="packt_figref">Figure 18.9: /etc/hosts file updated</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Verify that Kiali, Jaeger, Grafana, and Prometheus can be reached through the tunnel with the following commands:
        <pre class="programlisting con"><code class="hljs-con">curl -o /dev/null -sk -L -w "%{http_code}\n" https://kiali.minikube.me/kiali/
curl -o /dev/null -sk -L -w "%{http_code}\n" https://tracing.minikube.me
curl -o /dev/null -sk -L -w "%{http_code}\n" https://grafana.minikube.me
curl -o /dev/null -sk -L -w "%{http_code}\n" https://prometheus.minikube.me/graph#/
</code></pre>
      </li>
    </ol>
    <p class="normal">Each command should return <code class="inlineCode">200</code> (<code class="inlineCode">OK</code>). If the request sent to Kiali doesn’t return <code class="inlineCode">200</code>, it often means that its internal initialization is not complete. Wait a minute and try again in that case.</p>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">minikube tunnel</code> command will stop running if, for example, your computer or the Minikube instance are paused or restarted. It needs to be restarted manually in these cases. So, if you fail to call APIs on any of the <code class="inlineCode">minikube.me</code> hostnames, always check whether the Minikube tunnel is running and restart it if required.</p>
    </div>
    <p class="normal">With the Minikube tunnel in place, we are now ready to create the service mesh.</p>
    <h1 id="_idParaDest-448" class="heading-1">Creating the service mesh</h1>
    <p class="normal">With Istio deployed, we are ready to create the service mesh. The steps required to create the service mesh are basically the <a id="_idIndexMarker1311"/>same as those we used in <em class="chapterRef">Chapter 17</em>, <em class="italic">Implementing Kubernetes Features to Simplify the System Landscape</em> (refer to the <em class="italic">Testing with Kubernetes ConfigMaps, Secrets, Ingress, and cert-manager</em> section). Let’s first see what additions have been made to the Helm templates to set up the service mesh before we run the commands to create the service mesh.</p>
    <h2 id="_idParaDest-449" class="heading-2">Source code changes</h2>
    <p class="normal">To be able to run the microservices in a service mesh managed by Istio, the <code class="inlineCode">dev-env</code> Helm chart brings in two new named templates<a id="_idIndexMarker1312"/> from the <code class="inlineCode">common</code> chart, <code class="inlineCode">_istio_base.yaml</code> and <code class="inlineCode">_istio_dr_mutual_tls.yaml</code>. Let’s go through them one by one.</p>
    <h3 id="_idParaDest-450" class="heading-3">Content in the _istio_base.yaml template</h3>
    <p class="normal"><code class="inlineCode">_istio_base.yaml</code> defines a number<a id="_idIndexMarker1313"/> of Kubernetes manifests that will be used by both environment charts, <code class="inlineCode">dev-env</code> and <code class="inlineCode">prod-env</code>. First, it defines three Istio-specific security-related manifests:</p>
    <ul>
      <li class="bulletList">An <code class="inlineCode">AuthorizationPolicy</code> manifest named <code class="inlineCode">product-composite-require-jwt</code></li>
      <li class="bulletList">A <code class="inlineCode">PeerAuthentication</code> manifest named <code class="inlineCode">default</code></li>
      <li class="bulletList">A <code class="inlineCode">RequestAuthentication</code> manifest named <code class="inlineCode">product-composite-request-authentication</code></li>
    </ul>
    <p class="normal">These three manifests will be explained in the <em class="italic">Securing a service mesh</em> section below.</p>
    <p class="normal">The remaining four manifests will be discussed here. They are two pairs of <code class="inlineCode">Gateway</code> and <code class="inlineCode">VirtualService</code> manifests that are used to configure access to, and routing from, the hostnames <code class="inlineCode">minikube.me</code> and <code class="inlineCode">health.minikube.me</code>. Gateway objects will be used to define how to receive external traffic and <code class="inlineCode">VirtualService</code> objects are used to describe how to route the incoming traffic inside the service mesh.</p>
    <p class="normal">The <code class="inlineCode">Gateway</code> manifest for controlling access to <code class="inlineCode">minikube.me</code> looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hands-on-gw</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span>
  <span class="hljs-attr">servers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">minikube.me</span>
    <span class="hljs-attr">port:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">https</span>
      <span class="hljs-attr">number:</span> <span class="hljs-number">443</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTPS</span>
    <span class="hljs-attr">tls:</span>
      <span class="hljs-attr">credentialName:</span> <span class="hljs-string">hands-on-certificate</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">SIMPLE</span>
</code></pre>
    <p class="normal">Here are some explanations for the source code:</p>
    <ul>
      <li class="bulletList">The gateway is named <code class="inlineCode">hands-on-gw</code>; this name is used by the virtual services underneath.</li>
      <li class="bulletList">The <code class="inlineCode">selector</code> field specifies that the gateway object will be handled by the default Istio ingress gateway, named <code class="inlineCode">ingressgateway</code>.</li>
      <li class="bulletList">The <code class="inlineCode">hosts</code> and <code class="inlineCode">port</code> fields specify that the gateway will handle incoming requests for the <code class="inlineCode">minikube.me</code> hostname using HTTPS over port <code class="inlineCode">443</code>.</li>
      <li class="bulletList">The <code class="inlineCode">tls</code> field specifies that the Istio ingress gateway can find the certificate and private key used for HTTPS communication in a TLS Secret named <code class="inlineCode">hands-on-certificate</code>. Refer to the <em class="italic">Protecting external endpoints with HTTPS and certificates</em> section below for details on how these certificate files are created. The <code class="inlineCode">SIMPLE</code> mode denotes that normal<a id="_idIndexMarker1314"/> TLS semantics will be applied.</li>
    </ul>
    <p class="normal">The <code class="inlineCode">VirtualService</code> manifest for routing requests sent to <code class="inlineCode">minikube.me</code> appears as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hands-on-vs</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">gateways:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">hands-on-gw</span>
  <span class="hljs-attr">hosts:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">minikube.me</span>
  <span class="hljs-attr">http:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span>
        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/oauth2</span>
    <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">auth-server</span>
  <span class="hljs-string">–</span> <span class="hljs-attr">match:</span>
    <span class="hljs-string">...</span>
</code></pre>
    <p class="normal">Explanations for the preceding manifest are as follows:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">gateways</code> and <code class="inlineCode">hosts</code> fields specify that the virtual service will route requests that are sent to the <code class="inlineCode">minikube.me</code> hostname through the <code class="inlineCode">hands-on-gw</code> gateway.</li>
      <li class="bulletList">Under the <code class="inlineCode">http</code> element follows an array of <code class="inlineCode">match</code> and <code class="inlineCode">route</code> blocks that specify how URL paths will be forwarded to the associated Kubernetes service. In the manifest above, only the first pair of <code class="inlineCode">match</code> and <code class="inlineCode">route</code> elements is shown. They map requests sent to <code class="inlineCode">minikube.me</code> using the path <code class="inlineCode">/oauth2</code> to the <code class="inlineCode">auth-server</code> service. This mapping should be familiar from how we specified routing rules in both Spring Cloud Gateway and Ingress objects in the previous chapters. The remaining pairs of <code class="inlineCode">match</code> and <code class="inlineCode">route</code> elements configure the same routing rules as we have seen for Spring Cloud Gateway and Ingress objects:<ul>
          <li class="bulletList"><code class="inlineCode">/login → auth-server</code></li>
          <li class="bulletList"><code class="inlineCode">/error → auth-server</code></li>
          <li class="bulletList"><code class="inlineCode">/product-composite → product-composite</code></li>
          <li class="bulletList"><code class="inlineCode">/openapi → product-composite</code></li>
          <li class="bulletList"><code class="inlineCode">/webjars → product-composite</code></li>
        </ul>
      </li>
    </ul>
    <p class="normal">For details, see <code class="inlineCode">kubernetes/helm/common/templates/_istio_base.yaml</code>.</p>
    <div class="packt_tip">
      <p class="normal">In the preceding source code, the destination<a id="_idIndexMarker1315"/> host is specified using its short name, in other words, <code class="inlineCode">product-composite</code>. This works, since the example is based on Kubernetes definitions from the same Namespace, <code class="inlineCode">hands-on</code>. If that is not the case, it is recommended in the Istio documentation to use the host’s <strong class="keyWord">fully qualified domain name</strong> (<strong class="keyWord">FQDN</strong>) instead. In this case, it is <code class="inlineCode">product-composite.hands-on.svc.cluster.local</code>.</p>
    </div>
    <h3 id="_idParaDest-451" class="heading-3">Content in the _istio_dr_mutual_tls.yaml template</h3>
    <p class="normal"><code class="inlineCode">_istio_dr_mutual_tls.yaml</code> defines a<a id="_idIndexMarker1316"/> template for specifying a number of <code class="inlineCode">DestinationRule</code> objects. It is used to specify that mTLS should be used when routing a request to its corresponding service. It can also be used optionally to specify <code class="inlineCode">subsets</code>, something that we will use in the <code class="inlineCode">prod-env</code> chart in the <em class="italic">Performing zero-downtime updates</em> section below. The template looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">{{<span class="hljs-bullet">-</span> <span class="hljs-string">define</span> <span class="hljs-string">"common.istio_dr_mutual_tls"</span> <span class="hljs-string">-</span>}}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">range</span> <span class="hljs-string">$idx</span>, <span class="hljs-string">$dr</span> <span class="hljs-string">:=</span> <span class="hljs-string">.Values.destinationRules</span> }}
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> {{ <span class="hljs-string">$dr.name</span> }}
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">host:</span> {{ <span class="hljs-string">$dr.name</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">$dr.subsets</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">with</span> <span class="hljs-string">$dr.subsets</span> }}
  <span class="hljs-attr">subsets:</span>
{{ <span class="hljs-string">toYaml</span> <span class="hljs-string">.</span> <span class="hljs-string">|</span> <span class="hljs-string">indent</span> <span class="hljs-number">2</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
  <span class="hljs-attr">trafficPolicy:</span>
    <span class="hljs-attr">tls:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">ISTIO_MUTUAL</span>
<span class="hljs-meta">---</span>
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> <span class="hljs-string">-</span>}}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> <span class="hljs-string">-</span>}}
</code></pre>
    <p class="normal">Here are some comments about the preceding template:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">range</code> directive loops over the elements defined in the <code class="inlineCode">destinationRules</code> variable</li>
      <li class="bulletList">The <code class="inlineCode">host</code> field in the <code class="inlineCode">spec</code> part of the manifest is used to specify the name of the Kubernetes Service that this <code class="inlineCode">DestinationRule</code> applies to</li>
      <li class="bulletList">A <code class="inlineCode">subsets</code> section is only defined if a corresponding element is found in the current element, <code class="inlineCode">$dr</code>, in the <code class="inlineCode">destinationRules</code> list</li>
      <li class="bulletList">A <code class="inlineCode">trafficPolicy</code> is always used to require mTLS</li>
    </ul>
    <p class="normal">The template is used in the <code class="inlineCode">dev-end</code> Helm chart by specifying the <code class="inlineCode">destinationRules</code> variable in the <code class="inlineCode">values.yaml</code> file as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">destinationRules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">product-composite</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">auth-server</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">product</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">recommendation</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">review</span>
</code></pre>
    <p class="normal">The files can be found at <code class="inlineCode">kubernetes/helm/common/templates/_istio_dr_mutual_tls.yaml</code> and <code class="inlineCode">kubernetes/helm/environments/dev-env/values.yaml</code>.</p>
    <p class="normal">With these changes in the source <a id="_idIndexMarker1317"/>code in place, we are now ready to create the service mesh.</p>
    <h2 id="_idParaDest-452" class="heading-2">Running commands to create the service mesh</h2>
    <p class="normal">Create the service mesh by running the<a id="_idIndexMarker1318"/> following commands:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Build Docker images from the source code with the following commands:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter18
eval $(minikube docker-env -u)
./gradlew build
eval $(minikube docker-env)
docker-compose build
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">eval $(minikube docker-env -u)</code> command ensures that the <code class="inlineCode">./gradlew build </code>command uses the host’s Docker engine and not the Docker engine in the Minikube instance. The <code class="inlineCode">build</code> command uses Docker to run test containers.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Recreate the <code class="inlineCode">hands-on</code> Namespace, and set it as the default Namespace:
        <pre class="programlisting con"><code class="hljs-con">kubectl delete namespace hands-on
kubectl apply -f kubernetes/hands-on-namespace.yml
kubectl config set-context $(kubectl config current-context) --namespace=hands-on 
</code></pre>
        <p class="normal">Note that the <code class="inlineCode">hands-on-namespace.yml</code> file creates the <code class="inlineCode">hands-on</code> Namespace labeled with <code class="inlineCode">istio-injection: enabled</code>. This means that Pods created in this Namespace will get <code class="inlineCode">istio-proxy</code> containers injected as sidecars automatically.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Resolve the Helm chart <a id="_idIndexMarker1319"/>dependencies with the following commands:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">First, we update the dependencies in the <code class="inlineCode">components</code> folder:
            <pre class="programlisting con"><code class="hljs-con">for f in kubernetes/helm/components/*; do helm dep up $f; done
</code></pre>
          </li>
          <li class="alphabeticList">Next, we update the dependencies in the <code class="inlineCode">environments</code> folder:
            <pre class="programlisting con"><code class="hljs-con">for f in kubernetes/helm/environments/*; do helm dep up $f; done
</code></pre>
          </li>
        </ol>
      </li>
      <li class="numberedList">Deploy the system landscape using Helm and wait for all Deployments to complete:
        <pre class="programlisting con"><code class="hljs-con">helm install hands-on-dev-env \
  kubernetes/helm/environments/dev-env \
  -n hands-on --wait
</code></pre>
      </li>
      <li class="numberedList">Once the Deployment is complete, verify that we have two containers in each of the microservice Pods:
        <pre class="programlisting con"><code class="hljs-con">kubectl get pods
</code></pre>
        <p class="normal">Expect a response along the lines of the following:</p>
        <figure class="mediaobject"><img src="../Images/B19825_18_10.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence" width="682" height="254"/></figure>
        <p class="packt_figref">Figure 18.10: Pods up and running</p>
        <p class="normal">Note that the Pods that run our microservices report two containers per Pod; that is, they have the Istio proxy<a id="_idIndexMarker1320"/> injected as a sidecar!</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Run the usual tests with the following command:
        <pre class="programlisting con"><code class="hljs-con">./test-em-all.bash
</code></pre>
        <div class="packt_tip">
          <p class="normal">The default values for the <code class="inlineCode">test-em-all.bash</code> script have been updated from previous chapters to accommodate Kubernetes running in Minikube.</p>
        </div>
        <p class="normal">Expect the output to be similar to what we have seen in previous chapters:</p>
        <figure class="mediaobject"><img src="../Images/B19825_18_11.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="649" height="243"/></figure>
        <p class="packt_figref">Figure 18.11: Tests running successfully</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Before we start to try out Istio and its various components, let’s see how we can log the propagation of trace<a id="_idIndexMarker1321"/> and span IDs using the B3 headers mentioned in the <em class="italic">Replacing the Zipkin server with Istio’s Jaeger component</em> section above.</li>
    </ol>
    <h2 id="_idParaDest-453" class="heading-2">Logging propagation of trace and span IDs</h2>
    <p class="normal">We can see the trace and span IDs in the<a id="_idIndexMarker1322"/> outgoing requests from the <code class="inlineCode">product-composite</code> microservice, as we did in the <em class="italic">Sending a successful API request</em> section in <em class="chapterRef">Chapter 14</em>, <em class="italic">Understanding Distributed Tracing</em>. Since we now run the microservices in Kubernetes, we <a id="_idIndexMarker1323"/>need to change the log configuration in a ConfigMap and then delete the running Pod to make it affect the microservice:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Edit the ConfigMap with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl edit cm product-composite
</code></pre>
      
    <p class="normal">Look for the following lines:</p>
    <pre class="programlisting code"><code class="hljs-code"># To see tracing headers, uncomment the following two lines and restart the product-composite service
# spring.codec.log-request-details: true
# logging.level.org.springframework.web.reactive.function.client.ExchangeFunctions: TRACE
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Uncomment the two last of these lines and exit the editor.</li>
      <li class="numberedList">Restart the <code style="font-weight: bold;" class="codeHighlighted">product-composite</code> microservice by deleting its Pod with this command:
        <pre class="programlisting con"><code class="hljs-con">kubectl delete pod -l app=product-composite
</code></pre>
      </li>
      <li class="numberedList">Print the log output to a terminal window with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl logs -f -l app=product-composite
</code></pre>
      </li>
      <li class="numberedList">Acquire an access token and make a request using the access token:
        <pre class="programlisting con"><code class="hljs-con">unset ACCESS_TOKEN
ACCESS_TOKEN=$(curl -k https://writer:secret-writer@minikube.me/oauth2/token -d grant_type=client_credentials -d scope="product:read product:write" -s | jq -r .access_token)
echo $ACCESS_TOKEN
curl -H "Authorization: Bearer $ACCESS_TOKEN" -k https://minikube.me/product-composite/1 -w "%{http_code}\n" -o /dev/null -s
</code></pre>
        <p class="normal">Verify that the command returns the HTTP status code for success, <code class="inlineCode">200</code>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">In the log output, lines like the following should be seen:
        <pre class="programlisting con"><code class="hljs-con">2023-05-15T15:39:25.919Z TRACE [product-composite,01bd9fb5815a7889dea69ec33afee5c5,94d9157ae179554c] 1 --- [     parallel-1] o.s.w.r.f.client.ExchangeFunctions       : [14b00bcd] HTTP GET http://product/
product/1?delay=0&amp;faultPercent=0, headers=[X-B3-TraceId:"01bd9fb5815a7889dea69ec33afee5c5", X-B3-SpanId:"94d9157ae179554c", X-B3-ParentSpanId:"aa3e97771ef9155e", X-B3-Sampled:"1"]
</code></pre>
        <p class="normal">In the sample log output above, we can see the standard <code class="inlineCode">B3</code> headers like <code class="inlineCode">X-B3-TraceId</code> and <code class="inlineCode">X-B3-SpanId</code>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Revert to not logging<a id="_idIndexMarker1324"/> trace and span IDs by adding back the<a id="_idIndexMarker1325"/> comments in the ConfigMap and restart the microservice by deleting its Pod.</li>
    </ol>
    <p class="normal">With the service mesh up and running, let’s see how we can observe what’s going on in it using Kiali!</p>
    <h1 id="_idParaDest-454" class="heading-1">Observing the service mesh</h1>
    <p class="normal">In this section, we will use Kiali together with Jaeger to observe what’s going on in the service mesh.</p>
    <p class="normal">Before we do that, we need to <a id="_idIndexMarker1326"/>understand how to get rid of some noise created by the health checks performed by Kubernetes’ liveness and readiness probes. In the previous chapters, they used the same port as the API requests. This means that Istio will collect metrics for the usage of both health checks and requests sent to the API. This will cause the graphs shown by Kiali to become unnecessarily cluttered. Kiali can filter out traffic that we are not interested in, but a simpler solution is to use a different port for the health checks.</p>
    <p class="normal">Microservices can be configured to use a separate port for requests sent to the actuator endpoints, for example, health checks sent to the <code class="inlineCode">/actuator/health</code> endpoint. The following line has been added to the common configuration file for all microservices, <code class="inlineCode">config-repo/application.yml</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">management.server.port:</span> <span class="hljs-number">4004</span>
</code></pre>
    <p class="normal">This will make all microservices use port <code class="inlineCode">4004</code> to expose the <code class="inlineCode">health</code> endpoints. The <code class="inlineCode">values.yaml</code> file in the <code class="inlineCode">common</code> Helm chart has been updated to use port <code class="inlineCode">4004</code> in the default liveness and readiness probes. See <code class="inlineCode">kubernetes/helm/common/values.yaml</code>.</p>
    <p class="normal">The <code class="inlineCode">product-composite</code> microservice exposes its management port not only to the Kubernetes probes but also externally for health checks, for example, performed by <code class="inlineCode">test-em-all.bash</code>. This is done through Istio’s ingress gateway, and therefore port <code class="inlineCode">4004</code> is added to the <code class="inlineCode">product-composite</code> microservice Deployment and Service manifests. See the <code class="inlineCode">ports</code> and <code class="inlineCode">service.ports</code> definitions in <code class="inlineCode">kubernetes/helm/components/product-composite/values.yaml</code>.</p>
    <p class="normal">Spring Cloud Gateway (which is retained so we can run tests in Docker Compose) will continue to use the same port for requests to the API and the <code class="inlineCode">health</code> endpoint. In the <code class="inlineCode">config-repo/gateway.yml</code> configuration file, the <code class="inlineCode">management</code> port is reverted to the port used for the API:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">management.server.port:</span> <span class="hljs-number">8443</span>
</code></pre>
    <p class="normal">To simplify external access to the health check exposed by the <code class="inlineCode">product-composite</code> microservice, a route is configured for<a id="_idIndexMarker1327"/> the <code class="inlineCode">health.minikube.me</code> hostname to the <code class="inlineCode">management</code> port on the <code class="inlineCode">product-composite</code> microservice. Refer to the explanation of the <code class="inlineCode">_istio_base.yaml</code> template above.</p>
    <p class="normal">With the requests sent to the <code class="inlineCode">health</code> endpoint out of the way, we can start to send some requests through the service mesh.</p>
    <p class="normal">We will start a low-volume load test using <code class="inlineCode">siege</code>, which we learned about in <em class="chapterRef">Chapter 16</em>, <em class="italic">Deploying Our Microservices to Kubernetes</em>. After that, we will go through some of the most important parts of Kiali to see how it can be used to observe a service mesh in a web browser. We will also see how Jaeger is used for distributed tracing.</p>
    <div class="packt_tip">
      <p class="normal">Since the certificate we use is self-signed, web browsers will not rely on it automatically. Most web browsers let you visit the web page if you assure them that you understand the security risks. If the web browser refuses, opening a private window helps in some cases.</p>
      <p class="normal">Specifically, regarding Chrome, if it does not let you visit the web page, saying <strong class="screenText">Your connection is not private</strong>, you can click the <strong class="screenText">Advanced</strong> button and then click on the link <strong class="screenText">Proceed to … (unsafe)</strong>.</p>
    </div>
    <p class="normal">Start the test client with the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con">ACCESS_TOKEN=$(curl https://writer:secret-writer@minikube.me/oauth2/token -d grant_type=client_credentials -d scope="product:read product:write" -ks | jq .access_token -r)
echo ACCESS_TOKEN=$ACCESS_TOKEN
siege https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN" -c1 -d1 -v
</code></pre>
    <p class="normal">The first command will get an OAuth 2.0/OIDC access token that will be used in the next command, where <code class="inlineCode">siege</code> is used to submit one HTTP request per second to the <code class="inlineCode">product-composite</code> API.</p>
    <p class="normal">Expect output from the <code class="inlineCode">siege</code> command as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_12.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="878" height="260"/></figure>
    <p class="packt_figref">Figure 18.12: System landscape under siege</p>
    <p class="normal">Use a web browser of your<a id="_idIndexMarker1328"/> choice that accepts self-signed certificates and proceed with the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Open Kiali’s web UI using the <a href="https://kiali.minikube.me"><span class="url">https://kiali.minikube.me</span></a> URL. By default, you will be logged in as an anonymous user. Expect a web page similar to the following:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_13.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="650"/></figure>
    <p class="packt_figref">Figure 18.13: Kiali web UI</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Click on the <strong class="screenText">Overview</strong> tab, if it is not already active.</li>
      <li class="numberedList">Click on the menu in the<a id="_idIndexMarker1329"/> box named <strong class="screenText">hands-on</strong> (three vertical dots in the top-right corner) and select <strong class="screenText">Graph</strong>. Expect a graph to be shown, representing the current traffic flowing through the service mesh.</li>
      <li class="numberedList">Click on the <strong class="screenText">Display</strong> button, and deselect all options except for <strong class="screenText">Response Time,</strong> <strong class="screenText">Median</strong>, and <strong class="screenText">Traffic Animation</strong>.</li>
      <li class="numberedList">In the <strong class="screenText">Hide…</strong> field, specify <code class="inlineCode">name = jaeger</code> to avoid cluttering the view with traces sent to Jaeger.</li>
      <li class="numberedList">Kiali now displays a graph representing requests that are currently sent through the service mesh, where active requests are represented by small moving circles along the arrows, as follows:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_14.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="812" height="569"/></figure>
    <p class="packt_figref">Figure 18.14: Kiali graph showing the hands-on Namespace</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">The traffic from <strong class="screenText">unknown</strong> to the <strong class="screenText">auth-server</strong> represents calls to the authorization server to get the JWKS <a id="_idIndexMarker1330"/>public keys. <p class="normal">This gives a pretty good initial overview of what’s going on in the service mesh!</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Let’s now look at some distributed tracing using Jaeger. Open the web UI using the <a href="https://tracing.minikube.me"><span class="url">https://tracing.minikube.me</span></a> URL. Click on the <strong class="screenText">Service</strong> dropdown in the menu to the left and select the <strong class="screenText">istio-ingressgateway.istio-system</strong><strong class="keyWord"> </strong>service. Click on the <strong class="screenText">Find Trace</strong> button and you should see a result like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_15.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="474"/></figure>
    <p class="packt_figref">Figure 18.15: Distributed traces visualized by Jaeger</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Click on one of the traces that is <a id="_idIndexMarker1331"/>reported to contain <strong class="screenText">23 Spans</strong> to examine it. Expect a web page such as the following:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_16.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="812" height="549"/></figure>
    <p class="packt_figref">Figure 18.16: View of a full trace call tree in Jaeger</p>
    <p class="normal">This is basically the same tracing information as Zipkin made available in <em class="chapterRef">Chapter 14</em>, <em class="italic">Understanding Distributed Tracing</em>. Note<a id="_idIndexMarker1332"/> that we can see trace information from both the Istio proxies and the microservices themselves. The spans reported by Istio proxies are suffixed with the Kubernetes Namespace, that is,<strong class="screenText"> </strong><code class="inlineCode">.istio-system</code> and <code class="inlineCode">.hands-on</code>.</p>
    <p class="normal">There is much more to explore, but this is enough by way of an introduction. Feel free to explore the web UI in Kiali and Jaeger on your own.</p>
    <div class="packt_tip">
      <p class="normal">Be aware that the access token acquired for the test client, <code class="inlineCode">siege</code>, is only valid for an hour. If the traffic drops unexpectedly, check the output from <code class="inlineCode">siege</code>; if it reports <code class="inlineCode">4XX</code> instead of <code class="inlineCode">200</code>, it’s time to renew the access token!</p>
    </div>
    <p class="normal">Let’s move on and learn how Istio can be used to improve security in the service mesh!</p>
    <h1 id="_idParaDest-455" class="heading-1">Securing a service mesh</h1>
    <p class="normal">In this section, we will learn how to <a id="_idIndexMarker1333"/>use Istio to improve the security of a service mesh. We will cover the following topics:</p>
    <ul>
      <li class="bulletList">How to protect external endpoints with HTTPS and certificates</li>
      <li class="bulletList">How to require that external requests are authenticated using OAuth 2.0/OIDC access tokens</li>
      <li class="bulletList">How to protect internal communication using <strong class="keyWord">mutual authentication</strong> (<strong class="keyWord">mTLS</strong>)</li>
    </ul>
    <p class="normal">Let’s now understand each of these in the following sections.</p>
    <h2 id="_idParaDest-456" class="heading-2">Protecting external endpoints with HTTPS and certificates</h2>
    <p class="normal">From the <em class="italic">Setting up access to Istio services </em>and<em class="italic"> Content in the _istio_base.yaml template</em> sections, we learned that the gateway objects use a TLS certificate stored in a Secret named <code class="inlineCode">hands-on-certificate</code> for its<a id="_idIndexMarker1334"/> HTTPS endpoints.</p>
    <p class="normal">The Secret is created by the cert-manager based on the configuration in the <code class="inlineCode">istio-system</code> Helm chart. The chart’s template, <code class="inlineCode">selfsigned-issuer.yaml</code>, is used to define an internal self-signed CA and has the following content:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cert-manager.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Issuer</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">selfsigned-issuer</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selfSigned:</span> {}
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cert-manager.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Certificate</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">ca-cert</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">isCA:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">commonName:</span> <span class="hljs-string">hands-on-ca</span>
  <span class="hljs-attr">secretName:</span> <span class="hljs-string">ca-secret</span>
  <span class="hljs-attr">issuerRef:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">selfsigned-issuer</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cert-manager.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Issuer</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">ca-issuer</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">ca:</span>
    <span class="hljs-attr">secretName:</span> <span class="hljs-string">ca-secret</span>
</code></pre>
    <p class="normal">From the preceding manifests, we can see the following:</p>
    <ul>
      <li class="bulletList">A self-signed issuer named <code class="inlineCode">selfsigned-issuer</code>.</li>
      <li class="bulletList">This issuer is used to create a self-signed certificate, named <code class="inlineCode">ca-cert</code>.</li>
      <li class="bulletList">The certificate is given the common name <code class="inlineCode">hands-on-ca</code>.</li>
      <li class="bulletList">Finally, a self-signed CA, <code class="inlineCode">ca-issuer</code>, is defined using the certificate, <code class="inlineCode">ca-cert</code>, as its root certificate. This CA will be used to issue the certificate used by the gateway objects.</li>
    </ul>
    <p class="normal">The chart’s template, <code class="inlineCode">hands-on-certificate.yaml</code>, defines this certificate as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cert-manager.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Certificate</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hands-on-certificate</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">commonName:</span> <span class="hljs-string">minikube.me</span>
  <span class="hljs-attr">subject:</span>
    <span class="hljs-string">...</span>
  <span class="hljs-attr">dnsNames:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">health.minikube.m</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">dashboard.minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">kiali.minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">tracing.minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus.minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">grafana.minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">kibana.minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch.minikube.me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">mail.minikube.me</span>
  <span class="hljs-attr">issuerRef:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">ca-issuer</span>
  <span class="hljs-attr">secretName:</span> <span class="hljs-string">hands-on-certificate</span>
</code></pre>
    <p class="normal">From this manifest, we can learn that:</p>
    <ul>
      <li class="bulletList">The certificate is named <code class="inlineCode">hands-on-certificate</code></li>
      <li class="bulletList">Its common name is set to <code class="inlineCode">minikube.me</code></li>
      <li class="bulletList">It specifies a few optional extra details about its <code class="inlineCode">subject</code> (left out for clarity)</li>
      <li class="bulletList">All other hostnames are<a id="_idIndexMarker1335"/> declared as <strong class="keyWord">Subject Alternative Names</strong> in the certificate</li>
      <li class="bulletList">It will use the issuer named <code class="inlineCode">ca-issuer</code> declared above</li>
      <li class="bulletList">The <code class="inlineCode">cert-manager</code> will store the TLS certificate in a Secret named <code class="inlineCode">hands-on-certificate</code></li>
    </ul>
    <p class="normal">When the <code class="inlineCode">istio-system</code> Helm chart was installed, these templates were used to create the corresponding API objects in Kubernetes. This triggered the <code class="inlineCode">cert-manager</code> to create the certificates and Secrets.</p>
    <p class="normal">The template files can be found in the <code class="inlineCode">kubernetes/helm/environments/istio-system/templates</code> folder.</p>
    <p class="normal">To verify that it is these certificates that are used by the Istio ingress gateway, we can run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">keytool -printcert -sslserver minikube.me | grep -E "Owner:|Issuer:"
</code></pre>
    <p class="normal">Expect the following output:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_17.png" alt="A screen shot of a computer  Description automatically generated with medium confidence" width="878" height="153"/></figure>
    <p class="packt_figref">Figure 18.17: Inspecting the certificate for minikube.me</p>
    <p class="normal">The output shows that the certificate is issued for the common name <code class="inlineCode">minikube.se</code> and that it is issued by our own CA, using its root certificate with the common name <code class="inlineCode">hands-on-ca</code>.</p>
    <p class="normal">As mentioned in <em class="chapterRef">Chapter 17</em>, <em class="italic">Implementing Kubernetes Features to Simplify the System Landscape</em> (refer to the <em class="italic">Automating certificate provisioning</em> section), this self-signed CA needs to be replaced for production use cases with, for example, Let’s Encrypt or another CA that the <code style="font-weight: bold;" class="codeHighlighted">cert-manager</code> can use to provision<a id="_idIndexMarker1336"/> trusted certificates.</p>
    <p class="normal">With the certificate configuration verified, let’s move on to see how the Istio ingress gateway can protect microservices from unauthenticated requests.</p>
    <h2 id="_idParaDest-457" class="heading-2">Authenticating external requests using OAuth 2.0/OIDC access tokens</h2>
    <p class="normal">An Istio ingress gateway can require and <a id="_idIndexMarker1337"/>validate JWT-based OAuth 2.0/OIDC access tokens, in other words, protect the microservices in the service mesh from external unauthenticated requests. For a recap on JWT, OAuth<a id="_idIndexMarker1338"/> 2.0, and OIDC, refer to <em class="chapterRef">Chapter 11</em>, <em class="italic">Securing Access to APIs</em> (see the <em class="italic">Protecting APIs using OAuth 2.0 and OpenID Connect</em> section). Istio can also be configured to perform authorization but, as mentioned in the <em class="italic">Introducing Istio API objects</em> section, we will not use it.</p>
    <p class="normal">This is configured in the <code class="inlineCode">common</code> Helm chart’s template, <code class="inlineCode">_istio_base.yaml</code>. The two manifests look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RequestAuthentication</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">product-composite-request-authentication</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">jwtRules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">forwardOriginalToken:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">issuer:</span> <span class="hljs-string">http://auth-server</span>
    <span class="hljs-attr">jwksUri:</span> <span class="hljs-string">http://auth-server.hands-on.svc.cluster.local/oauth2/jwks</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">product-composite</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">AuthorizationPolicy</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">product-composite-require-jwt</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">action:</span> <span class="hljs-string">ALLOW</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> {}
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">product-composite</span> 
</code></pre>
    <p class="normal">From the manifests, we can see the following:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">RequestAuthentication</code> named <code class="inlineCode">product-composite-request-authentication</code> requires a valid JWT-encoded access token for requests sent to the <code class="inlineCode">product-composite</code> service.</li>
      <li class="bulletList">It selects services that it performs request authentication for based on a label selector, <code class="inlineCode">app.kubernetes.io/name: product-composite</code>.</li>
      <li class="bulletList">It allows tokens from the issuer, <code class="inlineCode">http://auth-server</code>.</li>
      <li class="bulletList">It will use the <code class="inlineCode">http://auth-server.hands-on.svc.cluster.local/oauth2/jwks</code> URL to fetch a JWKS<a id="_idIndexMarker1339"/>. The key set is used to validate the digital signature of the access tokens.</li>
      <li class="bulletList">It will forward the <a id="_idIndexMarker1340"/>access token to the underlying services, in our case, the <code class="inlineCode">product-composite</code> microservice.</li>
      <li class="bulletList">The <code class="inlineCode">AuthorizationPolicy</code> named <code class="inlineCode">product-composite-require-jwt</code> is configured to allow all requests to the <code class="inlineCode">product-composite</code> service; it will not apply any authorization rules.</li>
    </ul>
    <p class="normal">It can be a bit hard to understand whether Istio’s <code class="inlineCode">RequestAuthentication</code> is validating the access tokens or whether it is only the <code class="inlineCode">product-composite</code> service that is performing the validation. One way to ensure that Istio is doing its job is to change the configuration of <code class="inlineCode">RequestAuthentication</code> so that it always rejects access tokens.</p>
    <p class="normal">To verify that <code class="inlineCode">RequestAuthentication</code> is in action, apply the following commands:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Make a normal request:
        <pre class="programlisting con"><code class="hljs-con">ACCESS_TOKEN=$(curl https://writer:secret-writer@minikube.me/oauth2/token  -d grant_type=client_credentials -d scope="product:read product:write" -ks | jq .access_token -r)
echo ACCESS_TOKEN=$ACCESS_TOKEN
curl -k https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN" -i
</code></pre>
        <p class="normal">Verify that it returns an HTTP response status code <code class="inlineCode">200</code> (<code class="inlineCode">OK</code>).</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Edit the <code class="inlineCode">RequestAuthentication</code> object and temporarily change the <code class="inlineCode">issuer</code>, for example, to <code class="inlineCode">http://auth-server-x</code>:
        <pre class="programlisting con"><code class="hljs-con">kubectl edit RequestAuthentication product-composite-request-authentication
</code></pre>
      </li>
      <li class="numberedList">Verify the change:
        <pre class="programlisting con"><code class="hljs-con">kubectl get RequestAuthentication product-composite-request-authentication -o yaml
</code></pre>
        <p class="normal">Verify that the <code class="inlineCode">issuer</code> has been updated, in my case, to <code class="inlineCode">http://auth-server-x</code>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Make the request again. It should fail with the HTTP response status code <code class="inlineCode">401</code> (Unauthorized) and the error message <code class="inlineCode">Jwt issuer is not configured</code>:
        <pre class="programlisting con"><code class="hljs-con">curl -k https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN" -i
</code></pre>
        <p class="normal">Since it takes a few seconds <a id="_idIndexMarker1341"/>for Istio to propagate the change, the new name of the <code class="inlineCode">issuer</code>, you might <a id="_idIndexMarker1342"/>need to repeat the command a couple of times before it fails.</p>
        <p class="normal">This proves that Istio is validating the access tokens!</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Revert the changed name of the issuer to <code class="inlineCode">http://auth-server</code>:
        <pre class="programlisting con"><code class="hljs-con">kubectl edit RequestAuthentication product-composite-request-authentication
</code></pre>
      </li>
      <li class="numberedList">Verify that the request works again. First, wait a few seconds for the change to be propagated. Then, run the command:
        <pre class="programlisting con"><code class="hljs-con">curl -k https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN"
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal"><strong class="screenText">Suggested additional exercise</strong>: Try out the Auth0 OIDC provider, as described in <em class="chapterRef">Chapter 11</em>, <em class="italic">Securing Access to APIs</em> (refer to the <em class="italic">Testing with an external OpenID Connect provider</em> section). Add your Auth0 provider to <code class="inlineCode">jwt-authentication-policy.yml</code>. In my case, it appears as follows:</p>
      <pre class="programlisting code"><code class="hljs-code">  - jwtRules:
      issuer: <span class="hljs-string">"https://dev-magnus.eu.auth0.com/"</span> 
      jwksUri: <span class="hljs-string">"https://dev-magnus.eu.auth0.com/.well-known/jwks.json"</span>
</code></pre>
    </div>
    <p class="normal">Now, let’s move on to the last security mechanism that we will cover in Istio: the automatic protection of internal communication in the service mesh using mutual authentication, mTLS.</p>
    <h2 id="_idParaDest-458" class="heading-2">Protecting internal communication using mutual authentication (mTLS)</h2>
    <p class="normal">In this section, we will learn how<a id="_idIndexMarker1343"/> Istio can be configured to automatically protect internal communication within the service mesh using <strong class="keyWord">mTLS</strong>. When using mutual authentication, not only does the service prove its identity by exposing a certificate but the clients also prove their identity to the service by <a id="_idIndexMarker1344"/>exposing a client-side certificate. This provides a higher level of security compared to normal TLS/HTTPS usage, where only the identity of the service is proven. Setting up and maintaining mutual authentication, that is, provisioning new certificates and rotating outdated certificates for the clients, is known to be complex and is therefore seldom used. Istio fully automates the provisioning and rotation of certificates for the mutual authentication used for internal communication inside the service mesh. </p>
    <p class="normal">This makes it much easier to use mutual authentication compared to setting it up manually.</p>
    <p class="normal">So, why should we use mutual authentication? Isn’t it sufficient to protect external APIs with HTTPS and OAuth 2.0/OIDC access tokens?</p>
    <p class="normal">As long as the attacks come through the external API, it might be sufficient. But what if a Pod inside the Kubernetes cluster becomes compromised? For example, if an attacker gains control over a Pod, they can start listening to traffic between other Pods in the Kubernetes cluster. If the internal communication is sent as plaintext, it will be very easy for the attacker to gain access to sensitive <a id="_idIndexMarker1345"/>information sent between Pods in the cluster. To minimize the damage caused by such an intrusion, mutual authentication can be used to prevent an attacker from eavesdropping on internal network traffic.</p>
    <p class="normal">To enable the use of mutual authentication managed by Istio, Istio needs to be configured both on the server side, using a policy called <code class="inlineCode">PeerAuthentication</code>, and on the client side, using a <code class="inlineCode">DestinationRule</code>.</p>
    <p class="normal">The policy is configured in the <code class="inlineCode">common</code> Helm chart’s template, <code class="inlineCode">_istio_base.yaml</code>. The manifest looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PeerAuthentication</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">mtls:</span>
    <span class="hljs-attr">mode:</span> <span class="hljs-string">PERMISSIVE</span>
</code></pre>
    <p class="normal">As mentioned in the <em class="italic">Introducing Istio API objects</em> section, the <code class="inlineCode">PeerAuthentication</code> policy is configured to allow both mTLS and plain HTTP requests using the <code class="inlineCode">PERMISSIVE</code> mode. This enables Kubernetes to call liveness and readiness probes using plain HTTP.</p>
    <p class="normal">We have also already met the <code class="inlineCode">DestinationRule</code> manifests in the <em class="italic">Content in the _istio_dr_mutual_tls.yaml template</em> section. The central part of the <code class="inlineCode">DestinationRule</code> manifests for requiring mTLS looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-attr">trafficPolicy:</span>
    <span class="hljs-attr">tls:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">ISTIO_MUTUAL</span>
</code></pre>
    <p class="normal">To verify that the internal communication is protected by mTLS, perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Ensure that the load tests started in the preceding <em class="italic">Observing the service mesh</em> section are still running and report <code class="inlineCode">200</code> (<code class="inlineCode">OK</code>).</li>
      <li class="numberedList">Go to the Kiali graph in a web browser (<a href="https://kiali.minikube.me"><span class="url">https://kiali.minikube.me</span></a>).</li>
      <li class="numberedList">Click on the <strong class="screenText">Display</strong> button and enable the <strong class="screenText">Security</strong> label. The graph will show a padlock on all <a id="_idIndexMarker1346"/>communication links that are protected by Istio’s automated mutual authentication, as follows:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_18.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="812" height="563"/></figure>
    <p class="packt_figref">Figure 18.18: Inspecting mTLS settings in Kiali</p>
    <p class="normal">Expect a padlock <a id="_idIndexMarker1347"/>on all links.</p>
    <div class="packt_tip">
      <p class="normal">Calls to RabbitMQ, MySQL, and MongoDB are not handled by Istio proxies, and therefore require manual configuration to be protected using TLS, if required.</p>
    </div>
    <p class="normal">With this, we have seen all three security mechanisms in Istio in action, and it is now time to see how Istio can help us to verify that a service mesh is resilient.</p>
    <h1 id="_idParaDest-459" class="heading-1">Ensuring that a service mesh is resilient</h1>
    <p class="normal">In this section, we will learn how to use Istio to<a id="_idIndexMarker1348"/> ensure that a service mesh is resilient, that is, that it can handle temporary faults in a service mesh. Istio comes with mechanisms similar to what the Spring Framework offers in terms of timeouts, retries, and a type of circuit breaker<a id="_idIndexMarker1349"/> called <strong class="keyWord">outlier detection</strong> to handle temporary faults. </p>
    <p class="normal">When it comes to deciding whether language-native mechanisms should be used to handle temporary faults or whether this should be delegated to a service mesh such as Istio, I tend to favor using language-native mechanisms, as in the examples in <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em>. In many cases, it is important to keep the logic for handling errors, for example, handling fallback alternatives for a circuit breaker, together with other business logic for a microservice. Keeping the logic for handling temporary faults in the source code also makes it easier to test it using, for example, JUnit and test containers, something that becomes much more complex if handling temporary faults is delegated to a service mesh like Istio.</p>
    <p class="normal">There are cases when the<a id="_idIndexMarker1350"/> corresponding mechanisms in Istio could be of great help. For example, if a microservice is deployed and it is determined that it can’t handle temporary faults that occur in production from time to time, then it can be very convenient to add a timeout or a retry mechanism using Istio instead of waiting for a new release of the microservice with corresponding error handling features put in place.</p>
    <p class="normal">Another capability in the area of resilience that comes with Istio is the capability to inject faults and delays into an existing service mesh. Why might we want to do that?</p>
    <p class="normal">Injecting faults and delays in a controlled way is very useful for verifying that the resilient capabilities in the microservices work as expected! We will try them out in this section, verifying that the retry, timeout, and circuit breaker in the <code class="inlineCode">product-composite</code> microservice work as expected.</p>
    <div class="packt_tip">
      <p class="normal">In <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em> (refer to the <em class="italic">Adding programmable delays and random errors</em> section), we added support for injecting faults and delays into the microservices source code. That source code should preferably be replaced by using Istio’s capabilities for injecting faults and delays at runtime, as demonstrated in the following subsections.</p>
    </div>
    <p class="normal">We will begin by injecting faults to see whether the retry mechanisms in the <code class="inlineCode">product-composite</code> microservice work as expected. After that, we will delay the responses from the <code class="inlineCode">product</code> service and verify that the circuit breaker handles the delay as expected.</p>
    <h2 id="_idParaDest-460" class="heading-2">Testing resilience by injecting faults</h2>
    <p class="normal">Let’s make the <code class="inlineCode">product</code> service throw random errors and verify that the microservice landscape handles this correctly. We expect the<a id="_idIndexMarker1351"/> retry mechanism in the <code class="inlineCode">product-composite</code> microservice to kick in and retry the request until it succeeds or its limit of the maximum numbers of retries is reached. This will ensure that a short-lived fault does not affect the end user more than the delay introduced by the retry attempts. Refer to the <em class="italic">Adding a retry mechanism</em> section in <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em>, for a recap on the retry mechanism in the <code class="inlineCode">product-composite</code> microservice.</p>
    <p class="normal">Faults can be injected using a virtual service like <code class="inlineCode">kubernetes/resilience-tests/product-virtual-service-with-faults.yml</code>. This appears as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">product</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">product</span>
  <span class="hljs-attr">http:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">product</span>
    <span class="hljs-attr">fault:</span>
      <span class="hljs-attr">abort:</span>
        <span class="hljs-attr">httpStatus:</span> <span class="hljs-number">500</span>
        <span class="hljs-attr">percentage:</span>
          <span class="hljs-attr">value:</span> <span class="hljs-number">20</span>
</code></pre>
    <p class="normal">The definition says that <code class="inlineCode">20</code>% of the requests sent to the <code class="inlineCode">product</code> service will be aborted with the HTTP status code <code class="inlineCode">500</code> (<code class="inlineCode">Internal Server Error</code>).</p>
    <p class="normal">Perform the following steps to<a id="_idIndexMarker1352"/> test this:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Ensure that the load tests using <code class="inlineCode">siege</code>, as started in the <em class="italic">Observing the service mesh</em> section, are running.</li>
      <li class="numberedList">Apply the fault injection with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl apply -f kubernetes/resilience-tests/product-virtual-service-with-faults.yml
</code></pre>
      </li>
      <li class="numberedList">Monitor the output from the <code class="inlineCode">siege</code> load tests tool. Expect output similar to the following: <figure class="mediaobject"><img src="../Images/B19825_18_19.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="220"/></figure>
        <p class="packt_figref">Figure 18.19: Observing the retry mechanism in action</p>
        <p class="normal">From the sample output, we can see that all requests are still successful, in other words, status <code class="inlineCode">200</code> (<code class="inlineCode">OK</code>) is returned; however, some of them (20%) take an extra second to complete. This indicates that the retry mechanism in the <code class="inlineCode">product-composite</code> microservice has kicked in and has retried a failed request to the <code class="inlineCode">product</code> service.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Conclude the tests by removing the fault injection with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl delete -f kubernetes/resilience-tests/product-virtual-service-with-faults.yml
</code></pre>
      </li>
    </ol>
    <p class="normal">Let’s now move on to the <a id="_idIndexMarker1353"/>next section, where we will inject delays to trigger the circuit breaker.</p>
    <h2 id="_idParaDest-461" class="heading-2">Testing resilience by injecting delays</h2>
    <p class="normal">From <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em>, we know that a circuit breaker can be used to prevent problems due<a id="_idIndexMarker1354"/> to the slow or complete lack of response of services after accepting requests.</p>
    <p class="normal">Let’s verify that the circuit breaker in the <code class="inlineCode">product-composite</code> service works as expected by injecting a delay into the <code class="inlineCode">product</code> service using Istio. A delay can be injected using a virtual service.</p>
    <p class="normal">Refer to <code class="inlineCode">kubernetes/resilience-tests/product-virtual-service-with-delay.yml</code>. Its code appears as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">product</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">product</span>
  <span class="hljs-attr">http:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">product</span>
    <span class="hljs-attr">fault:</span>
      <span class="hljs-attr">delay:</span>
        <span class="hljs-attr">fixedDelay:</span> <span class="hljs-string">3s</span>
        <span class="hljs-attr">percent:</span> <span class="hljs-number">100</span>
</code></pre>
    <p class="normal">This definition says that all requests sent to the <code class="inlineCode">product</code> service will be delayed by <code class="inlineCode">3</code> seconds.</p>
    <p class="normal">Requests sent to the <code class="inlineCode">product</code> service from the <code class="inlineCode">product-composite</code> service are configured to time out after 2 seconds. The circuit breaker is configured to open its circuit if 3 consecutive requests fail. When the circuit is open, it will fast-fail; in other words, it will immediately throw an exception, not attempting to call the underlying service. The business logic in the <code class="inlineCode">product-composite</code> microservice will catch this exception and apply fallback logic. For a recap, see <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em> (refer to the <em class="italic">Adding a circuit breaker and a time limiter</em> section).</p>
    <p class="normal">Perform the following steps to test the circuit breaker by injecting a delay:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Stop the load test by pressing <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> in the terminal window where <code class="inlineCode">siege</code> is running.</li>
      <li class="numberedList">Create a temporary delay in the <code class="inlineCode">product</code> service with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl apply -f kubernetes/resilience-tests/product-virtual-service-with-delay.yml
</code></pre>
      </li>
      <li class="numberedList">Acquire an access token as follows:
        <pre class="programlisting con"><code class="hljs-con">ACCESS_TOKEN=$(curl https://writer:secret-writer@minikube.me/oauth2/token  -d grant_type=client_credentials -d scope="product:read product:write" -ks | jq .access_token -r)
echo ACCESS_TOKEN=$ACCESS_TOKEN
</code></pre>
      </li>
      <li class="numberedList">Send six requests in a row:
        <pre class="programlisting con"><code class="hljs-con">for i in {1..6}; do time curl -k https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN"; done
</code></pre>
        <p class="normal">Expect the following:</p>
        <ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">The circuit opens up after the first three failed calls</li>
          <li class="alphabeticList">The circuit breaker applies fast-fail logic for the last three calls</li>
          <li class="alphabeticList">A fallback response is returned for the last three calls</li>
        </ol>
        <p class="normal">The responses from the<a id="_idIndexMarker1355"/> first 3 calls are expected to be a timeout-related error message, with a response time of 2 seconds (in other words, the timeout time). Expect responses for the first 3 calls along the lines of the following:</p>
        <figure class="mediaobject"><img src="../Images/B19825_18_20.png" alt="A picture containing text, screenshot, font  Description automatically generated" width="812" height="166"/></figure>
        <p class="packt_figref">Figure 18.20: Observing timeouts</p>
        <p class="normal">The responses from the last 3 calls are expected to come from the fallback logic with a short response time. Expect responses for the last 3 calls as follows:</p>
        <figure class="mediaobject"><img src="../Images/B19825_18_21.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="536" height="122"/></figure>
        <p class="packt_figref">Figure 18.21: Fallback method in action</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Simulate the delay<a id="_idIndexMarker1356"/> problem being fixed by removing the temporary delay with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl delete -f kubernetes/resilience-tests/product-virtual-service-with-delay.yml
</code></pre>
      </li>
      <li class="numberedList">Verify that correct answers are returned again, and without any delay, by sending a new request using the <code class="inlineCode">for</code> loop command in <em class="italic">step 4</em>.</li>
    </ol>
    <div class="packt_tip">
      <p class="normal">If you want to check the state of the circuit breaker, you can do it with the following command:</p>
      <pre class="programlisting con"><code class="hljs-con">curl -ks https://health.minikube.me/actuator/health | jq -r .components.circuitBreakers.details.product.details.state
</code></pre>
      <p class="normal">It should report <code class="inlineCode">CLOSED</code>, <code class="inlineCode">OPEN</code>, or <code class="inlineCode">HALF_OPEN</code>, depending on its state.</p>
    </div>
    <p class="normal">This proves that the circuit breaker reacts as expected when we inject a delay using Istio. This concludes testing the features in Istio that can be used to verify that the microservice landscape is resilient. The final feature we will explore in Istio is its support for traffic management; we will see how it can be used to enable deployments with zero downtime.</p>
    <h1 id="_idParaDest-462" class="heading-1">Performing zero-downtime updates</h1>
    <p class="normal">As mentioned in <em class="chapterRef">Chapter 16</em>, <em class="italic">Deploying Our Microservices to Kubernetes</em>, being able to deploy an update without downtime becomes crucial with a growing number of autonomous microservices that are updated<a id="_idIndexMarker1357"/> independently of one another.</p>
    <p class="normal">In this section, we will learn about Istio’s traffic management and routing capabilities and how they can be used to perform deployments of new versions of microservices without requiring any downtime. In <em class="chapterRef">Chapter 15</em>, <em class="italic">Introduction to Kubernetes</em>, we learned that Kubernetes can be used to perform a rolling upgrade without requiring any downtime. Using the Kubernetes rolling upgrade mechanism automates the entire process but, unfortunately, provides no option to test the new version before all users are routed to it.</p>
    <p class="normal">Using Istio, we can deploy the new version but initially route all users to the existing version (called the <strong class="keyWord">old</strong> version in this chapter). After that, we can use Istio’s fine-grained routing mechanism to control how users are routed to the new and the old versions. We will see how two popular upgrade strategies can be implemented using Istio:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Canary deployments</strong>: When <a id="_idIndexMarker1358"/>using canary deployments, all users are routed to the old version, except for a group of selected test users who are routed to the new version. When the test users have approved the new version, regular users can be routed to the new version using a blue-green deploy.</li>
      <li class="bulletList"><strong class="keyWord">Blue-green deployments</strong>: Traditionally, a blue-green deploy means that all users are switched to either the blue or<a id="_idIndexMarker1359"/> the green version, one being the new version and the other being the old version. If something goes wrong when switching over to the new version, it is very simple to switch back to the old version. Using Istio, this strategy can be refined by gradually shifting users over to the new version, for example, starting with 20% of the users and then slowly increasing the percentage. At all times, it is very easy to route all users back to the old version if a fatal error is revealed in the new version.</li>
    </ul>
    <p class="normal">As already stated in <em class="chapterRef">Chapter 16</em>, it is important to<a id="_idIndexMarker1360"/> remember that a prerequisite for these types of upgrade strategies is that the upgrade is <strong class="keyWord">backward-compatible</strong>. Such an upgrade is <a id="_idIndexMarker1361"/>compatible both in terms of APIs and message formats, which are used to communicate with other services and database structures. If the new version of the microservice requires changes to external APIs, message formats, or database structures that the old version can’t handle, these upgrade strategies can’t be applied.</p>
    <p class="normal">We will go through the following deployment scenario:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We will start by deploying the <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions of the microservices, with routing configured to send all requests to the <code class="inlineCode">v1</code> version of the microservices.</li>
      <li class="numberedList">Next, we will allow a test group to run canary tests; that is, we’ll verify the new <code class="inlineCode">v2</code> versions of the microservices. To simplify the tests somewhat, we will only deploy new versions of the core microservices, that is, the <code class="inlineCode">product</code>, <code class="inlineCode">recommendation</code>, and <code class="inlineCode">review</code> microservices.</li>
      <li class="numberedList">Finally, we will start to move regular users over to the new versions using a blue-green deploy; initially, a small percentage of users and then, over time, more and more users until, eventually, they are all routed to the new version. We will also see how we can quickly switch back to the <code class="inlineCode">v1</code> version if a fatal error is detected in the new <code class="inlineCode">v2</code> version.</li>
    </ol>
    <p class="normal">Let’s first see what changes need to be applied to the source code to be able to deploy and route traffic to two concurrent versions, <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code>, of the core microservices.</p>
    <h2 id="_idParaDest-463" class="heading-2">Source code changes</h2>
    <p class="normal">To be able to run multiple versions of a microservice concurrently, the Deployment objects and their corresponding Pods must have different names, for example, <code class="inlineCode">product-v1</code> and <code class="inlineCode">product-v2</code>. There must, however, be only one<a id="_idIndexMarker1362"/> Kubernetes Service object per microservice. All traffic to a specific microservice always goes through the same Service object, irrespective <a id="_idIndexMarker1363"/>of what version of the Pod the request will be routed to in the end. To configure the actual routing rules for canary tests and blue-green deployments, Istio’s <code class="inlineCode">VirtualService</code> and <code class="inlineCode">DestinationRule</code> objects are used. Finally, the <code class="inlineCode">values.yaml</code> file in the <code class="inlineCode">prod-env</code> Helm chart is used to specify the versions of each microservice that will be used in the production environment.</p>
    <p class="normal">Let’s go through the details for each definition in the following subsections:</p>
    <ul>
      <li class="bulletList">Virtual services and destination rules</li>
      <li class="bulletList">Deployments and services</li>
      <li class="bulletList">Tying things together in the <code class="inlineCode">prod-env</code> Helm chart</li>
    </ul>
    <h3 id="_idParaDest-464" class="heading-3">Virtual services and destination rules</h3>
    <p class="normal">To split the traffic between two versions of a<a id="_idIndexMarker1364"/> microservice, we need to specify the weight distribution between the two versions in a virtual service, on the sender side. The virtual service will spread the traffic between two subsets, called <code class="inlineCode">old</code> and <code class="inlineCode">new</code>. The exact meaning of the <code class="inlineCode">new</code> and <code class="inlineCode">old</code> subset is defined in a corresponding <code class="inlineCode">DestinationRule</code>, on the receiver side. It uses <code class="inlineCode">labels</code> to determine which Pods run the old and new versions of the microservice.</p>
    <p class="normal">To support canary tests, a routing rule is required in the virtual services that always routes the canary testers to the <code class="inlineCode">new</code> subset. To identify canary testers, we will assume that requests from a canary tester contain an HTTP header named <code class="inlineCode">X-group</code> with the value <code class="inlineCode">test</code>.</p>
    <p class="normal">A template has been added to the <code class="inlineCode">common</code> Helm chart for creating a set of virtual services that can split the traffic between two versions of a microservice. The template is named <code class="inlineCode">_istio_vs_green_blue_deploy.yaml</code> and looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">{{<span class="hljs-bullet">-</span> <span class="hljs-string">define</span> <span class="hljs-string">"common.istio_vs_green_blue_deploy"</span> <span class="hljs-string">-</span>}}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">range</span> <span class="hljs-string">$name</span> <span class="hljs-string">:=</span> <span class="hljs-string">.Values.virtualServices</span> }}
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> {{ <span class="hljs-string">$name</span> }}
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">hosts:</span>
  <span class="hljs-bullet">-</span> {{ <span class="hljs-string">$name</span> }}
  <span class="hljs-attr">http:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">headers:</span>
        <span class="hljs-attr">X-group:</span>
          <span class="hljs-attr">exact:</span> <span class="hljs-string">test</span>
    <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> {{ <span class="hljs-string">$name</span> }}
        <span class="hljs-attr">subset:</span> <span class="hljs-string">new</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> {{ <span class="hljs-string">$name</span> }}
        <span class="hljs-attr">subset:</span> <span class="hljs-string">old</span>
      <span class="hljs-attr">weight:</span> <span class="hljs-number">100</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> {{ <span class="hljs-string">$name</span> }}
        <span class="hljs-attr">subset:</span> <span class="hljs-string">new</span>
      <span class="hljs-attr">weight:</span> <span class="hljs-number">0</span>
<span class="hljs-meta">---</span>
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> <span class="hljs-string">-</span>}}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> <span class="hljs-string">-</span>}}
</code></pre>
    <p class="normal">From the template, we can see the following:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">range</code> directive<a id="_idIndexMarker1365"/> loops over the elements defined in the <code class="inlineCode">virtualServices</code> variable</li>
      <li class="bulletList">The <code class="inlineCode">hosts</code> field in the <code class="inlineCode">spec</code> part of the manifest is used to specify the names of the Kubernetes service that this <code class="inlineCode">VirtualService</code> will apply to</li>
      <li class="bulletList">In the <code class="inlineCode">http</code> section, three routing destinations are declared:<ul>
          <li class="bulletList">One route matching the canary testers’ HTTP header, <code class="inlineCode">X-group</code>, set to <code class="inlineCode">test</code>. This route always sends the requests to the <code class="inlineCode">new</code> subset.</li>
          <li class="bulletList">One route destination for the <code class="inlineCode">old</code> subset and one for the <code class="inlineCode">new</code> subset.</li>
          <li class="bulletList">The <code class="inlineCode">weight</code> is specified as a percentage and the sum of the weights will always be 100.</li>
        </ul>
      </li>
      <li class="bulletList">All traffic is initially routed to the <code class="inlineCode">old</code> subset</li>
    </ul>
    <p class="normal">To be able to route canary testers to the new versions based on header-based routing, the <code class="inlineCode">product-composite</code> microservice has been updated to forward the HTTP header, <code class="inlineCode">X-group</code>. Refer to the <code class="inlineCode">getCompositeProduct()</code> method in the <code class="inlineCode">se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl</code> class for details.</p>
    <p class="normal">For the destination rules, we will reuse the template introduced in the <em class="italic">Content in the _istio_dr_mutual_tls.yaml template</em> section above. This template will be used by the <code class="inlineCode">prod-env</code> Helm chart to specify the versions of the microservices to be used. This is described in the <em class="italic">Tying things together in the prod-env Helm chart</em> section below.</p>
    <h3 id="_idParaDest-465" class="heading-3">Deployments and services</h3>
    <p class="normal">To make it possible for a destination rule<a id="_idIndexMarker1366"/> to identify the version of a Pod based on its labels, a <code class="inlineCode">version</code> label has been added in the template for deployments in the <code class="inlineCode">common</code> Helm chart, <code class="inlineCode">_deployment.yaml</code>. Its value is set to the <code class="inlineCode">tag</code> of the Pod’s Docker image. We will use the Docker image tags <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code>, so that will also be the value of the <code class="inlineCode">version</code> label. The added line looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-attr">version:</span> {{ <span class="hljs-string">.Values.image.tag</span> }}
</code></pre>
    <p class="normal">To give the Pods and their Deployment objects names that contain their version, their default names have been overridden in the <code class="inlineCode">prod-env</code> chart. In their <code class="inlineCode">values.yaml</code> files, the <code class="inlineCode">fullnameOverride</code> field is used to specify a name that includes version info. This is done for the three core microservices and looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">product:</span>
  <span class="hljs-attr">fullnameOverride:</span> <span class="hljs-string">product-v1</span>
<span class="hljs-attr">recommendation:</span>
  <span class="hljs-attr">fullnameOverride:</span> <span class="hljs-string">recommendation-v1</span>
<span class="hljs-attr">review:</span>
  <span class="hljs-attr">fullnameOverride:</span> <span class="hljs-string">review-v1</span>
</code></pre>
    <p class="normal">An undesired side effect of this is that the corresponding Service objects will also get a name that includes the version info. As explained above, we need to have one service that can route requests to the different versions of the Pods. To avoid this naming problem, the Service template, <code class="inlineCode">_service.yaml</code>, in the <code class="inlineCode">common</code> Helm chart is updated to use the <code class="inlineCode">common.name</code> template instead of the <code class="inlineCode">common.fullname</code> template used previously in <em class="chapterRef">Chapter 17</em>.</p>
    <p class="normal">Finally, to be able to deploy multiple <a id="_idIndexMarker1367"/>versions of the three core microservices, their Helm charts have been duplicated in the <code class="inlineCode">kubernetes/helm/components</code> folder. The name of the new charts is suffixed with <code class="inlineCode">-green</code>. The only difference compared to the existing charts is that they don’t include the Service template from the <code class="inlineCode">common</code> chart, avoiding the creation of two Service objects per core microservice. The new charts are named <code class="inlineCode">product-green</code>, <code class="inlineCode">recommendation-green</code>, and <code class="inlineCode">review-green</code>.</p>
    <h3 id="_idParaDest-466" class="heading-3">Tying things together in the prod-env Helm chart</h3>
    <p class="normal">The <code class="inlineCode">prod-env</code> Helm chart includes the <code class="inlineCode">_istio_vs_green_blue_deploy.yaml</code> template from the <code class="inlineCode">common</code> Helm chart, as well as the <a id="_idIndexMarker1368"/>templates included by the <code class="inlineCode">dev-env</code> chart; see the <em class="italic">Creating the service mesh</em> section.</p>
    <p class="normal">The three new <code class="inlineCode">*-green</code> Helm charts for the core microservices are added as dependencies to the <code class="inlineCode">Chart.yaml</code> file.</p>
    <p class="normal">In its <code class="inlineCode">values.yaml</code> file, everything is tied together. From the previous section, we have seen how the <code class="inlineCode">v1</code> versions of the core microservices are defined with names that include version info.</p>
    <p class="normal">For the <code class="inlineCode">v2</code> versions, the three new <code class="inlineCode">*-green</code> Helm charts are used. The values are the same as for the <code class="inlineCode">v1</code> versions except for the name and Docker image tag. For example, the configuration of the <code class="inlineCode">v2</code> version of the <code class="inlineCode">product</code> microservice looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">product-green:</span>
  <span class="hljs-attr">fullnameOverride:</span> <span class="hljs-string">product-v2</span>
  <span class="hljs-attr">image:</span>
    <span class="hljs-attr">tag:</span> <span class="hljs-string">v2</span>
</code></pre>
    <p class="normal">To declare virtual services for the three core microservices, the following declaration is used:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">virtualServices:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">product</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">recommendation</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">review</span>
</code></pre>
    <p class="normal">Finally, the destination rules are declared in a similar way as in the <code class="inlineCode">dev-env</code> Helm chart. The main difference is that we now use subsets to declare the actual versions that should be used when traffic is routed by the virtual services to either the <code class="inlineCode">old</code> or the <code class="inlineCode">new</code> subset. For example, the destination rule for the <code class="inlineCode">product</code> microservice is declared like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">destinationRules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">product</span>
    <span class="hljs-attr">subsets:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">old</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">new</span>
<span class="hljs-string">...</span>
</code></pre>
    <p class="normal">From the declaration above, we <a id="_idIndexMarker1369"/>can see that traffic sent to the <code class="inlineCode">old</code> subset is directed to <code class="inlineCode">v1</code> Pods of the <code class="inlineCode">product</code> microservice and to <code class="inlineCode">v2</code> Pods for the <code class="inlineCode">new</code> subset.</p>
    <p class="normal">For details, see the file in the <code class="inlineCode">prod-env</code> chart available in the <code class="inlineCode">kubernetes/helm/environments/prod-env</code> folder.</p>
    <div class="packt_tip">
      <p class="normal">Note that this is where we declare for the production environment what the existing (<code class="inlineCode">old</code>) and the coming (<code class="inlineCode">new</code>) versions are, <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> in this scenario. In a future scenario, where it is time to upgrade <code class="inlineCode">v2</code> to <code class="inlineCode">v3</code>, the <code class="inlineCode">old</code> subset should be updated to use <code class="inlineCode">v2</code> and the <code class="inlineCode">new</code> subset should use <code class="inlineCode">v3</code>.</p>
    </div>
    <p class="normal">Now, we have seen all the changes to the source code and we are ready to deploy <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions of the microservices.</p>
    <h2 id="_idParaDest-467" class="heading-2">Deploying v1 and v2 versions of the microservices with routing to the v1 version</h2>
    <p class="normal">To be able to test the <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions of the microservices, we need to remove the development environment we<a id="_idIndexMarker1370"/> used earlier in this chapter and create a production environment where we can deploy the <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions of the microservices.</p>
    <p class="normal">To achieve this, run the following commands:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Uninstall the development environment:
        <pre class="programlisting con"><code class="hljs-con">helm uninstall hands-on-dev-env
</code></pre>
      </li>
      <li class="numberedList">To monitor the termination of Pods in the development environment, run the following command until it reports <code class="inlineCode">No resources found in hands-on namespace</code>:
        <pre class="programlisting con"><code class="hljs-con">kubectl get pods
</code></pre>
      </li>
      <li class="numberedList">Start MySQL, MongoDB, and RabbitMQ outside of Kubernetes:
        <pre class="programlisting con"><code class="hljs-con">eval $(minikube docker-env)
docker-compose up -d mongodb mysql rabbitmq
</code></pre>
      </li>
      <li class="numberedList">Tag the Docker images with <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions:
        <pre class="programlisting con"><code class="hljs-con">docker tag hands-on/auth-server hands-on/auth-server:v1
docker tag hands-on/product-composite-service hands-on/product-composite-service:v1
docker tag hands-on/product-service hands-on/product-service:v1
docker tag hands-on/recommendation-service hands-on/recommendation-service:v1
docker tag hands-on/review-service hands-on/review-service:v1
docker tag hands-on/product-service hands-on/product-service:v2
docker tag hands-on/recommendation-service hands-on/recommendation-service:v2
docker tag hands-on/review-service hands-on/review-service:v2
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions of the microservices will be the same versions of the microservices in this test. But it doesn’t matter to Istio, so we can use this simplified approach to test Istio’s routing capabilities.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Deploy the system<a id="_idIndexMarker1371"/> landscape using Helm and wait for all deployments to complete:
        <pre class="programlisting con"><code class="hljs-con">helm install hands-on-prod-env \
  kubernetes/helm/environments/prod-env \
  -n hands-on --wait
</code></pre>
      </li>
      <li class="numberedList">Once the deployment is complete, verify that we have <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> Pods up and running for the three core microservices with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl get pods
</code></pre>
        <p class="normal">Expect a response like this:</p>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_22.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence" width="812" height="304"/></figure>
    <p class="packt_figref">Figure 18.22: v1 and v2 Pods deployed at the same time</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Run the usual tests to <a id="_idIndexMarker1372"/>verify that everything works:
        <pre class="programlisting con"><code class="hljs-con">./test-em-all.bash
</code></pre>
      
    <p class="normal">Unfortunately, the tests will fail initially with an error message like:</p>
    <pre class="programlisting con"><code class="hljs-con">- Response Body: Jwks doesn't have key to match kid or alg from Jwt
</code></pre></li>
    </ol>
    <p class="normal">This error is caused by the Istio daemon, <code class="inlineCode">istiod</code>, caching the JWKS public keys from the auth server in the development environment. The auth server in the production environment will have new JWKS keys but the same identity as <code class="inlineCode">istiod</code>, so it tries to reuse the old JWKS public keys, causing this failure. Istio caches JWKS public keys for 20 minutes by default, but when installing Istio, we lowered the refresh interval to 15 seconds; see the <em class="italic">Deploying Istio in a Kubernetes cluster</em> section. So, after waiting a short while, up to a minute depending on how quickly the refreshed keys are propagated, you should be able to run the tests successfully. The tests might still fail once the issue with cached JWKS has disappeared, with errors such as this:</p>
    <pre class="programlisting con"><code class="hljs-con">Test FAILED, EXPECTED VALUE: 3, ACTUAL VALUE: 0, WILL ABORT
</code></pre>
    <p class="normal">Then, simply rerun the command and it should run fine! These errors are secondary failures caused by the original error caused by the JWKS cache.</p>
    <p class="normal">Expect output that is similar to what we have seen from the previous chapters:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_23.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="650" height="247"/></figure>
    <p class="packt_figref">Figure 18.23: Tests run successfully</p>
    <p class="normal">We are now ready to run some <strong class="keyWord">zero-downtime deployment</strong> tests. Let’s begin by verifying that all traffic goes to the <code class="inlineCode">v1</code> version <a id="_idIndexMarker1373"/>of the microservices!</p>
    <h2 id="_idParaDest-468" class="heading-2">Verifying that all traffic initially goes to the v1 version of the microservices</h2>
    <p class="normal">To verify that all requests are<a id="_idIndexMarker1374"/> routed to the <code class="inlineCode">v1</code> version of the microservices, we will start up the load test tool, <code class="inlineCode">siege</code>, and then observe the traffic that flows through the service mesh using Kiali.</p>
    <p class="normal">Perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Get a new access token and start the <code class="inlineCode">siege</code> load test tool, with the following commands:
        <pre class="programlisting con"><code class="hljs-con">ACCESS_TOKEN=$(curl https://writer:secret-writer@minikube.me/oauth2/token -d grant_type=client_credentials -d scope="product:read product:write" -ks | jq .access_token -r)
echo ACCESS_TOKEN=$ACCESS_TOKEN
siege https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN" -c1 -d1 -v
</code></pre>
      </li>
      <li class="numberedList">Go to the <strong class="screenText">Graph</strong> view in Kiali’s web UI (<a href="https://kiali.minikube.me"><span class="url">https://kiali.minikube.me</span></a>):<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Click on the <strong class="screenText">Display</strong> menu button and select <strong class="screenText">Namespace Boxes</strong>.</li>
          <li class="alphabeticList">Click on the <strong class="screenText">App graph</strong> menu button and select <strong class="screenText">Versioned app graph</strong>.</li>
          <li class="alphabeticList">Expect only traffic to the <strong class="screenText">v1</strong> version of the microservices, as follows:</li>
        </ol>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_24.png" alt="A screenshot of a diagram  Description automatically generated with low confidence" width="812" height="765"/></figure>
    <p class="packt_figref">Figure 18.24: All requests go to the v1 Pods</p>
    <p class="normal">This means that, even<a id="_idIndexMarker1375"/> though the <code class="inlineCode">v2</code> versions of the microservices are deployed, they do not get any traffic routed to them. Let’s now try out canary tests where selected test users are allowed to try out the <code class="inlineCode">v2</code> versions of the microservices!</p>
    <h2 id="_idParaDest-469" class="heading-2">Running canary tests</h2>
    <p class="normal">To run a canary test so that <a id="_idIndexMarker1376"/>some users are routed to the new versions while all other users are still routed to the old versions of the deployed microservices, we need to add the <code class="inlineCode">X-group</code> HTTP header set to the value <code class="inlineCode">test</code> in our requests sent to the external API.</p>
    <p class="normal">To see which version of a microservice served a request, the <code class="inlineCode">serviceAddresses</code> field in the response can be inspected. The <code class="inlineCode">serviceAddresses</code> field contains the hostname of each service that took part in creating the response. The hostname is equal to the name of the Pod, so we can find the version in the hostname; for example, <code class="inlineCode">product-v1-...</code> for a <code class="inlineCode">product</code> service of version <code class="inlineCode">v1</code>, and <code class="inlineCode">product-v2-...</code> for a <code class="inlineCode">product</code> service of version <code class="inlineCode">v2</code>.</p>
    <p class="normal">Let’s begin by sending a normal request and verifying that it is the <code class="inlineCode">v1</code> versions of the microservices that respond to our request. Next, we’ll send a request with the <code class="inlineCode">X-group</code> HTTP header set to the value <code class="inlineCode">test</code>, and verify that the new <code class="inlineCode">v2</code> versions are responding.</p>
    <p class="normal">To do this, perform the<a id="_idIndexMarker1377"/> following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Perform a normal request to verify that the request is routed to the <code class="inlineCode">v1</code> version of the microservices by using <code class="inlineCode">jq</code> to filter out the <code class="inlineCode">serviceAddresses</code> field in the response:
        <pre class="programlisting con"><code class="hljs-con">ACCESS_TOKEN=$(curl https://writer:secret-writer@minikube.me/oauth2/token  -d grant_type=client_credentials -d scope="product:read product:write" -ks | jq .access_token -r)
echo ACCESS_TOKEN=$ACCESS_TOKEN
curl -ks https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN" | jq .serviceAddresses
</code></pre>
        <p class="normal">Expect a response along the lines of the following:</p>
        <figure class="mediaobject"><img src="../Images/B19825_18_25.png" alt="A screenshot of a computer  Description automatically generated" width="712" height="226"/></figure>
        <p class="packt_figref">Figure 18.25: All requests go to the v1 Pods</p>
        <p class="normal">As expected, all three core services are <code class="inlineCode">v1</code> versions of the microservices.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">If we add the <code class="inlineCode">X-group=test</code> header, we expect the request to be served by <code class="inlineCode">v2</code> versions of the core microservices. Run the following command:
        <pre class="programlisting con"><code class="hljs-con">curl -ks https://minikube.me/product-composite/1 -H "Authorization: Bearer $ACCESS_TOKEN" -H "X-group: test" | jq .serviceAddresses
</code></pre>
      
    <p class="normal">Expect a response similar to the following:</p></li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_26.png" alt="A screenshot of a computer  Description automatically generated" width="731" height="234"/></figure>
    <p class="packt_figref">Figure 18.26: Setting the HTTP header to X-group=test makes the requests go to the v2 Pods</p>
    <p class="normal">As expected, all three core microservices that respond are now <code class="inlineCode">v2</code> versions; as a canary tester, we<a id="_idIndexMarker1378"/> are routed to the new <code class="inlineCode">v2</code> versions!</p>
    <p class="normal">Given that the canary tests returned the expected results, we are ready to allow normal users to be routed to the new <code class="inlineCode">v2</code> versions using a blue-green deployment.</p>
    <h2 id="_idParaDest-470" class="heading-2">Running a blue-green deployment</h2>
    <p class="normal">To route a portion of the normal users to the new <code class="inlineCode">v2</code> versions of the microservices, we need to modify the weight distribution in the<a id="_idIndexMarker1379"/> virtual services. They are currently 100/0; in other words, all traffic is routed to the old <code class="inlineCode">v1</code> versions. We can achieve this, as we did before, by editing the manifest files of the virtual services and executing a <code class="inlineCode">kubectl apply</code> command to make the changes take effect. As an alternative, we can use the <code class="inlineCode">kubectl patch</code> command to change the weight distribution directly on the <code class="inlineCode">virtual Service</code> objects in the Kubernetes API server.</p>
    <p class="normal">I find the <code class="inlineCode">patch</code> command useful when making a number of changes to the same objects to try something out, for example, to change the weight distribution in the routing rules. In this section, we will use the <code class="inlineCode">kubectl patch</code> command to quickly change the weight distribution in the routing rules between the <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions of the microservices. To get the state of a virtual service after a few <code class="inlineCode">kubectl patch</code> commands have been executed, a command such as <code class="inlineCode">kubectl get vs NNN -o yaml</code> can be issued. For example, to get the state of the virtual service of the <code class="inlineCode">product</code> microservice, issue the following command: <code class="inlineCode">kubectl get vs product -o yaml</code>.</p>
    <p class="normal">Since we haven’t used the <code class="inlineCode">kubectl patch</code> command before and it can be a bit involved to start with, let’s undertake a short introduction to see how it works before we perform the blue-green deployment.</p>
    <h3 id="_idParaDest-471" class="heading-3">A short introduction to the kubectl patch command</h3>
    <p class="normal">The <code class="inlineCode">kubectl patch</code> command can be used to update specific fields in an existing object in the Kubernetes API server. We will try<a id="_idIndexMarker1380"/> the patch command on the virtual service for the review microservice, named <code class="inlineCode">review</code>. The relevant parts of the definition of the virtual service, <code class="inlineCode">review</code>, appear as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">http:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span>
    <span class="hljs-string">...</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">review</span>
        <span class="hljs-attr">subset:</span> <span class="hljs-string">old</span>
      <span class="hljs-attr">weight:</span> <span class="hljs-number">100</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">review</span>
        <span class="hljs-attr">subset:</span> <span class="hljs-string">new</span>
      <span class="hljs-attr">weight:</span> <span class="hljs-number">0</span> 
</code></pre>
    <p class="normal">A sample <code style="font-weight: bold;" class="codeHighlighted">patch</code> command that changes the weight distribution of the routing to the <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> Pods in the <code class="inlineCode">review</code> microservice appears as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">kubectl</span> <span class="hljs-string">patch</span> <span class="hljs-string">virtualservice</span> <span class="hljs-string">review</span> <span class="hljs-string">--type=json</span> <span class="hljs-string">-p='[</span>
  {<span class="hljs-attr">"op":</span> <span class="hljs-string">"add"</span>, <span class="hljs-attr">"path":</span> <span class="hljs-string">"/spec/http/1/route/0/weight"</span>, <span class="hljs-attr">"value":</span> <span class="hljs-number">80</span>}<span class="hljs-string">,</span>
  {<span class="hljs-attr">"op":</span> <span class="hljs-string">"add"</span>, <span class="hljs-attr">"path":</span> <span class="hljs-string">"/spec/http/1/route/1/weight"</span>, <span class="hljs-attr">"value":</span> <span class="hljs-number">20</span>}
<span class="hljs-string">]'</span>
</code></pre>
    <p class="normal">The command will configure the routing rules of the <code class="inlineCode">review</code> microservice to route 80% of the requests to the old version, and 20% of the requests to the new version.</p>
    <p class="normal">To specify that the <code class="inlineCode">weight</code> value should be changed in the <code class="inlineCode">review</code> virtual service, the <code class="inlineCode">/spec/http/1/route/0/weight</code> path is given for the old version, and <code class="inlineCode">/spec/http/1/route/1/weight</code> for the new version.</p>
    <p class="normal">The <code class="inlineCode">0</code> and <code class="inlineCode">1</code> in the path are used to specify the index of array elements in the definition of the virtual service. For example, <code class="inlineCode">http/1</code> means the second element in the array under the <code class="inlineCode">http</code> element. See the definition of the preceding <code class="inlineCode">review</code> virtual service.</p>
    <p class="normal">From the definition, we can see that the first element with index <code class="inlineCode">0</code> is the <code class="inlineCode">match</code> element, which we will not change. The second element is the <code class="inlineCode">route</code> element, which we want to change.</p>
    <p class="normal">Now that we know a bit more about the <code class="inlineCode">kubectl patch</code> command, we are ready to test a blue-green deployment.</p>
    <h3 id="_idParaDest-472" class="heading-3">Performing the blue-green deployment</h3>
    <p class="normal">It is time to gradually move <a id="_idIndexMarker1381"/>more and more users to the new versions using a blue-green deployment. To perform the deployment, run the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Ensure that the load test tool, <code class="inlineCode">siege</code>, is still running. Note that it was started in the preceding <em class="italic">Verifying that all traffic initially goes to the v1 version of the microservices</em> section.</li>
      <li class="numberedList">To allow 20% of users to <a id="_idIndexMarker1382"/>be routed to the new <code class="inlineCode">v2</code> version of the review microservice, we can patch the virtual service and change the weights with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl patch virtualservice review --type=json -p='[
  {"op": "add", "path": "/spec/http/1/route/0/weight", "value":  
  80},
  {"op": "add", "path": "/spec/http/1/route/1/weight", "value":  
  20}
]'
</code></pre>
      </li>
      <li class="numberedList">To observe the change in the routing rule, go to the Kiali web UI (<a href="https://kiali.minikube.me"><span class="url">https://kiali.minikube.me</span></a>) and select the <strong class="screenText">Graph</strong> view.</li>
      <li class="numberedList">Click on the <strong class="screenText">Display</strong> menu and change the edge labels to <strong class="screenText">Traffic Distribution</strong>.</li>
      <li class="numberedList">Wait for a minute before the metrics are updated in Kiali so that we can observe the change. Expect the graph in Kiali to show something like the following:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_18_27.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="812" height="618"/></figure>
    <p class="packt_figref">Figure 18.27: 80% goes to v1 services and 20% goes to v2 services</p>
    <p class="normal">Depending on how long you have waited, the graph might look a bit different! In the screenshot, we can see that Istio now routes traffic to both the <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> versions of the <code class="inlineCode">review</code> microservice.</p>
    <p class="normal">Of the traffic that is sent to<a id="_idIndexMarker1383"/> the <code class="inlineCode">review</code> microservice from the <code class="inlineCode">product-composite</code> microservice, 6.4% is routed to the new <code class="inlineCode">v2</code> Pod, and 22.3% to the old <code class="inlineCode">v1</code> Pod. This means that 6.4/(6.4 + 22.3) = 22% of the requests are routed to the <code class="inlineCode">v2</code> Pod, and 78% to the <code class="inlineCode">v1</code> Pod. This is in line with the 20/80 distribution we have requested.</p>
    <p class="normal">Please feel free to try out the preceding <code class="inlineCode">kubectl patch</code> command to affect the routing rules for the other core microservices, <code class="inlineCode">product</code> and <code class="inlineCode">recommendation</code>.</p>
    <p class="normal">To simplify changing the weight distribution for all three core microservices, the<code class="inlineCode">./kubernetes/routing-tests/split-traffic-between-old-and-new-services.bash</code> script can be used. For example, to route all traffic to the <code class="inlineCode">v2</code> version of all microservices, run the following script, feeding it with the weight distribution <code class="inlineCode">0 100</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">./kubernetes/routing-tests/split-traffic-between-old-and-new-services.bash 0 100
</code></pre>
    <p class="normal">You have to give Kiali a minute or two to collect metrics before it can visualize the changes in routing, but remember that the change in the actual routing is immediate!</p>
    <p class="normal">Expect that requests are routed only to the <code class="inlineCode">v2</code> versions of the microservices in the graph after a while:</p>
    <figure class="mediaobject"><img src="../Images/B19825_18_28.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="878" height="829"/></figure>
    <p class="packt_figref">Figure 18.28: All traffic goes to v2 services</p>
    <p class="normal">Depending on how long you have waited, the graph might look a bit different!</p>
    <p class="normal">If something goes terribly<a id="_idIndexMarker1384"/> wrong following the upgrade to <code class="inlineCode">v2</code>, the following command can be executed to revert all traffic to the <code class="inlineCode">v1</code> version of all microservices:</p>
    <pre class="programlisting con"><code class="hljs-con">./kubernetes/routing-tests/split-traffic-between-old-and-new-services.bash 100 0
</code></pre>
    <p class="normal">After a short while, the graph in Kiali should look like the screenshot in the previous <em class="italic">Verifying that all traffic initially goes to the v1 version of the microservices</em> section, showing all requests going to the <code class="inlineCode">v1</code> version of all microservices again.</p>
    <p class="normal">This concludes the introduction to the service mesh concept and Istio as an implementation of it.</p>
    <p class="normal">Before we wrap up the chapter, let’s recap how we can run tests in Docker Compose to ensure that the source code of our<a id="_idIndexMarker1385"/> microservices does not rely on either the deployment in Kubernetes or the presence of Istio.</p>
    <h1 id="_idParaDest-473" class="heading-1">Running tests with Docker Compose</h1>
    <p class="normal">As mentioned a few times now, it is important to ensure that the source code of the microservices doesn’t become <a id="_idIndexMarker1386"/>dependent on a platform such as Kubernetes or Istio from a functional perspective.</p>
    <p class="normal">To verify that the microservices work as expected without the presence of Kubernetes and Istio, run the tests as described in <em class="chapterRef">Chapter 17</em> (refer to the <em class="italic">Testing with Docker Compose</em> section). Since the default values of the test script, <code class="inlineCode">test-em-all.bash</code>, have been changed, as described previously in the <em class="italic">Running commands to create the service mesh</em> section, the following parameters must be set when using Docker Compose: <code class="inlineCode">USE_K8S=false HOST=localhost PORT=8443 HEALTH_URL=https://localhost:8443</code>. For example, to run the tests using the default Docker Compose file, <code class="inlineCode">docker-compose.yml</code>, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">USE_K8S=false HOST=localhost PORT=8443 HEALTH_URL=https://localhost:8443 ./test-em-all.bash start stop
</code></pre>
    <p class="normal">The test script should, as before, begin by starting all containers; it should then run the tests and, finally, stop all containers. For details of the expected output, see <em class="chapterRef">Chapter 17</em> (refer to the <em class="italic">Verifying that the microservices work without Kubernetes</em> section).</p>
    <p class="normal">After successfully executing the tests using Docker Compose, we have verified that the microservices are dependent on neither Kubernetes nor Istio from a functional perspective. These tests conclude the chapter on using Istio as a service mesh.</p>
    <h1 id="_idParaDest-474" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we learned about the service mesh concept and Istio, an open source implementation of the concept. A service mesh provides capabilities for handling challenges in a system landscape of microservices in areas such as security, policy enforcement, resilience, and traffic management. A service mesh can also be used to make a system landscape of microservices observable by visualizing the traffic that flows through the microservices.</p>
    <p class="normal">For observability, Istio can be integrated with Kiali, Jaeger, and Grafana (more on Grafana and Prometheus in <em class="chapterRef">Chapter 20</em>, <em class="italic">Monitoring Microservices</em>). When it comes to security, Istio can be configured to use a certificate to protect external APIs with HTTPS and require that external requests contain valid JWT-based OAuth 2.0/OIDC access tokens. Finally, Istio can be configured to automatically protect internal communication using mutual authentication (mTLS).</p>
    <p class="normal">For resilience and robustness, Istio comes with mechanisms for handling retries, timeouts, and an outlier detection mechanism similar to a circuit breaker. In many cases, it is preferable to implement these resilience capabilities in the source code of the microservices, if possible. The ability in Istio to inject faults and delays is very useful for verifying that the microservices in the service mesh work together as a resilient and robust system landscape. Istio can also be used to handle zero-downtime deployments. Using its fine-grained routing rules, both canary and blue-green deployments can be performed.</p>
    <p class="normal">One important area that we haven’t covered yet is how to collect and analyze log files created by all microservice instances. In the next chapter, we will see how this can be done using a popular stack of tools, known as the EFK stack, based on Elasticsearch, Fluentd, and Kibana.</p>
    <h1 id="_idParaDest-475" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is the purpose of a proxy component in a service mesh?</li>
      <li class="numberedList">What’s the difference between a control plane and a data plane in a service mesh?</li>
      <li class="numberedList">What is the <code class="inlineCode">istioctl kube-inject</code> command used for?</li>
      <li class="numberedList">What is the <code class="inlineCode">minikube tunnel</code> command used for?</li>
      <li class="numberedList">What tools are Istio integrated with for observability?</li>
      <li class="numberedList">What configuration is required to make Istio protect communication within the service mesh using mutual authentication?</li>
      <li class="numberedList">What can the <code class="inlineCode">abort</code> and <code class="inlineCode">delay</code> elements in a virtual service be used for?</li>
      <li class="numberedList">What configuration is required to set up a blue-green deployment scenario?</li>
    </ol>
  </div>
</div>
</div>
</body></html>