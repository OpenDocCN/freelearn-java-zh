<html><head></head><body>
		<div id="_idContainer072">
			<h1 class="chapter-number" id="_idParaDest-121"><a id="_idTextAnchor195"/>12</h1>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor196"/>Final Considerations</h1>
			<p>We have explored the architectural perspective of persistence, delved into Jakarta EE and MicroProfile, examined modern persistence technologies and their trade-offs, and discussed the essential aspects of persistence in the cloud era. This final chapter will reflect on the key insights and considerations gathered throughout our persistence journey. Now, let us combine the lessons learned and draw <span class="No-Break">some conclusions:</span></p>
			<ul>
				<li><strong class="bold">Embracing the architectural perspective</strong>: Understanding the architectural perspective<a id="_idIndexMarker467"/> is crucial for designing robust and scalable persistence solutions. A holistic approach that aligns persistence with the overall system architecture ensures we can effectively manage complexity and evolve our applications over time. By considering factors such as data modeling, transaction management, caching, and scalability, we can build systems that meet the demands of <span class="No-Break">modern applications.</span></li>
				<li><strong class="bold">Jakarta EE and MicroProfile</strong>: The Jakarta EE<a id="_idIndexMarker468"/> and MicroProfile<a id="_idIndexMarker469"/> specifications provide a standardized foundation for building enterprise Java applications. These frameworks offer many persistence-related APIs and features that simplify development. By adhering to these standards, we can benefit from portability, interoperability, and a vibrant ecosystem of compatible libraries <span class="No-Break">and tools.</span></li>
				<li><strong class="bold">Modern persistence technologies and trade-offs</strong>: The landscape of persistence technologies<a id="_idIndexMarker470"/> has evolved significantly, offering developers diverse options. We explored the trade-offs associated with different approaches, such as relational databases, NoSQL databases, and object-relational mapping frameworks. Each technology has its strengths and weaknesses, and the choice depends on specific project requirements. Understanding the trade-offs<a id="_idIndexMarker471"/> helps us make informed decisions and optimize the persistence layer for <span class="No-Break">our applications.</span></li>
				<li><strong class="bold">Persistence essentials in the cloud era</strong>: The rise of cloud computing has introduced new challenges and opportunities in the persistence domain. Cloud-native persistence<a id="_idIndexMarker472"/> solutions such as managed database services, distributed caching, and event-driven architectures enable us to build resilient, elastic, and cost-efficient applications. We discussed essential considerations for achieving persistence in the cloud, including scalability, data consistency, multi-region deployments, and <span class="No-Break">serverless architectures.</span></li>
				<li><strong class="bold">The importance of continuous learning</strong>: Persistence is dynamic, with new technologies and approaches emerging regularly. As developers, it is essential to cultivate a mindset of continuous learning and stay updated with the latest trends. It includes monitoring <a id="_idIndexMarker473"/>advancements in Jakarta EE and MicroProfile, exploring new database technologies, and understanding best practices for cloud-native persistence. By embracing a learning mindset, we can adapt to evolving requirements and leverage the full potential of persistence in <span class="No-Break">our applications.</span></li>
			</ul>
			<p>In this chapter, we’ll explore these <span class="No-Break">topics further:</span></p>
			<ul>
				<li>The power of tests and leading with <span class="No-Break">data-domain tests</span></li>
				<li>Don’t underestimate the documentation; this <span class="No-Break">helps scalability</span></li>
				<li>The software architecture is there, with or <span class="No-Break">without archi<a id="_idTextAnchor197"/>tects</span></li>
			</ul>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor198"/>The power of tests - How to lead with data-domain tests</h1>
			<p>Ensuring data and behavior consistency is a critical aspect of building robust and reliable applications. Application<a id="_idIndexMarker474"/> bugs can introduce inconsistencies in data, leading to unexpected behavior and incorrect results. Implementing effective testing strategies can help identify and prevent such issues. Integration testing and <a id="_idIndexMarker475"/>data-driven testing are effective approaches to verifying the correctness and consistency of the <span class="No-Break">application’s behavior.</span></p>
			<p>Integration testing<a id="_idIndexMarker476"/> involves testing the interactions between different components of an application to ensure they work together as expected. It is particularly relevant when trying the persistence layer, as it allows you to validate the integration between the application and the underlying data <span class="No-Break">storage systems.</span></p>
			<p>Data-driven testing<a id="_idIndexMarker477"/> validates the application’s behavior with different input datasets. By systematically varying the input data and comparing the expected results with the actual outputs, you can identify inconsistencies and detect any potential bugs that might impact <span class="No-Break">data consistency.</span></p>
			<p>Java has several testing frameworks and tools to facilitate integration and data-driven testing. JUnit Jupiter<a id="_idIndexMarker478"/> is a popular testing framework that provides a robust and flexible platform for writing and executing tests. It offers various annotations, assertions, and test execution life cycle callbacks to support integration <span class="No-Break">testing scenarios.</span></p>
			<p>AssertJ<a id="_idIndexMarker479"/> is another powerful library that enhances the readability and expressiveness of assertions in tests. It provides a fluent API for performing claims on various data types, making validating expected results easier and ensuring <span class="No-Break">data consistency.</span></p>
			<p>Test Container<a id="_idIndexMarker480"/> is a Java library that simplifies the testing of applications that depend on external resources such as databases, message brokers, or other containers. It allows you to define and manage lightweight, isolated containers for your integration tests, providing a convenient way to ensure consistent behavior when working with <span class="No-Break">external systems.</span></p>
			<p>Remember, testing is a<a id="_idIndexMarker481"/> crucial part of the development process, and investing in solid testing practices will help you identify and resolve data consistency issues early, leading to more robust and trustworthy applications. After tests, let’s<a id="_idIndexMarker482"/> move on to an underestimated topic in software development: documentation. It reduces the number of meetings, breaks down the silos, and can help you with <span class="No-Break">distr<a id="_idTextAnchor199"/>ibuted systems.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor200"/>Do not underestimate the importance of documentation</h1>
			<p>Documentation<a id="_idIndexMarker483"/> is crucial in software development, enabling teams to achieve scalability, streamline onboarding processes, break down knowledge silos, and ensure everyone is aligned and moving in the <span class="No-Break">right direction.</span></p>
			<p>As<a id="_idIndexMarker484"/> projects and teams grow, the need for scalability becomes evident. Documentation is a knowledge repository allowing teams to effectively share information and best practices. Developers can easily understand the system’s structure and collaborate efficiently by documenting architectural decisions, design patterns, and coding conventions. This scalability ensures that as teams expand or new members join, the collective knowledge is preserved, and onboarding <span class="No-Break">becomes smoother.</span></p>
			<p>Onboarding new team members can be a time-consuming and challenging process. Documentation provides a resource for new developers to quickly familiarize themselves with the project’s architecture, design principles, and coding standards. It flattens the learning curve and enables newcomers to learn quickly. Well-documented systems also facilitate knowledge transfer during employee transitions, minimizing the impact of personnel changes on <span class="No-Break">project continuity.</span></p>
			<p>In many organizations, knowledge silos can hinder collaboration and productivity and tend to cause errors. When knowledge resides with specific individuals, it becomes difficult for others to access and benefit from it. Documentation helps break down these silos by capturing and sharing expertise across the team. By documenting architectural decisions, integration patterns, and implementation details, teams can democratize knowledge and empower everyone to contribute to the <span class="No-Break">project’s success.</span></p>
			<p>Documentation serves as a compass, guiding the team in the right direction. It captures the “why” behind architectural choices, design decisions, and coding practices. By documenting these rationales, teams establish a shared understanding and vision for the project. It ensures everyone is aligned with the system’s purpose, goals, and desired outcomes. Documentation is a reference point, allowing developers to make informed decisions and avoid <span class="No-Break">diverging paths.</span></p>
			<p>Documentation plays a crucial role in the context of distributed systems by providing clarity and understanding of the system’s architecture, integration points, and communication protocols. It acts as a means to communicate the system’s structure, behavior, and dependencies to all stakeholders, ensuring a common language <span class="No-Break">and understanding.</span></p>
			<p>The documentation defines integration points, data formats, and communication protocols, facilitating seamless interoperability. It captures fault tolerance, resilience, and scalability strategies, enabling teams to design and implement systems that gracefully handle failures and optimize performance. Detailed documentation outlines deployment architectures, configuration parameters, and troubleshooting steps, aiding in the smooth setup, management, and maintenance of distributed systems. Overall, documentation in distributed systems enhances understanding, collaboration, and effective leadership, leading to improved reliability, performance, and <span class="No-Break">system quality.</span></p>
			<p>The <a id="_idIndexMarker485"/>C4 model, popularized by Simon Brown, provides a robust framework for documenting software <a id="_idIndexMarker486"/>architecture. It employs a hierarchical structure that allows teams to zoom in and out, giving high-level overviews and detailed views of the system’s components and their interactions. The C4 model acts as a “Google Maps” for architecture, enabling teams to communicate and visualize complex <span class="No-Break">systems effectively.</span></p>
			<p>In addition to <a id="_idIndexMarker487"/>architectural documentation, it is crucial to focus on tactical documentation<a id="_idIndexMarker488"/> at the code level. Clear and concise code comments, descriptive functions, and variable names enhance code readability and <a id="_idIndexMarker489"/>maintainability. It includes well-documented code, informative README files, and comprehensive changelogs. README files provide an overview of the project, installation instructions, and usage examples, facilitating collaboration with other developers. changelogs keep track of the version <a id="_idIndexMarker490"/>history, documenting feature additions, bug fixes, and other <span class="No-Break">notable changes.</span></p>
			<p>Documentation is a powerful tool in software development, aiding team scalability, facilitating onboarding, breaking down knowledge silos, and ensuring alignment and direction from documenting architectural decisions to providing tactical documentation at the code level, investing time and effort in creating comprehensive and <span class="No-Break">accessible documentation.</span></p>
			<p>If, after discussing <a id="_idIndexMarker491"/>documentation and testing, you are still here, let’s finish this chapter with a topic that we also don’t enjoy, or at least has become a red flag because of bad practices we’ve encountered in<a id="_idTextAnchor201"/> the <span class="No-Break">past: architecture.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor202"/>Architecture without architects</h1>
			<p>In the past, companies often associated software architecture with a centralized area of command and control, which may not have resulted in a better experience for engineers. However, it is crucial to recognize that software architecture goes beyond having a sector or team setup. It plays a significant role in the entire <span class="No-Break">organization’s success.</span></p>
			<p>Software architecture<a id="_idIndexMarker492"/> encompasses a system’s fundamental structure and design, encompassing its components, interactions, and overall organization. It is the blueprint for building robust, scalable, and maintainable systems. While some people perceive architecture as an optional concern, architecture is always present, whether we notice it <span class="No-Break">or not.</span></p>
			<p>A well-designed software architecture provides numerous benefits, especially in distributed systems. Good architecture comes in handy, especially when taking into consideration that <span class="No-Break">distributed systems:</span></p>
			<ul>
				<li>Often need <a id="_idIndexMarker493"/>to handle increased loads and accommodate growing user bases. A well-thought-out architecture considers scalability, enabling the system to handle higher traffic volumes and adapt to changing demands. It allows for horizontal scaling by distributing components across multiple nodes and leveraging load-balancing techniques, resulting in better performance <span class="No-Break">and responsiveness.</span></li>
				<li>Are prone to failures and network disruptions. With a robust architecture, you can incorporate fault tolerance and resilience strategies. It includes redundancy, replication, error-handling mechanisms, and the ability to recover gracefully from failures. By designing for resilience, your system can maintain availability and continue functioning despite individual <span class="No-Break">component failures.</span></li>
				<li>Often involve multiple components and services that must work together seamlessly. A well-designed architecture promotes modularity, encapsulation, and loose coupling between components. This modular approach allows for the more accessible development, testing, deployment, and evolution of individual members, enabling flexibility and adaptability to changing <span class="No-Break">business requirements.</span></li>
				<li>Frequently interact with external services, APIs, and data sources. A well-defined architecture facilitates seamless integration and interoperability with these external systems. By clearly defining communication protocols, API contracts, and integration patterns, the architecture enables smooth interactions, making it easier to consume or expose services and exchange data with <span class="No-Break">external entities.</span></li>
				<li>Must be <a id="_idIndexMarker494"/>designed to handle the demands of large-scale data processing and communication. A well-architected system can optimize performance by considering data locality, caching strategies, load balancing, and efficient communication protocols. You can minimize latency, bandwidth usage, and resource contention through careful architectural choices, ultimately improving the system’s <span class="No-Break">overall performance.</span></li>
			</ul>
			<p>In conclusion, software architecture is not merely a sector or team but a crucial aspect of the entire organization’s success. Good architecture helps build scalable, resilient, flexible, and performant distributed systems. By considering factors such as scalability, resilience, flexibility, interoperability, and performance optimization, a well-designed architecture sets the foundation for building distributed systems that meet the challenges and complexities of m<a id="_idTextAnchor203"/>odern <span class="No-Break">software development.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor204"/>Summary</h1>
			<p>To wrap it up, we express our sincere gratitude to you, the reader, for accompanying us to the end of this book. We hope the knowledge and insights shared throughout these pages are as valuable to you, as it were to us. Use this book whenever needed, as a helpful resource to understanding the intricacies of persistence in software development. Have in mind that this book is just the beginning of your persistence journey as a software engineer. The persistence field is continually evolving, with new technologies, patterns, and trade-offs emerging. Embrace this opportunity to learn and grow, staying curious and open-minded to recent advancements in persistence. By applying the principles and concepts covered in this book and remaining eager to explore further, you will be well equipped to tackle the challenges and opportunities in your journey as a software engineer. Again, thank you, and we wish you great success in<a id="_idTextAnchor205"/> your <span class="No-Break">persistent endeavors.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor206"/>Further reading</h1>
			<ul>
				<li><em class="italic">Effective Software Testing: A Developer’s Guide</em> by <em class="italic">Maurizio Aniche</em>, to delve deeper into effective software testing practices. This book provides valuable insights and techniques for improving your testing skills, including strategies for integration testing, data-driven testing, and other essential testing concepts. By leveraging the knowledge shared in this book, you can enhance the quality and reliability of your software through comprehensive and <span class="No-Break">effective testing.</span></li>
				<li><em class="italic">Fundamentals of Software Architecture an Engineering Approach</em> by <em class="italic">Neal Ford</em> is a highly recommended book that provides valuable insights into software architecture principles, patterns, and best practices. It covers essential topics such as architectural styles, design principles, scalability, modularity, and so on. By studying this book, you can enhance your understanding of software architecture and apply it effectively to <span class="No-Break">distributed systems.</span></li>
				<li><em class="italic">Docs for Developers: An Engineer’s Field Guide to Technical Writing</em> by <em class="italic">Jared Bhatti</em>, <em class="italic">Sarah Corleissen</em>, <em class="italic">Jen Lambourne</em>, and <em class="italic">David Nunez</em> is a comprehensive and practical book that is an invaluable resource for developers looking to enhance their technical writing skills. Written by experts in the field, this book delves into the nuances of practical documentation, offering insights, strategies, and best practices tailored specifically to the needs <span class="No-Break">of developers.</span></li>
				<li><em class="italic">The C4 Model for Visualising Software Architecture</em> by <em class="italic">Simon Brown</em> is a transformative book that offers developers a comprehensive framework for effectively visualizing and communicating software architecture. Authored by experienced practitioners, this book introduces the C4 model – a pragmatic approach that simplifies complex architectural designs into a series of hierarchical diagrams. By providing a clear and consistent language for representing software systems, components, containers, and code, the C4 model facilitates effective communication and collaboration among developers, architects, <span class="No-Break">and stakeholders.</span></li>
			</ul>
		</div>
	</body></html>