- en: '*Chapter 3*: Introducing the IBM Stock Trader Cloud-Native Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：介绍IBM股票交易员云原生应用'
- en: Throughout this book, we'll be using an example application known as **IBM Stock
    Trader** to demonstrate various concepts and techniques. This open source example
    is intended to show people how to develop, deploy, and use a typical cloud-native
    application that is composed of various microservices and leverages various external
    services such as databases, messaging systems, and internet services. All microservices
    are containerized and deployed (via an operator) to a Kubernetes cluster such
    as the **OpenShift Container Platform**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用一个名为**IBM股票交易员**的示例应用来演示各种概念和技术。这个开源示例旨在向人们展示如何开发、部署和使用一个由各种微服务组成且利用各种外部服务（如数据库、消息系统和服务）的典型云原生应用。所有微服务都是容器化的，并通过操作员部署到Kubernetes集群，例如**OpenShift容器平台**。
- en: As the name implies, the IBM Stock Trader example exists in the financial domain,
    simulating a brokerage application that tracks the stocks each customer has purchased
    in their portfolio. While it doesn't actually buy or sell anything, it does look
    up current actual prices of specified stocks and computes an overall portfolio
    value that maps to a customer loyalty level. It also simulates an account balance
    from which it debits commissions paid per trade and tracks the **return on investment**
    (**ROI**) for each portfolio. As well as this, it has optional pieces that do
    things such as send out notifications when new loyalty levels are reached and
    analyze submitted feedback to see if free (no commission) trades should be granted,
    demonstrating how it interacts with real-world systems such as Slack, Twitter,
    or **International Business Machine Corporation's** (**IBM's**) Watson.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，IBM股票交易员示例存在于金融领域，模拟了一个跟踪客户在其投资组合中购买的股票的经纪应用。虽然它实际上不购买或出售任何东西，但它确实会查找指定股票的当前实际价格，并计算映射到客户忠诚度级别的整体投资组合价值。它还模拟了一个账户余额，从中扣除每次交易的佣金，并跟踪每个投资组合的**投资回报率**（ROI）。此外，它还包括一些可选部分，例如在新忠诚度级别达到时发送通知，并分析提交的反馈以查看是否应授予免费（无佣金）交易，展示了它如何与Slack、Twitter或**国际商业机器公司**（**IBM**）的Watson等现实世界系统交互。
- en: As we discuss each MicroProfile 4.x technology in upcoming chapters, we'll be
    referring back to how this example demonstrates the usage of each. We'll include
    code snippets from various microservices that comprise the example, explaining
    the benefits the application derives from using each MicroProfile technology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论每个MicroProfile 4.x技术时，会回过头来看这个示例是如何演示每个技术的使用。我们将包括来自构成示例的各种微服务的代码片段，解释应用程序从使用每个MicroProfile技术中获得的益处。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Overview of the IBM Stock Trader application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM股票交易员应用的概述
- en: Mandatory microservices and external services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制性微服务和外部服务
- en: Optional microservices and external services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选微服务和外部服务
- en: By the end of this chapter, you will be familiar with the application, how to
    use it, how the various parts fit together to make a composite application, and
    which parts you can ignore if you're in a hurry.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉该应用的应用方式、如何使用它、各个部分如何组合成一个复合应用，以及如果你时间紧迫可以忽略哪些部分。
- en: Overview of the IBM Stock Trader application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IBM股票交易员应用的概述
- en: Created and enhanced over the past 3-4 years, this polyglot example demonstrates
    how to create containerized microservices, targeting a variety of application
    runtimes. For the most part, these microservices are deliberately kept simple
    so that readers don't get bogged down in the deep technical intricacies that would
    likely exist in a real brokerage application. That said, it is very much intended
    to be significantly more instructive than the various *Hello World*-level examples
    often shown in beginners' documentation for cloud-native programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去3-4年中创建和改进的这种多语言示例演示了如何创建容器化微服务，针对各种应用程序运行时。大部分微服务被故意保持简单，以免读者陷入可能存在于真实经纪应用中的深奥技术复杂性。尽管如此，它非常旨在比云原生编程初学者文档中经常展示的各种*Hello
    World*级别示例具有更显著的教育意义。
- en: The example consists of about a dozen microservices that interact with about
    a dozen external dependencies (most of which are optional). There is also a Helm
    chart and an OpenShift operator (which wraps the Helm chart) used for deployment
    of the example, which will be covered in [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173),
    *Deployment and Day 2 Operations*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例由大约一打微服务组成，这些微服务与大约一打外部依赖项（其中大部分是可选的）进行交互。此外，还有一个Helm图表和一个OpenShift操作符（它封装了Helm图表），用于部署示例，这将在[*第9章*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173)，“部署和第二天操作”中介绍。
- en: In this section, we will provide a high-level overview of the application, the
    microservices that comprise it, and what they do. Let's start by looking at **user
    interfaces** (**UIs**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一个关于应用程序、构成它的微服务以及它们所做的高层次概述。让我们首先看看**用户界面**（**UIs**）。
- en: UIs
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UIs
- en: 'Before diving into all of the backend microservices running in the cloud, let''s
    look at what is provided as a client for you to use in your web browser. There
    is actually a choice of **graphical UI** (**GUI**) clients for this example. There''s
    a simple Java servlet /JSP-based UI called **Trader** that deliberately uses very
    simplistic **HyperText Markup Language** (**HTML**) to render results so that
    the servlet code is easily understandable. Let''s take a look at this simplistic
    client in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨在云中运行的全部后端微服务之前，让我们看看作为客户端提供给你在网页浏览器中使用的有哪些。实际上，对于这个示例，有几种**图形用户界面**（**GUI**）客户端可供选择。有一个简单的基于Java
    servlet / JSP的UI称为**Trader**，它故意使用非常简单的**超文本标记语言**（**HTML**）来渲染结果，以便servlet代码易于理解。让我们在下面的屏幕截图中看看这个简单的客户端：
- en: '![Figure 3.1 – Simple Java servlet-based UI: Trader'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 简单基于Java servlet的UI：Trader'
- en: '](img/Figure_1.1_B17377_new.png)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.1_B17377_new.png](img/Figure_1.1_B17377_new.png)'
- en: 'Figure 3.1 – Simple Java servlet-based UI: Trader'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 简单基于Java servlet的UI：Trader
- en: As you can see, this client provides a list of the portfolios and allows you
    to view the details of one, modify one, create a new one, or delete one. You have
    to log in successfully to use the client and have the option to submit feedback,
    which can lead to free (no-commission) trades. It will show your current loyalty
    level, your account balance, and your ROI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个客户端提供了一个投资组合列表，并允许您查看一个投资组合的详细信息、修改一个、创建一个新的或删除一个。您必须成功登录才能使用客户端，并且可以选择提交反馈，这可能导致免费（无佣金）交易。它将显示您的当前忠诚度级别、您的账户余额和您的投资回报率。
- en: 'There is also a fancier user interface called **Tradr** that is written in
    Node.js using the **Vue.js UI framework** and that provides a more modern experience;
    this requires JavaScript to be enabled in your browser. Let''s take a look at
    that one too—you can see it in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个更华丽的用户界面称为**Tradr**，它使用**Vue.js UI框架**编写，并提供了一个更现代的体验；这需要在您的浏览器中启用JavaScript。让我们也看看这个——您可以在下面的屏幕截图中看到它：
- en: '![Figure 3.2 – Fancy Node.js-based UI: Tradr'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 奢华的基于Node.js的UI：Tradr'
- en: '](img/Figure_1.2_B17377.png.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.2_B17377.png.jpg](img/Figure_1.2_B17377.png.jpg)'
- en: 'Figure 3.2 – Fancy Node.js-based UI: Tradr'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 奢华的基于Node.js的UI：Tradr
- en: Both clients have the same functionality. The fancier one is a bit more complicated
    to understand when reading its code, but it presents a much more professional-looking,
    responsive experience. Trader looks as though it was written at the end of the
    twentieth century, while Tradr looks as though it was written in the modern day.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个客户端具有相同的功能。更华丽的那个在阅读其代码时理解起来稍微复杂一些，但它提供了一个看起来更加专业、响应式的体验。Trader看起来像是20世纪末编写的，而Tradr看起来像是现代编写的。
- en: 'There is also a command-line client called `loopctl` that runs a specified
    number of iterations (on parallel threads) of actions upon portfolios, which can
    be used for performance and throughput testing, as illustrated here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为`loopctl`的命令行客户端，它运行指定次数的迭代（在并行线程上）的操作，可以对投资组合进行性能和吞吐量测试，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the interest of brevity, only the first 4 of the 12 steps in each iteration
    are shown in the preceding output. In short, it creates a new portfolio, buys
    and sells stock in it, and deletes it, and does these dozen steps as many times
    as you request, on as many parallel threads as you want, and reports timings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，前一个输出中只显示了每个迭代中的前4个步骤。简而言之，它创建一个新的投资组合，在其中买卖股票，然后删除它，并且根据您的请求，在尽可能多的并行线程上重复这些步骤，并报告时间。
- en: No matter which of the three clients you use, they all make **REpresentational
    State Transfer** (**REST**) calls to the same **Broker** microservice, which in
    turn reaches out to the other microservices as needed, as we'll see in the next
    section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪三个客户端，它们都会向同一个**经纪人**微服务发出**表示性状态转移（REST**）调用，而该微服务随后根据需要与其他微服务进行交互，正如我们将在下一节中看到的。
- en: Architectural diagram
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构图
- en: 'Let''s take a look at a diagram showing how all of the pieces fit together.
    It may look a little overwhelming at first but, per the advice from *The Hitchhiker''s
    Guide to the Galaxy*, "*don''t panic!".* Most of the microservices and dependencies
    you see in the following diagram are optional:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个展示所有组件如何组合在一起的图。一开始可能会觉得有点令人不知所措，但根据《银河系漫游指南》的建议，“**不要慌张**”！在下面的图中，您看到的多数微服务和依赖项都是可选的：
- en: '![Figure 3.3 – Architectural diagram'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 架构图'
- en: '](img/Figure_1.3_B17377.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B17377.jpg)'
- en: Figure 3.3 – Architectural diagram
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 架构图
- en: There is a GitHub repository at [https://github.com/IBMStockTrader](https://github.com/IBMStockTrader)
    for each of the solid color boxes shown in *Figure 3.3*. As per standard GitHub
    naming conventions, each microservice name is converted to all lowercase, and
    a dash is used between words in a multi-word name; for example, the **Stock Quote**
    microservice is available at [https://github.com/IBMStockTrader/stock-quote](https://github.com/IBMStockTrader/stock-quote).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*图3.3*中显示的每个实色框，都有一个位于[https://github.com/IBMStockTrader](https://github.com/IBMStockTrader)的GitHub仓库。根据标准的GitHub命名约定，每个微服务名称被转换为全部小写，多词名称中的单词之间用连字符分隔；例如，**股票报价**微服务可在[https://github.com/IBMStockTrader/stock-quote](https://github.com/IBMStockTrader/stock-quote)找到。
- en: There is also a Docker Hub repository at [https://hub.docker.com/u/ibmstocktrader](https://hub.docker.com/u/ibmstocktrader)
    for each of these microservices. You can of course build each from their source
    code in GitHub (which we'll discuss in [*Chapter 8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159),
    *Building and Testing your Cloud-Native Application*) and push the images to whichever
    image repository you want, such as the one built into your OpenShift cluster.
    But to make it easier to deploy the example, there are pre-built images provided
    as well. If you use the operator to deploy the example, it will default to pulling
    the images from Docker Hub, but you can replace the default image and tag fields
    for each microservice to pull from any image repository.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些微服务，每个都有一个位于[https://hub.docker.com/u/ibmstocktrader](https://hub.docker.com/u/ibmstocktrader)的Docker
    Hub仓库。当然，您可以从GitHub（我们将在[*第8章*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159)，*构建和测试您的云原生应用程序）中的源代码构建每个微服务，并将镜像推送到您想要的任何镜像仓库，例如集成到您的OpenShift集群中的那个。但为了更容易部署示例，也提供了预构建的镜像。如果您使用操作员部署示例，它将默认从Docker
    Hub拉取镜像，但您可以替换每个微服务的默认镜像和标签字段，以从任何镜像仓库拉取。
- en: In the following sections, we'll look at each microservice in the application,
    as well as its dependencies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们将查看应用程序中的每个微服务及其依赖项。
- en: Mandatory microservices and external services
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必需的微服务和外部服务
- en: As mentioned earlier, the core part of the example is just that which is needed
    to do the basics of creating portfolios and buying/selling stock. Those parts
    of the example have a solid border around each box, as shown in *Figure 3.3*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本例的核心部分仅仅是创建投资组合和买卖股票的基本操作所需的部分。这些部分的示例都有坚固的边框，如图*图3.3*所示。
- en: The following subsections will describe each of the microservices and their
    dependencies that are required in order to exercise the primary functionality
    of the **IBM Stock Trader** application—that is, the ability to create portfolios
    and buy and sell stocks within them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将描述构成**IBM股票交易员**应用程序主要功能（即创建投资组合和在其中买卖股票的能力）所需的每个微服务及其依赖项。
- en: Trader
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易员
- en: '**Trader** is the standard UI client for the example. As seen earlier in *Figure
    3.1*, it presents a list of existing portfolios, allowing you to create new ones,
    update existing ones (by buying or selling stocks), and delete portfolios. It
    communicates, via REST service calls, with the Broker microservice, passing a
    **JavaScript Object Notation (JSON) Web Token** (**JWT**) for **single-sign-on**
    (**SSO**) purposes.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**交易员**是本例的标准UI客户端。如前文*图3.1*所示，它展示了一个现有投资组合列表，允许您创建新的投资组合，更新现有的投资组合（通过买卖股票），以及删除投资组合。它通过REST服务调用与经纪人微服务进行通信，传递用于**单点登录（SSO**）的**JavaScript对象表示法（JSON）Web令牌（JWT**）。'
- en: It is implemented via a set of simple Java servlets and JSPs that, as with most
    of the Stock Trader microservices, runs atop the open source Open Liberty application
    server, running in the **Universal Base Image** (**UBI**), which is a **Red Hat
    Enterprise Linux** (**RHEL**) 8.4 container with the Open J9 Java 11 **virtual
    machine** (**VM**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过一组简单的Java servlets和JSP实现，就像大多数股票交易员微服务一样，在开源Open Liberty应用程序服务器上运行，该服务器在**通用基础镜像**（**UBI**）上运行，这是一个**Red
    Hat Enterprise Linux**（**RHEL**） 8.4容器，带有Open J9 Java 11 **虚拟机**（**VM**）。
- en: There are choices for how this client performs authentication. The default and
    easiest way is to log in against a hardcoded list of credentials defined in a
    `basicRegistry` stanza within the `server.xml` file of the Trader microservice,
    such as `stock`/`trader` as the **identifier** (**ID**)/password.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此客户端如何执行认证，有一些选择。默认且最简单的方式是在交易微服务的`server.xml`文件中的`basicRegistry`部分定义的硬编码凭据列表中进行登录，例如`stock`/`trader`作为**标识符**（**ID**）/密码。
- en: LDAP
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LDAP
- en: Another option you can choose with the Trader microservice is to log in against
    your company's **Lightweight Directory Access Protocol** (**LDAP**) server. This
    way, your employees can log in against their corporate user registry, such as
    with their serial number or email address. Note that if you are deploying the
    example to an OpenShift cluster in the public cloud and your user registry server
    runs in an on-premises data center behind a firewall, then you'll need to set
    up a **virtual private network** (**VPN**) connection back to that LDAP server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择使用交易微服务对公司的**轻量级目录访问协议**（**LDAP**）服务器进行登录。这样，您的员工可以使用他们的公司用户注册信息进行登录，例如使用序列号或电子邮件地址。请注意，如果您将示例部署到公共云中的OpenShift集群，并且您的用户注册服务器在防火墙后面的本地数据中心运行，那么您需要设置一个**虚拟专用网络**（**VPN**）连接回该LDAP服务器。
- en: OIDC
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OIDC
- en: The final option for authentication with the Trader microservice is to log in
    using an **OpenID Connect** (**OIDC**) server. This option is often used if you
    want to require authentication via a third-party provider out on the internet,
    such as logging in via your Facebook, Twitter, or GitHub credentials. For testing
    purposes, you can also deploy your own OIDC server locally into your OpenShift
    cluster, such as by using the operator (in OperatorHub) for **Red Hat SSO** (**RH-SSO**),
    which is based on the open source **Keycloak** project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交易微服务的最终认证选项是使用**OpenID Connect**（**OIDC**）服务器进行登录。如果您想通过互联网上的第三方提供者进行认证，例如通过Facebook、Twitter或GitHub凭据登录，通常会使用此选项。出于测试目的，您还可以在OpenShift集群中本地部署自己的OIDC服务器，例如使用OperatorHub中的**Red
    Hat SSO**（**RH-SSO**）操作符，该操作符基于开源的**Keycloak**项目。
- en: Broker
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经纪人
- en: Architects often recommend using a **model-view-controller** (**MVC**) architecture
    with a multi-tiered application. With the Stock Trader example, the JSON is the
    *model*, Trader (or the optional Tradr or Looper) is the *view*, and the **Broker**
    microservice serves as the *controller*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师通常建议使用**模型-视图-控制器**（**MVC**）架构的多层应用程序。在股票交易员示例中，JSON是**模型**，交易员（或可选的Tradr或Looper）是**视图**，而**经纪人**微服务充当**控制器**。
- en: It is a stateless microservice that, as with most of the microservices in this
    example, exposes a REST interface via the **Jakarta RESTful Web Services** (**JAX-RS**).
    It coordinates calls to various other microservices such as **Portfolio** and
    the optional **Account** and **Trade History**. It does not directly depend on
    any external services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无状态的微服务，就像本例中的大多数微服务一样，通过**Jakarta RESTful Web Services**（**JAX-RS**）暴露REST接口。它协调对各种其他微服务的调用，例如**投资组合**以及可选的**账户**和**交易历史**。它不直接依赖于任何外部服务。
- en: Portfolio
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投资组合
- en: This microservice takes care of all of the stock-related operations for a given
    portfolio. It reaches out to the **Stock Quote** microservice to get the current
    price of the desired stock.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务负责处理特定投资组合的所有股票相关操作。它联系**股票报价**微服务以获取所需股票的当前价格。
- en: Conceptually, it is a stateful microservice; however, it does not maintain any
    state in memory. Instead, it connects to a relational database to persist and
    access its data. That database can be running locally in your OpenShift cluster
    or out in the cloud, or in an on-premises data center (which, if so, would require
    a VPN connection to reach). The microservice uses **Java Database Connectivity**
    (**JDBC**) to interact with the database, and optionally uses **Kafka** to post
    a message to a topic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，它是一个有状态的微服务；然而，它不在内存中维护任何状态。相反，它连接到关系数据库以持久化和访问其数据。该数据库可以运行在您的 OpenShift
    集群本地，或在云中，或在本地数据中心（如果是这样，则需要 VPN 连接才能访问）。微服务使用 **Java 数据库连接**（**JDBC**）与数据库交互，并可选择使用
    **Kafka** 向一个主题发布消息。
- en: JDBC database
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JDBC 数据库
- en: '`Portfolio` and `Stock`. There is a row in the `Portfolio` table corresponding
    to each row you see in the table in the client. There is also a row in the `Stock`
    table for each stock purchased. The `Stock` table has a foreign key back to the
    `Portfolio` table, and a `cascade delete` rule on the relationship that will remove
    all of the stocks for a given portfolio if that portfolio is deleted.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Portfolio` 和 `Stock`。`Portfolio` 表中有一行对应于客户端表中看到的每一行。对于每支购买的股票，`Stock` 表中也有一个行。`Stock`
    表有一个外键回指 `Portfolio` 表，并且在该关系上有一个 `级联删除` 规则，如果删除该投资组合，将删除该投资组合的所有股票。'
- en: Since this example was created by IBMers and is often used to demonstrate how
    to connect up a cloud-native application to various IBM products, usually IBM's
    `server.xml` file and the `Dockerfile` (to copy the JDBC **Java ARchive** (**JAR**)
    file into the container) needed updates to choose a different relational database
    vendor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此示例是由 IBM 员工创建的，并且经常被用来演示如何将云原生应用程序连接到各种 IBM 产品，因此通常需要更新 IBM 的 `server.xml`
    文件和 `Dockerfile`（将 JDBC **Java 归档**（**JAR**）文件复制到容器中），以便选择不同的关系数据库供应商。
- en: 'Here''s a graphical view of the resources that Portfolio uses in a **Db2-as-a-Service**
    database hosted in the IBM cloud:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Portfolio 在 IBM 云中托管的 **Db2-as-a-Service** 数据库所使用的资源的图形视图：
- en: '![Figure 3.4 – Details of the IBM Db2 on cloud database used by Portfolio'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – Portfolio 所使用的 IBM Db2 云数据库的详细信息'
- en: '](img/Figure_1.4_B17377.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.4_B17377.jpg)'
- en: Figure 3.4 – Details of the IBM Db2 on cloud database used by Portfolio
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Portfolio 所使用的 IBM Db2 云数据库的详细信息
- en: In the preceding screenshot, you can see the details of the table holding each
    of the stocks that have been purchased; the **OWNER** column is a foreign key
    back to the portfolio containing the stocks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以查看包含已购买股票详细信息的表；**OWNER** 列是一个外键，回指包含股票的投资组合。
- en: Kafka
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kafka
- en: Portfolio also has an optional dependency on **Kafka**. If configured, Portfolio
    will publish a message to a Kafka topic whenever a stock is traded. The optional
    Trade History microservice will subscribe to this topic, using MicroProfile Reactive
    Messaging (which we'll discuss further in [*Chapter 10*](B17377_10_Final_SB_epub.xhtml#_idTextAnchor187),
    *Reactive Cloud-Native Applications*), and act upon the message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Portfolio 还有一个可选的依赖项 **Kafka**。如果配置了，每当股票交易时，Portfolio 将向 Kafka 主题发布一条消息。可选的
    Trade History 微服务将订阅此主题，使用 MicroProfile Reactive Messaging（我们将在 [*第 10 章*](B17377_10_Final_SB_epub.xhtml#_idTextAnchor187)，*反应式云原生应用程序*）进行讨论），并对消息采取行动。
- en: Usually, the **IBM Event Streams** product (from the IBM *Cloud Pak for Integration*)
    is chosen as the Kafka provider. However, other providers could be used, such
    as **AMQ Streams** from Red Hat, if desired.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，选择作为 Kafka 提供商的是来自 IBM *云集成包* 的 **IBM Event Streams** 产品。然而，如果需要，也可以使用其他提供商，例如来自
    Red Hat 的 **AMQ Streams**。
- en: Stock Quote
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 股票报价
- en: This is the simplest microservice in the example. It merely calls a REST **application
    programming interface** (**API**) in the cloud that returns the current price
    of the specified stock (quotes are 15 minutes delayed from this free service;
    more real-time quotes cost money). There is also an optional caching service that
    can be used so that calls for the same stock ticker symbol (within a configurable
    period that defaults to 1 hour) can be returned quickly, without having to make
    another call out onto the internet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例中最简单的微服务。它仅仅调用云中的 REST **应用程序编程接口**（**API**），返回指定股票的当前价格（报价比这个免费服务晚 15 分钟；更实时的报价需要付费）。还有一个可选的缓存服务，可以用来快速返回相同股票代码（在可配置的默认为
    1 小时的配置期间内）的调用，而无需再次调用互联网。
- en: Note that this is the only microservice that is configured to run on Red Hat's
    **Quarkus** application framework. All of the other Java-based microservices run
    on Open Liberty. Quarkus is another Java MicroProfile implementation. The Java
    code is the same either way; the only difference is in how it is built and configured
    and which starting-point Docker container it runs in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是唯一配置在Red Hat的**Quarkus**应用程序框架上运行的微服务。所有其他基于Java的微服务都在Open Liberty上运行。无论是哪种方式，Java代码都是相同的；唯一的区别在于它的构建和配置方式以及它运行的起始点Docker容器。
- en: API Connect
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API Connect
- en: The REST API that Stock Quote calls is implemented in **API Connect** (part
    of the *IBM Cloud Pak for Integration*). You can simply accept the defaults and
    it will use a pre-provisioned instance with everything already set up. This API
    fronts a free service out in **IEX Cloud** that returns stock prices with a 15-minute
    delay (getting more real-time prices costs money). For information on how to set
    up this API in your own instance of API Connect, see [https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4](https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 股票报价调用的REST API是在**API Connect**（IBM Cloud Pak for Integration的一部分）中实现的。你可以简单地接受默认设置，它将使用预先配置的实例，其中所有设置都已就绪。此API面向**IEX
    Cloud**中的免费服务，该服务以15分钟的延迟返回股票价格（获取更实时的价格需要付费）。有关如何在API Connect的自己的实例中设置此API的信息，请参阅[https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4](https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4)。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This API used to use a different free stock price service from Quandl, but that
    service went offline; the nice thing was that nothing in the Stock Trader example
    had to change—it was simply an update to the implementation of the API from API
    Connect, which still presented the same operation signature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此API曾经使用来自Quandl的不同免费股票价格服务，但该服务已下线；好事是，股票交易示例中的任何内容都不需要更改——这只是API Connect实现的一个更新，它仍然提供了相同的操作签名。
- en: Redis
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis
- en: Stock Quote uses **Redis** as its optional caching service. If not present,
    then each call will result in a trip out to the internet to get the stock price.
    By caching each stock's price in Redis, it means you can scale the Stock Quote
    microservice up to as many pods as you want and be sure that no matter which one
    you get routed to each time, you will get a consistent answer. It also means that
    in true *serverless* fashion (where stuff not recently used gets stopped to save
    money and restarted **just in time** (**JIT**) when new requests arrive), you
    can scale all the way down to zero pods when not needed and be sure that when
    you get scaled back up to handle new requests, you can still benefit from the
    previously cached data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 股票报价使用**Redis**作为其可选缓存服务。如果没有提供，那么每次调用都会导致访问互联网以获取股票价格。通过在Redis中缓存每只股票的价格，这意味着你可以将股票报价微服务扩展到任意数量的Pod，并确保无论每次路由到哪个Pod，你都会得到一致的答案。这也意味着在真正的**无服务器**风格中（其中不经常使用的东西会被停止以节省金钱，并在新请求到达时**即时**（JIT）重新启动），当不需要时，你可以将Pod扩展到零，并确保当你扩展回以处理新请求时，你仍然可以受益于之前缓存的资料。
- en: Optional microservices and external services
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选微服务和外部服务
- en: There are also several optional parts of the example that you would only set
    up if you wanted certain extra bells and whistles available (such as having it
    send a tweet when you level up from **SILVER** to **GOLD**). Those parts have
    a dashed border in the architectural diagram.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中还有一些可选部分，你只有在想要某些额外功能（例如，当你从**银色**升级到**金色**时发送推文）时才会设置。这些部分在架构图中带有虚线边框。
- en: Most people setting up the example skip many (or sometimes all) of the following
    pieces in the interest of simplicity. But each of these demonstrates how to do
    some additional things in a cloud-native manner, so they serve as good examples
    of how to utilize additional **Java Enterprise Edition** (**EE**)/**Jakarta EE**
    and **MicroProfile** technologies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人在设置示例时都会跳过许多（有时甚至全部）以下部分，以追求简单性。但每个部分都展示了如何以云原生的方式执行一些额外操作，因此它们作为如何利用额外的**Java企业版**（**EE**）/**Jakarta
    EE**和**MicroProfile**技术的良好示例。
- en: In this section, we will take a look at each of these optional microservices
    and their dependencies. The first of these is the alternate UI we saw earlier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看这些可选微服务和它们的依赖关系。首先是我们在之前看到的备用UI。
- en: Tradr
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tradr
- en: The more attractive UI is called **Tradr**. Its source code (the only non-Java
    microservice in the example) is a bit more complicated to read, but it provides
    a much more modern, responsive interface, as is generally expected these days
    of professional websites. It calls the exact same REST services from the Broker
    microservice—it just renders the results in a more appealing way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更吸引人的用户界面称为 **Tradr**。它的源代码（示例中唯一的非 Java 微服务）读起来稍微复杂一些，但它提供了一个更加现代、响应式的界面，这是如今专业网站普遍期望的。它调用来自经纪人微服务的相同
    REST 服务——只是以更吸引人的方式呈现结果。
- en: Note that, whereas Trader offers a choice of authentication approaches, with
    the default being a very simple approach requiring no extra setup, the Tradr client
    requires the use of OIDC. This means you have to do extra setup, to either stand
    up your own OIDC server in your OpenShift cluster or to adjust the configuration
    of an external OIDC server (which often requires registering a callback **Uniform
    Resource Locator** (**URL**) pointing back to the OpenShift route for Tradr).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 Trader 提供了认证方法的选项，默认方法是一个非常简单的无需额外设置的方法，但 Tradr 客户端需要使用 OIDC。这意味着您必须进行额外设置，要么在自己的
    OpenShift 集群中建立自己的 OIDC 服务器，要么调整外部 OIDC 服务器的配置（这通常需要注册一个回调**统一资源定位符**（**URL**），指向
    Tradr 的 OpenShift 路由）。
- en: Account
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 账户
- en: This optional microservice takes care of things associated with a portfolio
    that are above and beyond the list of which stocks it holds. This includes the
    loyalty level, the account balance, commissions paid, the owner's sentiment, and
    any free trades they have earned. Those fields will just show `Unknown` (for strings)
    or `-1` (for numbers) if this microservice is not configured.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可选的微服务负责处理与投资组合相关的事务，这些事务超出了它持有的股票列表。这包括忠诚度等级、账户余额、支付的佣金、所有者的情绪以及他们赚取的任何免费交易。如果这个微服务未配置，这些字段将仅显示`未知`（对于字符串）或`-1`（对于数字）。
- en: 'Although the Portfolio microservice chose to use an old-fashioned **Structured
    Query Language** (**SQL**)-based database, this one demonstrates the use of a
    more modern NoSQL database to store each JSON document: IBM **Cloudant** (from
    the IBM *Cloud Pak for Data*).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管投资组合微服务选择使用老式的**结构化查询语言**（**SQL**）数据库，但这个示例展示了使用更现代的 NoSQL 数据库来存储每个 JSON 文档：IBM
    **Cloudant**（来自 IBM *Cloud Pak for Data*）。
- en: Cloudant
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cloudant
- en: 'Note that whereas the Portfolio microservice had to do an object-to-relational
    mapping (such as turning the one-to-many containment relationship between `Portfolio`
    and `Stock` into a foreign key with a `cascade delete` rule), that isn''t necessary
    for the Account microservice. The exact same JSON that gets returned by each of
    the REST operations on this JAX-RS-based microservice is what is stored in the
    Cloudant database, as we can see here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然投资组合微服务必须进行对象到关系映射（例如，将 `Portfolio` 和 `Stock` 之间的一对多包含关系转换为外键，并具有`级联删除`规则），但对于账户微服务来说这不是必要的。这个基于
    JAX-RS 的微服务上每个 REST 操作返回的精确 JSON 就是存储在 Cloudant 数据库中的内容，正如我们在这里可以看到的：
- en: '![Figure 3.5 – An example Account document stored in IBM Cloudant'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 存储在 IBM Cloudant 中的一个示例账户文档'
- en: '](img/Figure_1.5_B17377.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.5_B17377.jpg]'
- en: Figure 3.5 – An example Account document stored in IBM Cloudant
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 存储在 IBM Cloudant 中的一个示例账户文档
- en: In the preceding screenshot, we can see the data that Account manages, including
    the loyalty level and the account balance. Note that the `_id` and `_rev` fields
    are ones added by Cloudant itself to manage how you find a specific document (`_id`)
    and revisions on a document (`_rev`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到账户管理的数据，包括忠诚度等级和账户余额。请注意，`_id` 和 `_rev` 字段是由 Cloudant 本身添加的，用于管理如何找到特定文档（`_id`）以及文档的修订版本（`_rev`）。
- en: ODM
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ODM
- en: Rather than hardcode the business rule for determining the loyalty level in
    Java, this microservice externalizes that rule to a business rules engine. This
    allows us to adjust thresholds, such as how high the portfolio's total value must
    reach to achieve **GOLD** status, on the fly via a dashboard, without having to
    change and redeploy the microservice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 Java 中硬编码确定忠诚度等级的业务规则不同，这个微服务将这个规则外部化到一个业务规则引擎中。这使得我们可以通过仪表板实时调整阈值，例如，投资组合的总价值必须达到多高才能实现**金**级状态，而无需更改和重新部署微服务。
- en: The example uses the IBM **Operational Decision Manager** (**ODM**), from the
    IBM *Cloud Pak for Automation*, as its business rules engine. There is a ruleset
    ZIP file in the Account Git repository ([https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip](https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip))
    that you can import into the Decision Center UI and deploy to a Decision server.
    If ODM isn't configured, the loyalty level will just remain at its starting value
    forever.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用IBM的**操作决策管理器**（**ODM**），来自IBM *自动化云包*，作为其业务规则引擎。在账户Git仓库中有一个规则集ZIP文件（[https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip](https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip)），你可以将其导入决策中心UI并部署到决策服务器。如果ODM没有配置，忠诚度级别将永远保持在起始值。
- en: 'Let''s take a look at the **Decision Center** UI in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下截图中的**决策中心**UI：
- en: '![Figure 3.6 – The IBM ODM Decision Center UI, showing our decision table'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.6 – The IBM ODM Decision Center UI, showing our decision table'
- en: '](img/Figure_1.6_B17377.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.6_B17377.jpg]'
- en: Figure 3.6 – The IBM ODM Decision Center UI, showing our decision table
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – IBM ODM决策中心UI，显示我们的决策表
- en: Here, we can see the decision table, showing the various thresholds. For example,
    once your portfolio's total value crosses **US dollars** (**USD**) $50,000, its
    loyalty level goes from **BRONZE** to **SILVER**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到决策表，显示了各种阈值。例如，一旦你的投资组合总价值超过**美元**（**USD**）50,000，其忠诚度级别将从**青铜**变为**银**。
- en: Jakarta Messaging
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 雅加达消息
- en: When the loyalty level changes (meaning you have ODM configured and have bought
    enough stock—for example, the default threshold, as you can see in *Figure 3.6*,
    is $100,000 to reach **GOLD**), the Account microservice will post a message to
    a **Jakarta Messaging** queue. There are downstream microservices that will react
    to that message.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当忠诚度级别发生变化（这意味着你已经配置了ODM并且购买了足够的股票——例如，默认阈值，如你在*图3.6*中看到的，是10万美元以达到**金**级别）时，账户微服务将向一个**雅加达消息队列**发送消息。有下游微服务会对此消息做出反应。
- en: Usually, the IBM `server.xml` file and a line in the `Dockerfile` to copy the
    Jakarta Messaging `.rar` file into the container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，IBM的`server.xml`文件和`Dockerfile`中的一个行，用于将雅加达消息`.rar`文件复制到容器中。
- en: Watson Tone Analyzer
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Watson Tone Analyzer
- en: Normally, whenever you buy or sell a stock, a commission is debited from your
    account balance. However, it is possible to earn a free (zero commission) trade
    by using the `sentiment` will be determined and returned. You get one free trade
    for submitting most kinds of feedback, but there's a rule that will give you three
    free trades in order to soothe you if it determines your sentiment is **Angry**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，无论何时买卖股票，都会从你的账户余额中扣除佣金。然而，通过使用`sentiment`将确定并返回，你可以赚取免费（零佣金）交易。提交大多数类型的反馈，你将获得一次免费交易，但有一条规则，如果它确定你的情绪是**愤怒**，将给你三次免费交易以安慰你。
- en: If you don't configure the Watson Tone Analyzer, you'll get back **Unknown**
    and no free trades.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有配置Watson Tone Analyzer，你将得到**未知**并且没有免费交易。
- en: Trade History
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易历史
- en: This microservice keeps a record of every trade you made, when you made it,
    and what the stock cost when you made it. Without this microservice, the example
    only knows aggregate information. For example, if you bought 10 shares of IBM
    stock a month ago for $100, and 5 shares a week ago for $110, and 2 more shares
    today for $120, the Portfolio microservice would just know you now have 17 shares
    and what they are worth today ($2,040 in this example). The Trade History microservice
    remembers all of the details, so it would know you spent $1,790 and thus have
    an ROI of 14%. If this microservice isn't configured, the Trader and Tradr clients
    will just say **Unknown** for the ROI.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务记录了你所进行的每一次交易，交易时间以及你交易时的股票价格。没有这个微服务，示例只能知道汇总信息。例如，如果你一个月前以100美元的价格购买了10股IBM股票，一周前以110美元的价格购买了5股，今天又以120美元的价格购买了2股，投资组合微服务只会知道你现在有17股，以及它们现在的价值（在这个例子中是2040美元）。交易历史微服务记得所有细节，所以它会知道你花费了1790美元，因此投资回报率为14%。如果这个微服务没有配置，交易员和Tradr客户端将只会说**未知**作为投资回报率。
- en: As mentioned in the discussion of the Portfolio microservice, this microservice
    subscribes to and consumes the messages that Portfolio publishes to the Kafka
    topic, such as would be managed by *IBM Event Streams*. It does so via **MicroProfile
    Reactive Messaging**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在投资组合微服务的讨论中提到的，这个微服务订阅并消费了投资组合发布到Kafka主题的消息，例如由*IBM事件流*管理。它是通过**MicroProfile反应式消息**来做到这一点的。
- en: Mongo
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mongo
- en: This microservice uses a `Ready` state and thus nothing will ever consume the
    messages from the topic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务使用`Ready`状态，因此永远不会从主题中消费消息。
- en: Messaging
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息
- en: 'This microservice consumes the JSON messages from the JMS queue about the change
    in loyalty level that the Account microservice sent. This microservice has the
    only Jakarta **Enterprise Bean** in the example, using a **Message Driven Bean**
    (**MDB**) to receive the messages. It then alerts you via the **Notification**
    microservice about the newly reached level. As with the Account microservice,
    this one also needs a Jakarta Messaging provider such as IBM MQ, as we can see
    in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务消费来自Account微服务的关于忠诚度级别变化的JMS队列中的JSON消息。这个微服务在本例中只有一个Jakarta **企业Bean**，使用**消息驱动Bean**（**MDB**）接收消息。然后通过**Notification**微服务通知您达到的新级别。与Account微服务一样，这个微服务也需要一个Jakarta
    Messaging提供者，如IBM MQ，如下面的屏幕截图所示：
- en: '![Figure 3.7 – The IBM MQ UI, showing a message sent by the Account microservice'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – IBM MQ UI，显示由Account微服务发送的消息'
- en: '](img/Figure_1.7_B17377.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.7_B17377.jpg)'
- en: Figure 3.7 – The IBM MQ UI, showing a message sent by the Account microservice
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – IBM MQ UI，显示由Account微服务发送的消息
- en: Here, we see a simple JSON message on the MQ queue that gets processed by the
    Messaging microservice to provide a notification—in this case, about **Emily**
    having upgraded her loyalty level from **SILVER** to **GOLD**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到一个简单的JSON消息在MQ队列上，该消息由Messaging微服务处理以提供通知——在这种情况下，关于**Emily**将忠诚度级别从**银色**提升到**金色**的通知。
- en: Notifications
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知
- en: There are two different flavors of the Notification microservice—one sends a
    tweet and the other posts to a Slack channel. Both have the same REST interface,
    so you just pick which you want to use when you deploy the example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Notification微服务有两种不同的版本——一个发送推文，另一个发布到Slack频道。两者都有相同的REST接口，因此您只需在部署示例时选择您想要使用的版本即可。
- en: Notification-Twitter
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Notification-Twitter
- en: The **Notification-Twitter** flavor uses the open source library from [twitter4j.org](http://twitter4j.org)
    to interact with Twitter's REST API to send a tweet.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Notification-Twitter**版本使用来自[twitter4j.org](http://twitter4j.org)的开源库与Twitter的REST
    API交互以发送推文。'
- en: Whereas most of the microservices in this example run on Open Liberty, this
    one runs on the **traditional WebSphere Application Server** (**tWAS**) in a Docker
    container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与本例中的大多数微服务在Open Liberty上运行不同，这个微服务在Docker容器中运行**传统WebSphere应用服务器**（**tWAS**）。
- en: For more information on how this was set up, see [https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370](https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何设置此信息的更多信息，请参阅[https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370](https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370)。
- en: 'To configure the example to send tweets via your account, you need to get the
    **Open Authorization** (**OAuth**) credentials for your Twitter account. You''ll
    need the consumer key and consumer secret, as well as the access token and access
    token secret. Here''s an example tweet from Notification-Twitter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置示例以通过您的账户发送推文，您需要获取您的Twitter账户的**开放授权**（**OAuth**）凭证。您需要消费者密钥和消费者密钥，以及访问令牌和访问令牌密钥。以下是从Notification-Twitter发送的示例推文：
- en: '![Figure 3.8 – An example tweet sent by Notification-Twitter'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 由Notification-Twitter发送的示例推文'
- en: '](img/Figure_1.8_B17377.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.8_B17377.jpg)'
- en: Figure 3.8 – An example tweet sent by Notification-Twitter
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 由Notification-Twitter发送的示例推文
- en: In *Figure 3.8* you see the tweet from the `@IBMStockTrader` account that was
    sent when the loyalty level upgraded from **BRONZE** to **GOLD**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.8*中，您可以看到当忠诚度级别从**青铜**提升到**金色**时，由`@IBMStockTrader`账户发送的推文。
- en: Notification-Slack
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Notification-Slack
- en: 'This flavor of the Notification microservice posts a message to a Slack channel.
    As with the Twitter flavor, it does so whenever a JMS message about a loyalty-level
    change is processed. The microservice calls a *serverless* function that sends
    the actual post to Slack, as we see here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种Notification微服务会将消息发布到Slack频道。与Twitter版本一样，每当处理关于忠诚度级别变化的JMS消息时，它都会这样做。微服务调用一个*无服务器*函数，将实际帖子发送到Slack，正如我们在这里看到的：
- en: '![Figure 3.9 – An example Slack message sent by Notification-Slack'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – 由Notification-Slack发送的示例Slack消息'
- en: '](img/Figure_1.9_B17377.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.9_B17377.jpg)'
- en: Figure 3.9 – An example Slack message sent by Notification-Slack
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 由Notification-Slack发送的示例Slack消息
- en: As you can see, the message is much like what was sent to Twitter, but in this
    case, it was sent to a Slack channel instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，消息与发送到Twitter的消息非常相似，但在这个案例中，它是发送到Slack频道的。
- en: The *serverless* function is implemented via the **Apache OpenWhisk** framework.
    You can either deploy OpenWhisk to your OpenShift cluster or use IBM's **Function-as-a-Service**
    (**FaaS**) known as *IBM Cloud Functions*. For details on how the action sequence
    was created that posts a message to the Slack channel, see [https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972](https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**无服务器**函数是通过**Apache OpenWhisk**框架实现的。您可以将OpenWhisk部署到您的OpenShift集群或使用IBM的**函数即服务**（**FaaS**）称为*IBM
    Cloud Functions*。有关创建将消息发布到Slack频道的操作序列的详细信息，请参阅[https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972](https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972)。'
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is also an Amazon Web Services (AWS) Lambda serverless function that Notification-Slack
    can invoke to cause the message to get posted to the Slack channel. It expects
    the same API definition as the OpenWhisk function, so no changes were needed to
    the Notification-Slack microservice - you just configure it with a different URL
    and credentials via the operator. Whether you choose IBM Cloud Functions or AWS
    Lambda, this shows that Kubernetes and serverless frameworks can work together
    harmoniously.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个亚马逊网络服务（AWS）Lambda无服务器函数，Notification-Slack可以调用它，将消息发布到Slack频道。它期望与OpenWhisk函数相同的API定义，因此无需对Notification-Slack微服务进行任何更改——您只需通过操作员配置不同的URL和凭据即可。无论您选择IBM
    Cloud Functions还是AWS Lambda，这都表明Kubernetes和无服务器框架可以和谐地协同工作。
- en: Collector
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集器
- en: This microservice receives evidence from other microservices, persists it to
    IBM Cloudant, and makes it available for periodic scraping by a security/compliance
    tool such as the `Trader` can be configured to send evidence about login attempts,
    and `Stock Quote` can be configured to send evidence about cache hits (in Redis).
    It receives evidence via REST (a `POST` request) and exposes evidence via REST
    (a `GET` request).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务从其他微服务接收证据，将其持久化到IBM Cloudant，并使其可供安全/合规工具定期抓取，例如`Trader`可以配置为发送有关登录尝试的证据，而`Stock
    Quote`可以配置为发送有关缓存命中的证据（在Redis中）。它通过REST（一个`POST`请求）接收证据，并通过REST（一个`GET`请求）公开证据。
- en: Unlike the other microservices, this one does not use `/collector` endpoint.
    This is similar to how `/metrics` endpoint.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他微服务不同，这个微服务不使用 `/collector` 端点。这类似于 `/metrics` 端点。
- en: Looper
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Looper
- en: The final optional microservice in this example is called `1` if not specified)
    on its route URL, you can tell it to run a specified number of iterations of a
    dozen operations, which show off all of the **create, retrieve, update, and delete**
    (**CRUD**) operations available on the Broker microservice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，如果未指定，最后一个可选的微服务在其路由URL上称为`1`，您可以指示它运行一系列操作的指定迭代次数，这些操作展示了在Broker微服务上可用的所有**创建、检索、更新和删除**（**CRUD**）操作。
- en: For example, the operator for this example (which will be described in detail
    in [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173), *Deployment
    and Day 2 Operations*) has a checkbox to set up a **Horizontal Pod Autoscaler**
    (**HPA**) that will scale up each microservice to additional pods if they reach
    certain **central processing unit** (**CPU**) thresholds (and will scale back
    down when the CPU usage drops back off). By using Looper to put the example under
    load, you can see the HPA in action, and you can see that the resource usage graphs
    in the OpenShift console show the activity.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此示例的操作员（将在第9章中详细描述，*部署和第2天操作*）有一个复选框来设置**水平Pod自动缩放器**（**HPA**），如果微服务达到某些**中央处理器**（**CPU**）阈值，则将其扩展到额外的Pod（当CPU使用率下降时将缩减）。通过使用Looper对示例进行负载测试，您可以看到HPA的实际操作，并且您可以看到OpenShift控制台中的资源使用图显示了活动。
- en: loopctl
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: loopctl
- en: One issue with requesting a large number of iterations of the `Looper` servlet
    is that you see no output until all of them are complete. In fact, most browsers,
    by default, will time out if the request takes an unreasonable amount of time
    to return.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请求`Looper` servlet的大量迭代次数的一个问题是，您在它们全部完成之前看不到任何输出。实际上，大多数浏览器默认情况下，如果请求返回所需的时间不合理，将会超时。
- en: To address this, there is a command-line client to the Looper servlet known
    as `loopctl`, which calls the `Looper` servlet in a loop.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有一个名为`loopctl`的Looper servlet命令行客户端，它循环调用`Looper` servlet。
- en: You can tell it to run a specified number of iterations on a specified number
    of parallel threads. You saw the output of this command-line client earlier. To
    run it yourself, requesting 25 iterations on 4 parallel threads, the easiest approach
    is to go to the `./loopctl.sh 25 4`, which would run 100 total iterations (temporarily
    creating portfolios named `Looper1`, `Looper2`, `Looper3`, and `Looper4`) and
    would output the average number of milliseconds per iteration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以告诉它在一个指定的并行线程数上运行指定次数的迭代。你之前已经看到了这个命令行客户端的输出。要自己运行它，请求在4个并行线程上运行25次迭代，最简单的方法是进入`./loopctl.sh
    25 4`，这将运行总共100次迭代（临时创建名为`Looper1`、`Looper2`、`Looper3`和`Looper4`的投资组合），并将输出每次迭代的平均毫秒数。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a feel for the cloud-native example that will be used throughout
    this book. Though it may appear a bit daunting at first, the mandatory parts are
    quite easy to set up (especially if you use the pre-built images in Docker Hub),
    so you can be up and running with the basics of the example in a matter of minutes.
    Then, you can add whichever of the optional bonus capabilities you'd like at your
    own pace.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对本书中将使用的云原生示例有了感觉。尽管一开始可能看起来有些令人畏惧，但强制性的部分设置起来相当简单（尤其是如果你使用Docker Hub中的预构建镜像），所以你可以在几分钟内启动示例的基本功能。然后，你可以根据自己的节奏添加任何你想要的可选功能。
- en: In the upcoming chapters, various MicroProfile technologies will be discussed
    in detail. Each will show snippets from particular microservices in this example.
    As you have seen, different microservices are meant to demonstrate different features
    of Jakarta EE and MicroProfile and provide a real running tutorial of how to integrate
    with various external services.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，将详细讨论各种MicroProfile技术。每个都将展示这个示例中特定微服务的片段。正如你所见，不同的微服务旨在展示Jakarta
    EE和MicroProfile的不同功能，并提供一个真实运行的教程，说明如何与各种外部服务集成。
- en: In [*Chapter 8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159), *Building
    and Testing your Cloud-Native Application* we'll examine how these microservices
    were developed so that you can learn how to develop such microservices yourself.
    In [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173), *Step-by-Step
    Stock Trader Development*, we'll cover the deployment of the example in detail,
    as well as *day 2* operations you can perform.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159)，*构建和测试你的云原生应用程序*中，我们将检查这些微服务是如何开发的，以便你可以学习如何自己开发这样的微服务。在第[*第9章*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173)，*逐步股票交易者开发*中，我们将详细介绍示例的部署，以及你可以执行的*第二天*操作。
- en: In the next chapter, we will begin looking at each of the MicroProfile technologies
    themselves and see how they help Java developers create cloud-native applications
    that can run in, and deeply integrate with, an orchestrated, containerized environment
    in a public or private cloud.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始查看每个MicroProfile技术本身，并了解它们如何帮助Java开发者创建可以在公共或私有云中运行并深度集成的云原生应用程序。
