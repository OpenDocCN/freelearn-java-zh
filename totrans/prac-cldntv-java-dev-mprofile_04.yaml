- en: '*Chapter 3*: Introducing the IBM Stock Trader Cloud-Native Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：介绍IBM股票交易员云原生应用'
- en: Throughout this book, we'll be using an example application known as **IBM Stock
    Trader** to demonstrate various concepts and techniques. This open source example
    is intended to show people how to develop, deploy, and use a typical cloud-native
    application that is composed of various microservices and leverages various external
    services such as databases, messaging systems, and internet services. All microservices
    are containerized and deployed (via an operator) to a Kubernetes cluster such
    as the **OpenShift Container Platform**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用一个名为**IBM股票交易员**的示例应用来演示各种概念和技术。这个开源示例旨在向人们展示如何开发、部署和使用一个由各种微服务组成且利用各种外部服务（如数据库、消息系统和服务）的典型云原生应用。所有微服务都是容器化的，并通过操作员部署到Kubernetes集群，例如**OpenShift容器平台**。
- en: As the name implies, the IBM Stock Trader example exists in the financial domain,
    simulating a brokerage application that tracks the stocks each customer has purchased
    in their portfolio. While it doesn't actually buy or sell anything, it does look
    up current actual prices of specified stocks and computes an overall portfolio
    value that maps to a customer loyalty level. It also simulates an account balance
    from which it debits commissions paid per trade and tracks the **return on investment**
    (**ROI**) for each portfolio. As well as this, it has optional pieces that do
    things such as send out notifications when new loyalty levels are reached and
    analyze submitted feedback to see if free (no commission) trades should be granted,
    demonstrating how it interacts with real-world systems such as Slack, Twitter,
    or **International Business Machine Corporation's** (**IBM's**) Watson.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，IBM股票交易员示例存在于金融领域，模拟了一个跟踪客户在其投资组合中购买的股票的经纪应用。虽然它实际上不购买或出售任何东西，但它确实会查找指定股票的当前实际价格，并计算映射到客户忠诚度级别的整体投资组合价值。它还模拟了一个账户余额，从中扣除每次交易的佣金，并跟踪每个投资组合的**投资回报率**（ROI）。此外，它还包括一些可选部分，例如在新忠诚度级别达到时发送通知，并分析提交的反馈以查看是否应授予免费（无佣金）交易，展示了它如何与Slack、Twitter或**国际商业机器公司**（**IBM**）的Watson等现实世界系统交互。
- en: As we discuss each MicroProfile 4.x technology in upcoming chapters, we'll be
    referring back to how this example demonstrates the usage of each. We'll include
    code snippets from various microservices that comprise the example, explaining
    the benefits the application derives from using each MicroProfile technology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论每个MicroProfile 4.x技术时，会回过头来看这个示例是如何演示每个技术的使用。我们将包括来自构成示例的各种微服务的代码片段，解释应用程序从使用每个MicroProfile技术中获得的益处。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Overview of the IBM Stock Trader application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM股票交易员应用的概述
- en: Mandatory microservices and external services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制性微服务和外部服务
- en: Optional microservices and external services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选微服务和外部服务
- en: By the end of this chapter, you will be familiar with the application, how to
    use it, how the various parts fit together to make a composite application, and
    which parts you can ignore if you're in a hurry.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉该应用的应用方式、如何使用它、各个部分如何组合成一个复合应用，以及如果你时间紧迫可以忽略哪些部分。
- en: Overview of the IBM Stock Trader application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IBM股票交易员应用的概述
- en: Created and enhanced over the past 3-4 years, this polyglot example demonstrates
    how to create containerized microservices, targeting a variety of application
    runtimes. For the most part, these microservices are deliberately kept simple
    so that readers don't get bogged down in the deep technical intricacies that would
    likely exist in a real brokerage application. That said, it is very much intended
    to be significantly more instructive than the various *Hello World*-level examples
    often shown in beginners' documentation for cloud-native programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去3-4年中创建和改进的这种多语言示例演示了如何创建容器化微服务，针对各种应用程序运行时。大部分微服务被故意保持简单，以免读者陷入可能存在于真实经纪应用中的深奥技术复杂性。尽管如此，它非常旨在比云原生编程初学者文档中经常展示的各种*Hello
    World*级别示例具有更显著的教育意义。
- en: The example consists of about a dozen microservices that interact with about
    a dozen external dependencies (most of which are optional). There is also a Helm
    chart and an OpenShift operator (which wraps the Helm chart) used for deployment
    of the example, which will be covered in [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173),
    *Deployment and Day 2 Operations*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will provide a high-level overview of the application, the
    microservices that comprise it, and what they do. Let's start by looking at **user
    interfaces** (**UIs**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: UIs
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into all of the backend microservices running in the cloud, let''s
    look at what is provided as a client for you to use in your web browser. There
    is actually a choice of **graphical UI** (**GUI**) clients for this example. There''s
    a simple Java servlet /JSP-based UI called **Trader** that deliberately uses very
    simplistic **HyperText Markup Language** (**HTML**) to render results so that
    the servlet code is easily understandable. Let''s take a look at this simplistic
    client in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Simple Java servlet-based UI: Trader'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B17377_new.png)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1 – Simple Java servlet-based UI: Trader'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this client provides a list of the portfolios and allows you
    to view the details of one, modify one, create a new one, or delete one. You have
    to log in successfully to use the client and have the option to submit feedback,
    which can lead to free (no-commission) trades. It will show your current loyalty
    level, your account balance, and your ROI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a fancier user interface called **Tradr** that is written in
    Node.js using the **Vue.js UI framework** and that provides a more modern experience;
    this requires JavaScript to be enabled in your browser. Let''s take a look at
    that one too—you can see it in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Fancy Node.js-based UI: Tradr'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B17377.png.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.2 – Fancy Node.js-based UI: Tradr'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Both clients have the same functionality. The fancier one is a bit more complicated
    to understand when reading its code, but it presents a much more professional-looking,
    responsive experience. Trader looks as though it was written at the end of the
    twentieth century, while Tradr looks as though it was written in the modern day.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a command-line client called `loopctl` that runs a specified
    number of iterations (on parallel threads) of actions upon portfolios, which can
    be used for performance and throughput testing, as illustrated here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the interest of brevity, only the first 4 of the 12 steps in each iteration
    are shown in the preceding output. In short, it creates a new portfolio, buys
    and sells stock in it, and deletes it, and does these dozen steps as many times
    as you request, on as many parallel threads as you want, and reports timings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: No matter which of the three clients you use, they all make **REpresentational
    State Transfer** (**REST**) calls to the same **Broker** microservice, which in
    turn reaches out to the other microservices as needed, as we'll see in the next
    section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Architectural diagram
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at a diagram showing how all of the pieces fit together.
    It may look a little overwhelming at first but, per the advice from *The Hitchhiker''s
    Guide to the Galaxy*, "*don''t panic!".* Most of the microservices and dependencies
    you see in the following diagram are optional:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Architectural diagram'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B17377.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Architectural diagram
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: There is a GitHub repository at [https://github.com/IBMStockTrader](https://github.com/IBMStockTrader)
    for each of the solid color boxes shown in *Figure 3.3*. As per standard GitHub
    naming conventions, each microservice name is converted to all lowercase, and
    a dash is used between words in a multi-word name; for example, the **Stock Quote**
    microservice is available at [https://github.com/IBMStockTrader/stock-quote](https://github.com/IBMStockTrader/stock-quote).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: There is also a Docker Hub repository at [https://hub.docker.com/u/ibmstocktrader](https://hub.docker.com/u/ibmstocktrader)
    for each of these microservices. You can of course build each from their source
    code in GitHub (which we'll discuss in [*Chapter 8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159),
    *Building and Testing your Cloud-Native Application*) and push the images to whichever
    image repository you want, such as the one built into your OpenShift cluster.
    But to make it easier to deploy the example, there are pre-built images provided
    as well. If you use the operator to deploy the example, it will default to pulling
    the images from Docker Hub, but you can replace the default image and tag fields
    for each microservice to pull from any image repository.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll look at each microservice in the application,
    as well as its dependencies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory microservices and external services
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the core part of the example is just that which is needed
    to do the basics of creating portfolios and buying/selling stock. Those parts
    of the example have a solid border around each box, as shown in *Figure 3.3*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections will describe each of the microservices and their
    dependencies that are required in order to exercise the primary functionality
    of the **IBM Stock Trader** application—that is, the ability to create portfolios
    and buy and sell stocks within them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Trader
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Trader** is the standard UI client for the example. As seen earlier in *Figure
    3.1*, it presents a list of existing portfolios, allowing you to create new ones,
    update existing ones (by buying or selling stocks), and delete portfolios. It
    communicates, via REST service calls, with the Broker microservice, passing a
    **JavaScript Object Notation (JSON) Web Token** (**JWT**) for **single-sign-on**
    (**SSO**) purposes.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: It is implemented via a set of simple Java servlets and JSPs that, as with most
    of the Stock Trader microservices, runs atop the open source Open Liberty application
    server, running in the **Universal Base Image** (**UBI**), which is a **Red Hat
    Enterprise Linux** (**RHEL**) 8.4 container with the Open J9 Java 11 **virtual
    machine** (**VM**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过一组简单的Java servlets和JSP实现，就像大多数股票交易员微服务一样，在开源Open Liberty应用程序服务器上运行，该服务器在**通用基础镜像**（**UBI**）上运行，这是一个**Red
    Hat Enterprise Linux**（**RHEL**） 8.4容器，带有Open J9 Java 11 **虚拟机**（**VM**）。
- en: There are choices for how this client performs authentication. The default and
    easiest way is to log in against a hardcoded list of credentials defined in a
    `basicRegistry` stanza within the `server.xml` file of the Trader microservice,
    such as `stock`/`trader` as the **identifier** (**ID**)/password.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此客户端如何执行认证，有一些选择。默认且最简单的方式是在交易微服务的`server.xml`文件中的`basicRegistry`部分定义的硬编码凭据列表中进行登录，例如`stock`/`trader`作为**标识符**（**ID**）/密码。
- en: LDAP
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LDAP
- en: Another option you can choose with the Trader microservice is to log in against
    your company's **Lightweight Directory Access Protocol** (**LDAP**) server. This
    way, your employees can log in against their corporate user registry, such as
    with their serial number or email address. Note that if you are deploying the
    example to an OpenShift cluster in the public cloud and your user registry server
    runs in an on-premises data center behind a firewall, then you'll need to set
    up a **virtual private network** (**VPN**) connection back to that LDAP server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择使用交易微服务对公司的**轻量级目录访问协议**（**LDAP**）服务器进行登录。这样，您的员工可以使用他们的公司用户注册信息进行登录，例如使用序列号或电子邮件地址。请注意，如果您将示例部署到公共云中的OpenShift集群，并且您的用户注册服务器在防火墙后面的本地数据中心运行，那么您需要设置一个**虚拟专用网络**（**VPN**）连接回该LDAP服务器。
- en: OIDC
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OIDC
- en: The final option for authentication with the Trader microservice is to log in
    using an **OpenID Connect** (**OIDC**) server. This option is often used if you
    want to require authentication via a third-party provider out on the internet,
    such as logging in via your Facebook, Twitter, or GitHub credentials. For testing
    purposes, you can also deploy your own OIDC server locally into your OpenShift
    cluster, such as by using the operator (in OperatorHub) for **Red Hat SSO** (**RH-SSO**),
    which is based on the open source **Keycloak** project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交易微服务的最终认证选项是使用**OpenID Connect**（**OIDC**）服务器进行登录。如果您想通过互联网上的第三方提供者进行认证，例如通过Facebook、Twitter或GitHub凭据登录，通常会使用此选项。出于测试目的，您还可以在OpenShift集群中本地部署自己的OIDC服务器，例如使用OperatorHub中的**Red
    Hat SSO**（**RH-SSO**）操作符，该操作符基于开源的**Keycloak**项目。
- en: Broker
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经纪人
- en: Architects often recommend using a **model-view-controller** (**MVC**) architecture
    with a multi-tiered application. With the Stock Trader example, the JSON is the
    *model*, Trader (or the optional Tradr or Looper) is the *view*, and the **Broker**
    microservice serves as the *controller*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师通常建议使用**模型-视图-控制器**（**MVC**）架构的多层应用程序。在股票交易员示例中，JSON是**模型**，交易员（或可选的Tradr或Looper）是**视图**，而**经纪人**微服务充当**控制器**。
- en: It is a stateless microservice that, as with most of the microservices in this
    example, exposes a REST interface via the **Jakarta RESTful Web Services** (**JAX-RS**).
    It coordinates calls to various other microservices such as **Portfolio** and
    the optional **Account** and **Trade History**. It does not directly depend on
    any external services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无状态的微服务，就像本例中的大多数微服务一样，通过**Jakarta RESTful Web Services**（**JAX-RS**）暴露REST接口。它协调对各种其他微服务的调用，例如**投资组合**以及可选的**账户**和**交易历史**。它不直接依赖于任何外部服务。
- en: Portfolio
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投资组合
- en: This microservice takes care of all of the stock-related operations for a given
    portfolio. It reaches out to the **Stock Quote** microservice to get the current
    price of the desired stock.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务负责处理特定投资组合的所有股票相关操作。它联系**股票报价**微服务以获取所需股票的当前价格。
- en: Conceptually, it is a stateful microservice; however, it does not maintain any
    state in memory. Instead, it connects to a relational database to persist and
    access its data. That database can be running locally in your OpenShift cluster
    or out in the cloud, or in an on-premises data center (which, if so, would require
    a VPN connection to reach). The microservice uses **Java Database Connectivity**
    (**JDBC**) to interact with the database, and optionally uses **Kafka** to post
    a message to a topic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: JDBC database
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Portfolio` and `Stock`. There is a row in the `Portfolio` table corresponding
    to each row you see in the table in the client. There is also a row in the `Stock`
    table for each stock purchased. The `Stock` table has a foreign key back to the
    `Portfolio` table, and a `cascade delete` rule on the relationship that will remove
    all of the stocks for a given portfolio if that portfolio is deleted.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Since this example was created by IBMers and is often used to demonstrate how
    to connect up a cloud-native application to various IBM products, usually IBM's
    `server.xml` file and the `Dockerfile` (to copy the JDBC **Java ARchive** (**JAR**)
    file into the container) needed updates to choose a different relational database
    vendor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a graphical view of the resources that Portfolio uses in a **Db2-as-a-Service**
    database hosted in the IBM cloud:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Details of the IBM Db2 on cloud database used by Portfolio'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B17377.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Details of the IBM Db2 on cloud database used by Portfolio
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the details of the table holding each
    of the stocks that have been purchased; the **OWNER** column is a foreign key
    back to the portfolio containing the stocks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Kafka
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Portfolio also has an optional dependency on **Kafka**. If configured, Portfolio
    will publish a message to a Kafka topic whenever a stock is traded. The optional
    Trade History microservice will subscribe to this topic, using MicroProfile Reactive
    Messaging (which we'll discuss further in [*Chapter 10*](B17377_10_Final_SB_epub.xhtml#_idTextAnchor187),
    *Reactive Cloud-Native Applications*), and act upon the message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the **IBM Event Streams** product (from the IBM *Cloud Pak for Integration*)
    is chosen as the Kafka provider. However, other providers could be used, such
    as **AMQ Streams** from Red Hat, if desired.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Stock Quote
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the simplest microservice in the example. It merely calls a REST **application
    programming interface** (**API**) in the cloud that returns the current price
    of the specified stock (quotes are 15 minutes delayed from this free service;
    more real-time quotes cost money). There is also an optional caching service that
    can be used so that calls for the same stock ticker symbol (within a configurable
    period that defaults to 1 hour) can be returned quickly, without having to make
    another call out onto the internet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is the only microservice that is configured to run on Red Hat's
    **Quarkus** application framework. All of the other Java-based microservices run
    on Open Liberty. Quarkus is another Java MicroProfile implementation. The Java
    code is the same either way; the only difference is in how it is built and configured
    and which starting-point Docker container it runs in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是唯一配置在Red Hat的**Quarkus**应用程序框架上运行的微服务。所有其他基于Java的微服务都在Open Liberty上运行。无论是哪种方式，Java代码都是相同的；唯一的区别在于它的构建和配置方式以及它运行的起始点Docker容器。
- en: API Connect
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API Connect
- en: The REST API that Stock Quote calls is implemented in **API Connect** (part
    of the *IBM Cloud Pak for Integration*). You can simply accept the defaults and
    it will use a pre-provisioned instance with everything already set up. This API
    fronts a free service out in **IEX Cloud** that returns stock prices with a 15-minute
    delay (getting more real-time prices costs money). For information on how to set
    up this API in your own instance of API Connect, see [https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4](https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 股票报价调用的REST API是在**API Connect**（IBM Cloud Pak for Integration的一部分）中实现的。你可以简单地接受默认设置，它将使用预先配置的实例，其中所有设置都已就绪。此API面向**IEX
    Cloud**中的免费服务，该服务以15分钟的延迟返回股票价格（获取更实时的价格需要付费）。有关如何在API Connect的自己的实例中设置此API的信息，请参阅[https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4](https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4)。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This API used to use a different free stock price service from Quandl, but that
    service went offline; the nice thing was that nothing in the Stock Trader example
    had to change—it was simply an update to the implementation of the API from API
    Connect, which still presented the same operation signature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此API曾经使用来自Quandl的不同免费股票价格服务，但该服务已下线；好事是，股票交易示例中的任何内容都不需要更改——这只是API Connect实现的一个更新，它仍然提供了相同的操作签名。
- en: Redis
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis
- en: Stock Quote uses **Redis** as its optional caching service. If not present,
    then each call will result in a trip out to the internet to get the stock price.
    By caching each stock's price in Redis, it means you can scale the Stock Quote
    microservice up to as many pods as you want and be sure that no matter which one
    you get routed to each time, you will get a consistent answer. It also means that
    in true *serverless* fashion (where stuff not recently used gets stopped to save
    money and restarted **just in time** (**JIT**) when new requests arrive), you
    can scale all the way down to zero pods when not needed and be sure that when
    you get scaled back up to handle new requests, you can still benefit from the
    previously cached data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 股票报价使用**Redis**作为其可选缓存服务。如果没有提供，那么每次调用都会导致访问互联网以获取股票价格。通过在Redis中缓存每只股票的价格，这意味着你可以将股票报价微服务扩展到任意数量的Pod，并确保无论每次路由到哪个Pod，你都会得到一致的答案。这也意味着在真正的**无服务器**风格中（其中不经常使用的东西会被停止以节省金钱，并在新请求到达时**即时**（JIT）重新启动），当不需要时，你可以将Pod扩展到零，并确保当你扩展回以处理新请求时，你仍然可以受益于之前缓存的资料。
- en: Optional microservices and external services
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选微服务和外部服务
- en: There are also several optional parts of the example that you would only set
    up if you wanted certain extra bells and whistles available (such as having it
    send a tweet when you level up from **SILVER** to **GOLD**). Those parts have
    a dashed border in the architectural diagram.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中还有一些可选部分，你只有在想要某些额外功能（例如，当你从**银色**升级到**金色**时发送推文）时才会设置。这些部分在架构图中带有虚线边框。
- en: Most people setting up the example skip many (or sometimes all) of the following
    pieces in the interest of simplicity. But each of these demonstrates how to do
    some additional things in a cloud-native manner, so they serve as good examples
    of how to utilize additional **Java Enterprise Edition** (**EE**)/**Jakarta EE**
    and **MicroProfile** technologies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人在设置示例时都会跳过许多（有时甚至全部）以下部分，以追求简单性。但每个部分都展示了如何以云原生的方式执行一些额外操作，因此它们作为如何利用额外的**Java企业版**（**EE**）/**Jakarta
    EE**和**MicroProfile**技术的良好示例。
- en: In this section, we will take a look at each of these optional microservices
    and their dependencies. The first of these is the alternate UI we saw earlier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看这些可选微服务和它们的依赖关系。首先是我们在之前看到的备用UI。
- en: Tradr
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tradr
- en: The more attractive UI is called **Tradr**. Its source code (the only non-Java
    microservice in the example) is a bit more complicated to read, but it provides
    a much more modern, responsive interface, as is generally expected these days
    of professional websites. It calls the exact same REST services from the Broker
    microservice—it just renders the results in a more appealing way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更吸引人的用户界面称为 **Tradr**。它的源代码（示例中唯一的非 Java 微服务）读起来稍微复杂一些，但它提供了一个更加现代、响应式的界面，这是如今专业网站普遍期望的。它调用来自经纪人微服务的相同
    REST 服务——只是以更吸引人的方式呈现结果。
- en: Note that, whereas Trader offers a choice of authentication approaches, with
    the default being a very simple approach requiring no extra setup, the Tradr client
    requires the use of OIDC. This means you have to do extra setup, to either stand
    up your own OIDC server in your OpenShift cluster or to adjust the configuration
    of an external OIDC server (which often requires registering a callback **Uniform
    Resource Locator** (**URL**) pointing back to the OpenShift route for Tradr).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 Trader 提供了认证方法的选项，默认方法是一个非常简单的无需额外设置的方法，但 Tradr 客户端需要使用 OIDC。这意味着您必须进行额外设置，要么在自己的
    OpenShift 集群中建立自己的 OIDC 服务器，要么调整外部 OIDC 服务器的配置（这通常需要注册一个回调**统一资源定位符**（**URL**），指向
    Tradr 的 OpenShift 路由）。
- en: Account
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 账户
- en: This optional microservice takes care of things associated with a portfolio
    that are above and beyond the list of which stocks it holds. This includes the
    loyalty level, the account balance, commissions paid, the owner's sentiment, and
    any free trades they have earned. Those fields will just show `Unknown` (for strings)
    or `-1` (for numbers) if this microservice is not configured.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可选的微服务负责处理与投资组合相关的事务，这些事务超出了它持有的股票列表。这包括忠诚度等级、账户余额、支付的佣金、所有者的情绪以及他们赚取的任何免费交易。如果这个微服务未配置，这些字段将仅显示`未知`（对于字符串）或`-1`（对于数字）。
- en: 'Although the Portfolio microservice chose to use an old-fashioned **Structured
    Query Language** (**SQL**)-based database, this one demonstrates the use of a
    more modern NoSQL database to store each JSON document: IBM **Cloudant** (from
    the IBM *Cloud Pak for Data*).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管投资组合微服务选择使用老式的**结构化查询语言**（**SQL**）数据库，但这个示例展示了使用更现代的 NoSQL 数据库来存储每个 JSON 文档：IBM
    **Cloudant**（来自 IBM *Cloud Pak for Data*）。
- en: Cloudant
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cloudant
- en: 'Note that whereas the Portfolio microservice had to do an object-to-relational
    mapping (such as turning the one-to-many containment relationship between `Portfolio`
    and `Stock` into a foreign key with a `cascade delete` rule), that isn''t necessary
    for the Account microservice. The exact same JSON that gets returned by each of
    the REST operations on this JAX-RS-based microservice is what is stored in the
    Cloudant database, as we can see here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然投资组合微服务必须进行对象到关系映射（例如，将 `Portfolio` 和 `Stock` 之间的一对多包含关系转换为外键，并具有`级联删除`规则），但对于账户微服务来说这不是必要的。这个基于
    JAX-RS 的微服务上每个 REST 操作返回的精确 JSON 就是存储在 Cloudant 数据库中的内容，正如我们在这里可以看到的：
- en: '![Figure 3.5 – An example Account document stored in IBM Cloudant'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 存储在 IBM Cloudant 中的一个示例账户文档'
- en: '](img/Figure_1.5_B17377.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.5_B17377.jpg]'
- en: Figure 3.5 – An example Account document stored in IBM Cloudant
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 存储在 IBM Cloudant 中的一个示例账户文档
- en: In the preceding screenshot, we can see the data that Account manages, including
    the loyalty level and the account balance. Note that the `_id` and `_rev` fields
    are ones added by Cloudant itself to manage how you find a specific document (`_id`)
    and revisions on a document (`_rev`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到账户管理的数据，包括忠诚度等级和账户余额。请注意，`_id` 和 `_rev` 字段是由 Cloudant 本身添加的，用于管理如何找到特定文档（`_id`）以及文档的修订版本（`_rev`）。
- en: ODM
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ODM
- en: Rather than hardcode the business rule for determining the loyalty level in
    Java, this microservice externalizes that rule to a business rules engine. This
    allows us to adjust thresholds, such as how high the portfolio's total value must
    reach to achieve **GOLD** status, on the fly via a dashboard, without having to
    change and redeploy the microservice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 Java 中硬编码确定忠诚度等级的业务规则不同，这个微服务将这个规则外部化到一个业务规则引擎中。这使得我们可以通过仪表板实时调整阈值，例如，投资组合的总价值必须达到多高才能实现**金**级状态，而无需更改和重新部署微服务。
- en: The example uses the IBM **Operational Decision Manager** (**ODM**), from the
    IBM *Cloud Pak for Automation*, as its business rules engine. There is a ruleset
    ZIP file in the Account Git repository ([https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip](https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip))
    that you can import into the Decision Center UI and deploy to a Decision server.
    If ODM isn't configured, the loyalty level will just remain at its starting value
    forever.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the **Decision Center** UI in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The IBM ODM Decision Center UI, showing our decision table'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B17377.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – The IBM ODM Decision Center UI, showing our decision table
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the decision table, showing the various thresholds. For example,
    once your portfolio's total value crosses **US dollars** (**USD**) $50,000, its
    loyalty level goes from **BRONZE** to **SILVER**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Messaging
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the loyalty level changes (meaning you have ODM configured and have bought
    enough stock—for example, the default threshold, as you can see in *Figure 3.6*,
    is $100,000 to reach **GOLD**), the Account microservice will post a message to
    a **Jakarta Messaging** queue. There are downstream microservices that will react
    to that message.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the IBM `server.xml` file and a line in the `Dockerfile` to copy the
    Jakarta Messaging `.rar` file into the container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Watson Tone Analyzer
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, whenever you buy or sell a stock, a commission is debited from your
    account balance. However, it is possible to earn a free (zero commission) trade
    by using the `sentiment` will be determined and returned. You get one free trade
    for submitting most kinds of feedback, but there's a rule that will give you three
    free trades in order to soothe you if it determines your sentiment is **Angry**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: If you don't configure the Watson Tone Analyzer, you'll get back **Unknown**
    and no free trades.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Trade History
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This microservice keeps a record of every trade you made, when you made it,
    and what the stock cost when you made it. Without this microservice, the example
    only knows aggregate information. For example, if you bought 10 shares of IBM
    stock a month ago for $100, and 5 shares a week ago for $110, and 2 more shares
    today for $120, the Portfolio microservice would just know you now have 17 shares
    and what they are worth today ($2,040 in this example). The Trade History microservice
    remembers all of the details, so it would know you spent $1,790 and thus have
    an ROI of 14%. If this microservice isn't configured, the Trader and Tradr clients
    will just say **Unknown** for the ROI.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the discussion of the Portfolio microservice, this microservice
    subscribes to and consumes the messages that Portfolio publishes to the Kafka
    topic, such as would be managed by *IBM Event Streams*. It does so via **MicroProfile
    Reactive Messaging**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Mongo
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This microservice uses a `Ready` state and thus nothing will ever consume the
    messages from the topic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This microservice consumes the JSON messages from the JMS queue about the change
    in loyalty level that the Account microservice sent. This microservice has the
    only Jakarta **Enterprise Bean** in the example, using a **Message Driven Bean**
    (**MDB**) to receive the messages. It then alerts you via the **Notification**
    microservice about the newly reached level. As with the Account microservice,
    this one also needs a Jakarta Messaging provider such as IBM MQ, as we can see
    in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The IBM MQ UI, showing a message sent by the Account microservice'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B17377.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The IBM MQ UI, showing a message sent by the Account microservice
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Here, we see a simple JSON message on the MQ queue that gets processed by the
    Messaging microservice to provide a notification—in this case, about **Emily**
    having upgraded her loyalty level from **SILVER** to **GOLD**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two different flavors of the Notification microservice—one sends a
    tweet and the other posts to a Slack channel. Both have the same REST interface,
    so you just pick which you want to use when you deploy the example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Notification-Twitter
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Notification-Twitter** flavor uses the open source library from [twitter4j.org](http://twitter4j.org)
    to interact with Twitter's REST API to send a tweet.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Whereas most of the microservices in this example run on Open Liberty, this
    one runs on the **traditional WebSphere Application Server** (**tWAS**) in a Docker
    container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how this was set up, see [https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370](https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the example to send tweets via your account, you need to get the
    **Open Authorization** (**OAuth**) credentials for your Twitter account. You''ll
    need the consumer key and consumer secret, as well as the access token and access
    token secret. Here''s an example tweet from Notification-Twitter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – An example tweet sent by Notification-Twitter'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B17377.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – An example tweet sent by Notification-Twitter
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3.8* you see the tweet from the `@IBMStockTrader` account that was
    sent when the loyalty level upgraded from **BRONZE** to **GOLD**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Notification-Slack
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This flavor of the Notification microservice posts a message to a Slack channel.
    As with the Twitter flavor, it does so whenever a JMS message about a loyalty-level
    change is processed. The microservice calls a *serverless* function that sends
    the actual post to Slack, as we see here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – An example Slack message sent by Notification-Slack'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.9_B17377.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – An example Slack message sent by Notification-Slack
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the message is much like what was sent to Twitter, but in this
    case, it was sent to a Slack channel instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The *serverless* function is implemented via the **Apache OpenWhisk** framework.
    You can either deploy OpenWhisk to your OpenShift cluster or use IBM's **Function-as-a-Service**
    (**FaaS**) known as *IBM Cloud Functions*. For details on how the action sequence
    was created that posts a message to the Slack channel, see [https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972](https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: There is also an Amazon Web Services (AWS) Lambda serverless function that Notification-Slack
    can invoke to cause the message to get posted to the Slack channel. It expects
    the same API definition as the OpenWhisk function, so no changes were needed to
    the Notification-Slack microservice - you just configure it with a different URL
    and credentials via the operator. Whether you choose IBM Cloud Functions or AWS
    Lambda, this shows that Kubernetes and serverless frameworks can work together
    harmoniously.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Collector
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This microservice receives evidence from other microservices, persists it to
    IBM Cloudant, and makes it available for periodic scraping by a security/compliance
    tool such as the `Trader` can be configured to send evidence about login attempts,
    and `Stock Quote` can be configured to send evidence about cache hits (in Redis).
    It receives evidence via REST (a `POST` request) and exposes evidence via REST
    (a `GET` request).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other microservices, this one does not use `/collector` endpoint.
    This is similar to how `/metrics` endpoint.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Looper
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final optional microservice in this example is called `1` if not specified)
    on its route URL, you can tell it to run a specified number of iterations of a
    dozen operations, which show off all of the **create, retrieve, update, and delete**
    (**CRUD**) operations available on the Broker microservice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: For example, the operator for this example (which will be described in detail
    in [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173), *Deployment
    and Day 2 Operations*) has a checkbox to set up a **Horizontal Pod Autoscaler**
    (**HPA**) that will scale up each microservice to additional pods if they reach
    certain **central processing unit** (**CPU**) thresholds (and will scale back
    down when the CPU usage drops back off). By using Looper to put the example under
    load, you can see the HPA in action, and you can see that the resource usage graphs
    in the OpenShift console show the activity.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: loopctl
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One issue with requesting a large number of iterations of the `Looper` servlet
    is that you see no output until all of them are complete. In fact, most browsers,
    by default, will time out if the request takes an unreasonable amount of time
    to return.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: To address this, there is a command-line client to the Looper servlet known
    as `loopctl`, which calls the `Looper` servlet in a loop.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: You can tell it to run a specified number of iterations on a specified number
    of parallel threads. You saw the output of this command-line client earlier. To
    run it yourself, requesting 25 iterations on 4 parallel threads, the easiest approach
    is to go to the `./loopctl.sh 25 4`, which would run 100 total iterations (temporarily
    creating portfolios named `Looper1`, `Looper2`, `Looper3`, and `Looper4`) and
    would output the average number of milliseconds per iteration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a feel for the cloud-native example that will be used throughout
    this book. Though it may appear a bit daunting at first, the mandatory parts are
    quite easy to set up (especially if you use the pre-built images in Docker Hub),
    so you can be up and running with the basics of the example in a matter of minutes.
    Then, you can add whichever of the optional bonus capabilities you'd like at your
    own pace.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, various MicroProfile technologies will be discussed
    in detail. Each will show snippets from particular microservices in this example.
    As you have seen, different microservices are meant to demonstrate different features
    of Jakarta EE and MicroProfile and provide a real running tutorial of how to integrate
    with various external services.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159), *Building
    and Testing your Cloud-Native Application* we'll examine how these microservices
    were developed so that you can learn how to develop such microservices yourself.
    In [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173), *Step-by-Step
    Stock Trader Development*, we'll cover the deployment of the example in detail,
    as well as *day 2* operations you can perform.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin looking at each of the MicroProfile technologies
    themselves and see how they help Java developers create cloud-native applications
    that can run in, and deeply integrate with, an orchestrated, containerized environment
    in a public or private cloud.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
