- en: Exploring Built-In Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索内置效果
- en: Sometimes, computers do things differently compared to what the developer expects.
    Sometimes, a function can't return a value for a given set of arguments, a device
    is not available at runtime, or calling an external system takes much longer than
    expected.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，计算机的行为与开发者的预期不同。有时，一个函数可能无法为给定的一组参数返回值，设备在运行时不可用，或者调用外部系统所需的时间比预期长得多。
- en: Functional approaches strive to capture these aspects and express them with
    types. This allows for precise reasoning about the program and helps to avoid
    surprises at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式方法努力捕捉这些方面，并用类型来表示它们。这允许对程序进行精确推理，并有助于在运行时避免意外。
- en: 'In this chapter, we will study how the mentioned aspects are covered by Scala''s
    standard library. We''ll take a look at the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究这些方面是如何被Scala标准库所涵盖的。我们将查看以下内容：
- en: Foundations of encoding runtime aspects with types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型编码运行时方面的基础
- en: Option
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项
- en: Either
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者
- en: Try
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试
- en: Future
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保您已安装以下内容：
- en: JDK 1.8+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available under our GitHub repository at: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的GitHub仓库中找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter06).
- en: Introduction to effects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果简介
- en: 'Scala code compiles to the Java bytecode and runs on the JVM (Java Virtual
    Machine). As the name suggests, the JVM was not built specifically for Scala.
    Because of this, there is a mismatch between what is expressible with the Scala
    language and what the JVM supports. The consequences are twofold:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Scala代码编译成Java字节码，并在JVM（Java虚拟机）上运行。正如其名所示，JVM并非专门为Scala构建。因此，Scala语言能够表达的内容与JVM支持的内容之间存在不匹配。后果是双重的：
- en: The compiler converts Scala features that are not supported by the JVM into
    the proper bytecode, mostly by creating wrapper classes. As a result, the compilation
    of a simple Scala program might lead to the creation of dozens or hundreds of
    classes, which in turn leads to decreased performance and a higher garbage footprint.
    These negative consequences, in essence, are just an implementation detail. As
    the JVM improves, it is possible to optimize the bytecode produced by the compiler
    for the newer versions of Java without any efforts from the application developer.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器将Scala中JVM不支持的功能转换为适当的字节码，主要是通过创建包装类。因此，一个简单的Scala程序的编译可能会导致创建数十或数百个类，这反过来又会导致性能下降和更高的垃圾回收足迹。本质上，这些负面后果只是实现细节。随着JVM的改进，有可能优化编译器为Java的新版本生成的字节码，而无需应用程序开发者的任何努力。
- en: Looking in the opposite direction, there are some features of the platform that
    are not especially consistent with Scala. Support for them is required, though,
    partly for Scala-Java interoperability reasons, and partly because if something
    happens in the underlying runtime, it needs to be expressible in the language.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相反的方向来看，平台有一些特性与Scala并不特别一致。尽管如此，对这些特性的支持是必要的，部分原因是出于Scala与Java互操作性的原因，部分原因是因为如果底层运行时发生某些情况，它需要能够在语言中表达出来。
- en: For us, as users of the language, the first class of differences is more of
    a theoretical interest as it is comfortable to assume that the compiler developers
    are doing their best to generate the bytecode which is of the best standards for
    the current version of the JVM, so we can just rely on them. Consequences of the
    second kind concern us more directly because they might influence the way we structure
    our code, and they definitely affect the code we write to interact with existing
    libraries, especially Java libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们这些语言使用者来说，第一类差异更多的是一种理论上的兴趣，因为我们很舒服地假设编译器开发者正在尽最大努力生成最适合当前JVM版本的字节码，因此我们可以依赖他们。第二类差异对我们影响更直接，因为它们可能会影响我们编写代码的方式，并且它们肯定会影响我们与现有库（尤其是Java库）交互时编写的代码。
- en: Here, we're talking about features that might negatively impact on our possibility
    to reason about the code, especially those which break their referential transparency.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论的是可能会对我们的代码推理能力产生负面影响的功能，特别是那些破坏其引用透明性的功能。
- en: 'To illustrate the last point, let''s take a look at the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明最后一点，让我们看一下以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've defined a Java `HashMap`, an `ArrayList`, put some items in them, and
    got these back as expected. So far, so good.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个Java `HashMap`，一个`ArrayList`，在其中放入了一些项目，并如预期地得到了这些项目。到目前为止，一切顺利。
- en: 'Let''s push this a bit further:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For an element that can''t be found in the `map`, we got a `null: Null` back,
    which is a bit unexpected. Is it really so bad? Well, it probably is:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '对于在`map`中找不到的元素，我们得到了一个`null: Null`的返回值，这有点出乎意料。这真的那么糟糕吗？嗯，可能确实如此：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've got a `NullPointerException` which would crash our program at runtime if
    not caught!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一个`NullPointerException`，如果不捕获它，程序在运行时将会崩溃！
- en: 'OK, but we *can* check if the returned element is `null.` We just need to remember
    to do this each time we call a function that can potentially return `null`. Let''s
    do this with the `list`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但我们*可以*检查返回的元素是否为`null`。我们只需要记住每次调用可能返回`null`的函数时都要这样做。让我们用`list`来做这个操作：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Oh, the list does not return `null` for absent elements, it just throws the `IndexOutOfBoundsException`
    straight away! Looks like we need to add a `catch` clause to our call so that
    we can make it safe...
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，列表对于缺失的元素不会返回`null`，它只是直接抛出`IndexOutOfBoundsException`！看起来我们需要在我们的调用中添加一个`catch`子句，以便使其更安全...
- en: At this moment, our point is already clear – it is hard or impossible to reason
    about what the possible result of execution of some code written in this style is
    without looking at the JavaDocs, and eventually at the implementations' source
    code. The reason for this is that the functions we're calling can return the result
    in a way that's not encoded in their types. In the first example, the function
    returns a special `null` value for the case where there's no element in the collection.
    But this special value could also be something different! Another example is `-1`
    for the `indexOf` method that's defined on the `ArrayList`. Yet another case is
    the indication of the impossibility to perform an operation, which is done by
    throwing an exception.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的观点已经很明确了——在没有查看JavaDocs，最终查看实现源代码的情况下，很难或不可能推理出以这种风格编写的某些代码的执行可能的结果。原因在于我们调用的函数可以以它们类型中未编码的方式返回结果。在第一个例子中，函数在集合中没有元素的情况下返回一个特殊的`null`值。但这个特殊值也可能是其他东西！另一个例子是`ArrayList`上定义的`indexOf`方法的`-1`。还有另一种情况是指出无法执行操作，这是通过抛出异常来完成的。
- en: In a way, the functions we've called altered the environment they were executed
    in. In the case of an exception, the execution path of the program changed to
    propagate the exception, and in the case of `null` being returned, the caller's
    expectations had changed, unfortunately not at compile time but at runtime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们调用的函数改变了它们执行的环境。在异常的情况下，程序的执行路径改变以传播异常，而在返回`null`的情况下，调用者的期望发生了变化，不幸的是，不是在编译时，而是在运行时。
- en: In functional programming, we call such a behavior an *effect*, and strive to
    express this effect at the type level. Effects in functional programming (FP) overlap
    with *side-effects*, but represent a wider concept. For example, an effect of
    optionality (returning `null`) of the result is not a side-effect.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们称这种行为为*效果*，并努力在类型级别上表达这种效果。函数式编程（FP）中的效果与*副作用*重叠，但代表了一个更广泛的概念。例如，结果的可选性（返回`null`）并不是副作用。
- en: Effects have the advantage that they don't need to be implemented on the language
    level. Because of this, the same effect can be designed in different ways, depending
    on the goals and architectural considerations of the library author. Most importantly,
    they can be extended and combined, which allows us to represent complex sets of
    effects in a structured and type-safe way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 效果的优势在于它们不需要在语言级别上实现。正因为如此，根据库作者的目标和架构考虑，可以以不同的方式设计相同的效果。最重要的是，它们可以被扩展和组合，这允许我们以结构化和类型安全的方式表示复杂的效果集。
- en: In further sections of this chapter, we will take a look at four different kinds
    of effects that are available in the standard library, starting with `Option`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将探讨标准库中可用的四种不同类型的效果，从`Option`开始。
- en: Option
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选
- en: '`Option` is probably the first effect that a novice Scala developer gets familiar
    with. It encodes the situation that the function might return no result. Simplified,
    it is represented in `stdlib` as an algebraic data type, as shown in the following
    code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`可能是新手Scala开发者首先熟悉的效果。它编码了函数可能不返回结果的情况。简化来说，它在`stdlib`中以代数数据类型的形式表示，如下面的代码所示：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`None` represents the case of an absent result, while `Some(value)` represents
    the case where a result exists. Next, we''ll look at a three-step approach to
    gain more understanding of how to work with an `Option`—how to create it, read
    the value from it (if there is one) and which possibilities emerge from the fact
    that `Option` is an effect.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`表示不存在结果的情况，而`Some(value)`表示存在结果的情况。接下来，我们将探讨一种三步法来更深入地理解如何使用`Option`——如何创建它、从它（如果有的话）读取值以及从`Option`是一个效果的事实中产生的可能性。'
- en: Creating an Option
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Option
- en: 'An `Option` can be created in a variety of ways. The most straightforward,
    though not recommended, is to use the constructor of the case class or to return `None`
    directly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`可以通过多种方式创建。最直接的方法，尽管不推荐，是使用情况类的构造器或直接返回`None`：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is not recommended because it is absolutely possible to return `null`
    wrapped in `Option` again, thus defeating the purpose of it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不推荐的，因为绝对有可能再次返回被`Option`包裹的`null`，从而违背了它的目的：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because of this, we need to check whether the constructor argument is `null`
    first:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要首先检查构造器参数是否为`null`：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In fact, this pattern is so common that the `Option` companion object provides
    the corresponding constructor:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种模式如此常见，以至于`Option`伴随对象提供了相应的构造器：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The companion object defines a few more constructors which allow you to refrain
    from direct use of `Some` or `None` altogether:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象定义了几个更多的构造器，允许你完全避免直接使用`Some`或`None`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first constructor creates the type `None`, and the second and third return
    `Some`, but only if the condition is `true` or `false`, respectively. The second
    argument is a by-name parameter and is only calculated if the condition holds.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构造器创建类型`None`，第二个和第三个返回`Some`，但只有当条件分别为`true`或`false`时。第二个参数是一个按名传递的参数，并且只有在条件成立时才会计算。
- en: Reading from an Option
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Option中读取
- en: 'Now we have an `Option` and need to take the value out of it. The most obvious
    way to do this is in a "null-checking" style:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Option`，需要从中取出值。最明显的方法是在“空值检查”风格中这样做：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we''re using one of two emptiness checks and in this case, if an `Option`
    is non-empty, we call `.get` to retrieve its value. Besides being quite verbose,
    the main disadvantage of this approach is that it is easy to forget to check if
    an option has been defined. If `None.get` gets called, it will throw a `NoSuchElementException`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两种空值检查中的一种，在这种情况下，如果`Option`非空，我们调用`.get`来检索其值。除了相当冗长之外，这种方法的主要缺点是很容易忘记检查`Option`是否已定义。如果调用`None.get`，它将抛出`NoSuchElementException`：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are a few more methods that allow you to check whether the contents of
    the option satisfy a given criteria, but they all suffer in the same way:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个方法允许你检查`Option`的内容是否满足给定的条件，但它们都以相同的方式存在问题：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `contains` method compares its argument with the contents of the option
    if it has been defined. `exists` takes a predicate that is applied to the value
    of an option if it is non-empty. Compared to the other methods, `forall` is special
    because it returns `true` if a predicate applied to the argument holds for a non-empty
    option or if an option is empty.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains`方法在`Option`被定义的情况下将其参数与`Option`的内容进行比较。`exists`接受一个谓词，如果`Option`非空，则应用于`Option`的值。与其它方法相比，`forall`是特殊的，因为它在应用于参数的谓词对非空`Option`成立或`Option`为空时返回`true`。'
- en: 'Another way to get a value out of `Option` is to deconstruct it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Option`中获取值的另一种方式是解构它：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also use pattern matching to avoid checking for non-emptiness completely:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用模式匹配来完全避免检查非空性：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sometimes, all that is needed for the caller is a "default" value if an `Option`
    is empty. There is a special method for this called `getOrElse`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对于调用者来说，如果`Option`为空，只需要一个“默认”值。为此有一个特殊的方法叫做`getOrElse`：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another similar method is `orNull`. It is not very useful in Scala code, but
    is very convenient for Java interoperability and is available for `Option[AnyRef]`.
    It returns `null` in the case of an empty option or the option''s value otherwise:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的方法是`orNull`。在Scala代码中，它并不很有用，但对于Java互操作性来说非常方便，并且对`Option[AnyRef]`可用。在空`Option`的情况下，它返回`null`，否则返回`Option`的值：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `foreach` method feels quite different from what we''ve seen so far as
    it executes a function on a value of an `Option` in the case it is defined:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`方法与之前我们所见的不同，因为它在`Option`的值被定义的情况下执行一个函数：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The reason why it is special compared to the other methods we've seen so far
    is that it does not treat the option as a special value. Instead, it is semantically
    formulated as a callback – "if this effect has (had) place, execute the following
    code on it."
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的其他方法相比，它之所以特殊，是因为它不将选项视为特殊值。相反，它在语义上被表述为一个回调——“如果这个效果（已经）发生，就在它上面执行以下代码。”
- en: This view of an `Option` offers another possibility so that we can work with
    it – to provide higher order functions that will be executed in the case of an
    empty or non-empty option. Let's see how this works in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对 `Option` 的看法提供了另一种可能性，以便我们可以与之交互——提供在空或非空选项的情况下将执行的更高阶函数。让我们详细看看这是如何工作的。
- en: Option as an effect
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项作为效果
- en: 'The first consequence of the aforementioned approach is that it is possible
    to constrain the possible values of the `Option` (and convert it to `None` if
    the conditions don''t hold) without inspecting its contents. Here is an example
    of filtering options further containing a number bigger or less than `10`, respectively:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的第一种后果是，可以在不检查其内容的情况下约束 `Option` 的可能值（如果条件不成立，则将其转换为 `None`）。以下是一个进一步过滤选项的例子，包含一个大于或小于
    `10` 的数字：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is also possible to use a partial function as a filter. This allows you
    to filter and transform the value at the same time. For example, you can filter
    numbers bigger than `10` and convert them into a `String`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用部分函数作为过滤器。这允许你在过滤和转换值的同时进行操作。例如，你可以过滤大于 `10` 的数字并将它们转换为 `String`：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Functionally, the `collect` method can be seen as a combination of `filter`
    and `map`, where the latter can be used separately to transform the contents of
    a non-empty option. For instance, let''s imagine a chain of calls we''d need to
    make in order to catch a fish:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，`collect` 方法可以看作是 `filter` 和 `map` 的组合，其中后者可以单独使用来转换非空选项的内容。例如，让我们想象一系列我们需要调用的函数来捕捉鱼：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we're buying some bait, casting the line, and hooking the fish at the
    appropriate moment. The argument for our implementation is optional because we
    might not know what the best bite for a fish would be.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们是在购买一些诱饵，抛出鱼线，并在适当的时机钓到鱼。我们实现中的参数是可选的，因为我们可能不知道鱼的最佳咬钩时机是什么。
- en: There is an issue with this implementation, though. We're ignoring the fact
    that our functions will have no results for the given parameters. The fishing
    store might be closed, the cast might break, and the fish can slip out. It turns
    out that we violate our own rules about expressing effects with types that we
    defined a couple of pages ago!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个实现存在一个问题。我们忽略了我们的函数对于给定的参数将没有结果的事实。鱼店可能已经关闭，抛出的鱼线可能断裂，鱼也可能滑走。结果是我们违反了我们之前定义的关于使用类型表达效果的规则！
- en: 'Let''s fix that by making our functions return `Option`. We''ll start with `hookFish`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使我们的函数返回 `Option` 来修复这个问题。我们首先从 `hookFish` 开始：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But now our function returns a nested `Option`, which is hard to work with.
    We can address this by flattening the result using the corresponding method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们的函数返回一个嵌套的 `Option`，这很难处理。我们可以通过使用相应的方法来展平结果来解决这个问题：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can also make the `castLine` return `Option`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以让 `castLine` 返回 `Option`：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unfortunately, this implementation ceases to compile:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个实现无法编译：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To deal with chained, non-empty options, there is a `flatMap` method, which
    accepts a function returning an `Option` and flattens the result before returning
    it. With `flatMap`, we can implement our chain of calls without the need to call
    `flatten` at the end:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理链式非空选项，有一个 `flatMap` 方法，它接受一个返回 `Option` 的函数，并在返回之前展平结果。使用 `flatMap`，我们可以实现我们的调用链，而无需在最后调用
    `flatten`：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Having `map` and `flatMap` also allows us to use `Option` in `for` comprehensions.
    For instance, we can rewrite the preceding example like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有 `map` 和 `flatMap` 也允许我们在 `for` 简化表达式中使用 `Option`。例如，我们可以这样重写前面的例子：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we also added a fallback case for the situation of the fishing shop being
    closed, and when you need to make the bait by hand. This demonstrates that empty options
    can also be chained. The `orElse` method resolves a series of options until the
    first one that''s defined is found or returns the last `Option` in the chain,
    regardless of its contents:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还添加了一个后备情况，以应对鱼店关闭的情况，以及当你需要手工制作诱饵时。这表明空选项也可以链式使用。`orElse` 方法解决一系列选项，直到找到第一个定义的选项，或者返回链中的最后一个
    `Option`，无论其内容如何：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is a possibility to map over the `Option` and provide a default value
    for the empty case. This is done with the `fold` method, which accepts the default
    value as a first argument list and a mapping function as a second one:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以对`Option`进行映射，并为空情况提供一个默认值。这是通过`fold`方法完成的，它接受默认值作为第一个参数列表，映射函数作为第二个参数：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last pair of methods available for an `Option` are `toRight` and `toLeft`.
    They return instances of the next effect we want to take a look at, `Either`.
    `toRight` returns `Left`, which contains its argument for `None`, or `Right`,
    containing the value of `Some`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Option`，最后两个可用方法是`toRight`和`toLeft`。它们返回下一个我们想要查看的效果的实例，即`Either`。`toRight`返回`Left`，其中包含其参数的`None`，或者返回包含`Some`值的`Right`：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`toLeft` does the same but returns on different sides of `Either`, respectively:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLeft`做同样的事情，但返回`Either`的不同侧面：'
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But what are these `Left` and `Right` options we are talking about?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们所说的这些`Left`和`Right`选项是什么？
- en: Either
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Either
- en: '`Either` represents the possibility of a function having one of two alternative
    results which can''t be represented by a single type.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`表示一个函数可能有两种不同的结果，这些结果不能由单一类型表示的可能性。'
- en: 'For example, let''s imagine that we have a new simulation system that replaced
    an old one. The new system is very popular, and so is constantly under load and
    thus not always available. The old one is kept as a fallback for this reason.
    Unfortunately, the results of the simulation have very different formats for both
    systems. Hence, it makes sense to represent them as `Either`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象我们有一个新的模拟系统，它取代了旧的一个。新系统非常受欢迎，因此它始终处于负载状态，因此并不总是可用。出于这个原因，旧系统被保留作为后备。不幸的是，两个系统的模拟结果格式非常不同。因此，将它们表示为`Either`是有意义的：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If this example gives you the feeling that types of alternatives must be related,
    then you are getting the wrong feeling. Usually, the types of the results would
    be completely unrelated. To illustrate this, let's consider another example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子让你觉得替代项的类型必须相关，那么你就有误解了。通常，结果类型会完全不相关。为了说明这一点，让我们考虑另一个例子。
- en: 'As we''re fishing, there is the possibility of us catching very different kinds
    of fish. Yet another possibility is to pull something completely different—an
    old boot that was lost by a tourist two years ago, or potential evidence that
    had been concealed by a criminal:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们钓鱼的时候，有可能钓到非常不同种类的鱼。还有一种可能是拉出完全不同的东西——一个两年前游客丢失的旧靴子，或者被罪犯隐藏的潜在证据：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Traditionally, the right side is preferred to represent the more desirable,
    *right* outcome, the left side is less desirable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，右边被用来表示更理想的、*正确*的结果，而左边则表示不那么理想的结果。
- en: 'The simplified definition of `Either` looks like this in the Scala library:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`在Scala库中的简化定义如下：'
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It takes two type parameters for the left and right sides, and there are two
    case classes representing these sides. Let's dive a bit deeper using the same
    approach that we did with `Option` – create an effect, read from the effect, and
    abstract over it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它为左边和右边接受两个类型参数，并且有两个案例类代表这些侧面。让我们深入一点，使用与`Option`相同的方法——创建一个效果，从效果中读取，并对其抽象：
- en: Creating Either
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Either
- en: 'Again, as in the case of `Option`, an obvious way to create an instance of
    `Either` is to use the constructor of the respective case class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`Option`的情况下，创建`Either`实例的一个明显方法是使用相应的案例类的构造函数：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The caveat is that the preceding definition leaves us with an `Either` whose
    left side is of the type `Nothing`. This probably wasn''t our intention. Therefore,
    it is desirable to provide type parameters for both sides:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项是，前面的定义让我们得到了一个左边的类型为`Nothing`的`Either`，这很可能不是我们的初衷。因此，为两边提供类型参数是很有必要的：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is arguably a bit cumbersome.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点繁琐。
- en: 'Again, similar to `Option`, the `Either` companion object offers a helpful
    constructor which takes a predicate and two by-name constructors for the right
    and left sides:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，与`Option`类似，`Either`伴随对象提供了一个有用的构造函数，它接受一个谓词和两个按名称指定的构造函数，用于右边和左边：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the condition holds, the `Right` with a given argument is constructed, otherwise
    a `Left` is created. Because both sides are defined, the compiler can inference
    the resulting type of `Either` properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件成立，则构建一个带有给定参数的`Right`，否则创建一个`Left`。由于两边都已定义，编译器可以正确地推断出`Either`的结果类型。
- en: 'There are two helper methods that are defined on both the `Left` and `Right` that
    help to upcast the previously defined side to full `Either`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个辅助方法定义在 `Left` 和 `Right` 上，帮助将先前定义的侧升级为完整的 `Either`：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we upcast `Right[Nothing,Int]` to `Either[String,Int]` and do the same
    with `Left`, which produces the resulting value of the type `Either[StringBuilder,BigDecimal]`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `Right[Nothing,Int]` 升级为 `Either[String,Int]`，并将 `Left` 也做同样的处理，这会产生类型为
    `Either[StringBuilder,BigDecimal]` 的结果值。
- en: Reading values from Either
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Either 读取值
- en: '`Either` is different from `Option` in the sense that it represents two possible
    values instead of one. Accordingly, we can''t just check if `Either` contains
    a value. We have to specify which side we''re talking about:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 与 `Option` 不同之处在于它表示两个可能的值而不是一个。因此，我们无法仅仅检查 `Either` 是否包含值。我们必须指定我们谈论的是哪一侧：'
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'They are of little use if compared to the Option''s approach because `Either`
    does not offer a method to extract the value from it. In the case of `Either`,
    pattern matching is a way to go:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Option 的方法相比，它们用处不大，因为 `Either` 不提供从其中提取值的方法。在 `Either` 的情况下，模式匹配是一种可行的方法：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The predicate functions are also available with semantics similar to `Option`,
    with `None` represented by `Left` and `Some` by `Right`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 断言函数也提供了与 `Option` 类似的语义，其中 `None` 由 `Left` 表示，而 `Some` 由 `Right` 表示：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This special treatment of `Right` as a default side makes `Either` *right-biased*.
    Another example of this bias is the `getOrElse` function, which also returns the
    contents of the `Right` side or the default value provided as an argument in the
    case of `Left`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Right` 作为默认侧的特殊处理使得 `Either` 具有向右偏好的特性。另一个例子是 `getOrElse` 函数，它也会在 `Left`
    的情况下返回提供的默认值：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The right bias plays very well for the conversion to `Option`, with `Some`
    representing the right side and `None` the left side, regardless of the `value`
    of `Left`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 向右偏好在转换为 `Option` 时表现得非常好，其中 `Some` 表示右侧，而 `None` 表示左侧，无论 `Left` 的 `value` 如何：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Similarly, `toSeq` represents `Right` as a `Seq` of one element and `Left`
    as an empty `Seq`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`toSeq` 将 `Right` 表示为一个只有一个元素的 `Seq`，而将 `Left` 表示为一个空 `Seq`：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the case of there being a `Left` that we''d like to be `Right` or vice versa,
    there is a `swap` method whose sole purpose is to changes sides:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将 `Left` 转换为 `Right` 或反之亦然，有一个 `swap` 方法，它的唯一目的是改变两侧：
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This can help to apply the right-biased methods if a value that needs to be
    applied is on the left side.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助在需要应用值的左侧应用向右偏好的方法。
- en: Either as an Effect
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Either 作为 Effect
- en: 'Naturally, methods defined in terms of an effect are also right-biased for
    `Either`. So is, for example, the callback method `foreach`, which we already
    know from `Option`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，以效应定义的方法在 `Either` 上也是向右偏好的。例如，回调方法 `foreach` 也是这样，我们已经在 `Option` 中知道了它：
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding example, the callback is not executed for the `left`, but
    is called as soon as it becomes `Right` after we call `swap` on it. The filtering
    has a bit of a different definition, as it accepts a predicate to filter the right
    side, and a value to return as a `Left` if the predicate does not hold:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，回调在 `left` 上没有执行，而是在我们对它调用 `swap` 后立即变为 `Right` 时被调用。过滤的定义略有不同，因为它接受一个用于过滤右侧的谓词，以及一个在谓词不成立时作为
    `Left` 返回的值：
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`map` and `flatMap` allow you to transform the right side if you provide the
    appropriate functions. `flatMap` expects the result of the function to have a
    type of `Either` as well. To demonstrate this, we''ll reuse our `Option` example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `flatMap` 允许你在提供适当的函数时转换右侧。`flatMap` 期望函数的结果类型也是 `Either`。为了演示这一点，我们将重用我们的
    `Option` 示例：'
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But this time we''ll start with `bestBaitForFish`, which is the result of us
    asking about this other fisherman. The fisherman may be in a bad mood and we might
    hear them cursing instead of the hint we''re expecting to get. These are both
    of the `String` type, but we absolutely want to differentiate between them:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次我们将从 `bestBaitForFish` 开始，这是我们询问另一位渔夫的结果。渔夫可能心情不好，我们可能会听到他们咒骂而不是我们期望得到的提示。这两者都是
    `String` 类型，但我们绝对想要区分它们：
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Again, we''re not living up to the standards we''ve defined for ourselves.
    We might get an explanation from the seller in the shop as to why we can''t have
    the bait we want to buy. In the case that we fail to make bait, cast a line, or
    hook a fish, we might express ourselves verbally as well with some text that we
    will not put in the examples of this book. It makes sense to express the possibility
    that our functions return this verbal feedback if something goes wrong:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们没有达到自己设定的标准。我们可能从商店的卖家那里得到解释，说明为什么我们不能买到我们想要的诱饵。如果我们未能制作诱饵，抛出鱼线或钓到鱼，我们也可以用一些文字来表达，这些文字我们不会放在这本书的例子中。表达函数在出错时返回这种口头反馈的可能性是有意义的：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can rewrite the code that used `map` with `flatMap`. It makes sense
    to write it as a `for` comprehension:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用`flatMap`重写使用`map`的代码。将其写成`for`推导式是有意义的：
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The calls will be carried over until the last one succeeds or one of them produces
    a `Left`. In the second case, the first `Left` we meet will be returned as the
    result of the function call.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 调用将一直进行，直到最后一个成功或其中一个产生`Left`。在第二种情况下，我们遇到的第一`Left`将被作为函数调用的结果返回。
- en: In the preceding example, we used the `fold` method, which allows us to apply
    the given functions to one side of `Either`. In our use case, we did this to ignore
    any eventual error message that will be returned by the seller in the shop and
    to make the bait ourselves. If we succeed, we wrap the bait into the `Right` before
    returning it so that we have proper type alignment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，我们使用了`fold`方法，它允许我们将给定的函数应用于`Either`的一侧。在我们的用例中，我们这样做是为了忽略卖家在商店返回的任何可能的错误消息，并自己制作诱饵。如果我们成功了，我们在返回之前将诱饵包裹在`Right`中，以便我们有正确的类型对齐。
- en: The `fold` method is *unbiased* as it treats the left and right sides of `Either`
    equally.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`方法是无偏的，因为它平等地对待`Either`的左右两侧。'
- en: 'In the last example we looked at, the model we represented with `Either` had
    its left side dedicated to the description of failures that happened during its
    operation. It is always useful to have the type of the error  more specific than
    `String`. Often, especially in cases involving integration with Java, the most
    suitable choice would be to represent errors as subtypes of the `Exception`. In
    fact, this is so ubiquitous that there is a special effect available for this
    in Scala called `Try`. An `Either` having a type of its left side inheriting from
    a `Throwable` can be converted into a `Try` with the respective method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前看到的最后一个例子中，我们用`Either`表示的模型，其左侧专门用于描述其操作期间发生的失败。拥有比`String`更具体的错误类型总是有用的。特别是在涉及与Java集成的案例中，最合适的选择可能是将错误表示为`Exception`的子类型。事实上，这在Scala中是如此普遍，以至于有一个特殊的效果叫做`Try`。一个左侧类型继承自`Throwable`的`Either`可以转换为`Try`，使用相应的方法：
- en: '[PRE51]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let's examine cases in which `Try` is a better choice then `Either` and learn
    how to use it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一下在哪些情况下`Try`比`Either`更好，并学习如何使用它。
- en: Try
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Try
- en: 'In the same way that `Either` stands for an effect of possible alternative
    results, `Try` denotes the effect of throwing an `Exception` by the function.
    In a sense, it is just a subset of `Either`, but it is so common that it has its
    own implementation. Unsurprisingly, the simplified representation of it looks
    quite familiar:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Either`代表可能结果的效应一样，`Try`表示函数抛出`Exception`的效应。在某种意义上，它只是`Either`的一个子集，但它如此常见，以至于它有自己的实现。不出所料，它的简化表示看起来相当熟悉：
- en: '[PRE52]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Obviously, `Success` represents the happy-path outcome of the operation, and `Failure` is
    for exceptional conditions. The type for the contents of the `Failure` is fixed
    to be a subclass of `Throwable`, so we're back to the single type parameter for
    the whole ADT, which is similar to `Option`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`Success`代表操作的快乐路径结果，而`Failure`用于异常条件。`Failure`的内容类型被固定为`Throwable`的子类，因此我们回到了整个ADT的单个类型参数，这与`Option`类似。
- en: We'll study `Try` in the same way as we did with `Option` and `Either` – by creating,
    reading from, and abstracting over the effect.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与`Option`和`Either`相同的方式研究`Try`——通过创建、读取和抽象其效应。
- en: Creating a Try
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Try
- en: 'The definition of `Try` is already familiar because of its similarity to `Either`,
    and so are the ways of creating an instance of it. For starters, we can use the
    constructors of the case classes to create instances directly:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与`Either`的相似性，`Try`的定义已经熟悉，创建其实例的方法也是如此。首先，我们可以使用案例类的构造函数直接创建实例：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The idea behind `Try` is that it can be used in scenarios where an exception
    would normally be thrown. Hence, the constructors we just mentioned would normally
    form the following pattern:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try`背后的理念是它可以在通常抛出异常的场景中使用。因此，我们刚才提到的构造函数通常会形成以下模式：'
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will end with the result of the `try` block being wrapped in `Success`
    and the `catch` exception wrapped in `Failure`. Again, `stdlib` already has this
    pattern implemented in the companion object of `Try`. The `apply` method takes
    a single by-name parameter for the `try` block, like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以`try`块的结果被包裹在`Success`中，以及`catch`异常被包裹在`Failure`中的方式结束。再次强调，`stdlib`已经在`Try`的伴生对象中实现了这种模式。`apply`方法接受一个单参数的by-name参数，用于`try`块，如下所示：
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: And then catches all `NonFatal` exceptions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后捕获所有`NonFatal`异常。
- en: '`NonFatal` represents a class of exceptions that the developer is able to deal
    with. It does not include fatal errors such as `OutOfMemoryError`, `StackOverflowError`,
    `LinkageError`, or `InterruptedException`. It does not make sense to deal with
    these programmatically. Another group of Throwables not matched by `NonFatal`
    is `scala.util.control.ControlThrowable`, which is used internally to control
    program flow and thus should not be used in a catch exception either.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonFatal`代表一类开发者能够处理的异常。它不包括像`OutOfMemoryError`、`StackOverflowError`、`LinkageError`或`InterruptedException`这样的致命错误。这些错误在程序上处理没有意义。与`NonFatal`不匹配的另一组`Throwables`是`scala.util.control.ControlThrowable`，它用于内部控制程序流程，因此也不应该在捕获异常时使用。'
- en: 'It is common to provide multiline blocks wrapped in curly braces as a parameter
    for the `Try` constructor to makes it appear like it''s a language feature:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会将多行块用花括号括起来作为`Try`构造函数的参数，使其看起来像是一种语言特性：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This constructor is so common that it covers the absolute majority of use cases.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数非常常见，它涵盖了绝大多数的使用场景。
- en: Now, let's take a look at how we can get back the value from an instance of
    `Try`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从一个`Try`实例中获取值。
- en: Reading values from Try
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从`Try`中读取值
- en: 'There are multiple ways to approach this task. It is possible to use methods
    similar to `isDefined` and `isEmpty` for `Option`, which allow for a null-pointer
    checking style:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以处理这个任务。可以使用类似于`Option`的`isDefined`和`isEmpty`的方法，这些方法允许进行空指针检查风格的检查：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Obviously, this approach suffers from the same issue that `Option` does – if
    we forget to check that the result is a `Success` before extracting it, calling
    `.get` will throw an exception:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法存在与`Option`相同的问题——如果我们忘记在提取之前检查结果是否为`Success`，调用`.get`将抛出异常：
- en: '[PRE58]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To avoid throwing an exception just after catching it, there is a version of
    `get` that allows us to provide a default argument for the case if `Try` is a
    `Failure`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在捕获异常后立即抛出异常，有一个`get`版本允许我们为`Try`是`Failure`的情况提供一个默认参数：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Unfortunately, there are no predicate-taking methods like there were for `Option`.
    The reason for this is that `Try` was adopted from Twitter's implementation and
    was first added to Scala's standard library in version 2.10.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有像`Option`那样的接受谓词的方法。这是因为`Try`是从Twitter的实现中采纳的，并且首次在Scala 2.10版本的标准库中添加。
- en: 'The `foreach` callback is still available, though, and allows us to define
    a function that will be executed on the value of the `Success`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`foreach`回调仍然可用，并允许我们定义一个函数，该函数将在`Success`的值上执行：
- en: '[PRE60]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `foreach` method brings our discussion to the effect side of `Try`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`方法将我们的讨论带到了`Try`的效果方面。'
- en: Try as an effect
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`Try`作为效果
- en: '`Try` offers the same functionality as an `Option` in terms of filtering its
    results with a predicate. If the predicate does not hold, the result is represented
    as a `Failure[NoSuchElementException]`. Taking the `line` definition from our
    previous example, like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try`在用谓词过滤其结果方面提供了与`Option`相同的功能。如果谓词不成立，结果将表示为`Failure[NoSuchElementException]`。以我们之前的例子中的`line`定义为例，如下所示：'
- en: '[PRE61]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`collect` works in the same way, but it takes a partial function and allows
    us to filter and transform the contents of the `Try` at the same time:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect`的工作方式相同，但它接受一个部分函数，并允许我们在过滤和转换`Try`的内容的同时进行：'
- en: '[PRE62]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `filter` and `collect` functions are `Success` biased, and so are `map`
    and `flatMap`. Let''s reimplement the fishing example in this situation, where
    our parameter is of type `Try[String]`, and the exceptions are replacing strings
    as the problem descriptions we had in our example of `Either`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 和 `collect` 函数是 `Success` 有偏的，`map` 和 `flatMap` 也是如此。让我们在这个情况下重新实现钓鱼示例，其中我们的参数是
    `Try[String]` 类型，异常正在替换字符串作为我们 `Either` 示例中的问题描述：'
- en: '[PRE63]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The operations are chained on the `Success`. Yet again, we have to fix the
    signatures of our functions so that they encode the possibility of an error in
    every step in the type of the result:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 操作是在 `Success` 上链式的。再次强调，我们必须修复我们函数的签名，以便它们在结果的类型中编码每个步骤的错误可能性：
- en: '[PRE64]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we have to use `flatMap` instead of `map` to align the types. Again, it
    is more readable if represented as a `for` comprehension:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用 `flatMap` 而不是 `map` 来对齐类型。再次强调，如果以 `for` 循环的形式表示，则更易于阅读：
- en: '[PRE65]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This implementation is almost identical to the one we have for `Either`, with
    the exception that we now have to wrap successful calls into `Success` and not
    into `Right` (we have to use a different constructor for an effect).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现几乎与我们的 `Either` 实现相同，唯一的区别在于我们现在必须将成功的调用包装到 `Success` 中，而不是 `Right` 中（我们必须使用不同的构造函数来表示效果）。
- en: 'The `fold` is one of the methods that is unbiased for `Try`. It takes arguments
    to transfer both `Success` and `Failure`, as shown in the preceding code. Another
    unbiased method is `transform`, which is similar to `fold`, but takes functions
    for returning `Try` as parameters. In a sense, `transform` could be called `flatFold`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold` 是对 `Try` 无偏的方法之一。它接受传递 `Success` 和 `Failure` 的参数，如前述代码所示。另一个无偏方法是 `transform`，它与
    `fold` 类似，但接受返回 `Try` 的函数作为参数。在某种意义上，`transform` 可以被称为 `flatFold`：'
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There are also a few functions that are `Failure` biased.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些函数是 `Failure` 有偏的。
- en: '`recover` and `recoverWith` apply the given partial function to the `Failure`.
    They are basically duals of `map` and `flatMaps`, but for the exception side:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover` 和 `recoverWith` 将给定的部分函数应用于 `Failure`。它们基本上是 `map` 和 `flatMaps` 的对偶，但针对异常方面：'
- en: '[PRE67]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `orElse` method allows us to chain Failures in the same way we did with `None`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`orElse` 方法允许我们以与 `None` 相同的方式链式连接失败：'
- en: '[PRE68]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As we can see, `Try` is similar to `Option` and `Either`, and it should not
    come as a surprise that it can be converted to both `Option` and `Either[Throwable,
    _]`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Try` 与 `Option` 和 `Either` 类似，因此它能够转换为 `Option` 和 `Either[Throwable,
    _]` 并不令人惊讶：
- en: '[PRE69]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There is one more effect in the standard library that is a bit different from
    the three we just looked at because it takes into account a more subtle aspect
    of calling a function – the time it is going to take to return the result.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中还有一个效果与前面我们看到的三个略有不同，因为它考虑了调用函数的一个更微妙方面——返回结果所需的时间。
- en: Future
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来
- en: Sometimes, the functions we call take time to return results of the computation.
    Often, the cause is side-effects like reading from a disk or calling a slow remote
    API. At times, the operation itself just requires a lot of CPU time to finish.
    In both cases, the main flow of the program is stopped until the function returns
    the result. It might be acceptable in the latter case to wait for the result if
    it is required immediately after calculation (though even in this case it is suboptimal
    because it makes the system unresponsive), but it is undesirable in the former
    case because it means that our program consumes CPU while doing nothing (well,
    waiting for other subsystems of the computer to return the result, but still nothing
    related to the CPU). Often, such long-running operations are executed in a separate
    thread of execution.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们调用的函数需要时间来返回计算的结果。通常，原因是有副作用，如从磁盘读取或调用慢速的远程 API。有时，操作本身需要大量的 CPU 时间才能完成。在这两种情况下，程序的主要流程都会停止，直到函数返回结果。在后一种情况下，如果计算后立即需要结果，等待结果可能是可以接受的（尽管在这种情况下也是次优的，因为它使系统无响应），但在前一种情况下是不希望的，因为这意味着我们的程序在什么也不做（好吧，等待计算机的其他子系统返回结果，但仍然与
    CPU 无关）时消耗 CPU。通常，这样的长时间运行的操作是在单独的执行线程中执行的。
- en: As a functional programmer, we would like to express these—two aspects, that
    is, the duration of the call and the fact that the code is executed in a separate
    thread, as an effect. This is what `Future` does. To be more specific, it does
    not represent the duration of the call explicitly, but encodes it in a binary
    form—an operation either takes long and possibly runs in a separate thread or
    it doesn't.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `Future` is a very interesting concept and deserves a full chapter on its
    own. Here, we'll just take a brief look at some of its aspects. We highly recommend
    referring to the official documentation for more details. Let's apply our ubiquitous
    three-step approach one more time, this time for `Future`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Future
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Future` is not encoded as an ADT and thus we have to use a constructor
    that''s provided by the companion object to construct it. Because the code we''ll
    be providing will be executing in a separate thread, the `Future` has to have
    a way to obtain this `Thread`. This is done implicitly by having an `ExecutionContext`
    in scope, which we import in two steps. First, we''ll import the whose `scala.concurrent`
    package in scope and the `ExecutionContext` from it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `ExecutionContext` is basically a factory for `Threads`. It can be configured
    as needed for specific use cases. For demonstration purposes, we're using global
    context, but in general, this is not recommended. Please refer to the ScalaDocs
    under [https://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html](https://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html)
    for further details.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Having this context in scope, we can construct a `Future` by providing a by-name
    parameter to its constructor:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `Future` starts executing immediately after it is created, with respect
    to the time needed to obtain a thread from the executor.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we just want to wrap a value at hand into the `Future` for the code
    which expects some `Future` as a parameter. In this case, we don''t need an execution
    context because we don''t need to calculate anything. We can use one of the special
    constructors that help to create it successfully: `failed` and a `Future` from
    `Try`, respectively:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'There is also a predefined `Future[Unit]` that can be used as an indirect constructor
    by mapping over it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, since we have a value inside of the `Future`, let's take a look at the
    possible ways to get it out.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Reading values from a Future
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the `Future` is not implemented as an ADT, we can't directly pattern-match
    on it as we did with other the effects that we looked at in this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can use the null-checking style:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Luckily, the `value` method returns an `Option` that will be `None` until the
    future completes, so we can use this in a pattern match:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Of course, the most useful methods are defined not in relation to the value
    of the `Future`, but in terms of `Future` as an effect.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Future as an effect
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Future` has all of the usual suspects that have been made known to us from
    this chapter so far. `foreach` allows us to define a callback to execute after
    the `Future` successfully completes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`具有到目前为止我们已经从本章中了解到的所有常见功能。`foreach`允许我们定义在`Future`成功完成后执行的回调：'
- en: '[PRE76]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The order of execution is not guaranteed, as shown in the previous example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 执行顺序没有保证，如前一个示例所示。
- en: 'There is another callback that is called for any completed feature, regardless
    of its success. It accepts a function, taking `Try` as a parameter:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个回调会在任何完成的功能上被调用，无论其成功与否。它接受一个函数作为参数，该函数接受`Try`作为参数：
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `transform` method is also applied in both cases. There are two flavors
    of it. One takes two functions, for `Success` and `Failure`, accordingly, and
    another takes one function, `Try => Try`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`方法也在这两种情况下应用。它有两种形式。一种接受两个函数，分别对应`Success`和`Failure`，另一种接受一个函数`Try
    => Try`：'
- en: '[PRE78]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In both cases, we transform the string to its length in the case of success
    and wrap an exception in the case of failure. The second variant is more flexible,
    though, as it allows us to convert success to failure and vice versa.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都会在成功的情况下将字符串转换为它的长度，在失败的情况下包装一个异常。然而，第二种变体更加灵活，因为它允许我们将成功转换为失败，反之亦然。
- en: 'This filtering is also done in the same way as with other effects, that is,
    with the `filter` and `collect` methods:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过滤也是以与其他效果相同的方式进行，即使用`filter`和`collect`方法：
- en: '[PRE79]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The former just converts a `Success` into `Failure(NoSuchElementException)` (or
    leaves the existing `Failure` in place) if the predicate does not hold. The latter
    also modifies the contents to upper case for `Success`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前者如果谓词不成立，则将`Success`转换为`Failure(NoSuchElementException)`（或者保留现有的`Failure`不变）。后者也会将`Success`的内容修改为大写。
- en: 'And of course, `map` and `flatMap` are available. We''ll let our user service
    use Futures as an effect – this time to denote that every action, including our
    research for the best bite name for the fish, takes some time to finish:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`map`和`flatMap`也是可用的。我们将让我们的用户服务使用`Future`作为效果——这次是为了表示每个动作，包括我们为鱼寻找最佳咬合名称的研究，都需要一些时间来完成：
- en: '[PRE80]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This brings us to the following, already familiar, implementation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们来到了以下已经熟悉的实现：
- en: '[PRE81]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It is easy to see that besides changes in the effect type, the only difference
    to the previous implementations is the use of the fallback method to provide an
    alternative in the case of an unsuccessful call of the `buyBait` method.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，除了效果类型的变化外，与之前的实现相比，唯一的区别是使用了回退方法来在`buyBait`方法调用失败的情况下提供替代方案。
- en: There is a lot more to cover about the `Future` and its dual `Promise`. We encourage
    you to take a look at the official documentation and related blog posts (for example 
    [https://viktorklang.com/blog/Futures-in-Scala-2.12-part-9.html](https://viktorklang.com/blog/Futures-in-Scala-2.12-part-9.html))
    for some examples of advanced usage.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Future`及其双胞胎`Promise`还有很多内容要介绍。我们鼓励您查看官方文档和相关博客文章（例如 [https://viktorklang.com/blog/Futures-in-Scala-2.12-part-9.html](https://viktorklang.com/blog/Futures-in-Scala-2.12-part-9.html)），以了解一些高级用法的示例。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the effects defined in the standard library. First,
    an `Option` which represents a case where it might be impossible for the function
    to return the result. Then the `Try` which extends the optionality with the possibility
    to return an error description in the failure case. Next was `Either` which further
    extends the concept of `Try` by allowing it to provide an arbitrary type as a
    description of an *unsuccessful* path. Finally, the `Future` which stays a bit
    aside in this list and represents the notion of long and possibly executed in
    separate context computations
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了标准库中定义的效果。首先是一个`Option`，它表示函数可能无法返回结果的情况。然后是`Try`，它通过在失败情况下返回错误描述来扩展可选性。接下来是`Either`，它通过允许提供任意类型作为失败路径的描述来进一步扩展`Try`的概念。最后是`Future`，它在列表中稍微独立一些，代表长时间可能在不同上下文中执行的计算。
- en: We noticed that these effects have different constructors tailored to the situations
    that require the creation of the respective instances. In accordance, they offer
    slightly different ways to access values that are stored inside the container.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，这些效果有不同的构造函数，针对需要创建相应实例的情况进行了定制。相应地，它们提供了稍微不同的方式来访问容器内部存储的值。
- en: We paid attention to the fact that having effects as a first-class concept allows
    us to define methods not only in terms of contained values but also in terms of
    the effect itself, which often leads to more expressive code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，将效果作为一个一等概念可以让我们不仅根据包含的值来定义方法，还可以根据效果本身来定义，这通常会导致更具有表现力的代码。
- en: Most importantly, we realized that many methods such as `filter`, `collect`, `map`, `flatMap`,
    and so, are on identical from the user's perspective and induce identical, higher
    level implementations for different kinds of effects. We demonstrated this by
    implementing four uniform examples for catching a fish in a few steps, encoded
    in terms of different effects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们意识到许多方法，如`filter`、`collect`、`map`、`flatMap`等，从用户的角度来看是相同的，并为不同类型的效果诱导出相同的高级实现。我们通过实现四个统一示例来展示这一点，这些示例涉及在不同效果中编码的几个步骤来捕鱼。
- en: Later in this book, we will identify the underlying concepts that lead to these
    kinds of similarities.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将确定导致这些相似性的基本概念。
- en: We'll also approach the topic of combining different kinds of effects, which
    we left out of scope for now.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨结合不同类型效果的话题，目前我们将其排除在讨论范围之外。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What would be the proper effect to represent getting the first element of a
    list, such as a list of tweets? What about a user's information from the database
    for a given `userId`?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何表示获取列表的第一个元素的效果，例如获取推文列表？对于给定`userId`的用户信息从数据库中获取呢？
- en: What are the range of possible values of the following expression: `Option(scala.util.Random.nextInt(10)).fold(9)(_-1)`?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下表达式的可能值范围是什么：`Option(scala.util.Random.nextInt(10)).fold(9)(_-1)`？
- en: What will be the result of the following expression?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下表达式的结果会是什么？
- en: '[PRE82]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Describe the result of the following expression:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述以下表达式的结果：
- en: '[PRE83]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Given the following function, what would be the result of the following call: `either(1)`?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下函数，以下调用`either(1)`的结果会是什么？
- en: '[PRE84]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
