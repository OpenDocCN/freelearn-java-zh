- en: Exploring Built-In Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, computers do things differently compared to what the developer expects.
    Sometimes, a function can't return a value for a given set of arguments, a device
    is not available at runtime, or calling an external system takes much longer than
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: Functional approaches strive to capture these aspects and express them with
    types. This allows for precise reasoning about the program and helps to avoid
    surprises at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will study how the mentioned aspects are covered by Scala''s
    standard library. We''ll take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Foundations of encoding runtime aspects with types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available under our GitHub repository at: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala code compiles to the Java bytecode and runs on the JVM (Java Virtual
    Machine). As the name suggests, the JVM was not built specifically for Scala.
    Because of this, there is a mismatch between what is expressible with the Scala
    language and what the JVM supports. The consequences are twofold:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler converts Scala features that are not supported by the JVM into
    the proper bytecode, mostly by creating wrapper classes. As a result, the compilation
    of a simple Scala program might lead to the creation of dozens or hundreds of
    classes, which in turn leads to decreased performance and a higher garbage footprint.
    These negative consequences, in essence, are just an implementation detail. As
    the JVM improves, it is possible to optimize the bytecode produced by the compiler
    for the newer versions of Java without any efforts from the application developer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking in the opposite direction, there are some features of the platform that
    are not especially consistent with Scala. Support for them is required, though,
    partly for Scala-Java interoperability reasons, and partly because if something
    happens in the underlying runtime, it needs to be expressible in the language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For us, as users of the language, the first class of differences is more of
    a theoretical interest as it is comfortable to assume that the compiler developers
    are doing their best to generate the bytecode which is of the best standards for
    the current version of the JVM, so we can just rely on them. Consequences of the
    second kind concern us more directly because they might influence the way we structure
    our code, and they definitely affect the code we write to interact with existing
    libraries, especially Java libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we're talking about features that might negatively impact on our possibility
    to reason about the code, especially those which break their referential transparency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the last point, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a Java `HashMap`, an `ArrayList`, put some items in them, and
    got these back as expected. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s push this a bit further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For an element that can''t be found in the `map`, we got a `null: Null` back,
    which is a bit unexpected. Is it really so bad? Well, it probably is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've got a `NullPointerException` which would crash our program at runtime if
    not caught!
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, but we *can* check if the returned element is `null.` We just need to remember
    to do this each time we call a function that can potentially return `null`. Let''s
    do this with the `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Oh, the list does not return `null` for absent elements, it just throws the `IndexOutOfBoundsException`
    straight away! Looks like we need to add a `catch` clause to our call so that
    we can make it safe...
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, our point is already clear – it is hard or impossible to reason
    about what the possible result of execution of some code written in this style is
    without looking at the JavaDocs, and eventually at the implementations' source
    code. The reason for this is that the functions we're calling can return the result
    in a way that's not encoded in their types. In the first example, the function
    returns a special `null` value for the case where there's no element in the collection.
    But this special value could also be something different! Another example is `-1`
    for the `indexOf` method that's defined on the `ArrayList`. Yet another case is
    the indication of the impossibility to perform an operation, which is done by
    throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, the functions we've called altered the environment they were executed
    in. In the case of an exception, the execution path of the program changed to
    propagate the exception, and in the case of `null` being returned, the caller's
    expectations had changed, unfortunately not at compile time but at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, we call such a behavior an *effect*, and strive to
    express this effect at the type level. Effects in functional programming (FP) overlap
    with *side-effects*, but represent a wider concept. For example, an effect of
    optionality (returning `null`) of the result is not a side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: Effects have the advantage that they don't need to be implemented on the language
    level. Because of this, the same effect can be designed in different ways, depending
    on the goals and architectural considerations of the library author. Most importantly,
    they can be extended and combined, which allows us to represent complex sets of
    effects in a structured and type-safe way.
  prefs: []
  type: TYPE_NORMAL
- en: In further sections of this chapter, we will take a look at four different kinds
    of effects that are available in the standard library, starting with `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Option` is probably the first effect that a novice Scala developer gets familiar
    with. It encodes the situation that the function might return no result. Simplified,
    it is represented in `stdlib` as an algebraic data type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`None` represents the case of an absent result, while `Some(value)` represents
    the case where a result exists. Next, we''ll look at a three-step approach to
    gain more understanding of how to work with an `Option`—how to create it, read
    the value from it (if there is one) and which possibilities emerge from the fact
    that `Option` is an effect.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Option` can be created in a variety of ways. The most straightforward,
    though not recommended, is to use the constructor of the case class or to return `None`
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not recommended because it is absolutely possible to return `null`
    wrapped in `Option` again, thus defeating the purpose of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this, we need to check whether the constructor argument is `null`
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, this pattern is so common that the `Option` companion object provides
    the corresponding constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The companion object defines a few more constructors which allow you to refrain
    from direct use of `Some` or `None` altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first constructor creates the type `None`, and the second and third return
    `Some`, but only if the condition is `true` or `false`, respectively. The second
    argument is a by-name parameter and is only calculated if the condition holds.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from an Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have an `Option` and need to take the value out of it. The most obvious
    way to do this is in a "null-checking" style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re using one of two emptiness checks and in this case, if an `Option`
    is non-empty, we call `.get` to retrieve its value. Besides being quite verbose,
    the main disadvantage of this approach is that it is easy to forget to check if
    an option has been defined. If `None.get` gets called, it will throw a `NoSuchElementException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more methods that allow you to check whether the contents of
    the option satisfy a given criteria, but they all suffer in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `contains` method compares its argument with the contents of the option
    if it has been defined. `exists` takes a predicate that is applied to the value
    of an option if it is non-empty. Compared to the other methods, `forall` is special
    because it returns `true` if a predicate applied to the argument holds for a non-empty
    option or if an option is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to get a value out of `Option` is to deconstruct it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use pattern matching to avoid checking for non-emptiness completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, all that is needed for the caller is a "default" value if an `Option`
    is empty. There is a special method for this called `getOrElse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another similar method is `orNull`. It is not very useful in Scala code, but
    is very convenient for Java interoperability and is available for `Option[AnyRef]`.
    It returns `null` in the case of an empty option or the option''s value otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `foreach` method feels quite different from what we''ve seen so far as
    it executes a function on a value of an `Option` in the case it is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The reason why it is special compared to the other methods we've seen so far
    is that it does not treat the option as a special value. Instead, it is semantically
    formulated as a callback – "if this effect has (had) place, execute the following
    code on it."
  prefs: []
  type: TYPE_NORMAL
- en: This view of an `Option` offers another possibility so that we can work with
    it – to provide higher order functions that will be executed in the case of an
    empty or non-empty option. Let's see how this works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Option as an effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first consequence of the aforementioned approach is that it is possible
    to constrain the possible values of the `Option` (and convert it to `None` if
    the conditions don''t hold) without inspecting its contents. Here is an example
    of filtering options further containing a number bigger or less than `10`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to use a partial function as a filter. This allows you
    to filter and transform the value at the same time. For example, you can filter
    numbers bigger than `10` and convert them into a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Functionally, the `collect` method can be seen as a combination of `filter`
    and `map`, where the latter can be used separately to transform the contents of
    a non-empty option. For instance, let''s imagine a chain of calls we''d need to
    make in order to catch a fish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're buying some bait, casting the line, and hooking the fish at the
    appropriate moment. The argument for our implementation is optional because we
    might not know what the best bite for a fish would be.
  prefs: []
  type: TYPE_NORMAL
- en: There is an issue with this implementation, though. We're ignoring the fact
    that our functions will have no results for the given parameters. The fishing
    store might be closed, the cast might break, and the fish can slip out. It turns
    out that we violate our own rules about expressing effects with types that we
    defined a couple of pages ago!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix that by making our functions return `Option`. We''ll start with `hookFish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But now our function returns a nested `Option`, which is hard to work with.
    We can address this by flattening the result using the corresponding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can also make the `castLine` return `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this implementation ceases to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To deal with chained, non-empty options, there is a `flatMap` method, which
    accepts a function returning an `Option` and flattens the result before returning
    it. With `flatMap`, we can implement our chain of calls without the need to call
    `flatten` at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Having `map` and `flatMap` also allows us to use `Option` in `for` comprehensions.
    For instance, we can rewrite the preceding example like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we also added a fallback case for the situation of the fishing shop being
    closed, and when you need to make the bait by hand. This demonstrates that empty options
    can also be chained. The `orElse` method resolves a series of options until the
    first one that''s defined is found or returns the last `Option` in the chain,
    regardless of its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a possibility to map over the `Option` and provide a default value
    for the empty case. This is done with the `fold` method, which accepts the default
    value as a first argument list and a mapping function as a second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last pair of methods available for an `Option` are `toRight` and `toLeft`.
    They return instances of the next effect we want to take a look at, `Either`.
    `toRight` returns `Left`, which contains its argument for `None`, or `Right`,
    containing the value of `Some`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`toLeft` does the same but returns on different sides of `Either`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: But what are these `Left` and `Right` options we are talking about?
  prefs: []
  type: TYPE_NORMAL
- en: Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Either` represents the possibility of a function having one of two alternative
    results which can''t be represented by a single type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s imagine that we have a new simulation system that replaced
    an old one. The new system is very popular, and so is constantly under load and
    thus not always available. The old one is kept as a fallback for this reason.
    Unfortunately, the results of the simulation have very different formats for both
    systems. Hence, it makes sense to represent them as `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If this example gives you the feeling that types of alternatives must be related,
    then you are getting the wrong feeling. Usually, the types of the results would
    be completely unrelated. To illustrate this, let's consider another example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''re fishing, there is the possibility of us catching very different kinds
    of fish. Yet another possibility is to pull something completely different—an
    old boot that was lost by a tourist two years ago, or potential evidence that
    had been concealed by a criminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Traditionally, the right side is preferred to represent the more desirable,
    *right* outcome, the left side is less desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplified definition of `Either` looks like this in the Scala library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It takes two type parameters for the left and right sides, and there are two
    case classes representing these sides. Let's dive a bit deeper using the same
    approach that we did with `Option` – create an effect, read from the effect, and
    abstract over it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, as in the case of `Option`, an obvious way to create an instance of
    `Either` is to use the constructor of the respective case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The caveat is that the preceding definition leaves us with an `Either` whose
    left side is of the type `Nothing`. This probably wasn''t our intention. Therefore,
    it is desirable to provide type parameters for both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is arguably a bit cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, similar to `Option`, the `Either` companion object offers a helpful
    constructor which takes a predicate and two by-name constructors for the right
    and left sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If the condition holds, the `Right` with a given argument is constructed, otherwise
    a `Left` is created. Because both sides are defined, the compiler can inference
    the resulting type of `Either` properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two helper methods that are defined on both the `Left` and `Right` that
    help to upcast the previously defined side to full `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we upcast `Right[Nothing,Int]` to `Either[String,Int]` and do the same
    with `Left`, which produces the resulting value of the type `Either[StringBuilder,BigDecimal]`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values from Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Either` is different from `Option` in the sense that it represents two possible
    values instead of one. Accordingly, we can''t just check if `Either` contains
    a value. We have to specify which side we''re talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'They are of little use if compared to the Option''s approach because `Either`
    does not offer a method to extract the value from it. In the case of `Either`,
    pattern matching is a way to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The predicate functions are also available with semantics similar to `Option`,
    with `None` represented by `Left` and `Some` by `Right`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This special treatment of `Right` as a default side makes `Either` *right-biased*.
    Another example of this bias is the `getOrElse` function, which also returns the
    contents of the `Right` side or the default value provided as an argument in the
    case of `Left`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The right bias plays very well for the conversion to `Option`, with `Some`
    representing the right side and `None` the left side, regardless of the `value`
    of `Left`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `toSeq` represents `Right` as a `Seq` of one element and `Left`
    as an empty `Seq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of there being a `Left` that we''d like to be `Right` or vice versa,
    there is a `swap` method whose sole purpose is to changes sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This can help to apply the right-biased methods if a value that needs to be
    applied is on the left side.
  prefs: []
  type: TYPE_NORMAL
- en: Either as an Effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Naturally, methods defined in terms of an effect are also right-biased for
    `Either`. So is, for example, the callback method `foreach`, which we already
    know from `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the callback is not executed for the `left`, but
    is called as soon as it becomes `Right` after we call `swap` on it. The filtering
    has a bit of a different definition, as it accepts a predicate to filter the right
    side, and a value to return as a `Left` if the predicate does not hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`map` and `flatMap` allow you to transform the right side if you provide the
    appropriate functions. `flatMap` expects the result of the function to have a
    type of `Either` as well. To demonstrate this, we''ll reuse our `Option` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But this time we''ll start with `bestBaitForFish`, which is the result of us
    asking about this other fisherman. The fisherman may be in a bad mood and we might
    hear them cursing instead of the hint we''re expecting to get. These are both
    of the `String` type, but we absolutely want to differentiate between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we''re not living up to the standards we''ve defined for ourselves.
    We might get an explanation from the seller in the shop as to why we can''t have
    the bait we want to buy. In the case that we fail to make bait, cast a line, or
    hook a fish, we might express ourselves verbally as well with some text that we
    will not put in the examples of this book. It makes sense to express the possibility
    that our functions return this verbal feedback if something goes wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can rewrite the code that used `map` with `flatMap`. It makes sense
    to write it as a `for` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The calls will be carried over until the last one succeeds or one of them produces
    a `Left`. In the second case, the first `Left` we meet will be returned as the
    result of the function call.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the `fold` method, which allows us to apply
    the given functions to one side of `Either`. In our use case, we did this to ignore
    any eventual error message that will be returned by the seller in the shop and
    to make the bait ourselves. If we succeed, we wrap the bait into the `Right` before
    returning it so that we have proper type alignment.
  prefs: []
  type: TYPE_NORMAL
- en: The `fold` method is *unbiased* as it treats the left and right sides of `Either`
    equally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last example we looked at, the model we represented with `Either` had
    its left side dedicated to the description of failures that happened during its
    operation. It is always useful to have the type of the error  more specific than
    `String`. Often, especially in cases involving integration with Java, the most
    suitable choice would be to represent errors as subtypes of the `Exception`. In
    fact, this is so ubiquitous that there is a special effect available for this
    in Scala called `Try`. An `Either` having a type of its left side inheriting from
    a `Throwable` can be converted into a `Try` with the respective method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine cases in which `Try` is a better choice then `Either` and learn
    how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same way that `Either` stands for an effect of possible alternative
    results, `Try` denotes the effect of throwing an `Exception` by the function.
    In a sense, it is just a subset of `Either`, but it is so common that it has its
    own implementation. Unsurprisingly, the simplified representation of it looks
    quite familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, `Success` represents the happy-path outcome of the operation, and `Failure` is
    for exceptional conditions. The type for the contents of the `Failure` is fixed
    to be a subclass of `Throwable`, so we're back to the single type parameter for
    the whole ADT, which is similar to `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll study `Try` in the same way as we did with `Option` and `Either` – by creating,
    reading from, and abstracting over the effect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Try
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition of `Try` is already familiar because of its similarity to `Either`,
    and so are the ways of creating an instance of it. For starters, we can use the
    constructors of the case classes to create instances directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea behind `Try` is that it can be used in scenarios where an exception
    would normally be thrown. Hence, the constructors we just mentioned would normally
    form the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will end with the result of the `try` block being wrapped in `Success`
    and the `catch` exception wrapped in `Failure`. Again, `stdlib` already has this
    pattern implemented in the companion object of `Try`. The `apply` method takes
    a single by-name parameter for the `try` block, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: And then catches all `NonFatal` exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '`NonFatal` represents a class of exceptions that the developer is able to deal
    with. It does not include fatal errors such as `OutOfMemoryError`, `StackOverflowError`,
    `LinkageError`, or `InterruptedException`. It does not make sense to deal with
    these programmatically. Another group of Throwables not matched by `NonFatal`
    is `scala.util.control.ControlThrowable`, which is used internally to control
    program flow and thus should not be used in a catch exception either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common to provide multiline blocks wrapped in curly braces as a parameter
    for the `Try` constructor to makes it appear like it''s a language feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This constructor is so common that it covers the absolute majority of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how we can get back the value from an instance of
    `Try`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values from Try
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple ways to approach this task. It is possible to use methods
    similar to `isDefined` and `isEmpty` for `Option`, which allow for a null-pointer
    checking style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this approach suffers from the same issue that `Option` does – if
    we forget to check that the result is a `Success` before extracting it, calling
    `.get` will throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid throwing an exception just after catching it, there is a version of
    `get` that allows us to provide a default argument for the case if `Try` is a
    `Failure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, there are no predicate-taking methods like there were for `Option`.
    The reason for this is that `Try` was adopted from Twitter's implementation and
    was first added to Scala's standard library in version 2.10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `foreach` callback is still available, though, and allows us to define
    a function that will be executed on the value of the `Success`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `foreach` method brings our discussion to the effect side of `Try`.
  prefs: []
  type: TYPE_NORMAL
- en: Try as an effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Try` offers the same functionality as an `Option` in terms of filtering its
    results with a predicate. If the predicate does not hold, the result is represented
    as a `Failure[NoSuchElementException]`. Taking the `line` definition from our
    previous example, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`collect` works in the same way, but it takes a partial function and allows
    us to filter and transform the contents of the `Try` at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter` and `collect` functions are `Success` biased, and so are `map`
    and `flatMap`. Let''s reimplement the fishing example in this situation, where
    our parameter is of type `Try[String]`, and the exceptions are replacing strings
    as the problem descriptions we had in our example of `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The operations are chained on the `Success`. Yet again, we have to fix the
    signatures of our functions so that they encode the possibility of an error in
    every step in the type of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to use `flatMap` instead of `map` to align the types. Again, it
    is more readable if represented as a `for` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is almost identical to the one we have for `Either`, with
    the exception that we now have to wrap successful calls into `Success` and not
    into `Right` (we have to use a different constructor for an effect).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fold` is one of the methods that is unbiased for `Try`. It takes arguments
    to transfer both `Success` and `Failure`, as shown in the preceding code. Another
    unbiased method is `transform`, which is similar to `fold`, but takes functions
    for returning `Try` as parameters. In a sense, `transform` could be called `flatFold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There are also a few functions that are `Failure` biased.
  prefs: []
  type: TYPE_NORMAL
- en: '`recover` and `recoverWith` apply the given partial function to the `Failure`.
    They are basically duals of `map` and `flatMaps`, but for the exception side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `orElse` method allows us to chain Failures in the same way we did with `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, `Try` is similar to `Option` and `Either`, and it should not
    come as a surprise that it can be converted to both `Option` and `Either[Throwable,
    _]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: There is one more effect in the standard library that is a bit different from
    the three we just looked at because it takes into account a more subtle aspect
    of calling a function – the time it is going to take to return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the functions we call take time to return results of the computation.
    Often, the cause is side-effects like reading from a disk or calling a slow remote
    API. At times, the operation itself just requires a lot of CPU time to finish.
    In both cases, the main flow of the program is stopped until the function returns
    the result. It might be acceptable in the latter case to wait for the result if
    it is required immediately after calculation (though even in this case it is suboptimal
    because it makes the system unresponsive), but it is undesirable in the former
    case because it means that our program consumes CPU while doing nothing (well,
    waiting for other subsystems of the computer to return the result, but still nothing
    related to the CPU). Often, such long-running operations are executed in a separate
    thread of execution.
  prefs: []
  type: TYPE_NORMAL
- en: As a functional programmer, we would like to express these—two aspects, that
    is, the duration of the call and the fact that the code is executed in a separate
    thread, as an effect. This is what `Future` does. To be more specific, it does
    not represent the duration of the call explicitly, but encodes it in a binary
    form—an operation either takes long and possibly runs in a separate thread or
    it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: The `Future` is a very interesting concept and deserves a full chapter on its
    own. Here, we'll just take a brief look at some of its aspects. We highly recommend
    referring to the official documentation for more details. Let's apply our ubiquitous
    three-step approach one more time, this time for `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Future` is not encoded as an ADT and thus we have to use a constructor
    that''s provided by the companion object to construct it. Because the code we''ll
    be providing will be executing in a separate thread, the `Future` has to have
    a way to obtain this `Thread`. This is done implicitly by having an `ExecutionContext`
    in scope, which we import in two steps. First, we''ll import the whose `scala.concurrent`
    package in scope and the `ExecutionContext` from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `ExecutionContext` is basically a factory for `Threads`. It can be configured
    as needed for specific use cases. For demonstration purposes, we're using global
    context, but in general, this is not recommended. Please refer to the ScalaDocs
    under [https://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html](https://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html)
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having this context in scope, we can construct a `Future` by providing a by-name
    parameter to its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `Future` starts executing immediately after it is created, with respect
    to the time needed to obtain a thread from the executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we just want to wrap a value at hand into the `Future` for the code
    which expects some `Future` as a parameter. In this case, we don''t need an execution
    context because we don''t need to calculate anything. We can use one of the special
    constructors that help to create it successfully: `failed` and a `Future` from
    `Try`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a predefined `Future[Unit]` that can be used as an indirect constructor
    by mapping over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now, since we have a value inside of the `Future`, let's take a look at the
    possible ways to get it out.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values from a Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the `Future` is not implemented as an ADT, we can't directly pattern-match
    on it as we did with other the effects that we looked at in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can use the null-checking style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, the `value` method returns an `Option` that will be `None` until the
    future completes, so we can use this in a pattern match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the most useful methods are defined not in relation to the value
    of the `Future`, but in terms of `Future` as an effect.
  prefs: []
  type: TYPE_NORMAL
- en: Future as an effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Future` has all of the usual suspects that have been made known to us from
    this chapter so far. `foreach` allows us to define a callback to execute after
    the `Future` successfully completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The order of execution is not guaranteed, as shown in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another callback that is called for any completed feature, regardless
    of its success. It accepts a function, taking `Try` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `transform` method is also applied in both cases. There are two flavors
    of it. One takes two functions, for `Success` and `Failure`, accordingly, and
    another takes one function, `Try => Try`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, we transform the string to its length in the case of success
    and wrap an exception in the case of failure. The second variant is more flexible,
    though, as it allows us to convert success to failure and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'This filtering is also done in the same way as with other effects, that is,
    with the `filter` and `collect` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The former just converts a `Success` into `Failure(NoSuchElementException)` (or
    leaves the existing `Failure` in place) if the predicate does not hold. The latter
    also modifies the contents to upper case for `Success`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And of course, `map` and `flatMap` are available. We''ll let our user service
    use Futures as an effect – this time to denote that every action, including our
    research for the best bite name for the fish, takes some time to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings us to the following, already familiar, implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to see that besides changes in the effect type, the only difference
    to the previous implementations is the use of the fallback method to provide an
    alternative in the case of an unsuccessful call of the `buyBait` method.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to cover about the `Future` and its dual `Promise`. We encourage
    you to take a look at the official documentation and related blog posts (for example 
    [https://viktorklang.com/blog/Futures-in-Scala-2.12-part-9.html](https://viktorklang.com/blog/Futures-in-Scala-2.12-part-9.html))
    for some examples of advanced usage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the effects defined in the standard library. First,
    an `Option` which represents a case where it might be impossible for the function
    to return the result. Then the `Try` which extends the optionality with the possibility
    to return an error description in the failure case. Next was `Either` which further
    extends the concept of `Try` by allowing it to provide an arbitrary type as a
    description of an *unsuccessful* path. Finally, the `Future` which stays a bit
    aside in this list and represents the notion of long and possibly executed in
    separate context computations
  prefs: []
  type: TYPE_NORMAL
- en: We noticed that these effects have different constructors tailored to the situations
    that require the creation of the respective instances. In accordance, they offer
    slightly different ways to access values that are stored inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: We paid attention to the fact that having effects as a first-class concept allows
    us to define methods not only in terms of contained values but also in terms of
    the effect itself, which often leads to more expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we realized that many methods such as `filter`, `collect`, `map`, `flatMap`,
    and so, are on identical from the user's perspective and induce identical, higher
    level implementations for different kinds of effects. We demonstrated this by
    implementing four uniform examples for catching a fish in a few steps, encoded
    in terms of different effects.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, we will identify the underlying concepts that lead to these
    kinds of similarities.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also approach the topic of combining different kinds of effects, which
    we left out of scope for now.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What would be the proper effect to represent getting the first element of a
    list, such as a list of tweets? What about a user's information from the database
    for a given `userId`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the range of possible values of the following expression: `Option(scala.util.Random.nextInt(10)).fold(9)(_-1)`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will be the result of the following expression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the result of the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Given the following function, what would be the result of the following call: `either(1)`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
