<html><head></head><body>
		<div id="_idContainer113">
			<h1 id="_idParaDest-316"><em class="italic"><a id="_idTextAnchor315"/>Chapter 16</em>: Tackling Aliases and SQL Templating</h1>
			<p>This chapter covers two important topics that sustain your road to becoming a jOOQ power user: aliases and SQL templating. </p>
			<p>The first part of this chapter tackles several practices for aliasing tables and columns via the jOOQ DSL. The goal of this part is to make you comfortable when you need to express your SQL aliases via jOOQ and to provide you with a comprehensive list of examples that cover the most common use cases.</p>
			<p>The second part of this chapter is all about SQL templating or how to express SQL when the jOOQ DSL cannot help us. There will be rare cases when you'll have to write plain SQL or combine DSL and plain SQL to obtain some corner cases or vendor-specific features.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Expressing SQL aliases in jOOQ</li>
				<li>SQL templating</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor316"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16</a>.</p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor317"/>Expressing SQL aliases in jOOQ</h1>
			<p>SQL aliasing<a id="_idIndexMarker1661"/> is a simple task. After all, it's just about giving some nicknames to your columns and tables and referring to them via these nicknames instead of using their real names. But as simple as this may seem, this is a rather controversial topic. Some of the open questions you may come across will sound like this: Should I only use aliases when it's mandatory (for instance, when I reference the same table twice)? Should I use meaningful names or will single letters work just fine (<strong class="source-inline">p</strong>, <strong class="source-inline">q</strong>, <strong class="source-inline">t1</strong>, <strong class="source-inline">t2</strong>, and so on)? Do they increase readability and decrease typing time? Most probably, the correct answer is that it depends… on the context, on the query, on who is writing the query (a developer, a DBA, a generator), and so on!</p>
			<p>As you'll see shortly, using<a id="_idIndexMarker1662"/> aliasing via a DSL requires us to respect several rules and to be prepared for some verbosity since the host language (here, Java) comes with several shortcomings that a DSL must address as elegantly as possible. Aliasing sits next to derived tables, arithmetic expressions, and casting as one of the main challenges for a DSL, so let's see exactly what we should know about it.</p>
			<p>The examples from the following sections are available via <em class="italic">SimpleAliases</em> and <em class="italic">AliasesSamples</em>.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor318"/>Expressing simple aliased tables and columns</h2>
			<p>Independent<a id="_idIndexMarker1663"/> of how you like to use SQL aliases, when you want to express them in jOOQ, you must be aware of several methods, including <strong class="source-inline">as()</strong> and <strong class="source-inline">asTable()</strong>, which come in many flavors, such as <strong class="source-inline">as(String alias)</strong>, <strong class="source-inline">as(Name alias)</strong>, <strong class="source-inline">as(Name as, Name... fieldAliases)</strong>, <strong class="source-inline">asTable()</strong>, <strong class="source-inline">asTable(String alias)</strong>, <strong class="source-inline">asTable(Name alias)</strong>, <strong class="source-inline">asTable(Table&lt;?&gt; alias)</strong>, and so on. Commonly, we must deal with aliased tables and fields. Here is a quick sample of using aliased tables in jOOQ:</p>
			<pre class="source-code">ctx.select(field(name("t", "first_name")), </pre>
			<pre class="source-code">           field(name("t", "last_name")))</pre>
			<pre class="source-code">   .from(EMPLOYEE.as("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.select(field(name("t", "product_id")), </pre>
			<pre class="source-code">           field(name("t", "product_name")),</pre>
			<pre class="source-code">           field(selectCount()</pre>
			<pre class="source-code">                  .from(PRODUCT)</pre>
			<pre class="source-code">                  .where(PRODUCT.PRODUCT_ID.eq(</pre>
			<pre class="source-code">                     field(name("t", "product_id"), </pre>
			<pre class="source-code">                       Long.class)))).as("count"))</pre>
			<pre class="source-code">   .from(PRODUCT.as("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The<a id="_idIndexMarker1664"/> following is an example of using some aliased fields (used here to take full control of the column names that are generated in your SQL):</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME.as("fn"), </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME.as("ln"))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<pre class="source-code">ctx.select(concat(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           inline(" "), EMPLOYEE.LAST_NAME).as("name"),</pre>
			<pre class="source-code">           EMPLOYEE.EMAIL.as("contact"), </pre>
			<pre class="source-code">           EMPLOYEE.REPORTS_TO.as("boss_id"))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<p>Next, we'll look at some more complex examples of using aliases.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor319"/>Aliases and JOINs</h2>
			<p>One of the <a id="_idIndexMarker1665"/>common cases where we see SQL aliases at work is in <strong class="source-inline">JOIN</strong> statements. Instead of repeating the table names, people prefer to associate aliases with the joined tables and refer to them via these aliases. For instance, in the following screenshot, we have a <strong class="source-inline">JOIN</strong> between two MySQL tables (<strong class="source-inline">OFFICE</strong> and <strong class="source-inline">DEPARTMENT</strong>) expressed without aliases (top) and with aliases (bottom):</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B16833_Figure_16.1.jpg" alt="Figure 16.1 – JOIN with and without aliases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – JOIN with and without aliases</p>
			<p>If we<a id="_idIndexMarker1666"/> express the first SQL in jOOQ (without using aliases) then we obtain this – in jOOQ, whenever you can omit the usage of aliases, do it! This way, you have better a chance to obtain clean expressions, as shown here:</p>
			<pre class="source-code">ctx.select(OFFICE.CITY, DEPARTMENT.NAME, DEPARTMENT.PROFIT)</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .join(DEPARTMENT)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(DEPARTMENT.OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This is a clean and readable jOOQ snippet of code. Since jOOQ generates the SQL on our behalf, we don't feel the need to add some aliases to increase readability or reduce the typing time.</p>
			<p>Nevertheless, next, let's add the proper aliases to obtain the second SQL. As our first attempt, we may have written this:</p>
			<pre class="source-code">ctx.select(field("t1.city"), </pre>
			<pre class="source-code">           field("t2.name"), field("t2.profit"))</pre>
			<pre class="source-code">   .from(OFFICE.as("t1"))</pre>
			<pre class="source-code">   .join(DEPARTMENT.as("t2"))</pre>
			<pre class="source-code">   .on(field("t1.office_code").eq(field("t2.office_code")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>So, we have associated the <strong class="source-inline">t1</strong> alias with the <strong class="source-inline">OFFICE</strong> table via <strong class="source-inline">OFFICE.as("t1")</strong>, and the <strong class="source-inline">t2</strong> alias with the <strong class="source-inline">DEPARTMENT</strong> table via <strong class="source-inline">DEPARTMENT.as("t2")</strong>. Furthermore, we used our aliases via the <strong class="source-inline">field()</strong> method as <strong class="source-inline">t1</strong> and <strong class="source-inline">t2</strong>, respectively. Besides losing some readability in the jOOQ code, have you spotted other issues in this code compared to the jOOQ code without aliases? Sure you did – it's not type-safe and it renders unquoted identifiers.</p>
			<p>When<a id="_idIndexMarker1667"/> we say <strong class="source-inline">field("t1.city")</strong>, jOOQ renders <strong class="source-inline">t1.city</strong>, not <strong class="source-inline">`t1`.`city` </strong>(in MySQL). However, it is advisable to strive for qualified and quoted identifiers to avoid name conflicts and potential errors (for instance, using a keyword such as <strong class="source-inline">ORDER</strong> as an unquoted table name leads to errors). Generally speaking, quoted identifiers allow us to use reserved names as object names (for instance, <strong class="source-inline">ORDER</strong>), use special characters in object names (whitespaces and so on), and instructs (most databases) us to treat case-insensitive identifiers as case-sensitive ones (for example, <strong class="source-inline">"address"</strong> and <strong class="source-inline">"ADDRESS"</strong> are different identifiers, whereas <strong class="source-inline">address</strong> and <strong class="source-inline">ADDRESS</strong> are not).</p>
			<p>However, jOOQ can render qualified and quoted identifiers if we rely on explicitly using <strong class="source-inline">DSL.name()</strong>, which is a very handy <strong class="source-inline">static</strong> method that comes in several flavors and it is useful for constructing SQL-injection-safe, syntax-safe SQL identifiers for use in plain SQL. It is commonly used in the <strong class="source-inline">table()</strong> and <strong class="source-inline">field()</strong> methods – for example, <strong class="source-inline">name(table_name, field_name)</strong> – but you can check out all the flavors in the documentation. The following table represents what jOOQ renders for different usages of the <strong class="source-inline">name()</strong> method and different databases:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B16833_Figure_16.2.jpg" alt="Figure 16.2 – Using jOOQ name()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.2 – Using jOOQ name()</p>
			<p>When an identifier occurs several times, it can be extracted in a local variable as a <strong class="source-inline">Name</strong> and reused in queries as needed, like so:</p>
			<pre class="source-code">Name orderId = name("ORDER", "ORDER_ID");</pre>
			<pre class="source-code">Field orderId = field(name("ORDER", "ORDER_ID"));</pre>
			<pre class="source-code">Table t = table(name("ORDER"));</pre>
			<p>When jOOQ evaluates <strong class="source-inline">name("ORDER", "ORDER_ID")</strong> (for MySQL), it renders <strong class="source-inline">`ORDER`.`ORDER_ID`</strong>. Of course, <strong class="source-inline">ORDER_ID</strong> doesn't necessarily need the back ticks – only <strong class="source-inline">ORDER</strong> does. Playing with quotations for identifiers can be done via <strong class="source-inline">quotedName()</strong> and <strong class="source-inline">unquotedName()</strong> of the <strong class="source-inline">DSL</strong> class, like so: </p>
			<pre class="source-code">// `ORDER`.ORDER_ID</pre>
			<pre class="source-code">Name orderId = name(quotedName("ORDER"), </pre>
			<pre class="source-code">                    unquotedName("ORDER_ID"));</pre>
			<p>Moreover, jOOQ allows us to control (globally or at the query level) how identifiers are quoted via <a id="_idIndexMarker1668"/>the <strong class="source-inline">RenderQuotedNames</strong> setting and cases via the <strong class="source-inline">RenderNameCase</strong> setting. For instance, we can instruct jOOQ to quote all the identifiers in the upper part of the current query, as follows:</p>
			<pre class="source-code">For MySQL, jOOQ render this SQL:</pre>
			<pre class="source-code">select `T`.`FIRST_NAME` as `FN`, `T`.`LAST_NAME` as `LN` </pre>
			<pre class="source-code">from `CLASSICMODELS`.`EMPLOYEE` as `T`</pre>
			<pre class="source-code">ctx.configuration().derive(new Settings()</pre>
			<pre class="source-code">   .withRenderQuotedNames(RenderQuotedNames.ALWAYS)</pre>
			<pre class="source-code">   .withRenderNameCase(RenderNameCase.UPPER))</pre>
			<pre class="source-code">   .dsl()</pre>
			<pre class="source-code">   .select(field(name("t", "first_name")).as("fn"), </pre>
			<pre class="source-code">           field(name("t", "last_name")).as("ln"))</pre>
			<pre class="source-code">   .from(EMPLOYEE.as("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>While you can find more details about these settings in the documentation (<a href="https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/">https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/</a>), keep in mind that they only affect identifiers that are expressed via Java-based schemas or <strong class="source-inline">name()</strong>. In other words, they have no effect on <strong class="source-inline">field("identifier")</strong> and <strong class="source-inline">table("identifier")</strong>. These are rendered exactly as you provide them.</p>
			<p>jOOQ<a id="_idIndexMarker1669"/> doesn't force us in any way to use quoting, qualifications, and cases consistently in the same query or across multiple queries (since jOOQ renders by default). However, juggling these aspects may lead to issues, from inconsistent results to SQL errors. This happens because, in some databases (for instance, SQL Server), identifiers are always case insensitive. This means that quoting only helps to allow special characters or escape keywords in identifiers. In other databases (for instance, Oracle), identifiers are only case insensitive if they are unquoted, while quoted identifiers are case sensitive. However, there are also databases (for instance, Sybase ASE) where identifiers are always case sensitive, regardless of them being quoted. Again, quoting only helps to allow special characters or escape keywords in identifiers. And, let's not forget the dialects (for instance, MySQL) that mix the preceding rules, depending on the operating system, object type, configuration, and other events.</p>
			<p>So, pay attention to how you decide to handle quoting, qualification, and case sensitivity aspects. The best/safest way is to express queries via the Java-based schema, use aliases only when they are mandatory, and always use <strong class="source-inline">name()</strong> if you have to refer to identifiers as plain strings. From that point on, let jOOQ do the rest.</p>
			<p>That being said, if we apply <strong class="source-inline">name()</strong> to our query, we obtain the following code:</p>
			<pre class="source-code">ctx.select(field(name("t1", "city")), </pre>
			<pre class="source-code">      field(name("t2", "name")), field(name("t2", "profit")))</pre>
			<pre class="source-code">   .from(OFFICE.as(name("t1")))</pre>
			<pre class="source-code">   .join(DEPARTMENT.as(name("t2")))</pre>
			<pre class="source-code">   .on(field(name("t1", "office_code"))</pre>
			<pre class="source-code">        .eq(field(name("t2", "office_code"))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, the rendered identifiers correspond to our expectations, but this snippet of jOOQ code is still not type-safe. To transform this non-type-safe query into a type-safe one, we must extract the aliases and define them in local variables before using them, as follows (notice that there is no reason to explicitly use <strong class="source-inline">name()</strong>):</p>
			<pre class="source-code">Office t1 = OFFICE.as("t1");</pre>
			<pre class="source-code">Department t2 = DEPARTMENT.as("t2");</pre>
			<pre class="source-code">ctx.select(t1.CITY, t2.NAME, t2.PROFIT)</pre>
			<pre class="source-code">   .from(t1)</pre>
			<pre class="source-code">   .join(t2)</pre>
			<pre class="source-code">   .on(t1.OFFICE_CODE.eq(t2.OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Alternatively, you <a id="_idIndexMarker1670"/>may prefer a minimalist aliasing approach, as follows:</p>
			<pre class="source-code">Department t = DEPARTMENT.as("t"); </pre>
			<pre class="source-code">// or, Department t = DEPARTMENT;</pre>
			<pre class="source-code">ctx.select(OFFICE.CITY, t.NAME, t.PROFIT)</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .join(t)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(t.OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Calling the <strong class="source-inline">as()</strong> method on the generated tables (here, on <strong class="source-inline">OFFICE</strong> and <strong class="source-inline">DEPARTMENT</strong>) returns an object of the same type as the table (<strong class="source-inline">jooq.generated.tables.Office</strong> and <strong class="source-inline">jooq.generated.tables.Department</strong>). The resulting object can be used to dereference fields from the aliased table in a type-safe way. So, thanks to <strong class="source-inline">as()</strong>, <strong class="source-inline">Office</strong>, and <strong class="source-inline">Department</strong>, we are type-safe again while using the desired table aliases. And, of course, the identifiers are implicitly rendered, quoted, and qualified.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">As a rule of thumb, in jOOQ, strive to extract and declare aliases in local variables before using them in queries. Do this especially if your aliases refer to the generated tables, are aliases that should be reused across multiple queries, you wish to increase the readability of the jOOQ expression and/or avoid typos, and so on. Of course, if your jOOQ expression simply associates some aliases to columns (to take full control of the column names that are generated in your SQL), then extracting them as local variables won't produce a significant improvement.</p>
			<p>Let's look at a table<a id="_idIndexMarker1671"/> that's been aliased as follows:</p>
			<pre class="source-code">Table&lt;Record1&lt;String&gt;&gt; t3 = </pre>
			<pre class="source-code">  ctx.select(t1.CITY).from(t1).asTable("t3");</pre>
			<p>In this case, we can refer to fields in a non-type-safe manner via <strong class="source-inline">field(Name name)</strong>, as shown in the following example:</p>
			<pre class="source-code">ctx.select(t3.field(name("city")), </pre>
			<pre class="source-code">      CUSTOMERDETAIL.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">   .from(t3)</pre>
			<pre class="source-code">   .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .on(t3.field(name("city"), String.class)</pre>
			<pre class="source-code">     .eq(CUSTOMERDETAIL.CITY))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The same <strong class="source-inline">field()</strong> method can be applied to any type-unsafe aliased table as <strong class="source-inline">Table&lt;?&gt;</strong> to return <strong class="source-inline">Field&lt;?&gt;</strong>.</p>
			<p>In this case, we can make these fields look type-safe via the <strong class="source-inline">&lt;T&gt; Field&lt;T&gt; field(Field&lt;T&gt; field)</strong> method as well (introduced in <a href="B16833_14.xhtml#_idTextAnchor284"><em class="italic">Chapter 14</em></a><em class="italic">, Derived Tables, CTEs, and Views</em>). The <strong class="source-inline">t3.field(name("city"))</strong> expression indirectly refers to the <strong class="source-inline">t1.CITY</strong> field, so we can rewrite our queries in a type-safe manner, as follows:</p>
			<pre class="source-code">ctx.select(t3.field(t1.CITY), CUSTOMERDETAIL.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">   .from(t3)</pre>
			<pre class="source-code">   .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .on(t3.field(t1.CITY).eq(CUSTOMERDETAIL.CITY))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>However, <a id="_idIndexMarker1672"/>remember that <strong class="source-inline">Table.field(Field&lt;T&gt;):Field&lt;T&gt;</strong> just looks type-safe. It's as good as an unsafe cast in Java because the lookup only considers the identifier, not the type. Nor does it coerce the expression.</p>
			<p>So far, so good! You can practice these examples in <em class="italic">AliasesSamples</em>. Now, let's take some time to cover several fundamental aspects of jOOQ aliases and practice some simple but essential exercises.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor320"/>Aliases and GROUP BY/ORDER BY</h2>
			<p>Let's <a id="_idIndexMarker1673"/>consider the following SQL expressed in SQL Server:</p>
			<pre class="source-code">SELECT [classicmodels].[dbo].[product].[product_line] [pl]</pre>
			<pre class="source-code">FROM [classicmodels].[dbo].[product]</pre>
			<pre class="source-code">GROUP BY [classicmodels].[dbo].[product].[product_line]</pre>
			<pre class="source-code">ORDER BY [pl]</pre>
			<p>This query uses<a id="_idIndexMarker1674"/> an alias named <strong class="source-inline">pl</strong> for the <strong class="source-inline">PRODUCT_LINE</strong> column. Attempting to express this query via jOOQ, based on what we learned earlier, may result in something like this:</p>
			<pre class="source-code">Field&lt;String&gt; pl = PRODUCT.PRODUCT_LINE.as("pl");     </pre>
			<pre class="source-code">ctx.select(pl)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .groupBy(pl)</pre>
			<pre class="source-code">   .orderBy(pl)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But this isn't correct! The problem here is related to our expectations. We expect <strong class="source-inline">PRODUCT.PRODUCT_LINE.as("pl")</strong> to produce <strong class="source-inline">[pl]</strong> in <strong class="source-inline">ORDER BY</strong>, <strong class="source-inline">[classicmodels].[dbo].[product].[product_line]</strong> in <strong class="source-inline">GROUP BY</strong>, and <strong class="source-inline">[classicmodels].[dbo].[product].[product_line] [pl]</strong> in <strong class="source-inline">SELECT</strong>. In other words, we expect that the three usages of the local <strong class="source-inline">pl</strong> variable will magically render<a id="_idIndexMarker1675"/> the output that makes more sense for us. Well, this isn't true!</p>
			<p>Think <a id="_idIndexMarker1676"/>about the jOOQ DSL more as an expression tree. So, we can store both <strong class="source-inline">PRODUCT.PRODUCT_LINE</strong> and <strong class="source-inline">PRODUCT.PRODUCT_LINE.as("pl")</strong> in separate local variables, and explicitly reuse the one that makes the most sense:</p>
			<pre class="source-code">Field&lt;String&gt; pl1 = PRODUCT.PRODUCT_LINE.as("pl");     </pre>
			<pre class="source-code">Field&lt;String&gt; pl2 = PRODUCT.PRODUCT_LINE;   </pre>
			<pre class="source-code">ctx.select(pl1)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .groupBy(pl2)</pre>
			<pre class="source-code">   .orderBy(pl1)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, it is correct! </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Reusing the <strong class="source-inline">x.as("y")</strong> expression in a query and thinking that it "magically" produces <strong class="source-inline">x</strong> or <strong class="source-inline">y</strong>, whatever makes more sense, is a really bad understanding of jOOQ aliases. Thinking that <strong class="source-inline">x.as("y")</strong> generates <strong class="source-inline">x</strong> in <strong class="source-inline">GROUP BY</strong>, <strong class="source-inline">y</strong> in <strong class="source-inline">ORDER BY</strong>, and <strong class="source-inline">x.as("y")</strong> in <strong class="source-inline">SELECT</strong> is dangerous logic that will give you headaches. The aliased expression, <strong class="source-inline">x.as("y")</strong>, produces <strong class="source-inline">y</strong> "everywhere" outside of <strong class="source-inline">SELECT</strong>, and it produces the alias declaration in <strong class="source-inline">SELECT</strong> (but only immediately in <strong class="source-inline">SELECT</strong>). It "never" produces only <strong class="source-inline">x</strong>.</p>
			<p>You can practice these examples in <em class="italic">AliasesSamples</em>.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor321"/>Aliases and bad assumptions</h2>
			<p>Next, let's consider<a id="_idIndexMarker1677"/> the examples shown in the following screenshot:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B16833_Figure_16.3.jpg" alt="Figure 16.3 – Aliases use case&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.3 – Aliases use case</p>
			<p>What can you say about (A) and (B)? If you said that (A) is correct while (B) is wrong, then you are right. Congratulations! Speaking about (B), since we assigned an alias to the <strong class="source-inline">[office]</strong> table, the <strong class="source-inline">[office].[city]</strong> column becomes unknown. The rendered SQL highlights the following aspect:</p>
			<pre class="source-code">SELECT [classicmodels].[dbo].[office].[city]</pre>
			<pre class="source-code">FROM [classicmodels].[dbo].[office] [t]</pre>
			<p>So, one simple and straightforward solution is to simply remove the alias. Now, let's examine a few bad choices. First, let's explore this one:</p>
			<pre class="source-code">// SELECT t FROM [classicmodels].[dbo].[office] [t]        </pre>
			<pre class="source-code">ctx.select(field("t", "city"))</pre>
			<pre class="source-code">   .from(OFFICE.as("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This construction is based on the assumption that jOOQ exposes a method, <strong class="source-inline">field(String table_name, String field_name)</strong>, but there is no such method! Then why does the preceding code compile? Because DSL exposes a <strong class="source-inline">field(String sql, Object... bindings)</strong> that is used for SQL templating, it's being used in the wrong context. Pay attention to such silly mistakes! Who didn't feel lucky and tried to use an API without reading the documentation?!</p>
			<p>Now, how about this one?</p>
			<pre class="source-code">// SELECT [t].[office_code], [t].[city], ..., [t].[location] </pre>
			<pre class="source-code">// FROM [classicmodels].[dbo].[office] [t]</pre>
			<pre class="source-code">ctx.select(table("t").field("city"))</pre>
			<pre class="source-code">   .from(OFFICE.as("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This is just <a id="_idIndexMarker1678"/>another example built on wrong assumptions. While jOOQ exposes a <strong class="source-inline">table(String sql)</strong>, which is useful for returning a table that wraps the given plain SQL, this example assumes the existence of a <strong class="source-inline">table(String alias)</strong> that returns a table that wraps an alias and is aware of its fields.</p>
			<p>Going further, let's try this approach:</p>
			<pre class="source-code">// SELECT [city] FROM [classicmodels].[dbo].[office] [t]</pre>
			<pre class="source-code">ctx.select(field(name("city")))</pre>
			<pre class="source-code">   .from(OFFICE.as("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This approach works just fine but you must be aware that the unqualified <strong class="source-inline">[city]</strong> is prone to ambiguities. For instance, let's say that we enrich this query, as follows:</p>
			<pre class="source-code">ctx.select(field(name("city")))                   </pre>
			<pre class="source-code">   .from(OFFICE.as("t1"), CUSTOMERDETAIL.as("t2"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This leads to an ambiguous column, <strong class="source-inline">[city]</strong>, because it's unclear if we are referring to <strong class="source-inline">OFFICE.CITY</strong> or <strong class="source-inline">CUSTOMERDETAIL.CITY</strong>. In this case, table aliases can help us express this clearly:</p>
			<pre class="source-code">ctx.select(field(name("t1", "city")).as("city_office"),     </pre>
			<pre class="source-code">           field(name("t2", "city")).as("city_customer"))</pre>
			<pre class="source-code">   .from(OFFICE.as("t1"), CUSTOMERDETAIL.as("t2"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>It's much <a id="_idIndexMarker1679"/>better to declare aliases before using them:</p>
			<pre class="source-code">Office t1 = OFFICE.as("t1");</pre>
			<pre class="source-code">Customerdetail t2 = CUSTOMERDETAIL.as("t2");</pre>
			<pre class="source-code">ctx.select(t1.CITY, t2.CITY)</pre>
			<pre class="source-code">   .from(t1, t2)</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">Field&lt;String&gt; c1 = t1.CITY.as("city_office");</pre>
			<pre class="source-code">Field&lt;String&gt; c2 = t2.CITY.as("city_customer");</pre>
			<pre class="source-code">ctx.select(c1, c2)</pre>
			<pre class="source-code">   .from(t1, t2)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Now, let's look at another case and start with two wrong approaches. So, what's wrong here?</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE</pre>
			<pre class="source-code">   .leftOuterJoin(DEPARTMENT)</pre>
			<pre class="source-code">     .on(OFFICE.OFFICE_CODE.eq(DEPARTMENT.OFFICE_CODE)))</pre>
			<pre class="source-code">   .innerJoin(EMPLOYEE)</pre>
			<pre class="source-code"><strong class="bold">     .on(EMPLOYEE.OFFICE_CODE.eq(</strong></pre>
			<pre class="source-code"><strong class="bold">        field(name("office_code"), String.class)))</strong></pre>
			<pre class="source-code">   .fetch();</pre>
			<p>After joining <strong class="source-inline">OFFICE</strong> and <strong class="source-inline">DEPARTMENT</strong>, the result contains two columns named <strong class="source-inline">office_code</strong> – one from <strong class="source-inline">OFFICE</strong> and another from <strong class="source-inline">DEPARTMENT</strong>. Joining this result with <strong class="source-inline">EMPLOYEE</strong> reveals that the <strong class="source-inline">office_code</strong> column in the <strong class="source-inline">ON</strong> clause is ambiguous. To<a id="_idIndexMarker1680"/> remove this ambiguity, we can use aliased tables:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE.as("o")</pre>
			<pre class="source-code">   .leftOuterJoin(DEPARTMENT.as("d"))</pre>
			<pre class="source-code">     .on(field(name("o","office_code"))</pre>
			<pre class="source-code">       .eq(field(name("d","office_code")))))</pre>
			<pre class="source-code">   .innerJoin(EMPLOYEE)</pre>
			<pre class="source-code"><strong class="bold">     .on(EMPLOYEE.OFFICE_CODE.eq(OFFICE.OFFICE_CODE))</strong></pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Is this correct? This time, we have associated aliases with our <strong class="source-inline">OFFICE.as("o")</strong> and <strong class="source-inline">DEPARTMENT.as("d")</strong> tables. While joining <strong class="source-inline">OFFICE</strong> with <strong class="source-inline">DEPARTMENT</strong>, we correctly used the aliases, but when we joined the result to <strong class="source-inline">EMPLOYEE</strong>, we didn't use the <strong class="source-inline">OFFICE</strong> alias – we used the un-aliased <strong class="source-inline">OFFICE.OFFICE_CODE</strong>. This is rendered in MySQL as <strong class="source-inline">`classicmodels`.`office`.`office_code`</strong> and it represents an unknown column in the <strong class="source-inline">ON</strong> clause. So, the correct expression is as follows:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE.as("o")</pre>
			<pre class="source-code">   .leftOuterJoin(DEPARTMENT.as("d"))</pre>
			<pre class="source-code">     .on(field(name("o","office_code"))</pre>
			<pre class="source-code">       .eq(field(name("d","office_code")))))</pre>
			<pre class="source-code">   .innerJoin(EMPLOYEE)</pre>
			<pre class="source-code">     .on(EMPLOYEE.OFFICE_CODE</pre>
			<pre class="source-code">       .eq(field(name("o","office_code"), String.class)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Can we write this <a id="_idIndexMarker1681"/>more compact and type-safe? Sure we can – via local variables:</p>
			<pre class="source-code">Office o = OFFICE.as("o");</pre>
			<pre class="source-code">Department d = DEPARTMENT.as("d");</pre>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(o.leftOuterJoin(d)</pre>
			<pre class="source-code">   .on(o.OFFICE_CODE.eq(d.OFFICE_CODE)))</pre>
			<pre class="source-code">   .innerJoin(EMPLOYEE)</pre>
			<pre class="source-code">     .on(EMPLOYEE.OFFICE_CODE.eq(o.OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Again, local variables help us express aliases and obtain elegant code.</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor322"/>Aliases and typos</h2>
			<p>Next, let's look <a id="_idIndexMarker1682"/>at another way to extract aliases in local variables. Check out the following code:</p>
			<pre class="source-code">ctx.select(field("s1.msrp"), field("s2.msrp"))</pre>
			<pre class="source-code">   .from(PRODUCT.as("s1"), PRODUCT.as("s2"))</pre>
			<pre class="source-code">   .where(field("s1.msrp").lt(field("s2.msrp"))</pre>
			<pre class="source-code">      .and(field("s1.product_line").eq("s2.product_line")))</pre>
			<pre class="source-code">   .groupBy(field("s1.msrp"), field("s2.msrp"))</pre>
			<pre class="source-code">   .having(count().eq(selectCount().from(PRODUCT.as("s3"))</pre>
			<pre class="source-code">   .where(field("s3.msrp").eq(field("s1.msrp"))))</pre>
			<pre class="source-code">      .and(count().eq(selectCount().from(PRODUCT.as("s4"))</pre>
			<pre class="source-code">      .where(field("s4.msrp").eq(field("s2.msrp"))))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>There is a mistake (a typo) in this expression. Can you spot it? (It isn't easy!) If not, you'll end up with valid SQL that returns inaccurate results. The typo snuck into the <strong class="source-inline">.and(field("s1.product_line").eq("s2.product_line")))</strong> part of the code, which should be <strong class="source-inline">.and(field("s1.product_line").eq(field("s2.product_line"))))</strong>. But if we extract the aliases in local variables, then the code eliminates the risk of a typo and increases the readability of the expression (notice that <strong class="source-inline">s1</strong>, <strong class="source-inline">s2</strong>, <strong class="source-inline">s3</strong>, and <strong class="source-inline">s4</strong> are not equal <a id="_idIndexMarker1683"/>objects and that they cannot be used interchangeably):</p>
			<pre class="source-code">Product s1 = PRODUCT.as("s1");</pre>
			<pre class="source-code">Product s2 = PRODUCT.as("s2");</pre>
			<pre class="source-code">Product s3 = PRODUCT.as("s3");</pre>
			<pre class="source-code">Product s4 = PRODUCT.as("s4");</pre>
			<pre class="source-code">ctx.select(s1.MSRP, s2.MSRP)</pre>
			<pre class="source-code">   .from(s1, s2)</pre>
			<pre class="source-code">   .where(s1.MSRP.lt(s2.MSRP)</pre>
			<pre class="source-code">   .and(s1.PRODUCT_LINE.eq(s2.PRODUCT_LINE)))</pre>
			<pre class="source-code">   .groupBy(s1.MSRP, s2.MSRP)</pre>
			<pre class="source-code">   .having(count().eq(selectCount().from(s3)</pre>
			<pre class="source-code">     .where(s3.MSRP.eq(s1.MSRP)))</pre>
			<pre class="source-code">     .and(count().eq(selectCount().from(s4)</pre>
			<pre class="source-code">     .where(s4.MSRP.eq(s2.MSRP)))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can practice these examples in <em class="italic">AliasesSamples</em>.</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor323"/>Aliases and derived tables</h2>
			<p>Let's look at <a id="_idIndexMarker1684"/>another example that starts with the following snippet of code:</p>
			<pre class="source-code">ctx.select().from(</pre>
			<pre class="source-code"> select(CUSTOMER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">        CUSTOMER.CUSTOMER_NAME, field("t.invoice_amount"))</pre>
			<pre class="source-code"> .from(CUSTOMER)</pre>
			<pre class="source-code"> .join(select(PAYMENT.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">              PAYMENT.INVOICE_AMOUNT)</pre>
			<pre class="source-code">        .from(PAYMENT).asTable("t"))</pre>
			<pre class="source-code">  .on(field("t.customer_number")</pre>
			<pre class="source-code">    .eq(CUSTOMER.CUSTOMER_NUMBER))) </pre>
			<pre class="source-code"> .fetch();</pre>
			<p>So, what's wrong here?! Let's inspect the generated SQL (this is for MySQL):</p>
			<pre class="source-code">SELECT `alias_84938429`.`customer_number`,</pre>
			<pre class="source-code">       `alias_84938429`.`customer_name`,</pre>
			<pre class="source-code">       `<strong class="bold">alias_84938429`.t.invoice_amount</strong></pre>
			<pre class="source-code">FROM</pre>
			<pre class="source-code">  (SELECT `classicmodels`.`customer`.`customer_number`,</pre>
			<pre class="source-code">          `classicmodels`.`customer`.`customer_name`,</pre>
			<pre class="source-code">          t.invoice_amount</pre>
			<pre class="source-code">   FROM `classicmodels`.`customer`</pre>
			<pre class="source-code">   JOIN</pre>
			<pre class="source-code">     (SELECT `classicmodels`.`payment`.`customer_number`,</pre>
			<pre class="source-code">             `classicmodels`.`payment`.`invoice_amount`</pre>
			<pre class="source-code">      FROM `classicmodels`.`payment`) AS `t` ON </pre>
			<pre class="source-code">       t.customer_number = </pre>
			<pre class="source-code">        `classicmodels`.`customer`.`customer_number`) </pre>
			<pre class="source-code">      AS `alias_84938429</pre>
			<p>As you<a id="_idIndexMarker1685"/> can see, jOOQ has automatically associated an alias with the derived table (<strong class="source-inline">alias_84938429</strong>) that was obtained from <strong class="source-inline">JOIN</strong> and used this alias to reference <strong class="source-inline">customer_number</strong>, <strong class="source-inline">customer_name</strong>, and <strong class="source-inline">invoice_amount</strong>. While <strong class="source-inline">customer_number</strong> and <strong class="source-inline">customer_name</strong> are correctly qualified and quoted, <strong class="source-inline">invoice_amount</strong> has been incorrectly rendered as <strong class="source-inline">t.invoice_amount</strong>. The problem is in <strong class="source-inline">field("t.invoice_amount")</strong>, which instructs jOOQ that the column name is <strong class="source-inline">t.invoice_amount</strong>, not <strong class="source-inline">invoice_amount</strong>, so the resulting <strong class="source-inline">`alias_84938429`.t.invoice_amount</strong> is an unknown column.</p>
			<p>There are a few solutions to this problem, and one of them consists of using <strong class="source-inline">name()</strong> for proper quoting and qualifying:</p>
			<pre class="source-code">ctx.select().from(select(CUSTOMER.CUSTOMER_NUMBER,   </pre>
			<pre class="source-code">CUSTOMER.CUSTOMER_NAME, <strong class="bold">field(name("t", "invoice_amount"))</strong>)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .join(</pre>
			<pre class="source-code">     select(PAYMENT.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">            PAYMENT.INVOICE_AMOUNT)</pre>
			<pre class="source-code">      .from(PAYMENT).asTable("t"))</pre>
			<pre class="source-code">   .on(field(name("t", "customer_number"))</pre>
			<pre class="source-code">     .eq(CUSTOMER.CUSTOMER_NUMBER)))</pre>
			<pre class="source-code">   .fetch();    </pre>
			<p>This time, jOOQ renders <strong class="source-inline">`alias_10104609`.`invoice_amount`</strong>. In the bundled code, you can see four more solutions to this problem.</p>
			<p>To understand this context, let's check out the following example:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(select(EMPLOYEE.EMPLOYEE_NUMBER.as("en"), </pre>
			<pre class="source-code">                EMPLOYEE.SALARY.as("sal"))</pre>
			<pre class="source-code">             .from(EMPLOYEE)</pre>
			<pre class="source-code">             .where(EMPLOYEE.MONTHLY_BONUS.isNull()))</pre>
			<pre class="source-code">             .innerJoin(SALE)</pre>
			<pre class="source-code">             .on(field(name("en"))</pre>
			<pre class="source-code">             .eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here, we<a id="_idIndexMarker1686"/> have explicitly associated column aliases with the inner <strong class="source-inline">SELECT</strong>, but we did not associate an alias with the derived table produced by <strong class="source-inline">JOIN</strong>. These aliases are further used to reference the columns outside this <strong class="source-inline">SELECT</strong> (in the outer <strong class="source-inline">SELECT</strong>). Notice that we let jOOQ qualify these aliases to the generated alias for the divided table accordingly:</p>
			<pre class="source-code">SELECT `alias_41049514`.`en`,</pre>
			<pre class="source-code">       `alias_41049514`.`sal`,</pre>
			<pre class="source-code">       `classicmodels`.`sale`.`sale_id`,</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">FROM</pre>
			<pre class="source-code">  (SELECT `classicmodels`.`employee`.`employee_number` </pre>
			<pre class="source-code">       AS `en`, `classicmodels`.`employee`.`salary` AS `sal`</pre>
			<pre class="source-code">   FROM `classicmodels`.`employee`</pre>
			<pre class="source-code">   WHERE `classicmodels`.`employee`.`monthly_bonus` IS NULL </pre>
			<pre class="source-code">         ) AS `alias_41049514`</pre>
			<pre class="source-code">JOIN `classicmodels`.`sale` ON `en` = </pre>
			<pre class="source-code">     `classicmodels`.`sale`.`employee_number`</pre>
			<p>If we want<a id="_idIndexMarker1687"/> to control the alias of the derived table as well, then we can do the following:</p>
			<pre class="source-code">ctx.select(SALE.SALE_, SALE.FISCAL_YEAR, </pre>
			<pre class="source-code">           field(name("t", "sal")))</pre>
			<pre class="source-code">   .from(select(EMPLOYEE.EMPLOYEE_NUMBER.as("en"), </pre>
			<pre class="source-code">                EMPLOYEE.SALARY.as("sal"))</pre>
			<pre class="source-code">         .from(EMPLOYEE)</pre>
			<pre class="source-code">         .where(EMPLOYEE.MONTHLY_BONUS.isNull())</pre>
			<pre class="source-code">                .asTable("t"))</pre>
			<pre class="source-code">         .innerJoin(SALE)</pre>
			<pre class="source-code">          .on(field(name("t", "en"))</pre>
			<pre class="source-code">          .eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, the rendered SQL uses our table alias:</p>
			<pre class="source-code">SELECT `classicmodels`.`sale`.`sale`,</pre>
			<pre class="source-code">       `classicmodels`.`sale`.`fiscal_year`,</pre>
			<pre class="source-code">       `t`.`sal`</pre>
			<pre class="source-code">FROM</pre>
			<pre class="source-code">  (SELECT `classicmodels`.`employee`.`employee_number` </pre>
			<pre class="source-code">    AS `en`, `classicmodels`.`employee`.`salary` AS `sal`</pre>
			<pre class="source-code">   FROM `classicmodels`.`employee`</pre>
			<pre class="source-code">   WHERE `classicmodels`.`employee`.`monthly_bonus`  </pre>
			<pre class="source-code">      IS NULL) AS `t`</pre>
			<pre class="source-code">JOIN `classicmodels`.`sale` ON `t`.`en` = </pre>
			<pre class="source-code">     `classicmodels`.`sale`.`employee_number`</pre>
			<p>Finally, here is a more verbose example of using aliases:</p>
			<pre class="source-code">ctx.select(field(name("t2", "s")).as("c1"), </pre>
			<pre class="source-code">           field(name("t2", "y")).as("c2"), </pre>
			<pre class="source-code">           field(name("t2", "i")).as("c3"))</pre>
			<pre class="source-code">   .from(select(SALE.SALE_.as("s"), SALE.FISCAL_YEAR.as("y"), </pre>
			<pre class="source-code">                field(name("t1", "emp_sal")).as("i"))</pre>
			<pre class="source-code">          .from(select(EMPLOYEE.EMPLOYEE_NUMBER.as("emp_nr"), </pre>
			<pre class="source-code">               EMPLOYEE.SALARY.as("emp_sal"))</pre>
			<pre class="source-code">                 .from(EMPLOYEE)</pre>
			<pre class="source-code">                 .where(EMPLOYEE.MONTHLY_BONUS.isNull())</pre>
			<pre class="source-code">                 .asTable("t1"))</pre>
			<pre class="source-code">   .innerJoin(SALE)</pre>
			<pre class="source-code">   .on(field(name("t1","emp_nr"))</pre>
			<pre class="source-code">     .eq(SALE.EMPLOYEE_NUMBER)).asTable("t2"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Take your<a id="_idIndexMarker1688"/> time to analyze this expression and the generated SQL:</p>
			<pre class="source-code">SELECT `t2`.`s` AS `c1`,</pre>
			<pre class="source-code">       `t2`.`y` AS `c2`,</pre>
			<pre class="source-code">       `t2`.`i` AS `c3`</pre>
			<pre class="source-code">FROM</pre>
			<pre class="source-code">  (SELECT `classicmodels`.`sale`.`sale` AS `s`,</pre>
			<pre class="source-code">          `classicmodels`.`sale`.`fiscal_year` AS `y`,</pre>
			<pre class="source-code">          `t1`.`emp_sal` AS `i`</pre>
			<pre class="source-code">   FROM</pre>
			<pre class="source-code">     (SELECT `classicmodels`.`employee`.`employee_number` </pre>
			<pre class="source-code">                 AS `emp_nr`, </pre>
			<pre class="source-code">             `classicmodels`.`employee`.`salary`  </pre>
			<pre class="source-code">                 AS `emp_sal`</pre>
			<pre class="source-code">      FROM `classicmodels`.`employee`</pre>
			<pre class="source-code">      WHERE `classicmodels`.`employee`.`monthly_bonus` </pre>
			<pre class="source-code">        IS NULL) AS `t1`</pre>
			<pre class="source-code">   JOIN `classicmodels`.`sale` ON `t1`.`emp_nr` = </pre>
			<pre class="source-code">        `classicmodels`.`sale`.`employee_number`) AS `t2`</pre>
			<p>Now, let's look at a few more examples of using aliases.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor324"/>Derived column list</h2>
			<p>When<a id="_idIndexMarker1689"/> column names are not known in advance (but the table's degree is!), we can use the so-called <em class="italic">derived column list</em>. You saw many examples of using this feature with unnested tables, so here are two more for the <strong class="source-inline">VALUES()</strong> table constructor and a regular table:</p>
			<pre class="source-code">ctx.select().from(values(row("A", "John", 4333, false))</pre>
			<pre class="source-code">  .as("T", "A", "B", "C", "D")).fetch();</pre>
			<p>The following code is for a regular table:</p>
			<pre class="source-code">ctx.select(min(field(name("t", "rdate"))).as("cluster_start"),</pre>
			<pre class="source-code">         max(field(name("t", "rdate"))).as("cluster_end"),</pre>
			<pre class="source-code">         min(field(name("t", "status"))).as("cluster_status"))</pre>
			<pre class="source-code">    .from(select(ORDER.REQUIRED_DATE, ORDER.STATUS,</pre>
			<pre class="source-code">           rowNumber().over().orderBy(ORDER.REQUIRED_DATE)</pre>
			<pre class="source-code">           .minus(rowNumber().over().partitionBy(ORDER.STATUS)</pre>
			<pre class="source-code">            .orderBy(ORDER.REQUIRED_DATE)))</pre>
			<pre class="source-code">            .from(ORDER)</pre>
			<pre class="source-code">            .asTable("t", "rdate", "status", "cluster"))</pre>
			<pre class="source-code">    .groupBy(field(name("t", "cluster")))</pre>
			<pre class="source-code">    .orderBy(1)</pre>
			<pre class="source-code">    .fetch(); </pre>
			<p>If you <a id="_idIndexMarker1690"/>are not familiar with these kinds of aliases, take your time to inspect the rendered SQL and read some documentation.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor325"/>Aliases and the CASE expression</h2>
			<p>Aliases <a id="_idIndexMarker1691"/>can be used with <strong class="source-inline">CASE</strong> expressions as well. Here is an example:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.SALARY,</pre>
			<pre class="source-code">  count(case_().when(EMPLOYEE.SALARY</pre>
			<pre class="source-code">   .gt(0).and(EMPLOYEE.SALARY.lt(50000)), 1)).as("&lt; 50000"),</pre>
			<pre class="source-code">  count(case_().when(EMPLOYEE.SALARY.gt(50000)</pre>
			<pre class="source-code">   .and(EMPLOYEE.SALARY.lt(100000)), 1)).as("50000 - 100000"),</pre>
			<pre class="source-code">  count(case_().when(EMPLOYEE.SALARY</pre>
			<pre class="source-code">   .gt(100000), 1)).as("&gt; 100000"))</pre>
			<pre class="source-code"> .from(EMPLOYEE)</pre>
			<pre class="source-code"> .groupBy(EMPLOYEE.SALARY)</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>They can also be used in <strong class="source-inline">FILTER WHERE</strong> expressions:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.SALARY,</pre>
			<pre class="source-code">  count().filterWhere(EMPLOYEE.SALARY</pre>
			<pre class="source-code">   .gt(0).and(EMPLOYEE.SALARY.lt(50000))).as("&lt; 50000"),</pre>
			<pre class="source-code">  count().filterWhere(EMPLOYEE.SALARY.gt(50000)</pre>
			<pre class="source-code">   .and(EMPLOYEE.SALARY.lt(100000))).as("50000 - 100000"),</pre>
			<pre class="source-code">  count().filterWhere(EMPLOYEE.SALARY</pre>
			<pre class="source-code">   .gt(100000)).as("&gt; 100000"))               </pre>
			<pre class="source-code"> .from(EMPLOYEE)</pre>
			<pre class="source-code"> .groupBy(EMPLOYEE.SALARY)</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>As you<a id="_idIndexMarker1692"/> can see, using aliases in <strong class="source-inline">CASE</strong>/<strong class="source-inline">FILTER</strong> expressions is quite handy since it allows us to express the meaning of each case better.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor326"/>Aliases and IS NOT NULL</h2>
			<p>Aliases<a id="_idIndexMarker1693"/> can be used with <strong class="source-inline">IS NOT NULL</strong> (and companions) if we wrap our <strong class="source-inline">Condition</strong> in <strong class="source-inline">field()</strong> to obtain a <strong class="source-inline">Field&lt;Boolean&gt;</strong>:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, EMPLOYEE.COMMISSION,</pre>
			<pre class="source-code">           field(EMPLOYEE.COMMISSION.isNotNull()).as("C"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Finally, let's take a quick look at aliases and CTEs.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor327"/>Aliases and CTEs</h2>
			<p>In <a href="B16833_14.xhtml#_idTextAnchor284"><em class="italic">Chapter 14</em></a>, <em class="italic">Derived Tables, CTEs, and Views</em>, we looked at tons of examples of <a id="_idIndexMarker1694"/>using aliases in CTEs and derived tables, so please consider that chapter if you wish to become familiar with this topic. Next, let's talk about SQL templating.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor328"/>SQL templating</h1>
			<p>When we <a id="_idIndexMarker1695"/>talk about SQL templating or the Plain SQL Templating Language, we're talking about covering those cases where the DSL cannot help us express our SQL. The jOOQ DSL strives to cover SQL as much as possible by constantly adding more and more features, but it is normal to still find some corner case syntax or vendor-specific features that won't be covered by the DSL. In such cases, jOOQ allows us to express SQL as plain SQL strings with bind values or query parts via the Plain SQL API.</p>
			<p>The Plain SQL API materializes<a id="_idIndexMarker1696"/> in a set of overloaded methods that can be used where the DSL doesn't help. Here are some examples:</p>
			<pre class="source-code">field/table(String sql)</pre>
			<pre class="source-code">field(String sql, Class&lt;T&gt; type)</pre>
			<pre class="source-code">field(String sql, Class&lt;T&gt; type, Object... bindings)</pre>
			<pre class="source-code">field(String sql, Class&lt;T&gt; type, QueryPart... parts)</pre>
			<pre class="source-code">field/table(String sql, Object... bindings)</pre>
			<pre class="source-code">field(String sql, DataType&lt;T&gt; type)</pre>
			<pre class="source-code">field(String sql, DataType&lt;T&gt; type, Object... bindings)</pre>
			<pre class="source-code">field(String sql, DataType&lt;T&gt; type, QueryPart... parts)</pre>
			<pre class="source-code">field/table(String sql, QueryPart... parts)</pre>
			<pre class="source-code">from/where/join …(String string)</pre>
			<pre class="source-code">from/where/join …(String string, Object... os)</pre>
			<pre class="source-code">from/where/join …(String string, QueryPart... qps)</pre>
			<p>So, we can pass SQL as follows:</p>
			<ul>
				<li>Plain SQL strings</li>
				<li>Plain SQL strings and bindings (?)</li>
				<li>Plain SQL strings and <strong class="source-inline">QueryPart</strong> ({0}, {1}, …)</li>
			</ul>
			<p>Binding <a id="_idIndexMarker1697"/>and the query part argument overloads use the so-called Plain SQL Templating Language. </p>
			<p>Here are several examples of using plain SQL with bind values (these examples are available in <em class="italic">SQLTemplating</em>):</p>
			<pre class="source-code">ctx.fetch("""</pre>
			<pre class="source-code">          SELECT first_name, last_name</pre>
			<pre class="source-code">          FROM employee WHERE salary &gt; ? AND job_title = ?</pre>
			<pre class="source-code">          """, 5000, "Sales Rep");</pre>
			<pre class="source-code">ctx.resultQuery("""</pre>
			<pre class="source-code">           SELECT first_name, last_name</pre>
			<pre class="source-code">           FROM employee WHERE salary &gt; ? AND job_title = ?</pre>
			<pre class="source-code">           """, 5000, "Sales Rep")</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.query("""</pre>
			<pre class="source-code">          UPDATE product SET product.quantity_in_stock = ? </pre>
			<pre class="source-code">          WHERE product.product_id = ?</pre>
			<pre class="source-code">          """, 0, 2)</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.queries(query(""), query(""), query(""))</pre>
			<pre class="source-code">           .executeBatch();</pre>
			<p>Now, let's look <a id="_idIndexMarker1698"/>at some examples to help you become familiar with the technique of mixing plain SQL with SQL expressed via DSL. Let's consider the following MySQL query:</p>
			<pre class="source-code">SELECT `classicmodels`.`office`.`office_code`,</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">       `classicmodels`.`customerdetail`.`customer_number`,</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">FROM `classicmodels`.`office`</pre>
			<pre class="source-code">JOIN `classicmodels`.`customerdetail` </pre>
			<pre class="source-code">ON `classicmodels`.`office`.`postal_code` =   </pre>
			<pre class="source-code">   `classicmodels`.`customerdetail`.`postal_code`</pre>
			<pre class="source-code">WHERE <strong class="bold">not((</strong></pre>
			<pre class="source-code"><strong class="bold">  `classicmodels`.`office`.`city`,   </strong></pre>
			<pre class="source-code"><strong class="bold">  `classicmodels`.`office`.`country`) </strong></pre>
			<pre class="source-code"><strong class="bold">   &lt;=&gt; (`classicmodels`.`customerdetail`.`city`,   </strong></pre>
			<pre class="source-code"><strong class="bold">        `classicmodels`.`customerdetail`.`country`))</strong></pre>
			<p>If you are a jOOQ novice and you're trying to express this query via the jOOQ DSL, then you'll probably encounter some issues in the highlighted code. Can we express that part via the DSL? The answer is yes, but if we cannot find the proper solution, then we can embed it as plain SQL as well. Here is the code:</p>
			<pre class="source-code">ctx.select() </pre>
			<pre class="source-code">   .from(OFFICE) </pre>
			<pre class="source-code">   .innerJoin(CUSTOMERDETAIL) </pre>
			<pre class="source-code">   .on(OFFICE.POSTAL_CODE.eq(CUSTOMERDETAIL.POSTAL_CODE)) </pre>
			<pre class="source-code">   .where("""</pre>
			<pre class="source-code">            not(</pre>
			<pre class="source-code">                 (</pre>
			<pre class="source-code">                   `classicmodels`.`office`.`city`, </pre>
			<pre class="source-code">                   `classicmodels`.`office`.`country`</pre>
			<pre class="source-code">                 ) &lt;=&gt; (</pre>
			<pre class="source-code">                   `classicmodels`.`customerdetail`.`city`, </pre>
			<pre class="source-code">                   `classicmodels`.`customerdetail`.`country`</pre>
			<pre class="source-code">                 )</pre>
			<pre class="source-code">               )</pre>
			<pre class="source-code">          """) </pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Done! Of <a id="_idIndexMarker1699"/>course, once you become more familiar with the jOOQ DSL, you'll be able to express this query 100% via the DSL, and let jOOQ emulate it accordingly (much better!):</p>
			<pre class="source-code">ctx.select() </pre>
			<pre class="source-code">   .from(OFFICE) </pre>
			<pre class="source-code">   .innerJoin(CUSTOMERDETAIL) </pre>
			<pre class="source-code">   .on(OFFICE.POSTAL_CODE.eq(CUSTOMERDETAIL.POSTAL_CODE)) </pre>
			<pre class="source-code">   .where(row(OFFICE.CITY, OFFICE.COUNTRY)</pre>
			<pre class="source-code">   .isDistinctFrom(row(</pre>
			<pre class="source-code">      CUSTOMERDETAIL.CITY, CUSTOMERDETAIL.COUNTRY))) </pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But sometimes, you'll need SQL templating. For instance, MySQL defines a function, <strong class="source-inline">CONCAT_WS(separator, exp1, exp2, exp3,...)</strong>, that adds two or more expressions together with the given separator. This function doesn't have a jOOQ correspondent, so we can use it via SQL templating (here, plain SQL and query parts), as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_NAME,</pre>
			<pre class="source-code">           field("CONCAT_WS({0}, {1}, {2})", </pre>
			<pre class="source-code">                 String.class, val("-"), </pre>
			<pre class="source-code">                 PRODUCT.BUY_PRICE, PRODUCT.MSRP))</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Since the<a id="_idIndexMarker1700"/> number of parts to concatenate can vary, it will be more practical to rely on the convenient <strong class="source-inline">DSL.list(QueryPart...)</strong>, which allows us to define a comma-separated list of query parts in a single template argument:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_NAME,</pre>
			<pre class="source-code">           field("CONCAT_WS({0}, {1})", </pre>
			<pre class="source-code">                 String.class, val("-"), </pre>
			<pre class="source-code">                 list(PRODUCT.BUY_PRICE, PRODUCT.MSRP)))</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, the template argument, <strong class="source-inline">{1}</strong>, has been replaced with the list of strings that should be concatenated. Now, you can simply pass that list.</p>
			<p>The jOOQ DSL also doesn't support MySQL variables (<strong class="source-inline">@variable</strong>). For instance, how would you express the following MySQL query, which uses the <strong class="source-inline">@type</strong> and <strong class="source-inline">@num</strong> variables?</p>
			<pre class="source-code">SELECT `classicmodels`.`employee`.`job_title`,</pre>
			<pre class="source-code">   `classicmodels`.`employee`.`salary`, </pre>
			<pre class="source-code">   @num := if(@type = `classicmodels`.`employee`.</pre>
			<pre class="source-code">              `job_title`, @num + 1, 1) AS `rn`, </pre>
			<pre class="source-code">   @type := `classicmodels`.`employee`.`job_title` AS `dummy`</pre>
			<pre class="source-code">FROM `classicmodels`.`employee`</pre>
			<pre class="source-code">ORDER BY `classicmodels`.`employee`.`job_title`,</pre>
			<pre class="source-code">         `classicmodels`.`employee`.`salary`   </pre>
			<p>Here's SQL templating <a id="_idIndexMarker1701"/>to the rescue:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.JOB_TITLE, EMPLOYEE.SALARY,</pre>
			<pre class="source-code">        field("@num := if(@type = {0}, @num + 1, 1)", </pre>
			<pre class="source-code">        EMPLOYEE.JOB_TITLE).as("rn"),</pre>
			<pre class="source-code">        field("@type := {0}", EMPLOYEE.JOB_TITLE).as("dummy"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.JOB_TITLE, EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can practice these examples, along with others, in <em class="italic">SQLTemplating</em>.</p>
			<p>SQL templating is also useful when we need to work with certain data types, such as the PostgreSQL <strong class="source-inline">HSTORE</strong> data type. We know that jOOQ allows us to define converters and bindings, especially for dealing with such types. In <a href="B16833_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Types, Converters, and Bindings</em>, we wrote an <strong class="source-inline">org.jooq.Converter</strong> and an <strong class="source-inline">org.jooq.Binding</strong> for the <strong class="source-inline">HSTORE</strong> data type. Moreover, the <strong class="source-inline">jooq-postgres-extensions</strong> module supports <strong class="source-inline">HSTORE</strong> as well. </p>
			<p>However, using SQL templating can represent a quick solution as well – for instance, you may only need to write a few queries and you don't have time to write a converter/binding. We can insert this into our <strong class="source-inline">HSTORE</strong> (<strong class="source-inline">PRODUCT.SPECS</strong>) via SQL templating, as follows:</p>
			<pre class="source-code">ctx.insertInto(PRODUCT, PRODUCT.PRODUCT_NAME,   </pre>
			<pre class="source-code">         PRODUCT.PRODUCT_LINE, PRODUCT.CODE, PRODUCT.SPECS)</pre>
			<pre class="source-code">   .values("2002 Masserati Levante", "Classic Cars", </pre>
			<pre class="source-code">           599302L, field("?::hstore", String.class,</pre>
			<pre class="source-code">           HStoreConverter.toString(Map.of("Length (in)",</pre>
			<pre class="source-code">            "197", "Width (in)", "77.5", "Height (in)",</pre>
			<pre class="source-code">            "66.1", "Engine", "Twin Turbo Premium Unleaded </pre>
			<pre class="source-code">             V-6"))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>We can select<a id="_idIndexMarker1702"/> everything from a <strong class="source-inline">HSTORE</strong> like so:</p>
			<pre class="source-code">List&lt;Map&lt;String, String&gt;&gt; specs = </pre>
			<pre class="source-code"> ctx.select(PRODUCT.SPECS.coerce(String.class))</pre>
			<pre class="source-code">    .from(PRODUCT)</pre>
			<pre class="source-code">    .where(PRODUCT.PRODUCT_NAME.eq("2002 Masserati Levante"))</pre>
			<pre class="source-code">    .fetch(rs -&gt; {</pre>
			<pre class="source-code">      return HStoreConverter.fromString(</pre>
			<pre class="source-code">        rs.getValue(PRODUCT.SPECS).toString());</pre>
			<pre class="source-code">    });</pre>
			<p>Notice that both examples rely on <strong class="source-inline">org.postgresql.util.HStoreConverter</strong>.</p>
			<p>Other operations that are performed against an <strong class="source-inline">HSTORE</strong> rely on vendor-specific operators. Using such operators is a perfect job for SQL templating. For instance, getting an <strong class="source-inline">HSTORE</strong> entry by its key can be done by respecting the PostgreSQL syntax, as shown here:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME,</pre>
			<pre class="source-code">           field("{0} -&gt; {1}", String.class, PRODUCT.SPECS, </pre>
			<pre class="source-code">           val("Engine")).as("engine"))</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .where(field("{0} -&gt; {1}", String.class, PRODUCT.SPECS, </pre>
			<pre class="source-code">           val("Length (in)")).eq("197"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Alternatively, we can delete entries by key, as shown here:</p>
			<pre class="source-code">ctx.update(PRODUCT)</pre>
			<pre class="source-code">   .set(PRODUCT.SPECS, (field("delete({0}, {1})",</pre>
			<pre class="source-code">     Record.class, PRODUCT.SPECS, val("Engine"))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>We can also convert an <strong class="source-inline">HSTORE</strong> into JSON:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_NAME,</pre>
			<pre class="source-code">         field("hstore_to_json ({0}) json", PRODUCT.SPECS))</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>More examples <a id="_idIndexMarker1703"/>are available in the bundled code – <em class="italic">SQLTemplating</em> for PostgreSQL. If you need these operators more often, then you should retrieve their SQL templating code in static/utility methods and simply call those methods. For example, a get-by-key method can be expressed as follows:</p>
			<pre class="source-code">public static Field&lt;String&gt; getByKey(</pre>
			<pre class="source-code">         Field&lt;Map&lt;String, String&gt;&gt; hstore, String key) {</pre>
			<pre class="source-code">  return field("{0} -&gt; {1}", String.class, hstore, val(key));</pre>
			<pre class="source-code">}</pre>
			<p>We can also define CTE via SQL templating. Here is an example of defining a CTE via <strong class="source-inline">ResultQuery</strong> and SQL templating:</p>
			<pre class="source-code">Result&lt;Record1&lt;BigDecimal&gt;&gt; msrps = ctx.resultQuery(</pre>
			<pre class="source-code">  "with \"updatedMsrp\" as ({0}) {1}",</pre>
			<pre class="source-code">    update(PRODUCT).set(PRODUCT.MSRP,     </pre>
			<pre class="source-code">      PRODUCT.MSRP.plus(PRODUCT.MSRP.mul(0.25)))</pre>
			<pre class="source-code">      .returning(PRODUCT.MSRP),</pre>
			<pre class="source-code">    select().from(name("updatedMsrp")))</pre>
			<pre class="source-code">   .coerce(PRODUCT.MSRP)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This code <a id="_idIndexMarker1704"/>still uses <strong class="source-inline">ResultQuery</strong> and SQL templating, but this time, the plain SQL looks as follows:</p>
			<pre class="source-code">Result&lt;Record1&lt;BigDecimal&gt;&gt; msrps = ctx.resultQuery(</pre>
			<pre class="source-code">    "with \"updatedMsrp\" as ({0}) {1}",</pre>
			<pre class="source-code">     resultQuery("""</pre>
			<pre class="source-code">                 update </pre>
			<pre class="source-code">                     "public"."product" </pre>
			<pre class="source-code">                 set </pre>
			<pre class="source-code">                     "msrp" = (</pre>
			<pre class="source-code">                       "public"."product"."msrp" + (</pre>
			<pre class="source-code">                       "public"."product"."msrp" * 0.25</pre>
			<pre class="source-code">                      )</pre>
			<pre class="source-code">                 ) returning "public"."product"."msrp"</pre>
			<pre class="source-code">                 """),</pre>
			<pre class="source-code">     resultQuery("""</pre>
			<pre class="source-code">                 select * </pre>
			<pre class="source-code">                 from "updatedMsrp"</pre>
			<pre class="source-code">                 """))</pre>
			<pre class="source-code">    .coerce(PRODUCT.MSRP)</pre>
			<pre class="source-code">    .fetch();</pre>
			<p>More examples are available in <em class="italic">SQLTemplating</em> for PostgreSQL.</p>
			<p>How about calling some SQL Server functions? Let's try to call a function that returns an integer that measures the difference between the <strong class="source-inline">SOUNDEX()</strong> values of two different character expressions. Yes – the <strong class="source-inline">DIFFERENCE()</strong> function:</p>
			<pre class="source-code">ctx.select(field("DIFFERENCE({0}, {1})", </pre>
			<pre class="source-code">           SQLDataType.INTEGER, "Juice", "Jucy"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>How about <a id="_idIndexMarker1705"/>calling the <strong class="source-inline">FORMAT()</strong> function?</p>
			<pre class="source-code">ctx.select(field("FORMAT({0}, {1})", </pre>
			<pre class="source-code">      123456789, "##-##-#####"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Now, let's try the following SQL Server batch, which uses SQL Server local variables:</p>
			<pre class="source-code">DECLARE @var1 VARCHAR(70)</pre>
			<pre class="source-code">select @var1=(select   </pre>
			<pre class="source-code">  [classicmodels].[dbo].[product].[product_name] </pre>
			<pre class="source-code">from [classicmodels].[dbo].[product] </pre>
			<pre class="source-code">where [classicmodels].[dbo].[product].[product_id] = 1)</pre>
			<pre class="source-code">update [classicmodels].[dbo].[product] </pre>
			<pre class="source-code">set [classicmodels].[dbo].[product].[quantity_in_stock] = 0 </pre>
			<pre class="source-code">where [classicmodels].[dbo].[product].[product_name] = @var1</pre>
			<p>Again, combining SQL and SQL templating comes to the rescue:</p>
			<pre class="source-code">ctx.batch(</pre>
			<pre class="source-code">  query("DECLARE @var1 VARCHAR(70)"),</pre>
			<pre class="source-code">  select(field("@var1=({0})", select(PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">   .from(PRODUCT).where(PRODUCT.PRODUCT_ID.eq(1L)))),</pre>
			<pre class="source-code">  update(PRODUCT).set(PRODUCT.QUANTITY_IN_STOCK, 0)</pre>
			<pre class="source-code">   .where(PRODUCT.PRODUCT_NAME</pre>
			<pre class="source-code">      .eq(field("@var1", String.class)))</pre>
			<pre class="source-code">).execute();</pre>
			<p>You can practice<a id="_idIndexMarker1706"/> these examples in <em class="italic">SQLTemplating</em> for SQL Server.</p>
			<p>So far, we've looked at examples that are specific to MySQL, PostgreSQL, and SQL Server. Finally, let's add one for Oracle. For instance, if you plan to update/delete records that are referenced by a <strong class="source-inline">SELECT FOR UPDATE</strong> statement, you can use a <strong class="source-inline">WHERE CURRENT OF </strong>statement. The following example uses SQL templating to build such a SQL sample:</p>
			<pre class="source-code">String sql = ctx.resultQuery("{0} WHERE CURRENT OF cur", </pre>
			<pre class="source-code">   deleteFrom(PRODUCT)).getSQL();</pre>
			<p>The SQL is as follows:</p>
			<pre class="source-code">delete from "CLASSICMODELS"."PRODUCT" WHERE CURRENT OF cur</pre>
			<p>You can practice these examples in <em class="italic">SQLTemplating</em> for Oracle.</p>
			<p>Moreover, especially <a id="_idIndexMarker1707"/>for those corner cases that require complex SQL clauses, jOOQ exposes a set of classes that are very well exemplified in the official documentation: <a href="https://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-queryparts/">https://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-queryparts/</a>.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/>Summary</h1>
			<p>This was a short but comprehensive chapter about jOOQ aliases and SQL templating. In jOOQ, most of the time, you can have a peaceful life without being a power user of these features, but when they come into play, it is nice to understand their basics and exploit them. </p>
			<p>In the next chapter, we'll tackle multitenancy.</p>
		</div>
	</body></html>