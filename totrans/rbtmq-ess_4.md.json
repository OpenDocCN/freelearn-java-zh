["```java\n# Declare a queue for a taxi inbox 1\nqueue1 = channel.queue('taxi-inbox.1', \n  durable: true, \n  arguments:{\n    'x-message-ttl'=> 604800000, \n    'x-dead-letter-exchange'=> 'taxi-dlx', \n    'x-dead-letter-routing-key'=> 'taxi-inbox.1'\n  }\n)\n```", "```java\n$ sudo rabbitmqctl set_policy -p cc-dev-vhost Q_TTL_DLX \"taxi\\.\\d+\" '{\"message-ttl\":604800000, \"dead-letter-exchange\":\"taxi-dlx\"}' \n--apply-to queues\n```", "```java\nqueue1 = channel.queue('taxi-inbox.1', durable: true,\n  arguments: {'x-message-ttl'=> 604800000, 'x-dead-letter-exchange'=> 'taxi-dlx'})\n\nqueue2 = channel.queue('taxi-inbox.2', durable: true,\n  arguments: {'x-message-ttl'=> 604800000, 'x-dead-letter-exchange'=> 'taxi-dlx'})\n```", "```java\nexchange = channel.fanout('taxi-fanout')\n```", "```java\nqueue1.bind(exchange, routing_key: \"\")\nqueue2.bind(exchange, routing_key: \"\")\n```", "```java\ntaxi_dlq = channel.queue('taxi-dlq', durable: true)\n```", "```java\ndlx_exchange = channel.fanout('taxi-dlx')\n```", "```java\ntaxi_dlq.bind(dlx_exchange, routing_key: \"\")\n```", "```java\nexchange.publish(\"Hello! This is an information message!\",   key: \"\")\n```", "```java\n$ sudo rabbitmqctl set_policy \n-p cc-dev-vhost Q_TTL_DLX \"taxi-inbox\\.\\d+ \" '{\"message-ttl\":604800000, \"dead-letter-exchange\":\"taxi-dlx\"}' --apply-to queues\n\nSetting policy \"Q_TTL_DLX\" for pattern \"taxi-inbox\\.\\d+ \" to \"{\\\"message-ttl\\\":604800000, \\\"dead-letter-exchange\\\":\\\"taxi-dlx\\\"}\" with priority \"0\" ...\n...done.\n```", "```java\n#!/bin/bash\n\nqueues_to_purge=`rabbitmqctl list_queues -p cc-dev-vhost name messages_ready consumers | grep \"taxi\\.[[:digit:]]\\+[[:space:]]\\+[1-9][[:digit:]]*[[:space:]]\\+0\" | awk '{ print $1}'`\n\nfor queue in $queues_to_purge ; do\n    echo -n \"Purging $queue ... \"\n    rabbitmqadmin -V cc-dev-vhost -u cc-admin -p taxi123 purge queue name=$queue\ndone\n```", "```java\nDELAYED_QUEUE='work.later'\nDESTINATION_QUEUE='work.now'\n```", "```java\ndef publish\n  channel = connection.create_channel\n\n  channel.queue(DELAYED_QUEUE, arguments: {\n    'x-dead-letter-exchange' => '', \n    'x-dead-letter-routing-key' => DESTINATION_QUEUE,\n    'x-message-ttl' => 300000\n  })\n\n  channel.default_exchange.publish 'message content', routing_key: DELAYED_QUEUE\n    puts \"#{Time.now}: Published the message\"\n    channel.close\nend\n```", "```java\ndef subscribe\n  channel = connection.create_channel\n  q = channel.queue DESTINATION_QUEUE, durable: true\n  q.subscribe do |delivery, headers, body|\n    puts \"#{Time.now}: Got the message\"\n  end\nend\n```", "```java\nsubscribe()\npublish()\n```", "```java\nrequire \"bunny\"\n connection = Bunny.new ENV[\"RABBITMQ_URI\"]\n\n connection.start\n channel = connection.create_channel\n```", "```java\nexchange = channel.default_exchange\n```", "```java\nexchange.on_return do |return_info, properties, content|\n  puts \"A returned message!\"\nend\n```", "```java\nqueue = channel.queue(\"taxi-inbox.100\", durable: true)\n```", "```java\nqueue.subscribe do |delivery_info, properties, content|\n  puts \"A message is consumed.\"\nend\n```", "```java\nexchange.publish(\"A message published to a queue that does exist, it should NOT be returned\", :mandatory => true, :routing_key => queue.name)\n```", "```java\nexchange.publish(\"A message published to a queue that does not exist, it should be returned\", :mandatory => true, :routing_key => \"random-key\")\n```", "```java\nconnection.close\n```"]