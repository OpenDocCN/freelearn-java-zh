- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Spring Boot Applications with OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Open Authorization 2.0** (**OAuth 2.0**) is an open standard protocol that
    provides secure authorization for web and mobile applications. It allows users
    to grant limited access to their resources on one website (called the “resource
    server”) to another website or application (called the “client”) without sharing
    their credentials, such as usernames and passwords. This means that the resource
    server will never see a user’s credentials. OAuth 2.0 is widely used for enabling
    **single sign-on** (**SSO**), accessing third-party APIs, and implementing secure
    authorization mechanisms. SSO allows a user to log in to any of several related,
    yet independent, applications with a single ID. Once logged in to an application,
    the user is not required to reenter the credentials to access the rest of the
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenID Connect** (**OIDC**) is an open standard for user authentication that’s
    built on top of OAuth 2.0\. It’s used with OAuth 2.0 to enable secure access to
    user data. An example of this is when an application allows you to sign in with
    your Google Account. Usually, they can request access to certain parts of your
    Google Account profile or permissions to interact with your account on your behalf.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to deploy a basic Spring Authorization Server
    that we’ll be using in most of the recipes in this book. Then, we’ll learn about
    the most common scenarios to protect an application, from a RESTful API to a web
    application. Finally, we’ll apply the same concepts but using two popular cloud
    solutions: Google Accounts for user authentication and Azure AD B2C for an extensible
    end-to-end authentication experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot offers great support for OAuth2 and OIDC, regardless of the Identity/Authorization
    server used. It manages the standard OAuth2/OpenID concepts that are implemented
    by all vendors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Authorization Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting a RESTful API using OAuth2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting a RESTful API using OAuth2 with different scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an MVC application with OpenID authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in with Google Accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating a RESTful API with a cloud **identity** **provider** (**IdP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has the same technical requirements as [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
    So, we will need an editor such as Visual Studio Code or IntelliJ, Java OpenJDK
    21 or higher, and a tool to perform HTTP requests, such as `curl` or Postman.
  prefs: []
  type: TYPE_NORMAL
- en: For some scenarios, you will need a Redis server. The easiest way to run a Redis
    server locally is by using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: For the *Logging in with Google Accounts* recipe, you will need a Google Account.
  prefs: []
  type: TYPE_NORMAL
- en: For the *Integrating a RESTful API with a cloud IdP* recipe, I used Azure Entra
    (formerly known as Azure Active Directory) as an authentication provider. You
    can create a free account with 200 USD credit at [https://azure.microsoft.com/free/search](https://azure.microsoft.com/free/search)/.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Authorization Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Authorization Server is a project under the umbrella of Spring Framework
    that provides the components you need to create an Authorization Server. In this
    recipe, you will deploy a very simple Authorization Server that you will use for
    most of the recipes in this chapter. In the following recipes, you will continue
    to customize this server to achieve the goals of each exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration of this server is just for demo purposes. The Authorization
    Server plays a crucial role in managing and granting access to protected resources.
    If you plan to use it in production, I recommend following the instructions from
    the project at [https://docs.spring.io/spring-authorization-server/reference/overview.html](https://docs.spring.io/spring-authorization-server/reference/overview.html).
    In any case, the principles that we will explain in this book have been adjusted
    to the OAuth2 specification and well-known practices. For this reason, you will
    be able to apply what you learn here to any other Authorization Server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the Spring Authorization Server, we will use Spring Initializr. You
    can open this tool in your browser using [https://start.spring.io/](https://start.spring.io/)
    or use it in your code editor if it’s been integrated.
  prefs: []
  type: TYPE_NORMAL
- en: I assume that you have basic knowledge of OAuth2\. However, I have added some
    links in the *See also* section that can be useful if you need to go through some
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a Spring Authorization Server using Spring Initializr
    and do a very basic configuration to create an application registration. Finally,
    we’ll test the application registration and analyze the results. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io), as you did in the
    *Creating a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    and use the same parameters, except change the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `footballauth`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For **Dependencies**, select **OAuth2** **Authorization Server**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.1: Spring Initializr options for Spring Authorization Server](img/B21646_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Spring Initializr options for Spring Authorization Server'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **GENERATE** button to download the project, then unzip the content
    to your working folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to configure the authorization server. For that, we will create
    an `application.yml` file in the `resources` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We just defined an application that can be authenticated using the client credential
    flow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can execute your Authorization Server. You can retrieve the configuration
    of our server by making a request to http://localhost:9000/.well-known/openid-configuration.
    As the path indicates, this is a well-known endpoint that all OAuth2-compliant
    vendors implement to expose the relevant configuration for client applications.
    Most of the client libraries can configure themselves just from this endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To verify that it works, we can execute the authentication of our client. You
    can do this by executing the following `POST` request via `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a response that looks similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can copy the value of the `access_token` field, open [https://jwt.ms](https://jwt.ms)
    in your browser, and paste the value there. In the **Decoded Token** tab, you
    can see the token in its decoded form, while if you click on the **Claims** tab,
    you can see an explanation of each field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2: JWT token decoded in jwt.ms](img/B21646_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: JWT token decoded in jwt.ms'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – you’ve deployed a Spring Authorization Server and successfully
    configured an application for authorization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring OAuth2 Authorization Server contains all the components you need to
    create an authorization server. With the configuration provided in `application.yml`,
    it created an application with a `client-id` value of `basic-client`. Let’s look
    at the parameters that were used for the application and see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: The `client-id` is the identifier of the application we create d. In this case,
    it is `football`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `client-secret` is the secret of the application. By using the `{noop}`
    prefix in the secret, we tell Spring Security that the password is not encrypted
    and can be used as-is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `client-authentication-methods` is used to specify how this application
    can authenticate. By using the `client_secret_post` method, we can ensure that
    the client ID and secret will be sent in a `POST` request. We could configure
    additional methods, such as `client_secret_basic`, in which case the client ID
    and secret will be sent as HTTP basic schema – that is, in the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `authorization-grant-types`, we specify what grant flows are allowed
    for this application. By setting `client_credentials`, we are configuring an application
    that won’t have a user interface, such as a background server application. If
    you have an application that will interact with users, you could configure other
    options, such as `authorization_code`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, with the `scopes`, we are configuring the scopes that are allowed for
    this application. In this case, it is just the `football:read` scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring OAuth2 Authorization Server keeps this configuration in memory. As you
    may have guessed, this is just for demonstration and development purposes. In
    a production environment, you will need to persist this data. Spring OAuth2 Authorization
    Server provides support for JPA repositories.
  prefs: []
  type: TYPE_NORMAL
- en: We used **JWT MS** ([https://jwt.ms](https://jwt.ms)) to inspect the access
    token that was issued by our authorization server. This tool just decodes the
    token and describes the standard fields. There is another popular tool named **JWT
    IO** ([https://jwt.io](https://jwt.io)) that also allows you to validate the token,
    but it doesn’t explain each field.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can follow the instructions from the Spring OAuth2 Authorization Server
    project to implement the core services with JPA: [https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html](https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use any relational database supported by Spring Data JPA, such as PostgreSQL,
    which we used in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll manage many OAuth2 concepts, something that can be difficult
    to understand if you don’t have previous knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, it is very important to understand the different token types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`access_token`: This contains all authorization information granted by the
    authorization server that the resource server will verify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id_token`: This token is used for session management, normally in client applications,
    to customize the user interface, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh_token`: This token is used to get new `access_tokens` and `id_tokens`
    when they are about to expire. `refresh_token` is considered a secret as its lifetime
    is larger than the others and can be used not only to get fresher tokens for the
    already authorized applications but also for new ones. It is important to protect
    this token accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I strongly recommend getting familiar with the basic OAuth2 flows and their
    main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client** **credential flow**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the simplest flow and was used in this recipe. It is intended for applications
    without user interaction – for instance, for server applications communicating
    with other applications. They can be authenticated in different ways, such as
    with a secret, as seen in this recipe, a certificate, or other more sophisticated
    techniques.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Authorization code** **grant flow**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is intended to authenticate web and mobile applications. This is the two-leg
    authentication flow, where the user authenticates and allows the application to
    access the requested scopes. Then, the authentication endpoint issues a short-lived
    piece of code that should be redeemed in the token endpoint to get an access token.
    After, the application (not the user) should be authenticated. There are two variants
    of this flow, depending on how it authenticates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a client ID and a secret. This is intended for confidential applications,
    such as those that can keep secrets. This includes server applications.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a client ID and a challenge, also known as **Proof Key Challenge Exchange**
    (**PKCE**). This is intended for public applications, such as those that cannot
    keep a secret, such as mobile applications, or applications that just live in
    the browser, such as **single-page** **applications** (**SPAs**).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh_token`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more flows, but these are the basic ones that will be used in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting a RESTful API using OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protecting a resource – in this case, a RESTful API – is the core functionality
    of OAuth. In OAuth2, a resource server delegates authorization to access a third-party
    server – that is, the authorization server. In this recipe, you’ll learn how to
    configure a RESTful API application so that it can authorize the requests that
    are issued by your Spring Authorization Server.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue with our samples for football data management. You will protect
    your Football API by only allowing clients who have been granted access by our
    Authorization Server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will reuse the Authorization Server you created in the *Setting
    up Spring Authorization Server* recipe. If you haven’t completed that yet, you
    can use the authorization server that I’ve prepared. You can find it in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-2/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you will create a new RESTful API and configure it as a *resource
    server* using the client registration you created in the previous recipe. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a RESTful API using Spring Initializr ([https://start.spring.io](https://start.spring.io)).
    Use the same options that you did in the *Creating a RESTful API* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), except change the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `footballresource`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For **Dependencies**, select **Spring Web** and **Oauth2** **Resource Server**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.3: Spring Initializr options for a protected RESTful API](img/B21646_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Spring Initializr options for a protected RESTful API'
  prefs: []
  type: TYPE_NORMAL
- en: Click **GENERATE** to download a ZIP file that contains your project template.
    Unzip it in your working folder and open it in your code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a simple REST controller with a method that returns a list of
    teams. For that, create a class named `Football.java` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s configure our application for authorization by using the Authorization
    Server we created in the previous recipe. For that, create an `application.yml`
    file in the `resources` folder with the following content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to get an access token from our Authorization Server first. For that,
    you can execute the following request using `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.4: Access token issued by the Authorization Server](img/B21646_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Access token issued by the Authorization Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the access token value and use it in the next request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now have our RESTful API that’s protected by the tokens that were issued
    by the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this simplified example, you saw how authorization works in OAuth2\. There’s
    an authorization server issuing a token with authorization information. A resource
    server – our RESTful API – then checks the token’s validity and applies the provided
    configuration. The authorization server can issue the token in different formats,
    but the most common is via `.`) signs:'
  prefs: []
  type: TYPE_NORMAL
- en: The header contains the metadata needed to manage the token. It is encoded in
    base64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The payload contains the actual data and claims about the token. It carries
    information such as the expiration time, issuer, and custom claims. It is encoded
    in base64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature is created by taking the encoded header and encoded payload, along
    with a secret, and signing them using the signing algorithm specified in the header.
    The signature is used to verify the *authenticity* and *integrity* of the token
    so that we can ensure the token was issued by the authorization server and was
    not modified by anyone else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource needs to validate the authenticity and integrity of the token.
    For that, it needs to verify the signature. The Authorization Server provides
    an endpoint to download the public key of the certificate being used to sign the
    token. So, the first thing that the authorization server needs to know is where
    that endpoint is. We can configure this manually in the `application.yml` file,
    but luckily, Spring Resource Server knows how to retrieve all the information
    about the authorization server automatically. Just by configuring the `issuer-uri`
    property, it knows how to retrieve the rest of the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all authorization servers in the market can provide the well-known `OpenId`
    endpoint if we add the following path to the issuer URI: `.well-known/openid-configuration`.
    The first time the resource server needs to validate a JWT, it calls that endpoint
    – in our case, http://localhost:9000/.well-known/openid-configuration – and retrieves
    all the information it needs, such as the authorization and token endpoint, the
    **JSON Web Key Set** (**JWKS**) endpoint, which contains the sign-in key, and
    so on. JWKSs are the public keys that the authorization server can use to sign
    a token. The clients can download these keys to validate the signature of the
    JWT.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how the resource server validates that the token has been
    issued by the authorization server, we need to know how we can validate that the
    token is intended for our RESTful APIs. In the `application.yml` file, we’ve configured
    the `audiences` field. This indicates the entity for which the token is valid
    and who or what the token is intended for. The `aud` claim helps ensure that a
    JWT is only accepted by the intended recipient or resource server. The `aud` claim
    is part of the payload of the JWT. In our case, the payload, after decoding the
    base64, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just by setting `issuer-uri` and `audiences`, we ensure that only JWT issued
    by our Authorization Server and those that are intended for our application/audience
    will be accepted. Spring Resource Server performs other standard checks, such
    as for the expiration time (the `exp` claim) and not valid before (the `nbf` claim).
    Anything else will be rejected with an `HTTP 401 Unauthorized` error. In the *Protecting
    a RESTful API using OAuth2 with different scopes* recipe, we’ll learn how to use
    other claims to enhance protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that from a Spring Resource Server perspective, it’s
    not important how the client obtained the access token as that responsibility
    is delegated to the Authorization Server. The Authorization Server may require
    different levels of validations, depending on the kind of resource being accessed.
    Some examples of validations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Client ID and secret, as shown in this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple factors of authentication. For applications with user interaction,
    the authorization server may consider that the username and password are not enough
    and force using a second factor of authentication, such as an authentication application,
    a certificate, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an application tries to access specific scopes, it may require explicit consent.
    We see this often with social networks when a third-party application needs to
    access certain parts of our profile or tries to perform special actions, such
    as publishing on our behalf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting a RESTful API using OAuth2 with different scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we learned how to protect our application. In this
    recipe, we’ll learn how to apply more fine-grained security. We need to apply
    different levels of access to the application: one general form of read access
    for the consumers of our RESTful API and administrative access so that we can
    make changes to the data.'
  prefs: []
  type: TYPE_NORMAL
- en: To apply different levels of access to the API, we’ll use the standard OAuth2
    concept of *scopes*. In OAuth 2.0, `scope` is a parameter that’s used to specify
    the level of access and permissions that a client application is requesting from
    the user and the authorization server. It defines what actions or resources the
    client application is allowed to perform on behalf of the user. Scopes help ensure
    that users have control over which parts of their data and resources they grant
    access to, and they allow for fine-grained access control. In applications with
    user interaction, granting a scope may imply explicit consent from the user. For
    applications with no user interaction, it can be configured with administrative
    consent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our football application, you will create two access levels: one for read-only
    access and another for administrative access.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll reuse the Authentication Server from the *Setting up Spring
    Authorization Server* recipe and the resource server we created in the *Protecting
    a RESTful API using OAuth2* recipe. If you haven’t completed these recipes yet,
    you can find a working version in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-3/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create the `football:read` and `football:admin` scopes in the Authorization
    Server and apply the configuration for managing them in the resource server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you should do is ensure that the scopes are defined in the
    authorization server. For that, go to the `application.yml` file in the `resources`
    folder of the project you created in the *Setting up Spring Authorization Server*
    recipe. If you’re using the implementation I provided, as explained in the *Getting
    ready* section of that recipe, you can find the project in the `footballauth`
    folder. Ensure that the application mentions the `football:read` and `football:admin`
    scopes. The application configuration in the `application.yml` file should look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@PostMapping("/teams")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public String addTeam(@RequestBody String teamName){
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return teamName + " added";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, configure the resource server so that it can manage the scopes. For that,
    create a configuration class that exposes a `SecurityFilterChain` bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that as part of `SecurityFilterChain`, we defined a couple of `requestMatchers`
    with `HttpMethod`, the request path, and the required authority using both scopes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the required configuration, let’s run the application and
    perform some tests to validate its behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, get an access token from the authorization server, requesting just the
    `football:read` scope. You can execute the request by running the following `curl`
    command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'curl -H "Authorization: Bearer <access_token>" -H "Content-Type: application/text"
    --request POST --data ''Senegal'' http://localhost:8080/football/teams -v'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A note on curl
  prefs: []
  type: TYPE_NORMAL
- en: Note that we’re starting to use the `-v` parameter. It provides a verbose response
    so that we can see the reasons something fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will return an HTTP 403 forbidden error, and the details will look as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s retrieve another access token with the appropriate scopes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can request more than one scope at a time.
  prefs: []
  type: TYPE_NORMAL
- en: If we execute the request to create a team with the new access token, we’ll
    see that it works as expected and will return something like `Senegal added`.
  prefs: []
  type: TYPE_NORMAL
- en: With that, our application is protected and we’ve applied different levels of
    protection to our resource server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SecurityFilterChain` bean is a component that’s used for configuring the
    security filters that intercept and process incoming HTTP requests. Here, we created
    a `SecurityFilterChain` bean that looks for two matching patterns: `GET` requests
    that match the `/football/teams/**` path pattern and `POST` requests that match
    the same path pattern. `GET` requests should have the `SCOPE_football:read` authority
    and `POST` should have the `SCOPE_football:admin` authority. Once you configure
    `SecurityFilterChain`, it is applied to all incoming HTTP requests. Then, if a
    request matching the pattern doesn’t have the required scope, it will raise an
    `HTTP 403` `forbidden` response.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is `SCOPE_ prefix` used? It is created by the default `JwtAuthenticationConverter`.
    This component transforms the JWT into an `Authentication` object. The default
    `JwtAuthenticationConverter` is wired by Spring Security, but you can also register
    your own converter if you want a different behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More validations can be performed on JWT. For instance, a common way of validating
    a request is by checking its roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can validate a request’s roles by registering a `SecurityFilterChain` bean.
    Let’s say you have an administrator role defined in your Authorization Server.
    Here, you can configure a `SecurityFilterChain` bean in the resource server to
    ensure that only users with the `ADMIN` role can perform `POST` requests on `football/teams
    path`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make other checks to validate your token. In this case, you can use
    `OAuth2TokenValidator`. For instance, you may want to validate that a given claim
    is present in your JWT. For that, you can create a class that implements `OAuth2TokenValidator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I recommend that you look at the Spring OAuth2 Resource Server project documentation
    at [https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an MVC application with OpenID authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to create a new web application for our football fans. To do so, we
    must authenticate the users when they’re accessing the application. We’ll use
    access tokens to access the protected RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to use Spring OAuth2 Client to protect an MVC
    web application and get access tokens for other protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to use an SPA, you will need to look for OpenID-certified libraries
    for your target environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will reuse the Authorization Server application you created
    in the *Setting up Spring Authorization Server* recipe and the application you
    created in the *Protecting a RESTful API using OAuth2 with different scopes* recipe.
    I’ve prepared a working version of both projects in case you haven’t completed
    them yet. You can find them in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-4/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The authentication process involves some redirections and requires managing
    sessions for the protected application. We’ll use Redis to maintain the sessions
    for the application. You can download Redis and execute it on your computer, but
    as we did for other recipes, you can deploy Redis on Docker. For that, just execute
    the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command will download the Redis community image if it is not yet present
    on your computer and will start the Redis server so that it’s listening on port
    `6379` without any credentials. In a production environment, you probably want
    to secure this service, but in this recipe, we’ll keep it open for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you’ll create a new web application and integrate it with the
    existing authorization server and the RESTful API you created in previous recipes.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll need to create the client registration in the Authorization Server.
    For that, open the `application.yml` file in the `resources` folder of the Authorization
    Server – that is, the project you created in the *Setting up Spring Authorization
    Server* recipe. Add the new client registration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we want to authenticate users, you will need to create at least one user.
    To do that, in the same `application.yml` file in the Authorization Server, add
    the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `user` element should be aligned with the `oauth2` element. Remember that
    the indentation in `.yml` files is very important. You can change the username
    and password and set the values you wish.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Keep this configuration as you’ll use it later in the web application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s create a new Spring Boot application for our web application. You
    can use *Spring Initializr*, as you did in the *Creating a RESTful API* recipe
    in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), but change the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `footballui`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For **Dependencies**, select **Spring Web**, **Thymeleaf**, **Spring Session**,
    **Spring Data Redis (Access+Driver)**, **OAuth2 Client**, and **OAuth2 Security**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.5: Spring Initializr options for the web application](img/B21646_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Spring Initializr options for the web application'
  prefs: []
  type: TYPE_NORMAL
- en: Click **GENERATE** to download the project template as a ZIP file. Unzip the
    file in your development folder and open it in your preferred code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a known incompatibility between `org.thymeleaf.extras: thymeleaf-extras-springsecurity6`.
    For that, open the project’s `pom.xml` file and add the following dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s start by creating our web pages. Since we’re following the `Controller`
    class, which will populate a model and then be presented in the view. The view
    is rendered using the Thymeleaf template engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, create the `Controller` class and name it `FootballController` while
    providing a simple method for the home page:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns the name of the view. Now, we need to create the view.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the view, we should create a new template for Thymeleaf. The default template
    location is the `resources/template` folder. In the same folder, create a file
    named `home.html` with the following content:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a very basic page, but it now contains a link that we want to protect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we must configure the application so that it can be authenticated using
    the Authorization Server and force it to be authenticated for all pages except
    for the home page we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To integrate the web application with the Authorization Server, open the `application.yml`
    file in the `resources` folder and configure the OAuth2 client application, as
    follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, you’ve protected all pages, except the root. So, let’s
    create the rest of the pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a page to show the user information. To do that, in
    the same `FootballController` controller, create a new method, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are asking Spring Boot to inject `OidcUser` as a method parameter and
    we are creating a model that we’ll use in the view named `myself`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a file named `myself.html` in the `resources/templates` folder.
    Put the following content in `<body>` to show the `Model` data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there is a link to `/teams`. This link will open a new page
    showing the teams. The teams page retrieves data from the RESTful API you created
    in the *Protecting a RESTful API using OAuth2 with different* *scopes* recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a new method in `FootballController` so that we can get the teams.
    For that, you will get an access token by using the Spring Boot OAuth2 client:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need to pass the access token in the `Authorization` header, with the `Bearer`
    string as a prefix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To allow the web application to use the RESTful API, you’ll need to include
    `football-ui`, the web application audience, as an accepted audience. For that,
    in the project you created in the *Protecting a RESTful API using OAuth2 with
    different scopes* recipe, open the `application.yml` file in the `resources` folder
    and add `football-ui` to the `audiences` property. The `application.yml` file
    should look like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is still an important detail we must cover before we start the new application:
    we need to configure Redis. The only settings that are required for it are `hostname`
    and `port`. For that, open the `application.yml` file of the `football-ui` project
    again and set the following configuration:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last setting to configure is the application port. The resource server
    is already using port `8080`. To avoid port conflicts, we need to change the port
    of the `football-ui` project. For that, in the same `application.yml` file, add
    the following setting:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can set any port that is not being used yet. Keep in mind that it’s part
    of the configuration in the Authorization Server. If you modify the port, you
    will need to modify the configuration in the authorization server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you can run the application. Go to http://localhost:9080 in your browser:![Figure
    2.6: The application’s home page](img/B21646_02_6.jpg)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2.6: The application’s home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you will see the home page, which is the only route that is not protected.
    If you click on the **who you are** link, you will be redirected to the login
    page in the Authorization Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Login page in the authorization server](img/B21646_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Login page in the authorization server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the username and password you configured in *Step 2* and click on the
    **Sign in** button. You’ll be redirected to the consent page, where you should
    permit the scopes being requested by the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Consent page in the authorization server](img/B21646_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Consent page in the authorization server'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Submit Consent**; you will be redirected to the application. The OAuth
    client application will complete the process by redeeming the access code generated
    by the authentication endpoint to obtain the ID token, access token, and refresh
    token. This part of the process is transparent for you as it’s managed by the
    OAuth2 client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it’s done this, you’ll be returned to the application on the page you
    created to show the user authentication data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Application page with user OpenID data](img/B21646_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Application page with user OpenID data'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the `teams` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: The application page showing the data from the RESTful API](img/B21646_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: The application page showing the data from the RESTful API'
  prefs: []
  type: TYPE_NORMAL
- en: With that, your web application is protected by OpenID and it can call another
    OAuth2-protected resource.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you protected your web application by using OIDC. It is an
    authentication protocol that is an extension of OAuth 2.0\. It provides a standardized
    way for users to log in to web applications or mobile apps using their existing
    accounts with IdPs. In our exercise, we used the Authorization Server as an IdP
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OIDC server normally provides a discovery endpoint at `.well-known/openid-configuration`.
    If this is not provided, then it was likely hidden intentionally by the administrator.
    That endpoint provides all the information the client applications need to authenticate.
    In our application, we used the *authorization code grant flow*. It involves several
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the client application redirects the user for authentication, requesting
    the required scopes for application usage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the user is authenticated. Depending on the features provided by the authorization
    server, it could use sophisticated mechanisms to validate the user, such as certificates,
    multiple authentication factors, or even biometric features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user is authenticated, the authorization server may ask the user for
    consent or not, depending on the scopes requested by the client application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once authenticated, the Authorization Server will redirect the user to the
    client application, providing a short-lived authorization code. Then, the client
    application will redeem the authorization code on the token endpoint (provided
    by the discovery endpoint). The authorization server will return the tokens with
    the scopes that have been consented to. The scopes that have not been consented
    by the user won’t be present in the issued tokens. The following tokens are returned
    by the authorization server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An ID token containing the session information. This token should not be used
    for authorization, just for authentication purposes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An access token, which contains the authorization information, such as the scopes
    that have been consented. If the application requires a scope, it should validate
    the scopes returned and manage them accordingly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A refresh token, which is used to get new tokens before they expire.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since many redirects are involved in this process, the client application needs
    to keep the state of the user, hence the requirement for session management. The
    Spring Framework provides a convenient way to manage sessions using Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the client application needs to access the discovery endpoint
    when it starts. For that reason, remember to start your authorization server before
    the client application.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you configured the root page as the only permitted page without
    authentication. To access any other page, it must be authenticated. For that reason,
    just by trying to navigate to `/myself` or `/teams`, the authorization process
    is initiated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many modern applications are SPA. This type of application runs mostly in the
    browser. Also, note that many libraries implement OIDC. I recommend using an OpenID-certified
    library as they are validated by peers.
  prefs: []
  type: TYPE_NORMAL
- en: Even with the growing popularity of SPA, I haven’t explained the authentication
    of this type of application as it is not related to Spring Boot. However, if you
    are interested in integrating an SPA with Spring Authorization Server, I recommend
    following the guidelines from the Spring OAuth2 Authorization Server project at
    https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-pkce.html.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in with Google Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have a new requirement for your football application: your users want to
    log in to your application using their Gmail accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: To implement this scenario, you will configure your Authorization Server as
    an OAuth2 client, with Google Accounts being their IdP. You will learn how to
    create an OAuth2 Client ID in Google Cloud and integrate it into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will reuse the Spring Authorization Server you created
    in the *Setting up Spring Authorization Server* and *Protecting a RESTful API
    using OAuth2 with different scopes* recipes, as well as the web application you
    created in the *Configuring an MVC application with OpenID authentication* recipe.
    The MVC application stores sessions in Redis. You can run a Redis server in Docker,
    as explained in the *Configuring an MVC application with OpenID* *authentication*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve prepared a working version of the required recipes in case you haven’t
    completed them yet. You can find them in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-5/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: As you will integrate the application with Google Accounts, you will need a
    Google Account. If you don’t have a Google Account yet, you can create one at
    [https://accounts.google.com](https://accounts.google.com).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating an OAuth2 client in Google and then use the configuration
    provided to configure our Authorization Server so that it can log in to your application
    using GoogleAaccounts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the Google Cloud console at [https://console.cloud.google.com/](https://console.cloud.google.com/).
    You will need to log in using your Google Account. Once you’ve done this, you
    will see the Google Cloud home page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, you’ll need to create a project:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11: The Google Cloud home page](img/B21646_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: The Google Cloud home page'
  prefs: []
  type: TYPE_NORMAL
- en: To create the project, click **Select** **a project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Select a project** dialogue, click **NEW PROJECT**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12: Creating a new project](img/B21646_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Creating a new project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the project – for instance, `springboot3-cookbook`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13: New Project settings](img/B21646_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: New Project settings'
  prefs: []
  type: TYPE_NORMAL
- en: Click **CREATE**. This process will take a few moments. A notification will
    appear when it is completed. Once created, select the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a project, let’s configure the consent page for our web application.
    For that, open the **APIs & Services** menu and choose **Credentials**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14: The Credentials menu](img/B21646_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: The Credentials menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **Credentials** page, you will see a reminder to create the consent
    page for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: The Credentials home page with a reminder to configure the OAuth
    consent screen highlighted](img/B21646_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: The Credentials home page with a reminder to configure the OAuth
    consent screen highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **CONFIGURE CONSENT SCREEN** button and follow the instructions
    to configure the consent page. For **User Type**, select **External** and click
    **CREATE**.
  prefs: []
  type: TYPE_NORMAL
- en: With this type of user, the application will start in testing mode. This means
    that only some test users will be able to use it. Once you’ve completed the development
    process and the application is ready, you can publish it. To do this, your site
    must be verified. We won’t publish the application in this recipe, but if you
    plan to use it in your application, you’ll need to complete this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting **External** for **User Type**, there is a four-step process
    you must go through:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the **OAuth** **consent** screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, you should configure the application’s name. You can set it as **Spring
    Boot 3 Cookbook**, for instance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You should configure a user support email. You can use the same email address
    that you use for your Google Account.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You should also configure the Developer Contact Information email. Again, you
    can use the same email address that you use for your Google Account.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the parameters are optional. We don’t need to configure them for
    now.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For **Update selected scopes**, click **ADD OR REMOVE SCOPES** and select **openid**,
    **userinfo.email**, and **userinfo.profile**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16: Selecting scopes](img/B21646_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Selecting scopes'
  prefs: []
  type: TYPE_NORMAL
- en: Then, click **UPDATE**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **test users** step, click **ADD USERS** to add some testing users who will
    be able to access the application before it’s published. You can add a different
    Google Account to test the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **summary** step, you will see a summary of your consent screen. You
    can click **BACK TO DASHBOARD** to return to the **OAuth consent** **screen**
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create the client credentials. For that, once again, navigate
    to the **Credentials** page, as shown in *Figure 2**.17*. Once you are on the
    **Credentials** page, click **+ CREATE CREDENTIALS** and select **OAuth** **client
    ID**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.17: Selecting OAuth client ID credentials](img/B21646_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Selecting OAuth client ID credentials'
  prefs: []
  type: TYPE_NORMAL
- en: For **Application type**, select **Web application**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `football-gmail`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For **Authorized redirect URIs**, add http://localhost:9000/login/oauth2/code/football-gmail:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.18: Creating an OAuth client ID](img/B21646_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Creating an OAuth client ID'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **CREATE**. A dialogue box will appear, informing you that the client
    was created and showing you the **Client ID** and **Client secret** details. We’ll
    need this data to configure the Authorization Server, so keep it safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19: OAuth client created](img/B21646_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: OAuth client created'
  prefs: []
  type: TYPE_NORMAL
- en: There is a button to download a JSON file containing the configuration. Click
    on it and save the JSON file in a secure place as it contains the credentials
    that are required to use the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can configure the Spring OAuth2 Authorization Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to add the OAuth2 client dependency. For that, open the `pom.xml`
    file and add the following dependency:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the `application.yml` file in the `resources` folder and add the
    client configuration for Google:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace the `client-id` and `client-secret` fields with the values you obtained
    in *Step 2*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step to configure the Authorization Server is defining the behavior
    of the security checks. For that, create a configuration class named `SecurityConfig`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a `SecurityFilterChain` bean:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code configures Spring Security to use OAuth 2.0 and OpenID Connect
    1.0 for authentication, as well as to accept JWT access tokens for certain requests.
    For instance, it will accept requests that provide JWT access tokens to get user
    information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will also need to add another `SecurityFilterChain` bean but with less
    priority. It will initiate the OAuth2 login process, which means it will initiate
    the authentication as a client application in Google, as configured in the `application.yml`
    file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code configures Spring Security to require authentications for
    all requests and to use OAuth 2.0 for logging in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With that, your OAuth2 Authorization Server has been configured to require
    authentication using Google Accounts. Now, you can run all your environments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Authorization Server you just configured
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the RESTful API server you created in the *Protecting a RESTful API using
    OAuth2 with different* *scopes* recipe
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the web application you created in the *Configuring an MVC application with
    OpenID* *authentication* recipe
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you navigate to `http://localhost:9080/myself`, you will be asked to log
    in using a Google Account:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.20: Logging in using a Google Account](img/B21646_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: Logging in using a Google Account'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve logged in, you will see that the application is the same. You can
    now use the claims issued by the Authorization Server and invoke the RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we’re using the Authorization Server with just the login delegated in
    Google, the Authorization Server doesn’t need to maintain a user repository, though
    it still has the responsibility of issuing tokens. This means that when the application
    requests to identify a user, the Authorization Server redirects the login to Google.
    Once back, the Authorization Server continues issuing tokens. Due to this, you
    didn’t need to change the code in the MVC web application or the RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to configure the MVC application so that it bypasses the authorization
    server and logs in to Google Accounts directly. You just need to replace the OAuth2
    client configuration in the MVC web application with the client configuration
    you used in the Authorization server. However, in that case, you won’t be able
    to use the access tokens that have been issued by Google to protect your RESTful
    API. This is because Google access tokens are intended to be used with Google
    services only and they are not standard JWT.
  prefs: []
  type: TYPE_NORMAL
- en: The main complexity is configuring the security chain as there are many options
    available. In the `SecurityConfig` class, there are two `Beans` with different
    priorities.
  prefs: []
  type: TYPE_NORMAL
- en: The `SecurityConfig` class defines two `SecurityFilterChain` beans. Here, `SecurityFilterChain`
    is essentially a chain of filters that Spring Security uses to perform various
    security checks. Each filter in the chain has a specific role, such as authenticating
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: The first `SecurityFilterChain` bean is defined with an order of 1, meaning
    it will be the first filter chain to be consulted. This filter chain has been
    configured to apply default security settings for an OAuth 2.0 authorization server.
    It also enables OpenID Connect 1.0 via the `oidc(Customizer.withDefaults())` method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration also specifies that if a user is not authenticated, they should
    be redirected to the OAuth 2.0 login endpoint. This is done using `LoginUrlAuthenticationEntryPoint`
    with a URL of `/oauth2/authorization/football-gmail`.
  prefs: []
  type: TYPE_NORMAL
- en: The filter chain is also configured to accept JWT access tokens for user info
    and/or client registration. This is done using the `oauth2ResourceServer((oauth2)
    -> oauth2.jwt(Customizer.withDefaults()))` method call.
  prefs: []
  type: TYPE_NORMAL
- en: The second `SecurityFilterChain` bean is defined with an order of 2, meaning
    it will be consulted if the first filter chain does not handle the request. The
    `anyRequest().authenticated()` chain of methods means that any request must be
    authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: The `oauth2Login(Customizer.withDefaults())` method call configures the application
    to use OAuth 2.0 for authentication. The `Customizer.withDefaults()` method call
    is used to apply the default configuration for OAuth 2.0 login.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, integrating a third-party authentication in the Authorization
    Server just requires configuring the client application for the IdP. So, if you
    need to integrate with another social provider, you will need to obtain the client
    application data.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to integrate with GitHub, you can create an application registration
    on the https://github.com/settings/developers page.
  prefs: []
  type: TYPE_NORMAL
- en: For Facebook, you can create your application on the developer’s page at https://developers.facebook.com/apps.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a RESTful API with a cloud IdP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that your application is becoming more and more popular, you decide to delegate
    your authentication to a cloud IdP as they offer advanced protection for sophisticated
    threats. You decide to use Azure AD B2C. This service is intended for public-facing
    applications, allowing customers to sign in and sign up, as well as customize
    the user journey, social network integration, and other interesting features.
  prefs: []
  type: TYPE_NORMAL
- en: What you’ll learn in this recipe can be applied to other cloud IdPs, such as
    Okta, AWS Cognito, Google Firebase, and many others. Spring Boot offers specialized
    starters that simplify the process of integrating with an IdP even more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll integrate the application you prepared in the *Configuring
    an MVC application with OpenID authentication* recipe. If you haven’t completed
    that recipe yet, I’ve prepared a working version that you can find in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-6/start` folder. This recipe also requires Redis, as
    explained in the *Configuring an MVC application with OpenID authentication* recipe.
    The easiest way to deploy it on your computer is by using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll be integrating with Azure AD B2C, you will need an Azure subscription.
    If you don’t have one, you can create a free account at https://azure.microsoft.com/free.
    Azure AD B2C offers a free tier that allows up to 50,000 monthly active users.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have an Azure AD B2C tenant, please follow the instructions at
    [https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant](https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant)
    to create one before starting this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build a smooth sign-in/signup process with Azure AD B2C
    and learn how to connect it seamlessly with your Spring Boot application for large-scale
    user authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you’ll need to do is create an application registration in
    Azure AD B2C. An application registration is the same as the client registration
    you created in Spring Authorization Server in previous recipes. You can create
    the application registration in the **App** **registrations** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.21: Creating an app registration in Azure AD B2C](img/B21646_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: Creating an app registration in Azure AD B2C'
  prefs: []
  type: TYPE_NORMAL
- en: On the `Football UI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For `http://localhost:9080/login/oauth/code` as the value of the redirect UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.22: Application registration options in Azure AD B2C](img/B21646_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.22: Application registration options in Azure AD B2C'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Register** to continue with the application registration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the application registration, you need to configure a
    client secret. You can do this in the **Certificates & secrets** section of the
    application registration you’ve created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.23: Creating a new client secret](img/B21646_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.23: Creating a new client secret'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created the secret, the secret value generated by Azure AD B2C will
    appear. You should copy the value now as it won’t be accessible again. Keep it
    safe as you’ll need it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we must create a user flow. A user flow is a configuration policy
    that can be used to set up the authentication experience for end users. Set the
    following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `SUSI`; this is an acronym for “sign up and sign in.”
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Identity providers**, select **Email signup**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **User attributes and token claims**, select **Given Name** and **Surname**.
    For both attributes, check the **Collect attribute** and **Return** **claim**
    boxes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep the rest of the options as-is:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.24: The Create a user flow page](img/B21646_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.24: The Create a user flow page'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Create** to create the user flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s configure our application. First, you’ll need to add the appropriate
    dependencies. For that, open the `pom.xml` file of the web application and add
    the `org.springframework.boot:spring-boot-starter-oauth2-client` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you’ll need to configure the Azure AD B2C settings in the `application.yml`
    file in the `resources` folder. Replace the Oauth2 client settings with the B2C
    ones. The file should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `client-secret` field, set the value you kept in *Step 4*. I recommend
    enclosing the secret value in quotation marks since the secret likely contains
    reserved characters that can cause unexpected behavior when the `application.yaml`
    file is being processed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To complete the OpenID configuration to allow users to log in to your application
    with Azure AD B2C, you’ll need to adjust the security chain by applying an Azure
    AD OIDC configurer. To do this, modify the `SecurityConfiguration` class by adding
    `AadB2cOidcLoginConfigurer` in the constructor to allow bean injection, and then
    use it in the existing `defaultSecurityFilterChain` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, you can run your web application and authenticate with Azure
    AD B2C. However, there’s still something pending that’s protecting the RESTful
    API server with Azure AD B2C.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get around this, you can modify the dependencies. For that, open the `pom.xml`
    file of the RESTful API project and replace the `org.springframework.boot: spring-boot-starter-oauth2-resource-server`
    dependency with `com.azure.spring:spring-cloud-azure-starter-active-directory-b2c`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, modify the `application.yml` file so that it configures the Azure B2C
    client registration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can run both the web application and the RESTful server since both
    are protected with Azure AD B2C:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your browser and navigate to `http://localhost:8080/myself`. As the method
    is protected, you will be redirected to the **Azure AD B2C Sign up or sign** **in**
    page:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.25: The Azure AD B2C default Sign up or sign in page](img/B21646_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.25: The Azure AD B2C default Sign up or sign in page'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **Sign up now** link, you can create a new user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.26: Sign-up page](img/B21646_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.26: Sign-up page'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to provide a valid email address. Once you’ve done this click
    **Send verification code**. You will receive an email containing a verification
    code that you will need to provide on this page. Once verified, you can introduce
    the rest of the fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you return to the page, you will see the claims that have been provided
    by Azure AD B2C:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.27: Our web page showing the claims from Azure B2C](img/B21646_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.27: Our web page showing the claims from Azure B2C'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the **Teams** link, you will see the same data that you did
    in the *Configuring an MVC application with OpenID* *authentication* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you click on the **Logout** link, you will be redirected to the default
    logout page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.28: The default logout page](img/B21646_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.28: The default logout page'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you click on the **Log Out** button, you will be redirected to the
    logout endpoint in Azure AD B2C.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `com.azure.spring:spring-cloud-azure-starter-active-directory-b2c` dependency
    includes both the Spring OAuth2 client and Spring OAuth2 resource starters that
    we used in previous recipes. On top of those starters, it also includes specific
    components to adapt the Azure AD B2C-specific features. For instance, the discovery
    endpoint cannot be inferred just from the issuer URL as it is dependent on the
    Azure AD B2C policy being used.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure AD B2C starter maps the configuration used in the Azure portal to
    the configuration on your `application.yml` file. Apart from that, the application
    doesn’t require specific changes as it follows the OAuth2 specification.
  prefs: []
  type: TYPE_NORMAL
- en: In Azure AD B2C, we defined an app registration. This is equivalent to the concept
    of a client in Spring Authorization Server.
  prefs: []
  type: TYPE_NORMAL
- en: Azure AD B2C allows us to define different policies so that we can customize
    the user experience. We created a policy that performs the sign-up and sign-in
    process using the default settings, but you can define an edit profile or reset
    password policy as well. Other interesting capabilities include defining custom
    interfaces and integrating other IdPs. For instance, it’s quite easy to integrate
    with cloud providers such as Google Accounts, social network providers such as
    Facebook and Instagram, and enterprise IdPs such as Azure Entra.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of this solution is that users can register themselves;
    they don’t need an administrator to do this for them.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe doesn’t intend to review all the possibilities of Azure AD B2C –
    it’s been provided to help you understand how to integrate your Spring Boot application
    with Azure AD B2C.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interesting and probably more frequent scenario is when our RESTful API
    uses a different application registration than the UI application. When I build
    a RESTful API, I usually design it while keeping one thing in mind: more than
    one client should be able to consume it. This works for different scenarios, such
    as the web and mobile versions, or allowing a third-party application to consume
    some of the APIs. In that scenario, you can create a dedicated application registration
    for your RESTful API and create different application roles with different access
    levels. Then, you can assign the corresponding role to the consumer applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create the application registration for the RESTful API, you can create
    the roles by opening the manifest and including the desired roles of your application.
    For instance, we can create the `football.read` role for general consumer access
    and the `football.admin` role for administrative access. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29: The application registration manifest with two application roles](img/B21646_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.29: The application registration manifest with two application roles'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the RESTful application registration area, go to **Expose an API**
    and assign an **Application ID** **URI** value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30: Assigning an Application ID URI value](img/B21646_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.30: Assigning an Application ID URI value'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can assign permissions to the RESTful API. Go to **API permissions**
    and assign **Application permissions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31: Assigning application permissions to the consumer application](img/B21646_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.31: Assigning application permissions to the consumer application'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the RESTful API has its own application registration. This means that you
    can configure the application with its own audience, instead of the UI application.
    To configure that, go to the `application.yml` file of the RESTful API and change
    the `client-id` property to the client ID of the application registration of the
    RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use the application roles to provide different access levels,
    you will need to use `AadJwtGrantedAuthoritiesConverter` from the Azure AD B2C
    starter. You can register the bean in the `SecurityConfig` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the Spring OAuth2 resource server only converts the `scope` claim
    and the application roles will be provided in the `roles` claim. The converter
    generates authorities for each role with the `APPROLE_` prefix. So, you can restrict
    access using these authorities like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what the payload of an access token with the application roles looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, only the allowed client applications will be able to consume
    the RESTful API.
  prefs: []
  type: TYPE_NORMAL
