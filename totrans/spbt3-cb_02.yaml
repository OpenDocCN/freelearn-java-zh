- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Securing Spring Boot Applications with OAuth2
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth2保护Spring Boot应用程序
- en: '**Open Authorization 2.0** (**OAuth 2.0**) is an open standard protocol that
    provides secure authorization for web and mobile applications. It allows users
    to grant limited access to their resources on one website (called the “resource
    server”) to another website or application (called the “client”) without sharing
    their credentials, such as usernames and passwords. This means that the resource
    server will never see a user’s credentials. OAuth 2.0 is widely used for enabling
    **single sign-on** (**SSO**), accessing third-party APIs, and implementing secure
    authorization mechanisms. SSO allows a user to log in to any of several related,
    yet independent, applications with a single ID. Once logged in to an application,
    the user is not required to reenter the credentials to access the rest of the
    applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放授权2.0**（**OAuth 2.0**）是一个提供Web和移动应用程序安全授权的开放标准协议。它允许用户在不共享其凭据（如用户名和密码）的情况下，将一个网站（称为“资源服务器”）上的有限访问权限授予另一个网站或应用程序（称为“客户端”）。这意味着资源服务器永远不会看到用户的凭据。OAuth
    2.0被广泛用于启用**单点登录**（**SSO**）、访问第三方API和实现安全的授权机制。SSO允许用户使用单个ID登录到多个相关但独立的独立应用程序。一旦登录到应用程序，用户就不需要重新输入凭据来访问其他应用程序。'
- en: '**OpenID Connect** (**OIDC**) is an open standard for user authentication that’s
    built on top of OAuth 2.0\. It’s used with OAuth 2.0 to enable secure access to
    user data. An example of this is when an application allows you to sign in with
    your Google Account. Usually, they can request access to certain parts of your
    Google Account profile or permissions to interact with your account on your behalf.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenID Connect**（**OIDC**）是一个建立在OAuth 2.0之上的开放标准，用于用户身份验证。它与OAuth 2.0一起使用，以实现用户数据的安全访问。一个例子是当应用程序允许您使用Google账户登录时。通常，它们可以请求访问您Google账户配置文件的部分内容或代表您与账户交互的权限。'
- en: 'In this chapter, we will learn how to deploy a basic Spring Authorization Server
    that we’ll be using in most of the recipes in this book. Then, we’ll learn about
    the most common scenarios to protect an application, from a RESTful API to a web
    application. Finally, we’ll apply the same concepts but using two popular cloud
    solutions: Google Accounts for user authentication and Azure AD B2C for an extensible
    end-to-end authentication experience.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何部署一个基本的Spring授权服务器，我们将在本书的大多数食谱中使用它。然后，我们将了解保护应用程序最常见的情况，从RESTful
    API到Web应用程序。最后，我们将应用相同的概念，但使用两种流行的云解决方案：Google账户用于用户身份验证和Azure AD B2C用于可扩展的端到端身份验证体验。
- en: Spring Boot offers great support for OAuth2 and OIDC, regardless of the Identity/Authorization
    server used. It manages the standard OAuth2/OpenID concepts that are implemented
    by all vendors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为OAuth2和OIDC提供了极大的支持，无论使用的是哪种身份/授权服务器。它管理所有供应商实现的标准OAuth2/OpenID概念。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Setting up Spring Authorization Server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Spring授权服务器
- en: Protecting a RESTful API using OAuth2
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth2保护RESTful API
- en: Protecting a RESTful API using OAuth2 with different scopes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth2和不同作用域保护RESTful API
- en: Configuring an MVC application with OpenID authentication
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置具有OpenID身份验证的MVC应用程序
- en: Logging in with Google Accounts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google账户登录
- en: Integrating a RESTful API with a cloud **identity** **provider** (**IdP**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RESTful API与云**身份****提供者**（**IdP**）集成
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has the same technical requirements as [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
    So, we will need an editor such as Visual Studio Code or IntelliJ, Java OpenJDK
    21 or higher, and a tool to perform HTTP requests, such as `curl` or Postman.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有与[*第一章*](B21646_01.xhtml#_idTextAnchor020)相同的技术要求。因此，我们需要一个编辑器，例如Visual
    Studio Code或IntelliJ，Java OpenJDK 21或更高版本，以及一个执行HTTP请求的工具，例如`curl`或Postman。
- en: For some scenarios, you will need a Redis server. The easiest way to run a Redis
    server locally is by using Docker.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些场景，您需要一个Redis服务器。在本地运行Redis服务器的最简单方法是使用Docker。
- en: For the *Logging in with Google Accounts* recipe, you will need a Google Account.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*使用Google账户登录*食谱，您需要一个Google账户。
- en: For the *Integrating a RESTful API with a cloud IdP* recipe, I used Azure Entra
    (formerly known as Azure Active Directory) as an authentication provider. You
    can create a free account with 200 USD credit at [https://azure.microsoft.com/free/search](https://azure.microsoft.com/free/search)/.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**将 RESTful API 与云身份提供者集成**食谱，我使用了 Azure Entra（以前称为 Azure Active Directory）作为身份验证提供者。您可以在[https://azure.microsoft.com/free/search](https://azure.microsoft.com/free/search/)上创建一个免费账户，并获得
    200 美元的信用额度。
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将要演示的所有食谱都可以在以下位置找到：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2)
- en: Setting up Spring Authorization Server
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Spring 授权服务器
- en: Spring Authorization Server is a project under the umbrella of Spring Framework
    that provides the components you need to create an Authorization Server. In this
    recipe, you will deploy a very simple Authorization Server that you will use for
    most of the recipes in this chapter. In the following recipes, you will continue
    to customize this server to achieve the goals of each exercise.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 授权服务器是 Spring 框架下的一个项目，它提供了创建授权服务器所需的组件。在本食谱中，你将部署一个非常简单的授权服务器，你将在本章的大部分食谱中使用它。在接下来的食谱中，你将继续定制这个服务器以实现每个练习的目标。
- en: The configuration of this server is just for demo purposes. The Authorization
    Server plays a crucial role in managing and granting access to protected resources.
    If you plan to use it in production, I recommend following the instructions from
    the project at [https://docs.spring.io/spring-authorization-server/reference/overview.html](https://docs.spring.io/spring-authorization-server/reference/overview.html).
    In any case, the principles that we will explain in this book have been adjusted
    to the OAuth2 specification and well-known practices. For this reason, you will
    be able to apply what you learn here to any other Authorization Server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器的配置仅用于演示目的。授权服务器在管理和授予对受保护资源的访问方面发挥着至关重要的作用。如果你计划在生产中使用它，我建议遵循[https://docs.spring.io/spring-authorization-server/reference/overview.html](https://docs.spring.io/spring-authorization-server/reference/overview.html)项目中的说明。无论如何，本书中我们将解释的原则已经调整为
    OAuth2 规范和公认的实践。因此，你将能够将在这里学到的知识应用到任何其他授权服务器。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To create the Spring Authorization Server, we will use Spring Initializr. You
    can open this tool in your browser using [https://start.spring.io/](https://start.spring.io/)
    or use it in your code editor if it’s been integrated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Spring 授权服务器，我们将使用 Spring Initializr。您可以通过浏览器使用[https://start.spring.io/](https://start.spring.io/)打开此工具，或者如果您已经将其集成到代码编辑器中，也可以使用它。
- en: I assume that you have basic knowledge of OAuth2\. However, I have added some
    links in the *See also* section that can be useful if you need to go through some
    concepts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您对 OAuth2 有基本的了解。然而，我在**也见**部分添加了一些链接，如果您需要了解一些概念，这些链接可能很有用。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will create a Spring Authorization Server using Spring Initializr
    and do a very basic configuration to create an application registration. Finally,
    we’ll test the application registration and analyze the results. Follow these
    steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 Spring Initializr 创建一个 Spring 授权服务器，并进行非常基本的配置以创建应用程序注册。最后，我们将测试应用程序注册并分析结果。按照以下步骤操作：
- en: 'Open [https://start.spring.io](https://start.spring.io), as you did in the
    *Creating a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    and use the same parameters, except change the following options:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开[https://start.spring.io](https://start.spring.io)，就像在[*第 1 章*](B21646_01.xhtml#_idTextAnchor020)中创建
    RESTful API 食谱时做的那样，并使用相同的参数，除了以下选项：
- en: For `footballauth`
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `footballauth`
- en: 'For **Dependencies**, select **OAuth2** **Authorization Server**:'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**依赖项**，选择**OAuth2 授权服务器**：
- en: '![Figure 2.1: Spring Initializr options for Spring Authorization Server](img/B21646_02_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：Spring 授权服务器的 Spring Initializr 选项](img/B21646_02_1.jpg)'
- en: 'Figure 2.1: Spring Initializr options for Spring Authorization Server'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：Spring 授权服务器的 Spring Initializr 选项
- en: Click on the **GENERATE** button to download the project, then unzip the content
    to your working folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**生成**按钮下载项目，然后将内容解压缩到你的工作文件夹中。
- en: 'Now, we need to configure the authorization server. For that, we will create
    an `application.yml` file in the `resources` folder with the following content:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要配置授权服务器。为此，我们将在`resources`文件夹中创建一个`application.yml`文件，内容如下：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We just defined an application that can be authenticated using the client credential
    flow.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个可以使用客户端凭证流进行认证的应用程序。
- en: Now, you can execute your Authorization Server. You can retrieve the configuration
    of our server by making a request to http://localhost:9000/.well-known/openid-configuration.
    As the path indicates, this is a well-known endpoint that all OAuth2-compliant
    vendors implement to expose the relevant configuration for client applications.
    Most of the client libraries can configure themselves just from this endpoint.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以执行您的授权服务器。您可以通过向http://localhost:9000/.well-known/openid-configuration发送请求来检索服务器的配置。如路径所示，这是一个众所周知的端点，所有OAuth2兼容的供应商都实现它以公开客户端应用程序的相关配置。大多数客户端库都可以仅从这个端点进行配置。
- en: 'To verify that it works, we can execute the authentication of our client. You
    can do this by executing the following `POST` request via `curl`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证其是否正常工作，我们可以执行我们客户端的认证。您可以通过执行以下`POST`请求并通过`curl`来完成此操作：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see a response that looks similar to this:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到一个类似以下响应：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, you can copy the value of the `access_token` field, open [https://jwt.ms](https://jwt.ms)
    in your browser, and paste the value there. In the **Decoded Token** tab, you
    can see the token in its decoded form, while if you click on the **Claims** tab,
    you can see an explanation of each field:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以复制`access_token`字段的值，在您的浏览器中打开[https://jwt.ms](https://jwt.ms)，并将该值粘贴到那里。在**解码令牌**标签页中，您可以查看令牌的解码形式；如果您点击**声明**标签页，您可以看到每个字段的解释：
- en: '![Figure 2.2: JWT token decoded in jwt.ms](img/B21646_02_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：在jwt.ms中解码的JWT令牌](img/B21646_02_2.jpg)'
- en: 'Figure 2.2: JWT token decoded in jwt.ms'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：在jwt.ms中解码的JWT令牌
- en: Congratulations – you’ve deployed a Spring Authorization Server and successfully
    configured an application for authorization.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜——您已部署了Spring授权服务器，并成功配置了授权应用程序。
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Spring OAuth2 Authorization Server contains all the components you need to
    create an authorization server. With the configuration provided in `application.yml`,
    it created an application with a `client-id` value of `basic-client`. Let’s look
    at the parameters that were used for the application and see how they work:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring OAuth2授权服务器包含创建授权服务器所需的所有组件。通过在`application.yml`中提供的配置，它创建了一个具有`client-id`值为`basic-client`的应用程序。让我们看看用于应用程序的参数以及它们是如何工作的：
- en: The `client-id` is the identifier of the application we create d. In this case,
    it is `football`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client-id`是我们创建的应用程序的标识符。在这种情况下，它是`football`。'
- en: The `client-secret` is the secret of the application. By using the `{noop}`
    prefix in the secret, we tell Spring Security that the password is not encrypted
    and can be used as-is.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client-secret`是应用程序的密钥。通过在密钥中使用`{noop}`前缀，我们告诉Spring Security密码未加密，可以直接使用。'
- en: The `client-authentication-methods` is used to specify how this application
    can authenticate. By using the `client_secret_post` method, we can ensure that
    the client ID and secret will be sent in a `POST` request. We could configure
    additional methods, such as `client_secret_basic`, in which case the client ID
    and secret will be sent as HTTP basic schema – that is, in the URL.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client-authentication-methods`用于指定此应用程序如何进行认证。通过使用`client_secret_post`方法，我们可以确保客户端ID和密钥将以`POST`请求的形式发送。我们还可以配置其他方法，例如`client_secret_basic`，在这种情况下，客户端ID和密钥将以HTTP基本模式发送——即在URL中。'
- en: With the `authorization-grant-types`, we specify what grant flows are allowed
    for this application. By setting `client_credentials`, we are configuring an application
    that won’t have a user interface, such as a background server application. If
    you have an application that will interact with users, you could configure other
    options, such as `authorization_code`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`authorization-grant-types`，我们指定了此应用程序允许的授权流。通过设置`client_credentials`，我们正在配置一个没有用户界面的应用程序，例如后台服务器应用程序。如果您有一个将与应用户交互的应用程序，您可以选择其他选项，例如`authorization_code`。
- en: Finally, with the `scopes`, we are configuring the scopes that are allowed for
    this application. In this case, it is just the `football:read` scope.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，通过`scopes`，我们正在配置此应用程序允许的作用域。在这种情况下，仅仅是`football:read`作用域。
- en: Spring OAuth2 Authorization Server keeps this configuration in memory. As you
    may have guessed, this is just for demonstration and development purposes. In
    a production environment, you will need to persist this data. Spring OAuth2 Authorization
    Server provides support for JPA repositories.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring OAuth2 授权服务器将此配置保存在内存中。正如你可能猜到的，这只是为了演示和开发目的。在生产环境中，你需要持久化这些数据。Spring
    OAuth2 授权服务器为 JPA 存储库提供支持。
- en: We used **JWT MS** ([https://jwt.ms](https://jwt.ms)) to inspect the access
    token that was issued by our authorization server. This tool just decodes the
    token and describes the standard fields. There is another popular tool named **JWT
    IO** ([https://jwt.io](https://jwt.io)) that also allows you to validate the token,
    but it doesn’t explain each field.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **JWT MS** ([https://jwt.ms](https://jwt.ms)) 检查由我们的授权服务器签发的访问令牌。这个工具只是解码令牌并描述标准字段。还有一个名为
    **JWT IO** ([https://jwt.io](https://jwt.io)) 的流行工具，它也允许你验证令牌，但它不会解释每个字段。
- en: There’s more…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can follow the instructions from the Spring OAuth2 Authorization Server
    project to implement the core services with JPA: [https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html](https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遵循 Spring OAuth2 授权服务器项目的说明，使用 JPA 实现核心服务：[https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html](https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html)。
- en: You can use any relational database supported by Spring Data JPA, such as PostgreSQL,
    which we used in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Spring Data JPA 支持的任何关系型数据库，例如 PostgreSQL，我们在 [*第 5 章*](B21646_05.xhtml#_idTextAnchor203)
    中使用过。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In this chapter, we’ll manage many OAuth2 concepts, something that can be difficult
    to understand if you don’t have previous knowledge.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将管理许多 OAuth2 概念，如果你没有先前的知识，这可能很难理解。
- en: 'For instance, it is very important to understand the different token types:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，了解不同的令牌类型非常重要：
- en: '`access_token`: This contains all authorization information granted by the
    authorization server that the resource server will verify.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_token`：这包含授权服务器授予的所有授权信息，资源服务器将进行验证。'
- en: '`id_token`: This token is used for session management, normally in client applications,
    to customize the user interface, for example.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_token`：此令牌用于会话管理，通常在客户端应用程序中，例如用于自定义用户界面。'
- en: '`refresh_token`: This token is used to get new `access_tokens` and `id_tokens`
    when they are about to expire. `refresh_token` is considered a secret as its lifetime
    is larger than the others and can be used not only to get fresher tokens for the
    already authorized applications but also for new ones. It is important to protect
    this token accordingly.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_token`：此令牌用于在即将过期时获取新的 `access_tokens` 和 `id_tokens`。`refresh_token`
    被视为秘密，因为其有效期比其他令牌长，不仅可以用于获取已授权应用程序的新鲜令牌，还可以用于新的应用程序。因此，需要相应地保护此令牌。'
- en: 'I strongly recommend getting familiar with the basic OAuth2 flows and their
    main purposes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议熟悉基本的 OAuth2 流程及其主要目的：
- en: '**Client** **credential flow**:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端** **凭证流**：'
- en: This is the simplest flow and was used in this recipe. It is intended for applications
    without user interaction – for instance, for server applications communicating
    with other applications. They can be authenticated in different ways, such as
    with a secret, as seen in this recipe, a certificate, or other more sophisticated
    techniques.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 simplest 的流程，在本次食谱中使用过。它适用于无需用户交互的应用程序——例如，用于与其他应用程序通信的服务器应用程序。它们可以通过不同的方式认证，例如使用密钥，如本食谱中所示，证书或其他更复杂的技术。
- en: '**Authorization code** **grant flow**:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权码** **授权流**：'
- en: 'This is intended to authenticate web and mobile applications. This is the two-leg
    authentication flow, where the user authenticates and allows the application to
    access the requested scopes. Then, the authentication endpoint issues a short-lived
    piece of code that should be redeemed in the token endpoint to get an access token.
    After, the application (not the user) should be authenticated. There are two variants
    of this flow, depending on how it authenticates:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是为了验证网页和移动应用程序。这是双因素认证流程，用户进行认证并允许应用程序访问请求的作用域。然后，认证端点会发放一个短期有效的代码，该代码应在令牌端点兑换以获取访问令牌。之后，应该对应用程序（而非用户）进行认证。根据认证方式的不同，此流程有两种变体：
- en: Using a client ID and a secret. This is intended for confidential applications,
    such as those that can keep secrets. This includes server applications.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端 ID 和密钥。这适用于保密应用程序，例如那些可以保密的应用程序。这包括服务器应用程序。
- en: Using a client ID and a challenge, also known as **Proof Key Challenge Exchange**
    (**PKCE**). This is intended for public applications, such as those that cannot
    keep a secret, such as mobile applications, or applications that just live in
    the browser, such as **single-page** **applications** (**SPAs**).
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端 ID 和挑战，也称为 **证明密钥挑战交换** (**PKCE**)。这适用于公共应用程序，例如那些无法保密的应用程序，如移动应用程序，或者仅存在于浏览器中的应用程序，如
    **单页应用程序** (**SPAs**)。
- en: '`refresh_token`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_token`。'
- en: There are more flows, but these are the basic ones that will be used in this
    chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多流程，但这些都是本章将使用的基本流程。
- en: Protecting a RESTful API using OAuth2
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth2 保护 RESTful API
- en: Protecting a resource – in this case, a RESTful API – is the core functionality
    of OAuth. In OAuth2, a resource server delegates authorization to access a third-party
    server – that is, the authorization server. In this recipe, you’ll learn how to
    configure a RESTful API application so that it can authorize the requests that
    are issued by your Spring Authorization Server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 保护资源 – 在这种情况下，一个 RESTful API – 是 OAuth 的核心功能。在 OAuth2 中，资源服务器将授权访问第三方服务器的权限委托给授权服务器。在本菜谱中，你将学习如何配置一个
    RESTful API 应用程序，以便它可以授权由你的 Spring 授权服务器发出的请求。
- en: We will continue with our samples for football data management. You will protect
    your Football API by only allowing clients who have been granted access by our
    Authorization Server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的足球数据管理示例。你将通过只允许授权服务器授权的客户端来保护你的 Football API。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will reuse the Authorization Server you created in the *Setting
    up Spring Authorization Server* recipe. If you haven’t completed that yet, you
    can use the authorization server that I’ve prepared. You can find it in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-2/start` folder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，你将重用你在 *设置 Spring 授权服务器* 菜谱中创建的授权服务器。如果你还没有完成，你可以使用我准备好的授权服务器。你可以在本书的
    GitHub 仓库中找到它，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)，在
    `chapter4/recipe4-2/start` 文件夹中。
- en: How to do it…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, you will create a new RESTful API and configure it as a *resource
    server* using the client registration you created in the previous recipe. Follow
    these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，你将创建一个新的 RESTful API，并使用之前菜谱中创建的客户端注册将其配置为 *资源服务器*。按照以下步骤操作：
- en: 'First, create a RESTful API using Spring Initializr ([https://start.spring.io](https://start.spring.io)).
    Use the same options that you did in the *Creating a RESTful API* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), except change the following options:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 Spring Initializr ([https://start.spring.io](https://start.spring.io))
    创建一个 RESTful API。使用与你在 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中 *创建 RESTful
    API* 菜单中相同的选项，但以下选项需要更改：
- en: For `footballresource`.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `footballresource`。
- en: 'For **Dependencies**, select **Spring Web** and **Oauth2** **Resource Server**:'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **依赖项**，选择 **Spring Web** 和 **Oauth2 资源服务器**：
- en: '![Figure 2.3: Spring Initializr options for a protected RESTful API](img/B21646_02_3.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3：受保护 RESTful API 的 Spring Initializr 选项](img/B21646_02_3.jpg)'
- en: 'Figure 2.3: Spring Initializr options for a protected RESTful API'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：受保护 RESTful API 的 Spring Initializr 选项
- en: Click **GENERATE** to download a ZIP file that contains your project template.
    Unzip it in your working folder and open it in your code editor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **GENERATE** 下载包含你的项目模板的 ZIP 文件。将其解压到你的工作文件夹中，并在代码编辑器中打开它。
- en: 'We can create a simple REST controller with a method that returns a list of
    teams. For that, create a class named `Football.java` with the following content:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个简单的 REST 控制器，其中包含一个返回球队列表的方法。为此，创建一个名为 `Football.java` 的类，并包含以下内容：
- en: '[PRE3]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s configure our application for authorization by using the Authorization
    Server we created in the previous recipe. For that, create an `application.yml`
    file in the `resources` folder with the following content:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们使用之前菜谱中创建的授权服务器来配置我们的应用程序以进行授权。为此，在 `resources` 文件夹中创建一个 `application.yml`
    文件，并包含以下内容：
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to get an access token from our Authorization Server first. For that,
    you can execute the following request using `curl`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要从我们的授权服务器获取一个访问令牌。为此，你可以使用 `curl` 执行以下请求：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The response will look like this:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应将看起来像这样：
- en: '![Figure 2.4: Access token issued by the Authorization Server](img/B21646_02_4.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：授权服务器签发的访问令牌](img/B21646_02_4.jpg)'
- en: 'Figure 2.4: Access token issued by the Authorization Server'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：授权服务器签发的访问令牌
- en: 'Copy the access token value and use it in the next request:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制访问令牌值并在下一个请求中使用它：
- en: '[PRE6]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You now have our RESTful API that’s protected by the tokens that were issued
    by the authorization server.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你有了由授权服务器签发的令牌保护的我们的RESTful API。
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In this simplified example, you saw how authorization works in OAuth2\. There’s
    an authorization server issuing a token with authorization information. A resource
    server – our RESTful API – then checks the token’s validity and applies the provided
    configuration. The authorization server can issue the token in different formats,
    but the most common is via `.`) signs:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的例子中，你看到了OAuth2中的授权是如何工作的。有一个授权服务器签发带有授权信息的令牌。然后资源服务器——我们的RESTful API——检查令牌的有效性并应用提供的配置。授权服务器可以以不同的格式签发令牌，但最常见的是通过`.`)符号：
- en: The header contains the metadata needed to manage the token. It is encoded in
    base64.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头包含管理令牌所需的元数据。它使用base64进行编码。
- en: The payload contains the actual data and claims about the token. It carries
    information such as the expiration time, issuer, and custom claims. It is encoded
    in base64.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载包含实际数据和关于令牌的声明。它包含诸如过期时间、发行者和自定义声明等信息。它使用base64进行编码。
- en: The signature is created by taking the encoded header and encoded payload, along
    with a secret, and signing them using the signing algorithm specified in the header.
    The signature is used to verify the *authenticity* and *integrity* of the token
    so that we can ensure the token was issued by the authorization server and was
    not modified by anyone else.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名是通过使用编码的标头和编码的负载，以及一个密钥，并使用标头中指定的签名算法来对它们进行签名来创建的。签名用于验证令牌的**真实性**和**完整性**，以确保令牌是由授权服务器签发的，并且没有被其他人修改。
- en: The resource needs to validate the authenticity and integrity of the token.
    For that, it needs to verify the signature. The Authorization Server provides
    an endpoint to download the public key of the certificate being used to sign the
    token. So, the first thing that the authorization server needs to know is where
    that endpoint is. We can configure this manually in the `application.yml` file,
    but luckily, Spring Resource Server knows how to retrieve all the information
    about the authorization server automatically. Just by configuring the `issuer-uri`
    property, it knows how to retrieve the rest of the information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 资源需要验证令牌的真实性和完整性。为此，它需要验证签名。授权服务器提供了一个端点，可以下载用于签名令牌的证书的公钥。因此，授权服务器首先需要知道该端点的位置。我们可以在`application.yml`文件中手动配置此信息，但幸运的是，Spring
    Resource Server知道如何自动检索授权服务器所有相关信息。只需配置`issuer-uri`属性，它就知道如何检索其余信息。
- en: 'Almost all authorization servers in the market can provide the well-known `OpenId`
    endpoint if we add the following path to the issuer URI: `.well-known/openid-configuration`.
    The first time the resource server needs to validate a JWT, it calls that endpoint
    – in our case, http://localhost:9000/.well-known/openid-configuration – and retrieves
    all the information it needs, such as the authorization and token endpoint, the
    **JSON Web Key Set** (**JWKS**) endpoint, which contains the sign-in key, and
    so on. JWKSs are the public keys that the authorization server can use to sign
    a token. The clients can download these keys to validate the signature of the
    JWT.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有市场上的授权服务器，如果我们向发行者URI添加以下路径：`.well-known/openid-configuration`，都可以提供已知的`OpenId`端点。当资源服务器第一次需要验证JWT时，它会调用该端点——在我们的例子中，是`http://localhost:9000/.well-known/openid-configuration`——并检索它所需的所有信息，例如授权和令牌端点、**JSON
    Web Key Set**（**JWKS**）端点，该端点包含签名密钥，等等。JWKS是授权服务器可以用来签名令牌的公钥。客户端可以下载这些密钥以验证JWT的签名。
- en: 'Now that we know how the resource server validates that the token has been
    issued by the authorization server, we need to know how we can validate that the
    token is intended for our RESTful APIs. In the `application.yml` file, we’ve configured
    the `audiences` field. This indicates the entity for which the token is valid
    and who or what the token is intended for. The `aud` claim helps ensure that a
    JWT is only accepted by the intended recipient or resource server. The `aud` claim
    is part of the payload of the JWT. In our case, the payload, after decoding the
    base64, looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了资源服务器如何验证令牌是由授权服务器签发的，我们就需要了解如何验证令牌是否针对我们的 RESTful API。在 `application.yml`
    文件中，我们已经配置了 `audiences` 字段。这表示令牌有效的实体以及令牌旨在为谁或什么服务。`aud` 声明有助于确保 JWT 只被预期的接收者或资源服务器接受。`aud`
    声明是 JWT 有效载荷的一部分。在我们的案例中，解码 base64 后的有效载荷看起来如下：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just by setting `issuer-uri` and `audiences`, we ensure that only JWT issued
    by our Authorization Server and those that are intended for our application/audience
    will be accepted. Spring Resource Server performs other standard checks, such
    as for the expiration time (the `exp` claim) and not valid before (the `nbf` claim).
    Anything else will be rejected with an `HTTP 401 Unauthorized` error. In the *Protecting
    a RESTful API using OAuth2 with different scopes* recipe, we’ll learn how to use
    other claims to enhance protection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只需设置 `issuer-uri` 和 `audiences`，我们就能确保只有由我们的授权服务器签发以及旨在为我们应用程序/受众签发的 JWT 会被接受。Spring
    资源服务器执行其他标准检查，例如过期时间（`exp` 声明）和不可用之前（`nbf` 声明）。其他任何内容都会以 `HTTP 401 未授权` 错误被拒绝。在
    *使用 OAuth2 和不同作用域保护 RESTful API* 的配方中，我们将学习如何使用其他声明来增强保护。
- en: 'It is important to note that from a Spring Resource Server perspective, it’s
    not important how the client obtained the access token as that responsibility
    is delegated to the Authorization Server. The Authorization Server may require
    different levels of validations, depending on the kind of resource being accessed.
    Some examples of validations are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，从 Spring 资源服务器角度来看，客户端如何获取访问令牌并不重要，因为这个责任已经委托给了授权服务器。授权服务器可能需要根据访问的资源类型进行不同级别的验证。以下是一些验证的示例：
- en: Client ID and secret, as shown in this example.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端 ID 和密钥，如本示例所示。
- en: Multiple factors of authentication. For applications with user interaction,
    the authorization server may consider that the username and password are not enough
    and force using a second factor of authentication, such as an authentication application,
    a certificate, and so on.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多因素认证。对于具有用户交互的应用程序，授权服务器可能认为用户名和密码不足以进行认证，并强制使用第二个认证因素，例如认证应用程序、证书等。
- en: If an application tries to access specific scopes, it may require explicit consent.
    We see this often with social networks when a third-party application needs to
    access certain parts of our profile or tries to perform special actions, such
    as publishing on our behalf.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序尝试访问特定的作用域，可能需要显式同意。我们经常在社交网络中看到这种情况，当第三方应用程序需要访问我们个人资料的部分内容或试图执行特殊操作，如代表我们发布时。
- en: Protecting a RESTful API using OAuth2 with different scopes
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth2 和不同作用域保护 RESTful API
- en: 'In the previous recipe, we learned how to protect our application. In this
    recipe, we’ll learn how to apply more fine-grained security. We need to apply
    different levels of access to the application: one general form of read access
    for the consumers of our RESTful API and administrative access so that we can
    make changes to the data.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们学习了如何保护我们的应用程序。在这个配方中，我们将学习如何应用更细粒度的安全措施。我们需要为应用程序应用不同级别的访问权限：一种通用的读取访问形式供我们的
    RESTful API 的消费者使用，以及管理访问权限，以便我们可以更改数据。
- en: To apply different levels of access to the API, we’ll use the standard OAuth2
    concept of *scopes*. In OAuth 2.0, `scope` is a parameter that’s used to specify
    the level of access and permissions that a client application is requesting from
    the user and the authorization server. It defines what actions or resources the
    client application is allowed to perform on behalf of the user. Scopes help ensure
    that users have control over which parts of their data and resources they grant
    access to, and they allow for fine-grained access control. In applications with
    user interaction, granting a scope may imply explicit consent from the user. For
    applications with no user interaction, it can be configured with administrative
    consent.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将不同级别的访问应用于API，我们将使用标准的OAuth2概念*范围*。在OAuth 2.0中，`scope`是一个参数，用于指定客户端应用程序从用户和授权服务器请求的访问级别和权限。它定义了客户端应用程序代表用户可以执行哪些操作或资源。范围有助于确保用户对其数据和资源授予访问权限的部分有所控制，并允许进行细粒度的访问控制。在具有用户交互的应用程序中，授予范围可能意味着用户明确同意。对于没有用户交互的应用程序，它可以配置为管理同意。
- en: 'In our football application, you will create two access levels: one for read-only
    access and another for administrative access.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的足球应用程序中，你将创建两个访问级别：一个用于只读访问，另一个用于管理访问。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we’ll reuse the Authentication Server from the *Setting up Spring
    Authorization Server* recipe and the resource server we created in the *Protecting
    a RESTful API using OAuth2* recipe. If you haven’t completed these recipes yet,
    you can find a working version in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-3/start` folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将重用*设置Spring授权服务器*配方中的认证服务器和我们在*使用OAuth2保护RESTful API*配方中创建的资源服务器。如果你还没有完成这些配方，你可以在本书的GitHub存储库中找到工作版本，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)，在`chapter4/recipe4-3/start`文件夹中。
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s create the `football:read` and `football:admin` scopes in the Authorization
    Server and apply the configuration for managing them in the resource server:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在授权服务器中创建`football:read`和`football:admin`范围，并在资源服务器中应用管理它们的配置：
- en: 'The first thing you should do is ensure that the scopes are defined in the
    authorization server. For that, go to the `application.yml` file in the `resources`
    folder of the project you created in the *Setting up Spring Authorization Server*
    recipe. If you’re using the implementation I provided, as explained in the *Getting
    ready* section of that recipe, you can find the project in the `footballauth`
    folder. Ensure that the application mentions the `football:read` and `football:admin`
    scopes. The application configuration in the `application.yml` file should look
    like this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该做的第一件事是确保在授权服务器中定义了范围。为此，请转到你在*设置Spring授权服务器*配方中创建的项目在`resources`文件夹中的`application.yml`文件。如果你使用了我提供的实现，如该配方中的*准备就绪*部分所述，你可以在`footballauth`文件夹中找到该项目。确保应用程序提到了`football:read`和`football:admin`范围。`application.yml`文件中的应用程序配置应如下所示：
- en: '[PRE8]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '@PostMapping("/teams")'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@PostMapping("/teams")'
- en: public String addTeam(@RequestBody String teamName){
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public String addTeam(@RequestBody String teamName){
- en: return teamName + " added";
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回`teamName + " added"`;
- en: '}'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, configure the resource server so that it can manage the scopes. For that,
    create a configuration class that exposes a `SecurityFilterChain` bean:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，配置资源服务器，使其能够管理范围。为此，创建一个配置类，该类公开一个`SecurityFilterChain`bean：
- en: '[PRE10]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that as part of `SecurityFilterChain`, we defined a couple of `requestMatchers`
    with `HttpMethod`, the request path, and the required authority using both scopes.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，作为`SecurityFilterChain`的一部分，我们使用`HttpMethod`、请求路径和所需的权限，通过两种范围定义了几个`requestMatchers`。
- en: 'Now that we have the required configuration, let’s run the application and
    perform some tests to validate its behavior:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了所需的配置，让我们运行应用程序并执行一些测试以验证其行为：
- en: 'First, get an access token from the authorization server, requesting just the
    `football:read` scope. You can execute the request by running the following `curl`
    command:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从授权服务器获取访问令牌，请求仅`football:read`范围。你可以通过运行以下`curl`命令来执行请求：
- en: '[PRE11]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'curl -H "Authorization: Bearer <access_token>" -H "Content-Type: application/text"
    --request POST --data ''Senegal'' http://localhost:8080/football/teams -v'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'curl -H "Authorization: Bearer <access_token>" -H "Content-Type: application/text"
    --request POST --data ''Senegal'' http://localhost:8080/football/teams -v'
- en: '[PRE12]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A note on curl
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于curl的说明
- en: Note that we’re starting to use the `-v` parameter. It provides a verbose response
    so that we can see the reasons something fails.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们开始使用 `-v` 参数。它提供详细的响应，以便我们可以看到某些失败的原因。
- en: 'It will return an HTTP 403 forbidden error, and the details will look as this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回 HTTP 403 禁止错误，详细信息如下：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s retrieve another access token with the appropriate scopes:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用适当的范围检索另一个访问令牌：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we can request more than one scope at a time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们一次可以请求多个范围。
- en: If we execute the request to create a team with the new access token, we’ll
    see that it works as expected and will return something like `Senegal added`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用新的访问令牌执行创建球队的请求，我们会看到它按预期工作，并返回类似 `Senegal added` 的内容。
- en: With that, our application is protected and we’ve applied different levels of
    protection to our resource server.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，我们的应用程序就得到了保护，并且我们已经为我们的资源服务器应用了不同的保护级别。
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `SecurityFilterChain` bean is a component that’s used for configuring the
    security filters that intercept and process incoming HTTP requests. Here, we created
    a `SecurityFilterChain` bean that looks for two matching patterns: `GET` requests
    that match the `/football/teams/**` path pattern and `POST` requests that match
    the same path pattern. `GET` requests should have the `SCOPE_football:read` authority
    and `POST` should have the `SCOPE_football:admin` authority. Once you configure
    `SecurityFilterChain`, it is applied to all incoming HTTP requests. Then, if a
    request matching the pattern doesn’t have the required scope, it will raise an
    `HTTP 403` `forbidden` response.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityFilterChain` bean 是一个用于配置拦截和处理传入 HTTP 请求的安全过滤器的组件。在这里，我们创建了一个 `SecurityFilterChain`
    bean，它查找两个匹配的模式：匹配 `/football/teams/**` 路径模式的 `GET` 请求和匹配相同路径模式的 `POST` 请求。`GET`
    请求应该有 `SCOPE_football:read` 权限，而 `POST` 应该有 `SCOPE_football:admin` 权限。一旦配置了 `SecurityFilterChain`，它就会应用于所有传入的
    HTTP 请求。然后，如果匹配模式的请求没有所需的范围，它将引发 `HTTP 403` `forbidden` 响应。'
- en: Why is `SCOPE_ prefix` used? It is created by the default `JwtAuthenticationConverter`.
    This component transforms the JWT into an `Authentication` object. The default
    `JwtAuthenticationConverter` is wired by Spring Security, but you can also register
    your own converter if you want a different behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 `SCOPE_` 前缀？这是由默认的 `JwtAuthenticationConverter` 创建的。该组件将 JWT 转换为 `Authentication`
    对象。默认的 `JwtAuthenticationConverter` 由 Spring Security 连接，但您也可以注册自己的转换器，如果您想要不同的行为。
- en: There’s more…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: More validations can be performed on JWT. For instance, a common way of validating
    a request is by checking its roles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 JWT 上执行更多验证。例如，验证请求的一种常见方式是检查其角色。
- en: 'You can validate a request’s roles by registering a `SecurityFilterChain` bean.
    Let’s say you have an administrator role defined in your Authorization Server.
    Here, you can configure a `SecurityFilterChain` bean in the resource server to
    ensure that only users with the `ADMIN` role can perform `POST` requests on `football/teams
    path`, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过注册 `SecurityFilterChain` bean 来验证请求的角色。假设您在授权服务器中定义了一个管理员角色。在这里，您可以在资源服务器中配置一个
    `SecurityFilterChain` bean，以确保只有具有 `ADMIN` 角色的用户可以在 `football/teams` 路径上执行 `POST`
    请求，如下所示：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can make other checks to validate your token. In this case, you can use
    `OAuth2TokenValidator`. For instance, you may want to validate that a given claim
    is present in your JWT. For that, you can create a class that implements `OAuth2TokenValidator`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进行其他检查以验证您的令牌。在这种情况下，您可以使用 `OAuth2TokenValidator`。例如，您可能想验证给定的声明是否存在于您的 JWT
    中。为此，您可以创建一个实现 `OAuth2TokenValidator` 的类：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: I recommend that you look at the Spring OAuth2 Resource Server project documentation
    at [https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html)
    for more details.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您查看 Spring OAuth2 资源服务器项目文档[https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html)，以获取更多详细信息。
- en: Configuring an MVC application with OpenID authentication
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenID 身份验证配置 MVC 应用程序
- en: We want to create a new web application for our football fans. To do so, we
    must authenticate the users when they’re accessing the application. We’ll use
    access tokens to access the protected RESTful API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想为我们的足球迷创建一个新的网络应用程序。为此，我们必须在用户访问应用程序时进行用户身份验证。我们将使用访问令牌来访问受保护的 RESTful API。
- en: In this recipe, we’ll learn how to use Spring OAuth2 Client to protect an MVC
    web application and get access tokens for other protected resources.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用Spring OAuth2 Client保护MVC Web应用程序并获取其他受保护资源的访问令牌。
- en: If you plan to use an SPA, you will need to look for OpenID-certified libraries
    for your target environment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划使用SPA，您将需要为您目标环境寻找OpenID认证的库。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will reuse the Authorization Server application you created
    in the *Setting up Spring Authorization Server* recipe and the application you
    created in the *Protecting a RESTful API using OAuth2 with different scopes* recipe.
    I’ve prepared a working version of both projects in case you haven’t completed
    them yet. You can find them in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-4/start` folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，您将重用您在*设置Spring授权服务器*食谱中创建的授权服务器应用程序以及您在*使用OAuth2和不同作用域保护RESTful API*食谱中创建的应用程序。如果您还没有完成它们，我已经为这两个项目准备了可工作的版本。您可以在本书的GitHub存储库中找到它们，在`chapter4/recipe4-4/start`文件夹中。[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
- en: 'The authentication process involves some redirections and requires managing
    sessions for the protected application. We’ll use Redis to maintain the sessions
    for the application. You can download Redis and execute it on your computer, but
    as we did for other recipes, you can deploy Redis on Docker. For that, just execute
    the following command in your terminal:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 认证过程涉及一些重定向，并需要管理受保护应用程序的会话。我们将使用Redis来维护应用程序的会话。您可以在您的计算机上下载Redis并执行它，但正如我们在其他食谱中所做的那样，您可以在Docker上部署Redis。为此，只需在您的终端中执行以下命令：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command will download the Redis community image if it is not yet present
    on your computer and will start the Redis server so that it’s listening on port
    `6379` without any credentials. In a production environment, you probably want
    to secure this service, but in this recipe, we’ll keep it open for simplicity.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载Redis社区镜像，如果它尚未存在于您的计算机上，并将启动Redis服务器，使其在端口`6379`上监听，无需任何凭证。在生产环境中，您可能希望保护此服务，但在本食谱中，我们将为了简单起见保持它开放。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, you’ll create a new web application and integrate it with the
    existing authorization server and the RESTful API you created in previous recipes.
    Follow these steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将创建一个新的Web应用程序并将其与您在之前的食谱中创建的现有授权服务器和RESTful API集成。按照以下步骤操作：
- en: 'First, you’ll need to create the client registration in the Authorization Server.
    For that, open the `application.yml` file in the `resources` folder of the Authorization
    Server – that is, the project you created in the *Setting up Spring Authorization
    Server* recipe. Add the new client registration, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要在授权服务器中创建客户端注册。为此，打开授权服务器`resources`文件夹中的`application.yml`文件——即您在*设置Spring授权服务器*食谱中创建的项目。添加新的客户端注册，如下所示：
- en: '[PRE18]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we want to authenticate users, you will need to create at least one user.
    To do that, in the same `application.yml` file in the Authorization Server, add
    the following configuration:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想要对用户进行认证，您至少需要创建一个用户。为此，在授权服务器中的同一`application.yml`文件中添加以下配置：
- en: '[PRE19]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `user` element should be aligned with the `oauth2` element. Remember that
    the indentation in `.yml` files is very important. You can change the username
    and password and set the values you wish.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`user`元素应与`oauth2`元素对齐。请记住，`.yml`文件中的缩进非常重要。您可以更改用户名和密码，并设置您想要的值。'
- en: Keep this configuration as you’ll use it later in the web application.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持此配置，因为您将在Web应用程序中稍后使用它。
- en: 'Now, let’s create a new Spring Boot application for our web application. You
    can use *Spring Initializr*, as you did in the *Creating a RESTful API* recipe
    in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), but change the following options:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的Web应用程序创建一个新的Spring Boot应用程序。您可以使用*Spring Initializr*，就像您在[*第1章*](B21646_01.xhtml#_idTextAnchor020)中创建RESTful
    API食谱中所做的那样，但更改以下选项：
- en: For `footballui`
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`footballui`
- en: 'For **Dependencies**, select **Spring Web**, **Thymeleaf**, **Spring Session**,
    **Spring Data Redis (Access+Driver)**, **OAuth2 Client**, and **OAuth2 Security**:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**依赖项**，选择**Spring Web**、**Thymeleaf**、**Spring Session**、**Spring Data Redis
    (Access+Driver)**、**OAuth2 Client**和**OAuth2 Security**：
- en: '![Figure 2.5: Spring Initializr options for the web application](img/B21646_02_5.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：Web应用程序的Spring Initializr选项](img/B21646_02_5.jpg)'
- en: 'Figure 2.5: Spring Initializr options for the web application'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：Web应用程序的Spring Initializr选项
- en: Click **GENERATE** to download the project template as a ZIP file. Unzip the
    file in your development folder and open it in your preferred code editor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**生成**以将项目模板作为ZIP文件下载。在您的开发文件夹中解压缩文件，并在您首选的代码编辑器中打开它。
- en: 'There is a known incompatibility between `org.thymeleaf.extras: thymeleaf-extras-springsecurity6`.
    For that, open the project’s `pom.xml` file and add the following dependency:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`org.thymeleaf.extras: thymeleaf-extras-springsecurity6`之间存在已知的兼容性问题。为此，请打开项目的`pom.xml`文件，并添加以下依赖项：'
- en: '[PRE20]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s start by creating our web pages. Since we’re following the `Controller`
    class, which will populate a model and then be presented in the view. The view
    is rendered using the Thymeleaf template engine:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建我们的Web页面。由于我们遵循`Controller`类，该类将填充模型并在视图中展示。视图是通过Thymeleaf模板引擎渲染的：
- en: 'First, create the `Controller` class and name it `FootballController` while
    providing a simple method for the home page:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建名为`FootballController`的`Controller`类，并提供一个用于主页的简单方法：
- en: '[PRE21]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method returns the name of the view. Now, we need to create the view.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法返回视图的名称。现在，我们需要创建视图。
- en: 'For the view, we should create a new template for Thymeleaf. The default template
    location is the `resources/template` folder. In the same folder, create a file
    named `home.html` with the following content:'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于视图，我们应该为Thymeleaf创建一个新的模板。默认模板位置是`resources/template`文件夹。在同一个文件夹中，创建一个名为`home.html`的文件，内容如下：
- en: '[PRE22]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a very basic page, but it now contains a link that we want to protect.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个非常基本的页面，但现在它包含了一个我们想要保护的链接。
- en: 'Now, we must configure the application so that it can be authenticated using
    the Authorization Server and force it to be authenticated for all pages except
    for the home page we just created:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须配置应用程序，使其可以使用授权服务器进行身份验证，并强制所有页面（除了我们刚刚创建的首页）进行身份验证：
- en: 'To integrate the web application with the Authorization Server, open the `application.yml`
    file in the `resources` folder and configure the OAuth2 client application, as
    follows:'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将Web应用程序与授权服务器集成，请打开`resources`文件夹中的`application.yml`文件，并配置OAuth2客户端应用程序，如下所示：
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this configuration, you’ve protected all pages, except the root. So, let’s
    create the rest of the pages.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，您已保护了所有页面，除了根页面。因此，让我们创建其余的页面。
- en: 'Next, we need to create a page to show the user information. To do that, in
    the same `FootballController` controller, create a new method, as follows:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个页面来显示用户信息。为此，在同一个`FootballController`控制器中，创建一个新的方法，如下所示：
- en: '[PRE25]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are asking Spring Boot to inject `OidcUser` as a method parameter and
    we are creating a model that we’ll use in the view named `myself`.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们要求Spring Boot将`OidcUser`注入为方法参数，并创建一个我们将用于视图的名为`myself`的模型。
- en: 'Now, create a file named `myself.html` in the `resources/templates` folder.
    Put the following content in `<body>` to show the `Model` data:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在`resources/templates`文件夹中创建一个名为`myself.html`的文件。将以下内容放入`<body>`中，以显示`Model`数据：
- en: '[PRE26]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, there is a link to `/teams`. This link will open a new page
    showing the teams. The teams page retrieves data from the RESTful API you created
    in the *Protecting a RESTful API using OAuth2 with different* *scopes* recipe.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，有一个链接到`/teams`。此链接将打开一个新的页面，显示团队。团队页面从您在*使用OAuth2和不同范围保护RESTful API*配方中创建的RESTful
    API检索数据。
- en: 'Let’s create a new method in `FootballController` so that we can get the teams.
    For that, you will get an access token by using the Spring Boot OAuth2 client:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在`FootballController`中创建一个新的方法，以便我们可以获取团队。为此，您将使用Spring Boot OAuth2客户端获取访问令牌：
- en: '[PRE27]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You need to pass the access token in the `Authorization` header, with the `Bearer`
    string as a prefix.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要在`Authorization`头中传递访问令牌，前缀为`Bearer`字符串。
- en: 'To allow the web application to use the RESTful API, you’ll need to include
    `football-ui`, the web application audience, as an accepted audience. For that,
    in the project you created in the *Protecting a RESTful API using OAuth2 with
    different scopes* recipe, open the `application.yml` file in the `resources` folder
    and add `football-ui` to the `audiences` property. The `application.yml` file
    should look like this:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要允许Web应用程序使用RESTful API，您需要将`football-ui`，Web应用程序受众，作为接受受众包括在内。为此，在您创建的*使用OAuth2和不同范围保护RESTful
    API*配方中，打开`resources`文件夹中的`application.yml`文件，并将`football-ui`添加到`audiences`属性中。`application.yml`文件应如下所示：
- en: '[PRE28]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is still an important detail we must cover before we start the new application:
    we need to configure Redis. The only settings that are required for it are `hostname`
    and `port`. For that, open the `application.yml` file of the `football-ui` project
    again and set the following configuration:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们开始新的应用程序之前，还有一个重要的细节需要说明：我们需要配置Redis。对于它，所需的唯一设置是`hostname`和`port`。为此，再次打开`football-ui`项目的`application.yml`文件，并设置以下配置：
- en: '[PRE29]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last setting to configure is the application port. The resource server
    is already using port `8080`. To avoid port conflicts, we need to change the port
    of the `football-ui` project. For that, in the same `application.yml` file, add
    the following setting:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后要配置的设置是应用程序端口号。资源服务器已经使用端口号`8080`。为了避免端口冲突，我们需要更改`football-ui`项目的端口号。为此，在同一个`application.yml`文件中，添加以下设置：
- en: '[PRE30]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can set any port that is not being used yet. Keep in mind that it’s part
    of the configuration in the Authorization Server. If you modify the port, you
    will need to modify the configuration in the authorization server.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以设置任何尚未使用的端口号。请注意，这是授权服务器配置的一部分。如果您修改端口号，您需要修改授权服务器中的配置。
- en: 'Now, you can run the application. Go to http://localhost:9080 in your browser:![Figure
    2.6: The application’s home page](img/B21646_02_6.jpg)'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序。在您的浏览器中转到http://localhost:9080：![图 2.6：应用程序的主页](img/B21646_02_6.jpg)
- en: 'Figure 2.6: The application’s home page'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：应用程序的主页
- en: 'Here, you will see the home page, which is the only route that is not protected.
    If you click on the **who you are** link, you will be redirected to the login
    page in the Authorization Server:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到主页，这是唯一一个未受保护的路由。如果您点击**你是谁**链接，您将被重定向到授权服务器的登录页面：
- en: '![Figure 2.7: Login page in the authorization server](img/B21646_02_7.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7：授权服务器中的登录页面](img/B21646_02_7.jpg)'
- en: 'Figure 2.7: Login page in the authorization server'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：授权服务器的登录页面
- en: 'Apply the username and password you configured in *Step 2* and click on the
    **Sign in** button. You’ll be redirected to the consent page, where you should
    permit the scopes being requested by the application:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应用您在*步骤 2*中配置的用户名和密码，然后点击**登录**按钮。您将被重定向到同意页面，在那里您应该允许应用程序请求的权限：
- en: '![Figure 2.8: Consent page in the authorization server](img/B21646_02_8.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8：授权服务器中的同意页面](img/B21646_02_8.jpg)'
- en: 'Figure 2.8: Consent page in the authorization server'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：授权服务器中的同意页面
- en: Click **Submit Consent**; you will be redirected to the application. The OAuth
    client application will complete the process by redeeming the access code generated
    by the authentication endpoint to obtain the ID token, access token, and refresh
    token. This part of the process is transparent for you as it’s managed by the
    OAuth2 client.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**提交同意**；您将被重定向到应用程序。OAuth客户端应用程序将通过兑换由认证端点生成的访问代码来获取ID令牌、访问令牌和刷新令牌来完成此过程。这一过程对您来说是透明的，因为它由OAuth2客户端管理。
- en: 'Once it’s done this, you’ll be returned to the application on the page you
    created to show the user authentication data:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您将返回到您创建的页面上的应用程序，以显示用户认证数据：
- en: '![Figure 2.9: Application page with user OpenID data](img/B21646_02_9.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9：包含用户OpenID数据的应用程序页面](img/B21646_02_9.jpg)'
- en: 'Figure 2.9: Application page with user OpenID data'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：包含用户OpenID数据的应用程序页面
- en: 'If you click on the `teams` data:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击`teams`数据：
- en: '![Figure 2.10: The application page showing the data from the RESTful API](img/B21646_02_10.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10：显示RESTful API数据的应用程序页面](img/B21646_02_10.jpg)'
- en: 'Figure 2.10: The application page showing the data from the RESTful API'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：显示RESTful API数据的应用程序页面
- en: With that, your web application is protected by OpenID and it can call another
    OAuth2-protected resource.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您的Web应用程序被OpenID保护，并且它可以调用另一个OAuth2受保护的资源。
- en: How it works…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this project, you protected your web application by using OIDC. It is an
    authentication protocol that is an extension of OAuth 2.0\. It provides a standardized
    way for users to log in to web applications or mobile apps using their existing
    accounts with IdPs. In our exercise, we used the Authorization Server as an IdP
    as well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您通过使用OIDC保护了您的Web应用程序。它是一种OAuth 2.0的扩展认证协议。它为用户提供了一种标准化的方式，使用他们在IdP的现有账户登录Web应用程序或移动应用程序。在我们的练习中，我们使用了授权服务器作为IdP。
- en: 'The OIDC server normally provides a discovery endpoint at `.well-known/openid-configuration`.
    If this is not provided, then it was likely hidden intentionally by the administrator.
    That endpoint provides all the information the client applications need to authenticate.
    In our application, we used the *authorization code grant flow*. It involves several
    steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC服务器通常在`.well-known/openid-configuration`提供发现端点。如果没有提供，那么它可能被管理员有意隐藏。该端点提供了客户端应用程序进行认证所需的所有信息。在我们的应用程序中，我们使用了*授权代码授权流程*。它涉及几个步骤：
- en: First, the client application redirects the user for authentication, requesting
    the required scopes for application usage.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，客户端应用程序将用户重定向到认证页面，请求应用程序使用所需的权限范围。
- en: Then, the user is authenticated. Depending on the features provided by the authorization
    server, it could use sophisticated mechanisms to validate the user, such as certificates,
    multiple authentication factors, or even biometric features.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用户完成认证。根据授权服务器提供的功能，它可能使用复杂的机制来验证用户，例如证书、多个认证因素，甚至生物识别特征。
- en: If the user is authenticated, the authorization server may ask the user for
    consent or not, depending on the scopes requested by the client application.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户已认证，授权服务器可能会根据客户端应用程序请求的权限范围要求用户同意或不需要。
- en: 'Once authenticated, the Authorization Server will redirect the user to the
    client application, providing a short-lived authorization code. Then, the client
    application will redeem the authorization code on the token endpoint (provided
    by the discovery endpoint). The authorization server will return the tokens with
    the scopes that have been consented to. The scopes that have not been consented
    by the user won’t be present in the issued tokens. The following tokens are returned
    by the authorization server:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦认证，授权服务器将用户重定向到客户端应用程序，提供一个短暂的授权代码。然后，客户端应用程序将在令牌端点（由发现端点提供）兑换授权代码。授权服务器将返回包含已同意权限范围的令牌。用户未同意的权限范围将不会出现在颁发的令牌中。授权服务器返回以下令牌：
- en: An ID token containing the session information. This token should not be used
    for authorization, just for authentication purposes.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含会话信息的ID令牌。此令牌不应用于授权，仅用于认证目的。
- en: An access token, which contains the authorization information, such as the scopes
    that have been consented. If the application requires a scope, it should validate
    the scopes returned and manage them accordingly.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌包含授权信息，例如已同意的权限范围。如果应用程序需要权限范围，它应验证返回的权限范围并相应地管理它们。
- en: A refresh token, which is used to get new tokens before they expire.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新令牌，用于在令牌过期前获取新令牌。
- en: Since many redirects are involved in this process, the client application needs
    to keep the state of the user, hence the requirement for session management. The
    Spring Framework provides a convenient way to manage sessions using Redis.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此过程中涉及许多重定向，客户端应用程序需要保持用户状态，因此需要会话管理。Spring框架提供了一个方便的方法来使用Redis管理会话。
- en: Keep in mind that the client application needs to access the discovery endpoint
    when it starts. For that reason, remember to start your authorization server before
    the client application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，客户端应用程序在启动时需要访问发现端点。因此，请记住在客户端应用程序启动之前启动您的授权服务器。
- en: In this exercise, you configured the root page as the only permitted page without
    authentication. To access any other page, it must be authenticated. For that reason,
    just by trying to navigate to `/myself` or `/teams`, the authorization process
    is initiated.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已将根页面配置为唯一允许的无认证页面。要访问任何其他页面，都必须进行认证。因此，仅通过尝试导航到`/myself`或`/teams`，就会启动授权过程。
- en: See also
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Many modern applications are SPA. This type of application runs mostly in the
    browser. Also, note that many libraries implement OIDC. I recommend using an OpenID-certified
    library as they are validated by peers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代应用程序都是SPA（单页应用程序）。这类应用程序主要在浏览器中运行。此外，请注意，许多库实现了OIDC（OpenID Connect）。我建议使用经过OpenID认证的库，因为它们已经过同行验证。
- en: Even with the growing popularity of SPA, I haven’t explained the authentication
    of this type of application as it is not related to Spring Boot. However, if you
    are interested in integrating an SPA with Spring Authorization Server, I recommend
    following the guidelines from the Spring OAuth2 Authorization Server project at
    https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-pkce.html.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 即使单页应用程序（SPA）越来越受欢迎，我还没有解释这种类型应用程序的认证，因为它与 Spring Boot 无关。然而，如果您有兴趣将 SPA 与 Spring
    授权服务器集成，我建议您遵循 Spring OAuth2 授权服务器项目在 https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-pkce.html
    上的指南。
- en: Logging in with Google Accounts
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google 账户登录
- en: 'You have a new requirement for your football application: your users want to
    log in to your application using their Gmail accounts.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您的足球应用程序有了新的需求：您的用户希望使用他们的 Gmail 账户登录到您的应用程序。
- en: To implement this scenario, you will configure your Authorization Server as
    an OAuth2 client, with Google Accounts being their IdP. You will learn how to
    create an OAuth2 Client ID in Google Cloud and integrate it into your application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此场景，您需要将您的授权服务器配置为 OAuth2 客户端，Google 账户作为其身份提供者（IdP）。您将学习如何在 Google Cloud
    中创建 OAuth2 客户端 ID 并将其集成到您的应用程序中。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will reuse the Spring Authorization Server you created
    in the *Setting up Spring Authorization Server* and *Protecting a RESTful API
    using OAuth2 with different scopes* recipes, as well as the web application you
    created in the *Configuring an MVC application with OpenID authentication* recipe.
    The MVC application stores sessions in Redis. You can run a Redis server in Docker,
    as explained in the *Configuring an MVC application with OpenID* *authentication*
    recipe.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，您将重用您在 *设置 Spring 授权服务器* 和 *使用 OAuth2 和不同作用域保护 RESTful API* 食谱中创建的 Spring
    授权服务器，以及您在 *配置具有 OpenID 认证的 MVC 应用程序* 食谱中创建的 Web 应用程序。MVC 应用程序将会话存储在 Redis 中。您可以在
    Docker 中运行 Redis 服务器，如 *配置具有 OpenID 认证的 MVC 应用程序* 食谱中所述。
- en: I’ve prepared a working version of the required recipes in case you haven’t
    completed them yet. You can find them in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-5/start` folder.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未完成这些食谱，我已经准备了一个工作版本。您可以在本书的 GitHub 仓库 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
    中的 `chapter4/recipe4-5/start` 文件夹中找到它们。
- en: As you will integrate the application with Google Accounts, you will need a
    Google Account. If you don’t have a Google Account yet, you can create one at
    [https://accounts.google.com](https://accounts.google.com).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将应用程序与 Google 账户集成，您需要一个 Google 账户。如果您还没有 Google 账户，您可以在 [https://accounts.google.com](https://accounts.google.com)
    上创建一个。
- en: How to do it…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s start by creating an OAuth2 client in Google and then use the configuration
    provided to configure our Authorization Server so that it can log in to your application
    using GoogleAaccounts:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Google 中创建一个 OAuth2 客户端开始，然后使用提供的配置来配置我们的授权服务器，以便它可以使用 Google 账户登录到您的应用程序：
- en: 'Let’s start by opening the Google Cloud console at [https://console.cloud.google.com/](https://console.cloud.google.com/).
    You will need to log in using your Google Account. Once you’ve done this, you
    will see the Google Cloud home page:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开 Google Cloud 控制台 [https://console.cloud.google.com/](https://console.cloud.google.com/)
    开始。您需要使用您的 Google 账户登录。一旦完成，您将看到 Google Cloud 主页：
- en: 'First, you’ll need to create a project:'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个项目：
- en: '![Figure 2.11: The Google Cloud home page](img/B21646_02_11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11：Google Cloud 主页](img/B21646_02_11.jpg)'
- en: 'Figure 2.11: The Google Cloud home page'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：Google Cloud 主页
- en: To create the project, click **Select** **a project**.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建项目，请点击**选择** **项目**。
- en: 'In the **Select a project** dialogue, click **NEW PROJECT**:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选择项目** 对话框中，点击 **新建项目**：
- en: '![Figure 2.12: Creating a new project](img/B21646_02_12.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12：创建新项目](img/B21646_02_12.jpg)'
- en: 'Figure 2.12: Creating a new project'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：创建新项目
- en: 'Name the project – for instance, `springboot3-cookbook`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名项目 – 例如，`springboot3-cookbook`：
- en: '![Figure 2.13: New Project settings](img/B21646_02_13.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13：新建项目设置](img/B21646_02_13.jpg)'
- en: 'Figure 2.13: New Project settings'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：新建项目设置
- en: Click **CREATE**. This process will take a few moments. A notification will
    appear when it is completed. Once created, select the project.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建**。这个过程需要几分钟。完成后将出现通知。创建完成后，选择项目。
- en: 'Now that we have a project, let’s configure the consent page for our web application.
    For that, open the **APIs & Services** menu and choose **Credentials**:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个项目，让我们为我们的 Web 应用程序配置同意页面。为此，打开**APIs & Services**菜单并选择**凭据**：
- en: '![Figure 2.14: The Credentials menu](img/B21646_02_14.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14：凭据菜单](img/B21646_02_14.jpg)'
- en: 'Figure 2.14: The Credentials menu'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14：凭据菜单
- en: 'On the **Credentials** page, you will see a reminder to create the consent
    page for the application:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在**凭据**页面上，您将看到一个创建应用程序同意页面的提醒：
- en: '![Figure 2.15: The Credentials home page with a reminder to configure the OAuth
    consent screen highlighted](img/B21646_02_15.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15：带有突出显示配置 OAuth 同意屏幕的凭据主页](img/B21646_02_15.jpg)'
- en: 'Figure 2.15: The Credentials home page with a reminder to configure the OAuth
    consent screen highlighted'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15：带有突出显示配置 OAuth 同意屏幕的凭据主页
- en: Click on the **CONFIGURE CONSENT SCREEN** button and follow the instructions
    to configure the consent page. For **User Type**, select **External** and click
    **CREATE**.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**配置同意屏幕**按钮并按照说明配置同意页面。对于**用户类型**，选择**外部**并点击**创建**。
- en: With this type of user, the application will start in testing mode. This means
    that only some test users will be able to use it. Once you’ve completed the development
    process and the application is ready, you can publish it. To do this, your site
    must be verified. We won’t publish the application in this recipe, but if you
    plan to use it in your application, you’ll need to complete this step.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类用户，应用程序将以测试模式启动。这意味着只有一些测试用户能够使用它。一旦您完成开发过程并且应用程序准备就绪，您就可以发布它。为此，您的网站必须经过验证。我们不会在这个菜谱中发布应用程序，但如果您计划在应用程序中使用它，您需要完成此步骤。
- en: 'After selecting **External** for **User Type**, there is a four-step process
    you must go through:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择**用户类型**为**外部**后，您必须完成以下四个步骤：
- en: 'First, we have the **OAuth** **consent** screen:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有**OAuth** **同意**屏幕：
- en: Here, you should configure the application’s name. You can set it as **Spring
    Boot 3 Cookbook**, for instance.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，您应该配置应用程序的名称。例如，您可以将其设置为**Spring Boot 3 烹饪书**。
- en: You should configure a user support email. You can use the same email address
    that you use for your Google Account.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该配置一个用户支持电子邮件地址。您可以使用与您的 Google 账户相同的电子邮件地址。
- en: You should also configure the Developer Contact Information email. Again, you
    can use the same email address that you use for your Google Account.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还应该配置开发者联系信息电子邮件。同样，您可以使用与您的 Google 账户相同的电子邮件地址。
- en: The rest of the parameters are optional. We don’t need to configure them for
    now.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的参数是可选的。我们现在不需要配置它们。
- en: 'For **Update selected scopes**, click **ADD OR REMOVE SCOPES** and select **openid**,
    **userinfo.email**, and **userinfo.profile**:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**更新选定的作用域**，点击**添加或删除作用域**并选择**openid**、**userinfo.email**和**userinfo.profile**：
- en: '![Figure 2.16: Selecting scopes](img/B21646_02_16.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16：选择作用域](img/B21646_02_16.jpg)'
- en: 'Figure 2.16: Selecting scopes'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：选择作用域
- en: Then, click **UPDATE**.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**更新**。
- en: In **test users** step, click **ADD USERS** to add some testing users who will
    be able to access the application before it’s published. You can add a different
    Google Account to test the application.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**测试用户**步骤中，点击**添加用户**以添加一些测试用户，他们将在应用程序发布之前能够访问应用程序。您可以添加不同的 Google 账户来测试应用程序。
- en: In the **summary** step, you will see a summary of your consent screen. You
    can click **BACK TO DASHBOARD** to return to the **OAuth consent** **screen**
    page.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**摘要**步骤中，您将看到您的同意屏幕的摘要。您可以点击**返回仪表板**以返回到**OAuth 同意****屏幕**页面。
- en: 'Next, we will create the client credentials. For that, once again, navigate
    to the **Credentials** page, as shown in *Figure 2**.17*. Once you are on the
    **Credentials** page, click **+ CREATE CREDENTIALS** and select **OAuth** **client
    ID**:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建客户端凭据。为此，再次导航到**凭据**页面，如图 *图 2**.17* 所示。一旦你进入**凭据**页面，点击**+ 创建凭据**并选择**OAuth**
    **客户端 ID**：
- en: '![Figure 2.17: Selecting OAuth client ID credentials](img/B21646_02_17.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17：选择 OAuth 客户端 ID 凭据](img/B21646_02_17.jpg)'
- en: 'Figure 2.17: Selecting OAuth client ID credentials'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17：选择 OAuth 客户端 ID 凭据
- en: For **Application type**, select **Web application**
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**应用程序类型**，选择**Web 应用程序**
- en: For `football-gmail`
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`football-gmail`
- en: 'For **Authorized redirect URIs**, add http://localhost:9000/login/oauth2/code/football-gmail:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**授权重定向 URI**，添加 http://localhost:9000/login/oauth2/code/football-gmail：
- en: '![Figure 2.18: Creating an OAuth client ID](img/B21646_02_18.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18：创建 OAuth 客户端 ID](img/B21646_02_18.jpg)'
- en: 'Figure 2.18: Creating an OAuth client ID'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18：创建 OAuth 客户端 ID
- en: 'Click **CREATE**. A dialogue box will appear, informing you that the client
    was created and showing you the **Client ID** and **Client secret** details. We’ll
    need this data to configure the Authorization Server, so keep it safe:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建**。将出现一个对话框，告知你客户端已创建，并显示**客户端ID**和**客户端密钥**详细信息。我们需要这些数据来配置授权服务器，所以请妥善保管：
- en: '![Figure 2.19: OAuth client created](img/B21646_02_19.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19：创建的OAuth客户端](img/B21646_02_19.jpg)'
- en: 'Figure 2.19: OAuth client created'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：创建的OAuth客户端
- en: There is a button to download a JSON file containing the configuration. Click
    on it and save the JSON file in a secure place as it contains the credentials
    that are required to use the client.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个按钮可以下载包含配置的JSON文件。点击它并将JSON文件保存在安全的地方，因为它包含使用客户端所需的凭证。
- en: 'Now, we can configure the Spring OAuth2 Authorization Server:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以配置Spring OAuth2授权服务器：
- en: 'First, we need to add the OAuth2 client dependency. For that, open the `pom.xml`
    file and add the following dependency:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加OAuth2客户端依赖项。为此，打开`pom.xml`文件并添加以下依赖项：
- en: '[PRE31]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, open the `application.yml` file in the `resources` folder and add the
    client configuration for Google:'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`resources`文件夹中的`application.yml`文件，并添加Google的客户端配置：
- en: '[PRE32]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Replace the `client-id` and `client-secret` fields with the values you obtained
    in *Step 2*.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`client-id`和`client-secret`字段替换为你在*步骤2*中获得的值。
- en: 'The last step to configure the Authorization Server is defining the behavior
    of the security checks. For that, create a configuration class named `SecurityConfig`:'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置授权服务器的最后一步是定义安全检查的行为。为此，创建一个名为`SecurityConfig`的配置类：
- en: '[PRE33]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, add a `SecurityFilterChain` bean:'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个`SecurityFilterChain`豆：
- en: '[PRE34]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code configures Spring Security to use OAuth 2.0 and OpenID Connect
    1.0 for authentication, as well as to accept JWT access tokens for certain requests.
    For instance, it will accept requests that provide JWT access tokens to get user
    information.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码配置了Spring Security使用OAuth 2.0和OpenID Connect 1.0进行身份验证，以及接受某些请求的JWT访问令牌。例如，它将接受提供JWT访问令牌以获取用户信息的请求。
- en: 'You will also need to add another `SecurityFilterChain` bean but with less
    priority. It will initiate the OAuth2 login process, which means it will initiate
    the authentication as a client application in Google, as configured in the `application.yml`
    file:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还需要添加另一个`SecurityFilterChain`豆，但优先级较低。它将启动OAuth2登录过程，这意味着它将以客户端应用程序的身份启动身份验证，如`application.yml`文件中配置的那样：
- en: '[PRE35]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code configures Spring Security to require authentications for
    all requests and to use OAuth 2.0 for logging in.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码配置了Spring Security，要求对所有请求进行身份验证，并使用OAuth 2.0进行登录。
- en: 'With that, your OAuth2 Authorization Server has been configured to require
    authentication using Google Accounts. Now, you can run all your environments:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样，你的OAuth2授权服务器已经配置为要求使用Google账户进行身份验证。现在，你可以运行所有环境：
- en: Run the Authorization Server you just configured
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你刚刚配置的授权服务器
- en: Run the RESTful API server you created in the *Protecting a RESTful API using
    OAuth2 with different* *scopes* recipe
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你在“使用不同*作用域*配置OAuth2保护RESTful API”菜谱中创建的RESTful API服务器
- en: Run the web application you created in the *Configuring an MVC application with
    OpenID* *authentication* recipe
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你在“使用OpenID身份验证配置MVC应用程序”菜谱中创建的Web应用程序
- en: 'When you navigate to `http://localhost:9080/myself`, you will be asked to log
    in using a Google Account:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你导航到`http://localhost:9080/myself`时，你将需要使用Google账户进行登录：
- en: '![Figure 2.20: Logging in using a Google Account](img/B21646_02_20.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20：使用Google账户登录](img/B21646_02_20.jpg)'
- en: 'Figure 2.20: Logging in using a Google Account'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：使用Google账户登录
- en: Once you’ve logged in, you will see that the application is the same. You can
    now use the claims issued by the Authorization Server and invoke the RESTful API.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你会看到应用程序是相同的。现在，你可以使用授权服务器颁发的声明来调用RESTful API。
- en: How it works…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Because we’re using the Authorization Server with just the login delegated in
    Google, the Authorization Server doesn’t need to maintain a user repository, though
    it still has the responsibility of issuing tokens. This means that when the application
    requests to identify a user, the Authorization Server redirects the login to Google.
    Once back, the Authorization Server continues issuing tokens. Due to this, you
    didn’t need to change the code in the MVC web application or the RESTful API.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仅使用Google进行登录委派，因此授权服务器不需要维护用户存储库，尽管它仍然负责发行令牌。这意味着当应用程序请求识别用户时，授权服务器将登录重定向到Google。一旦返回，授权服务器将继续发行令牌。因此，您不需要更改MVC
    Web应用程序或RESTful API中的代码。
- en: It is possible to configure the MVC application so that it bypasses the authorization
    server and logs in to Google Accounts directly. You just need to replace the OAuth2
    client configuration in the MVC web application with the client configuration
    you used in the Authorization server. However, in that case, you won’t be able
    to use the access tokens that have been issued by Google to protect your RESTful
    API. This is because Google access tokens are intended to be used with Google
    services only and they are not standard JWT.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置MVC应用程序，使其绕过授权服务器并直接登录到Google账户。您只需将MVC Web应用程序中的OAuth2客户端配置替换为在授权服务器中使用的客户端配置即可。然而，在这种情况下，您将无法使用Google发行的访问令牌来保护您的RESTful
    API。这是因为Google访问令牌仅用于Google服务，并且它们不是标准的JWT。
- en: The main complexity is configuring the security chain as there are many options
    available. In the `SecurityConfig` class, there are two `Beans` with different
    priorities.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 主要复杂性在于配置安全链，因为有许多选项可用。在`SecurityConfig`类中，有两个具有不同优先级的`Beans`。
- en: The `SecurityConfig` class defines two `SecurityFilterChain` beans. Here, `SecurityFilterChain`
    is essentially a chain of filters that Spring Security uses to perform various
    security checks. Each filter in the chain has a specific role, such as authenticating
    the user.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityConfig`类定义了两个`SecurityFilterChain` bean。在这里，`SecurityFilterChain`实际上是Spring
    Security用于执行各种安全检查的过滤器链。链中的每个过滤器都有特定的角色，例如用户身份验证。'
- en: The first `SecurityFilterChain` bean is defined with an order of 1, meaning
    it will be the first filter chain to be consulted. This filter chain has been
    configured to apply default security settings for an OAuth 2.0 authorization server.
    It also enables OpenID Connect 1.0 via the `oidc(Customizer.withDefaults())` method
    call.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`SecurityFilterChain` bean的顺序设置为1，这意味着它将是第一个被咨询的过滤器链。此过滤器链已配置为为OAuth 2.0授权服务器应用默认安全设置。它还通过`oidc(Customizer.withDefaults())`方法调用启用OpenID
    Connect 1.0。
- en: The configuration also specifies that if a user is not authenticated, they should
    be redirected to the OAuth 2.0 login endpoint. This is done using `LoginUrlAuthenticationEntryPoint`
    with a URL of `/oauth2/authorization/football-gmail`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 配置还指定，如果用户未经过身份验证，则应将其重定向到OAuth 2.0登录端点。这是通过使用具有URL `/oauth2/authorization/football-gmail`
    的`LoginUrlAuthenticationEntryPoint`来完成的。
- en: The filter chain is also configured to accept JWT access tokens for user info
    and/or client registration. This is done using the `oauth2ResourceServer((oauth2)
    -> oauth2.jwt(Customizer.withDefaults()))` method call.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器链还配置为接受JWT访问令牌用于用户信息和/或客户端注册。这是通过使用`oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults()))`方法调用来完成的。
- en: The second `SecurityFilterChain` bean is defined with an order of 2, meaning
    it will be consulted if the first filter chain does not handle the request. The
    `anyRequest().authenticated()` chain of methods means that any request must be
    authenticated.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`SecurityFilterChain` bean的顺序设置为2，这意味着如果第一个过滤器链没有处理请求，则会咨询它。`anyRequest().authenticated()`
    方法链意味着任何请求都必须经过身份验证。
- en: The `oauth2Login(Customizer.withDefaults())` method call configures the application
    to use OAuth 2.0 for authentication. The `Customizer.withDefaults()` method call
    is used to apply the default configuration for OAuth 2.0 login.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`oauth2Login(Customizer.withDefaults())` 方法调用配置应用程序使用OAuth 2.0进行身份验证。`Customizer.withDefaults()`
    方法调用用于应用OAuth 2.0登录的默认配置。'
- en: See also
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: As you can see, integrating a third-party authentication in the Authorization
    Server just requires configuring the client application for the IdP. So, if you
    need to integrate with another social provider, you will need to obtain the client
    application data.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在授权服务器中集成第三方身份验证只需配置IdP的客户端应用程序。因此，如果您需要与另一个社交提供者集成，您将需要获取客户端应用程序数据。
- en: If you want to integrate with GitHub, you can create an application registration
    on the https://github.com/settings/developers page.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想与 GitHub 集成，您可以在 https://github.com/settings/developers 页面上创建一个应用注册。
- en: For Facebook, you can create your application on the developer’s page at https://developers.facebook.com/apps.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Facebook，您可以在 https://developers.facebook.com/apps 开发者页面上创建您的应用程序。
- en: Integrating a RESTful API with a cloud IdP
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RESTful API 与云身份提供者（IdP）集成
- en: Now that your application is becoming more and more popular, you decide to delegate
    your authentication to a cloud IdP as they offer advanced protection for sophisticated
    threats. You decide to use Azure AD B2C. This service is intended for public-facing
    applications, allowing customers to sign in and sign up, as well as customize
    the user journey, social network integration, and other interesting features.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序越来越受欢迎，您决定将身份验证委托给云身份提供者（IdP），因为它们提供了针对复杂威胁的高级保护。您决定使用 Azure AD B2C。此服务旨在面向公众的应用程序，允许客户登录和注册，以及自定义用户旅程、社交网络集成和其他有趣的功能。
- en: What you’ll learn in this recipe can be applied to other cloud IdPs, such as
    Okta, AWS Cognito, Google Firebase, and many others. Spring Boot offers specialized
    starters that simplify the process of integrating with an IdP even more.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中您将学习的内容可以应用于其他云身份提供者，例如 Okta、AWS Cognito、Google Firebase 以及许多其他。Spring
    Boot 提供了专门的启动器，可以进一步简化与身份提供者（IdP）集成的过程。
- en: Getting ready
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll integrate the application you prepared in the *Configuring
    an MVC application with OpenID authentication* recipe. If you haven’t completed
    that recipe yet, I’ve prepared a working version that you can find in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter4/recipe4-6/start` folder. This recipe also requires Redis, as
    explained in the *Configuring an MVC application with OpenID authentication* recipe.
    The easiest way to deploy it on your computer is by using Docker.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将集成在 *使用 OpenID 身份验证配置 MVC 应用程序* 配方中准备的应用程序。如果您还没有完成该配方，我已准备了一个可在此书的
    GitHub 仓库中找到的工作版本，该仓库位于 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
    的 `chapter4/recipe4-6/start` 文件夹中。本配方还要求使用 Redis，如 *使用 OpenID 身份验证配置 MVC 应用程序*
    配方中所述。在您的计算机上部署它的最简单方法是使用 Docker。
- en: As we’ll be integrating with Azure AD B2C, you will need an Azure subscription.
    If you don’t have one, you can create a free account at https://azure.microsoft.com/free.
    Azure AD B2C offers a free tier that allows up to 50,000 monthly active users.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将与 Azure AD B2C 集成，您需要一个 Azure 订阅。如果您没有，您可以在 https://azure.microsoft.com/free
    上创建一个免费账户。Azure AD B2C 提供了一个免费层，允许每月最多 50,000 活跃用户。
- en: If you don’t have an Azure AD B2C tenant, please follow the instructions at
    [https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant](https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant)
    to create one before starting this recipe.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有 Azure AD B2C 租户，请在开始此配方之前按照[https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant](https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant)中的说明创建一个。
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to build a smooth sign-in/signup process with Azure AD B2C
    and learn how to connect it seamlessly with your Spring Boot application for large-scale
    user authentication:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建与 Azure AD B2C 的顺畅登录/注册流程，并学习如何将其无缝连接到您的 Spring Boot 应用程序以进行大规模用户身份验证：
- en: 'The first thing you’ll need to do is create an application registration in
    Azure AD B2C. An application registration is the same as the client registration
    you created in Spring Authorization Server in previous recipes. You can create
    the application registration in the **App** **registrations** section:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是在 Azure AD B2C 中创建一个应用注册。应用注册与您在之前配方中在 Spring Authorization Server
    中创建的客户端注册相同。您可以在 **应用** **注册** 部分创建应用注册：
- en: '![Figure 2.21: Creating an app registration in Azure AD B2C](img/B21646_02_21.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21：在 Azure AD B2C 中创建应用注册](img/B21646_02_21.jpg)'
- en: 'Figure 2.21: Creating an app registration in Azure AD B2C'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21：在 Azure AD B2C 中创建应用注册
- en: On the `Football UI`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Football UI` 上。
- en: 'For `http://localhost:9080/login/oauth/code` as the value of the redirect UI:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `http://localhost:9080/login/oauth/code` 作为重定向 UI 的值：
- en: '![Figure 2.22: Application registration options in Azure AD B2C](img/B21646_02_22.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22：Azure AD B2C 中的应用注册选项](img/B21646_02_22.jpg)'
- en: 'Figure 2.22: Application registration options in Azure AD B2C'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22：Azure AD B2C 中的应用注册选项
- en: Click **Register** to continue with the application registration process.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**注册**以继续应用程序注册过程。
- en: 'Once you have created the application registration, you need to configure a
    client secret. You can do this in the **Certificates & secrets** section of the
    application registration you’ve created:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了应用程序注册，你需要配置一个客户端秘密。你可以在你创建的应用程序注册的**证书和秘密**部分中这样做：
- en: '![Figure 2.23: Creating a new client secret](img/B21646_02_23.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23：创建新的客户端秘密](img/B21646_02_23.jpg)'
- en: 'Figure 2.23: Creating a new client secret'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23：创建新的客户端秘密
- en: Once you’ve created the secret, the secret value generated by Azure AD B2C will
    appear. You should copy the value now as it won’t be accessible again. Keep it
    safe as you’ll need it later.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建了秘密，Azure AD B2C 生成的秘密值将出现。你现在应该复制这个值，因为它将不再可用。请妥善保管，因为你稍后需要它。
- en: 'Finally, we must create a user flow. A user flow is a configuration policy
    that can be used to set up the authentication experience for end users. Set the
    following options:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须创建一个用户流程。用户流程是一个配置策略，可以用来设置最终用户的认证体验。设置以下选项：
- en: For `SUSI`; this is an acronym for “sign up and sign in.”
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `SUSI`；这是一个代表“注册和登录”的缩写。
- en: For **Identity providers**, select **Email signup**.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**身份提供者**，选择**电子邮件注册**。
- en: For **User attributes and token claims**, select **Given Name** and **Surname**.
    For both attributes, check the **Collect attribute** and **Return** **claim**
    boxes.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**用户属性和令牌声明**，选择**给定名**和**姓氏**。对于这两个属性，勾选**收集属性**和**返回****声明**框。
- en: 'Keep the rest of the options as-is:'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持其余选项不变：
- en: '![Figure 2.24: The Create a user flow page](img/B21646_02_24.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24：创建用户流程页面](img/B21646_02_24.jpg)'
- en: 'Figure 2.24: The Create a user flow page'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24：创建用户流程页面
- en: Click **Create** to create the user flow.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建**以创建用户流程。
- en: 'Now, let’s configure our application. First, you’ll need to add the appropriate
    dependencies. For that, open the `pom.xml` file of the web application and add
    the `org.springframework.boot:spring-boot-starter-oauth2-client` dependency:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们配置我们的应用程序。首先，你需要添加适当的依赖项。为此，打开 Web 应用程序的 `pom.xml` 文件并添加 `org.springframework.boot:spring-boot-starter-oauth2-client`
    依赖项：
- en: '[PRE36]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, you’ll need to configure the Azure AD B2C settings in the `application.yml`
    file in the `resources` folder. Replace the Oauth2 client settings with the B2C
    ones. The file should look as follows:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要在 `resources` 文件夹中的 `application.yml` 文件中配置 Azure AD B2C 设置。用 B2C 设置替换
    Oauth2 客户端设置。文件应如下所示：
- en: '[PRE37]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `client-secret` field, set the value you kept in *Step 4*. I recommend
    enclosing the secret value in quotation marks since the secret likely contains
    reserved characters that can cause unexpected behavior when the `application.yaml`
    file is being processed.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `client-secret` 字段中，设置你在*步骤 4*中保留的值。我建议将秘密值用引号括起来，因为秘密可能包含保留字符，这可能导致在处理 `application.yaml`
    文件时出现意外的行为。
- en: 'To complete the OpenID configuration to allow users to log in to your application
    with Azure AD B2C, you’ll need to adjust the security chain by applying an Azure
    AD OIDC configurer. To do this, modify the `SecurityConfiguration` class by adding
    `AadB2cOidcLoginConfigurer` in the constructor to allow bean injection, and then
    use it in the existing `defaultSecurityFilterChain` method, as follows:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成 OpenID 配置，允许用户使用 Azure AD B2C 登录你的应用程序，你需要通过应用 Azure AD OIDC 配置器来调整安全链。为此，通过在构造函数中添加
    `AadB2cOidcLoginConfigurer` 允许 Bean 注入来修改 `SecurityConfiguration` 类，然后在现有的 `defaultSecurityFilterChain`
    方法中使用它，如下所示：
- en: '[PRE38]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, you can run your web application and authenticate with Azure
    AD B2C. However, there’s still something pending that’s protecting the RESTful
    API server with Azure AD B2C.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到这一点，你可以运行你的 Web 应用程序并通过 Azure AD B2C 进行认证。然而，还有一件事待办，那就是用 Azure AD B2C 保护 RESTful
    API 服务器。
- en: 'To get around this, you can modify the dependencies. For that, open the `pom.xml`
    file of the RESTful API project and replace the `org.springframework.boot: spring-boot-starter-oauth2-resource-server`
    dependency with `com.azure.spring:spring-cloud-azure-starter-active-directory-b2c`:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以修改依赖项。为此，打开 RESTful API 项目的 `pom.xml` 文件，并将 `org.springframework.boot:spring-boot-starter-oauth2-resource-server`
    依赖项替换为 `com.azure.spring:spring-cloud-azure-starter-active-directory-b2c`：
- en: '[PRE39]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, modify the `application.yml` file so that it configures the Azure B2C
    client registration:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改 `application.yml` 文件，以便它配置 Azure B2C 客户端注册：
- en: '[PRE40]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, you can run both the web application and the RESTful server since both
    are protected with Azure AD B2C:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行 Web 应用程序和 RESTful 服务器，因为它们都受到 Azure AD B2C 的保护：
- en: 'Open your browser and navigate to `http://localhost:8080/myself`. As the method
    is protected, you will be redirected to the **Azure AD B2C Sign up or sign** **in**
    page:'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的浏览器并导航到`http://localhost:8080/myself`。由于该方法受保护，你将被重定向到**Azure AD B2C注册或登录**页面：
- en: '![Figure 2.25: The Azure AD B2C default Sign up or sign in page](img/B21646_02_25.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图2.25：Azure AD B2C默认的注册或登录页面](img/B21646_02_25.jpg)'
- en: 'Figure 2.25: The Azure AD B2C default Sign up or sign in page'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25：Azure AD B2C默认的注册或登录页面
- en: 'If you click on the **Sign up now** link, you can create a new user:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击**立即注册**链接，你可以创建一个新用户：
- en: '![Figure 2.26: Sign-up page](img/B21646_02_26.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图2.26：注册页面](img/B21646_02_26.jpg)'
- en: 'Figure 2.26: Sign-up page'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26：注册页面
- en: The first step is to provide a valid email address. Once you’ve done this click
    **Send verification code**. You will receive an email containing a verification
    code that you will need to provide on this page. Once verified, you can introduce
    the rest of the fields.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是提供一个有效的电子邮件地址。一旦你完成这个步骤，点击**发送验证码**。你将收到一封包含验证码的电子邮件，你需要在页面上提供这个验证码。一旦验证成功，你就可以填写其余字段。
- en: 'When you return to the page, you will see the claims that have been provided
    by Azure AD B2C:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你返回到页面时，你会看到Azure AD B2C提供的声明：
- en: '![Figure 2.27: Our web page showing the claims from Azure B2C](img/B21646_02_27.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图2.27：我们的网页显示了Azure B2C提供的声明](img/B21646_02_27.jpg)'
- en: 'Figure 2.27: Our web page showing the claims from Azure B2C'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27：我们的网页显示了Azure B2C提供的声明
- en: If you click on the **Teams** link, you will see the same data that you did
    in the *Configuring an MVC application with OpenID* *authentication* recipe.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击**团队**链接，你会看到与在*使用OpenID身份验证配置MVC应用程序*菜谱中看到相同的数据。
- en: 'If you click on the **Logout** link, you will be redirected to the default
    logout page:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击**注销**链接，你将被重定向到默认的注销页面：
- en: '![Figure 2.28: The default logout page](img/B21646_02_28.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图2.28：默认的注销页面](img/B21646_02_28.jpg)'
- en: 'Figure 2.28: The default logout page'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28：默认的注销页面
- en: Finally, if you click on the **Log Out** button, you will be redirected to the
    logout endpoint in Azure AD B2C.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果你点击**注销**按钮，你将被重定向到Azure AD B2C的注销端点。
- en: How it works…
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `com.azure.spring:spring-cloud-azure-starter-active-directory-b2c` dependency
    includes both the Spring OAuth2 client and Spring OAuth2 resource starters that
    we used in previous recipes. On top of those starters, it also includes specific
    components to adapt the Azure AD B2C-specific features. For instance, the discovery
    endpoint cannot be inferred just from the issuer URL as it is dependent on the
    Azure AD B2C policy being used.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.azure.spring:spring-cloud-azure-starter-active-directory-b2c`依赖项包括我们在之前的菜谱中使用的Spring
    OAuth2客户端和Spring OAuth2资源启动器。在这些启动器之上，它还包括特定组件以适应Azure AD B2C特定的功能。例如，发现端点不能仅从发行者URL推断出来，因为它依赖于正在使用的Azure
    AD B2C策略。'
- en: The Azure AD B2C starter maps the configuration used in the Azure portal to
    the configuration on your `application.yml` file. Apart from that, the application
    doesn’t require specific changes as it follows the OAuth2 specification.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Azure AD B2C入门教程将Azure门户中使用的配置映射到`application.yml`文件上的配置。除此之外，应用程序不需要进行特定更改，因为它遵循OAuth2规范。
- en: In Azure AD B2C, we defined an app registration. This is equivalent to the concept
    of a client in Spring Authorization Server.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure AD B2C中，我们定义了一个应用程序注册。这相当于Spring Authorization Server中的客户端概念。
- en: Azure AD B2C allows us to define different policies so that we can customize
    the user experience. We created a policy that performs the sign-up and sign-in
    process using the default settings, but you can define an edit profile or reset
    password policy as well. Other interesting capabilities include defining custom
    interfaces and integrating other IdPs. For instance, it’s quite easy to integrate
    with cloud providers such as Google Accounts, social network providers such as
    Facebook and Instagram, and enterprise IdPs such as Azure Entra.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Azure AD B2C 允许我们定义不同的策略，以便我们可以自定义用户体验。我们创建了一个使用默认设置的注册和登录流程的策略，但你也可以定义编辑个人资料或重置密码策略。其他有趣的特性包括定义自定义界面和集成其他身份提供者。例如，与谷歌账户、社交媒体提供者如Facebook和Instagram以及企业身份提供者如Azure
    Entra集成相当容易。
- en: One of the main advantages of this solution is that users can register themselves;
    they don’t need an administrator to do this for them.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的主要优势之一是用户可以自己注册；他们不需要管理员为他们做这件事。
- en: This recipe doesn’t intend to review all the possibilities of Azure AD B2C –
    it’s been provided to help you understand how to integrate your Spring Boot application
    with Azure AD B2C.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方并不打算回顾 Azure AD B2C 的所有可能性——它已经提供，以帮助您了解如何将您的 Spring Boot 应用程序与 Azure AD
    B2C 集成。
- en: There’s more…
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An interesting and probably more frequent scenario is when our RESTful API
    uses a different application registration than the UI application. When I build
    a RESTful API, I usually design it while keeping one thing in mind: more than
    one client should be able to consume it. This works for different scenarios, such
    as the web and mobile versions, or allowing a third-party application to consume
    some of the APIs. In that scenario, you can create a dedicated application registration
    for your RESTful API and create different application roles with different access
    levels. Then, you can assign the corresponding role to the consumer applications.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣且可能更常见的场景是，当我们的 RESTful API 使用与 UI 应用程序不同的应用程序注册时。当我构建 RESTful API 时，我通常会考虑一件事：应该让多个客户端能够消费它。这适用于不同的场景，例如网页和移动版本，或者允许第三方应用程序消费一些
    API。在这种情况下，您可以为您 RESTful API 创建一个专门的应用程序注册，并创建具有不同访问级别的不同应用程序角色。然后，您可以将相应的角色分配给消费者应用程序。
- en: 'When you create the application registration for the RESTful API, you can create
    the roles by opening the manifest and including the desired roles of your application.
    For instance, we can create the `football.read` role for general consumer access
    and the `football.admin` role for administrative access. It would look like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为 RESTful API 创建应用程序注册时，您可以通过打开清单并包括应用程序所需的角色来创建角色。例如，我们可以创建 `football.read`
    角色以供一般消费者访问，以及 `football.admin` 角色以供管理访问。它看起来会是这样：
- en: '![Figure 2.29: The application registration manifest with two application roles](img/B21646_02_29.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.29：具有两个应用程序角色的应用程序注册清单](img/B21646_02_29.jpg)'
- en: 'Figure 2.29: The application registration manifest with two application roles'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29：具有两个应用程序角色的应用程序注册清单
- en: 'Then, in the RESTful application registration area, go to **Expose an API**
    and assign an **Application ID** **URI** value:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 RESTful 应用程序注册区域，转到 **暴露 API** 并分配一个 **应用程序 ID** **URI** 值：
- en: '![Figure 2.30: Assigning an Application ID URI value](img/B21646_02_30.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.30：分配应用程序 ID URI 值](img/B21646_02_30.jpg)'
- en: 'Figure 2.30: Assigning an Application ID URI value'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30：分配应用程序 ID URI 值
- en: 'Then, we can assign permissions to the RESTful API. Go to **API permissions**
    and assign **Application permissions**:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为 RESTful API 分配权限。转到 **API 权限** 并分配 **应用程序权限**：
- en: '![Figure 2.31: Assigning application permissions to the consumer application](img/B21646_02_31.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.31：将应用程序权限分配给消费者应用程序](img/B21646_02_31.jpg)'
- en: 'Figure 2.31: Assigning application permissions to the consumer application'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31：将应用程序权限分配给消费者应用程序
- en: Now, the RESTful API has its own application registration. This means that you
    can configure the application with its own audience, instead of the UI application.
    To configure that, go to the `application.yml` file of the RESTful API and change
    the `client-id` property to the client ID of the application registration of the
    RESTful API.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，RESTful API 有了自己的应用程序注册。这意味着您可以使用自己的受众来配置应用程序，而不是 UI 应用程序。要配置这一点，请转到 RESTful
    API 的 `application.yml` 文件，并将 `client-id` 属性更改为 RESTful API 应用程序注册的客户端 ID。
- en: 'If you want to use the application roles to provide different access levels,
    you will need to use `AadJwtGrantedAuthoritiesConverter` from the Azure AD B2C
    starter. You can register the bean in the `SecurityConfig` class, as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用应用程序角色提供不同的访问级别，您将需要使用 Azure AD B2C 启动器中的 `AadJwtGrantedAuthoritiesConverter`。您可以在
    `SecurityConfig` 类中注册该 Bean，如下所示：
- en: '[PRE41]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'By default, the Spring OAuth2 resource server only converts the `scope` claim
    and the application roles will be provided in the `roles` claim. The converter
    generates authorities for each role with the `APPROLE_` prefix. So, you can restrict
    access using these authorities like so:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring OAuth2 资源服务器仅转换 `scope` 声明，并且应用程序角色将包含在 `roles` 声明中。转换器为每个角色生成带有
    `APPROLE_` 前缀的权限。因此，您可以使用这些权限来限制访问，如下所示：
- en: '[PRE42]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s what the payload of an access token with the application roles looks
    like:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是具有应用程序角色的访问令牌的有效载荷看起来像：
- en: '[PRE43]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By doing this, only the allowed client applications will be able to consume
    the RESTful API.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，只有允许的客户端应用程序才能消费 RESTful API。
