<html><head></head><body>
<div id="_idContainer061">
<h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-135"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.2.1">Building the Framework Hexagon</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When building a hexagonal application, the last step consists of exposing the application features by connecting input adapters to input ports. </span><span class="koboSpan" id="kobo.3.2">Also, if there is any need to get data from, or persist it inside, external systems, then we need to connect output adapters to output ports. </span><span class="koboSpan" id="kobo.3.3">The Framework hexagon is the place where we assemble all the adapters required to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We first created the domain model using things including entities, value objects, and specifications in the Domain hexagon. </span><span class="koboSpan" id="kobo.5.2">Then, in the Application hexagon, we expressed the user’s intent using use cases and ports. </span><span class="koboSpan" id="kobo.5.3">Now, in the Framework hexagon, we have to employ adapters to expose system features and define which technologies will be used to enable such features. </span><span class="koboSpan" id="kobo.5.4">After assembling the Domain, Application, and Framework hexagons, we will have an architecture resembling the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.7.1"><img alt="Figure 8.1 – Domain, Application, and Frameworks hexagons assembled" src="image/B19777_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.8.1">Figure 8.1 – Domain, Application, and Frameworks hexagons assembled</span></p>
<p><span class="koboSpan" id="kobo.9.1">What is so compelling about the hexagonal architecture is that we can add and remove adapters without worrying about changing the core system logic wrapped in the Domain hexagon. </span><span class="koboSpan" id="kobo.9.2">Of course, there is a price to be paid in the form of data translation between domain entities and external entities. </span><span class="koboSpan" id="kobo.9.3">However, in exchange, we gain a more decoupled system with clear boundaries between its realms </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of responsibilities.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Bootstrapping the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Framework hexagon</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">output adapters</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">I</span><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.18.1">mplementing </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">input adapters</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Testing the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Framework hexagon</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">By the end of this chapter, you’ll have learned to create input adapters to make the hexagonal application features accessible to other users and systems. </span><span class="koboSpan" id="kobo.22.2">Also, you’ll learn how to implement output adapters to enable the hexagonal system to communicate with external </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">data sources.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">To compile and run the code examples presented in this chapter, you’ll need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.27.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.29.1"> installed on your computer. </span><span class="koboSpan" id="kobo.29.2">They are all available for the Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08"><span class="No-Break"><span class="koboSpan" id="kobo.33.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.34.1">.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.35.1">Bootstrapping the Framework hexagon</span></h1>
<p><span class="koboSpan" id="kobo.36.1">When building a system using </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.37.1">hexagonal architecture, you don’t need to decide upfront whether the system API will be exposed using REST or gRPC, nor whether the system’s primary data source will be a MySQL database or MongoDB. </span><span class="koboSpan" id="kobo.37.2">Instead, what you need to do is start modeling your problem domain in the Domain hexagon, then designing and implementing use cases in the Application hexagon. </span><span class="koboSpan" id="kobo.37.3">Then, only after creating the previous two hexagons do you need to start thinking about which technologies will enable the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">system’s functionalities.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">A hexagonal approach centered around </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.41.1"> allows us to postpone the decisions </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.42.1">regarding the underlying technologies internal or external to the hexagonal system. </span><span class="koboSpan" id="kobo.42.2">Another prerogative of the hexagonal approach is the pluggable nature of the adapters. </span><span class="koboSpan" id="kobo.42.3">If you want to expose a certain system feature to be accessible via REST, you create and plug a REST input adapter into an input port. </span><span class="koboSpan" id="kobo.42.4">Later on, if you want to expose that same feature to clients using gRPC, you can create and plug a gRPC input adapter into the same </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">input port.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">When dealing with external data sources, we have the same pluggable prerogatives using output adapters. </span><span class="koboSpan" id="kobo.44.2">You can plug different output adapters into the same output port, changing the underlying data source technology without having to majorly refactor the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">To further explore</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.47.1"> input adapters, we’ll have a more in-depth discussion in </span><a href="B19777_12.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.49.1">, </span><em class="italic"><span class="koboSpan" id="kobo.50.1">Using RESTEasy Reactive to Implement Input Adapters</span></em><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">We’ll also investigate more possibilities for output adapters in </span><a href="B19777_13.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.52.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.53.1">, </span><em class="italic"><span class="koboSpan" id="kobo.54.1">Persisting Data with Output Adapters and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.55.1">Hibernate Reactive</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Let’s stick to the basics and create a solid structure for input and output adapters. </span><span class="koboSpan" id="kobo.57.2">On top of this structure, later on, we’ll be able to add the exciting features provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">Quarkus framework.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Continuing the development of the topology and inventory system, we need to bootstrap the Framework hexagon as a Maven and </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">Java module.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Inside the topology and inventory Maven root project, we have to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.63.1">
mvn archetype:generate \
    -DarchetypeGroupId=de.rieckpil.archetypes  \
    -DarchetypeArtifactId=testing-toolkit \
    -DarchetypeVersion=1.0.0 \
    -DgroupId=dev.davivieira \
    -DartifactId=framework \
    -Dversion=1.0-SNAPSHOT \
    -Dpackage=dev.davivieira.topologyinventory.framework \
    -DinteractiveMode=false</span></pre> <p><span class="koboSpan" id="kobo.64.1">We recommend running the preceding command directly on CMD instead of PowerShell if you are using Windows. </span><span class="koboSpan" id="kobo.64.2">If you need to use PowerShell, you’ll need to wrap each part of the command in </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">double quotes.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">mvn</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.68.1">archetype:generate</span></strong><span class="koboSpan" id="kobo.69.1"> goal creates a Maven module called </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">framework</span></strong><span class="koboSpan" id="kobo.71.1"> inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">topology-inventory</span></strong><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">This module comes with a skeleton directory structure based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">groupId</span></strong><span class="koboSpan" id="kobo.75.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">artificatId</span></strong><span class="koboSpan" id="kobo.77.1"> we passed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">mvn</span></strong><span class="koboSpan" id="kobo.79.1"> command. </span><span class="koboSpan" id="kobo.79.2">Also, it includes a child </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">pom.xml</span></strong><span class="koboSpan" id="kobo.81.1"> file inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">framework</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">After executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">mvn</span></strong><span class="koboSpan" id="kobo.86.1"> command</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.87.1"> to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">framework</span></strong><span class="koboSpan" id="kobo.89.1"> module, the root project’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">pom.xml</span></strong><span class="koboSpan" id="kobo.91.1"> file will be updated to contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">new module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
&lt;modules&gt;
  &lt;module&gt;domain&lt;/module&gt;
  &lt;module&gt;application&lt;/module&gt;
  &lt;module&gt;framework&lt;/module&gt;
&lt;/modules&gt;</span></pre> <p><span class="koboSpan" id="kobo.94.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">framework</span></strong><span class="koboSpan" id="kobo.96.1"> module is inserted at the end as the latest module we have </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">just added.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">framework</span></strong><span class="koboSpan" id="kobo.100.1"> module depends on both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">domain</span></strong><span class="koboSpan" id="kobo.102.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">application</span></strong><span class="koboSpan" id="kobo.104.1"> modules, we need to add them as dependencies to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">framework</span></strong><span class="koboSpan" id="kobo.106.1"> module’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.109.1">
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
    &lt;artifactId&gt;domain&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
    &lt;artifactId&gt;application&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/dependency&gt;
&lt;dependencies&gt;</span></pre> <p><span class="koboSpan" id="kobo.110.1">After running the Maven command to</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.111.1"> create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">framework</span></strong><span class="koboSpan" id="kobo.113.1"> module, you should see a directory tree similar to the one </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.115.1"><img alt="Figure 8.2 – The directory structure of the Framework hexagon" src="image/B19777_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.116.1">Figure 8.2 – The directory structure of the Framework hexagon</span></p>
<p><span class="koboSpan" id="kobo.117.1">There should be a child </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">pom.xml</span></strong><span class="koboSpan" id="kobo.119.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">framework</span></strong><span class="koboSpan" id="kobo.121.1"> directory and a parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">pom.xml</span></strong><span class="koboSpan" id="kobo.123.1"> file in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">topology-inventory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Once we have completed the Maven configuration, we can create the descriptor file that turns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">framework</span></strong><span class="koboSpan" id="kobo.128.1"> Maven module into a Java module. </span><span class="koboSpan" id="kobo.128.2">We do that by creating the following </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">file, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">topology-inventory/framework/src/java/module-info.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
module framework {
    requires domain;
    requires application;
}</span></pre> <p><span class="koboSpan" id="kobo.133.1">Because we have added </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">domain</span></strong><span class="koboSpan" id="kobo.135.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">application</span></strong><span class="koboSpan" id="kobo.137.1"> as Maven dependencies to the framework’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">pom.xml</span></strong><span class="koboSpan" id="kobo.139.1"> file, we can also add them as Java module dependencies to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">module-info.java</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.141.1">descriptor file.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">With both the Maven and Java </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.143.1">modules properly configured for the Framework hexagon, we can move on to creating the output adapters for the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">inventory system.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.145.1">Implementing output adapters</span></h1>
<p><span class="koboSpan" id="kobo.146.1">We will start by implementing the</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.147.1"> output adapters to set up the integration between our topology and inventory system and the underlying data source technology, which is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">H2</span></strong><span class="koboSpan" id="kobo.149.1"> in-memory database. </span><span class="koboSpan" id="kobo.149.2">It’s also important to implement output adapters first because we refer to them when implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">input adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">The topology and inventory system allows external data retrieval for routers’ and switches’ entities. </span><span class="koboSpan" id="kobo.151.2">So, in this section, we will review the output port interfaces that get external data related to these entities. </span><span class="koboSpan" id="kobo.151.3">We’ll also provide an output adapter implementation for each output </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">port interface.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.153.1">The router management output adapter</span></h2>
<p><span class="koboSpan" id="kobo.154.1">The router management output adapter we need to</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.155.1"> create should implement this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">RouterManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
package dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.158.2">  ports.output;
import
  dev.davivieira.topologyinventory.domain.entity.Router;
import dev.davivieira.topologyinventory.domain.vo.Id;
public interface RouterManagementOutputPort {
    Router retrieveRouter(Id id);
    Router removeRouter(Id id);
    Router persistRouter(Router router);
}</span></pre> <p><span class="koboSpan" id="kobo.159.1">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.161.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">removeRouter</span></strong><span class="koboSpan" id="kobo.163.1"> methods’ signatures have </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Id</span></strong><span class="koboSpan" id="kobo.165.1"> as a parameter. </span><span class="koboSpan" id="kobo.165.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Id</span></strong><span class="koboSpan" id="kobo.167.1"> to identify the router in the underlying data source. </span><span class="koboSpan" id="kobo.167.2">Then, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">persistRouter</span></strong><span class="koboSpan" id="kobo.169.1"> method signature receiving a </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Router</span></strong><span class="koboSpan" id="kobo.171.1"> parameter, which can represent both core and edge routers. </span><span class="koboSpan" id="kobo.171.2">We use that </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Router</span></strong><span class="koboSpan" id="kobo.173.1"> parameter to persist the data in the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">data source.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">For the topology and</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.176.1"> inventory system, for now, we have to implement only one output adapter to allow the system to use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">H2</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.178.1">in-memory database.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">We start the implementation with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">RouterManagementH2Adapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
package dev.davivieira.topologyinventory.framework.
</span><span class="koboSpan" id="kobo.182.2">  adapters.output.h2;
import dev.davivieira.topologyinventory.application.ports.
</span><span class="koboSpan" id="kobo.182.3">  output.RouterManagementOutputPort;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.182.4">  entity.Router;
import dev.davivieira.topologyinventory.domain.vo.Id;
import dev.davivieira.topologyinventory.framework.adapters.
</span><span class="koboSpan" id="kobo.182.5">  output.h2.data.RouterData;
import dev.davivieira.topologyinventory.framework.adapters.
</span><span class="koboSpan" id="kobo.182.6">  output.h2.mappers.RouterH2Mapper;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;
import jakarta.persistence.PersistenceContext;
public class RouterManagementH2Adapter implements
  RouterManagementOutputPort {
    private static RouterManagementH2Adapter instance;
    @PersistenceContext
    private EntityManager em;
    private RouterManagementH2Adapter(){
        setUpH2Database();
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.183.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">H2</span></strong><span class="koboSpan" id="kobo.185.1"> database connection is controlled by </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">EntityManager</span></strong><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">This connection is configured by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">setUpH2Database</span></strong><span class="koboSpan" id="kobo.189.1"> method, which we execute when we call the class’s empty constructor. </span><span class="koboSpan" id="kobo.189.2">We </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.190.1">use the variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">instance</span></strong><span class="koboSpan" id="kobo.192.1"> to provide a singleton so other objects can trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">database operations.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Let’s implement each method declared on the output </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">port interface:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.196.1">We start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.198.1"> method, which receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">Id</span></strong><span class="koboSpan" id="kobo.200.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">a parameter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.202.1">
@Override
public Router retrieveRouter(Id id) {
    var routerData = em.getReference(
                     RouterData.class, id.getUuid());
    return RouterH2Mapper.
</span><span class="koboSpan" id="kobo.202.2">      routerDataToDomain(routerData);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.203.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">getReference</span></strong><span class="koboSpan" id="kobo.205.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">EntityManager</span></strong><span class="koboSpan" id="kobo.207.1"> is called with </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">RouterData.class</span></strong><span class="koboSpan" id="kobo.209.1"> and the UUID value is extracted from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Id</span></strong><span class="koboSpan" id="kobo.211.1"> object. </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">RouterData</span></strong><span class="koboSpan" id="kobo.213.1"> is a database entity class that we use to map data coming from the database into</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.214.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">Router</span></strong><span class="koboSpan" id="kobo.216.1"> domain entity class. </span><span class="koboSpan" id="kobo.216.2">This mapping is accomplished by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">routerDataToDomain</span></strong><span class="koboSpan" id="kobo.218.1"> method from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">RouterH2Mapper</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1"> class.</span></span></p></li> <li><span class="koboSpan" id="kobo.221.1">Then, we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">removeRouter</span></strong><span class="koboSpan" id="kobo.223.1"> method, which removes a router from </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">the database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.225.1">
@Override
public Router removeRouter(Id id) {
    var routerData = em.getReference(
                     RouterData.class, id.getUuid());
    em.remove(routerData);
    return null;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.226.1">To remove a router, we first have to retrieve it by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">getReference</span></strong><span class="koboSpan" id="kobo.228.1"> method. </span><span class="koboSpan" id="kobo.228.2">Once we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">RouterData</span></strong><span class="koboSpan" id="kobo.230.1"> object representing the database entity, we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">remove</span></strong><span class="koboSpan" id="kobo.232.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">EntityManager</span></strong><span class="koboSpan" id="kobo.234.1">, which can delete the router from </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">the database.</span></span></p></li> <li><span class="koboSpan" id="kobo.236.1">Finally, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">persistRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
@Override
public Router persistRouter(Router router) {
    var routerData = RouterH2Mapper.
</span><span class="koboSpan" id="kobo.239.2">                     routerDomainToData(router);
    em.persist(routerData);
    return router;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.240.1">It receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Router</span></strong><span class="koboSpan" id="kobo.242.1"> domain entity object that needs to be converted into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">RouterData</span></strong><span class="koboSpan" id="kobo.244.1"> database </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.245.1">entity object that can be persisted with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">persist</span></strong><span class="koboSpan" id="kobo.247.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">EntityManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.251.1">By implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.253.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">removeRouter</span></strong><span class="koboSpan" id="kobo.255.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">persistRouter</span></strong><span class="koboSpan" id="kobo.257.1"> methods, we provide the basic database operations required by the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">inventory system.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Let’s move on to see the switch output </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">adapters’ implementation.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.261.1">The switch management output adapter</span></h2>
<p><span class="koboSpan" id="kobo.262.1">The output adapter we implement for the switch is simpler because we don’t need to persist switches directly or </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.263.1">remove them. </span><span class="koboSpan" id="kobo.263.2">The sole purpose of the switch’s output adapter is to enable the retrieval of switches from the database. </span><span class="koboSpan" id="kobo.263.3">We allow persistence only through the router </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">output adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">To get started, let’s define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">SwitchManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
package dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.268.2">  ports.output;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.268.3">  entity.Switch;
import dev.davivieira.topologyinventory.domain.vo.Id;
public interface SwitchManagementOutputPort {
    Switch retrieveSwitch(Id id);
}</span></pre> <p><span class="koboSpan" id="kobo.269.1">We have just one method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">retrieveSwitch</span></strong><span class="koboSpan" id="kobo.271.1">, which receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Id</span></strong><span class="koboSpan" id="kobo.273.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">SwitchManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.279.1"> output adapter implementation is very straightforward and </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.280.1">similar to its router counterpart. </span><span class="koboSpan" id="kobo.280.2">So, we’ll just assess the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">retrieveSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.282.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
/** Code omitted **/
public class SwitchManagementH2Adapter implements
  SwitchManagementOutputPort {
    /** Code omitted **/
    @Override
    public Switch retrieveSwitch(Id id) {
        var switchData = em.getReference(
                         SwitchData.class, id.getUuid());
        return
        RouterH2Mapper.switchDataToDomain(switchData);
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.284.1">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">getReference</span></strong><span class="koboSpan" id="kobo.286.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">EntityManager</span></strong><span class="koboSpan" id="kobo.288.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">SwitchData.class</span></strong><span class="koboSpan" id="kobo.290.1"> and a UUID value as parameters in order to retrieve a </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">SwitchData</span></strong><span class="koboSpan" id="kobo.292.1"> database entity object. </span><span class="koboSpan" id="kobo.292.2">Then, this object is converted into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Switch</span></strong><span class="koboSpan" id="kobo.294.1"> domain entity when we</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.295.1"> call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">switchDataToDomain</span></strong><span class="koboSpan" id="kobo.297.1"> method from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">RouterH2Mapper</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">Now that we have both </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.302.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">SwitchManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.304.1"> properly implemented, we can proceed to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">inp</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.306.1">ut adapters.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.307.1">Implementing the input adapters</span></h1>
<p><span class="koboSpan" id="kobo.308.1">When building</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.309.1"> the Application hexagon, we need to create use cases and input ports to express system capabilities. </span><span class="koboSpan" id="kobo.309.2">To make these capabilities available to users and other systems, we need to build input adapters and connect them to </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">input ports.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">For the topology and inventory system, we will implement a set of generic input adapters as Java POJOs. </span><span class="koboSpan" id="kobo.311.2">These generic input adapters are the basis for the technologically specific implementation that takes place in </span><a href="B19777_12.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.312.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.313.1">, </span><em class="italic"><span class="koboSpan" id="kobo.314.1">Using RESTEasy Reactive to Implement Input Adapters</span></em><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">In that chapter, we will reimplement the generic input adapters as RESTEasy-based input adapters using the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">Quarkus framework.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">The input adapter’s central role is to receive requests from outside the hexagonal system and fulfill these requests using an </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">input port.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Continuing to develop the topology and inventory system, let’s implement the input adapters that receive requests related to </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">router management.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.321.1">The router management input adapter</span></h2>
<p><span class="koboSpan" id="kobo.322.1">We start by </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.323.1">creating the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">RouterManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
public class RouterManagementGenericAdapter {
    private RouterManagementUseCase
      routerManagementUseCase;
    public RouterManagementGenericAdapter(){
        setPorts();
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.327.1">We start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">RouterManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.329.1"> implementation by declaring a class attribute for </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">Instead of using an input port class reference, we utilize the use</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.332.1"> case interface reference, </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.334.1">, to connect to the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">input port.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">On the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">RouterManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.338.1">, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">setPorts</span></strong><span class="koboSpan" id="kobo.340.1"> method, which instantiates </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.342.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.344.1"> parameter as an output port to connect to the H2 in-memory database that the input </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">port uses.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">The following is how we should implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">setPorts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.348.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
private void setPorts(){
    this.routerManagementUseCase =
            new RouterManagementInputPort(
            RouterManagementH2Adapter.getInstance()
    );
}
/** Code omitted **/</span></pre> <p><span class="koboSpan" id="kobo.350.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">setPorts</span></strong><span class="koboSpan" id="kobo.352.1"> method stores a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.354.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.356.1"> attribute we </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">defined earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">After class initialization, we need to create the methods that expose the operations supported by the hexagonal system. </span><span class="koboSpan" id="kobo.358.2">The intent here is to receive the request in the input adapter and forward it to an input port by using its use case </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">interface reference:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.360.1">Here are the operations </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.361.1">for retrieving and removing routers from </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">the system:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
/**
 * GET /router/retrieve/{id}
 * */
public Router retrieveRouter(Id id){
    return routerManagementUseCase.retrieveRouter(id);
}
/**
 * GET /router/remove/{id}
 * */
public Router removeRouter(Id id){
    return routerManagementUseCase.removeRouter(id);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.364.1">The comments are to remind us that these operations will be transformed into REST endpoints when integrating Quarkus into the hexagonal system. </span><span class="koboSpan" id="kobo.364.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.366.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">removeRouter</span></strong><span class="koboSpan" id="kobo.368.1"> receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Id</span></strong><span class="koboSpan" id="kobo.370.1"> as a parameter. </span><span class="koboSpan" id="kobo.370.2">Then, the request is forwarded to an input port using a use </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">case reference.</span></span></p></li> <li><span class="koboSpan" id="kobo.372.1">Then, we have the operation to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">new router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.374.1">
/**
 * POST /router/create
 * */
public Router createRouter(Vendor vendor,
                               Model,
                               IP,
                               Location,
                               RouterType routerType){
    var router = routerManagementUseCase.createRouter(
            null,
            vendor,
            model,
            ip,
            location,
            routerType
   );
   return routerManagementUseCase.
</span><span class="koboSpan" id="kobo.374.2">     persistRouter(router);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.375.1">From the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.377.1"> reference, we first call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">createRouter</span></strong><span class="koboSpan" id="kobo.379.1"> method to </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.380.1">create a new router, then we persist it using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">persistRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1"> method.</span></span></p></li> <li><span class="koboSpan" id="kobo.383.1">Remember that in the topology and inventory system, only core routers can receive connections from both core and edge routers. </span><span class="koboSpan" id="kobo.383.2">To allow the addition and removal of routers to or from a core router, we first define the following operation to </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">add routers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
/**
 * POST /router/add
 * */
public Router addRouterToCoreRouter(
    Id routerId, Id coreRouterId){
    Router = routerManagementUseCase.
</span><span class="koboSpan" id="kobo.385.2">    retrieveRouter(routerId);
    CoreRouter =
        (CoreRouter) routerManagementUseCase.
</span><span class="koboSpan" id="kobo.385.3">        retrieveRouter(coreRouterId);
    return routerManagementUseCase.
</span><span class="koboSpan" id="kobo.385.4">            addRouterToCoreRouter(router, coreRouter);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.386.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">addRouterToCoreRouter</span></strong><span class="koboSpan" id="kobo.388.1"> method, we pass the routers’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">Id</span></strong><span class="koboSpan" id="kobo.390.1"> instances as parameters we intend to add along with the target core router’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Id</span></strong><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">With these IDs, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.394.1"> method to get the router objects from our data</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.395.1"> source. </span><span class="koboSpan" id="kobo.395.2">Once we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Router</span></strong><span class="koboSpan" id="kobo.397.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.399.1"> objects, we handle the request to the input port using a use case reference, by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">addRouterToCoreRouter</span></strong><span class="koboSpan" id="kobo.401.1"> to add one router to </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">the other.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.403.1">After that, we define the operation to remove routers from a </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">core router:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.405.1">/**
 * POST /router/remove
 * */
public Router removeRouterFromCoreRouter(
    Id routerId, Id coreRouterId){
    Router =
    routerManagementUseCase.
</span><span class="koboSpan" id="kobo.405.2">    retrieveRouter(routerId);
    CoreRouter =
         (CoreRouter) routerManagementUseCase.
</span><span class="koboSpan" id="kobo.405.3">         retrieveRouter(coreRouterId);
    return routerManagementUseCase.
</span><span class="koboSpan" id="kobo.405.4">            removeRouterFromCoreRouter(router,
              coreRouter);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.406.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">removeRouterFromCoreRouter</span></strong><span class="koboSpan" id="kobo.408.1"> method, we follow the same steps as those for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">addRouterToCoreRouter</span></strong><span class="koboSpan" id="kobo.410.1"> method. </span><span class="koboSpan" id="kobo.410.2">The only difference, though, is that at the end, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">removeRouterFromCoreRouter</span></strong><span class="koboSpan" id="kobo.412.1"> from the use case in order to remove one router from </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">the other.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.414.1">Let’s now create the adapter</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.415.1"> that handles </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">switch-related operations.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.417.1">The switch management input adapter</span></h2>
<p><span class="koboSpan" id="kobo.418.1">Before we define the methods that </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.419.1">expose the switch-related operations, we need to configure the proper initialization of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">SwitchManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
package dev.davivieira.topologyinventory.framework.
</span><span class="koboSpan" id="kobo.422.2">  adapters.input.generic;
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.422.3">  ports.input.*
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.422.4">  usecases.*;
import dev.davivieira.topologyinventory.domain.entity.*;
import dev.davivieira.topologyinventory.domain.vo.*;
import dev.davivieira.topologyinventory.framework.
</span><span class="koboSpan" id="kobo.422.5">  adapters.output.h2.*;
public class SwitchManagementGenericAdapter {
    private SwitchManagementUseCase
      switchManagementUseCase;
    private RouterManagementUseCase
      routerManagementUseCase;
    public SwitchManagementGenericAdapter(){
        setPorts();
    }</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">SwitchManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.424.1"> is connected to two input ports – the first input port is </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">SwitchManagementInputPort</span></strong><span class="koboSpan" id="kobo.426.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.428.1">, and the second input port is </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.430.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.432.1">. </span><span class="koboSpan" id="kobo.432.2">That’s why we start the class implementation by declaring the attributes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.434.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">We are connecting the switch adapter to the router input port because we want to enforce any persistence activity to </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.437.1">happen only through a router. </span><span class="koboSpan" id="kobo.437.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Router</span></strong><span class="koboSpan" id="kobo.439.1"> entity, as an aggregate, controls the life cycles of the objects that are related </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Next, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">setPorts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.443.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
private void setPorts(){
    this.switchManagementUseCase =
            new SwitchManagementInputPort(
            SwitchManagementH2Adapter.getInstance()
    );
    this.routerManagementUseCase =
            new RouterManagementInputPort(
            RouterManagementH2Adapter.getInstance()
    );
}
** Code omitted **</span></pre> <p><span class="koboSpan" id="kobo.445.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">setPorts</span></strong><span class="koboSpan" id="kobo.447.1"> method, we initialize both input ports with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">SwitchManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.449.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.451.1"> adapters to allow access to the H2 </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">in-memory database.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Let’s see how to implement the </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.454.1">methods that expose the </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">switch-related operations:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.456.1">We start with a simple operation that just retrieves </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">a switch:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
/**
 * GET /switch/retrieve/{id}
 * */
public Switch retrieveSwitch(Id switchId) {
    return switchManagementUseCase.
</span><span class="koboSpan" id="kobo.458.2">      retrieveSwitch(switchId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.459.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">retrieveSwitch</span></strong><span class="koboSpan" id="kobo.461.1"> method receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">Id</span></strong><span class="koboSpan" id="kobo.463.1"> as a parameter. </span><span class="koboSpan" id="kobo.463.2">Then, it utilizes a use case reference to forward the request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">input port.</span></span></p></li> <li><span class="koboSpan" id="kobo.465.1">Next, we have a method that lets us create and add a switch to an </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">edge router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.467.1">
/**
 * POST /switch/create
 * */
public EdgeRouter createAndAddSwitchToEdgeRouter(
       Vendor,
       Model,
       IP,
       Location,
       SwitchType, Id routerId
) {
    Switch newSwitch = switchManagementUseCase.
</span><span class="koboSpan" id="kobo.467.2">    createSwitch(vendor, model, ip, location,
      switchType);
    Router edgeRouter = routerManagementUseCase.
</span><span class="koboSpan" id="kobo.467.3">    retrieveRouter(routerId);
    if(!edgeRouter.getRouterType().equals
      (RouterType.EDGE))
        throw new UnsupportedOperationException(
    "Please inform the id of an edge router to add a
     switch");
    Router = switchManagementUseCase.
</span><span class="koboSpan" id="kobo.467.4">    addSwitchToEdgeRouter(newSwitch, (EdgeRouter)
      edgeRouter);
    return (EdgeRouter)
    routerManagementUseCase.persistRouter(router);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.468.1">We call the switch input port method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">createSwitch</span></strong><span class="koboSpan" id="kobo.470.1">, by passing the parameters received by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">createAndAddSwitchToEdgeRouter</span></strong><span class="koboSpan" id="kobo.472.1"> method to create a switch. </span><span class="koboSpan" id="kobo.472.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">routerId</span></strong><span class="koboSpan" id="kobo.474.1">, we retrieve the edge router by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.476.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">router</span></strong><span class="koboSpan" id="kobo.478.1"> input port. </span><span class="koboSpan" id="kobo.478.2">Once we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Switch</span></strong><span class="koboSpan" id="kobo.480.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.482.1"> objects, we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">addSwitchToEdgeRouter</span></strong><span class="koboSpan" id="kobo.484.1"> method to add the switch to the edge router. </span><span class="koboSpan" id="kobo.484.2">As the last step, we call </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.485.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">persistRouter</span></strong><span class="koboSpan" id="kobo.487.1"> method to persist the operation in the </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">data source.</span></span></p></li> <li><span class="koboSpan" id="kobo.489.1">Finally, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.491.1"> method, which allows us to remove a switch from an </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">edge router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.493.1">
/**
 * POST /switch/remove
 * */
public EdgeRouter removeSwitchFromEdgeRouter(
Id switchId, Id edgeRouterId) {
    EdgeRouter =
            (EdgeRouter) routerManagementUseCase.
</span><span class="koboSpan" id="kobo.493.2">                         retrieveRouter(edgeRouterId);
    Switch networkSwitch = edgeRouter.
</span><span class="koboSpan" id="kobo.493.3">                           getSwitches().
</span><span class="koboSpan" id="kobo.493.4">                           get(switchId);
    Router = switchManagementUseCase.
</span><span class="koboSpan" id="kobo.493.5">                    removeSwitchFromEdgeRouter(
                    networkSwitch, edgeRouter);
    return (EdgeRouter) routerManagementUseCase.
</span><span class="koboSpan" id="kobo.493.6">    persistRouter(router);
}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.495.1"> receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Id</span></strong><span class="koboSpan" id="kobo.497.1"> as a parameter for the switch and another </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Id</span></strong><span class="koboSpan" id="kobo.499.1"> for the edge router. </span><span class="koboSpan" id="kobo.499.2">Then, it retrieves the router by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.501.1"> method. </span><span class="koboSpan" id="kobo.501.2">With the switch ID, it retrieves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">switch</span></strong><span class="koboSpan" id="kobo.503.1"> object from the edge router object. </span><span class="koboSpan" id="kobo.503.2">Once it gets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Switch</span></strong><span class="koboSpan" id="kobo.505.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.507.1"> objects, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.509.1"> method to remove the switch from the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">edge router.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.511.1">What’s left now is to implement the </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.512.1">adapter that deals with the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">inventory networks.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.514.1">The network management input adapter</span></h2>
<p><span class="koboSpan" id="kobo.515.1">As we did with the router </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.516.1">and switch adapters, let’s implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">NetworkManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.518.1"> class by first defining the ports </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">it needs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
package dev.davivieira.topologyinventory.framework.
</span><span class="koboSpan" id="kobo.520.2">  adapters.input.generic;
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.520.3">  ports.input.*;
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.520.4">  usecases.*;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.520.5">  entity.Switch;
import dev.davivieira.topologyinventory.domain.vo.*;
import dev.davivieira.topologyinventory.framework.
</span><span class="koboSpan" id="kobo.520.6">  adapters.output.h2.*;
public class NetworkManagementGenericAdapter {
    private SwitchManagementUseCase
      switchManagementUseCase;
    private NetworkManagementUseCase
    networkManagementUseCase;
    public NetworkManagementGenericAdapter(){
        setPorts();
    }</span></pre> <p><span class="koboSpan" id="kobo.521.1">Besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.523.1">, we also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.525.1">. </span><span class="koboSpan" id="kobo.525.2">We need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">setPorts</span></strong><span class="koboSpan" id="kobo.527.1"> method from the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">NetworkManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.529.1"> to properly initialize the input port objects and assign them to their respective use case references. </span><span class="koboSpan" id="kobo.529.2">The following is how we</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.530.1"> implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">setPorts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.532.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
private void setPorts(){
    this.switchManagementUseCase =
             new SwitchManagementInputPort(
             SwitchManagementH2Adapter.getInstance());
    this.networkManagementUseCase =
             new NetworkManagementInputPort(
             RouterManagementH2Adapter.getInstance());
}
/** Code omitted **/</span></pre> <p><span class="koboSpan" id="kobo.534.1">As we did in previous input adapter implementations, we configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">setPorts</span></strong><span class="koboSpan" id="kobo.536.1"> method to initialize the input port objects and assign them to the use </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">case references.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Let’s implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">network-related methods:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.540.1">First, we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.542.1"> method to add a network to </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">a switch:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.544.1">
/**
 * POST /network/add
 * */
public Switch addNetworkToSwitch(Network network, Id
  switchId) {
    Switch networkSwitch = switchManagementUseCase.
</span><span class="koboSpan" id="kobo.544.2">                           retrieveSwitch(switchId);
    return networkManagementUseCase.
</span><span class="koboSpan" id="kobo.544.3">           addNetworkToSwitch(
           network, networkSwitch);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.545.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.547.1"> method receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">Network</span></strong><span class="koboSpan" id="kobo.549.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Id</span></strong><span class="koboSpan" id="kobo.551.1"> objects as parameters. </span><span class="koboSpan" id="kobo.551.2">To proceed, we need to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">Switch</span></strong><span class="koboSpan" id="kobo.553.1"> object by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">retrieveSwitch</span></strong><span class="koboSpan" id="kobo.555.1"> method. </span><span class="koboSpan" id="kobo.555.2">Then, we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.557.1"> method t</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.558.1">o add the network to </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">the switch.</span></span></p></li> <li><span class="koboSpan" id="kobo.560.1">Then, we implement the method to remove a network from </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">a switch:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
/**
 * POST /network/remove
 * */
public Switch removeNetworkFromSwitch(
String networkName, Id switchId) {
    Switch networkSwitch = switchManagementUseCase.
</span><span class="koboSpan" id="kobo.562.2">                           retrieveSwitch(switchId);
    return networkManagementUseCase.
</span><span class="koboSpan" id="kobo.562.3">           removeNetworkFromSwitch(
           networkName, networkSwitch);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.563.1">First, we get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">Switch</span></strong><span class="koboSpan" id="kobo.565.1"> object by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">retrieveSwitch</span></strong><span class="koboSpan" id="kobo.567.1"> method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Id</span></strong><span class="koboSpan" id="kobo.569.1"> parameter. </span><span class="koboSpan" id="kobo.569.2">To remove a network from a switch, we use the network name to find it from a list of networks attached to the switch. </span><span class="koboSpan" id="kobo.569.3">We do that by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">removeNetworkFromSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.571.1"> method.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.572.1">The adapter for </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.573.1">managing networks is the last input adapter we have to implement. </span><span class="koboSpan" id="kobo.573.2">With these three adapters, we can now manage routers, switches, and networks from the Framework hexagon. </span><span class="koboSpan" id="kobo.573.3">To make sure these adapters are working well, let’s create some tests </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">for them.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.575.1">Testing the Framework hexagon</span></h1>
<p><span class="koboSpan" id="kobo.576.1">By testing the Framework</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.577.1"> hexagon, we not only have the opportunity to check whether the input and output adapters are working well but we can also test whether the other hexagons, Domain and Application, are doing their part in response to the requests coming from the </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">Framework hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">To test it, we call the input adapters to trigger the execution of everything necessary in the downstream hexagons to fulfill the request. </span><span class="koboSpan" id="kobo.579.2">We start by implementing tests for the router management adapters. </span><span class="koboSpan" id="kobo.579.3">The tests for switches and networks follow the same pattern and are available in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">For the routers, we will put our tests into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">RouterTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.583.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
public class RouterTest extends FrameworkTestData {
    RouterManagementGenericAdapter
    routerManagementGenericAdapter;
    public RouterTest() {
        this.routerManagementGenericAdapter =
        new RouterManagementGenericAdapter();
        loadData();
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.585.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">RouterTest</span></strong><span class="koboSpan" id="kobo.587.1"> constructor, we instantiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">RouterManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.589.1"> input adapter class that we use to perform the tests. </span><span class="koboSpan" id="kobo.589.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">loadData</span></strong><span class="koboSpan" id="kobo.591.1"> method loads some test data from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">FrameworkTestData</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.593.1">parent class.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">Once we have correctly </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.595.1">configured the requirements of the tests, we can proceed with </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">the testing:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.597.1">First, we test </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">router retrieval:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
@Test
public void retrieveRouter() {
    var id = Id.withId(
    "b832ef4f-f894-4194-8feb-a99c2cd4be0c");
    var actualId = routerManagementGenericAdapter.
</span><span class="koboSpan" id="kobo.599.2">                   retrieveRouter(id).getId();
    assertEquals(id, actualId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.600.1">We call the input adapter, informing it of the router </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">id</span></strong><span class="koboSpan" id="kobo.602.1"> we want to retrieve. </span><span class="koboSpan" id="kobo.602.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">assertEquals</span></strong><span class="koboSpan" id="kobo.604.1">, we compare the expected ID with the actual ID to see whether </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">they match.</span></span></p></li> <li><span class="koboSpan" id="kobo.606.1">To test router creation, we have to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">createRouter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.608.1">test method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.609.1">
@Test
public void createRouter() {
    var ipAddress = "40.0.0.1";
    var routerId  = this.
</span><span class="koboSpan" id="kobo.609.2">    routerManagementGenericAdapter.createRouter(
            Vendor.DLINK,
            Model.XYZ0001,
            IP.fromAddress(ipAddress),
            locationA,
            RouterType.EDGE).getId();
    var router = this.routerManagementGenericAdapter.
</span><span class="koboSpan" id="kobo.609.3">    retrieveRouter(routerId);
    assertEquals(routerId, router.getId());
    assertEquals(Vendor.DLINK, router.getVendor());
    assertEquals(Model.XYZ0001, router.getModel());
    assertEquals(ipAddress,
    router.getIp().getIpAddress());
    assertEquals(locationA, router.getLocation());
    assertEquals(RouterType.EDGE,
    router.getRouterType());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.610.1">From the router input </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.611.1">adapter, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">createRouter</span></strong><span class="koboSpan" id="kobo.613.1"> method to create and persist a new router. </span><span class="koboSpan" id="kobo.613.2">Then, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.615.1"> method with the ID previously generated by the router we have just created. </span><span class="koboSpan" id="kobo.615.2">Finally, we run </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">assertEquals</span></strong><span class="koboSpan" id="kobo.617.1"> to confirm whether the router retrieved from the data source is indeed the router </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">we created.</span></span></p></li> <li><span class="koboSpan" id="kobo.619.1">To test the addition of a router to a core router, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">addRouterToCoreRouter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.621.1">test method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.622.1">
@Test
public void addRouterToCoreRouter() {
    var routerId = Id.withId(
    "b832ef4f-f894-4194-8feb-a99c2cd4be0b");
    var coreRouterId = Id.withId(
    "b832ef4f-f894-4194-8feb-a99c2cd4be0c");
    var actualRouter =
    (CoreRouter) this.routerManagementGenericAdapter.
</span><span class="koboSpan" id="kobo.622.2">    addRouterToCoreRouter(routerId,coreRouterId);
    assertEquals(routerId,
    actualRouter.getRouters().get(routerId).getId());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.623.1">We pass the </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.624.1">variables, </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">routerId</span></strong><span class="koboSpan" id="kobo.626.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">coreRouterId</span></strong><span class="koboSpan" id="kobo.628.1">, as parameters to the input adapter’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">addRouterToCoreRouter</span></strong><span class="koboSpan" id="kobo.630.1"> method, which returns a core router. </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">assertEquals</span></strong><span class="koboSpan" id="kobo.632.1"> checks whether the core router has the router </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">we added.</span></span></p></li> <li><span class="koboSpan" id="kobo.634.1">To test the removal of a router from a core router, we’ll use </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">this code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
@Test
public void removeRouterFromCoreRouter(){
    var routerId = Id.withId(
    "b832ef4f-f894-4194-8feb-a99c2cd4be0a");
    var coreRouterId = Id.withId(
    "b832ef4f-f894-4</span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.637.1">194-8feb-a99c2cd4be0c");
    var removedRouter =
    this.routerManagementGenericAdapter.
</span><span class="koboSpan" id="kobo.637.2">    removeRouterFromCoreRouter(routerId,
    coreRouterId);
    var coreRouter =
    (CoreRouter)this.routerManagementGenericAdapter.
</span><span class="koboSpan" id="kobo.637.3">    retrieveRouter(coreRouterId);
    assertEquals(routerId, removedRouter.getId());
    assertFalse(
    coreRouter.getRouters().containsKey(routerId));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.638.1">This test is very similar to the</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.639.1"> previous one. </span><span class="koboSpan" id="kobo.639.2">We again use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">routerId</span></strong><span class="koboSpan" id="kobo.641.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">coreRouterId</span></strong><span class="koboSpan" id="kobo.643.1"> variables, but now we also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">removeRouterFromCoreRouter</span></strong><span class="koboSpan" id="kobo.645.1"> method, which returns the removed router. </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">assertEquals</span></strong><span class="koboSpan" id="kobo.647.1"> checks whether the removed router’s ID matches the ID from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">routerId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1"> variable.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.650.1">To run these tests, execute the following command in the Maven project </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">root directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.652.1">
mvn test</span></pre> <p><span class="koboSpan" id="kobo.653.1">The output should be similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">one here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.655.1">
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running dev.davivieira.topologyinventory.framework.NetworkTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.654 s - in dev.davivieira.topologyinventory.framework.NetworkTest
[INFO] Running dev.davivieira.topologyinventory.framework.RouterTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.014 s - in dev.davivieira.topologyinventory.framework.RouterTest
[INFO] Running dev.davivieira.topologyinventory.framework.SwitchTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.006 s - in dev.davivieira.topologyinventory.framework.SwitchTest</span></pre> <p><span class="koboSpan" id="kobo.656.1">Along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">RouterTest</span></strong><span class="koboSpan" id="kobo.658.1">, we also have tests from </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">SwitchTest</span></strong><span class="koboSpan" id="kobo.660.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">NetworkTest</span></strong><span class="koboSpan" id="kobo.662.1">, which you can find in the book’s GitHub repository, as </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">mentioned before.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">By implementing the Framework hexagon tests, we conclude the development of the Framework hexagon and the </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.665.1">whole topology and inventory system’s backend. </span><span class="koboSpan" id="kobo.665.2">Taking what we’ve learned from this chapter and the previous chapters, we can apply all the techniques covered to create a system following the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">architecture principles.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.667.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.668.1">We started the Framework hexagon construction by first implementing the output adapters to enable the topology and inventory system to use an H2 in-memory database as its primary </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">data source.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Then, we created three input adapters: one for router operations, another one for switch operations, and the last one for network-related operations. </span><span class="koboSpan" id="kobo.670.2">To conclude, we implemented tests to ensure that the adapters and the whole hexagonal system worked as expected. </span><span class="koboSpan" id="kobo.670.3">By completing the development of the Framework hexagon, we have finished the development of our overall </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">We can improve the hexagonal system we have created by exploring the possibilities offered by the </span><strong class="bold"><span class="koboSpan" id="kobo.673.1">Java Module Platform System</span></strong><span class="koboSpan" id="kobo.674.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.675.1">JPMS</span></strong><span class="koboSpan" id="kobo.676.1">). </span><span class="koboSpan" id="kobo.676.2">For example, we can leverage the hexagonal modular structure to apply the </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">Dependency Inversion</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.678.1">Principle</span></strong><span class="koboSpan" id="kobo.679.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.680.1">DIP</span></strong><span class="koboSpan" id="kobo.681.1">). </span><span class="koboSpan" id="kobo.681.2">By doing so, we can make the hexagonal system more loosely coupled. </span><span class="koboSpan" id="kobo.681.3">We shall examine the DIP and other exciting features in the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">next chapter.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.683.1">Questions</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.684.1">Which other Java modules does the </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">Framework hexagon</span></strong><span class="koboSpan" id="kobo.686.1"> Java module </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">depend on?</span></span></li>
<li><span class="koboSpan" id="kobo.688.1">Why do we need to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">output adapters?</span></span></li>
<li><span class="koboSpan" id="kobo.690.1">In order to communicate with the input ports, the input adapters instantiate input port objects and assign them to an interface reference. </span><span class="koboSpan" id="kobo.690.2">What’s </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">that interface?</span></span></li>
<li><span class="koboSpan" id="kobo.692.1">When we test a Framework hexagon’s input adapter, we are also testing other hexagons. </span><span class="koboSpan" id="kobo.692.2">Why does </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">that happen?</span></span></li>
</ol>
<h1 id="_idParaDest-148"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.694.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.695.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">Framework hexagon</span></strong><span class="koboSpan" id="kobo.697.1"> module depends on the Domain and Application hexagons’ </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">Java modules.</span></span></li>
<li><span class="koboSpan" id="kobo.699.1">We create output adapters to enable the hexagonal system to connect to external </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">data sources.</span></span></li>
<li><span class="koboSpan" id="kobo.701.1">It’s the use </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">case interface.</span></span></li>
<li><span class="koboSpan" id="kobo.703.1">Because the input adapters depend on the components provided by the Domain and </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">Application hexagons.</span></span></li>
</ol>
</div>
</body></html>