- en: Additional Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充信息
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Processing results for Runnable objects in the Executor framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Executor 框架中处理 `Runnable` 对象的结果
- en: Processing uncontrolled exceptions in a ForkJoinPool class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ForkJoinPool 类中处理未受控的异常
- en: Using a blocking thread-safe queue to communicate with producers and consumers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阻塞线程安全的队列与生产者和消费者进行通信
- en: Monitoring a Thread class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 `Thread` 类
- en: Monitoring a Semaphore class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 `Semaphore` 类
- en: Generating concurrent random numbers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成并发随机数
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter include recipes about the `Executor` framework and the fork/join
    framework, concurrent data structures, monitoring concurrent objects, and generating
    concurrent random numbers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括关于 `Executor` 框架和 fork/join 框架、并发数据结构、监控并发对象以及生成并发随机数的食谱。
- en: Processing results for Runnable objects in the Executor framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Executor 框架中处理 `Runnable` 对象的结果
- en: The `Executor` framework allows the execution of concurrent tasks that returns
    a result using the `Callable` and `Future` interfaces. The traditional concurrent
    programming in Java is based on `Runnable` objects, but this kind of object doesn't
    return a result.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor` 框架允许使用 `Callable` 和 `Future` 接口执行返回结果的并发任务。Java 中的传统并发编程基于 `Runnable`
    对象，但这种类型的对象不返回结果。'
- en: In this recipe, you will learn how to adapt a `Runnable` object to simulate
    a `Callable` one, allowing a concurrent task to return a result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何将 `Runnable` 对象适配为 `Callable` 对象，允许并发任务返回结果。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse, or another IDE such as NetBeans, open it and create a new Java project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to implement the example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现示例：
- en: 'Create a class named `FileSearch` and specify that it implements the `Runnable`
    interface. This class implements the file search operation:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FileSearch` 的类，并指定它实现 `Runnable` 接口。此类实现了文件搜索操作：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare two private `String` attributes: one named `initPath`, which will store
    the initial folder for the search operation, and the other named end, which will
    store the extension of the files this task is going to look for:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有 `String` 属性：一个名为 `initPath`，它将存储搜索操作的初始文件夹，另一个名为 `end`，它将存储此任务将要查找的文件的扩展名：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Declare a private `List<String>` attribute named `results` that will store
    the full paths of the files that this task has found:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `results` 的私有 `List<String>` 属性，该属性将存储此任务找到的文件的完整路径：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement the constructor of the class that will initialize its attributes:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化其属性：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the method `getResults()`. This method returns the list with the
    full paths of the files that this task has found:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法 `getResults()`。此方法返回包含此任务找到的文件完整路径的列表：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `run()` method. First of all, write a log message to the console
    indicating that the task is starting its job:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法 `run()`。首先，向控制台写入一条日志消息，表明任务开始执行工作：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, if the `initPath` attribute stores the name of an existing folder, call
    the auxiliary method, `directoryProcess()`, to process its files and folders:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果 `initPath` 属性存储了现有文件夹的名称，请调用辅助方法 `directoryProcess()` 来处理其文件和文件夹：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the auxiliary `diretoryProcess()` method, which receives a `File`
    object as a parameter. First of all, get the contents of the folder pointed to
    by the parameter:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助的 `diretoryProcess()` 方法，该方法接收一个 `File` 对象作为参数。首先，获取参数指向的文件夹的内容：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With all the elements of the folder, if they are folders, make a recursive
    call to the `directoryProcess()` method. If they are files, call the `fileProcess()`
    auxiliary method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于文件夹中的所有元素，如果它们是文件夹，则递归调用 `directoryProcess()` 方法。如果它们是文件，则调用辅助方法 `fileProcess()`：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the auxiliary method `fileProcess()` that receives a `File` object
    with the full path of a file. This method checks if the file extension is equal
    to the one stored in the end attribute. If they are equal, add the full path of
    the file to the list of results:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法 `fileProcess()`，该方法接收一个包含文件完整路径的 `File` 对象。此方法检查文件扩展名是否与存储在 `end` 属性中的扩展名相等。如果它们相等，将文件的完整路径添加到结果列表中：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement a class named `Task` that extends the `FutureTask` class. You''ll
    use `List<String>` as the parameterized type, as this will be the type of the
    data this task will return:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `Task` 的类，该类扩展了 `FutureTask` 类。你将使用 `List<String>` 作为参数化类型，因为这将是这个任务返回的数据类型：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Declare a private `FileSearch` attribute named `fileSearch`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `fileSearch` 的私有 `FileSearch` 属性：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Implement the constructor of this class. This constructor has two parameters: a `Runnable`
    object named `runnable` and a `List<String>` object named result. In the constructor,
    you have to call the constructor of the parent class, passing to it the same parameters.
    Then, store the `runnable` parameter, casting it to a `FileSearch` object:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这个类的构造函数。这个构造函数有两个参数：一个名为 `runnable` 的 `Runnable` 对象和一个名为 `result` 的 `List<String>`
    对象。在构造函数中，你必须调用父类的构造函数，并将相同的参数传递给它。然后，存储 `runnable` 参数，将其转换为 `FileSearch` 对象：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Override the `set()` method of the `FutureTask` class:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `FutureTask` 类的 `set()` 方法：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the parameter that it receives is null, store in it the result of calling
    the `getResults()` method of the `FileSearch` class:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它接收到的参数是 null，则将其存储为调用 `FileSearch` 类的 `getResults()` 方法的返回结果：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, call the parent''s method passing the received parameter as a parameter:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用父类的方法，将接收到的参数作为参数传递：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, implement the main class of the example. Create a class named `Main`
    and implement the `main()` method:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现示例的主类。创建一个名为 `Main` 的类并实现 `main()` 方法：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a `ThreadPoolExecutor` object named executor calling the `newCachedThreadPool()`
    method of the `Executors` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `Executors` 类的 `newCachedThreadPool()` 方法创建一个名为 `executor` 的 `ThreadPoolExecutor`
    对象：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create three `FileSearch` objects with a different initial folder for each
    one. You are going to look for files with the `log` extension:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个具有不同初始文件夹的 `FileSearch` 对象。你将查找具有 `log` 扩展名的文件：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create three `Task` objects to execute the search operations in the executor:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个 `Task` 对象以在执行器中执行搜索操作：
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Send these objects to the executor object using the `submit()` method. This
    version of the `submit()` method returns a `Future<?>` object, but you''re going
    to ignore it. You have a class that extends the `FutureTask` class to control
    the execution of this task:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `submit()` 方法将这些对象发送到执行器对象。这个版本的 `submit()` 方法返回一个 `Future<?>` 对象，但你将忽略它。你有一个扩展了
    `FutureTask` 类的类来控制这个任务的执行：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Call the `shutdown()` method of the executor object to indicate that it should
    finish its execution when these three tasks have finished:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用执行器对象的 `shutdown()` 方法，表示当这三个任务完成时，它应该完成其执行：
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Call the `awaitTermination()` method of the executor object, indicating a long
    waiting period to guarantee that this method won''t return until the three tasks
    have finished:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用执行器对象的 `awaitTermination()` 方法，表示一个较长的等待期，以确保这个方法不会在三个任务完成之前返回：
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For each task, write a message with the size of the result list using the `get()`
    method of the `Task` object:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个任务，使用 `Task` 对象的 `get()` 方法写一个包含结果列表大小的消息：
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first point to take into consideration to understand this example is the
    difference between the `submit()` method of the `ThreadPoolExecutor` class when
    you pass a `Callable` object as the parameter and the `submit()` method when you
    pass a `Runnable` object as the parameter. In the first case, you can use the
    `Future` object that this method returns to control the status of the task and
    to get its result. But in the second case, when you pass a `Runnable` object,
    you can only use the `Future` object that this method returns to control the status
    of the task. If you call the `get()` method of that `Future` object, you will
    get a null value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个示例的第一个要点是，当将 `Callable` 对象作为参数传递给 `ThreadPoolExecutor` 类的 `submit()` 方法时，与将
    `Runnable` 对象作为参数传递时的 `submit()` 方法的区别。在前一种情况下，你可以使用这个方法返回的 `Future` 对象来控制任务的状态并获取其结果。但在第二种情况下，当你传递一个
    `Runnable` 对象时，你只能使用这个方法返回的 `Future` 对象来控制任务的状态。如果你调用那个 `Future` 对象的 `get()` 方法，你会得到一个
    null 值。
- en: 'To override this behavior, you have implemented the `Task` class. This class
    extends the `FutureTask` class that is a class that implements the `Future` interface
    and the `Runnable` interface. When you call a method that returns a `Future` object
    (for example, the `submit()` method), you will normally get a `FutureTask` object.
    So you can use this class with two objectives:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖此行为，您已实现了`Task`类。这个类扩展了实现了`Future`接口和`Runnable`接口的`FutureTask`类。当您调用返回`Future`对象的方法（例如，`submit()`方法）时，您通常会得到一个`FutureTask`对象。因此，您可以使用这个类实现两个目标：
- en: First, execute the `Runnable` object (in this case, a `FileSearch` object).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，执行`Runnable`对象（在这种情况下，一个`FileSearch`对象）。
- en: Second, return the results that this task generates. To achieve this, you have
    overridden the `set()` method of the `Task` class. Internally, the `FutureTask`
    class controls when the task it has to execute has finished. At that moment, it
    makes a call to the `set()` method to establish the return value of the task.
    When you are executing a `Callable` object, this call is made with the value returned
    by the `call()` method, but when you are executing a `Runnable` object, this call
    is made with the null value. You have changed this null value with the list of
    results generated by the `FileSearch` object. The `set()` method will only have
    effect the first time it is called. When it's called for the first time, it marks
    the task as finished and the rest of the calls will not modify the return value
    of the task.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，返回此任务生成的结果。为了实现这一点，您已覆盖了`Task`类的`set()`方法。内部，`FutureTask`类控制它必须执行的任务何时完成。在那个时刻，它调用`set()`方法来设置任务的返回值。当您执行`Callable`对象时，这个调用使用`call()`方法返回的值，但当您执行`Runnable`对象时，这个调用使用null值。您已将此null值更改为由`FileSearch`对象生成的结果列表。`set()`方法只有在第一次调用时才会生效。当它第一次被调用时，它将任务标记为完成，其余的调用将不会修改任务的返回值。
- en: In the `Main` class, instead of sending the `FutureTasks` objects to the `Callable`
    or `Runnable` objects, you can send it to the executor object. The main difference
    is that you use the `FutureTasks` objects to get the results of the task instead
    of the `Future` object returned by the `submit()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`类中，您可以将`FutureTask`对象发送到执行器对象，而不是发送到`Callable`或`Runnable`对象。主要区别在于您使用`FutureTask`对象来获取任务的结果，而不是使用`submit()`方法返回的`Future`对象。
- en: In this case, you can still use the `Future` object returned by the `submit()`
    method to control the status of the task but remember that, as this task executes
    a `Runnable` object (you have initialized the `FutureTasks` objects with the `FileSearch`
    objects that implement the `Runnable` interface), if you call the `get()` method
    in the `Future` objects, you will get the null value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您仍然可以使用`submit()`方法返回的`Future`对象来控制任务的状态，但请记住，由于此任务执行一个`Runnable`对象（您已使用实现了`Runnable`接口的`FileSearch`对象初始化了`FutureTask`对象），如果您在`Future`对象中调用`get()`方法，您将得到null值。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `FutureTask` class provides a method not included in the `Future` interface.
    It's the `setException()` method. This method receives a `Throwable` object as
    the parameter and when the `get()` method is called, an `ExecutionException` exception
    will be thrown. This call has an effect only if the `set()` method of the `FutureTask`
    object hasn't been called yet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`FutureTask`类提供了一个不在`Future`接口中包含的方法。它是`setException()`方法。此方法接收一个`Throwable`对象作为参数，当调用`get()`方法时，将抛出`ExecutionException`异常。此调用只有在尚未调用`FutureTask`对象的`set()`方法时才有效。'
- en: See also
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736)的*在返回结果的执行器中执行任务*菜谱中，*线程执行器*
- en: The *Creating, running, and setting the characteristics of a thread* recipe
    in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736), *Thread
    Management*
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736)的*创建、运行和设置线程特性*菜谱中，*线程管理*
- en: Processing uncontrolled exceptions in a ForkJoinPool class
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ForkJoinPool类中处理不受控制的异常
- en: The fork/join framework gives you the possibility to set a handler for the exceptions
    thrown by the worker threads of a `ForkJoinPool` class. When you work with a `ForkJoinPool`
    class, you should understand the difference between tasks and worker threads.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/Join框架为您提供了为`ForkJoinPool`类的工作线程抛出的异常设置处理程序的可能性。当您使用`ForkJoinPool`类工作时，您应该了解任务和工作线程之间的区别。
- en: To work with the fork/join framework, you implement a task extending the `ForkJoinTask`
    class or, usually, the `RecursiveAction` or `RecursiveTask` classes. The task
    implements the actions you want to execute concurrently with the framework. They
    are executed in the `ForkJoinPool` class by the worker threads. A worker thread
    will execute various tasks. In the work-stealing algorithm implemented by the
    `ForkJoinPool` class, a worker thread looks for a new task when the task it was
    executing finishes its execution or it is waiting for the completion of another
    task.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 fork/join 框架一起工作，你实现一个扩展 `ForkJoinTask` 类的任务，通常是 `RecursiveAction` 或 `RecursiveTask`
    类。任务实现了你想要与框架并发执行的操作。它们由工作线程在 `ForkJoinPool` 类中执行。工作线程将执行各种任务。在 `ForkJoinPool`
    类实现的 work-stealing 算法中，当工作线程执行的任务完成其执行或正在等待另一个任务的完成时，它将寻找新的任务。
- en: 'In this recipe, you will learn how to process the exceptions thrown by a worker
    thread. You''ll have to implement two additional elements for it to work as described
    in the following items:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何处理工作线程抛出的异常。为了使其按以下项目所述工作，你必须实现两个额外的元素：
- en: The first element is an extended class of the `ForkJoinWorkerThread` class.
    This class implements the worker thread of a `ForkJoinPool` class. You will implement
    a basic child class that will throw an exception.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个元素是 `ForkJoinWorkerThread` 类的扩展类。这个类实现了 `ForkJoinPool` 类的工作线程。你将实现一个基本的子类，该子类将抛出异常。
- en: The second element is a factory to create worker threads of your own custom
    type. The `ForkJoinPool` class uses a factory to create its worker threads. You
    have to implement a class that implements the `ForkJoinWorkerThreadFactory` interface
    and uses an object of that class in the constructor of the `ForkJoinPool` class.
    The `ForkJoinPool` object created will use that factory to create worker threads.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个元素是创建自定义类型工作线程的工厂。`ForkJoinPool` 类使用工厂来创建其工作线程。你必须实现一个类，该类实现了 `ForkJoinWorkerThreadFactory`
    接口，并在 `ForkJoinPool` 类的构造函数中使用该类的对象。创建的 `ForkJoinPool` 对象将使用该工厂来创建工作线程。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to implement the example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现示例：
- en: 'First, implement your own worker thread class. Create a class named `AlwaysThrowsExceptionWorkerThread`
    that extends the `ForkJoinWorkerThread` class:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，实现你自己的工作线程类。创建一个名为 `AlwaysThrowsExceptionWorkerThread` 的类，该类扩展了 `ForkJoinWorkerThread`
    类：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the constructor of the class. It receives a `ForkJoinPool` class
    as a parameter and calls the constructor of its parent class:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它接收一个 `ForkJoinPool` 类作为参数，并调用其父类的构造函数：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the `onStart()` method. This is a method of the `ForkJoinWorkerThread`
    class and is executed when the worker thread begins its execution. The implementation
    will throw a `RuntimeException` exception upon being called:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `onStart()` 方法。这是 `ForkJoinWorkerThread` 类的一个方法，在工作线程开始执行时执行。当被调用时，实现将抛出一个
    `RuntimeException` 异常：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, implement the factory needed to create your worker threads. Create a class
    named `AlwaysThrowsExceptionWorkerThreadFactory` that implements the `ForkJoinWorkerThreadFactory`
    interface:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现创建工作线程所需的工厂。创建一个名为 `AlwaysThrowsExceptionWorkerThreadFactory` 的类，该类实现了
    `ForkJoinWorkerThreadFactory` 接口：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `newThread()` method. It receives a `ForkJoinPool` object as
    the parameter and returns a `ForkJoinWorkerThread` object. Create an `AlwaysThrowsExceptionWorkerThread`
    object and return it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `newThread()` 方法。它接收一个 `ForkJoinPool` 对象作为参数，并返回一个 `ForkJoinWorkerThread`
    对象。创建一个 `AlwaysThrowsExceptionWorkerThread` 对象并返回它：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement a class that will manage the exceptions thrown by worker threads.
    Implement a class named `Handler` that implements the `UncaughtExceptionHandler`
    interface:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个将管理工作线程抛出的异常的类。实现一个名为 `Handler` 的类，该类实现了 `UncaughtExceptionHandler` 接口：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement the `uncaughtException()` method. It receives as parameters a Thread
    object and a `Throwable` object and is called by the `ForkJoinPool` class each
    time a worker thread throws an exception. Write a message to the console and exit
    the program:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `uncaughtException()` 方法。它接收一个线程对象和一个 `Throwable` 对象作为参数，并在工作线程抛出异常时由 `ForkJoinPool`
    类调用。向控制台写入一条消息并退出程序：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, implement a task to be executed in the `ForkJoinPool` executor. Create
    a class named `OneSecondLongTask` that extends the `RecursiveAction` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一个要在 `ForkJoinPool` 执行器中执行的任务。创建一个名为 `OneSecondLongTask` 的类，该类扩展了 `RecursiveAction`
    类：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `compute()` method. It simply puts the thread to sleep after
    one second:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现了 `compute()` 方法。它简单地在经过一秒后将线程休眠：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, implement the main class of the example. Create a class named Main with
    a `main()` method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现示例的主类。创建一个名为 Main 的类，并包含一个 `main()` 方法：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new `OneSecondLongTask` object:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `OneSecondLongTask` 对象：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a new Handler object:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Handler 对象：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new `AlwaysThrowsExceptionWorkerThreadFactory` object:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `AlwaysThrowsExceptionWorkerThreadFactory` 对象：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a new `ForkJoinPool` object. Pass as parameters the value `2`, the factory
    object, the handler object, and the value `false`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `ForkJoinPool` 对象。将值 `2`、工厂对象、处理程序对象和值 `false` 作为参数传递：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Execute the task in the pool using the `execute()` method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `execute()` 方法在池中执行任务：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Shut down the pool with the `shutdown()` method.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法关闭池：
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Wait for the finalization of the tasks using the `awaitTermination()` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `awaitTermination()` 方法等待任务的最终化：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Write a message indicating the end of the program:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一条消息以指示程序的结束：
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, you have implemented the following elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你实现了以下元素：
- en: '**Your own worker thread class**: You have implemented the `AlwaysThrowsExceptionWorkerThread`
    class, which extends the `ForkJoinWorkerThread` class, which implements the worker
    threads of a fork/join pool. You have overridden the `onStart()` method. This
    method is executed when a worker thread starts its execution. It simply throws
    an exception `RuntimeException` upon being called.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你自己的工作线程类**：你已经实现了 `AlwaysThrowsExceptionWorkerThread` 类，它扩展了 `ForkJoinWorkerThread`
    类，该类实现了 fork/join 池的工作线程。你已经重写了 `onStart()` 方法。该方法在工作线程开始执行时执行。它简单地在被调用时抛出一个 `RuntimeException`
    异常。'
- en: '**Your own thread factory**: A `ForkJoinPool` class creates its worker threads
    using a factory. As you want to create a `ForkJoinPool` object that uses the `AlwaysThrowsExceptionWorkerThreadFactory`
    worker threads, you have implemented a factory that creates them. To implement
    a worker thread factory, you need to implement the `ForkJoinWorkerThreadFactory`
    interface. This interface only has a method named `newThread()`, which creates
    the worker thread and returns it to the `ForkJoinPool` class.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你自己的线程工厂**：`ForkJoinPool` 类使用一个工厂来创建其工作线程。由于你想创建一个使用 `AlwaysThrowsExceptionWorkerThreadFactory`
    工作线程的 `ForkJoinPool` 对象，你已经实现了一个创建它们的工厂。要实现工作线程工厂，你需要实现 `ForkJoinWorkerThreadFactory`
    接口。该接口只有一个名为 `newThread()` 的方法，该方法创建工作线程并将其返回给 `ForkJoinPool` 类。'
- en: '**A task class**: The worker threads execute the tasks you send to the `ForkJoinPool`
    executor. As you want to start the execution of a worker thread, you need to send
    a task to the `ForkJoinPool` executor. The task sleeps for one second, but, as
    the `AlwaysThrowsExceptionWorkerThread` thread throws an exception, it will never
    be executed.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务类**：工作线程执行你发送给 `ForkJoinPool` 执行器的任务。由于你想启动工作线程的执行，你需要将任务发送给 `ForkJoinPool`
    执行器。任务会休眠一秒，但由于 `AlwaysThrowsExceptionWorkerThread` 线程抛出异常，它将永远不会被执行。'
- en: '**A handler class for uncaught exceptions**: When a worker thread throws an
    exception, the `ForkJoinPool` class checks whether an exception handler has been
    registered. You have implemented the `Handler` class for this purpose. This handler
    implements the `UncaughtExceptionHandler` interface, which only has one method,
    that is, the `uncaughtException()` method. This method receives as a parameter
    the thread that throws the exception and the exception it throws.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未捕获异常的处理程序类**：当工作线程抛出异常时，`ForkJoinPool` 类会检查是否已注册异常处理程序。你已实现了 `Handler` 类来完成此目的。此处理程序实现了
    `UncaughtExceptionHandler` 接口，该接口只有一个方法，即 `uncaughtException()` 方法。该方法接收一个参数，即抛出异常的线程及其抛出的异常。'
- en: 'In the Main class, you have put together all these elements. You have passed
    to the constructor of the `ForkJoinPool` class four parameters: the parallelism
    level, the number of active worker threads you want to have, the worker thread
    factory you want to use in the `ForkJoinPool` object, the handler you want to
    use for the uncaught exceptions of the worker threads, and the async mode.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Main 类中，你已经将这些元素组合在一起。你向 `ForkJoinPool` 类的构造函数传递了四个参数：并行级别、你想要拥有的活动工作线程数量、你想要在
    `ForkJoinPool` 对象中使用的线程工厂、你想要用于工作线程未捕获异常的处理程序，以及异步模式。
- en: 'The following screenshot shows the result of an execution of this example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的执行结果：
- en: '![](img/00073.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: When you execute the program, a worker thread throws a `RuntimeException` exception.
    The `ForkJoinPool` class hands it over to your handler, which in turn writes the
    message to the console and exits the program. The task doesn't start its execution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，一个工作线程抛出一个`RuntimeException`异常。`ForkJoinPool`类将其传递给你的处理器，然后处理器将消息写入控制台并退出程序。任务不会开始执行。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can test two interesting variants of this example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以测试这个示例的两个有趣的变体：
- en: 'If you comment the following line in the Handler class and execute the program,
    you will see a lot of messages written in the console. The `ForkJoinPool` class
    tries to start a worker thread to execute the task and, as it can''t because they
    always throw an exception, it tries it over and over again:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你取消注释处理器类中的以下行并执行程序，你将在控制台看到很多消息。`ForkJoinPool`类试图启动一个工作线程来执行任务，因为它无法执行（因为它们总是抛出异常），所以它一次又一次地尝试：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Something like that occurs if you change the third parameter (the exception
    handler) of the `ForkJoinPool` class constructor for the null value. In this case,
    you will see how the JVM writes the exceptions in the console.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将`ForkJoinPool`类构造函数的第三个参数（异常处理器）改为null值，就会发生类似的情况。在这种情况下，你将看到JVM如何在控制台写入异常。
- en: Take this into account when you implement your own worker threads that could
    throw exceptions.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现自己的工作线程并可能抛出异常时，请考虑这一点。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第5章的*创建fork/join池*配方中，*Fork/Join框架*，[第6节](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736)
- en: The *Customizing tasks running in the fork/join framework* and *Implementing
    the ThreadFactory interface to generate custom threads for the fork/join framework*
    recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8章的*自定义在fork/join框架中运行的任务*和*实现ThreadFactory接口以生成fork/join框架的自定义线程*配方中，*自定义并发类*，[第6节](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736)
- en: Using a blocking thread-safe queue for communicating with producers and consumers
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阻塞线程安全的队列与生产者和消费者进行通信
- en: The producer/consumer problem is a classical problem in concurrent programming.
    You have one or more producers of data that store this data in a buffer. You also
    have one or more consumers of data that take the data from the same buffer. Both
    producers and consumers share the same buffer, so you have to control access to
    it to avoid data inconsistency problems. When the buffer is empty, the consumers
    wait until the buffer has elements. If the buffer is full, the producers wait
    until the buffer has empty space.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者/消费者问题是并发编程中的一个经典问题。你有一个或多个生产者将数据存储在缓冲区中。你还有一个或多个消费者从同一个缓冲区中获取数据。生产者和消费者共享同一个缓冲区，因此你必须控制对其的访问以避免数据不一致问题。当缓冲区为空时，消费者会等待直到缓冲区有元素。如果缓冲区已满，生产者会等待直到缓冲区有空闲空间。
- en: This problem has been implemented using almost all the techniques and synchronization
    mechanisms developed in Java and in other languages (refer to the *See Also* section
    to get more information). One advantage of this problem is that it can be extrapolated
    to a lot of real-world situations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题已经使用Java和其他语言中开发的几乎所有技术和同步机制来实现（有关更多信息，请参阅*参见*部分）。这个问题的优点是它可以推广到许多现实世界的情况。
- en: 'The Java 7 Concurrency API introduced a data structure oriented to be used
    in these kinds of problem. It''s the `LinkedTransferQueue` class, and its main
    characteristics are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7并发API引入了一个面向这些类型问题的数据结构。它是`LinkedTransferQueue`类，其主要特点如下：
- en: It's a blocking data structure. The thread is blocked until the operation can
    be made, provided that the operations are performed immediately.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个阻塞的数据结构。线程在操作可以执行之前会被阻塞，前提是操作立即执行。
- en: Its size has no limit. You can insert as many elements as you want.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的大小没有限制。你可以插入你想要的任意多个元素。
- en: It's a parameterized class. You have to indicate the class of the elements you're
    going to store in the list.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个参数化类。你必须指定你打算存储在列表中的元素的类。
- en: In this recipe, you will learn how to use the `LinkedTransferQueue` class running
    a lot of producer and consumer tasks that share a buffer of strings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何使用`LinkedTransferQueue`类运行许多共享字符串缓冲区的生产者和消费者任务。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或任何其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to implement the example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现示例：
- en: 'Create a class named `Producer` and specify that it implements the `Runnable`
    interface:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Producer`的类，并指定它实现`Runnable`接口：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare a private `LinkedTransferQueue` attribute parameterized with the `String`
    class named buffer:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`buffer`的私有`LinkedTransferQueue`属性，参数化为`String`类：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare a private `String` attribute named name to store the name of the producer:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性以存储生产者的名称：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `run()` method. Store `10,000` strings in the buffer using the
    `put()` method of the buffer object and write a message to the console indicating
    the end of the method:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该`run()`方法。使用缓冲区对象的`put()`方法将`10,000`个字符串存储在缓冲区中，并向控制台写入一条消息，表示方法结束：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement a class named `Consumer` and specify that it implements the `Runnable`
    interface:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`Consumer`的类，并指定它实现`Runnable`接口：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Declare a private `LinkedTransferQueue` attribute parameterized with the `String`
    class named buffer:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`buffer`的私有`LinkedTransferQueue`属性，参数化为`String`类：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Declare a private `String` attribute named name to store the name of the consumer:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性以存储消费者的名称：
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement the `run()` method. Take out 10,000 strings from the buffer using
    the `take()` method of the buffer object and write a message to the console indicating
    the end of the method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该`run()`方法。使用缓冲区对象的`take()`方法从缓冲区中取出10,000个字符串，并向控制台写入一条消息，表示方法结束：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the main class of the example. Create a class named `Main` and add
    to it the `main()` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现示例的主类。创建一个名为`Main`的类，并向其中添加`main()`方法：
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Declare a constant named `THREADS` and assign to it the value `100`. Create
    a `LinkedTransferQueue` object with the `String` class object and call it buffer:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`THREADS`的常量，并将其值设置为`100`。创建一个参数化为`String`类的`LinkedTransferQueue`对象，并将其命名为buffer：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create an array of 100 Thread objects to execute 100 producer tasks:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含100个`Thread`对象的数组以执行100个生产者任务：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create an array of 100 Thread objects to execute 100 consumer tasks:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含100个`Thread`对象的数组以执行100个消费者任务：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create and launch 100 `Consumer` objects and store the threads in the array
    created earlier:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动100个`Consumer`对象，并将线程存储在之前创建的数组中：
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create and launch 100 `Producer` objects and store the threads in the array
    created earlier:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动100个`Producer`对象，并将线程存储在之前创建的数组中：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的最终化：
- en: '[PRE59]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Write a message to the console with the size of the buffer:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入一条包含缓冲区大小的消息：
- en: '[PRE60]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you have used the `LinkedTransferQueue` class parameterized
    with the String class to implement the producer/consumer problem. This `LinkedTransferQueue`
    class is used as a buffer to share the data between producers and consumers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你使用了参数化为`String`类的`LinkedTransferQueue`类来实现生产者/消费者问题。这个`LinkedTransferQueue`类被用作缓冲区，在生产者和消费者之间共享数据。
- en: You have implemented a `Producer` class that adds strings to the buffer using
    the `put()` method. You have executed 100 producers and every producer inserts
    in the buffer 10,000 strings, so you insert 1,000,000 strings in the buffer. The
    `put()` method adds the element at the end of the buffer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了一个`Producer`类，使用`put()`方法向缓冲区添加字符串。你已经执行了100个生产者，每个生产者在缓冲区中插入10,000个字符串，因此你在缓冲区中插入了1,000,000个字符串。`put()`方法将元素添加到缓冲区的末尾。
- en: You also have implemented a `Consumer` class, which gets a string from the buffer
    using the `take()` method. This method returns and deletes the first element of
    the buffer. If the buffer is empty, the method blocks the thread that makes the
    call until there are strings in the buffer to consume. You have executed 100 consumers,
    and every consumer gets 10,000 strings from the buffer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你还实现了一个`Consumer`类，该类使用`take()`方法从缓冲区中获取字符串。此方法返回并删除缓冲区的第一个元素。如果缓冲区为空，则该方法将阻塞调用线程，直到缓冲区中有可消费的字符串。你已经执行了100个消费者，每个消费者从缓冲区中获取10,000个字符串。
- en: In the example, first, you have launched the consumers and then the producers,
    so, as the buffer is empty, all the consumers will be blocked until the producers
    begin their execution and stores strings in the list.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，首先启动了消费者，然后是生产者，因此，由于缓冲区为空，所有消费者都将被阻塞，直到生产者开始执行并将字符串存储在列表中。
- en: 'The following screenshot shows part of the output of an execution of this example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例执行的部分输出：
- en: '![](img/00074.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00074.jpeg)'
- en: To write the number of elements of the buffer, you have used the `size()` method.
    You have to take into account that this method can return a value that is not
    real, if you use them when there are threads adding or deleting data in the list.
    The method has to traverse the entire list to count the elements and the contents
    of the list can change for this operation. Only if you use them when there aren't
    any threads modifying the list, you will have the guarantee that the returned
    result is correct.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入缓冲区中的元素数量，你使用了`size()`方法。你必须考虑到，如果你在列表中有线程添加或删除数据时使用此方法，它可能返回一个非真实值。该方法必须遍历整个列表来计数元素，并且列表的内容可能会因为此操作而改变。只有在你没有线程修改列表时使用它们，你才能保证返回的结果是正确的。
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The `LinkedTransferQueue` class provides other useful methods. The following
    are some of them:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedTransferQueue`类提供了其他有用的方法。以下是一些：'
- en: '`getWaitingConsumerCount()`: This method returns the number of consumers that
    are blocked in the `take()` method or `poll (long timeout, TimeUnit unit)` because
    the `LinkedTransferQueue` object is empty.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getWaitingConsumerCount()`: 此方法返回因为`LinkedTransferQueue`对象为空而在`take()`方法或`poll
    (long timeout, TimeUnit unit)`中被阻塞的消费者数量。'
- en: '`hasWaitingConsumer()`: This method returns `true` if the `LinkedTransferQueue`
    object has consumers waiting, or false otherwise.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasWaitingConsumer()`: 如果`LinkedTransferQueue`对象有等待的消费者，则此方法返回`true`，否则返回`false`。'
- en: '`offer(E e)`: This method adds the element passed as a parameter at the end
    of the `LinkedTransferQueue` object and returns the true value. `E` represents
    the class used to parameterize the declaration of the `LinkedTransferQueue` class
    or a subclass of it.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offer(E e)`: 此方法将作为参数传递的元素添加到`LinkedTransferQueue`对象的末尾，并返回true值。`E`代表用于参数化`LinkedTransferQueue`类声明或其子类的类。'
- en: '`peek()`: This method returns the first element in the `LinkedTransferQueue`
    object, but it doesn''t delete it from the list. If the queue is empty, the method
    returns the null value.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法返回`LinkedTransferQueue`对象中的第一个元素，但不从列表中删除它。如果队列是空的，则方法返回null值。'
- en: '`poll(long timeout, TimeUnit unit)`: This version of the poll method, if the
    `LinkedTransferQueue` buffer is empty, waits for it for a specified period of
    time. If the specified period of time passes and the buffer is still empty, the
    method returns a `null` value. The `TimeUnit` class is an enumeration with the
    following constants-`DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`,
    `NANOSECONDS`, and `SECONDS`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll(long timeout, TimeUnit unit)`: 此版本的`poll`方法，如果`LinkedTransferQueue`缓冲区为空，将等待指定的时间。如果指定的时间过去后缓冲区仍然为空，则方法返回`null`值。`TimeUnit`类是一个枚举，具有以下常量-`DAYS`，`HOURS`，`MICROSECONDS`，`MILLISECONDS`，`MINUTES`，`NANOSECONDS`和`SECONDS`。'
- en: See also
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using conditions in synchronized code* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736)的*使用同步代码中的条件*配方中，*基本线程同步*
- en: The *Exchanging data between concurrent tasks* recipe in [Chapter 3](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Synchronization Utilities*
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736)的*在并发任务之间交换数据*配方中，*线程同步工具*
- en: Monitoring a Thread class
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控线程类
- en: Threads are the most basic element of the Java Concurrency API. Every Java program
    has at least one thread that executes the `main()` method, which, in turn, starts
    the execution of the application. When you launch a new `Thread` class, it's executed
    in parallel with the other threads of the application and with the other processes
    on an operating system. There is a critical difference between process and thread.
    A process is an instance of an application that is running (for example, you're
    editing a document in a text processor). This process has one or more threads
    that execute the tasks that make the process. You can be running more than one
    process of the same application, for example, two instances of the text processor.
    Threads inside a process share the memory while processes of the same OS don't.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是Java并发API中最基本的元素。每个Java程序至少有一个执行`main()`方法的线程，它反过来启动应用程序的执行。当你启动一个新的`Thread`类时，它将与应用程序的其他线程以及操作系统上的其他进程并行执行。进程和线程之间存在一个关键的区别。进程是一个正在运行的应用程序的实例（例如，你正在文本处理器中编辑文档）。此进程有一个或多个执行使进程运行的任务的线程。你可以运行同一应用程序的多个进程，例如，两个文本处理器的实例。进程内的线程共享内存，而同一操作系统上的进程则不共享。
- en: All the kinds of Java tasks that you can execute (`Runnable`, `Callable`, or
    fork/join tasks) are executed in threads, and all the advanced Java concurrency
    mechanisms, such as the `Executor` framework and the fork/join framework, are
    based on pools of threads.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行的Java任务类型（`Runnable`、`Callable`或fork/join任务）都是在线程中执行的，所有高级Java并发机制，如`Executor`框架和fork/join框架，都是基于线程池的。
- en: In this recipe, you will learn what information you can obtain about the status
    of a `Thread` class and how to obtain it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习你可以从`Thread`类的状态中获得哪些信息，以及如何获取这些信息。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例使用Eclipse IDE实现。如果你使用Eclipse或任何其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to implement the example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现示例：
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类实现了`Runnable`接口：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Implement the `run()` method of the task:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现任务的`run()`方法：
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create a loop with 100 steps:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含100个步骤的循环：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In each step, put the thread to sleep for 100 milliseconds:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个步骤中，让线程休眠100毫秒：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Write a message in the console with the name of the thread and the step number:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出一条消息，包含线程的名称和步骤编号：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create the main class of the example. Create a class named `Main` with a `main()`
    method:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建示例的主类。创建一个名为`Main`的类，并包含一个`main()`方法：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a `Task` object named task:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`task`的`Task`对象：
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a `Thread` array with five elements:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个元素的`Thread`数组：
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create and start five threads to execute the `Task` object created earlier:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动五个线程来执行之前创建的`Task`对象：
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a loop with ten steps to write information about the threads launched
    before. Inside it, create another loop with five steps:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含十个步骤的循环来输出之前启动的线程的信息。在它内部，创建另一个包含五个步骤的循环：
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For each thread, write its name, its status, its group, and the length of its
    stack trace in the console:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个线程，在控制台输出其名称、状态、所属组和堆栈跟踪的长度：
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Write a loop to write the stack trace of the thread:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个循环来输出线程的堆栈跟踪：
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Put the thread to sleep for one second and close the loop and the class:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让线程休眠一秒，然后关闭循环和类：
- en: '[PRE73]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, you have used the following methods to get information about
    a `Thread` class:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你使用了以下方法来获取`Thread`类的信息：
- en: '`getId()`: This method returns the ID of a thread. It''s a unique long number
    and it can''t be changed.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId()`: 此方法返回线程的ID。它是一个唯一的long数字，不能更改。'
- en: '`getName()`: This method returns the name of a thread. If you don''t establish
    the name of the thread, Java gives it a default name.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getName()`: 此方法返回线程的名称。如果你没有为线程设置名称，Java会为其提供一个默认名称。'
- en: '`getPriority()`: This method returns the priority of execution of a thread.
    Threads with higher priority are executed in preference to threads with lower
    priority. It''s an `int` value that has a value between the `MIN_PRIORITY` and
    `MAX_PRIORITY` constants of the `Thread` class. By default, threads are created
    with the same priority that specified by the constant `NORM_PRIORITY` of the `Thread`
    class.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPriority()`: 这个方法返回线程的执行优先级。优先级较高的线程会优先于优先级较低的线程执行。它是一个介于`Thread`类的`MIN_PRIORITY`和`MAX_PRIORITY`常量之间的`int`值。默认情况下，线程会以`Thread`类中常量`NORM_PRIORITY`指定的相同优先级创建。'
- en: '`getState()`: This method returns the status of a thread. It''s a `Thread.State`
    object. The `Thread.State` enumeration has all the possible states of a thread.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`: 这个方法返回线程的状态。它是一个`Thread.State`对象。`Thread.State`枚举包含了线程的所有可能状态。'
- en: '`getThreadGroup()`: This method returns the `ThreadGroup` object of a thread.
    By default, threads belong to the same thread group, but you can establish a different
    one in the constructor of a thread.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getThreadGroup()`: 这个方法返回线程的`ThreadGroup`对象。默认情况下，线程属于同一个线程组，但你可以在线程的构造函数中创建一个不同的线程组。'
- en: '`getStackTrace()`: This method returns an array of `StackTraceElement` objects.
    Each of these objects represent a call to a method that begins with the `run()`
    method of a thread and includes all the methods that have been called until the
    actual execution point. When a new method is called, a new stack trace element
    is added to the array. When a method finishes its execution, its stack trace element
    is removed from the array.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStackTrace()`: 这个方法返回一个`StackTraceElement`对象的数组。这些对象中的每一个代表从线程的`run()`方法开始的调用，包括所有被调用的方法，直到实际的执行点。当调用一个新的方法时，一个新的堆栈跟踪元素会被添加到数组中。当一个方法完成执行后，它的堆栈跟踪元素会被从数组中移除。'
- en: There's more...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Thread` class includes other methods that provide information about it
    that can be useful. These methods are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类包括其他一些方法，这些方法提供了关于线程的信息，可能很有用。这些方法如下：'
- en: '`activeCount()`: This method returns the number of active threads in a group
    of threads.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activeCount()`: 这个方法返回线程组中活动线程的数量。'
- en: '`dumpStack()`: This method prints the stack trace of a thread to the standard
    error output.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumpStack()`: 这个方法将线程的堆栈跟踪打印到标准错误输出。'
- en: See also
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating, running, and setting the characteristics of a thread* recipe
    in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736), *Thread
    Management*
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736)，“线程管理”中的*创建、运行和设置线程的特性*配方
- en: The *Using a ThreadFactory interface in an Executor framework* and *Implementing
    a ThreadFactory interface to generate custom threads for the fork/join framework*
    recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736)，“自定义并发类”中的*在Executor框架中使用ThreadFactory接口*和*在fork/join框架中实现ThreadFactory接口以生成自定义线程*的配方
- en: Monitoring a Semaphore class
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控信号量类
- en: A semaphore is a counter that protects the access to one or more shared resources.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是一个保护一个或多个共享资源访问的计数器。
- en: The concept of semaphore was introduced by Edsgar Dijkstra in 1965 and was used
    for the first time in the THEOS operating system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的概念是由Edsgar Dijkstra在1965年提出的，并首次用于THEOS操作系统。
- en: When a thread wants to use shared resources, it must acquire a semaphore. If
    the internal counter of the semaphore is greater than 0, the semaphore decrements
    the counter and allows the access to the shared resource. If the counter of the
    semaphore is 0, the semaphore blocks the thread until the counter is greater than
    0\. When the thread has finished using the shared resource, it must release the
    semaphore. That operation increases the internal counter of the semaphore.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程想要使用共享资源时，它必须获取一个信号量。如果信号量的内部计数器大于0，信号量会减少计数器并允许访问共享资源。如果信号量的计数器为0，信号量会阻塞线程，直到计数器大于0。当线程完成使用共享资源后，它必须释放信号量。这个操作会增加信号量的内部计数器。
- en: In Java, semaphores are implemented in the `Semaphore` class.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，信号量是在`Semaphore`类中实现的。
- en: In this recipe, you will learn what information you can obtain about the status
    of a semaphore and how to obtain it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习你可以获取关于信号量状态的哪些信息以及如何获取这些信息。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或任何其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to implement the example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现示例：
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类实现了`Runnable`接口：
- en: '[PRE74]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Declare a private `Semaphore` attribute named `semaphore`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`semaphore`的私有`Semaphore`属性：
- en: '[PRE75]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE76]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Implement the `run()` method. First, acquire permit for the `semaphore` attribute
    writing a message in the console to indicate that circumstance:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。首先，获取`semaphore`属性的许可，并在控制台写入一条消息以指示该情况：
- en: '[PRE77]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, put the thread to sleep for two seconds using the `sleep()` method. Finally,
    release the permit and write a message in the console to indicate that circumstance:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`sleep()`方法将线程休眠两秒。最后，释放许可，并在控制台写入一条消息以指示该情况：
- en: '[PRE78]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Implement the main class of the example. Create a class named `Main` with a
    `main()` method:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现示例的主类。创建一个名为`Main`的类，其中包含一个`main()`方法：
- en: '[PRE79]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a `Semaphore` object named `semaphore` with three permits:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`semaphore`的`Semaphore`对象，具有三个许可：
- en: '[PRE80]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create an array to store 10 `Thread` objects:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数组以存储10个`Thread`对象：
- en: '[PRE81]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create and start 10 `Thread` objects to execute 10 `Task` objects. After starting
    a thread, put the thread to sleep for 200 milliseconds and call the `showLog()`
    method to write information about the `Semaphore` class:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动10个`Thread`对象以执行10个`Task`对象。启动线程后，将其休眠200毫秒，并调用`showLog()`方法来记录关于`Semaphore`类的信息：
- en: '[PRE82]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Implement a loop with five steps to call the `showLog()` method to write information
    about the `semaphore` and put the thread to sleep for `1` second:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个包含五个步骤的循环，调用`showLog()`方法记录关于`semaphore`的信息，并将线程休眠`1`秒：
- en: '[PRE83]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Implement the `showLog()` method. It receives a `Semaphore` object as parameter.
    Write in the console information about the available permits, queued threads,
    and permits of the `semaphore`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`showLog()`的方法。它接收一个`Semaphore`对象作为参数。在控制台写入有关可用许可、队列线程和`semaphore`许可的信息：
- en: '[PRE84]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, you have used the following methods to get information about
    a `semaphore`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您已使用以下方法来获取关于`semaphore`的信息：
- en: '`availablePermits()`: This method returns an `int` value, which is the number
    of available resources of a semaphore.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`availablePermits()`: 此方法返回一个`int`值，表示信号量的可用资源数量。'
- en: '`hasQueuedThreads()`: This method returns a Boolean value indicating if there
    are threads waiting for a resource protected by a semaphore.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasQueuedThreads()`: 此方法返回一个布尔值，指示是否有线程正在等待由信号量保护的资源。'
- en: '`getQueueLength()`: This method returns the number of threads that are waiting
    for a resource protected by a semaphore.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueueLength()`: 此方法返回正在等待由信号量保护的资源的线程数量。'
- en: '`isFair()`: This method returns a Boolean value indicating if a semaphore has
    the fair mode activated. When the fair mode is active (this method returns the
    true value), and the lock has to select another thread to give to it the access
    to the shared resource, it selects the longest-waiting thread. If the fair mode
    is inactive (this method returns the false value), there is no guarantee about
    the order in which threads are selected to get the access to the shared resource.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFair()`: 此方法返回一个布尔值，指示信号量是否激活了公平模式。当公平模式激活（此方法返回true值）时，并且锁必须选择另一个线程以提供对共享资源的访问时，它选择等待时间最长的线程。如果公平模式未激活（此方法返回false值），则没有关于线程选择顺序的保证。'
- en: See also
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Controlling concurrent access to one or more copies of a resource* recipes
    in [Chapter 3](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736), *Thread
    Synchronization Utilities*
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736)的*控制对资源的一个或多个副本的并发访问*食谱中，*线程同步工具*
- en: Generating concurrent random numbers
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成并发随机数
- en: The Java concurrency API provides a specific class to generate pseudorandom
    numbers in concurrent applications. It's the `ThreadLocalRandom` class and it's
    new in Java 7 version. It works as the thread's local variables. Every thread
    that wants to generate random numbers has a different generator, but all of them
    are managed from the same class, in a transparent way to the programmer. With
    this mechanism, you will get a better performance than using a shared Random object
    to generate the random numbers of all the threads.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Java 并发 API 提供了一个特定的类来在并发应用程序中生成伪随机数。它是 `ThreadLocalRandom` 类，并且是 Java 7 版本中新增的。它作为线程的局部变量工作。每个想要生成随机数的线程都有一个不同的生成器，但它们都由同一个类管理，对程序员来说是透明的。通过这种机制，你将获得比使用共享的
    `Random` 对象生成所有线程的随机数更好的性能。
- en: In this recipe, you will learn how to use the `ThreadLocalRandom` class to generate
    random numbers in a concurrent application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，你将学习如何使用 `ThreadLocalRandom` 类在并发应用程序中生成随机数。
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `TaskLocalRandom` and specify that it implements the `Runnable`
    interface:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TaskLocalRandom` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Implement the `run()` method. Get the name of the thread that is executing
    this task and write 10 random integer numbers to the console using the `nextInt()`
    method:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。获取执行此任务的线程名称，并使用 `nextInt()` 方法将10个随机整数写入控制台：
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例中的主类：
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create an array for three `Thread` objects:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含三个 `Thread` 对象的数组：
- en: '[PRE88]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create and launch three `TaskLocalRandom` tasks. Store the threads in the array
    created earlier:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动三个 `TaskLocalRandom` 任务。将线程存储在之前创建的数组中：
- en: '[PRE89]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of this example is in the `TaskLocalRandom` class. In the constructor
    of the class, we make a call to the `current()` method of the `ThreadLocalRandom`
    class. This is a static method that returns the `ThreadLocalRandom` object associated
    with the current thread, so you can generate random numbers using that object.
    If the thread that makes the call does not have any object associated yet, the
    class creates a new one. In this case, you use this method to initialize the random
    generator associated with this task, so it will be created in the next call to
    the method.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的关键在于 `TaskLocalRandom` 类。在类的构造函数中，我们调用 `ThreadLocalRandom` 类的 `current()`
    方法。这是一个静态方法，它返回与当前线程关联的 `ThreadLocalRandom` 对象，因此你可以使用该对象生成随机数。如果调用该方法的线程尚未关联任何对象，则该类将创建一个新的对象。在这种情况下，你使用此方法来初始化与该任务关联的随机数生成器，因此它将在下一次调用该方法时创建。
- en: In the `run()` method of the `TaskLocalRandom` class, make a call to the `current()`
    method to get the random generator associated with this thread, also you make
    a call to the `nextInt()` method passing the number 10 as the parameter. This
    method will return a pseudo random number between 0 and 10\. Each task generates
    10 random numbers.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TaskLocalRandom` 类的 `run()` 方法中，调用 `current()` 方法以获取与该线程关联的随机生成器，同时调用 `nextInt()`
    方法并传递数字 10 作为参数。此方法将返回介于 0 和 10 之间的伪随机数。每个任务生成 10 个随机数。
- en: There's more...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ThreadLocalRandom` class also provides methods to generate long, float,
    and double numbers, and Boolean values. There are methods that allow you to provide
    a number as a parameter to generate random numbers between zero and that number.
    The other methods allow you to provide two parameters to generate random numbers
    between these numbers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocalRandom` 类还提供了生成长整型、浮点型和双精度型数字以及布尔值的函数。有一些函数允许你提供一个数字作为参数来生成介于零和该数字之间的随机数。其他函数允许你提供两个参数来生成介于这两个数字之间的随机数。'
- en: See also
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using local thread variables* recipe in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread management*
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第1章](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736) 的 *使用局部线程变量* 菜谱中，*线程管理*
