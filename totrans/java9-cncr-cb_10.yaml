- en: Additional Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing results for Runnable objects in the Executor framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing uncontrolled exceptions in a ForkJoinPool class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a blocking thread-safe queue to communicate with producers and consumers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Thread class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Semaphore class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating concurrent random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter include recipes about the `Executor` framework and the fork/join
    framework, concurrent data structures, monitoring concurrent objects, and generating
    concurrent random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Processing results for Runnable objects in the Executor framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Executor` framework allows the execution of concurrent tasks that returns
    a result using the `Callable` and `Future` interfaces. The traditional concurrent
    programming in Java is based on `Runnable` objects, but this kind of object doesn't
    return a result.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to adapt a `Runnable` object to simulate
    a `Callable` one, allowing a concurrent task to return a result.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse, or another IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `FileSearch` and specify that it implements the `Runnable`
    interface. This class implements the file search operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `String` attributes: one named `initPath`, which will store
    the initial folder for the search operation, and the other named end, which will
    store the extension of the files this task is going to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `List<String>` attribute named `results` that will store
    the full paths of the files that this task has found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that will initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the method `getResults()`. This method returns the list with the
    full paths of the files that this task has found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. First of all, write a log message to the console
    indicating that the task is starting its job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if the `initPath` attribute stores the name of an existing folder, call
    the auxiliary method, `directoryProcess()`, to process its files and folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary `diretoryProcess()` method, which receives a `File`
    object as a parameter. First of all, get the contents of the folder pointed to
    by the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the elements of the folder, if they are folders, make a recursive
    call to the `directoryProcess()` method. If they are files, call the `fileProcess()`
    auxiliary method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `fileProcess()` that receives a `File` object
    with the full path of a file. This method checks if the file extension is equal
    to the one stored in the end attribute. If they are equal, add the full path of
    the file to the list of results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a class named `Task` that extends the `FutureTask` class. You''ll
    use `List<String>` as the parameterized type, as this will be the type of the
    data this task will return:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `FileSearch` attribute named `fileSearch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of this class. This constructor has two parameters: a `Runnable`
    object named `runnable` and a `List<String>` object named result. In the constructor,
    you have to call the constructor of the parent class, passing to it the same parameters.
    Then, store the `runnable` parameter, casting it to a `FileSearch` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `set()` method of the `FutureTask` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parameter that it receives is null, store in it the result of calling
    the `getResults()` method of the `FileSearch` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call the parent''s method passing the received parameter as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the main class of the example. Create a class named `Main`
    and implement the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ThreadPoolExecutor` object named executor calling the `newCachedThreadPool()`
    method of the `Executors` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three `FileSearch` objects with a different initial folder for each
    one. You are going to look for files with the `log` extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three `Task` objects to execute the search operations in the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Send these objects to the executor object using the `submit()` method. This
    version of the `submit()` method returns a `Future<?>` object, but you''re going
    to ignore it. You have a class that extends the `FutureTask` class to control
    the execution of this task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `shutdown()` method of the executor object to indicate that it should
    finish its execution when these three tasks have finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `awaitTermination()` method of the executor object, indicating a long
    waiting period to guarantee that this method won''t return until the three tasks
    have finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For each task, write a message with the size of the result list using the `get()`
    method of the `Task` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first point to take into consideration to understand this example is the
    difference between the `submit()` method of the `ThreadPoolExecutor` class when
    you pass a `Callable` object as the parameter and the `submit()` method when you
    pass a `Runnable` object as the parameter. In the first case, you can use the
    `Future` object that this method returns to control the status of the task and
    to get its result. But in the second case, when you pass a `Runnable` object,
    you can only use the `Future` object that this method returns to control the status
    of the task. If you call the `get()` method of that `Future` object, you will
    get a null value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To override this behavior, you have implemented the `Task` class. This class
    extends the `FutureTask` class that is a class that implements the `Future` interface
    and the `Runnable` interface. When you call a method that returns a `Future` object
    (for example, the `submit()` method), you will normally get a `FutureTask` object.
    So you can use this class with two objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: First, execute the `Runnable` object (in this case, a `FileSearch` object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, return the results that this task generates. To achieve this, you have
    overridden the `set()` method of the `Task` class. Internally, the `FutureTask`
    class controls when the task it has to execute has finished. At that moment, it
    makes a call to the `set()` method to establish the return value of the task.
    When you are executing a `Callable` object, this call is made with the value returned
    by the `call()` method, but when you are executing a `Runnable` object, this call
    is made with the null value. You have changed this null value with the list of
    results generated by the `FileSearch` object. The `set()` method will only have
    effect the first time it is called. When it's called for the first time, it marks
    the task as finished and the rest of the calls will not modify the return value
    of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Main` class, instead of sending the `FutureTasks` objects to the `Callable`
    or `Runnable` objects, you can send it to the executor object. The main difference
    is that you use the `FutureTasks` objects to get the results of the task instead
    of the `Future` object returned by the `submit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can still use the `Future` object returned by the `submit()`
    method to control the status of the task but remember that, as this task executes
    a `Runnable` object (you have initialized the `FutureTasks` objects with the `FileSearch`
    objects that implement the `Runnable` interface), if you call the `get()` method
    in the `Future` objects, you will get the null value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FutureTask` class provides a method not included in the `Future` interface.
    It's the `setException()` method. This method receives a `Throwable` object as
    the parameter and when the `get()` method is called, an `ExecutionException` exception
    will be thrown. This call has an effect only if the `set()` method of the `FutureTask`
    object hasn't been called yet.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating, running, and setting the characteristics of a thread* recipe
    in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736), *Thread
    Management*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing uncontrolled exceptions in a ForkJoinPool class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fork/join framework gives you the possibility to set a handler for the exceptions
    thrown by the worker threads of a `ForkJoinPool` class. When you work with a `ForkJoinPool`
    class, you should understand the difference between tasks and worker threads.
  prefs: []
  type: TYPE_NORMAL
- en: To work with the fork/join framework, you implement a task extending the `ForkJoinTask`
    class or, usually, the `RecursiveAction` or `RecursiveTask` classes. The task
    implements the actions you want to execute concurrently with the framework. They
    are executed in the `ForkJoinPool` class by the worker threads. A worker thread
    will execute various tasks. In the work-stealing algorithm implemented by the
    `ForkJoinPool` class, a worker thread looks for a new task when the task it was
    executing finishes its execution or it is waiting for the completion of another
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to process the exceptions thrown by a worker
    thread. You''ll have to implement two additional elements for it to work as described
    in the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: The first element is an extended class of the `ForkJoinWorkerThread` class.
    This class implements the worker thread of a `ForkJoinPool` class. You will implement
    a basic child class that will throw an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second element is a factory to create worker threads of your own custom
    type. The `ForkJoinPool` class uses a factory to create its worker threads. You
    have to implement a class that implements the `ForkJoinWorkerThreadFactory` interface
    and uses an object of that class in the constructor of the `ForkJoinPool` class.
    The `ForkJoinPool` object created will use that factory to create worker threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, implement your own worker thread class. Create a class named `AlwaysThrowsExceptionWorkerThread`
    that extends the `ForkJoinWorkerThread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. It receives a `ForkJoinPool` class
    as a parameter and calls the constructor of its parent class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `onStart()` method. This is a method of the `ForkJoinWorkerThread`
    class and is executed when the worker thread begins its execution. The implementation
    will throw a `RuntimeException` exception upon being called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the factory needed to create your worker threads. Create a class
    named `AlwaysThrowsExceptionWorkerThreadFactory` that implements the `ForkJoinWorkerThreadFactory`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `newThread()` method. It receives a `ForkJoinPool` object as
    the parameter and returns a `ForkJoinWorkerThread` object. Create an `AlwaysThrowsExceptionWorkerThread`
    object and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a class that will manage the exceptions thrown by worker threads.
    Implement a class named `Handler` that implements the `UncaughtExceptionHandler`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `uncaughtException()` method. It receives as parameters a Thread
    object and a `Throwable` object and is called by the `ForkJoinPool` class each
    time a worker thread throws an exception. Write a message to the console and exit
    the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement a task to be executed in the `ForkJoinPool` executor. Create
    a class named `OneSecondLongTask` that extends the `RecursiveAction` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method. It simply puts the thread to sleep after
    one second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the main class of the example. Create a class named Main with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `OneSecondLongTask` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Handler object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `AlwaysThrowsExceptionWorkerThreadFactory` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `ForkJoinPool` object. Pass as parameters the value `2`, the factory
    object, the handler object, and the value `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the task in the pool using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the pool with the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the tasks using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you have implemented the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Your own worker thread class**: You have implemented the `AlwaysThrowsExceptionWorkerThread`
    class, which extends the `ForkJoinWorkerThread` class, which implements the worker
    threads of a fork/join pool. You have overridden the `onStart()` method. This
    method is executed when a worker thread starts its execution. It simply throws
    an exception `RuntimeException` upon being called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Your own thread factory**: A `ForkJoinPool` class creates its worker threads
    using a factory. As you want to create a `ForkJoinPool` object that uses the `AlwaysThrowsExceptionWorkerThreadFactory`
    worker threads, you have implemented a factory that creates them. To implement
    a worker thread factory, you need to implement the `ForkJoinWorkerThreadFactory`
    interface. This interface only has a method named `newThread()`, which creates
    the worker thread and returns it to the `ForkJoinPool` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A task class**: The worker threads execute the tasks you send to the `ForkJoinPool`
    executor. As you want to start the execution of a worker thread, you need to send
    a task to the `ForkJoinPool` executor. The task sleeps for one second, but, as
    the `AlwaysThrowsExceptionWorkerThread` thread throws an exception, it will never
    be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A handler class for uncaught exceptions**: When a worker thread throws an
    exception, the `ForkJoinPool` class checks whether an exception handler has been
    registered. You have implemented the `Handler` class for this purpose. This handler
    implements the `UncaughtExceptionHandler` interface, which only has one method,
    that is, the `uncaughtException()` method. This method receives as a parameter
    the thread that throws the exception and the exception it throws.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Main class, you have put together all these elements. You have passed
    to the constructor of the `ForkJoinPool` class four parameters: the parallelism
    level, the number of active worker threads you want to have, the worker thread
    factory you want to use in the `ForkJoinPool` object, the handler you want to
    use for the uncaught exceptions of the worker threads, and the async mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you execute the program, a worker thread throws a `RuntimeException` exception.
    The `ForkJoinPool` class hands it over to your handler, which in turn writes the
    message to the console and exits the program. The task doesn't start its execution.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can test two interesting variants of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you comment the following line in the Handler class and execute the program,
    you will see a lot of messages written in the console. The `ForkJoinPool` class
    tries to start a worker thread to execute the task and, as it can''t because they
    always throw an exception, it tries it over and over again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Something like that occurs if you change the third parameter (the exception
    handler) of the `ForkJoinPool` class constructor for the null value. In this case,
    you will see how the JVM writes the exceptions in the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take this into account when you implement your own worker threads that could
    throw exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing tasks running in the fork/join framework* and *Implementing
    the ThreadFactory interface to generate custom threads for the fork/join framework*
    recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a blocking thread-safe queue for communicating with producers and consumers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The producer/consumer problem is a classical problem in concurrent programming.
    You have one or more producers of data that store this data in a buffer. You also
    have one or more consumers of data that take the data from the same buffer. Both
    producers and consumers share the same buffer, so you have to control access to
    it to avoid data inconsistency problems. When the buffer is empty, the consumers
    wait until the buffer has elements. If the buffer is full, the producers wait
    until the buffer has empty space.
  prefs: []
  type: TYPE_NORMAL
- en: This problem has been implemented using almost all the techniques and synchronization
    mechanisms developed in Java and in other languages (refer to the *See Also* section
    to get more information). One advantage of this problem is that it can be extrapolated
    to a lot of real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java 7 Concurrency API introduced a data structure oriented to be used
    in these kinds of problem. It''s the `LinkedTransferQueue` class, and its main
    characteristics are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a blocking data structure. The thread is blocked until the operation can
    be made, provided that the operations are performed immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its size has no limit. You can insert as many elements as you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a parameterized class. You have to indicate the class of the elements you're
    going to store in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `LinkedTransferQueue` class running
    a lot of producer and consumer tasks that share a buffer of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Producer` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `LinkedTransferQueue` attribute parameterized with the `String`
    class named buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named name to store the name of the producer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Store `10,000` strings in the buffer using the
    `put()` method of the buffer object and write a message to the console indicating
    the end of the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a class named `Consumer` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `LinkedTransferQueue` attribute parameterized with the `String`
    class named buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named name to store the name of the consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Take out 10,000 strings from the buffer using
    the `take()` method of the buffer object and write a message to the console indicating
    the end of the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example. Create a class named `Main` and add
    to it the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a constant named `THREADS` and assign to it the value `100`. Create
    a `LinkedTransferQueue` object with the `String` class object and call it buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of 100 Thread objects to execute 100 producer tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of 100 Thread objects to execute 100 consumer tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch 100 `Consumer` objects and store the threads in the array
    created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch 100 `Producer` objects and store the threads in the array
    created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to the console with the size of the buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you have used the `LinkedTransferQueue` class parameterized
    with the String class to implement the producer/consumer problem. This `LinkedTransferQueue`
    class is used as a buffer to share the data between producers and consumers.
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented a `Producer` class that adds strings to the buffer using
    the `put()` method. You have executed 100 producers and every producer inserts
    in the buffer 10,000 strings, so you insert 1,000,000 strings in the buffer. The
    `put()` method adds the element at the end of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: You also have implemented a `Consumer` class, which gets a string from the buffer
    using the `take()` method. This method returns and deletes the first element of
    the buffer. If the buffer is empty, the method blocks the thread that makes the
    call until there are strings in the buffer to consume. You have executed 100 consumers,
    and every consumer gets 10,000 strings from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, first, you have launched the consumers and then the producers,
    so, as the buffer is empty, all the consumers will be blocked until the producers
    begin their execution and stores strings in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To write the number of elements of the buffer, you have used the `size()` method.
    You have to take into account that this method can return a value that is not
    real, if you use them when there are threads adding or deleting data in the list.
    The method has to traverse the entire list to count the elements and the contents
    of the list can change for this operation. Only if you use them when there aren't
    any threads modifying the list, you will have the guarantee that the returned
    result is correct.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LinkedTransferQueue` class provides other useful methods. The following
    are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getWaitingConsumerCount()`: This method returns the number of consumers that
    are blocked in the `take()` method or `poll (long timeout, TimeUnit unit)` because
    the `LinkedTransferQueue` object is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasWaitingConsumer()`: This method returns `true` if the `LinkedTransferQueue`
    object has consumers waiting, or false otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offer(E e)`: This method adds the element passed as a parameter at the end
    of the `LinkedTransferQueue` object and returns the true value. `E` represents
    the class used to parameterize the declaration of the `LinkedTransferQueue` class
    or a subclass of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This method returns the first element in the `LinkedTransferQueue`
    object, but it doesn''t delete it from the list. If the queue is empty, the method
    returns the null value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll(long timeout, TimeUnit unit)`: This version of the poll method, if the
    `LinkedTransferQueue` buffer is empty, waits for it for a specified period of
    time. If the specified period of time passes and the buffer is still empty, the
    method returns a `null` value. The `TimeUnit` class is an enumeration with the
    following constants-`DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`,
    `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using conditions in synchronized code* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exchanging data between concurrent tasks* recipe in [Chapter 3](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Synchronization Utilities*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Thread class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threads are the most basic element of the Java Concurrency API. Every Java program
    has at least one thread that executes the `main()` method, which, in turn, starts
    the execution of the application. When you launch a new `Thread` class, it's executed
    in parallel with the other threads of the application and with the other processes
    on an operating system. There is a critical difference between process and thread.
    A process is an instance of an application that is running (for example, you're
    editing a document in a text processor). This process has one or more threads
    that execute the tasks that make the process. You can be running more than one
    process of the same application, for example, two instances of the text processor.
    Threads inside a process share the memory while processes of the same OS don't.
  prefs: []
  type: TYPE_NORMAL
- en: All the kinds of Java tasks that you can execute (`Runnable`, `Callable`, or
    fork/join tasks) are executed in threads, and all the advanced Java concurrency
    mechanisms, such as the `Executor` framework and the fork/join framework, are
    based on pools of threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information you can obtain about the status
    of a `Thread` class and how to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a loop with 100 steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In each step, put the thread to sleep for 100 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message in the console with the name of the thread and the step number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the main class of the example. Create a class named `Main` with a `main()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task` object named task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Thread` array with five elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and start five threads to execute the `Task` object created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a loop with ten steps to write information about the threads launched
    before. Inside it, create another loop with five steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For each thread, write its name, its status, its group, and the length of its
    stack trace in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a loop to write the stack trace of the thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for one second and close the loop and the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you have used the following methods to get information about
    a `Thread` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getId()`: This method returns the ID of a thread. It''s a unique long number
    and it can''t be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getName()`: This method returns the name of a thread. If you don''t establish
    the name of the thread, Java gives it a default name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPriority()`: This method returns the priority of execution of a thread.
    Threads with higher priority are executed in preference to threads with lower
    priority. It''s an `int` value that has a value between the `MIN_PRIORITY` and
    `MAX_PRIORITY` constants of the `Thread` class. By default, threads are created
    with the same priority that specified by the constant `NORM_PRIORITY` of the `Thread`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getState()`: This method returns the status of a thread. It''s a `Thread.State`
    object. The `Thread.State` enumeration has all the possible states of a thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getThreadGroup()`: This method returns the `ThreadGroup` object of a thread.
    By default, threads belong to the same thread group, but you can establish a different
    one in the constructor of a thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStackTrace()`: This method returns an array of `StackTraceElement` objects.
    Each of these objects represent a call to a method that begins with the `run()`
    method of a thread and includes all the methods that have been called until the
    actual execution point. When a new method is called, a new stack trace element
    is added to the array. When a method finishes its execution, its stack trace element
    is removed from the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Thread` class includes other methods that provide information about it
    that can be useful. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activeCount()`: This method returns the number of active threads in a group
    of threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dumpStack()`: This method prints the stack trace of a thread to the standard
    error output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating, running, and setting the characteristics of a thread* recipe
    in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736), *Thread
    Management*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a ThreadFactory interface in an Executor framework* and *Implementing
    a ThreadFactory interface to generate custom threads for the fork/join framework*
    recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Semaphore class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A semaphore is a counter that protects the access to one or more shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of semaphore was introduced by Edsgar Dijkstra in 1965 and was used
    for the first time in the THEOS operating system.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread wants to use shared resources, it must acquire a semaphore. If
    the internal counter of the semaphore is greater than 0, the semaphore decrements
    the counter and allows the access to the shared resource. If the counter of the
    semaphore is 0, the semaphore blocks the thread until the counter is greater than
    0\. When the thread has finished using the shared resource, it must release the
    semaphore. That operation increases the internal counter of the semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, semaphores are implemented in the `Semaphore` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information you can obtain about the status
    of a semaphore and how to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Semaphore` attribute named `semaphore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. First, acquire permit for the `semaphore` attribute
    writing a message in the console to indicate that circumstance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, put the thread to sleep for two seconds using the `sleep()` method. Finally,
    release the permit and write a message in the console to indicate that circumstance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example. Create a class named `Main` with a
    `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Semaphore` object named `semaphore` with three permits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array to store 10 `Thread` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and start 10 `Thread` objects to execute 10 `Task` objects. After starting
    a thread, put the thread to sleep for 200 milliseconds and call the `showLog()`
    method to write information about the `Semaphore` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a loop with five steps to call the `showLog()` method to write information
    about the `semaphore` and put the thread to sleep for `1` second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `showLog()` method. It receives a `Semaphore` object as parameter.
    Write in the console information about the available permits, queued threads,
    and permits of the `semaphore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you have used the following methods to get information about
    a `semaphore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`availablePermits()`: This method returns an `int` value, which is the number
    of available resources of a semaphore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasQueuedThreads()`: This method returns a Boolean value indicating if there
    are threads waiting for a resource protected by a semaphore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueueLength()`: This method returns the number of threads that are waiting
    for a resource protected by a semaphore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFair()`: This method returns a Boolean value indicating if a semaphore has
    the fair mode activated. When the fair mode is active (this method returns the
    true value), and the lock has to select another thread to give to it the access
    to the shared resource, it selects the longest-waiting thread. If the fair mode
    is inactive (this method returns the false value), there is no guarantee about
    the order in which threads are selected to get the access to the shared resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Controlling concurrent access to one or more copies of a resource* recipes
    in [Chapter 3](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736), *Thread
    Synchronization Utilities*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating concurrent random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a specific class to generate pseudorandom
    numbers in concurrent applications. It's the `ThreadLocalRandom` class and it's
    new in Java 7 version. It works as the thread's local variables. Every thread
    that wants to generate random numbers has a different generator, but all of them
    are managed from the same class, in a transparent way to the programmer. With
    this mechanism, you will get a better performance than using a shared Random object
    to generate the random numbers of all the threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `ThreadLocalRandom` class to generate
    random numbers in a concurrent application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `TaskLocalRandom` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Get the name of the thread that is executing
    this task and write 10 random integer numbers to the console using the `nextInt()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array for three `Thread` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch three `TaskLocalRandom` tasks. Store the threads in the array
    created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key of this example is in the `TaskLocalRandom` class. In the constructor
    of the class, we make a call to the `current()` method of the `ThreadLocalRandom`
    class. This is a static method that returns the `ThreadLocalRandom` object associated
    with the current thread, so you can generate random numbers using that object.
    If the thread that makes the call does not have any object associated yet, the
    class creates a new one. In this case, you use this method to initialize the random
    generator associated with this task, so it will be created in the next call to
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `run()` method of the `TaskLocalRandom` class, make a call to the `current()`
    method to get the random generator associated with this thread, also you make
    a call to the `nextInt()` method passing the number 10 as the parameter. This
    method will return a pseudo random number between 0 and 10\. Each task generates
    10 random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ThreadLocalRandom` class also provides methods to generate long, float,
    and double numbers, and Boolean values. There are methods that allow you to provide
    a number as a parameter to generate random numbers between zero and that number.
    The other methods allow you to provide two parameters to generate random numbers
    between these numbers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using local thread variables* recipe in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread management*
  prefs: []
  type: TYPE_NORMAL
