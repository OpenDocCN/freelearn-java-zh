- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Maintainability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: This book is about software architecture. One of the definitions of *architecture*
    is *the structure of a system or process*. In our case, it’s the structure of
    a software system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于软件架构的。*架构*的一个定义是*系统或过程的结构*。在我们的情况下，它是软件系统的结构。
- en: Architecture is designing this structure with a purpose. We’re consciously designing
    our software system to fulfill certain requirements. There are functional requirements
    that the software has to fulfill to create value for its users. Without functionality,
    software is worthless, because it produces no value.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是设计这个结构以达到某种目的。我们是有意识地设计我们的软件系统以满足某些要求。软件必须满足的功能性要求是为了为用户创造价值。没有功能性，软件就毫无价值，因为它不会产生价值。
- en: There are also **quality requirements** (also called **non-functional requirements**)
    that the software should fulfill to be considered high quality by its users, developers,
    and stakeholders. One such quality requirement is **maintainability**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，软件还应该满足一些质量要求（也称为非功能性要求），以使其用户、开发人员和利益相关者认为它是高质量的。其中一个质量要求就是**可维护性**。
- en: What would you say if I told you that maintainability as a quality attribute,
    in a way, is more important than functionality and that we should design our software
    for maintainability over everything else? Once we have established maintainability
    as an important quality, we will use the rest of this book to explore how we can
    improve the maintainability of our software by applying the concepts of Clean
    and Hexagonal Architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，可维护性作为一个质量属性，从某种意义上说，比功能更重要，而且我们应该优先设计软件的可维护性，而不是其他一切，你会说什么？一旦我们确立了可维护性作为一个重要的质量，我们将使用本书的其余部分来探讨我们如何通过应用清洁和六边形架构的概念来提高我们软件的可维护性。
- en: What does maintainability even mean?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性到底是什么意思？
- en: Before you write me off as a lunatic and start looking for options to return
    this book, let me explain what I mean by maintainability.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在你把我当作疯子并开始寻找退书选项之前，让我解释一下我所说的可维护性是什么意思。
- en: 'Maintainability is only one of the many quality requirements that potentially
    make up a software architecture. I asked ChatGPT for a list of quality requirements,
    and this is the result:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性只是构成软件架构的许多潜在质量要求之一。我向ChatGPT询问了一份质量要求清单，这是结果：
- en: Scalability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Flexibility
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性
- en: Maintainability
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Security
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Reliability
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性
- en: Modularity
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化
- en: Performance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Interoperability
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互操作性
- en: Testability
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Cost-effectiveness
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本效益
- en: The list doesn’t end here.[1](#footnote-007)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还没有结束。[1](#footnote-007)
- en: '[1](#footnote-007-backlink) For some inspiration about software quality (which
    has been created by humans, and not a language model), have a look at [https://quality.arc42.org/](https://quality.arc42.org/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-007-backlink) 关于软件质量的一些灵感（这是由人类创造的，而不是语言模型），请查看 [https://quality.arc42.org/](https://quality.arc42.org/)。'
- en: As software architects, we design our software to fulfill the quality requirements
    that are most important for the software. For a high-throughput trading application,
    we might focus on scalability and reliability. For an application dealing with
    personally identifiable information in Germany, we might want to focus on security.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，我们设计我们的软件以满足对软件最重要的质量要求。对于一个高吞吐量交易应用，我们可能会关注可扩展性和可靠性。对于一个处理德国个人可识别信息的应用，我们可能希望关注安全性。
- en: I think it’s wrong to lump maintainability in with the rest of the quality requirements
    because maintainability is special. If software is maintainable, that means it’s
    easy to change. If it’s easy to change, it’s flexible and probably modular. It’s
    probably cost-effective, too, because easy changes mean cheap changes. If it’s
    maintainable, we can probably evolve it to be scalable, secure, reliable, and
    performant, should the need arise. We can change the software to be interoperable
    with other systems because it’s easy to change. Last but not least, maintainability
    implies testability because maintainable software is most likely designed from
    smaller and simpler components that make testing easy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为将可维护性与其他质量要求混为一谈是不正确的，因为可维护性是特殊的。如果软件是可维护的，这意味着它很容易改变。如果它容易改变，它就灵活，可能模块化。它也可能具有成本效益，因为容易的改变意味着低成本的改变。如果它是可维护的，我们可能可以将其演变为可扩展的、安全的、可靠的和性能良好的，如果需要的话。我们可以改变软件以与其他系统互操作，因为它容易改变。最后但同样重要的是，可维护性意味着可测试性，因为可维护的软件最有可能是由较小的、更简单的组件设计的，这使得测试变得容易。
- en: 'You can see what I did here. I asked AI for a list of quality requirements
    and then tied them all back to maintainability. I could probably tie many more
    quality requirements back to maintainability with similarly plausible arguments.
    It’s a bit simplistic, of course, but the core of it is true: if software is maintainable,
    it’s easier to evolve in any direction, functionally and non-functionally. And
    we all know that change is common during the life of a software system.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到我所做的工作。我向人工智能请求了一份质量要求列表，并将它们全部与可维护性联系起来。我可能可以用类似合理的论据将更多的质量要求与可维护性联系起来。当然，这有点过于简单化，但核心是真实的：如果软件是可维护的，它就更容易在任何方向上进化，无论是功能性的还是非功能性的。我们都知道，在软件系统的生命周期中，变化是常见的。
- en: Maintainability enables functionality
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性使功能得以实现
- en: Now back to my claim that maintainability is more important than functionality
    from the beginning of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我在这章开头提出的观点：可维护性比功能性更重要。
- en: If you ask a product person what’s most important in a software project, they’ll
    tell you that the value the software provides to its users is the most important
    thing. Software that doesn’t provide value to its users means that users don’t
    pay for it. And without paying users, we don’t have a working business model,
    which is the main measure of success in the business world.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问一个产品人员一个软件项目中最重要的东西是什么，他们会告诉你，软件为用户提供的价值是最重要的。对用户没有价值的软件意味着用户不会为其付费。而没有付费的用户，我们就无法拥有一个可行的商业模式，这是商业世界中成功的主要衡量标准。
- en: So, our software needs to provide value. But it shouldn’t provide value at the
    cost of maintainability.[2](#footnote-006) Think about how much more efficient
    and joyful it is to add functionality to a software system that is easily changeable
    as compared to a software system where you have to fight your way through one
    line of code at a time! I’m pretty sure that you’ve worked on one of those software
    projects where there’s so much cruft and ritual that it takes days or weeks to
    build a feature that you think should take no more than a couple of hours to complete.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的软件需要提供价值。但是，它不应该以牺牲可维护性为代价。[2](#footnote-006) 想想，与那些你必须逐行代码地艰难推进的软件系统相比，向一个易于更改的软件系统添加功能要高效和愉快得多！我非常确信，你曾经参与过那些充斥着冗余和仪式的软件项目，要完成一个你认为只需几个小时就能完成的功能，却需要花费几天或几周的时间。
- en: '[2](#footnote-006-backlink) In the context of this book, I use the term "maintainability"
    synonymously with "changeability of a code base". Also see [https://quality.arc42.org/qualities/maintainability](https://quality.arc42.org/qualities/maintainability)
    for some definitions of maintainability (all of which have to do with changing
    the software).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-006-backlink) 在本书的语境中，我将“可维护性”一词与“代码库的可更改性”同义使用。有关可维护性的定义，请参阅[https://quality.arc42.org/qualities/maintainability](https://quality.arc42.org/qualities/maintainability)（所有这些都与更改软件有关）。'
- en: 'In this way, maintainability is a key supporter of functionality. Bad maintainability
    means that changes in functionality become more and more expensive over time,
    as shown in *Figure 1**.1*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，可维护性是功能性的关键支持者。糟糕的可维护性意味着功能的变化随着时间的推移变得越来越昂贵，如图 *图 1.1* 所示：
- en: '![Figure 1.1 – A maintainable software system has a smaller lifetime cost than
    a not-so-maintainable software system](img/Figure_01.1_B19916.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 一个可维护的软件系统比一个不太可维护的软件系统具有更小的生命周期成本](img/Figure_01.1_B19916.jpg)'
- en: Figure 1.1 – A maintainable software system has a smaller lifetime cost than
    a not-so-maintainable software system
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 一个可维护的软件系统比一个不太可维护的软件系统具有更小的生命周期成本
- en: In a not-so-maintainable software system, changes in functionality will soon
    become so expensive that change is a pain. Product people will complain to the
    engineers about the cost of changes. The engineers will defend themselves by saying
    that shipping new features has always had a higher priority than increasing maintainability.
    The probability of conflict increases with the cost of change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个不太可维护的软件系统中，功能的变化很快就会变得非常昂贵，以至于变化变得痛苦。产品人员会对工程师抱怨变化的成本。工程师会通过说推出新功能始终比提高可维护性具有更高的优先级来为自己辩护。随着变化成本的提高，冲突的可能性也会增加。
- en: Maintainability is a pacifier. It’s inversely proportional to the cost of change
    and thus to the probability of conflict. Did you ever think about adding maintainability
    to a software system to avoid conflict? I think that’s a good investment in itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性是一种安抚剂。它与变更成本成反比，因此与冲突的可能性成反比。你有没有想过在软件系统中添加可维护性以避免冲突？我认为那本身就是一项很好的投资。
- en: But what about those big software systems that are successful in spite of bad
    maintainability? It’s true that there are commercially successful software systems
    out there that are barely maintainable. I’ve worked on systems where adding a
    single field to a form is a project that takes weeks of developer time, and the
    client happily paid a premium for my time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但那些尽管可维护性差却取得成功的庞大软件系统怎么办？确实，有些商业上成功的软件系统几乎不可维护。我工作过的系统中，向表单中添加一个字段的项目需要花费开发者几周的时间，而客户很高兴为我的时间支付溢价。
- en: 'Those systems usually fall into one (or both) of two categories:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统通常属于以下一个（或两个）类别之一：
- en: They are at the end of their life where changes to the system are few and far
    between
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们处于生命周期的末期，系统变更很少
- en: They are backed by a financially well-off company that is willing to throw money
    at the problem
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们背后有一个财务状况良好的公司，愿意花钱解决问题
- en: Even in the case where a company has a lot of money to spend, the company realizes
    that they can reduce the maintenance tax by investing in maintainability. So,
    usually, there are already initiatives underway to make the software more maintainable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使公司有大量的资金可以花费，公司也会意识到，通过投资可维护性，他们可以减少维护成本。因此，通常，已经有计划进行中，以使软件更具可维护性。
- en: We should always care about the maintainability of the software we’re creating
    so it doesn’t degrade into the dreaded **big ball of mud**, but if our software
    doesn’t fall into one of the two categories mentioned previously, we should care
    even more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终关注我们正在创建的软件的可维护性，以免其退化成令人恐惧的**大泥球**，但如果我们的软件不属于之前提到的两种类别之一，我们应该更加关注。
- en: Does this mean that we have to spend a lot of time planning out a maintainable
    architecture before we even start programming? Do we have to do a **big design
    up front** (**BDUF**), which is often considered synonymous with the waterfall
    methodology? No, we don’t. But we need to do **some design up-front** (should
    we call it **SDUF**?) to bake a seed of maintainability into the software, which
    can make it easier to evolve the architecture to where it needs to be over time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们甚至在开始编程之前就必须花大量时间规划可维护的架构？我们是否必须进行**大设计前期**（通常被认为与瀑布方法同义）？不，我们不必。但我们确实需要进行**一些前期设计**（我们应该称之为**SDUF**？）来将可维护性的种子植入软件中，这样随着时间的推移，可以更容易地将架构演变到所需的状态。
- en: Part of that up-front design is choosing an architecture style that defines
    the guardrails of the software we’re building. This book will help you decide
    whether a *Clean* – or *Ports and Adapters/Hexagonal* – architecture is a good
    fit for your context.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那部分前期设计包括选择一种定义我们正在构建的软件的护栏的架构风格。这本书将帮助你决定*纯净*——或*端口和适配器/六边形*——架构是否适合你的环境。
- en: Maintainability generates developer joy
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性带来开发者的快乐
- en: As a developer, would you rather work on software where changes are easy or
    on software where changes are hard? Don’t answer; it’s a rhetorical question.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你更愿意在易于更改的软件上工作，还是更愿意在难以更改的软件上工作？不必回答；这是一个修辞问题。
- en: 'Aside from the direct influence on the cost of change, maintainability has
    another benefit: it makes developers happy (or, depending on the current project
    they’re working on, it at least makes them less sad).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接影响变更成本之外，可维护性还有另一个好处：它使开发者快乐（或者，根据他们目前正在从事的项目，至少使他们不那么悲伤）。
- en: The term I want to use to describe this happiness is **developer joy**. It’s
    also known as **developer experience** or **developer enablement**. Whatever we
    call it, it means that we provide the context developers need to do their work
    well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我想用来描述这种快乐的是**开发者快乐**。它也被称为**开发者体验**或**开发者赋能**。无论我们称之为什么，它都意味着我们提供了开发者完成工作所需的环境。
- en: 'Developer joy is directly related to developer productivity. In general, if
    developers are happy, they do better work. And if they do good work, they are
    happier. There’s a two-way correlation between developer joy and developer productivity:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者快乐与开发者生产力直接相关。一般来说，如果开发者快乐，他们会做得更好。而且如果他们做得好，他们会更快乐。开发者快乐与开发者生产力之间存在双向相关性：
- en: '![Figure 1.2 – Developer joy influences developer productivity and vice versa](img/Figure_01.2_B19916.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 开发者快乐影响开发者生产力，反之亦然](img/Figure_01.2_B19916.jpg)'
- en: Figure 1.2 – Developer joy influences developer productivity and vice versa
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 开发者快乐影响开发者生产力，反之亦然
- en: This correlation has been recognized in the *SPACE framework* for developer
    productivity.[3](#footnote-005) While SPACE doesn’t provide an easy answer on
    how to measure developer productivity, it provides five categories for such metrics
    so that we can consciously pick a set of metrics covering all those categories
    to best measure developer productivity in the context of our company and projects.
    One of these categories (the **S** in **SPACE**) is **satisfaction and well-being**,
    which I’ve translated to developer joy for this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相关性已经在开发者生产力*SPACE框架*中被认可。[3](#footnote-005)虽然SPACE没有提供一个关于如何衡量开发者生产力的简单答案，但它提供了五个类别来衡量此类指标，以便我们可以有意识地选择一组涵盖所有这些类别的指标，以最好地衡量我们公司和项目背景下的开发者生产力。其中这些类别之一（**SPACE**中的**S**）是**满意度和福祉**，我在本章将其翻译为开发者快乐。
- en: '[3](#footnote-005-backlink) *The SPACE of Developer Productivity* by Nicole
    Forsgren et al., March 6, 2021\. “SPACE” stands for satisfaction and well-being,
    performance, activity, communication and collaboration, and efficiency and flow.
    See [https://queue.acm.org/detail.cfm?id=3454124](https://queue.acm.org/detail.cfm?id=3454124).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-005-backlink) *《开发者生产力空间》* 由Nicole Forsgren等人著，2021年3月6日。“SPACE”代表满意度与福祉、绩效、活动、沟通与协作，以及效率和流程。参见[https://queue.acm.org/detail.cfm?id=3454124](https://queue.acm.org/detail.cfm?id=3454124)。'
- en: Developer joy not only leads to better productivity but it naturally also leads
    to better retention. A developer who enjoys their work will stay with the company.
    Or rather, a developer who does not enjoy their work is more likely to leave for
    greener pastures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者快乐不仅会导致更高的生产力，而且自然会带来更好的留存率。一个享受自己工作的开发者会留在公司。或者更确切地说，一个不喜欢自己工作的开发者更有可能离开去寻找更广阔的天地。
- en: So, where does maintainability come into the picture? Well, if our software
    system is maintainable, we need less time to implement a change, so we are more
    productive. Also, if our software system is maintainable, we find more joy in
    making changes because it’s more efficient and we can take more pride in it. Even
    if our software is not as maintainable as we would like it to be (which is a tautology,
    to be honest), but we get the opportunity to improve maintainability over time,
    we are happier and more productive. If we are happy, we’re more likely to stay.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，可维护性是如何进入画面的呢？嗯，如果我们的软件系统是可维护的，我们实施更改所需的时间会更少，因此我们更有效率。此外，如果我们的软件系统是可维护的，我们在进行更改时会感到更多的快乐，因为效率更高，我们可以从中获得更多的自豪感。即使我们的软件的可维护性不如我们希望的那样（坦白说，这是一个同义反复），但如果我们有机会随着时间的推移提高可维护性，我们会更加快乐和高效。如果我们快乐，我们更有可能留下来。
- en: 'Expressed in a diagram, it looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以图表形式表达，看起来是这样的：
- en: "![Figure 1.3 – Maintainability directly influences developer joy and productivity\uFEFF\
    \ while developer joy influences retention](img/Figure_01.3_B19916.jpg)"
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 可维护性直接影响开发者快乐和生产力，而开发者快乐影响留存](img/Figure_01.3_B19916.jpg)'
- en: Figure 1.3 – Maintainability directly influences developer joy and productivity
    while developer joy influences retention
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 可维护性直接影响开发者快乐和生产力，而开发者快乐影响留存
- en: Maintainability supports decision-making
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性支持决策
- en: When building a software system, we solve problems every day. For most problems
    we face, there is more than one solution. We have to make decisions to choose
    between those solutions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建软件系统时，我们每天都要解决问题。对于大多数我们面临的问题，都有不止一个解决方案。我们必须做出决定，在那些解决方案之间进行选择。
- en: Do we copy this bit of code for the new feature we’re building? Do we create
    our objects ourselves or do we use a dependency injection framework? Do we use
    an overloaded constructor to create this object, or do we create a builder?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否为构建的新功能复制这段代码？我们是自己创建对象还是使用依赖注入框架？我们是使用重载构造函数来创建这个对象，还是创建一个构建器？
- en: 'Many of these decisions we don’t even make consciously. We just apply a pattern
    or principle we’ve used before that our intuition says will work in the current
    situation, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多决定甚至都不是有意识地做出的。我们只是应用之前使用过的模式或原则，直觉告诉我们这些在当前情况下会有效，如下所示：
- en: We apply **don’t repeat yourself (DRY)** when we find code duplication
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们发现代码重复时，我们应用**不要重复自己（DRY）**原则
- en: We use **dependency injection** to make the code more testable
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**依赖注入**来使代码更易于测试
- en: We introduce a **builder** to make it simpler to create an object
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了一个**构建者**来简化对象的创建过程
- en: If we take a look at these and many other well-known patterns, then what is
    their effect? In many cases, the main effect is that they make the code easier
    to change in the future (i.e., they make it more maintainable). Maintainability
    is built into many of the decisions we’re making automatically every day!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看这些以及其他许多众所周知的模式，那么它们的效果是什么？在许多情况下，主要的效果是使代码在未来更容易更改（即，使它更易于维护）。可维护性已经融入了我们每天自动做出的许多决策中！
- en: 'We can take advantage of that even when facing tougher decisions that require
    more than just applying a pre-canned pattern. *Whenever we have to decide between
    multiple options, we can choose the one that makes the code easier to change in
    the future*.[4](#footnote-004) No more agonizing between different options. We
    just take the one that increases maintainability the most. Expressed as a diagram,
    it’s pretty simple:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在面对需要更多比仅仅应用预定义模式更复杂的决策时利用这一点。*每当我们必须在多个选项之间做出决定时，我们可以选择那些在未来使代码更容易更改的选项*。[4](#footnote-004)
    不再需要在不同的选项之间痛苦挣扎。我们只需选择最能提高可维护性的那个。用图表表达，这很简单：
- en: '[4](#footnote-004-backlink) In a talk from 2022 with the same name, (Pragmatic)
    Dave Thomas called the principle of making decisions based on changeability "One
    Rule to Rule Them All". I didn''t find the talk online, but I hope he will add
    it to his website at some point. See [https://pragdave.me/talks-and-interviews.html](https://pragdave.me/talks-and-interviews.html).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-004-backlink) 在 2022 年的一次同名演讲中，（实用主义）Dave Thomas 将基于可变性的决策原则称为“一条规则统治一切”。我没有在网上找到这次演讲，但希望他将来会在他的网站上添加。请参阅
    [https://pragdave.me/talks-and-interviews.html](https://pragdave.me/talks-and-interviews.html)。'
- en: '![Figure 1.4 – Maintainability influences decision-making](img/Figure_01.4_B19916.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 可维护性影响决策](img/Figure_01.4_B19916.jpg)'
- en: Figure 1.4 – Maintainability influences decision-making
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 可维护性影响决策
- en: Like most principles, this is a generalization, of course. In a given context,
    the right decision might be to take the option that does not improve maintainability
    or even reduces maintainability. But as a default rule to fall back on, choosing
    maintainability is a guide that simplifies daily decision-making.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数原则一样，这当然是一种概括。在特定的情境下，正确的决策可能是不提高甚至降低可维护性的选项。但作为一个默认的规则，选择可维护性是一个简化日常决策的指南。
- en: Maintaining maintainability
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护可维护性
- en: Alright, I assume that you believe me that maintainability positively influences
    developer joy, productivity, and decision-making. How do we know that the changes
    we make to our code base increase (or at least don’t decrease) maintainability?
    How do we manage maintainability over time?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我假设你相信我，认为可维护性对开发者的快乐、生产力和决策能力有积极影响。我们如何知道我们对代码库所做的更改增加了（至少没有减少）可维护性？我们如何随着时间的推移管理可维护性？
- en: 'The answer to that question is to create and maintain an architecture that
    makes it easy to create maintainable code. A good architecture makes it easy to
    navigate the code base. In an easily navigable code base, it’s a breeze to modify
    existing features or add new features. The dependencies between the components
    of our application are clear and not tangled. In summary, good architecture increases
    maintainability:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那个问题的答案是创建和维护一个使创建可维护代码变得容易的架构。一个好的架构使得在代码库中导航变得容易。在一个易于导航的代码库中，修改现有功能或添加新功能变得轻而易举。我们应用程序组件之间的依赖关系清晰且不混乱。总之，好的架构提高了可维护性：
- en: '![Figure 1.5 – Software architecture influences maintainability](img/Figure_01.5_B19916.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 软件架构影响可维护性](img/Figure_01.5_B19916.jpg)'
- en: Figure 1.5 – Software architecture influences maintainability
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 软件架构影响可维护性
- en: By extension, a good architecture increases developer joy, developer productivity,
    developer retention, and decision-making. We could go on and find even more things
    influenced directly or indirectly by software architecture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展，一个好的架构可以提升开发者的快乐、开发效率、留存率以及决策能力。我们可以继续探讨更多直接或间接受到软件架构影响的事物。
- en: This correlation means that we should invest a bit of thought into how we structure
    our code. How do we group our code files into components? How do we manage the
    dependencies between those components? Which dependencies are necessary, and which
    should be discouraged to keep the code base supple to change? This brings us to
    the purpose of this book. This book shows one way of structuring a code base to
    make it maintainable. The architecture style described in this book is one way
    of implementing a Clean/Hexagonal Architecture. This architecture style is not
    a silver bullet to solve all problems with building software, however. As we will
    learn in [*Chapter 15*](B19916_15.xhtml#_idTextAnchor124), *Deciding on an Architecture
    Style*, it’s not suitable for all kinds of software applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相关性意味着我们应该在如何构建我们的代码结构上投入一些思考。我们如何将代码文件分组为组件？我们如何管理这些组件之间的依赖关系？哪些依赖是必要的，哪些应该被劝阻以保持代码库的灵活性，便于更改？这引出了本书的目的。本书展示了一种构建代码库的方法，使其易于维护。本书中描述的架构风格是实现Clean/六边形架构的一种方式。然而，这种架构风格并不是解决所有软件构建问题的万能钥匙。正如我们将在[*第15章*](B19916_15.xhtml#_idTextAnchor124)，“选择架构风格”中学习到的，它并不适合所有类型的软件应用。
- en: I encourage you to take what you learn in this book, play around with the ideas,
    modify them to make them yours, and then add them to your toolbox to apply when
    they feel right in a given context. Each of the following chapters ends with a
    section titled *How does this help me build maintainable software?* This section
    will summarize the main ideas of each chapter and hopefully help you to make decisions
    regarding the architecture of your current or future software projects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你将本书中学到的知识运用到实践中，尝试不同的想法，修改它们以使其成为你自己的，然后将它们添加到你的工具箱中，以便在特定情境下觉得合适时应用。以下每一章的结尾都有一个名为*这如何帮助我构建可维护的软件？*的部分。这一部分将总结每一章的主要思想，并希望帮助你做出关于当前或未来软件项目架构的决定。
