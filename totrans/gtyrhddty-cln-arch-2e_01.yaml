- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is about software architecture. One of the definitions of *architecture*
    is *the structure of a system or process*. In our case, it’s the structure of
    a software system.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture is designing this structure with a purpose. We’re consciously designing
    our software system to fulfill certain requirements. There are functional requirements
    that the software has to fulfill to create value for its users. Without functionality,
    software is worthless, because it produces no value.
  prefs: []
  type: TYPE_NORMAL
- en: There are also **quality requirements** (also called **non-functional requirements**)
    that the software should fulfill to be considered high quality by its users, developers,
    and stakeholders. One such quality requirement is **maintainability**.
  prefs: []
  type: TYPE_NORMAL
- en: What would you say if I told you that maintainability as a quality attribute,
    in a way, is more important than functionality and that we should design our software
    for maintainability over everything else? Once we have established maintainability
    as an important quality, we will use the rest of this book to explore how we can
    improve the maintainability of our software by applying the concepts of Clean
    and Hexagonal Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: What does maintainability even mean?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you write me off as a lunatic and start looking for options to return
    this book, let me explain what I mean by maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintainability is only one of the many quality requirements that potentially
    make up a software architecture. I asked ChatGPT for a list of quality requirements,
    and this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost-effectiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list doesn’t end here.[1](#footnote-007)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-007-backlink) For some inspiration about software quality (which
    has been created by humans, and not a language model), have a look at [https://quality.arc42.org/](https://quality.arc42.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: As software architects, we design our software to fulfill the quality requirements
    that are most important for the software. For a high-throughput trading application,
    we might focus on scalability and reliability. For an application dealing with
    personally identifiable information in Germany, we might want to focus on security.
  prefs: []
  type: TYPE_NORMAL
- en: I think it’s wrong to lump maintainability in with the rest of the quality requirements
    because maintainability is special. If software is maintainable, that means it’s
    easy to change. If it’s easy to change, it’s flexible and probably modular. It’s
    probably cost-effective, too, because easy changes mean cheap changes. If it’s
    maintainable, we can probably evolve it to be scalable, secure, reliable, and
    performant, should the need arise. We can change the software to be interoperable
    with other systems because it’s easy to change. Last but not least, maintainability
    implies testability because maintainable software is most likely designed from
    smaller and simpler components that make testing easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see what I did here. I asked AI for a list of quality requirements
    and then tied them all back to maintainability. I could probably tie many more
    quality requirements back to maintainability with similarly plausible arguments.
    It’s a bit simplistic, of course, but the core of it is true: if software is maintainable,
    it’s easier to evolve in any direction, functionally and non-functionally. And
    we all know that change is common during the life of a software system.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability enables functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now back to my claim that maintainability is more important than functionality
    from the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you ask a product person what’s most important in a software project, they’ll
    tell you that the value the software provides to its users is the most important
    thing. Software that doesn’t provide value to its users means that users don’t
    pay for it. And without paying users, we don’t have a working business model,
    which is the main measure of success in the business world.
  prefs: []
  type: TYPE_NORMAL
- en: So, our software needs to provide value. But it shouldn’t provide value at the
    cost of maintainability.[2](#footnote-006) Think about how much more efficient
    and joyful it is to add functionality to a software system that is easily changeable
    as compared to a software system where you have to fight your way through one
    line of code at a time! I’m pretty sure that you’ve worked on one of those software
    projects where there’s so much cruft and ritual that it takes days or weeks to
    build a feature that you think should take no more than a couple of hours to complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-006-backlink) In the context of this book, I use the term "maintainability"
    synonymously with "changeability of a code base". Also see [https://quality.arc42.org/qualities/maintainability](https://quality.arc42.org/qualities/maintainability)
    for some definitions of maintainability (all of which have to do with changing
    the software).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, maintainability is a key supporter of functionality. Bad maintainability
    means that changes in functionality become more and more expensive over time,
    as shown in *Figure 1**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A maintainable software system has a smaller lifetime cost than
    a not-so-maintainable software system](img/Figure_01.1_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – A maintainable software system has a smaller lifetime cost than
    a not-so-maintainable software system
  prefs: []
  type: TYPE_NORMAL
- en: In a not-so-maintainable software system, changes in functionality will soon
    become so expensive that change is a pain. Product people will complain to the
    engineers about the cost of changes. The engineers will defend themselves by saying
    that shipping new features has always had a higher priority than increasing maintainability.
    The probability of conflict increases with the cost of change.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability is a pacifier. It’s inversely proportional to the cost of change
    and thus to the probability of conflict. Did you ever think about adding maintainability
    to a software system to avoid conflict? I think that’s a good investment in itself.
  prefs: []
  type: TYPE_NORMAL
- en: But what about those big software systems that are successful in spite of bad
    maintainability? It’s true that there are commercially successful software systems
    out there that are barely maintainable. I’ve worked on systems where adding a
    single field to a form is a project that takes weeks of developer time, and the
    client happily paid a premium for my time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those systems usually fall into one (or both) of two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: They are at the end of their life where changes to the system are few and far
    between
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are backed by a financially well-off company that is willing to throw money
    at the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even in the case where a company has a lot of money to spend, the company realizes
    that they can reduce the maintenance tax by investing in maintainability. So,
    usually, there are already initiatives underway to make the software more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: We should always care about the maintainability of the software we’re creating
    so it doesn’t degrade into the dreaded **big ball of mud**, but if our software
    doesn’t fall into one of the two categories mentioned previously, we should care
    even more.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that we have to spend a lot of time planning out a maintainable
    architecture before we even start programming? Do we have to do a **big design
    up front** (**BDUF**), which is often considered synonymous with the waterfall
    methodology? No, we don’t. But we need to do **some design up-front** (should
    we call it **SDUF**?) to bake a seed of maintainability into the software, which
    can make it easier to evolve the architecture to where it needs to be over time.
  prefs: []
  type: TYPE_NORMAL
- en: Part of that up-front design is choosing an architecture style that defines
    the guardrails of the software we’re building. This book will help you decide
    whether a *Clean* – or *Ports and Adapters/Hexagonal* – architecture is a good
    fit for your context.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability generates developer joy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, would you rather work on software where changes are easy or
    on software where changes are hard? Don’t answer; it’s a rhetorical question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the direct influence on the cost of change, maintainability has
    another benefit: it makes developers happy (or, depending on the current project
    they’re working on, it at least makes them less sad).'
  prefs: []
  type: TYPE_NORMAL
- en: The term I want to use to describe this happiness is **developer joy**. It’s
    also known as **developer experience** or **developer enablement**. Whatever we
    call it, it means that we provide the context developers need to do their work
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developer joy is directly related to developer productivity. In general, if
    developers are happy, they do better work. And if they do good work, they are
    happier. There’s a two-way correlation between developer joy and developer productivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Developer joy influences developer productivity and vice versa](img/Figure_01.2_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Developer joy influences developer productivity and vice versa
  prefs: []
  type: TYPE_NORMAL
- en: This correlation has been recognized in the *SPACE framework* for developer
    productivity.[3](#footnote-005) While SPACE doesn’t provide an easy answer on
    how to measure developer productivity, it provides five categories for such metrics
    so that we can consciously pick a set of metrics covering all those categories
    to best measure developer productivity in the context of our company and projects.
    One of these categories (the **S** in **SPACE**) is **satisfaction and well-being**,
    which I’ve translated to developer joy for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-005-backlink) *The SPACE of Developer Productivity* by Nicole
    Forsgren et al., March 6, 2021\. “SPACE” stands for satisfaction and well-being,
    performance, activity, communication and collaboration, and efficiency and flow.
    See [https://queue.acm.org/detail.cfm?id=3454124](https://queue.acm.org/detail.cfm?id=3454124).'
  prefs: []
  type: TYPE_NORMAL
- en: Developer joy not only leads to better productivity but it naturally also leads
    to better retention. A developer who enjoys their work will stay with the company.
    Or rather, a developer who does not enjoy their work is more likely to leave for
    greener pastures.
  prefs: []
  type: TYPE_NORMAL
- en: So, where does maintainability come into the picture? Well, if our software
    system is maintainable, we need less time to implement a change, so we are more
    productive. Also, if our software system is maintainable, we find more joy in
    making changes because it’s more efficient and we can take more pride in it. Even
    if our software is not as maintainable as we would like it to be (which is a tautology,
    to be honest), but we get the opportunity to improve maintainability over time,
    we are happier and more productive. If we are happy, we’re more likely to stay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expressed in a diagram, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.3 – Maintainability directly influences developer joy and productivity\uFEFF\
    \ while developer joy influences retention](img/Figure_01.3_B19916.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Maintainability directly influences developer joy and productivity
    while developer joy influences retention
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability supports decision-making
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a software system, we solve problems every day. For most problems
    we face, there is more than one solution. We have to make decisions to choose
    between those solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Do we copy this bit of code for the new feature we’re building? Do we create
    our objects ourselves or do we use a dependency injection framework? Do we use
    an overloaded constructor to create this object, or do we create a builder?
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these decisions we don’t even make consciously. We just apply a pattern
    or principle we’ve used before that our intuition says will work in the current
    situation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We apply **don’t repeat yourself (DRY)** when we find code duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use **dependency injection** to make the code more testable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We introduce a **builder** to make it simpler to create an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we take a look at these and many other well-known patterns, then what is
    their effect? In many cases, the main effect is that they make the code easier
    to change in the future (i.e., they make it more maintainable). Maintainability
    is built into many of the decisions we’re making automatically every day!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take advantage of that even when facing tougher decisions that require
    more than just applying a pre-canned pattern. *Whenever we have to decide between
    multiple options, we can choose the one that makes the code easier to change in
    the future*.[4](#footnote-004) No more agonizing between different options. We
    just take the one that increases maintainability the most. Expressed as a diagram,
    it’s pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[4](#footnote-004-backlink) In a talk from 2022 with the same name, (Pragmatic)
    Dave Thomas called the principle of making decisions based on changeability "One
    Rule to Rule Them All". I didn''t find the talk online, but I hope he will add
    it to his website at some point. See [https://pragdave.me/talks-and-interviews.html](https://pragdave.me/talks-and-interviews.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Maintainability influences decision-making](img/Figure_01.4_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Maintainability influences decision-making
  prefs: []
  type: TYPE_NORMAL
- en: Like most principles, this is a generalization, of course. In a given context,
    the right decision might be to take the option that does not improve maintainability
    or even reduces maintainability. But as a default rule to fall back on, choosing
    maintainability is a guide that simplifies daily decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, I assume that you believe me that maintainability positively influences
    developer joy, productivity, and decision-making. How do we know that the changes
    we make to our code base increase (or at least don’t decrease) maintainability?
    How do we manage maintainability over time?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to that question is to create and maintain an architecture that
    makes it easy to create maintainable code. A good architecture makes it easy to
    navigate the code base. In an easily navigable code base, it’s a breeze to modify
    existing features or add new features. The dependencies between the components
    of our application are clear and not tangled. In summary, good architecture increases
    maintainability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Software architecture influences maintainability](img/Figure_01.5_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Software architecture influences maintainability
  prefs: []
  type: TYPE_NORMAL
- en: By extension, a good architecture increases developer joy, developer productivity,
    developer retention, and decision-making. We could go on and find even more things
    influenced directly or indirectly by software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: This correlation means that we should invest a bit of thought into how we structure
    our code. How do we group our code files into components? How do we manage the
    dependencies between those components? Which dependencies are necessary, and which
    should be discouraged to keep the code base supple to change? This brings us to
    the purpose of this book. This book shows one way of structuring a code base to
    make it maintainable. The architecture style described in this book is one way
    of implementing a Clean/Hexagonal Architecture. This architecture style is not
    a silver bullet to solve all problems with building software, however. As we will
    learn in [*Chapter 15*](B19916_15.xhtml#_idTextAnchor124), *Deciding on an Architecture
    Style*, it’s not suitable for all kinds of software applications.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to take what you learn in this book, play around with the ideas,
    modify them to make them yours, and then add them to your toolbox to apply when
    they feel right in a given context. Each of the following chapters ends with a
    section titled *How does this help me build maintainable software?* This section
    will summarize the main ideas of each chapter and hopefully help you to make decisions
    regarding the architecture of your current or future software projects.
  prefs: []
  type: TYPE_NORMAL
