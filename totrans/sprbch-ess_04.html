<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 4. Handling Job Transactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Handling Job Transactions</h1></div></div></div><p>In the previous chapter, we learned about essential data handling mechanisms, including reading, processing, and writing data from/to different sources, such as flat files, XML, and databases. From the previous chapters, we learned that Spring Batch jobs handle bulk data reading, manipulating, and writing activities. Through these activities, it is important to make the activity consistent through a transaction while interacting with files/databases. Spring Batch provides strong transaction support through job processing.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Transactions</li><li class="listitem" style="list-style-type: disc">Spring Batch transaction management</li><li class="listitem" style="list-style-type: disc">Customizing the transaction</li><li class="listitem" style="list-style-type: disc">Transaction patterns</li></ul></div><div class="section" title="Transactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Transactions</h1></div></div></div><p>As part of the job <a id="id282" class="indexterm"/>processing, activities involve reading data from different sources, processing the data, and writing it to different sources, including files and databases. Data, as a complete set of records or in chunks, has to either be completely processed and written to the end system, or be tracked as failed records in the case of any error. Transaction management should take care of this operation to make it consistent, by committing the correct information and rolling back in case of any error. The following are the activities involved in a database transaction:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Beginning the transaction</li><li class="listitem" style="list-style-type: disc">Processing a set of records</li><li class="listitem" style="list-style-type: disc">Committing the transaction if no errors occur during processing</li><li class="listitem" style="list-style-type: disc">Rolling back the transaction if any errors occur during processing<div class="mediaobject"><img src="Images/3372OS_04_04.jpg" alt="Transactions" width="500" height="146"/></div></li></ul></div><p>Hence, a <a id="id283" class="indexterm"/>transaction is defined as a series of operations that obey the <span class="strong"><strong>atomic, consistent, isolated, and durable</strong></span> (<span class="strong"><strong>ACID</strong></span>) characteristics described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Atomic</strong></span>: This ensures success in either all or none of the operations in the transaction</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Consistent</strong></span>: This ensures that the transaction brings the resource from one valid state to the other valid state</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Isolated</strong></span>: One transaction's state and effect are hidden from all other transactions during concurrent execution</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Durable</strong></span>: The result of a transaction should be persistent and survive a system crash once the transaction is completed</li></ul></div><p>If a transaction follows these ACID characteristics, it can handle any unexpected errors, by aborting the error that occurs during the transaction, to gracefully recover the consistent state of the system.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Spring Batch transaction management"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Spring Batch transaction management</h1></div></div></div><p>Spring Batch <a id="id284" class="indexterm"/>provides transaction management through step execution, where each transaction is committed after successful data processing <a id="id285" class="indexterm"/>and is rolled back if any error is found through processing.</p><p>Spring Batch manages the transactions in either of the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tasklet steps</li><li class="listitem" style="list-style-type: disc">Chunk-oriented steps</li><li class="listitem" style="list-style-type: disc">Listeners</li></ul></div><div class="section" title="Tasklet steps"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Tasklet steps</h2></div></div></div><p>Tasklets are used <a id="id286" class="indexterm"/>in Spring Batch to process business-specific <a id="id287" class="indexterm"/>activities, such as archiving, remote interactions, and invoking services. By default, the <code class="literal">execute</code> method of the tasklet itself is transactional. Hence, each call to the <code class="literal">execute</code> method calls for a new transaction. The following is a sample tasklet configuration:</p><div class="informalexample"><pre class="programlisting">&lt;step id="stepOne"&gt;
&lt;tasklet ref="myTasklet"/&gt;
&lt;/step&gt;
&lt;bean id="myTasklet" class="batch.MyTasklet"&gt;
&lt;property name="targetObject"&gt;
&lt;bean class="batch.EmployeeData"/&gt;
&lt;/property&gt;
&lt;property name="targetMethod" value="updateEmployeeDetails"/&gt;
&lt;/bean&gt;</pre></div><p>The implementation of the tasklet can be as follows:</p><div class="informalexample"><pre class="programlisting">public class MyTasklet implements Tasklet {
@Override
publicRepeatStatus execute(StepContribution contribution,
ChunkContext chunkContext) throwsException {
...
returnRepeatStatus.FINISHED;
}
}</pre></div></div><div class="section" title="Chunk-oriented steps"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Chunk-oriented steps</h2></div></div></div><p>Chunk-oriented <a id="id288" class="indexterm"/>steps processing undertakes chunks of <a id="id289" class="indexterm"/>records in a read-process-write mechanism, as shown in the following diagram. Each step, once the transaction is started, handles the data to be read, processed, and written, and after the successful completion of these stages, the step commits the transaction. Then, it follows the next transaction to handle the next set of records. If any error occurs in either of these steps, it rolls back the transaction and completes the step execution.</p><div class="mediaobject"><img src="Images/3372OS_04_01.jpg" alt="Chunk-oriented steps" width="800" height="398"/></div><p>Hence, chunk-oriented steps are preferred for bulk data processing so that the entire data is divided into chunks and processed in individual transactions. If any exception occurs in any phase, it rolls back that transaction, hence, the data handling will be more efficient and complete. Failed <a id="id290" class="indexterm"/>steps, which can be logged and re-run with corrected information, are gracefully rolled back. The following is a <a id="id291" class="indexterm"/>sample chunk-oriented step configuration:</p><div class="informalexample"><pre class="programlisting">&lt;step id="stepOne"&gt;
&lt;tasklet allow-start-if-complete="true"&gt;
&lt;chunk reader="itemReader" writer="itemWriter" commit-interval="10"/&gt;
&lt;/tasklet&gt;
&lt;/step&gt;

&lt;step id="stepTwo" parent="stepOne"&gt;
&lt;tasklet start-limit="5"&gt;
&lt;chunk processor="itemProcessor" commit-interval="5"/&gt;
&lt;/tasklet&gt;
&lt;/step&gt;</pre></div><p>In the preceding configuration, we have the first step (<code class="literal">stepOne</code>) with tasklet and chunk within it. To ensure the order of execution, <code class="literal">stepOne</code> is the parent of <code class="literal">stepTwo</code>. While <code class="literal">stepOne</code> configures <code class="literal">itemReader</code> and <code class="literal">itemWriter</code>, <code class="literal">stepTwo</code> configures <code class="literal">itemProcessor</code>.</p></div><div class="section" title="Listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Listeners</h2></div></div></div><p>Spring Batch supports <a id="id292" class="indexterm"/>listeners to execute certain operations after/before an event occurs. Spring Batch handles each of these events, and the way transactions are handled in each listener is specific to that listener and how they handle the <a id="id293" class="indexterm"/>data. Hence, it is important to observe if the listener methods are handled as part of the step transaction. If not, then the application should handle such transactions programmatically. The following is the sample listener configuration:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="myStepExecutionListener" 
      class="org.java.MyStepExecutionListener" /&gt;
  &lt;job id="readEmployeeDetails"&gt;
    &lt;step id="step1"&gt;
      &lt;tasklet&gt;
        &lt;chunk reader="itemReader" writer="itemWriter"
            commit-interval="1" /&gt;
          &lt;listeners&gt;
            &lt;listener ref="myStepExecutionListener" /&gt;
          &lt;/listeners&gt;
      &lt;/tasklet&gt;
    &lt;/step&gt;
  &lt;/job&gt;</pre></div><p>The implementation of the listener can be as follows:</p><div class="informalexample"><pre class="programlisting">public class MyStepExecutionListener implements StepExecutionListener {
 
  @Override
  public void beforeStep(StepExecution stepExecution) {
    System.out.println("StepExecutionListener : beforeStep");
  }
 
  @Override
  public ExitStatus afterStep(StepExecution stepExecution) {
    System.out.println("StepExecutionListener : afterStep");
    return null;
  }

}</pre></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Customizing the transaction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Customizing the transaction</h1></div></div></div><p>Spring Batch allows <a id="id294" class="indexterm"/>the configurations to customize the way transactions are handled. The data exchange between different transactions, if processed and read gracefully, make the transaction clean. However, we have different ways to configure the visibility of transaction integrity to other interactions, called isolation levels. The following <a id="id295" class="indexterm"/>are the isolation levels to customize the Spring Batch transactions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Serializable</strong></span>: This <a id="id296" class="indexterm"/>is the highest isolation level. Based on lock-based or non-lock-based concurrency control, it ensures clean data reading.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Repeatable reads</strong></span>: This <a id="id297" class="indexterm"/>lock-based implementation maintains read and write locks, hence clean data is guaranteed; however, with no support for range locks, phantom reads may occur.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Read committed</strong></span>: This <a id="id298" class="indexterm"/>lock-based implementation maintains the write lock, hence it promises any data read is committed the moment it is read, and restricts any intermediate, uncommitted, and dirty read.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Read uncommitted</strong></span>: This <a id="id299" class="indexterm"/>is the lowest isolation level. One transaction can see the uncommitted changes of other transactions as well. Hence, dirty reads are allowed in this level.</li></ul></div><p>There are predefined constants for each isolation level. By default, the configuration is <code class="literal">READ_COMMITTED</code> for the Spring Batch isolation level. Based on the criticality and importance of the data to be read across transactions, one has to set the isolation level for that transaction. For example, a bank account transaction might want to read only clean, committed data from other <a id="id300" class="indexterm"/>transactions and make the transaction with persistent data. In such cases, one has to choose between the isolation level and performance of the application. The following is a sample isolation level configuration:</p><div class="informalexample"><pre class="programlisting">&lt;job-repository id="jobRepository" isolation-level-for-create="SERIALIZABLE"/&gt;</pre></div><p>If the batch jobs are integrated with applications having other frameworks using similar nomenclature for configurations, then one should be careful with configurations. The intent of control in one technology can control others; it's better to disable either one of the configurations on need basis in such scenarios.</p><p>The attributes on each of the batch components, as discussed in <a class="link" href="ch02.xhtml" title="Chapter 2. Getting Started with Spring Batch Jobs">Chapter 2</a>, <span class="emphasis"><em>Getting Started with Spring Batch Jobs</em></span>, can help us better customize the batch job transaction configurations. For example, one can control the rollback transactions, in specific exception scenarios, by configuring <code class="literal">no-rollback-exception-classes</code>.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Transaction patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Transaction patterns</h1></div></div></div><p>Spring Batch job <a id="id301" class="indexterm"/>processing involves handling data across multiple sources. Such <a id="id302" class="indexterm"/>scenarios, which usually occur time and again, can be identified as transaction patterns.</p><p>The following are the patterns identified:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Simple transaction</strong></span>: This <a id="id303" class="indexterm"/>is a transaction <a id="id304" class="indexterm"/>with a single application and data source (source and target)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Global transaction</strong></span>: This <a id="id305" class="indexterm"/>is a transaction involving <a id="id306" class="indexterm"/>more than one data source to be handled through the <a id="id307" class="indexterm"/>same transaction</li></ul></div><div class="section" title="Simple transaction"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Simple transaction</h2></div></div></div><p>Simple transactions with a <a id="id308" class="indexterm"/>single batch application and a data source can be easily implemented with the support of Spring Batch integrated with diverse database interaction techniques, such as JDBC, JPA, or Hibernate supports from Spring Batch. The interaction would be as shown in the following figure:</p><div class="mediaobject"><img src="Images/3372OS_04_02.jpg" alt="Simple transaction" width="600" height="155"/></div></div><div class="section" title="Global transaction"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Global transaction</h2></div></div></div><p>If more than one <a id="id309" class="indexterm"/>data source has to be persisted through a single transaction, such transactions are termed as global transactions, which can managed by the transaction manager. It is the responsibility of the transaction manager to make sure the transaction obeys the ACID characteristics through its multiple data sources and the data is persisted consistently.</p><p>However, if an application is deployed in an integrated enterprise server, which supports a transaction <a id="id310" class="indexterm"/>manager, that might as well be considered against the <span class="strong"><strong>Java Transaction API</strong></span> (<span class="strong"><strong>JTA</strong></span>) based transaction manager. The following is a representation of a managed transaction.</p><div class="mediaobject"><img src="Images/3372OS_04_03.jpg" alt="Global transaction" width="600" height="438"/></div><p>These transactions can also <a id="id311" class="indexterm"/>be configured to maintain the references of the one database schema as a synonym in another database schema to refer it virtually as a local transaction. However, the effort of creating such synonyms must be considered.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>Through this chapter we learned about transactions and key characteristics of transactions. We also learned how Spring Batch performs transaction management in different scenarios, including tasklet steps, chunk-oriented steps, and listeners. We also learned about customizing the transaction with isolation levels and attribute configurations. We finished this chapter with an understanding of commonly used transaction patterns with single and multiple data sources in a batch application.</p><p>In the next chapter, we will learn in detail about the flow of jobs and sharing data between steps of the executing jobs.</p></div></div>



  </body></html>