- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Java in Standalone Packages and Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter, we will look at different ways to package and distribute
    a Java application. We have already seen JAR files for desktop applications and
    WAR files for web applications, along with how to deploy them. While this approach
    can be sufficient for deployment, there are situations where this traditional
    approach can be improved upon.
  prefs: []
  type: TYPE_NORMAL
- en: Java is big. There are numerous libraries in the Java SE distribution, although
    it is likely that your application only needs some of them. The same can be said
    for third-party or external libraries. Modern packaging using the Java module
    approach allows you to produce JAR or WAR files that only contain parts of a library
    that you will use.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of web applications, this type of packaging can reduce the size
    of a WAR file to contain only the required modules from a required external library,
    rather than the entire library. In the case of desktop applications, it is required
    that the Java language must already be installed on a computer. The Java runtime
    is now modularized. This allows you to create executable applications that do
    not require an installed version of Java to run but, rather, include it as part
    of the packaged installer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will look at the Docker container system. Imagine a team of developers,
    each with different **operating systems** (**OSes**), working on an application.
    While Java is *write once, run anywhere*, it is sometimes advantageous to have
    every developer working in an identical environment. Docker containers help meet
    this need. Furthermore, you can deploy these containers to a cloud. While we will
    not look at cloud deployment, understanding how containers work prepares you for
    working within the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring what modular Java is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom JRE with `jlink`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging with an installer using `jpackage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Docker container system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use a modified version of `BankSwing`, originally from [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254),
    *Desktop Graphical User Interface Coding with Swing and JavaFX*, and now renamed
    `BankSwingJUL` in this chapter, to explore modules and packages. To look at Docker,
    we will use `JSF_FinancialCalculator`, unchanged from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ll need the following for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For `jpackage`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rpm-build` package'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fakeroot` package'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**macOS**: Xcode command-line tools'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop [(https://www.docker.com](https://www.docker.com/)/). To use
    Docker, you will need to create an account. The free Personal account is sufficient.
    Once you have an account, you can download Docker Desktop. There is a version
    for every OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring what modular Java is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we saw code in classes that consists of class fields and methods.
    Then, we grouped these classes into packages and, finally, as a JAR or WAR file.
    Modular Java introduces a new grouping called **modules**. A module is a JAR file
    but with a module descriptor. There is also an automatic module that has a module
    name in its manifest file. This feature of Java is called the **Java Platform
    Module** **System** (**JPMS**).
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we used Maven to build our applications. Maven is a build tool
    that downloads any libraries we need and ensures that our code will compile successfully.
    What it does not do is determine whether all the required external libraries,
    such as Java itself, are present. Its primary job ends when the code successfully
    compiles. The JPMS, on the other hand, focuses on the libraries required to successfully
    run a program. Unlike Maven, JPMS checks that libraries coded as modules are present
    or will be present when the code runs. This leads to the question, what is a module?
  prefs: []
  type: TYPE_NORMAL
- en: A module is a JAR file. There are minor differences between a regular JAR file
    and a module JAR file. At a minimum, a module file must have a file named `module-info.java`
    in the `src/main/java` folder. One purpose of this file is to list the required
    modules. There may not be any required modules, but the presence of this file
    denotes that this project can be a module. Not every library coded in Java has
    been recoded to be a module, but many new libraries are coded this way. A module
    file can be used as an ordinary JAR file or as a module when using JPMS tools.
    You do not need two versions of a library.
  prefs: []
  type: TYPE_NORMAL
- en: At one time, there were two versions of Java available to users. There is the
    JDK that contains the JVM and all the required developer tools, such as the Java
    compiler. The second version was the **Java Runtime Edition** (**JRE**). As its
    name implies, the JRE contains all the necessary libraries to run almost any Java
    program. The JRE was significantly smaller, coming in at around 90 MB, while the
    full JDK is around 300 MB. With the introduction of the JPMS, the JRE was no longer
    available as a download. Times change, and some Java distributions now contain
    a JRE again.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the JRE significantly smaller than the JDK, what can modules do for us?
    The reason is related to why the JRE was dropped from Java distributions. With
    the JPMS, you can construct your own custom JRE, including only those modules
    you need. So, what are the modules in the Java language? In a terminal/console
    window, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now get a list of every module. On my Windows 11 system, there are
    71 modules listed – 22 that begin with `java` and 49 that begin with `jdk`. To
    build a custom JRE, you need to know which modules your program uses. Retrieve
    from this chapter’s GitHub the `BankSwingJUL` project. The only difference from
    the [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254) version is that `JUL` replaces
    `log4j2`. I have done this to reduce the number of modules required to just those
    in the Java distribution. Build the project, and you should find in the `target`
    folder a JAR file named `BankSwingJUL-0.1-SNAPSHOT.jar`. Open a terminal/console
    window in the `target` folder and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will begin with a summary of the Java modules you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The remainder of the output looks at every class in the project, showing you
    what Java classes you are using and what module they belong to. The `java.base`
    module is the home to the core set of classes. The `java.desktop` module is the
    home of Swing, while `java.logging` module is the home of JUL. Now, it’s time
    to create our custom JRE.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom JRE with jlink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `jlink` tool that is part of the Java JDK to create our custom
    JRE. We will begin by creating a JRE that contains all the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one line. In Linux, you can enter a multiline command using the backslash
    (`\`), while in Windows, you use the caret (`^`). The output of this command will
    be a folder named `jdk-17.0.2-jre` that contains a JRE of only 76 MB. This is
    smaller than the original JRE, but we do not want all the Java modules; we just
    need three. Here is our new command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now have a new JRE in the `jdk-17.0.2-minimaljre` folder that is only
    41 MB. Now, we need to use our custom JRE with our application. To test whether
    our JRE is working, you can execute the application by first opening a terminal/console
    window in the `bin` folder of the custom JRE you have created. Issue the following
    command to run your code. Take note that the paths are for Windows, so they must
    be adjusted for Linux or Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a single-line command. If all is well, your `BankSwingJUL` app will
    run. Now, it’s time to wrap up the application into a single executable file that
    contains both our application and the JRE. This will allow us to distribute our
    applications without requiring the recipient of our program to first install Java.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging with an installer using jpackage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our custom JRE created, we are now ready to create a custom installable
    package. You can create these for Windows, Linux, or Mac. You must use the OS
    that is the target of your package. In addition, there are additional steps for
    each OS.
  prefs: []
  type: TYPE_NORMAL
- en: Windows requires you to install the WiX toolset. You can find this at [https://wixtoolset.org/](https://wixtoolset.org/).
    Download the latest version and install it. When you run `jpackage`, it will produce
    an EXE file. You can distribute this file, and when run, it will install all that
    is necessary to run the program in the `C:\Program Files` directory. An executable
    EXE file will be in the folder, and this is how you will run your program.
  prefs: []
  type: TYPE_NORMAL
- en: Linux users, depending on the version they are using, will need the `rpm-build`
    or `fakeroot` package. When you run `jpackage`, it will produce a DEB file for
    Debian Linux or an RPM file for other distros. You can distribute this file, and
    when run, it will install all that is necessary to run the program in the `/opt/application-name`
    directory. An executable file will be in the folder, and this is how you will
    run your program.
  prefs: []
  type: TYPE_NORMAL
- en: Mac users require the Xcode command-line tools. When you run `jpackage`, it
    will produce a DMG file. You can distribute this file, and when run, it will install
    all that is necessary to run the program in the `/Applications/application-name`
    directory. An executable file will be in the folder, and this is how you will
    run your program.
  prefs: []
  type: TYPE_NORMAL
- en: In all three cases, it is not necessary to have Java installed. Even if you
    do, you will be using the custom JRE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an installer package with `jpackage`, you simply enter the following
    on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a single-line command. Here is a rundown of the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--name`: The name of the executable file with `-1.0` added. Use `–app-version`
    followed by a version designation to override this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--input`: The location of the JAR file you are packaging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--main-jar`: The name of the JAR file that contains the class with the `main`
    method. If you do not have a `MANIFEST.MF` file in your JAR file that lists the
    class with a `main` method, you can use `–main-class`, followed by the name of
    the class that contains the `main` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--runtime-image`: This is the path and name of the JRE folder you created
    with `jlink`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dest`: By default, the packaged application will be found in whatever folder
    you issued the `jpackage` command. You can choose the folder you want with this
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon the successful conclusion of this command, you will have an executable
    package that will install your program, with an executable file to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications depend on an application server and not the JRE to run. For
    this reason, we cannot use `jpackage`. This is where our next choice for packaging
    comes in, the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker container system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a platform-as-a-service system that allows you to construct an image
    of a running application that can run in a virtualized Linux container. These
    images can be run on any computer that supports Docker containers. This includes
    Windows and Linux distributions. This image can contain everything necessary to
    run the program. In this section, we will create an image with a Java application
    server, a Java JDK, and our `JSF_FinancialCalculator` web application and deploy
    it in a container. Why this is significant is that most cloud providers, such
    as AWS, support the deployment of cloud applications in Docker containers. We
    will not be discussing cloud deployment, as the various cloud providers work differently.
    What they share is the use of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to install the Docker system. The easiest way is to download
    and install the Docker Desktop system from [https://www.docker.com/](https://www.docker.com/).
    There is a version each for Windows, Mac, and Linux, and they contain a GUI interface
    as well as command-line tools. On a Windows 10 or 11 system that supports WSL2,
    the command-line tools are available in both, a Windows terminal and a WSL2 Linux
    Terminal. This means that, except for how paths to files are described, all commands
    work the same on all OSes. Now, take a moment and install Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we could build an image from scratch, there is another way. Many organizations
    that create software that is destined for the cloud make available pre-built images.
    To these images, we can add our application. In our case, we want a pre-built
    image with Java 17 and an application server. We will use an image from Payara.
    This company provides a server based on GlassFish, with enhancements in both an
    open source community version and a commercial paid version.
  prefs: []
  type: TYPE_NORMAL
- en: Images on Docker Hub may have been created for malicious reasons. While Docker
    provides a service to scan for vulnerabilities, you should also scan any executable
    files in an image for potentially malicious behavior. The Docker plan you have
    signed up for determines how many images you can pull from or push to the Hub.
    With the free Personal subscription, you may have an unlimited number of public
    repositories you can push, but you are restricted to no more than 400 image pulls
    a day. The commercial subscriptions increase the number of pulls from the repository
    and can carry out vulnerability scans on your image.
  prefs: []
  type: TYPE_NORMAL
- en: Start Docker Desktop. It comes with an image and container that contains a basic
    web server that has the documentation pages for Docker. We will do most of our
    setup on the command line, while the desktop GUI is useful for seeing what the
    state of Docker images and containers are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to download the image we will modify by adding the `JSF_FinancialCalculator`
    application. We will use this program unchanged from the previous chapter. Here
    is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you visit [https://hub.docker.com/r/payara/server-full/tags](https://hub.docker.com/r/payara/server-full/tags),
    you can see all the versions of the Payara server available. As you can see from
    the previous command, we are pulling the `server-full:6.2023.2-jdk17` image that
    contains both the server and Java 17\. In Docker, a successful command returns
    a long stream of digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to run this image in a container. While you can run multiple containers,
    network applications that use TCP ports can result in conflicts. For this reason,
    I recommend stopping any containers that are currently running. Using the Docker
    Desktop, select the container list from the menu and look for any containers listed
    as **Running**, and then stop them by clicking on the square button in the **Actions**
    column. You can also stop a container by entering the following at the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `my_container` is replaced by the name of a running container or image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to wrap this image in a container and run the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a single-line command. The `--name` switch allows you to assign a name
    to the container. If you leave this switch out, Docker will assign a random name.
    The `-p` switch maps a port in the container to a port of the computer. In this
    example, we are mapping to the same port. The name of the image is the same as
    the name of the image we pulled down. Assuming that there were no errors, you
    can now test the container. Go to your browser and first visit the Payara home
    page by entering `http://localhost:8080`. Next, visit the admin console page at
    `https://localhost:4848`. You may get a warning from your browser, as the TLS
    certificate is self-signed. Ignore the warning and you should get to the sign-in
    page. The username and password are both `admin`.
  prefs: []
  type: TYPE_NORMAL
- en: Under `JSF_FinancialCalculator` example in the previous chapter, which you can
    find in the project’s `target` folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can now verify that the application has been properly deployed by entering
    in your browser `http://localhost:8080/JSF_FinancialCalculator`. The name of the
    project must match the name of the WAR file. If all works and the calculator opens
    in your browser, you can now create your own container based on the `payara/server-full:6.2023.2-jdk17`
    image, which will contain the calculator app installed on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to create our own image. First, we need to stop the container
    we just used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal/console, enter the following command to create your new container,
    which will contain the Payara image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `transition` is arbitrary and can be anything you want. You now have
    a new container based on the Payara image. We want to modify this container to
    include the calculator application. The first step is to run this new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The most common error that occurs here is if another container is listening
    to the same ports. Ensure that any containers or images with Payara are not running.
    The Docker Desktop app can show you which containers or images are running.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did when we tested the Payara image, use your browser to open the
    admin console of Payara. Now, deploy the `JSF_FinancialCalculator` WAR file to
    the server. Verify that it is running successfully by visiting the application’s
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, make the change to the image in the container, the addition of the web
    app, permanent by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one last step. Enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an entry with `<none>` for both `REPOSITORY` and `TAG`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To resolve this, and as the final step in creating an image, assign a tag name
    and image ID by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note that the hexadecimal number that must be used can be found in the
    table from the previous `docker images` command. When you run `docker images`
    after `docker tag`, the table will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You now have a configured image in your local repository. For anyone to use
    your image, you must publish it on the Docker Hub website.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already noted, for security reasons, any image you use as the basis of a
    new image must be scanned for vulnerabilities, especially any executable code
    in the image. The free Personal tier allows you to have an unlimited number of
    public images. The paid tiers support private images. The first step in publishing
    is to create a repository on the Hub. To do this, open your browser and go to
    [https://hub.docker.com/](https://hub.docker.com/). Sign into your account if
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, select **Repositories** from the choices at the top of the web page. You
    will now see any repositories you may have already created. Click on **Create
    repository**. On this page, you must fill in the form, entering a name for the
    container along with an optional description. It also shows your Docker username.
    Ensure that **Public** is the choice for the repo type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can push your image to the Hub. There are three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `my_username` with your Docker username. You will now be asked for your
    password. You will receive confirmation of a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to change the tag for your image, `transition-image`, to match
    the name of the repository you created, `omniprof/transitioning_to_java`. The
    name consists of your username and the name of the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now comes the final step, pushing your image into the Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To determine whether you were successful, visit Docker Hub and select `omniprof/transitioning_to_java`.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a Docker image that can be shared with your team or clients.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what modular Java means. We took advantage of
    the fact that Java itself has been modularized. This allows you to construct a
    JRE with `jlink` that is significantly smaller than the JDK. You can even make
    it smaller by only including the modules your code depends on.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at two ways to distribute your code. The first employed `jpackage`
    to create an installer for your application. The installer can include your custom
    JRE and will install your program, along with an executable file to run the application.
    This is usually the best way to distribute desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: The second distribution method uses the Docker container system. Docker allows
    us to construct and publish an image that includes not only our code and a JDK
    but also any other programs required. In our example, the extra program was an
    application server to which the finance application was installed. The images
    we construct are published to a repository, such as Docker Hub. Anyone running
    Docker on any OS can now pull our image and have it run in a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: This also leads us to the end of this book. My goal was to provide a reference
    to experienced developers in need of learning about and understanding Java. There
    is still much to learn, but my hope is that this book has put you on the right
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Multi-Module Maven Application with Java* *Modules*: [https://www.baeldung.com/maven-multi-module-project-java-jpms](https://www.baeldung.com/maven-multi-module-project-java-jpms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java Platform, Standard Edition – Packaging Tool User’s* *Guide*: [https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf](https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker* *docs*: [https://docs.docker.com/](https://docs.docker.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
