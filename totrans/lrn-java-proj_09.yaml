- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance and Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), we learned about classes,
    objects, and enums. Initially, we explored the relationship between classes and
    objects and the need to separate the reference type from the object type. We contrasted
    instance versus class members and saw that using the `static` keyword applies
    class scope to a member. We discussed the `this` reference and demonstrated that
    inside an instance method, the `this` reference refers to the object instance
    responsible for the method call. We also covered various access modifiers: `private`,
    package-private (no keyword), `protected`, and `public`. These modifiers enable
    us to apply one of the cornerstones of OOP, namely encapsulation. While encapsulation
    is commonly referred to as “private data, public methods,” we demonstrated that
    this does not go far enough due to Java’s call by value mechanism when passing
    references into and out of methods. We showed how a technique called “defensive
    copying” can be used to apply proper (advanced) encapsulation. To improve our
    understanding of what is happening in the background, we detailed the object life
    cycle and gently touched on garbage collection. We also covered the `instanceof`
    keyword, which is used to determine the object type a reference is referring to.
    We covered a variation of a class, namely **enumerations** (**enums**). Enums
    enable us to limit the number of instances created, thereby facilitating type
    safety. We covered both simple and complex enums. Lastly, we covered another class
    variation, namely records, which saves us from typing a lot of boilerplate code.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore inheritance, another core principle of OOP.
    Initially, we will outline the benefits of inheritance and the Java keywords to
    use. This leads to polymorphism, another core pillar of OOP. We will explain polymorphism
    and, with the aid of examples, how polymorphism is achieved. As polymorphism requires
    “method overriding,” we will explain how to use `instanceof`, to ensure type safety
    when downcasting.
  prefs: []
  type: TYPE_NORMAL
- en: We will also contrast method overriding with method overloading. We will explain
    the `super` keyword and how it is used. As promised in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168),
    we will revisit `protected`, the most misunderstood of Java’s access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will discuss both the `abstract` and `final` keywords and their
    place in inheritance. We will also show how `sealed` classes enable us to scope
    inheritance. In addition, we will cover both `static` and instance blocks in an
    inheritance hierarchy. Lastly, we will discuss upcasting and downcasting the inheritance
    tree, and how a simple rule-of-thumb helps prevent `ClassCastException` errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrasting method overriding and method overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the `super` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting the `protected` access modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the `abstract` and `final` keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying `sealed` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding instance and `static` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering upcasting and downcasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three core pillars in Java: polymorphism, inheritance, and encapsulation
    (data hiding). It is easy to remember them using the acronym “PIE” (*P*olymorphism,
    *I*nheritance, and *E*ncapsulation). Let us now examine inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a code reusability mechanism where common properties between
    related types are exploited by forming relationships between those types. Inheritance
    relationships in Java are created by extending from a class or by implementing
    an interface. We will cover interfaces in [*Chapter 10*](B19793_10.xhtml#_idTextAnchor249),
    so for the moment, we will assume classes throughout. To understand why inheritance
    in OOP is important, we will examine its advantages (and disadvantages). As we
    have not covered the terminology used yet, this discussion will be somewhat abstract.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One principle advantage of inheritance is code reuse. A new class can be written
    based on an existing class rather than writing the new class from scratch. In
    other words, the new class can inherit code that has been already written (and
    tested). This is called *code reuse* and reduces redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance naturally promotes polymorphism, which we discuss later. This feature
    gives your code flexibility. For example, you could have a method that deals with
    an `Animal` reference but at runtime, the code executed is in the `Dog` type (or
    `Cat` or any other type of `Animal` in the hierarchy). In effect, one method works
    with all `Animal` types.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance organizes code into a hierarchy. This can improve productivity and
    simplify the maintenance of code as changes made to inherited code are immediately
    reflected throughout the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite its advantages, inheritance does have its disadvantages. Tight coupling
    between the base (source) type and the derived (target) type is one such drawback.
    Any changes made to the base type affect all the derived types.
  prefs: []
  type: TYPE_NORMAL
- en: Code bloat is another disadvantage. Changes may be made to the base type that
    many derived types do not need and this can result in an unnecessarily large code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an appreciation of inheritance and why it is used, let’s discuss
    the nomenclature (terms) used when discussing inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Base class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The “base” class is also known as the “super” or “parent” class. This is where
    the inherited members are defined. As a class is a type, the term *type* is often
    used interchangeably for class. Note that in Java, the *Object* class is at the
    top of every hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The subclass is also known as the “child” or “derived” class. So, the subclass
    inherits functionality (and/or data) from the base class. Again, as a class is
    a type, the term *subtype* is often used interchangeably for subclass. A class
    can be both a base class and a subclass. Java ensures that *Object* is at the
    top of every (inheritance) hierarchy. Thus, every class we write is implicitly
    a subtype already (even if you do not say so).
  prefs: []
  type: TYPE_NORMAL
- en: The “is-a” relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance generates what is called an *“is-a”* relationship. *Figure 9**.1*
    will help us explain this. We will expand on this diagram as this chapter progresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – UML diagram for the Vehicle hierarchy](img/B19793_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – UML diagram for the Vehicle hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Unified Modeling Language (UML)
  prefs: []
  type: TYPE_NORMAL
- en: 'UML is a modeling language used in software design availing of the maxim that
    “a picture speaks a thousand words.” UML makes understanding topics such as inheritance
    very straightforward, so we will present a very brief overview of UML here. Further
    detail is available here: [https://en.wikipedia.org/wiki/Unified_Modeling_Language](https://en.wikipedia.org/wiki/Unified_Modeling_Language).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With *Figure 9**.1* in mind, here is an overview of the symbols used:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Package name*: The package name is at the top left (`ch9`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Classes*: Classes are in boxes with three sections – the top box is the class
    name; the middle box is for the instance/class variables; the bottom box is for
    the methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Access modifiers*: `public` (+), `private` (-), package-private (~), and `protected`
    (#)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Static*: The underline is used to signify that a member is `static`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method return type*: The last part of the method signature in UML'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Class inheritance*: An arrow with a solid line; for example, `Car` inherits
    from `Vehicle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interfaces*: These are shown in boxes with dashed lines ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interface inheritance*: An arrow with a dashed line ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Association*: A solid line; for example, `TestVehicle` is associated with
    `Vehicle` for the simple reason that we will be creating objects based on the
    `Vehicle` hierarchy in `main()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in *Figure 9**.1*, we have a package, namely `ch9`. There are five
    classes in the `Vehicle` hierarchy: `Vehicle`, `Car`, `Saloon`, `Convertible`,
    and `Boat`. In this hierarchy, from a base class viewpoint, `Vehicle` is the base
    class for `Car` and `Boat`; and `Car` is the base class for `Saloon` and `Convertible`.
    Interpreting the diagram from the sub-class perspective, `Car` and `Boat` are
    sub-classes of `Vehicle`, whereas `Saloon` and `Convertible` are sub-classes of
    `Car`. Regardless of which perspective you use, every `Car` “is-a” `Vehicle`,
    and every `Boat` “is-a” `Vehicle` too. In addition, every `Saloon` “is-a” `Car`,
    and every `Convertible` “is-a” `Car`.'
  prefs: []
  type: TYPE_NORMAL
- en: It also follows that because `Saloon` “is-a” `Car` and `Car` “is-a” `Vehicle`,
    `Saloon` “is-a” `Vehicle` as well. The same applies to `Convertible`; in other
    words, `Convertible` “is-a” `Car`, `Car` “is-a” `Vehicle`; therefore, `Convertible`
    “is-a” `Vehicle` also.
  prefs: []
  type: TYPE_NORMAL
- en: However, the “is-a” relationship works in one direction only (reading the diagram
    from the bottom up). For example, while *every* `Car` “is-a” `Vehicle`, *not*
    every `Vehicle` “is-a” `Car`; some are `Boat`s. There is a very good reason for
    this, which we will explore further when we discuss upcasting and downcasting.
  prefs: []
  type: TYPE_NORMAL
- en: There is one method in `Vehicle`, namely `toString()`, which, because it is
    `public`, is inherited by all the subtypes; namely, `Car`, `Saloon`, `Convertible`,
    and `Boat`. Thus, the version of `toString()` in `Vehicle` is available throughout
    the whole hierarchy. Lastly, the other class, `TestVehicle` contains the `main()`
    method so that we can test the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the concept of inheritance, let’s apply it in code.
  prefs: []
  type: TYPE_NORMAL
- en: Applying inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in the previous section, inheritance creates an “is-a” relationship
    hierarchy. This enables base class functionality to be inherited and therefore
    available to subclasses, without any extra coding. Java uses two keywords in applying
    inheritance: `extends` and `implements`. Let’s discuss them now.'
  prefs: []
  type: TYPE_NORMAL
- en: extends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the principle keyword that’s used and relates to both classes and interfaces.
    Regarding classes, we state that `class Sub extends Base {}`. In this case, all
    of the non-`private` members from the `Base` class will be inherited into the
    `Sub` class. Note that `private` members and constructors are not inherited –
    this makes sense as both `private` members and constructors are class-specific.
    In addition, Java prohibits multiple class inheritance. This means that you cannot
    extend from more than one class at a time. Regarding interfaces, we state that
    `interface ChildInt extends` `ParentInt {}`.
  prefs: []
  type: TYPE_NORMAL
- en: implements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we will discuss interfaces in detail in [*Chapter 10*](B19793_10.xhtml#_idTextAnchor249),
    a brief overview here is appropriate. An interface is a construct that enables
    Java to ensure that if a class implements an interface, the class is, in effect,
    signing a contract. The contract states, generally speaking, that the class will
    have code for the `abstract` methods in the interface. An `abstract` method, which
    we will discuss in more detail later, is a method that has no implementation code;
    in other words, no curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning inheritance, unlike classes, Java allows interfaces to extend from
    more than one interface at a time. So, for example, `interface C extends A, B
    {}`, where `A`, `B`, and `C` are all interfaces, is fine. Note that, as of Java
    8, both the `default` and `static` methods in interfaces have implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: A class implements an interface using the `class Dog implements Walkable` syntax.
    With this, the `static` and `default` methods in `Walkable` are available to `Dog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at inheritance in action. *Figure 9**.2* shows the Java code
    for the UML in *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Inheritance in action](img/B19793_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Inheritance in action
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, lines 3 and 4 are equivalent. `Vehicle` is at the top of this
    particular hierarchy and to ensure that `Object` is inherited by every class,
    the compiler simply inserts `extends Object` after `class Vehicle`, as per line
    3\. Lines 5-7 are a custom implementation of the `toString()` method inherited
    from `Object`. This is known as *overriding*, a topic we will discuss in detail
    shortly. Lines 9-12 represent the rest of the inheritance hierarchy: a `Car` “is-a”
    `Vehicle`; a `Boat` “is-a” `Vehicle`; a `Saloon` “is-a” `Car`; and a `Convertible`
    “is-a” `Car`.'
  prefs: []
  type: TYPE_NORMAL
- en: On line 16, we create a `Vehicle` object and use a `Vehicle` reference called
    `vehicle` to refer to it. On line 17, we call the `toString()` method, defined
    on lines 5-7, outputting `Vehicle::toString()`.
  prefs: []
  type: TYPE_NORMAL
- en: On line 18, we create a `Car` object and use a `Car` reference called `car`
    to refer to it. On line 20, we simply insert the `car` reference inside `System.out.println()`.
    When Java encounters a reference like this inside `System.out.println()`, it looks
    up the object type (`Car`, in this instance) and calls its `toString()`. As every
    class inherits from `Object`, and `Object` defines a basic (unfriendly) `toString()`,
    a version of `toString()` will exist. However, in this hierarchy, `Vehicle` has
    replaced (overridden) `toString()` inherited from `Object` with its own custom
    one (lines 5-7). This custom one from `Vehicle` is inherited by `Car`. What happens
    is that Java checks if there is a custom `toString()` defined in `Car`; as there
    isn’t one, Java then checks its parent, namely `Vehicle`. If `Vehicle` has no
    `toString()`, the version from `Object` would be used. Since `toString()` is defined
    in `Vehicle`, this is the version inherited by `Car` and used on line 20\. Thus,
    the output is, again, `Vehicle::toString()`.
  prefs: []
  type: TYPE_NORMAL
- en: On line 21, we create a `Saloon` object and use a `Saloon` reference called
    `saloon` to refer to it. Again, on line 22, we simply insert the `saloon` reference
    inside `System.out.println()`. As `Saloon` has no custom `toString()` defined,
    and its parent, `Car`, has no custom version either, the one inherited from `Vehicle`
    is used. This results in `Vehicle::toString()` being output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 24 is used to demonstrate the output when the `toString()` method from
    `Object` is used. On line 24, we are creating an instance of `TestVehicle` and
    calling its `toString()` method. As `TestVehicle` is not explicitly inheriting
    from any class (using `extends`), it implicitly inherits from `Object`. In addition,
    as `TestVehicle` is not overriding `toString()` with its own custom version, the
    one inherited from `Object` is used. This is demonstrated by the output from line
    24: `ch9.TestVehicle@378bf509`. The output from the `toString()` method in `Object`
    is formatted as `package_name.class name@hash code`. The package name in this
    case is `ch9` (line 1), the class name is `TestVehicle` (line 24), and the hash
    code is a hexadecimal number that’s used in hashing collections ([*Chapter 13*](B19793_13.xhtml#_idTextAnchor317)).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen basic inheritance in action, let’s move on to another
    cornerstone of OOP, namely polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism has its origins in the Greek terms poly (many) morphe (forms).
    Any object that passes more than one “is-a” test can be considered polymorphic.
    Therefore, only objects of the `Object` type are not polymorphic as any type passes
    the “is-a” test for both `Object` and itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss why separating the reference type from the
    object type is so important. In addition, we will examine method overriding and
    its critical role in enabling polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the reference type from the object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have inheritance hierarchies, we will regularly differentiate the
    reference type from the object type. The reference type can be a class, record,
    enum or interface. In other words, we have flexibility with regard to the reference
    type. The object type is more restrictive: the object type is based on non-abstract
    classes, records, and enums only. In other words, we cannot create objects based
    on abstract classes or interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given the hierarchy in *Figure 9**.2*, it is perfectly legal to
    say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is because every `Car` “is-a” `Vehicle` (reading it right to left, as assignment
    associates right to left). In this instance, the reference, `v`, is of the `Vehicle`
    type and it is referring to an object of the `Car` type. This is known as *upcasting*,
    as we are going *up* the inheritance tree (again, reading it from right to left,
    from `Car` *up* to `Vehicle`). We are upcasting the `Car` reference, created by
    `new Car()`, and casting it to a `Vehicle` reference, `v`.
  prefs: []
  type: TYPE_NORMAL
- en: Why does this work? This works because, due to inheritance, every inheritable
    method available to `Vehicle` will exist in `Car`. That is a guarantee. Whether
    `Car` has overridden (replaced) any/all `Vehicle` methods with its own custom
    ones is immaterial. Given that the compiler looks at the reference type (and not
    the object type), the methods we can call using the `Vehicle` reference, `v`,
    are defined in `Vehicle` (and `Object`) and will be present in `Car` (the object
    type).
  prefs: []
  type: TYPE_NORMAL
- en: So, that is the first point to keep in mind - the compiler is always looking
    at the reference type. As we will see shortly, the object type comes into play
    at runtime. So, a simple but effective rule of thumb is that *a reference can
    refer to objects of its own type or objects of subclasses*. In effect, a reference
    can point “across and down” the (UML) hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: If a reference is ever pointing “up” the hierarchy, that is when you get `ClassCastException`
    errors. Why is this? Well, a subclass inherits from its parent. In addition to
    replacing inherited functionality (overriding), the subclass can also add extra
    methods. So, if you have a reference of the subclass type, you can invoke these
    *extra* added methods. But if your object is of the parent type, these methods
    will not exist! This is a serious issue for the JVM and it throws an exception
    ([*Chapter* *11*](B19793_11.xhtml#_idTextAnchor266)) immediately.
  prefs: []
  type: TYPE_NORMAL
- en: So, the reference type determines the methods that can be called on the object.
    In addition, while the reference type cannot change, the object type it refers
    to can.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s address how to avail of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Applying polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism applies only to instance (non-static) methods, as only instance
    methods can be overridden. At compile time, the compiler decides which method
    signature to bind to; however, the object that will provide the actual method
    to execute is decided at runtime! That is what polymorphism is. This is why polymorphism
    is also known as “runtime binding” or “late binding.”
  prefs: []
  type: TYPE_NORMAL
- en: What if you are accessing a static member?
  prefs: []
  type: TYPE_NORMAL
- en: 'A `static` member (method or data) is associated with the class and therefore
    not involved in polymorphism. The following applies: if you are accessing any
    type of data (`static` or non-static) or `static` methods, the JVM uses the reference
    type. Only if it’s an instance method is the object type used (polymorphism).'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, for polymorphism to work, we need instance methods in the base and subclass
    where the subclass overrides the base version. For this to happen, the subclass
    must code a method that has the same signature as the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that’s enough theory – let’s look at an example that reinforces everything
    we’ve learned thus far.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in code – example 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 9**.3* shows the UML for the code to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – UML for polymorphism example](img/B19793_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – UML for polymorphism example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the `Vehicle` class has a `move()` method. It is an instance
    method, with a return type of `void`. Both `Car` and `Boat` extend `Vehicle` and
    override `move()`. `Car` adds a method called `wheels()` and `Boat` adds a method
    called `floats()`. Both `Saloon` and `Convertible` extend `Car`. `Saloon` overrides
    `move()` but `Convertible` does not.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.4* presents the code for this UML and demonstrates polymorphism
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override annotation'
  prefs: []
  type: TYPE_NORMAL
- en: An annotation is a form of metadata that provides information about the program
    that is not part of the program itself. Annotations are preceded in Java with
    the `@` symbol and have several uses. For example, annotations are used by the
    compiler to detect errors or by the runtime to generate code.
  prefs: []
  type: TYPE_NORMAL
- en: When overriding a base class method, we can insert the `@Override` annotation
    just prior to the subclass method. While not mandatory, it is very useful, because,
    if we apply this annotation, the compiler will ensure that we override the method
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Polymorphism example](img/B19793_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Polymorphism example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, `Car` and `Boat` both extend `Vehicle`; and `Saloon` and `Convertible`
    both extend `Car`. Note that the `move()` method in `Vehicle` (line 4) is a non-static/instance
    method and therefore polymorphic. In addition, as `move()` is non-`private`, it
    is inheritable. The `move()` method from `Vehicle` is overridden by `Car` (line
    7), `Boat` (line 11), and `Saloon` (line 15). To highlight this fact, on each
    of those lines, we have used the `@Override` annotation. This means that the parent
    `move()` method is overridden by the respective subclass versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 21 creates a `Car` object and uses a `Vehicle` reference, namely `v`,
    to refer to it. It is worth repeating that this upcasting, from `Car` up to `Vehicle`,
    is only possible because, via inheritance, *every* `Car` “is-a” `Vehicle`. Therefore,
    any method available to the `Vehicle` reference will exist in `Car`. Consequently,
    as upcasting is never a risk, it is performed implicitly by the compiler; in other
    words, you do not need to explicitly state the (up)cast in code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compile time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Line 22 makes the polymorphic `v.move()` call. Every time a method call is
    in code, there are two perspectives to keep in mind: compile time and runtime.
    As we know, the compiler concerns itself with the reference type. So, in this
    case, the compiler checks the reference, `v`, and determines that it is of type
    `Vehicle`. The compiler then checks if there is a `move()` method, with that exact
    signature in the `Vehicle` class, either defined in `Vehicle` or inherited into
    `Vehicle` (from `Object` in this example). As there is a `move()` method defined
    in `Vehicle`, the compiler is happy.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in action
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At runtime, as `move()` is a non-static, polymorphic method, the object being
    referred to by the reference, `v`, applies. As `v` is referring to a `Car` object,
    the `Car` version of `move()` is executed. This is polymorphism in action! We
    have one method but many implementations of that method. The compiler ensures
    that the method exists and dynamically, at runtime, polymorphism kicks in and
    executes the version in the object being referred to. As `v` is referring to a
    `Car` object, the output from line 22 is `Car::move()`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 23 reuses the `Vehicle` reference, `v` (which is perfectly valid), to refer
    to a `Boat` object. As `Boat` “is-a” `Vehicle`, this is fine. Line 24 makes the
    same polymorphic call to `v.move()` as was the case on line 22\. However, this
    time, `v` is referring to a `Boat` object, and as `Boat` has overridden `move()`,
    the `Boat` version of `move()` is executed at runtime. Therefore the output is
    `Boat::move()`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 25 demonstrates that the compiler looks at the reference type. As we know,
    `v` is of type `Vehicle`. However, `Vehicle` has no `floats()` method; this is
    a method specific to `Boat`. Therefore, the compiler complains about `v.floats()`
    on line 25, and hence, the line is commented out.
  prefs: []
  type: TYPE_NORMAL
- en: Line 26 reuses the `Vehicle` reference, `v`, to refer to a `Saloon` object.
    As `Saloon` “is-a” `Vehicle`, this is fine. Line 27 makes the same polymorphic
    call to `v.move()` as was the case on lines 22 and 24\. As `v` is now referring
    to a `Saloon` object with an overridden `move()` method, the `Saloon` version
    of `move()` is executed polymorphically at runtime. Therefore, the output is `Saloon::move()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 28 creates a `Convertible` object and uses `v` to refer to it. This is
    not a problem as `Convertible` “is-a” `Vehicle` (indirectly, via `Car`). In other
    words, because `Convertible` is-a `Vehicle` and `Vehicle` is-a `Car`, `Convertible`
    is-a `Car` also. Line 29 makes the same polymorphic call, `v.move()`, as was the
    case on lines 22, 24, and 27\. Note, however, that `Convertible` has not overridden
    `move()`. `Convertible` has an empty class body. Therefore, the methods in `Convertible`
    are the `move()` and `wheels()` methods inherited from `Car` and the methods inherited
    from `Object`, such as `toString()`. So, at runtime, when `v.move()` is called,
    the JVM executes the version of `move()` in `Car`, resulting in `Car::move()`.
    You can also look at it this way: the runtime looks for `move()` in `Convertible`,
    and finds none; the JVM then checks the parent, `Car`, and finds one, which it
    executes. Note that if `Car` had not provided a `move()` method, its parent, `Vehicle`,
    would have been next in the search. So, there is an “up the hierarchy, one generation
    at a time” orderly search.'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we get a ClassCastException error?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Line 31 demonstrates downcasting and a `ClassCastException` error. Exceptions
    will be discussed in [*Chapter 11*](B19793_11.xhtml#_idTextAnchor266), so we won’t
    go into detail here. Downcasting will be discussed in greater detail later in
    this chapter but this example is too good to pass up! Let’s examine line 31 in
    greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is that the cast (`Saloon`) *is* required. The compiler
    will not allow the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a compiler error because every `Vehicle` is not a `Saloon` class; some
    are `Boat`s. Indeed, even if the `Boat` class were not present, this line would
    still not compile. Why? Because, reading it right to left, you are going *down*
    the hierarchy from `Vehicle` to `Saloon`. As `Saloon` could (and indeed does)
    have extra methods not in the `Vehicle` class, this situation must be prevented.
    For example, the `Saloon` reference, `s`, has access to the `wheels()` method
    (inherited from `Car`), which is not present in `Vehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can override the compiler by using a (down)cast. This is what line
    31 has done with the `(Saloon)` cast. In effect, by inserting the cast and overriding
    the compiler error, you are saying to the compiler: “Let me proceed, I know what
    I am doing.” So, the code compiles with the cast in place. However, at runtime,
    the JVM realizes that it has a `Saloon` reference referring *up* the inheritance
    tree to a `Vehicle` object. This is a big no-no because *if* the JVM allowed the
    `Saloon` reference `s` to refer to a `Vehicle` object, what would it do with a
    subsequent `s.wheels()` method call? Remember, we would be looking at a `Vehicle`
    object, which has no such method! Hence the JVM generates a `ClassCastException`
    error.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor this code to demonstrate polymorphism from another angle.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in code – example 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 9**.5* shows the refactored code from *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Refactored polymorphism example](img/B19793_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Refactored polymorphism example
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in this figure, the inheritance hierarchy remains untouched from
    *Figure 9**.4*. The `TestVehicle` class (lines 19-30) has been refactored though.
    We have introduced a new method, namely `doAction()` (lines 20-22), that accepts
    a `Vehicle` reference. In the `doAction()` method, we simply call the `move()`
    method (line 21). As `Vehicle` has a `move()` method, this is fine.
  prefs: []
  type: TYPE_NORMAL
- en: Line 24 is as before; it creates a `Car` object and upcasts the reference to
    a `Vehicle` reference, `v`. Thus, `v` is referring to a `Car` object. Line 25
    invokes the `doAction()` method, passing in the reference, `v`. This reference,
    `v`, which is declared on line 24, is copied into the separate (different scope)
    but similarly named reference, `v`, which is declared on line 20\. Now, in `doAction()`,
    we have a local `v` reference referring to the same `Car` object created on line
    24\. Thus, when we invoke `v.move()` on line 21, polymorphism kicks in and we
    get the `Car` version of `move()`, resulting in `Car::move()`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 26 does the same thing in one line of code as was done in the previous
    two lines of code (lines 24-25). On line 26, the `Boat` object is created, and
    the method call to `doAction()` results in the upcast to the `Vehicle` reference,
    `v` (line 20). After that, line 21 executes polymorphically and we get the `Boat`
    version of `move()`, resulting in `Boat::move()`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 27 is the same as line 26 except we are creating a `Saloon` object. Thus,
    the `Vehicle` reference, `v`, in `doAction()` executes the `move()` method as
    `Saloon`, resulting in `Saloon::move()`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 28 is the same as line 27 except we are creating a `Convertible` object.
    Thus, the `Vehicle` reference, `v`, in `doAction()` attempts to execute the `move()`
    method in `Convertible`. As there is none, the parent of `Convertible`, namely
    `Car`, is checked. `Car` does have a version of `move()`, resulting in `Car::move()`.
  prefs: []
  type: TYPE_NORMAL
- en: To be clear about when polymorphism applies and when it does not, we will revisit
    a callout box presented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: JVM – object type versus reference type usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed briefly in a previous callout, if you are dealing with any type
    of data (`static` or non-static), the reference type applies; when dealing with
    instance methods, the object type applies (polymorphism). *Figure 9**.6* presents
    a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – When the JVM uses the reference type versus the object type](img/B19793_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – When the JVM uses the reference type versus the object type
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the `Vehicle` class declares an instance variable, namely `cost`
    (line 4), and a class variable, namely `age` (line 5). In addition, `Vehicle`
    also declares an instance method called `move()` (lines 6-8) and a class method
    called `sm()` (lines 9-11). So, in `Vehicle`, we have both instance and `static`
    data and instance and `static` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `Car` class extends from `Vehicle` (lines 13-23) and simply replicates `Vehicle`.
    In other words, `Car` has the same data and methods as its parent, `Vehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: In `Car`, we declare both instance and non-instance variables, namely `cost`
    and `age`, respectively (lines 14-15). These variables in `Car` have the same
    types and identifiers as their counterparts in the parent class, `Vehicle`. In
    other words, `Vehicle` has an instance variable called `cost`, which is a `double`;
    and `Car` also has an instance variable named `cost`, which is also a `double`.
    The same occurs with the `age` class variable in `Vehicle` – there is a class
    variable named `age` in the `Car` subclass also. This is known as *hiding* (or
    *shadowing*).
  prefs: []
  type: TYPE_NORMAL
- en: '`Vehicle` defines the instance method, `move()` (lines 6-8), which is overridden
    by the version in `Car` (lines 17-19). As this is an instance method, polymorphism
    applies at runtime if `move()` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vehicle` also defines a class method called `sm()` (lines 9-11), which is
    hidden (shadowed) by the version of `sm()` in `Car` (lines 20-22).'
  prefs: []
  type: TYPE_NORMAL
- en: Line 26 creates a `Car` object and uses a `Vehicle` reference, `v`, to refer
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Line 27 outputs `v.cost`. As `cost` is data (an instance variable), the reference
    type applies. Consequently, we get `100.0`, which is the `cost` instance variable
    in `Vehicle` (as opposed to `20_000.0`, which is the `cost` instance variable
    in `Car`).
  prefs: []
  type: TYPE_NORMAL
- en: Using the class name when accessing a static member
  prefs: []
  type: TYPE_NORMAL
- en: 'Both lines 28 and 29 present syntax that you should *never* use: using a reference
    to access a `static` member. When accessing a `static` member, you should prefix
    the member with the class name. For example, line 28 should use `Vehicle.age`
    and line 29 should use `Vehicle.sm()` as this emphasizes the member’s `static`
    nature. Using references here is confusing as it implies that the member is non-static.
    We accessed `static` members using the reference for demo purposes only!'
  prefs: []
  type: TYPE_NORMAL
- en: Line 28 outputs `v.age`. As `age` is a `static` member, the compiler checks
    the type for `v` (namely `Vehicle`) and changes `v.code` to `Vehicle.code`. Therefore,
    `age` from `Vehicle` is used as opposed to `age` from `Car`. In other words, the
    output is 1, not 2.
  prefs: []
  type: TYPE_NORMAL
- en: Line 29 is the call to `v.sm()`. As `sm()` is also `static`, the compiler translates
    this into `Vehicle.sm()` and therefore the output is `Vehicle::sm()`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, line 30 is the polymorphic call to `move()`, and as a result, the object
    type, `Car`, is used. This results in `Car::move()` being output.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand polymorphism, let’s ensure that we understand the difference
    between two terms that are often confused, namely method overriding and method
    overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting method overriding and method overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These two terms are often confused but in this section, we will compare and
    contrast both. We will show that concerning method overloading, the method signature
    must be different; whereas concerning method overriding, the method signature
    must be the same. Recall that the method signature consists of the method name
    and the parameter types, including their order. The return type and the parameter
    identifiers are *not* part of the method signature. So, for example, take the
    method from *Figure 9**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The signature is `doAction(Vehicle)`.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we will initially discuss method overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that the method signature consists of the method name and the parameter
    types. Method overloading is where you have the same method name but the parameters
    differ, either in type and/or order. This means that the method signatures are
    different even though the method names are the same. They have to be – how else
    will the compiler choose which method to bind to? Thus, method overloading is
    all about compile time.
  prefs: []
  type: TYPE_NORMAL
- en: The rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bearing in mind that the method signatures *must be different* (apart from
    the method name), the rules are quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded methods must use *DIFFERENT* parameter lists; either the types used
    must be different or the order of the types must be different
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the method signature only relates to the method name and the parameter list,
    overloaded methods are free to change the return type and the access modifier
    and use new or broader checked exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overloaded method can be overloaded in the same type or a subtype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s look at an example of method overloading in code.
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 9**.7* presents the example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Method overloading](img/B19793_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Method overloading
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we will first discuss the method overloading between lines
    10-17\. To help, the method signatures are in comments on each line. Line 10 defines
    a `calc` method that takes in an `int` and a `double`, in that order. Therefore,
    the signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are not interested in the return type or the identifiers used for the `int`
    and `double` parameters. So long as we do not code another `calc(int, double)`
    method in the *same class*, we are okay. Note that if we coded a method with the
    same signature in a subtype, this is overriding! As the method signatures between
    lines 11-14 are different, they are fine.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine why lines 16 and 17 fail to compile. Line 16 attempts to just
    change the identifiers used for the parameters. This does not change the method
    signature. Consequently, this signature is an exact match for the method on line
    10 and therefore, the compiler complains. Similarly, line 17 changes the return
    type (as well as the identifiers in the parameter list). Again, as this signature
    is a duplicate of the one on line 10, the compiler complains.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance hierarchy is interesting. We have a parent called `Animal` (lines
    2-4) and a subclass class `Cow` (lines 5-8). On line 3, `Animal` defines an `eat()`
    method. On line 7, `Cow` overloads this method with an `eat(String)` method. The
    parent `Animal` version accepts no argument, whereas the subtype version accepts
    `String`. The compiler is happy.
  prefs: []
  type: TYPE_NORMAL
- en: But what about line 6, where `Cow` defines an `eat()` method that accepts no
    argument? This is overriding the parent version (polymorphism), so there is no
    conflict. The compiler will bind to the reference type used, be it `Animal` or
    `Cow`, as both have an `eat()` method. At runtime, depending on the object type,
    the JVM will execute the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine this process to make sure it is clear. Line 20 creates an `Animal`
    object and uses an `Animal` reference, `aa`, to refer to it. Line 21 calls `aa.eat()`.
    At compile time, the compiler checks if there is an `eat()` method with that exact
    signature in `Animal`, as `Animal` is the type for `aa`. As there is, the compiler
    is happy. At runtime, as the method is an instance method, polymorphism applies
    and the JVM will execute the `Animal` version (as that is the object type).
  prefs: []
  type: TYPE_NORMAL
- en: Note how line 22 does not compile. This is because there is no `eat(String)`
    method in `Animal`. Remember, the compiler looks at the reference type only and
    as `aa` is of type `Animal`, it checks the `Animal` class.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 24-26 take things one step further. Line 24 creates a `Cow` object and
    uses an `Animal` reference called `ac` to refer to it. Line 25 makes the polymorphic
    call to `eat()`, which will execute the `Cow` version at runtime. Line 26 is interesting
    and is there to prove that the compiler is looking at the reference type. Even
    though our object type is `Cow` and `Cow` has an `eat(String)` method, the `ac.eat("Grass")`
    class still does not compile (because `ac` is of type `Animal`).
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we get access to the `eat(String)` method? We need a `Cow` reference.
    This is what lines 28-30 demonstrate. Line 30 successfully invokes `cc.eat("Grass")`
    using the `cc` reference declared on line 28.
  prefs: []
  type: TYPE_NORMAL
- en: What this code demonstrates is that an `Animal` reference only has access to
    the `eat()` method it defined. On the other hand, a `Cow` reference has access
    to both `eat()` and `eat(String)`. The `Cow` type inherited (and overrode) `eat()`
    and defined `eat(String)` itself. Note that the `Cow` class did not need to override
    `eat()` to have access to the inherited version.
  prefs: []
  type: TYPE_NORMAL
- en: Method overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method overriding occurs when you have the same method signatures in both a
    parent and subclass. Method overriding is critical for enabling (runtime) polymorphism.
    Remember, a method must first be inherited to be overridden. For example, methods
    that are defined as `private`, `static`, or `final` are not inherited because
    `private` methods are local to the class; `static` methods are not polymorphic
    and marking a method as `final` is stating that “this method is not to be overridden.”
  prefs: []
  type: TYPE_NORMAL
- en: To understand the rules, it is critical to remember that the compiler has compiled
    the code based on the reference. Therefore, the runtime polymorphic method *must
    not* behave differently from what the compiler verified. For example, the access
    modifier on the overriding method cannot be more restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss the rules, we must first explain covariant returns.
  prefs: []
  type: TYPE_NORMAL
- en: Covariant returns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you are overriding a parent method in a subclass, if the return type is
    a primitive, then the overriding method’s return type must match. However, if
    the return type is a non-primitive, then there is one exception to the rule: covariant
    returns.'
  prefs: []
  type: TYPE_NORMAL
- en: What a covariant return means is that if you return a type, `X`, in the parent
    method, then you can return `X` and any subtype of `X` in the overriding method.
    For example, if a parent method is returning `Animal`, then the overriding method
    can return `Animal`, (naturally) as well as any subtype of `Animal`; for example,
    `Cow`.
  prefs: []
  type: TYPE_NORMAL
- en: The rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we discuss the rules, it is helpful to bear in mind that the compiler checks
    against the reference type. These overriding rules ensure that the runtime object
    cannot do something that the compiler (and thus your code) does not expect. The
    rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method signatures must match exactly in the parent and subclass; otherwise,
    you are just overloading the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return types must match also, except for covariant returns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access modifier on the overriding method cannot be more restrictive. So,
    if the parent method defines a method as `public`, the subclass cannot override
    it with a `private` method. This makes sense, as your code, verified by the compiler,
    is expecting access to the method. *If*, however, you were allowed to reduce access
    when overriding, the compiler would have said “It is okay to access this method,”
    whereas the JVM would not! This rule helps keep the compiler and JVM in sync.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, to keep the compiler and JVM in sync, an overriding method cannot throw
    (generate) new or broader checked exceptions ([*Chapter 11*](B19793_11.xhtml#_idTextAnchor266)).
    Briefly, an exception is an error and checked exceptions must have code present
    to handle them. This is enforced by the compiler. If, at runtime, the overriding
    method threw/generated an exception for which there was no code to handle it,
    the JVM would be in trouble. So, the compiler steps in and prevents that from
    happening.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s look at an example of method overriding in code.
  prefs: []
  type: TYPE_NORMAL
- en: Method overriding example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 9**.8* presents the example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Method overriding](img/B19793_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Method overriding
  prefs: []
  type: TYPE_NORMAL
- en: The code in this figure demonstrates what you can and cannot do when overriding
    a method. In the `Dog` class (lines 5-8), we have a `walk()` method that returns
    nothing (`void`). There is also a `run()` method that returns `Dog`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Terrier` class subclasses from `Dog` (line 9). Therefore, any `Terrier`
    “is-a” `Dog`. As the two methods in `Dog` are `public`, `Terrier` automatically
    inherits them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the lines in `Terrier` in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Line 10 does not compile because, while the method signatures match (both are
    `walk()`), the return types are different. The parent return type is `void` and
    thus, the overriding return type must match; it does not, it is `String`, causing
    the compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Line 11 does not compile because you cannot weaken the access modifier when
    overriding. The `walk()` method in `Dog` is `public`, so `walk()` in `Terrier`
    cannot be `private`. *If* this was allowed, then when the JVM went to execute
    the `walk()` method in `Terrier`, using a `Dog` reference (as on line 24), there
    would be a serious problem. The compiler, looking at the `public` `Dog` version,
    said “All is well;” but the JVM would, polymorphically, encounter the `private`
    version in `Terrier`!
  prefs: []
  type: TYPE_NORMAL
- en: Line 12 fails to compile because the overridden method did not throw any exceptions
    but the overriding method is attempting to throw a new checked exception (`IOException`).
    This is similar to the previous access issue – the compiler will have checked
    the `walk()` version in `Dog` and as it throws no exceptions (errors), no code
    is present to handle (cater) for these exceptions. *If* the overriding method
    was allowed to throw new checked exceptions, what would the JVM do with them (as
    there is no code in place to handle them)?
  prefs: []
  type: TYPE_NORMAL
- en: Line 13 is simply an overload. `Dog` defines a `walk()` method; `Terrier` defines
    a `walk(int)` method. Two separate method signatures means two separate methods.
    As the methods have the same name, this is method overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Line 14 is a correct method override. We used the `@Override` annotation to
    ensure that we have overridden properly (no typos, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Line 16 is an exact duplication of the `run()` method defined on line 7\. We
    just included it for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Line 17 demonstrates covariant returns because it defines a `Terrier` return
    type. This is a valid covariant return because `Terrier` is a subtype of the parent
    return type, `Dog` (line 7). The code for the overridden method (line 17) simply
    returns a `Terrier` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 18 is almost identical to line 17 except that the return type is now `Dog`.
    Thus, there is an upcast going on in the background. The code for `walk()` on
    line 18 is shorthand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s look at the `main()` method in `OverridingTest`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 23 creates a `Terrier` object that can be accessed via a `Dog` reference,
    `dt`. Line 24 invokes the polymorphic `walk()` method in `Terrier`. As `Terrier`
    overrode the `walk()` method it inherited from `Dog`, the `Terrier` version is
    dynamically executed at runtime, resulting in `Terrier::walk()` being output.
  prefs: []
  type: TYPE_NORMAL
- en: Line 25 executes the `run()` method using the `dt` reference created on line
    23\. As `run()` is an instance method where `Terrier` overrode the version inherited
    from `Dog`, the version in `Terrier` is executed, resulting in the `d` reference
    (line 25) referring to a `Terrier` object (line 18). This is proven by the use
    of the `instanceof` operator (line 26). As the `Dog` reference, `d`, is indeed
    referring to a `Terrier` object, the `if` statement is `true`, resulting in *Terrier
    object* being output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'That concludes our discussion of method overloading and method overriding.
    Now, let’s examine a keyword that is pivotal in inheritance: `super`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the super keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `super` keyword is used in a subclass in two specific scenarios: to call
    a parent constructor and to access parent members (typically methods). When an
    object is constructed, the order of constructor calls is very important. Bearing
    in mind that we now have the possibility of having many classes in an inheritance
    hierarchy, *the order of constructor calls is from the top down*. This means that,
    the parent constructor is *always* called before the subclass constructor. If
    you have a hierarchy where `Toyota` “is-a” `Car` and `Car` “is-a” `Vehicle`, then
    when you go to create a `Toyota` object, the order of constructor calls is as
    follows: `Vehicle` is first, `Car` is second, and `Toyota` is last.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a good reason for this. Firstly, remember that the constructor’s role
    is to initialize the instance members of the class. Now, given that the subclass
    constructor *may use inherited members* from its parent when initializing its
    own members, it stands to reason that the parent must first get a chance to initialize
    those members.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the situations where the `super` keyword is very often used. We
    will then present code, supported by a UML diagram, where both contexts are demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: super()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the parentheses after `super`, as in `super()`, you are invoking
    the parent constructor. If required, you can pass in arguments inside the parentheses
    as constructors are just (special) methods. There are two rules for the use of
    `super()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `super()` can only appear inside a constructor and not a regular
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If present, the call to `super()` must be the very first line in the constructor
    (there is one exception – see the callout)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have coded several constructors so far and none of them had a call to `super()`
    present. How did that work? Well, if you *do not* provide any constructor at all,
    the default constructor will be synthesized by the compiler for you and its first
    line of code is `super();`. Please refer back to *Figure 8**.1* and *Figure 8**.2*
    for examples of this. If you *do* provide a constructor, then the compiler will
    also insert `super();` as the first line (unless the first line is already a call
    to `super()` or `this()` ).
  prefs: []
  type: TYPE_NORMAL
- en: The first line of any constructor
  prefs: []
  type: TYPE_NORMAL
- en: The very first line of any constructor is `this()` or `super()`. You cannot
    have both. A call to `this()` is a call to another constructor in the same class.
    From the inheritance hierarchy perspective, this is a sideways call. Remember
    that the parent constructor must be called before the subclass constructor. Regardless
    of whether `this()` is present or not, the order of constructor calls is from
    the top down. Now, if the subclass constructor has a `this()` call present, it
    is only delaying the call to `super()`. At some point, either explicitly or implicitly,
    the call to `super()` will execute. Note that, as with `super()`, the call to
    `this()` can contain arguments.
  prefs: []
  type: TYPE_NORMAL
- en: So, `super()` relates only to constructors and must be the first line of code
    (assuming `this()` is not there already). Now, let’s examine the other scenario.
  prefs: []
  type: TYPE_NORMAL
- en: super.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access a parent member (not the constructor), you can use the `super.` dot
    notation syntax. As with the `this` keyword, the `super` keyword relates to instances
    and thus cannot be used from within a `static` context (`static` methods or `static`
    blocks). This can be very useful when you want to piggyback on parent functionality.
    For example, the subclass method can invoke its parent version first and then
    execute its own version. This is what we will demonstrate in the example.
  prefs: []
  type: TYPE_NORMAL
- en: So, rather than call a parent constructor from a subclass constructor (which
    is what `super()` is for), `super.` gives us access to the other (non-constructor)
    members.
  prefs: []
  type: TYPE_NORMAL
- en: An example of using super
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine both `super()` and `super.` in code. *Figure 9**.9* presents
    the UML inheritance diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – UML for demonstrating super() and super.](img/B19793_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – UML for demonstrating super() and super.
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have three classes representing a class inheritance hierarchy.
    `Employee` is at the top of the hierarchy. `Manager` “is-a” `Employee` and `Director`
    “is-a” `Manager`. Indirectly, `Director` “is-a” `Employee` also. Each of the classes
    has `private` instance variables that its respective constructors will initialize,
    based on the arguments passed into the respective constructor. For example, the
    `Employee` constructor takes in two parameters, `int` followed by `String`; these
    parameters will be used to initialize the `Employee` instance variables, namely
    `empId` (`int`) and `name` (`String`).
  prefs: []
  type: TYPE_NORMAL
- en: '`EmployeeTest` is simply the driver to ensure the code is working as it should.
    Let’s examine the code. *Figure 9**.10* is the code for the UML in *Figure 9**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Code demonstrating super](img/B19793_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Code demonstrating super
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the `Employee` class initializes its instance variables (lines
    8-9). The `toString()` method for `Employee` (line 11) returns a `String` outlining
    the values in the `empId` and `name` instance variables. Line 11 also uses the
    `@Override` annotation because it is overriding the `toString()` method inherited
    from `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Manager` class “is-a” `Employee` (line 13). `Manager` contains (is composed
    of) a `String` instance variable, namely `deptName`. This is known as composition.
  prefs: []
  type: TYPE_NORMAL
- en: Composition versus inheritance
  prefs: []
  type: TYPE_NORMAL
- en: Composition defines a *“has-a”* relationship whereas, inheritance defines an
    *“is-a”* relationship. Composition is where an object is “composed” of other objects.
    For example, `Car` has `Engine`. In *Figure 9**.10*, `Manager` “is-a” `Employee`
    (line 13), but `Manager` “has-a” department, which is represented by the `String`
    instance variable `deptName` (line 14).
  prefs: []
  type: TYPE_NORMAL
- en: The `Manager` constructor (lines 16-19) is where things get interesting. Line
    17, `super(empId, name)`, is the call to the parent constructor in `Employee`
    passing up the employee ID (`empId`) and employee name (`name`) that are required
    by the `Employee` constructor. That is why the `Manager` constructor requires
    those parameters in the first place – it needs the employee ID and employee name
    so it can invoke its parent `Employee` constructor. The `Manager` constructor
    also requires the department name so that it can initialize its own instance variable,
    `deptName`. Thus, when executing a `Manager` constructor, the `Employee` constructor
    is executed first and then the `Manager` constructor executes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if line 17 is commented out, the code will not compile. Why? Because
    the compiler will now insert `super()`; which is attempting to call the `Employee`
    constructor with no-arguments (the `no-args` constructor, namely `Employee()`).
    There is no such constructor in `Employee`. Additionally, as `Employee` has already
    defined a constructor, the compiler will not insert the default (`no-args`) constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `Manager` classes’ `toString()` method (lines 21-24), overrides the version
    inherited from `Employee`. However, `Manager` can still access the `Employee`
    version, which it does by using `super.toString()` on line 23\. Thus, the `toString()`
    method in `Manager` first executes the `toString()` method in `Employee`, which
    returns the employee ID and employee name. The `Manager` classes’ `toString()`
    method then appends its own instance variable, `deptName`, to the overall `String`
    to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Director` class behaves similarly to `Manager`. The constructor “supers
    up” (line 30) the required data for the `Manager` constructor; in turn, the `Manager`
    constructor supers up the required data for the `Employee` constructor. So, when
    creating a `Director` object, the order of constructor calls is as follows: `Employee`
    is first; `Manager` is second; `Director` is last. On line 31, `Director` initializes
    its own instance data.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Director` version of `toString()`, on line 33, first calls the `Manager`
    version of `toString()` using `super.toString()`. The `Manager` version (line
    23) then calls the `Employee` classes’ `toString()` method, which is on line 11\.
    So, the employee’s ID and name are the first employee details in the string. Next,
    the manager data (`deptName`) is appended (after the call to the `Employee` classes’
    `toString()` method returns). Lastly, the `Director` data (`budget`) is appended
    to the string (after the call to the `Manager` classes’ `toString()` method returns).
    Note that you cannot bypass a level in the hierarchy; meaning that, `super.super.`
    is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '`EmployeeTest` is the driver class. In `main()` on line 39, we create a `Director`
    object that can be accessed via an `Employee` reference of `emplDir` (implicit
    upcasting). Using `super()` as outlined, this results in the `Employee` constructor
    being executed first, followed by the `Manager` constructor, and lastly the `Director`
    constructor being executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 40 passes the `emplDir` reference to `System.out.println()`, resulting
    in a polymorphic call to the `Director` classes’ `toString()` method. Using `super.toString()`,
    `Director` invokes the `Manager` classes’ `toString()` method, which also has
    a `super.toString()` method resulting in `Employee` `toString()` being executed
    first. Then, the `Manager` classes’ `toString()` method finishes, and lastly,
    the `Director` classes’ `toString()` method finishes. The output shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding the output, `ID: 754, Name: Joe Bloggs` is output from `Employee
    toString()`, `Department: Marketing` is output from the `Department toString()`,
    and `Budget: 10000.0` is output from `Director toString()`.'
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our discussion on `super`. Now that we understand inheritance,
    as promised in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), let’s return to
    the `protected` access modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the protected access modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall that a `protected` member is accessible from within its own package
    and any subclasses outside of the package: *protected = package + children*. On
    the face of it, this seems very straightforward. However, some nuances lead to
    confusion. The subclasses that access the `protected` member (via inheritance),
    can only do so *in a very specific way*. A subclass from outside the package cannot
    use a superclass reference to access the `protected` member! In addition, an unrelated
    class from outside the package cannot use a reference to the subclass outside
    the package either to access the `protected` member. In effect, once the subclass
    that’s outside the package inherits the `protected` member, that member becomes
    `private` to the subclass (and subclasses of the subclass). This is quite tricky
    and definitely needs an example.'
  prefs: []
  type: TYPE_NORMAL
- en: The UML diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.11* shows the UML diagram for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – UML for “protected” code](img/B19793_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – UML for “protected” code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have two packages, namely `ch9.pkgA` and `ch9.pkgB`. In `ch9.pkgA`,
    we have a `Book` class and its subclass, `NonFictionBook`. The `read()` method
    in `Book` is marked with the `#` symbol, which means it is `protected`. The `Magnifier`
    class is not related to `Book` and is simply another class in the same package.
  prefs: []
  type: TYPE_NORMAL
- en: In `ch9.pkgB`, `FictionBook` subclasses `Book` from `ch9.pkgA` and provides
    a `doThings()` method, which we will use to demonstrate what is/is not allowed.
    In addition, `SpaceFictionBook` subclasses `FictionBook` and overrides the `doThings()`
    method inherited from `FictionBook`. Lastly, `Reader` is a completely separate
    class from the `Book` hierarchy; its `doThings()` method is also a sample method
    for demo purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from the previous chapter that we had not fully completed the access
    modifiers table (as we had not covered inheritance at that point). *Table 9.1*
    represents the completed access modifiers table. Bear in mind that the table represents
    annotating a member in the `Book` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 - Access modifiers table with ‘protected’ row fully filled out](img/B19793_09_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 9.1 - Access modifiers table with ‘protected’ row fully filled out
  prefs: []
  type: TYPE_NORMAL
- en: Examining the `protected` row, we can now see that subclasses, regardless of
    the package, can access inherited protected members.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us examine the code for each of the packages in turn. Firstly, we will
    examine the package that defines the `protected` member.
  prefs: []
  type: TYPE_NORMAL
- en: The package with the protected member
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.12* shows the code for the first package, `ch9.pkgA`, from *Figure
    9**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Code for “ch9.pkgA” from UML](img/B19793_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Code for “ch9.pkgA” from UML
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a class called `Book` (lines 3-5) that defines a `protected`
    `read()` method (line 4). `NonFictionBook` is a subclass of `Book` and has its
    own `doThings()` method (lines 7-9). In addition, there is a completely unrelated
    class to `Book`, namely `Magnifier`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that, as the `read()` method is `protected`, other
    code in the same package can access it, even if the code is *not* a subclass.
    This is demonstrated by line 14, where the `read()` method in `Book` is accessed
    from `Magnifier`, a completely unrelated class.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, regardless of the package, subclasses can access the `protected`
    member. This is shown on line 8, where the `NonFictionBook` subclass invokes `read()`.
    Remember that line 8 is essentially `this.read()`. So, whichever `NonFictionBook`
    object is used to invoke `doThings()` on line 7 will be used to invoke the inherited
    (and `protected`) `read()` method on line 4.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting code is in the other package, namely `ch9.pkgB`. Let’s examine
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: The other package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.13* presents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Code for “ch9.pkgB” from UML](img/B19793_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Code for “ch9.pkgB” from UML
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we can see that `FictionBook` “is-a” `Book` (line 5) and `SpaceFictionBook`
    “is-a” `FictionBook` (line 19). For this hierarchy to be possible, the `Book`
    class needed to be imported from the other package (line 3). We were only able
    to import `Book` from another package because `Book` is a `public` class. In addition,
    we have a completely unrelated class called `Reader` (lines 27-36).
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the fun! Let’s examine the `dothings()` method in `FictionBook` (lines
    6-17). Lines 7 and 8 are essentially equivalent and show that subclasses outside
    the package, when using *inheritance directly*, can access `protected` members.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 9-10 also show that when inside the subclass outside the package, if you
    create an instance of that particular subclass (`FictionBook`, in this instance),
    then all is ok. This makes sense because the two references used to invoke `read()`
    without issue, namely `this` and `fb`, are both of type `FictionBook`, where the
    code resides.
  prefs: []
  type: TYPE_NORMAL
- en: Note that line 15, where we instantiate a `Book` object, compiles because the
    `Book` class (*Figure 9**.12*, line 3) is `public`. The `Book` class did not define
    a constructor, so the default constructor was created for us. This default constructor
    takes on the same access as the class, namely `public`, and as a result, we can
    invoke the constructor from a different package.
  prefs: []
  type: TYPE_NORMAL
- en: Line 16, which does not compile, is very interesting. When inside the subclass
    outside the package, you cannot access the `protected` member using the superclass
    reference – even though the `protected` member resides in that superclass! Remember
    that, once outside the package, the `protected` member becomes `private` to subclasses
    (and their subclasses). In other words, you must use inheritance in a very specific
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '`SpaceFictionBook` (lines 19-26) shows that access is available to subclasses
    of the subclass outside the package. Line 21 is the same as line 7, except that
    they are in two separate classes. As this line compiles, it demonstrates that
    subclasses of the subclass outside the package have access to the `protected`
    member in the base class.'
  prefs: []
  type: TYPE_NORMAL
- en: Lines 22 and 23 both fail to compile. Line 22 tries to access the `protected`
    member via a `Book` reference and line 23 tries to access it via a `FictionBook`
    reference. Both fail. Contrast this with line 24, which uses an instance of the
    current class, namely `SpaceFictionBook`, which works. Note that line 24 is similar
    to line 21 in that a `SpaceFictionBook` reference is used in both instances (as
    line 21 is equivalent to `this.read()`). In addition, line 24 is very similar
    to lines 9-10\. Therefore, when in a subclass outside the package, access the
    `protected` member directly, as on lines 7, 21; or use a reference to the current
    subclass, as on lines 10, 24.
  prefs: []
  type: TYPE_NORMAL
- en: The `Reader` class (lines 27-36) is a completely separate class from the `Book`
    hierarchy. Line 30 attempts to access the `protected` member using a reference
    to the class that defines the `protected` member, namely `Book`, and fails. Line
    34 attempts to access the `protected` member using a reference to the subclass
    outside the package that inherits the `protected` member, namely `FictionBook`,
    and also fails.
  prefs: []
  type: TYPE_NORMAL
- en: So `protected` is somewhat tricky. While we are revisiting previous topics,
    it is an ideal opportunity to revisit `switch`. To be more specific, to discuss
    pattern matching for `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As promised from [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087), now that
    we understand inheritance and polymorphism, we are going to revisit the `switch`.
    Given the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Assume that `Car`, `Boat`, and `Train` all extend from `Vehicle` and that `Car`
    has a custom method `onRoad()`. As you can see, in this `switch` expression, the
    selector expression, `v`, can be any reference type (`Boat`, `Train`, `Car`, and
    so forth). The `case` labels demonstrate *type patterns and pattern matching*;
    for example, `Boat b`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, both `case` labels for `Car` are known as *guarded patterns*. A
    guarded pattern is a `case` label protected by a “guard” on the right-hand side
    of a `when` clause. A guard is a conditional expression, evaluating to true or
    false. Note the use of the custom `Car` method `onRoad()` and the fact that no
    cast is required, as the cast is done for us in the background (provided we are
    dealing with a `Car`).
  prefs: []
  type: TYPE_NORMAL
- en: The last case `label`, containing `default`, ensures exhaustiveness is catered
    for, thereby keeping the compiler happy. In other words, all possible `Vehicle`s
    are catered for. Note also the use of `null` as a valid label and the fact that
    `null` and `default` can be comma separated.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the effect on inheritance of two particular keywords, namely
    `abstract` and `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the abstract and final keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, when coding methods, we can apply the access modifier keywords,
    namely `private`, `protected`, `public`, and package-private (no keyword). Two
    other keywords have special significance regarding inheritance: `abstract` and
    `final`. Both are opposites of each other, which is why both cannot be applied
    to a method at the same time. Let’s discuss them now, starting with `abstract`.'
  prefs: []
  type: TYPE_NORMAL
- en: The abstract keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `abstract` keyword is applied to classes and methods. While `abstract`
    classes will be discussed more fully in [*Chapter 10*](B19793_10.xhtml#_idTextAnchor249),
    we will be discussing them here also (for reasons that will soon become obvious).
    An `abstract` method has no implementation (code). In other words, the method
    signature, rather than following it with curly braces, `{}`, which represents
    the implementation, an `abstract` method signature is simply followed by a semi-colon.
    Marking a method as `abstract` implies the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The class must be `abstract` also
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first concrete (non-`abstract`) subclass must provide an implementation
    for the `abstract` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s discuss this in more detail. When you mark a method (or methods) as `abstract`,
    you are saying that this method has no implementation code. As there is something
    “missing,” the class itself must be marked as `abstract` also. This tells the
    compiler that the class is incomplete and as a result, you cannot instantiate
    (create) an object based on an `abstract` class. In other words, you cannot execute
    `new` on an abstract class (although a reference is perfectly ok). The whole rationale
    for `abstract` methods (and thus `abstract` classes) is for them to be overridden
    by subclasses, where the “missing” implementation code is provided. Now, if the
    direct subclass does not provide the implementation code for the inherited `abstract`
    method, that subclass must also be `abstract`. Therefore, the first non-abstract
    (concrete) subclass of an `abstract` class must provide the implementation code
    for the `abstract` method. *Figure 9**.14* demonstrates these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The “abstract” keyword in action](img/B19793_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The “abstract” keyword in action
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an `abstract` method, namely `write()`, on line 4\.
    Notice how there are no curly braces for the method; we just have the semi-colon
    immediately after the parentheses. As the `Pencil` class (lines 3-5) contains
    an `abstract` method, the class itself must be `abstract`; which it is (line 3).
  prefs: []
  type: TYPE_NORMAL
- en: On line 6, `CharcoalPencil` attempts to subclass `Pencil`. But because (a) it
    does not provide an implementation for the `abstract` method `write()`, which
    it inherited from `Pencil`, and (b) `CharcoalPencil` *itself* is not `abstract`,
    `CharcoalPencil` fails to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast line 6 with line 7\. As we saw, line 6 does not compile. However, line
    7, `WaterColorPencil`, does compile. Why? Because `WaterColorPencil` is `abstract`;
    the fact that it does not provide an implementation for the `abstract` method
    `write()` is no problem.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes do not have to have abstract methods
  prefs: []
  type: TYPE_NORMAL
- en: As we know, if you have 1 (or more) `abstract` methods, then the class must
    be `abstract`. However, the opposite is not true. In other words, an `abstract`
    class does not have to have any `abstract` methods at all! Note that `WaterColorPencil`
    (line 7 in *Figure 9**.14*) is an example of such a class. It is `abstract` and
    yet has no methods at all. This is fine. This could be a design decision whereby,
    even if the class contains only concrete methods, you simply want this class to
    be used as a reference type and not as an object type (as you cannot `new` it).
  prefs: []
  type: TYPE_NORMAL
- en: The `GraphitePencil` class (lines 8-13) is a concrete, non-abstract class. As
    it `extends` the `abstract` class, `Pencil`, it must provide an implementation
    for the `abstract` method `write()`. This is done on lines 10 to 12 and we use
    the `@Override` annotation to emphasize this.
  prefs: []
  type: TYPE_NORMAL
- en: Line 17 demonstrates that you cannot instantiate an object of an `abstract`
    class. The reference part of the `Pencil pp` statement is fine. The issue is with
    the `new` `Pencil()` part.
  prefs: []
  type: TYPE_NORMAL
- en: Line 18 shows what is allowed. Again, we are using a `Pencil` reference but
    this time, we are referring to a `GraphitePencil` object. `GraphitePencil` is
    a concrete class (line 8). Line 19 polymorphically calls the `write()` method
    provided by `GraphitePencil` (lines 10-12). Assuming lines 6 and 17 are commented
    out (so the code will compile), line 19 outputs `GraphitePencil::write()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand `abstract` methods and classes, let’s examine the `final`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The final keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `final` keyword can be applied in various contexts. Inheritance is the main
    focus here, but we will examine other situations also. We will examine each in
    turn and then look at code that demonstrates them. We will start with `final`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: final methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `final` method cannot be overridden in a subclass. This prevents any unwanted
    changes by subclasses. We can take this a stage further with `final` classes.
  prefs: []
  type: TYPE_NORMAL
- en: final classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class that is marked `final` cannot be used as a base type. This means you
    cannot extend from a `final` class. All the methods in the class are implicitly
    `final`. Java uses this in its API to guarantee behavior. For example, the `String`
    class is `final` so that nobody can extend it and provide a custom implementation.
    Therefore, Java always knows how strings behave. Now, we will examine `final`
    method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: final method parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `final` method parameter is a parameter that cannot be changed. However, be
    aware that the semantics are subtly different depending on the parameter type.
    If the parameter type is a primitive, such as `int`, then you cannot change the
    value of the `int` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the parameter in question is a reference (as opposed to a primitive),
    `final` applies to the reference and therefore, it is the reference that cannot
    be changed. In other words, the object the reference is pointing to is modifiable,
    but the reference itself is not. What this means is that, for example, if the
    method accepts a `Dog` reference, namely `dog`, then using the `dog` reference,
    you can change the properties of the object, such as `dog.setAge(10)`. You cannot,
    however, change `dog` to refer to a different object, such as `dog =` `new Dog()`.
  prefs: []
  type: TYPE_NORMAL
- en: final (constants)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A constant is a value that cannot change. It is customary and good practice
    to use capital letters as the identifiers for constants, with each word separated
    by an underscore. This makes them stand out and developers know they cannot change
    them. One example from the Java API is the *PI* constant from the `Math` class
    (in the auto-imported `java.lang` package). It is `final` so that it cannot be
    changed. To provide easy access, *PI* is also `public` and `static`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a code example to re-enforce the use of `final`. *Figure
    9**.15* presents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The “final” keyword in action](img/B19793_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The “final” keyword in action
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a `final` class called `Earth` (line 3). Line 5 demonstrates,
    via a compiler error, that you cannot extend from a `final` class.
  prefs: []
  type: TYPE_NORMAL
- en: Line 8 defines a `final` method called `write()` in the `Pen` class. Consequently,
    the `FountainPen` class encounters a compiler error (line 15) when attempting
    to override `write()`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 11 shows that you cannot annotate a method as both `abstract` and `final`
    – `abstract` implies that this method is to be overridden in a subclass; `final`
    means that this method must not be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Line 18 declares a constant called `ONE_YEAR` and sets it to `1`. Line 27 attempts
    to change the constant value – as this is not allowed, the compiler complains.
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` method (lines 19-28) outlines what `final` means for method parameters.
    The method parameters (line 19) are `final String name` and `final int age`, respectively.
    `String` is a non-primitive type and therefore `name` is a reference. In other
    words, the value inside `name` is a memory location (reference) of where the object
    is on the heap. On the other hand, `age` is simply a primitive `int`, whose value
    is simply a whole number, such as `1`. It is easy to understand what you can and
    cannot do with `final` parameters when you view the *value* as `final`. Thus,
    if `1` is in `age`, it cannot be changed and neither can the reference (address)
    in `name`. However, the object referred to by `name` can be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Line 21 is a compiler error and demonstrates that `final` primitives cannot
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Line 23 shows us that the object that the reference is referring to can be accessed
    (and changed if required). Note that, in this particular example, as `String`s
    are immutable objects, the `toUpperCase()` method returns the new, uppercase `String`,
    as opposed to changing the original. We will talk more about `String`s in [*Chapter
    12*](B19793_12.xhtml#_idTextAnchor293). The important thing to note is that the
    compiler had no issue with line 23.
  prefs: []
  type: TYPE_NORMAL
- en: Line 25 attempts to change the `String` reference `name` to refer to a different
    `String`. As the reference is `final`, the compiler complains. Once again, the
    separation of reference and object makes things much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we know how to create (unlimited) inheritance hierarchies (using
    `extends`). We also know that `final` disables inheritance. What if we wanted
    a “middle ground,” where we could customize our hierarchy to certain types? This
    is what sealed classes enable. Let’s discuss them now.
  prefs: []
  type: TYPE_NORMAL
- en: Applying sealed classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sealed classes were introduced in Java 17\. What we are going to cover here
    relates to classes but the same logic applies to interfaces ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249)).
    With inheritance, you can extend from any class (or interface) using the `extends`
    keyword, unless the class is `final` of course.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces cannot be `final` because their whole rationale is to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario: what if you wanted your class to be available
    for inheritance, but only for certain classes? In other words, you want to scope
    the subclasses allowed. So far, inheritance, using `extends`, enables every class
    to become a subclass, whereas `final` prevents a class from having subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where sealed classes are useful – they enable you to specify what subclasses
    are allowed. Just to reiterate, this also applies to interfaces, where we can
    specify what classes are allowed to implement the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at an example, there are some new keywords that we need to understand.
  prefs: []
  type: TYPE_NORMAL
- en: sealed and permits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These keywords work together. To state that a class is sealed, you can simply
    specify that it is just that, `sealed`. Once you do that, however, you must specify
    which classes can extend from this class. To do that, you use the `permits` keyword,
    followed by the comma-separated list of classes.
  prefs: []
  type: TYPE_NORMAL
- en: non-sealed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you start to scope/restrict a hierarchy, you must use certain keywords
    when specifying the subclasses. A subclass involved in a sealed hierarchy must
    state one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is also sealed. This means, we have further scoping to perform and therefore
    we must use the `sealed`/`permits` pairing on this subclass to specify the subclasses
    allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the `final` class in the hierarchy (no more subclasses allowed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ends the scoping. In effect, you want to open up the hierarchy again for
    extension. To do this, we use the `non-sealed` keyword as `non-sealed` classes
    can be subclassed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example using sealed, permits, and non-sealed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.16* presents a UML diagram for the code example we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – UML diagram for “sealed” classes](img/B19793_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – UML diagram for “sealed” classes
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a `Vehicle` hierarchy. The parts we are going to restrict
    (seal) are the `Vehicle`, `Car`, and `Saloon` classes. Therefore, the only class
    that can subclass `Vehicle` is `Car`; and the only class that can subclass `Car`
    is `Saloon`. Note that even though the diagram implies `Truck` “is-a” `Vehicle`
    and `Convertible` “is-a” `Car`, for this example, we will prevent that in code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the code is to ensure that the only `Vehicle`s we are interested
    in are `Car`s and the only `Car`s we are interested in are `Saloon`s. In addition,
    all `Saloon`s (`Ford` and `Volvo`) are of interest. *Figure 9**.17* presents the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – “sealed” code](img/B19793_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – “sealed” code
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, line 3 states that we have a `sealed` class called
    `Vehicle` and that the only subclass allowed (permitted) is `Car`. At this point,
    the `Car` class must exist; otherwise, the compiler will complain.
  prefs: []
  type: TYPE_NORMAL
- en: Line 4 defines a sealed class called `Car` as a subclass of `Vehicle` (which
    it must do due to line 3) and that the only subclass permitted is `Saloon`. Note
    that when we were defining `Car`, we had to specify that `Car` was either `sealed`,
    `non-sealed`, or `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 5 is the `Truck` class attempting to subclass `Vehicle`. However, as we
    have sealed `Vehicle` to only allow `Car` as a subclass, this generates a compiler
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Line 6 defines `Saloon` as a subclass of `Car` (as expected from line 4). In
    this instance, we have chosen to open up the hierarchy for further extension (by
    any class) by stating that `Saloon` is `non-sealed`. Lines 7 and 8 demonstrate
    that `Saloon` is a non-sealed class by allowing `Volvo` and `Ford` to extend from
    it, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, on line 9, `Convertible` attempts to subclass `Car`. This is not allowed
    as line 4 states that the only subclass of `Car` allowed is `Saloon`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on now and discuss both instance and `static` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding instance and static blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, in Java, a block is delimited by curly braces, `{}`, and these code
    blocks are no different. What is different about instance and `static` code blocks
    is *where* these blocks appear – in other words, their scope. Both of these code
    blocks appear outside every method but inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss each in turn and then present a code example to demonstrate
    them in operation. We will start with instance blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Instance blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance block is a set of braces that appear outside of any method but inside
    the class. Assuming an instance block is present in a class, every time an object
    is created (using `new`), the instance block is executed. Note that the instance
    block executes *before* the constructor. To be technically accurate, `super()`
    is executed first so that the parent constructor has a chance to execute; this
    is followed by the instance block, after which the rest of the constructor executes.
    Use the “sic” (*s*uper, *i*nstance block, *c*onstructor) acronym to help remember
    the order. You can think of the compiler inserting the instance block into the
    constructor code just after the call to `super()`. If more than one instance block
    exists in a class, they are executed in order of appearance, from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: As instance blocks execute as part of every constructor, they are an ideal location
    for inserting code that you want every constructor to have. In other words, code
    that is common across all constructors should go into an instance block. This
    saves you from duplicating code across constructors.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the parent constructor must execute before the child constructor.
    The same occurs with instance blocks. In other words, the parent instance blocks
    must execute before the child instance blocks. We will see this in the code example.
  prefs: []
  type: TYPE_NORMAL
- en: static blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `static` block is a set of braces, preceded by the `static` keyword, that
    appears outside of any method but inside the class. The `static` block is only
    executed once, the very first time the class is loaded. This could occur when
    the first object of the class is created or the first time a `static` member is
    accessed. Static blocks execute before instance blocks (as we have to load the
    class file/bytecode before we can execute a constructor). Once executed, given
    that the class file is now loaded into memory, the `static` block is never executed
    again.
  prefs: []
  type: TYPE_NORMAL
- en: As with instance blocks, if more than one `static` block exists in a class,
    they are executed in order of appearance, from top to bottom. Similarly, as with
    instance blocks, if inheritance is involved, then the parent `static` blocks execute
    before the child `static` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: This will all make a lot more sense with a code example, where we will be able
    to compare and contrast both types of code blocks in an inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.18* presents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Instance and “static” code blocks example](img/B19793_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Instance and “static” code blocks example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a parent class called `Parent` and a child class called
    `Child` (it took a while to come up with those names!). Both classes have two
    instance initialization blocks, two `static` initialization blocks, and a constructor.
    Notice that the `static` initialization blocks (lines 7, 12, 16, and 21) are all
    simply blocks of code preceded by the `static` keyword. Also, note their location/scope
    – outside the methods but inside the class. The same is true for the instance
    initialization blocks (lines 5, 11, 15, and 20), except that the instance blocks
    have no keyword preceding them.
  prefs: []
  type: TYPE_NORMAL
- en: The main driver class, `InitializationBlocks`, also has one `static` and one
    instance initialization block (lines 24 and 25, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these blocks simply outputs a tracer message so that we know which
    block of code is currently executing. The tracer messages are annotated with ascending
    numbers so we can follow the order of execution more easily. *Figure 9**.19*,
    presents the output from the code in *Figure 9**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Output from the code in Figure 9.18](img/B19793_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Output from the code in Figure 9.18
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To avoid confusion between numbers representing output in *Figure 9**.19* with
    line numbers in *Figure 9**.18*, all numbers mentioned here refer to output numbers
    in *Figure 9**.19*. Any line numbers relating to *Figure 9**.18* will be explicitly
    annotated as “line....”
  prefs: []
  type: TYPE_NORMAL
- en: All Java programs start with the `main()` method. Therefore, the JVM has to
    find, using the `CLASSPATH` environment variable, the `.class` file containing
    `main()`, namely `InitializationBlocks.class`. As the JVM loads the class, if
    the class has a parent, it loads the parent first. In this example, as `InitializationBlocks`
    is not a subclass, this does not apply. However, there is a `static` block and
    this gives us our first line of output. Note that the instance block for `InitializationBlocks`
    is never executed. This is because no instance of `InitializationBlocks` was ever
    created. In other words, there is no `new` `InitializationBlocks()` in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Line 27 simply outputs `"---> Creating first Child object…"`. What is interesting
    to note is that it is not the first line output to the screen – the output from
    the `static` block is first.
  prefs: []
  type: TYPE_NORMAL
- en: Line 28 creates a `Child` object. Its output is represented by numbers 2-11\.
    As this is the first time a `Child` object has been created (as no `static` member
    in `Child` has been accessed before this), the class file for `Child` is loaded.
    During this process, the JVM realizes that `Child` is a subclass of `Parent`,
    so it loads the `Parent` class first. Therefore, the `static` blocks in `Parent`
    are executed first, in order of appearance (2 and 3); followed by the `Child`
    static blocks, also in order of appearance (4 and 5).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `static` blocks are done, the instance blocks and constructors
    are executed. First, the superclass `Parent` instance blocks are executed in order
    of appearance (6 and 7), followed by the `Parent` constructor (8). Then, the subclass
    `Child` instance blocks are executed in order of appearance (9 and 10), followed
    by the `Child` constructor (11). That is a lot of processing from a simple `new
    Child()` line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Line 29 simply outputs `"---> Creating second` `Child object…"`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 30 creates another `Child` object. As the class was already loaded previously,
    the `static` blocks will already have run for both `Child` and its superclass,
    `Parent`. Therefore, they do not run again. So, we run the `Parent` instance blocks
    (6 and 7), followed by the `Parent` constructor (8). Then, we run the `Child`
    instance blocks (9 and 10), followed by the `Child` constructor (11).
  prefs: []
  type: TYPE_NORMAL
- en: Note the repetition of line numbers 6-11 when creating a `Child` object. The
    `Parent` instance blocks are executed in order; followed by the `Parent` constructor.
    The `Child` instance blocks and constructor follow in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'That covers `static` and instance initialization blocks. Before we conclude
    this chapter on inheritance, we would just like to delve a little deeper into
    one of the topics we touched on earlier: upcasting and downcasting.'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering upcasting and downcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we touched upon why we get `ClassCastException` errors. The rule is
    that a reference can refer to objects of its own type or objects of subclasses.
    In effect, a reference can point across and down the inheritance hierarchy, but
    never up. If a reference does point up the hierarchy, you will get a `ClassCastException`
    error. Recall that the reason this occurs is that the subclass reference could
    have extra methods that any superclass object would have no code for. Whether
    that is the case or not is immaterial, *could have* is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that assignment works from right to left; so, when reading code
    involving upcasting/downcasting, the direction in the hierarchy is from right
    to left as well. In addition, remember that the compiler is always looking at
    the reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss, with the aid of code examples, both upcasting and downcasting.
    Let’s start with upcasting.
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With upcasting, you are going from a more specific type “up to” a more general
    type. For example, let’s look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are going from `Car` *up* to `Vehicle`. The more specific type (`Car`)
    is further down the hierarchy and potentially has extra methods. Due to inheritance,
    whatever methods the parent reference has access to, the subclass will also have.
    So, any methods available to the `Vehicle` reference, `vc`, will exist in the
    `Car` object! Therefore, upcasting is never an issue, and an explicit cast is
    not required.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.20* presents upcasting in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Upcasting in action](img/B19793_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Upcasting in action
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a class called `Machine` (lines 3-5) and a subclass
    called `Tractor` (lines 6-9). The `on()` method in `Tractor` (line 7) overrides
    the `on()` method in `Machine` (line 4).
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 involves an implicit upcast. Reading it right to left (as assignment
    is right to left), we are going from `Tractor` “up to” `Machine`. This is possible
    because every `Tractor` “is-a” `Machine`. Thus, line 15 results in a `Machine`
    reference referring to a `Tractor` object.
  prefs: []
  type: TYPE_NORMAL
- en: Line 16 invokes the `doAction()` method while passing in the reference created
    on line 15, namely `mt`. This `mt` reference is copied (remember Java is call
    by value) into the `Machine` reference, namely `machine`, on line 11\. Thus, the
    `mt` reference in the `main()` method and the `machine` reference in the `doAction()`
    method are pointing at the one and same object, which was created on line 15.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `doAction()` method, we invoke the `on()` method using the `machine`
    reference (line 12). As the `machine` references type, namely `Machine`, has an
    `on()` method, the compiler is happy. At runtime, the object that `machine` is
    referring to, namely `Tractor`, is used. In other words, the `on()` method from
    `Tractor` is dynamically executed (polymorphically).
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 17 is just accomplishing in one line what was coded over lines 15 and
    16\. With the invocation of `doAction()` on line 17, the upcasting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Machine` reference, namely `machine`, is provided by the `doAction()` signature
    (line 11), and the `Tractor` instance creation comes from line 17.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both lines 16 and 17 result in the same output: `Tractor::on()`. Now, let’s
    discuss the trickier of the two: downcasting.'
  prefs: []
  type: TYPE_NORMAL
- en: Downcasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With downcasting, you are going from a more general type “down to” a more specific
    type. For example, let’s look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reading it from right to left, we are going from `Vehicle` *down* to `Car`.
    Again, the more specific type (`Car`) is further down the hierarchy and potentially
    has extra methods. The compiler spots this and complains. We can overrule the
    compiler by inserting a (down)cast, `(Car)`. This is what we have done here. However,
    at runtime, this line of code results in a `ClassCastException` error. This is
    because, on the right-hand side of the assignment statement, we are attempting
    to create a `Car` reference that will point up the inheritance tree at a `Vehicle`
    object!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.21* presents downcasting in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Downcasting in action](img/B19793_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Downcasting in action
  prefs: []
  type: TYPE_NORMAL
- en: The code in this figure is very similar to the code in *Figure 9**.20*. The
    inheritance hierarchy is the same. The changes are in the `doAction()` and `main()`
    methods. Line 12 works normally and we have commented it out to focus on downcasting.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal, as stated on line 14, is to *safely* invoke the `Tractor` object’s
    `drive()` method. Note that this method is specific to `Tractor`. Let’s look at
    the changes in baby steps.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, as `drive()` is specific to `Tractor` (and not `Machine`), this means
    that we need a `Tractor` reference to get the code to compile. The fact that line
    15 does not compile demonstrates this – the `machine` reference is of the `Machine`
    type and `Machine` does not have a `drive()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Line 16 addresses the compiler error from line 15\. Line 16 compiles because
    it (down)casts the machine reference to a `Tractor` reference *before* it calls
    the `drive()` method. That is why the extra set of parentheses are needed – method
    invocation has higher precedence than casting, so we change the order of precedence
    by using parentheses. Without the extra set of parentheses, we have `(Tractor)machine.drive()`,
    and this does not compile (for the same reason as line 15 does not compile). However,
    the extra set of parentheses forces the cast from `Machine` to `Tractor` to be
    performed first, and thus the compiler looks for `drive()` in `Tractor`.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are still not “out of the woods.” Yes, the compiler is happy, but
    the JVM is vulnerable to `ClassCastException` errors at runtime. If line 16 were
    uncommented, then line 22 would cause a `ClassCastException` error at runtime.
    This is because line 22 passes in a `Machine` object, so inside the `doAction()`
    method, the `machine` reference is referring to a `Machine` object. Therefore,
    on line 16, we would be trying to create a `Tractor` reference to point *up* to
    the `Machine` object, which is a `ClassCastException` all day long.
  prefs: []
  type: TYPE_NORMAL
- en: Line 17 uses the `instanceof` keyword, in conjunction with a type pattern and
    pattern matching. Line 17 is only true if the reference `machine` refers to a
    `Tractor` object; when it is, the cast is done for us in the background and `t`
    is initialized to refer to the `Tractor` object. This is why line 22 outputs nothing
    – the `Machine` object passed in, fails the `instanceof` test and therefore line
    18 is *not* executed. However, as line 23 passes in a `Tractor` object, it passes
    the `instanceof` test. This means that line 18 is executed and outputs `Tractor::drive()`.
  prefs: []
  type: TYPE_NORMAL
- en: That completes another hugely important chapter. Now, let’s apply what we have
    learned!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our park is full of diversity, not just in the species of dinosaurs but also
    in the roles of our employees. To model this diversity, we will be incorporating
    the concept of inheritance into our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all dinosaurs are the same. Some are small, others big. Some are herbivores,
    others carnivores. Create at least three subclasses for different types of dinosaurs
    that inherit from the base `Dinosaur` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you need inspiration, you can create a `FlyingDinosaur` subclass and an `AquaticDinosaur`
    subclass from the `Dinosaur` class, each with its unique properties. (This is
    not the most optimal way to model this, but don’t worry about that now.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just like our dinosaurs, our employees also have diverse roles. Some are park
    managers, while others are security officers or veterinarians. Create subclasses
    for these employee roles that inherit from the `Employee` base class. Come up
    with at least three subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance doesn’t just stop at properties and methods. Even the behavior of
    some methods can be customized in subclasses. Provide a custom implementation
    of the `toString()` method in the `Dinosaur` and `Employee` classes (from exercises
    1 and 2) and their subclasses to display detailed information about each object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, override the `equals()` method in the `Dinosaur` and `Employee` classes
    to compare objects of these classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class called `App` with a `main` method. In there, add functionality
    to check if an employee is qualified to work in a specific enclosure, considering
    the employee’s role and the enclosure’s safety level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The park offers regular tickets and season tickets. Create a `SeasonTicket`
    class that extends the `Ticket` class and add properties such as start date and
    end date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will be developing a more advanced version of the Mesozoic Eden park manager
    console application. Your task is to implement the concept of polymorphism to
    handle different types of dinosaurs and employees. By incorporating polymorphism,
    the application can accommodate an even wider range of dinosaur species and employee
    roles. The key features of the system should now include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to manage diverse types of dinosaur profiles, representing a variety
    of species
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to manage different types of park employee profiles that represent
    a variety of roles, such as park rangers, janitors, veterinarians, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All previous features, such as editing and removing profiles, real-time dinosaur
    tracking, employee scheduling, guest admissions, and handling special events,
    should now accommodate these new varieties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s what you need to do, broken down into smaller steps if you need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` classes into different subclasses to represent different
    types of dinosaurs and employee roles. Make sure these subclasses demonstrate
    the principle of polymorphism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` objects, where each object could be an instance of
    any subclass.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Update the interaction**: Modify your interactive console-based interface
    to handle the new types of dinosaurs and employees. You might need to add more
    options or submenus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enhance menu creation**: Your menu should now handle different types of dinosaurs
    and employees. Make sure each option corresponds to a particular function in the
    program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handle actions**: Each menu item should trigger a function that is now able
    to handle different types of dinosaurs and employees. For example, the “Manage
    Dinosaurs” option could now trigger a function to add, remove, or edit a profile
    of any dinosaur species.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exit the program**: Ensure your program continues to provide an option for
    the user to exit the program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The starting code snippet will remain mostly the same as the previous one.
    However, when implementing `manageDinosaurs()`, `manageEmployees()`, and other
    similar functions, you’ll need to handle different types of dinosaurs and employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `manageDinosaurs()`, `manageEmployees()`, `manageTickets()`, `checkParkStatus()`,
    and `handleSpecialEvents()` methods now need to be updated to be able to handle
    the increased complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined one of the cornerstones of OOP, namely inheritance.
    Inheritance defines an “is-a” relationship between the sub- and parent classes
    – for example, `Fox` “is-a” `Animal`, and `Train` “is-a” `Vehicle`. Inheritance
    promotes code reuse as inheritable base class members are automatically available
    to subclasses. Class inheritance is enabled via the `extends` keyword and interface
    inheritance is enabled via the `implements` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding methods, the subclasses are free to override (replace) the base class
    implementation. This is how we enable another cornerstone of OOP, namely polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is a feature where the instance method from the object is only
    selected at runtime. Hence, other terms for polymorphism are “late binding,” “runtime
    binding,” and “dynamic binding,” For polymorphism to work, the signature of the
    instance method in the subtype must match that of the parent method. The only
    caveat to that rule is covariant returns, where, in the overriding method, a subtype
    of the parent return type is allowed. The overriding method, when comparing it
    with its parent version, must not reduce the access privileges or add extra checked
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading, on the other hand, is where the method signatures must be
    different (apart from the matching method name). Thus, the number of parameters,
    their types and/or their order, must be different. The return type and parameter
    names do not matter (as they are not part of the method signature). Method overloading
    can occur at any level in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: With inheritance, the reference type and object types are often different. As
    assignment works right to left, when we discuss upcasting and downcasting, we
    refer to going “up” or “down” the inheritance tree. Upcasting is always safe as
    the subtype will always have the methods accessible via the supertype reference.
    Downcasting, however, is not safe and requires a cast for the compiler to be happy.
    Even at that, if you end up creating a reference that is pointing up the hierarchy
    tree, you will get a `ClassCastException` error at runtime. Pointing up the hierarchy
    is not allowed because the subclass reference type could have methods that the
    parent type object has no code for.
  prefs: []
  type: TYPE_NORMAL
- en: The `super` keyword is used in two situations. The first is to access the parent
    constructor using `super()`. This call is only allowed as the very first line
    in any constructor. If not coded explicitly, `super()` will be inserted by the
    compiler to ensure that the parent constructor executes before the subtype constructor.
    Construction occurs from the base down because a subtype may rely on parent members
    and thus, the parent must have a chance to initialize them first. The second scenario
    is accessing a parent member from subtype code, using `super.parentMember`.
  prefs: []
  type: TYPE_NORMAL
- en: We already know from [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), that the
    `protected` access modifier ensures members are available within the package and
    also to any subclasses, regardless of the package. We revisited this and demonstrated
    that, when accessing a `protected` member from a subclass in a different package,
    you have to do so, via inheritance, in a very specific way.
  prefs: []
  type: TYPE_NORMAL
- en: An `abstract` method is a method with no code (implementation). Even though
    a class does not need to have any `abstract` methods to be `abstract` itself;
    once the class has even one `abstract` method, the class must be `abstract`. Any
    subclass of an `abstract` class must provide the implementation code for the `abstract`
    method(s) inherited, or the subclass must also be `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning inheritance, a `final` class cannot be inherited from. A `final`
    method cannot be overridden. Other uses for `final` are for defining constants
    and ensuring that (the values of) method parameters are constant.
  prefs: []
  type: TYPE_NORMAL
- en: The use of sealed classes enables us to restrict parts of a hierarchy to certain
    types. Rather than the general `extends`, which allows a class to subclass any
    base class it wants; and without turning off inheritance altogether using `final`;
    sealed classes achieve a custom restriction using the `sealed`, `non-sealed`,
    and `permits` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Instance and `static` initialization blocks are coded outside the methods but
    inside the class. The `static` block precedes the block with the `static` keyword.
    The instance uses no keyword (instance semantics are implied). Both enable initialization
    at various points. Static initialization occurs just once – the first time a class
    is loaded. Instance initialization occurs every time a constructor is called.
    Consequently, instance blocks are perfect locations for inserting code that is
    common across all constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we took a deeper dive into upcasting and downcasting. This helped deepen
    our understanding as to why upcasting is not an issue, why downcasting needs a
    cast, and why we get `ClassCastException` errors. In addition, using the `instanceof`
    operator ensures that we prevent `ClassCastException` errors from occurring.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on inheritance – this was a big chapter! We will
    now move on to interfaces and `abstract` classes.
  prefs: []
  type: TYPE_NORMAL
