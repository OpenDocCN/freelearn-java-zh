- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Inheritance and Polymorphism
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和多态
- en: 'In [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), we learned about classes,
    objects, and enums. Initially, we explored the relationship between classes and
    objects and the need to separate the reference type from the object type. We contrasted
    instance versus class members and saw that using the `static` keyword applies
    class scope to a member. We discussed the `this` reference and demonstrated that
    inside an instance method, the `this` reference refers to the object instance
    responsible for the method call. We also covered various access modifiers: `private`,
    package-private (no keyword), `protected`, and `public`. These modifiers enable
    us to apply one of the cornerstones of OOP, namely encapsulation. While encapsulation
    is commonly referred to as “private data, public methods,” we demonstrated that
    this does not go far enough due to Java’s call by value mechanism when passing
    references into and out of methods. We showed how a technique called “defensive
    copying” can be used to apply proper (advanced) encapsulation. To improve our
    understanding of what is happening in the background, we detailed the object life
    cycle and gently touched on garbage collection. We also covered the `instanceof`
    keyword, which is used to determine the object type a reference is referring to.
    We covered a variation of a class, namely **enumerations** (**enums**). Enums
    enable us to limit the number of instances created, thereby facilitating type
    safety. We covered both simple and complex enums. Lastly, we covered another class
    variation, namely records, which saves us from typing a lot of boilerplate code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B19793_08.xhtml#_idTextAnchor168)中，我们学习了类、对象和枚举。最初，我们探讨了类与对象之间的关系以及将引用类型与对象类型分开的需要。我们对比了实例成员与类成员，并看到使用`static`关键字将类作用域应用于成员。我们讨论了`this`引用，并演示了在实例方法内部，`this`引用指向负责方法调用的对象实例。我们还涵盖了各种访问修饰符：`private`、包私有（无关键字）、`protected`和`public`。这些修饰符使我们能够应用面向对象编程的基石之一，即封装。虽然封装通常被称为“私有数据，公有方法”，但我们演示了这还不够，因为Java在将引用传递进方法和从方法返回时采用值传递机制。我们展示了如何使用称为“防御性复制”的技术来应用适当的（高级）封装。为了提高我们对后台发生的事情的理解，我们详细介绍了对象生命周期，并简要提到了垃圾回收。我们还涵盖了`instanceof`关键字，它用于确定引用所引用的对象类型。我们涵盖了类的变体，即**枚举**（**枚举**）。枚举使我们能够限制实例的数量，从而促进类型安全。我们涵盖了简单和复杂的枚举。最后，我们涵盖了另一种类变体，即记录，它可以节省我们编写大量样板代码。
- en: In this chapter, we will explore inheritance, another core principle of OOP.
    Initially, we will outline the benefits of inheritance and the Java keywords to
    use. This leads to polymorphism, another core pillar of OOP. We will explain polymorphism
    and, with the aid of examples, how polymorphism is achieved. As polymorphism requires
    “method overriding,” we will explain how to use `instanceof`, to ensure type safety
    when downcasting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨继承，这是面向对象编程的另一个核心原则。最初，我们将概述继承的好处以及要使用的Java关键字。这导致多态，这是面向对象编程的另一个核心支柱。我们将解释多态，并通过示例说明如何实现多态。由于多态需要“方法重写”，我们将解释如何使用`instanceof`，以确保向下转型时的类型安全。
- en: We will also contrast method overriding with method overloading. We will explain
    the `super` keyword and how it is used. As promised in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168),
    we will revisit `protected`, the most misunderstood of Java’s access modifiers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将对比方法重写与方法重载。我们将解释`super`关键字及其用法。正如在[*第8章*](B19793_08.xhtml#_idTextAnchor168)中所承诺的，我们将重新探讨`protected`，这是Java访问修饰符中最容易被误解的一个。
- en: After that, we will discuss both the `abstract` and `final` keywords and their
    place in inheritance. We will also show how `sealed` classes enable us to scope
    inheritance. In addition, we will cover both `static` and instance blocks in an
    inheritance hierarchy. Lastly, we will discuss upcasting and downcasting the inheritance
    tree, and how a simple rule-of-thumb helps prevent `ClassCastException` errors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将讨论`abstract`和`final`关键字及其在继承中的作用。我们还将展示如何使用`sealed`类来限制继承的范围。此外，我们还将涵盖继承层次结构中的`static`和实例块。最后，我们将讨论向上转型和向下转型继承树，以及一个简单的经验法则如何帮助防止`ClassCastException`错误。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Understanding inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解继承
- en: Applying inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用继承
- en: Exploring polymorphism
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索多态
- en: Contrasting method overriding and method overloading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对比方法重写与方法重载
- en: Exploring the `super` keyword
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`super`关键字
- en: Revisiting the `protected` access modifier
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新探讨`protected`访问修饰符
- en: Explaining the `abstract` and `final` keywords
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`abstract`和`final`关键字
- en: Applying `sealed` classes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用`sealed`类
- en: Understanding instance and `static` blocks
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解实例和`static`块
- en: Mastering upcasting and downcasting
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握向上转型和向下转型
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9)。
- en: Understanding inheritance
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承
- en: 'There are three core pillars in Java: polymorphism, inheritance, and encapsulation
    (data hiding). It is easy to remember them using the acronym “PIE” (*P*olymorphism,
    *I*nheritance, and *E*ncapsulation). Let us now examine inheritance.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java有三个核心支柱：多态性、继承和封装（数据隐藏）。使用缩写“PIE”(*P*olymorphism, *I*nheritance, 和 *E*ncapsulation)来记忆它们很容易。现在让我们来考察继承。
- en: Inheritance is a code reusability mechanism where common properties between
    related types are exploited by forming relationships between those types. Inheritance
    relationships in Java are created by extending from a class or by implementing
    an interface. We will cover interfaces in [*Chapter 10*](B19793_10.xhtml#_idTextAnchor249),
    so for the moment, we will assume classes throughout. To understand why inheritance
    in OOP is important, we will examine its advantages (and disadvantages). As we
    have not covered the terminology used yet, this discussion will be somewhat abstract.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种代码重用机制，通过在相关类型之间形成关系来利用它们之间的共同属性。Java中的继承关系是通过从一个类扩展或通过实现一个接口来创建的。我们将在[*第10章*](B19793_10.xhtml#_idTextAnchor249)中介绍接口，所以现在我们将假设类。为了理解为什么面向对象的继承很重要，我们将检查其优点（和缺点）。由于我们尚未介绍所使用的术语，这次讨论将有些抽象。
- en: Advantages of inheritance
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的优点
- en: One principle advantage of inheritance is code reuse. A new class can be written
    based on an existing class rather than writing the new class from scratch. In
    other words, the new class can inherit code that has been already written (and
    tested). This is called *code reuse* and reduces redundancy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的一个主要优点是代码重用。可以基于现有类编写新类，而不是从头开始编写新类。换句话说，新类可以继承已经编写（并测试）的代码。这被称为*代码重用*，减少了冗余。
- en: Inheritance naturally promotes polymorphism, which we discuss later. This feature
    gives your code flexibility. For example, you could have a method that deals with
    an `Animal` reference but at runtime, the code executed is in the `Dog` type (or
    `Cat` or any other type of `Animal` in the hierarchy). In effect, one method works
    with all `Animal` types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自然地促进了多态性，我们稍后讨论。这个特性给你的代码带来了灵活性。例如，你可以有一个处理`Animal`引用的方法，但在运行时，执行的代码是在`Dog`类型（或`Cat`或任何其他`Animal`类型的层次结构中的类型）。实际上，一个方法可以与所有`Animal`类型一起工作。
- en: Inheritance organizes code into a hierarchy. This can improve productivity and
    simplify the maintenance of code as changes made to inherited code are immediately
    reflected throughout the hierarchy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 继承将代码组织成层次结构。这可以提高生产力并简化代码的维护，因为对继承代码所做的更改会立即在整个层次结构中反映出来。
- en: Disadvantages of inheritance
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的缺点
- en: Despite its advantages, inheritance does have its disadvantages. Tight coupling
    between the base (source) type and the derived (target) type is one such drawback.
    Any changes made to the base type affect all the derived types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有优点，继承确实有其缺点。基类型（源类型）和派生类型（目标类型）之间的紧密耦合是一个缺点。对基类型所做的任何更改都会影响所有派生类型。
- en: Code bloat is another disadvantage. Changes may be made to the base type that
    many derived types do not need and this can result in an unnecessarily large code
    base.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码膨胀是另一个缺点。可能对基类型进行更改，而许多派生类型并不需要这些更改，这可能导致代码库不必要地庞大。
- en: Now that we have an appreciation of inheritance and why it is used, let’s discuss
    the nomenclature (terms) used when discussing inheritance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对继承及其用途有了认识，让我们讨论在讨论继承时使用的术语（名词）。
- en: Base class
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基类
- en: The “base” class is also known as the “super” or “parent” class. This is where
    the inherited members are defined. As a class is a type, the term *type* is often
    used interchangeably for class. Note that in Java, the *Object* class is at the
    top of every hierarchy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “基”类也被称为“超”类或“父”类。这是定义继承成员的地方。由于类是一种类型，因此术语*类型*通常可以与类互换使用。请注意，在Java中，*Object*类是每个层次结构的顶层。
- en: Subclass
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派生类
- en: The subclass is also known as the “child” or “derived” class. So, the subclass
    inherits functionality (and/or data) from the base class. Again, as a class is
    a type, the term *subtype* is often used interchangeably for subclass. A class
    can be both a base class and a subclass. Java ensures that *Object* is at the
    top of every (inheritance) hierarchy. Thus, every class we write is implicitly
    a subtype already (even if you do not say so).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 子类也被称为“子”或“派生”类。因此，子类从基类继承功能（和/或数据）。再次强调，由于类是一种类型，因此术语 *子类型* 常与子类互换使用。一个类可以既是基类也是子类。Java
    确保每个（继承）层次结构的顶部都是 *Object*。因此，我们编写的每个类都是隐式子类型（即使你没有这么说）。
- en: The “is-a” relationship
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “是”关系
- en: 'Inheritance generates what is called an *“is-a”* relationship. *Figure 9**.1*
    will help us explain this. We will expand on this diagram as this chapter progresses:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 继承生成所谓的 *“是”* 关系。*图 9.1* 将帮助我们解释这一点。随着本章的进展，我们将扩展这个图：
- en: '![Figure 9.1 – UML diagram for the Vehicle hierarchy](img/B19793_09_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 车辆层次结构的 UML 图](img/B19793_09_1.jpg)'
- en: Figure 9.1 – UML diagram for the Vehicle hierarchy
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 车辆层次结构的 UML 图
- en: Unified Modeling Language (UML)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 统一建模语言 (UML)
- en: 'UML is a modeling language used in software design availing of the maxim that
    “a picture speaks a thousand words.” UML makes understanding topics such as inheritance
    very straightforward, so we will present a very brief overview of UML here. Further
    detail is available here: [https://en.wikipedia.org/wiki/Unified_Modeling_Language](https://en.wikipedia.org/wiki/Unified_Modeling_Language).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: UML 是一种在软件设计中使用的建模语言，它利用了“一图胜千言”的原则。UML 使得理解诸如继承等主题变得非常直接，因此在这里我们将简要介绍 UML。更多详细信息请参阅：[https://en.wikipedia.org/wiki/Unified_Modeling_Language](https://en.wikipedia.org/wiki/Unified_Modeling_Language)。
- en: 'With *Figure 9**.1* in mind, here is an overview of the symbols used:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 *图 9.1* 的基础上，以下是所使用的符号概述：
- en: '*Package name*: The package name is at the top left (`ch9`)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包名*：包名位于左上角 (`ch9`)'
- en: '*Classes*: Classes are in boxes with three sections – the top box is the class
    name; the middle box is for the instance/class variables; the bottom box is for
    the methods'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类*：类在有三个部分的框中，顶部框是类名；中间框用于实例/类变量；底部框用于方法'
- en: '*Access modifiers*: `public` (+), `private` (-), package-private (~), and `protected`
    (#)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问修饰符*：`public` (+), `private` (-), 包私有 (~), 和 `protected` (#)'
- en: '*Static*: The underline is used to signify that a member is `static`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态*：下划线用于表示成员是 `static`'
- en: '*Method return type*: The last part of the method signature in UML'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法返回类型*：UML 中方法签名中的最后一部分'
- en: '*Class inheritance*: An arrow with a solid line; for example, `Car` inherits
    from `Vehicle`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类继承*：带有实线的箭头；例如，`Car` 从 `Vehicle` 继承'
- en: '*Interfaces*: These are shown in boxes with dashed lines ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249))'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接口*：这些在带有虚线的框中表示 ([*第 10 章*](B19793_10.xhtml#_idTextAnchor249))'
- en: '*Interface inheritance*: An arrow with a dashed line ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249))'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接口继承*：带有虚线的箭头 ([*第 10 章*](B19793_10.xhtml#_idTextAnchor249))'
- en: '*Association*: A solid line; for example, `TestVehicle` is associated with
    `Vehicle` for the simple reason that we will be creating objects based on the
    `Vehicle` hierarchy in `main()`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关联*：一条实线；例如，`TestVehicle` 与 `Vehicle` 相关联的简单原因是我们将在 `main()` 函数中基于 `Vehicle`
    层次创建对象。'
- en: 'As shown in *Figure 9**.1*, we have a package, namely `ch9`. There are five
    classes in the `Vehicle` hierarchy: `Vehicle`, `Car`, `Saloon`, `Convertible`,
    and `Boat`. In this hierarchy, from a base class viewpoint, `Vehicle` is the base
    class for `Car` and `Boat`; and `Car` is the base class for `Saloon` and `Convertible`.
    Interpreting the diagram from the sub-class perspective, `Car` and `Boat` are
    sub-classes of `Vehicle`, whereas `Saloon` and `Convertible` are sub-classes of
    `Car`. Regardless of which perspective you use, every `Car` “is-a” `Vehicle`,
    and every `Boat` “is-a” `Vehicle` too. In addition, every `Saloon` “is-a” `Car`,
    and every `Convertible` “is-a” `Car`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 9.1* 所示，我们有一个包，即 `ch9`。在 `Vehicle` 层次结构中有五个类：`Vehicle`、`Car`、`Saloon`、`Convertible`
    和 `Boat`。在这个层次结构中，从基类角度来看，`Vehicle` 是 `Car` 和 `Boat` 的基类；而 `Car` 是 `Saloon` 和
    `Convertible` 的基类。从子类角度来看，`Car` 和 `Boat` 是 `Vehicle` 的子类，而 `Saloon` 和 `Convertible`
    是 `Car` 的子类。无论使用哪种视角，每个 `Car` 都是 `Vehicle` 的“是”，每个 `Boat` 也是 `Vehicle` 的“是”。此外，每个
    `Saloon` 是 `Car` 的“是”，每个 `Convertible` 也是 `Car` 的“是”。
- en: It also follows that because `Saloon` “is-a” `Car` and `Car` “is-a” `Vehicle`,
    `Saloon` “is-a” `Vehicle` as well. The same applies to `Convertible`; in other
    words, `Convertible` “is-a” `Car`, `Car` “is-a” `Vehicle`; therefore, `Convertible`
    “is-a” `Vehicle` also.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，因为“Saloon”是“Car”的一种，而“Car”又是“Vehicle”的一种，所以“Saloon”也是“Vehicle”的一种。同样的情况也适用于“Convertible”；换句话说，“Convertible”是“Car”的一种，“Car”是“Vehicle”的一种；因此，“Convertible”也是“Vehicle”的一种。
- en: However, the “is-a” relationship works in one direction only (reading the diagram
    from the bottom up). For example, while *every* `Car` “is-a” `Vehicle`, *not*
    every `Vehicle` “is-a” `Car`; some are `Boat`s. There is a very good reason for
    this, which we will explore further when we discuss upcasting and downcasting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“是一个”的关系只在一个方向上起作用（从底部向上读取图）。例如，虽然*每个*`Car`都是“Vehicle”的一种，但*不是*每个`Vehicle`都是“Car”的一种；有些是“Boat”。这有一个非常好的原因，我们将在讨论向上转型和向下转型时进一步探讨。
- en: There is one method in `Vehicle`, namely `toString()`, which, because it is
    `public`, is inherited by all the subtypes; namely, `Car`, `Saloon`, `Convertible`,
    and `Boat`. Thus, the version of `toString()` in `Vehicle` is available throughout
    the whole hierarchy. Lastly, the other class, `TestVehicle` contains the `main()`
    method so that we can test the hierarchy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Vehicle`类中有一个方法，即`toString()`，因为它被声明为`public`，所以被所有子类型继承；也就是说，`Car`、`Saloon`、`Convertible`和`Boat`。因此，`Vehicle`中的`toString()`版本在整个层次结构中都是可用的。最后，其他类`TestVehicle`包含`main()`方法，这样我们就可以测试这个层次结构。
- en: Now that we understand the concept of inheritance, let’s apply it in code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了继承的概念，让我们在代码中应用它。
- en: Applying inheritance
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用继承
- en: 'As we learned in the previous section, inheritance creates an “is-a” relationship
    hierarchy. This enables base class functionality to be inherited and therefore
    available to subclasses, without any extra coding. Java uses two keywords in applying
    inheritance: `extends` and `implements`. Let’s discuss them now.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节所学，继承创建了一个“是一个”的关系层次结构。这使得基类的功能可以被继承，因此对子类可用，而无需额外的编码。Java在应用继承时使用两个关键字：`extends`和`implements`。现在让我们来讨论它们。
- en: extends
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: extends
- en: This is the principle keyword that’s used and relates to both classes and interfaces.
    Regarding classes, we state that `class Sub extends Base {}`. In this case, all
    of the non-`private` members from the `Base` class will be inherited into the
    `Sub` class. Note that `private` members and constructors are not inherited –
    this makes sense as both `private` members and constructors are class-specific.
    In addition, Java prohibits multiple class inheritance. This means that you cannot
    extend from more than one class at a time. Regarding interfaces, we state that
    `interface ChildInt extends` `ParentInt {}`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于类和接口的原理关键字。关于类，我们声明`class Sub extends Base {}`。在这种情况下，`Base`类中所有非`private`成员都将被继承到`Sub`类中。请注意，`private`成员和构造函数不会被继承——这是有道理的，因为`private`成员和构造函数都是类特定的。此外，Java禁止多重类继承。这意味着你一次不能从一个以上的类中扩展。关于接口，我们声明`interface
    ChildInt extends ParentInt {}`。
- en: implements
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: implements
- en: While we will discuss interfaces in detail in [*Chapter 10*](B19793_10.xhtml#_idTextAnchor249),
    a brief overview here is appropriate. An interface is a construct that enables
    Java to ensure that if a class implements an interface, the class is, in effect,
    signing a contract. The contract states, generally speaking, that the class will
    have code for the `abstract` methods in the interface. An `abstract` method, which
    we will discuss in more detail later, is a method that has no implementation code;
    in other words, no curly braces.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在[*第10章*](B19793_10.xhtml#_idTextAnchor249)中详细讨论接口，但在这里简要概述是合适的。接口是一种结构，它使Java能够确保如果一个类实现了接口，那么这个类实际上是在签署一份合同。这个合同通常表示，该类将为接口中的`abstract`方法提供代码。`abstract`方法，我们将在稍后详细讨论，是一种没有实现代码的方法；换句话说，没有花括号。
- en: Concerning inheritance, unlike classes, Java allows interfaces to extend from
    more than one interface at a time. So, for example, `interface C extends A, B
    {}`, where `A`, `B`, and `C` are all interfaces, is fine. Note that, as of Java
    8, both the `default` and `static` methods in interfaces have implementation code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于继承，与类不同，Java允许接口一次扩展多个接口。例如，`interface C extends A, B {}`，其中`A`、`B`和`C`都是接口，这是可以的。请注意，截至Java
    8，接口中的`default`和`static`方法都有实现代码。
- en: A class implements an interface using the `class Dog implements Walkable` syntax.
    With this, the `static` and `default` methods in `Walkable` are available to `Dog`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类使用 `class Dog implements Walkable` 语法实现接口。这样，`Walkable` 中的 `static` 和 `default`
    方法对 `Dog` 可用。
- en: 'Now, let’s look at inheritance in action. *Figure 9**.2* shows the Java code
    for the UML in *Figure 9**.1*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看继承的实际应用。*图 9*.*2* 展示了 *图 9*.*1* 中的 UML 图对应的 Java 代码：
- en: '![Figure 9.2 – Inheritance in action](img/B19793_09_2.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 继承的实际应用](img/B19793_09_2.jpg)'
- en: Figure 9.2 – Inheritance in action
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 继承的实际应用
- en: 'In this figure, lines 3 and 4 are equivalent. `Vehicle` is at the top of this
    particular hierarchy and to ensure that `Object` is inherited by every class,
    the compiler simply inserts `extends Object` after `class Vehicle`, as per line
    3\. Lines 5-7 are a custom implementation of the `toString()` method inherited
    from `Object`. This is known as *overriding*, a topic we will discuss in detail
    shortly. Lines 9-12 represent the rest of the inheritance hierarchy: a `Car` “is-a”
    `Vehicle`; a `Boat` “is-a” `Vehicle`; a `Saloon` “is-a” `Car`; and a `Convertible`
    “is-a” `Car`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第 3 行和第 4 行是等效的。`Vehicle` 是这个特定层次结构的最顶层，为了确保每个类都继承自 `Object`，编译器在第 3 行简单地插入
    `extends Object`。第 5-7 行是对从 `Object` 继承的 `toString()` 方法的自定义实现。这被称为 *重写*，我们将在稍后详细讨论这个话题。第
    9-12 行代表了继承层次结构的其余部分：一个 `Car` 是一个 `Vehicle`；一个 `Boat` 是一个 `Vehicle`；一个 `Saloon`
    是一个 `Car`；一个 `Convertible` 是一个 `Car`。
- en: On line 16, we create a `Vehicle` object and use a `Vehicle` reference called
    `vehicle` to refer to it. On line 17, we call the `toString()` method, defined
    on lines 5-7, outputting `Vehicle::toString()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 16 行，我们创建了一个 `Vehicle` 对象，并使用一个名为 `vehicle` 的 `Vehicle` 引用来引用它。在第 17 行，我们调用定义在第
    5-7 行的 `toString()` 方法，输出 `Vehicle::toString()`。
- en: On line 18, we create a `Car` object and use a `Car` reference called `car`
    to refer to it. On line 20, we simply insert the `car` reference inside `System.out.println()`.
    When Java encounters a reference like this inside `System.out.println()`, it looks
    up the object type (`Car`, in this instance) and calls its `toString()`. As every
    class inherits from `Object`, and `Object` defines a basic (unfriendly) `toString()`,
    a version of `toString()` will exist. However, in this hierarchy, `Vehicle` has
    replaced (overridden) `toString()` inherited from `Object` with its own custom
    one (lines 5-7). This custom one from `Vehicle` is inherited by `Car`. What happens
    is that Java checks if there is a custom `toString()` defined in `Car`; as there
    isn’t one, Java then checks its parent, namely `Vehicle`. If `Vehicle` has no
    `toString()`, the version from `Object` would be used. Since `toString()` is defined
    in `Vehicle`, this is the version inherited by `Car` and used on line 20\. Thus,
    the output is, again, `Vehicle::toString()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 18 行，我们创建了一个 `Car` 对象，并使用一个名为 `car` 的 `Car` 引用来引用它。在第 20 行，我们只需将 `car` 引用插入到
    `System.out.println()` 中。当 Java 遇到这样的引用在 `System.out.println()` 内部时，它会查找对象类型（在这个例子中是
    `Car`）并调用其 `toString()` 方法。由于每个类都继承自 `Object`，而 `Object` 定义了一个基本的（不友好的）`toString()`，因此将存在一个
    `toString()` 版本。然而，在这个层次结构中，`Vehicle` 用自己的自定义版本（第 5-7 行）替换了从 `Object` 继承的 `toString()`。这个来自
    `Vehicle` 的自定义版本被 `Car` 继承。发生的情况是，Java 检查 `Car` 中是否定义了自定义的 `toString()`；由于没有定义，Java
    然后检查其父类，即 `Vehicle`。如果 `Vehicle` 中没有 `toString()`，将使用来自 `Object` 的版本。由于 `toString()`
    在 `Vehicle` 中定义，这是 `Car` 继承并用于第 20 行的版本。因此，输出再次是 `Vehicle::toString()`。
- en: On line 21, we create a `Saloon` object and use a `Saloon` reference called
    `saloon` to refer to it. Again, on line 22, we simply insert the `saloon` reference
    inside `System.out.println()`. As `Saloon` has no custom `toString()` defined,
    and its parent, `Car`, has no custom version either, the one inherited from `Vehicle`
    is used. This results in `Vehicle::toString()` being output to the screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 21 行，我们创建了一个 `Saloon` 对象，并使用一个名为 `saloon` 的 `Saloon` 引用来引用它。同样，在第 22 行，我们只需将
    `saloon` 引用插入到 `System.out.println()` 中。由于 `Saloon` 没有自定义的 `toString()`，其父类 `Car`
    也没有自定义版本，因此使用从 `Vehicle` 继承的版本。这导致输出到屏幕的是 `Vehicle::toString()`。
- en: 'Line 24 is used to demonstrate the output when the `toString()` method from
    `Object` is used. On line 24, we are creating an instance of `TestVehicle` and
    calling its `toString()` method. As `TestVehicle` is not explicitly inheriting
    from any class (using `extends`), it implicitly inherits from `Object`. In addition,
    as `TestVehicle` is not overriding `toString()` with its own custom version, the
    one inherited from `Object` is used. This is demonstrated by the output from line
    24: `ch9.TestVehicle@378bf509`. The output from the `toString()` method in `Object`
    is formatted as `package_name.class name@hash code`. The package name in this
    case is `ch9` (line 1), the class name is `TestVehicle` (line 24), and the hash
    code is a hexadecimal number that’s used in hashing collections ([*Chapter 13*](B19793_13.xhtml#_idTextAnchor317)).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第24行用于演示当使用`Object`类的`toString()`方法时的输出。在第24行，我们创建了一个`TestVehicle`的实例并调用其`toString()`方法。由于`TestVehicle`没有明确地从任何类继承（使用`extends`），它隐式地继承了`Object`。此外，由于`TestVehicle`没有用自己的自定义版本覆盖`toString()`，因此使用从`Object`继承的版本。这可以通过第24行的输出得到证明：`ch9.TestVehicle@378bf509`。`Object`中的`toString()`方法的输出格式为`package_name.class
    name@hash code`。在这个例子中，包名是`ch9`（第1行），类名是`TestVehicle`（第24行），而哈希码是一个用于散列集合的十六进制数（[*第13章*](B19793_13.xhtml#_idTextAnchor317)）。
- en: Now that we have seen basic inheritance in action, let’s move on to another
    cornerstone of OOP, namely polymorphism.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了基本继承的作用，让我们继续探讨面向对象编程的另一个基石，即多态性。
- en: Exploring polymorphism
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索多态性
- en: Polymorphism has its origins in the Greek terms poly (many) morphe (forms).
    Any object that passes more than one “is-a” test can be considered polymorphic.
    Therefore, only objects of the `Object` type are not polymorphic as any type passes
    the “is-a” test for both `Object` and itself.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性起源于希腊术语poly（许多）和morphe（形式）。任何通过一个以上的“is-a”测试的对象都可以被认为是多态的。因此，只有`Object`类型的对象不是多态的，因为任何类型都会通过`Object`和它自己的“is-a”测试。
- en: In this section, we will discuss why separating the reference type from the
    object type is so important. In addition, we will examine method overriding and
    its critical role in enabling polymorphism.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论为什么将引用类型与对象类型分开是如此重要。此外，我们还将检查方法覆盖及其在启用多态性中的关键作用。
- en: Separating the reference type from the object type
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将引用类型与对象类型分开
- en: 'Now that we have inheritance hierarchies, we will regularly differentiate the
    reference type from the object type. The reference type can be a class, record,
    enum or interface. In other words, we have flexibility with regard to the reference
    type. The object type is more restrictive: the object type is based on non-abstract
    classes, records, and enums only. In other words, we cannot create objects based
    on abstract classes or interfaces.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了继承层次结构，我们将经常区分引用类型和对象类型。引用类型可以是类、记录、枚举或接口。换句话说，我们在引用类型方面有灵活性。对象类型更为严格：对象类型仅基于非抽象类、记录和枚举。换句话说，我们不能基于抽象类或接口创建对象。
- en: 'For example, given the hierarchy in *Figure 9**.2*, it is perfectly legal to
    say the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定*图9.2*中的层次结构，以下说法是完全合法的：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is because every `Car` “is-a” `Vehicle` (reading it right to left, as assignment
    associates right to left). In this instance, the reference, `v`, is of the `Vehicle`
    type and it is referring to an object of the `Car` type. This is known as *upcasting*,
    as we are going *up* the inheritance tree (again, reading it from right to left,
    from `Car` *up* to `Vehicle`). We are upcasting the `Car` reference, created by
    `new Car()`, and casting it to a `Vehicle` reference, `v`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每个`Car`都是`Vehicle`的“is-a”类型（从右到左阅读，因为赋值是从右到左关联的）。在这个例子中，引用`v`是`Vehicle`类型，它指向一个`Car`类型的对象。这被称为*向上转型*，因为我们正在*向上*继承树（再次从右到左阅读，从`Car`向上到`Vehicle`）。我们正在向上转型`Car`引用，由`new
    Car()`创建，并将其转换为`Vehicle`引用`v`。
- en: Why does this work? This works because, due to inheritance, every inheritable
    method available to `Vehicle` will exist in `Car`. That is a guarantee. Whether
    `Car` has overridden (replaced) any/all `Vehicle` methods with its own custom
    ones is immaterial. Given that the compiler looks at the reference type (and not
    the object type), the methods we can call using the `Vehicle` reference, `v`,
    are defined in `Vehicle` (and `Object`) and will be present in `Car` (the object
    type).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这行得通？这行得通是因为，由于继承，`Vehicle`可用的所有可继承方法都将存在于`Car`中。这是一个保证。无论`Car`是否用其自定义的任何/所有`Vehicle`方法替换了这些方法，都是无关紧要的。鉴于编译器查看引用类型（而不是对象类型），我们可以使用`Vehicle`引用`v`调用的方法是在`Vehicle`（和`Object`）中定义的，并且将在`Car`（对象类型）中存在。
- en: So, that is the first point to keep in mind - the compiler is always looking
    at the reference type. As we will see shortly, the object type comes into play
    at runtime. So, a simple but effective rule of thumb is that *a reference can
    refer to objects of its own type or objects of subclasses*. In effect, a reference
    can point “across and down” the (UML) hierarchy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是需要记住的第一个要点——编译器始终查看引用类型。正如我们很快就会看到的，对象类型在运行时发挥作用。所以，一个简单但有效的经验法则是*一个引用可以指向其自身类型的对象或子类对象*。实际上，一个引用可以指向（UML）层次结构的“上方和下方”。
- en: If a reference is ever pointing “up” the hierarchy, that is when you get `ClassCastException`
    errors. Why is this? Well, a subclass inherits from its parent. In addition to
    replacing inherited functionality (overriding), the subclass can also add extra
    methods. So, if you have a reference of the subclass type, you can invoke these
    *extra* added methods. But if your object is of the parent type, these methods
    will not exist! This is a serious issue for the JVM and it throws an exception
    ([*Chapter* *11*](B19793_11.xhtml#_idTextAnchor266)) immediately.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个引用始终指向层次结构的“上方”，那么就会出现`ClassCastException`错误。为什么会出现这种情况呢？好吧，子类从其父类继承。除了替换继承的功能（重写）之外，子类还可以添加额外的方法。所以，如果你有一个子类类型的引用，你可以调用这些*额外*添加的方法。但是，如果你的对象是父类类型，这些方法将不存在！这对JVM来说是一个严重的问题，它会立即抛出一个异常（[*第11章*](B19793_11.xhtml#_idTextAnchor266)）。
- en: So, the reference type determines the methods that can be called on the object.
    In addition, while the reference type cannot change, the object type it refers
    to can.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，引用类型决定了可以调用对象的方法。此外，虽然引用类型不能改变，但它所指向的对象类型可以改变。
- en: Now, let’s address how to avail of polymorphism.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何利用多态性。
- en: Applying polymorphism
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用多态性
- en: Polymorphism applies only to instance (non-static) methods, as only instance
    methods can be overridden. At compile time, the compiler decides which method
    signature to bind to; however, the object that will provide the actual method
    to execute is decided at runtime! That is what polymorphism is. This is why polymorphism
    is also known as “runtime binding” or “late binding.”
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性仅适用于实例（非静态）方法，因为只有实例方法可以被重写。在编译时，编译器决定绑定哪个方法签名；然而，将提供实际要执行的方法的对象是在运行时决定的！这就是多态性的含义。这也是为什么多态性也被称为“运行时绑定”或“后期绑定”的原因。
- en: What if you are accessing a static member?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在访问一个静态成员怎么办？
- en: 'A `static` member (method or data) is associated with the class and therefore
    not involved in polymorphism. The following applies: if you are accessing any
    type of data (`static` or non-static) or `static` methods, the JVM uses the reference
    type. Only if it’s an instance method is the object type used (polymorphism).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`static`成员（方法或数据）与类相关联，因此不涉及多态性。以下适用：如果你正在访问任何类型的数据（`static`或非静态）或`static`方法，JVM使用引用类型。只有当它是实例方法时，才会使用对象类型（多态性）。
- en: Thus, for polymorphism to work, we need instance methods in the base and subclass
    where the subclass overrides the base version. For this to happen, the subclass
    must code a method that has the same signature as the parent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使多态性起作用，我们需要在基类和子类中实现实例方法，其中子类重写了基类版本。为了实现这一点，子类必须编写一个与父类具有相同签名的函数。
- en: Okay, that’s enough theory – let’s look at an example that reinforces everything
    we’ve learned thus far.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，理论就到这里为止——让我们看看一个例子，以巩固我们迄今为止所学的一切。
- en: Polymorphism in code – example 1
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码中的多态性——示例1
- en: '*Figure 9**.3* shows the UML for the code to follow:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.3*显示了以下代码的UML图：'
- en: '![Figure 9.3 – UML for polymorphism example](img/B19793_09_3.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 多态性的UML示例](img/B19793_09_3.jpg)'
- en: Figure 9.3 – UML for polymorphism example
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 多态性的UML示例
- en: In this figure, the `Vehicle` class has a `move()` method. It is an instance
    method, with a return type of `void`. Both `Car` and `Boat` extend `Vehicle` and
    override `move()`. `Car` adds a method called `wheels()` and `Boat` adds a method
    called `floats()`. Both `Saloon` and `Convertible` extend `Car`. `Saloon` overrides
    `move()` but `Convertible` does not.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`Vehicle`类有一个`move()`方法。它是一个实例方法，返回类型为`void`。`Car`和`Boat`都扩展了`Vehicle`并重写了`move()`方法。`Car`添加了一个名为`wheels()`的方法，而`Boat`添加了一个名为`floats()`的方法。`Saloon`和`Convertible`都扩展了`Car`。`Saloon`重写了`move()`方法，而`Convertible`没有。
- en: '*Figure 9**.4* presents the code for this UML and demonstrates polymorphism
    in action:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.4* 展示了此UML的代码，并展示了多态的实际应用：'
- en: '@Override annotation'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Override`注释'
- en: An annotation is a form of metadata that provides information about the program
    that is not part of the program itself. Annotations are preceded in Java with
    the `@` symbol and have several uses. For example, annotations are used by the
    compiler to detect errors or by the runtime to generate code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是一种元数据形式，它提供了关于程序的信息，但这些信息本身并不包含在程序中。在Java中，注释由`@`符号开头，并且有多种用途。例如，注释被编译器用来检测错误，或者被运行时用来生成代码。
- en: When overriding a base class method, we can insert the `@Override` annotation
    just prior to the subclass method. While not mandatory, it is very useful, because,
    if we apply this annotation, the compiler will ensure that we override the method
    correctly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当重写基类方法时，我们可以在子类方法之前插入`@Override`注释。虽然这不是强制的，但它非常有用，因为如果我们应用这个注释，编译器将确保我们正确地重写了方法。
- en: '![Figure 9.4 – Polymorphism example](img/B19793_09_4.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 多态示例](img/B19793_09_4.jpg)'
- en: Figure 9.4 – Polymorphism example
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 多态示例
- en: In this figure, `Car` and `Boat` both extend `Vehicle`; and `Saloon` and `Convertible`
    both extend `Car`. Note that the `move()` method in `Vehicle` (line 4) is a non-static/instance
    method and therefore polymorphic. In addition, as `move()` is non-`private`, it
    is inheritable. The `move()` method from `Vehicle` is overridden by `Car` (line
    7), `Boat` (line 11), and `Saloon` (line 15). To highlight this fact, on each
    of those lines, we have used the `@Override` annotation. This means that the parent
    `move()` method is overridden by the respective subclass versions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`Car`和`Boat`都扩展了`Vehicle`；`Saloon`和`Convertible`都扩展了`Car`。请注意，`Vehicle`中的`move()`方法（第4行）是一个非静态/实例方法，因此是多态的。此外，由于`move()`不是`private`的，它是可继承的。`Vehicle`中的`move()`方法被`Car`（第7行）、`Boat`（第11行）和`Saloon`（第15行）重写。为了强调这一点，我们在这些行的每一行都使用了`@Override`注释。这意味着父类`move()`方法被相应的子类版本重写。
- en: 'Line 21 creates a `Car` object and uses a `Vehicle` reference, namely `v`,
    to refer to it. It is worth repeating that this upcasting, from `Car` up to `Vehicle`,
    is only possible because, via inheritance, *every* `Car` “is-a” `Vehicle`. Therefore,
    any method available to the `Vehicle` reference will exist in `Car`. Consequently,
    as upcasting is never a risk, it is performed implicitly by the compiler; in other
    words, you do not need to explicitly state the (up)cast in code, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第21行创建了一个`Car`对象，并使用一个`Vehicle`引用，即`v`，来引用它。值得重复的是，这种从`Car`到`Vehicle`的上转型，仅因为通过继承，*每个*
    `Car` 都是 `Vehicle` 的子类。因此，任何对`Vehicle`引用可用的方法都将存在于`Car`中。因此，由于上转型从不构成风险，编译器会隐式地执行它；换句话说，你不需要在代码中显式地声明（上）转型，如下所示：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile time
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译时
- en: 'Line 22 makes the polymorphic `v.move()` call. Every time a method call is
    in code, there are two perspectives to keep in mind: compile time and runtime.
    As we know, the compiler concerns itself with the reference type. So, in this
    case, the compiler checks the reference, `v`, and determines that it is of type
    `Vehicle`. The compiler then checks if there is a `move()` method, with that exact
    signature in the `Vehicle` class, either defined in `Vehicle` or inherited into
    `Vehicle` (from `Object` in this example). As there is a `move()` method defined
    in `Vehicle`, the compiler is happy.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第22行调用了多态的`v.move()`方法。每次在代码中进行方法调用时，都需要考虑两个视角：编译时和运行时。正如我们所知，编译器关注的是引用类型。因此，在这种情况下，编译器检查引用`v`，并确定它是`Vehicle`类型。然后编译器检查在`Vehicle`类中是否存在具有该确切签名的`move()`方法，无论是定义在`Vehicle`中还是从`Object`（在这个例子中）继承到`Vehicle`中。由于在`Vehicle`中定义了`move()`方法，编译器对此感到满意。
- en: Polymorphism in action
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多态的实际应用
- en: At runtime, as `move()` is a non-static, polymorphic method, the object being
    referred to by the reference, `v`, applies. As `v` is referring to a `Car` object,
    the `Car` version of `move()` is executed. This is polymorphism in action! We
    have one method but many implementations of that method. The compiler ensures
    that the method exists and dynamically, at runtime, polymorphism kicks in and
    executes the version in the object being referred to. As `v` is referring to a
    `Car` object, the output from line 22 is `Car::move()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，由于`move()`是一个非静态的多态方法，被引用的对象，即`v`，适用。由于`v`指的是一个`Car`对象，所以执行了`Car`版本的`move()`。这是多态的实际应用！我们有一个方法，但有很多这个方法的实现。编译器确保方法存在，并在运行时动态地触发多态，并执行被引用对象中的版本。由于`v`指的是一个`Car`对象，所以第22行的输出结果是`Car::move()`。
- en: Line 23 reuses the `Vehicle` reference, `v` (which is perfectly valid), to refer
    to a `Boat` object. As `Boat` “is-a” `Vehicle`, this is fine. Line 24 makes the
    same polymorphic call to `v.move()` as was the case on line 22\. However, this
    time, `v` is referring to a `Boat` object, and as `Boat` has overridden `move()`,
    the `Boat` version of `move()` is executed at runtime. Therefore the output is
    `Boat::move()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第23行重复使用了`Vehicle`引用，`v`（这是完全有效的），来指代一个`Boat`对象。因为`Boat`是`Vehicle`的一种（即“is-a”关系），所以这是可以的。第24行对`v.move()`进行了与第22行相同的多态调用。然而，这次`v`指的是一个`Boat`对象，并且由于`Boat`重写了`move()`方法，所以在运行时执行了`Boat`版本的`move()`。因此，输出结果是`Boat::move()`。
- en: Line 25 demonstrates that the compiler looks at the reference type. As we know,
    `v` is of type `Vehicle`. However, `Vehicle` has no `floats()` method; this is
    a method specific to `Boat`. Therefore, the compiler complains about `v.floats()`
    on line 25, and hence, the line is commented out.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第25行展示了编译器查看引用类型。正如我们所知，`v`的类型是`Vehicle`。然而，`Vehicle`没有`floats()`方法；这是一个特定于`Boat`的方法。因此，编译器在第25行对`v.floats()`提出了抱怨，所以这一行被注释掉了。
- en: Line 26 reuses the `Vehicle` reference, `v`, to refer to a `Saloon` object.
    As `Saloon` “is-a” `Vehicle`, this is fine. Line 27 makes the same polymorphic
    call to `v.move()` as was the case on lines 22 and 24\. As `v` is now referring
    to a `Saloon` object with an overridden `move()` method, the `Saloon` version
    of `move()` is executed polymorphically at runtime. Therefore, the output is `Saloon::move()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第26行重复使用了`Vehicle`引用，`v`，来指代一个`Saloon`对象。因为`Saloon`是`Vehicle`的一种（即“is-a”关系），所以这是可以的。第27行对`v.move()`进行了相同的多态调用，就像第22行和第24行的情况一样。由于`v`现在指的是一个具有重写`move()`方法的`Saloon`对象，所以在运行时以多态方式执行了`Saloon`版本的`move()`。因此，输出结果是`Saloon::move()`。
- en: 'Line 28 creates a `Convertible` object and uses `v` to refer to it. This is
    not a problem as `Convertible` “is-a” `Vehicle` (indirectly, via `Car`). In other
    words, because `Convertible` is-a `Vehicle` and `Vehicle` is-a `Car`, `Convertible`
    is-a `Car` also. Line 29 makes the same polymorphic call, `v.move()`, as was the
    case on lines 22, 24, and 27\. Note, however, that `Convertible` has not overridden
    `move()`. `Convertible` has an empty class body. Therefore, the methods in `Convertible`
    are the `move()` and `wheels()` methods inherited from `Car` and the methods inherited
    from `Object`, such as `toString()`. So, at runtime, when `v.move()` is called,
    the JVM executes the version of `move()` in `Car`, resulting in `Car::move()`.
    You can also look at it this way: the runtime looks for `move()` in `Convertible`,
    and finds none; the JVM then checks the parent, `Car`, and finds one, which it
    executes. Note that if `Car` had not provided a `move()` method, its parent, `Vehicle`,
    would have been next in the search. So, there is an “up the hierarchy, one generation
    at a time” orderly search.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行创建了一个`Convertible`对象，并使用`v`来引用它。这没问题，因为`Convertible`是`Vehicle`的一种（通过`Car`间接）。换句话说，因为`Convertible`是`Vehicle`的一种，而`Vehicle`是`Car`的一种，所以`Convertible`也是`Car`的一种。第29行进行了相同的多态调用，即`v.move()`，就像第22行、第24行和第27行的情况一样。然而，需要注意的是，`Convertible`没有重写`move()`方法。`Convertible`有一个空的类体。因此，`Convertible`中的方法是从`Car`继承来的`move()`和`wheels()`方法，以及从`Object`继承来的方法，如`toString()`。所以，在运行时，当调用`v.move()`时，JVM执行了`Car`中的`move()`版本，结果是`Car::move()`。你也可以这样理解：运行时在`Convertible`中查找`move()`，但没有找到；然后JVM检查其父类`Car`，并找到了一个，然后执行它。请注意，如果`Car`没有提供`move()`方法，它的父类`Vehicle`将会是下一个搜索的对象。所以，这是一个“逐级向上，一次一代”的有序搜索。
- en: Why do we get a ClassCastException error?
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么我们会得到`ClassCastException`错误？
- en: 'Line 31 demonstrates downcasting and a `ClassCastException` error. Exceptions
    will be discussed in [*Chapter 11*](B19793_11.xhtml#_idTextAnchor266), so we won’t
    go into detail here. Downcasting will be discussed in greater detail later in
    this chapter but this example is too good to pass up! Let’s examine line 31 in
    greater detail:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第31行展示了向下转型和`ClassCastException`错误。异常将在[*第11章*](B19793_11.xhtml#_idTextAnchor266)中讨论，所以这里不会详细说明。向下转型将在本章后面更详细地讨论，但这个例子太好了，不容错过！让我们更详细地检查第31行：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first thing to note is that the cast (`Saloon`) *is* required. The compiler
    will not allow the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，转型（`Saloon`）是必需的。编译器不会允许以下代码：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a compiler error because every `Vehicle` is not a `Saloon` class; some
    are `Boat`s. Indeed, even if the `Boat` class were not present, this line would
    still not compile. Why? Because, reading it right to left, you are going *down*
    the hierarchy from `Vehicle` to `Saloon`. As `Saloon` could (and indeed does)
    have extra methods not in the `Vehicle` class, this situation must be prevented.
    For example, the `Saloon` reference, `s`, has access to the `wheels()` method
    (inherited from `Car`), which is not present in `Vehicle`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个编译器错误，因为并非每个`Vehicle`都是`Saloon`类；有些是`Boat`。实际上，即使没有`Boat`类，这一行代码也无法编译。为什么？因为，从右向左阅读，你是在从`Vehicle`到`Saloon`的层次结构中向下移动。由于`Saloon`可能（实际上确实如此）有不在`Vehicle`类中的额外方法，这种情况必须被阻止。例如，`Saloon`引用`s`可以访问从`Car`继承来的`wheels()`方法，而`Vehicle`中没有这个方法。
- en: 'Now, we can override the compiler by using a (down)cast. This is what line
    31 has done with the `(Saloon)` cast. In effect, by inserting the cast and overriding
    the compiler error, you are saying to the compiler: “Let me proceed, I know what
    I am doing.” So, the code compiles with the cast in place. However, at runtime,
    the JVM realizes that it has a `Saloon` reference referring *up* the inheritance
    tree to a `Vehicle` object. This is a big no-no because *if* the JVM allowed the
    `Saloon` reference `s` to refer to a `Vehicle` object, what would it do with a
    subsequent `s.wheels()` method call? Remember, we would be looking at a `Vehicle`
    object, which has no such method! Hence the JVM generates a `ClassCastException`
    error.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用（向下）转型来覆盖编译器。这就是第31行使用`(Saloon)`转型的做法。实际上，通过插入转型并覆盖编译器错误，你是在告诉编译器：“让我继续，我知道我在做什么。”因此，代码在放置转型后可以编译。然而，在运行时，JVM意识到它有一个指向继承树中`Vehicle`对象的`Saloon`引用。这是大忌，因为如果JVM允许`Saloon`引用`s`指向一个`Vehicle`对象，那么在随后的`s.wheels()`方法调用中会发生什么？记住，我们会看到一个没有这种方法的`Vehicle`对象！因此，JVM生成一个`ClassCastException`错误。
- en: Let’s refactor this code to demonstrate polymorphism from another angle.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构这段代码，从另一个角度展示多态性。
- en: Polymorphism in code – example 2
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码中的多态性 – 示例 2
- en: '*Figure 9**.5* shows the refactored code from *Figure 9**.4*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.5*显示了从*图9.4*重构的代码：'
- en: '![Figure 9.5 – Refactored polymorphism example](img/B19793_09_5.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 重构的多态性示例](img/B19793_09_5.jpg)'
- en: Figure 9.5 – Refactored polymorphism example
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 重构的多态性示例
- en: Note that, in this figure, the inheritance hierarchy remains untouched from
    *Figure 9**.4*. The `TestVehicle` class (lines 19-30) has been refactored though.
    We have introduced a new method, namely `doAction()` (lines 20-22), that accepts
    a `Vehicle` reference. In the `doAction()` method, we simply call the `move()`
    method (line 21). As `Vehicle` has a `move()` method, this is fine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个图中，继承层次结构从*图9.4*保持不变。`TestVehicle`类（第19-30行）已经被重构。我们引入了一个新方法，即`doAction()`（第20-22行），它接受一个`Vehicle`引用。在`doAction()`方法中，我们简单地调用`move()`方法（第21行）。由于`Vehicle`有一个`move()`方法，这是可以的。
- en: Line 24 is as before; it creates a `Car` object and upcasts the reference to
    a `Vehicle` reference, `v`. Thus, `v` is referring to a `Car` object. Line 25
    invokes the `doAction()` method, passing in the reference, `v`. This reference,
    `v`, which is declared on line 24, is copied into the separate (different scope)
    but similarly named reference, `v`, which is declared on line 20\. Now, in `doAction()`,
    we have a local `v` reference referring to the same `Car` object created on line
    24\. Thus, when we invoke `v.move()` on line 21, polymorphism kicks in and we
    get the `Car` version of `move()`, resulting in `Car::move()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第24行与之前相同；它创建了一个`Car`对象，并将引用向上转换为`Vehicle`引用`v`。因此，`v`引用了一个`Car`对象。第25行调用`doAction()`方法，传入引用`v`。这个在第24行声明的引用`v`被复制到另一个（不同的作用域）但名称相似的引用`v`，它在第20行声明。现在，在`doAction()`中，我们有一个局部`v`引用，它引用了第24行创建的同一个`Car`对象。因此，当我们第21行调用`v.move()`时，多态就起作用了，我们得到`Car`版本的`move()`，结果是`Car::move()`。
- en: Line 26 does the same thing in one line of code as was done in the previous
    two lines of code (lines 24-25). On line 26, the `Boat` object is created, and
    the method call to `doAction()` results in the upcast to the `Vehicle` reference,
    `v` (line 20). After that, line 21 executes polymorphically and we get the `Boat`
    version of `move()`, resulting in `Boat::move()`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第26行在一行代码中做了与前面两行代码（第24-25行）相同的事情。在第26行，创建了`Boat`对象，对`doAction()`的方法调用导致向上转换为`Vehicle`引用`v`（第20行）。之后，第21行以多态方式执行，我们得到`Boat`版本的`move()`，结果是`Boat::move()`。
- en: Line 27 is the same as line 26 except we are creating a `Saloon` object. Thus,
    the `Vehicle` reference, `v`, in `doAction()` executes the `move()` method as
    `Saloon`, resulting in `Saloon::move()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第27行与第26行相同，只是我们正在创建一个`Saloon`对象。因此，`doAction()`中的`Vehicle`引用`v`执行了`move()`方法作为`Saloon`，结果是`Saloon::move()`。
- en: Line 28 is the same as line 27 except we are creating a `Convertible` object.
    Thus, the `Vehicle` reference, `v`, in `doAction()` attempts to execute the `move()`
    method in `Convertible`. As there is none, the parent of `Convertible`, namely
    `Car`, is checked. `Car` does have a version of `move()`, resulting in `Car::move()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行与第27行相同，只是我们正在创建一个`Convertible`对象。因此，`doAction()`中的`Vehicle`引用`v`试图在`Convertible`中执行`move()`方法。由于没有找到，检查`Convertible`的父类，即`Car`。`Car`确实有一个`move()`版本，结果是`Car::move()`。
- en: To be clear about when polymorphism applies and when it does not, we will revisit
    a callout box presented earlier.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地了解何时应用多态以及何时不应用，我们将重新审视之前提出的调用框。
- en: JVM – object type versus reference type usage
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM – 引用类型与对象类型的使用
- en: 'As discussed briefly in a previous callout, if you are dealing with any type
    of data (`static` or non-static), the reference type applies; when dealing with
    instance methods, the object type applies (polymorphism). *Figure 9**.6* presents
    a code example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个调用框中简要讨论的，如果你处理任何类型的数据（`static`或非静态），则应用引用类型；当处理实例方法时，应用对象类型（多态）。**图9**.6展示了代码示例：
- en: '![Figure 9.6 – When the JVM uses the reference type versus the object type](img/B19793_09_6.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – JVM使用引用类型与对象类型的情况](img/B19793_09_6.jpg)'
- en: Figure 9.6 – When the JVM uses the reference type versus the object type
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – JVM使用引用类型与对象类型的情况
- en: In this figure, the `Vehicle` class declares an instance variable, namely `cost`
    (line 4), and a class variable, namely `age` (line 5). In addition, `Vehicle`
    also declares an instance method called `move()` (lines 6-8) and a class method
    called `sm()` (lines 9-11). So, in `Vehicle`, we have both instance and `static`
    data and instance and `static` methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`Vehicle`类声明了一个实例变量，即`cost`（第4行），以及一个类变量，即`age`（第5行）。此外，`Vehicle`还声明了一个名为`move()`的实例方法（第6-8行）和一个名为`sm()`的类方法（第9-11行）。因此，在`Vehicle`中，我们既有实例和`static`数据，也有实例和`static`方法。
- en: The `Car` class extends from `Vehicle` (lines 13-23) and simply replicates `Vehicle`.
    In other words, `Car` has the same data and methods as its parent, `Vehicle`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`类从`Vehicle`扩展（第13-23行）并简单地复制`Vehicle`。换句话说，`Car`具有与父类`Vehicle`相同的数据和方法。'
- en: In `Car`, we declare both instance and non-instance variables, namely `cost`
    and `age`, respectively (lines 14-15). These variables in `Car` have the same
    types and identifiers as their counterparts in the parent class, `Vehicle`. In
    other words, `Vehicle` has an instance variable called `cost`, which is a `double`;
    and `Car` also has an instance variable named `cost`, which is also a `double`.
    The same occurs with the `age` class variable in `Vehicle` – there is a class
    variable named `age` in the `Car` subclass also. This is known as *hiding* (or
    *shadowing*).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Car`中，我们分别声明了实例变量和非实例变量，即`cost`和`age`（第14-15行）。这些变量在`Car`中的类型和标识符与父类`Vehicle`中的对应变量相同。换句话说，`Vehicle`有一个名为`cost`的实例变量，它是一个`double`；`Car`也有一个名为`cost`的实例变量，它也是一个`double`。`Vehicle`中的`age`类变量也有相同的情况——`Car`子类中也有一个名为`age`的类变量。这被称为*隐藏*（或*遮蔽*）。
- en: '`Vehicle` defines the instance method, `move()` (lines 6-8), which is overridden
    by the version in `Car` (lines 17-19). As this is an instance method, polymorphism
    applies at runtime if `move()` is called.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`定义了一个实例方法`move()`（第6-8行），它被`Car`中的版本（第17-19行）重写。由于这是一个实例方法，如果调用`move()`，则在运行时应用多态。'
- en: '`Vehicle` also defines a class method called `sm()` (lines 9-11), which is
    hidden (shadowed) by the version of `sm()` in `Car` (lines 20-22).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`还定义了一个名为`sm()`的类方法（第9-11行），它被`Car`中的`sm()`版本（第20-22行）隐藏（遮蔽）。'
- en: Line 26 creates a `Car` object and uses a `Vehicle` reference, `v`, to refer
    to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第26行创建了一个`Car`对象，并使用一个`Vehicle`引用`v`来引用它。
- en: Line 27 outputs `v.cost`. As `cost` is data (an instance variable), the reference
    type applies. Consequently, we get `100.0`, which is the `cost` instance variable
    in `Vehicle` (as opposed to `20_000.0`, which is the `cost` instance variable
    in `Car`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第27行输出`v.cost`。由于`cost`是数据（一个实例变量），引用类型适用。因此，我们得到`100.0`，这是`Vehicle`中的`cost`实例变量（而不是`20_000.0`，这是`Car`中的`cost`实例变量）。
- en: Using the class name when accessing a static member
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问静态成员时使用类名
- en: 'Both lines 28 and 29 present syntax that you should *never* use: using a reference
    to access a `static` member. When accessing a `static` member, you should prefix
    the member with the class name. For example, line 28 should use `Vehicle.age`
    and line 29 should use `Vehicle.sm()` as this emphasizes the member’s `static`
    nature. Using references here is confusing as it implies that the member is non-static.
    We accessed `static` members using the reference for demo purposes only!'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行和第29行展示了你应该*永远不要*使用的语法：使用引用来访问`static`成员。在访问`static`成员时，你应该在成员前加上类名。例如，第28行应该使用`Vehicle.age`，而第29行应该使用`Vehicle.sm()`，因为这强调了成员的`static`属性。在这里使用引用是令人困惑的，因为它暗示成员是非静态的。我们仅为了演示目的使用引用来访问`static`成员！
- en: Line 28 outputs `v.age`. As `age` is a `static` member, the compiler checks
    the type for `v` (namely `Vehicle`) and changes `v.code` to `Vehicle.code`. Therefore,
    `age` from `Vehicle` is used as opposed to `age` from `Car`. In other words, the
    output is 1, not 2.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行输出`v.age`。由于`age`是一个`static`成员，编译器会检查`v`的类型（即`Vehicle`），并将`v.code`更改为`Vehicle.code`。因此，使用的是`Vehicle`中的`age`，而不是`Car`中的`age`。换句话说，输出是1，而不是2。
- en: Line 29 is the call to `v.sm()`. As `sm()` is also `static`, the compiler translates
    this into `Vehicle.sm()` and therefore the output is `Vehicle::sm()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第29行是对`v.sm()`的调用。由于`sm()`也是`static`的，编译器将其转换为`Vehicle.sm()`，因此输出是`Vehicle::sm()`。
- en: Lastly, line 30 is the polymorphic call to `move()`, and as a result, the object
    type, `Car`, is used. This results in `Car::move()` being output.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第30行是对`move()`的多态调用，因此使用的是对象类型`Car`。这导致输出`Car::move()`。
- en: Now that we understand polymorphism, let’s ensure that we understand the difference
    between two terms that are often confused, namely method overriding and method
    overloading.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了多态，让我们确保我们理解了两个经常被混淆的术语之间的区别，即方法重写和方法重载。
- en: Contrasting method overriding and method overloading
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对比方法重写和方法重载
- en: 'These two terms are often confused but in this section, we will compare and
    contrast both. We will show that concerning method overloading, the method signature
    must be different; whereas concerning method overriding, the method signature
    must be the same. Recall that the method signature consists of the method name
    and the parameter types, including their order. The return type and the parameter
    identifiers are *not* part of the method signature. So, for example, take the
    method from *Figure 9**.5*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个术语经常被混淆，但在本节中，我们将比较和对比这两个术语。我们将展示，在方法重载的情况下，方法签名必须不同；而在方法重写的情况下，方法签名必须相同。回想一下，方法签名由方法名和参数类型组成，包括它们的顺序。返回类型和参数标识符不是方法签名的一部分。所以，例如，考虑*图9**.5*中的方法：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The signature is `doAction(Vehicle)`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 签名为`doAction(Vehicle)`。
- en: With this in mind, we will initially discuss method overloading.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们将首先讨论方法重载。
- en: Method overloading
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: Recall that the method signature consists of the method name and the parameter
    types. Method overloading is where you have the same method name but the parameters
    differ, either in type and/or order. This means that the method signatures are
    different even though the method names are the same. They have to be – how else
    will the compiler choose which method to bind to? Thus, method overloading is
    all about compile time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，方法签名由方法名和参数类型组成。方法重载是你有相同的方法名，但参数不同，无论是类型和/或顺序。这意味着即使方法名相同，方法签名也不同。它们必须这样，否则编译器如何选择绑定哪个方法？因此，方法重载完全是关于编译时间的。
- en: The rules
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则
- en: 'Bearing in mind that the method signatures *must be different* (apart from
    the method name), the rules are quite straightforward:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到方法签名*必须不同*（除了方法名之外），规则相当简单：
- en: Overloaded methods must use *DIFFERENT* parameter lists; either the types used
    must be different or the order of the types must be different
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载方法必须使用*不同的*参数列表；要么使用的类型必须不同，要么类型的顺序必须不同
- en: As the method signature only relates to the method name and the parameter list,
    overloaded methods are free to change the return type and the access modifier
    and use new or broader checked exceptions
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于方法签名只与方法名和参数列表相关，重载方法可以更改返回类型和访问修饰符，并使用新的或更广泛的检查异常
- en: An overloaded method can be overloaded in the same type or a subtype
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载方法可以在同一类型或子类型中进行重载
- en: Now, let’s look at an example of method overloading in code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码中方法重载的一个例子。
- en: Method overloading example
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重载示例
- en: '*Figure 9**.7* presents the example code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.7* 展示了示例代码：'
- en: '![Figure 9.7 – Method overloading](img/B19793_09_7.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 方法重载](img/B19793_09_7.jpg)'
- en: Figure 9.7 – Method overloading
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 方法重载
- en: 'In this figure, we will first discuss the method overloading between lines
    10-17\. To help, the method signatures are in comments on each line. Line 10 defines
    a `calc` method that takes in an `int` and a `double`, in that order. Therefore,
    the signature is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们将首先讨论第10-17行之间的方法重载。为了帮助理解，每行上的注释中都包含了方法签名。第10行定义了一个`calc`方法，该方法接受一个`int`和一个`double`类型的参数，顺序如下。因此，签名如下：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are not interested in the return type or the identifiers used for the `int`
    and `double` parameters. So long as we do not code another `calc(int, double)`
    method in the *same class*, we are okay. Note that if we coded a method with the
    same signature in a subtype, this is overriding! As the method signatures between
    lines 11-14 are different, they are fine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对返回类型或用于`int`和`double`参数的标识符不感兴趣。只要我们不在同一个类中编码另一个`calc(int, double)`方法，我们就没问题。注意，如果我们在一个子类型中编码了一个具有相同签名的函数，这将是重写！由于第11-14行之间的方法签名不同，它们是可行的。
- en: Let’s examine why lines 16 and 17 fail to compile. Line 16 attempts to just
    change the identifiers used for the parameters. This does not change the method
    signature. Consequently, this signature is an exact match for the method on line
    10 and therefore, the compiler complains. Similarly, line 17 changes the return
    type (as well as the identifiers in the parameter list). Again, as this signature
    is a duplicate of the one on line 10, the compiler complains.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析为什么第16和17行无法编译。第16行试图只更改参数使用的标识符。这并没有改变方法签名。因此，这个签名与方法第10行的签名完全匹配，因此编译器会报错。同样，第17行更改了返回类型（以及参数列表中的标识符）。再次，由于这个签名与第10行的签名重复，编译器会报错。
- en: The inheritance hierarchy is interesting. We have a parent called `Animal` (lines
    2-4) and a subclass class `Cow` (lines 5-8). On line 3, `Animal` defines an `eat()`
    method. On line 7, `Cow` overloads this method with an `eat(String)` method. The
    parent `Animal` version accepts no argument, whereas the subtype version accepts
    `String`. The compiler is happy.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 继承层次结构很有趣。我们有一个父类`Animal`（第2-4行）和一个子类`Cow`（第5-8行）。在第3行，`Animal`定义了一个`eat()`方法。在第7行，`Cow`使用`eat(String)`方法重载了这个方法。父类`Animal`版本不接受任何参数，而子类版本接受`String`参数。编译器很高兴。
- en: But what about line 6, where `Cow` defines an `eat()` method that accepts no
    argument? This is overriding the parent version (polymorphism), so there is no
    conflict. The compiler will bind to the reference type used, be it `Animal` or
    `Cow`, as both have an `eat()` method. At runtime, depending on the object type,
    the JVM will execute the relevant code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但第6行呢，`Cow`类定义了一个不接受任何参数的`eat()`方法？这是在覆盖父类版本（多态），所以没有冲突。编译器将绑定到使用的引用类型，无论是`Animal`还是`Cow`，因为两者都有一个`eat()`方法。在运行时，根据对象类型，JVM将执行相关代码。
- en: Let’s examine this process to make sure it is clear. Line 20 creates an `Animal`
    object and uses an `Animal` reference, `aa`, to refer to it. Line 21 calls `aa.eat()`.
    At compile time, the compiler checks if there is an `eat()` method with that exact
    signature in `Animal`, as `Animal` is the type for `aa`. As there is, the compiler
    is happy. At runtime, as the method is an instance method, polymorphism applies
    and the JVM will execute the `Animal` version (as that is the object type).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个过程以确保它清晰。第20行创建了一个`Animal`对象，并使用一个`Animal`引用`aa`来引用它。第21行调用`aa.eat()`。在编译时，编译器检查`Animal`类中是否有具有该确切签名的`eat()`方法，因为`Animal`是`aa`的类型。由于有，编译器很高兴。在运行时，由于方法是实例方法，多态适用，JVM将执行`Animal`版本（因为这是对象类型）。
- en: Note how line 22 does not compile. This is because there is no `eat(String)`
    method in `Animal`. Remember, the compiler looks at the reference type only and
    as `aa` is of type `Animal`, it checks the `Animal` class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第22行为什么无法编译。这是因为`Animal`类中没有`eat(String)`方法。记住，编译器只查看引用类型，而`aa`的类型是`Animal`，它检查`Animal`类。
- en: Lines 24-26 take things one step further. Line 24 creates a `Cow` object and
    uses an `Animal` reference called `ac` to refer to it. Line 25 makes the polymorphic
    call to `eat()`, which will execute the `Cow` version at runtime. Line 26 is interesting
    and is there to prove that the compiler is looking at the reference type. Even
    though our object type is `Cow` and `Cow` has an `eat(String)` method, the `ac.eat("Grass")`
    class still does not compile (because `ac` is of type `Animal`).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第24-26行进一步说明了问题。第24行创建了一个`Cow`对象，并使用一个名为`ac`的`Animal`引用来引用它。第25行进行了多态调用`eat()`，这将执行运行时的`Cow`版本。第26行很有趣，它存在是为了证明编译器正在查看引用类型。尽管我们的对象类型是`Cow`且`Cow`有一个`eat(String)`方法，但`ac.eat("Grass")`类仍然无法编译（因为`ac`的类型是`Animal`）。
- en: So, how do we get access to the `eat(String)` method? We need a `Cow` reference.
    This is what lines 28-30 demonstrate. Line 30 successfully invokes `cc.eat("Grass")`
    using the `cc` reference declared on line 28.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何访问`eat(String)`方法呢？我们需要一个`Cow`引用。这正是第28-30行所展示的。第30行成功使用第28行声明的`cc`引用调用了`cc.eat("Grass")`。
- en: What this code demonstrates is that an `Animal` reference only has access to
    the `eat()` method it defined. On the other hand, a `Cow` reference has access
    to both `eat()` and `eat(String)`. The `Cow` type inherited (and overrode) `eat()`
    and defined `eat(String)` itself. Note that the `Cow` class did not need to override
    `eat()` to have access to the inherited version.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示的是，一个`Animal`引用只能访问它定义的`eat()`方法。另一方面，一个`Cow`引用可以访问`eat()`和`eat(String)`。`Cow`类型继承（并覆盖）了`eat()`并自己定义了`eat(String)`。注意，`Cow`类不需要覆盖`eat()`就能访问继承的版本。
- en: Method overriding
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法覆盖
- en: Method overriding occurs when you have the same method signatures in both a
    parent and subclass. Method overriding is critical for enabling (runtime) polymorphism.
    Remember, a method must first be inherited to be overridden. For example, methods
    that are defined as `private`, `static`, or `final` are not inherited because
    `private` methods are local to the class; `static` methods are not polymorphic
    and marking a method as `final` is stating that “this method is not to be overridden.”
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在父类和子类中都有相同的方法签名时，就会发生方法重写。方法重写对于启用（运行时）多态至关重要。记住，一个方法必须首先被继承才能被重写。例如，定义为`private`、`static`或`final`的方法不会被继承，因为`private`方法仅限于类内部；`static`方法不是多态的，将方法标记为`final`是声明“这个方法不应该被重写”。
- en: To understand the rules, it is critical to remember that the compiler has compiled
    the code based on the reference. Therefore, the runtime polymorphic method *must
    not* behave differently from what the compiler verified. For example, the access
    modifier on the overriding method cannot be more restrictive.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解规则，关键是要记住编译器是根据引用来编译代码的。因此，运行时多态方法**必须**与编译器验证的行为一致。例如，重写方法上的访问修饰符不能更严格。
- en: Before we discuss the rules, we must first explain covariant returns.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论规则之前，我们必须首先解释协变返回。
- en: Covariant returns
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协变返回
- en: 'When you are overriding a parent method in a subclass, if the return type is
    a primitive, then the overriding method’s return type must match. However, if
    the return type is a non-primitive, then there is one exception to the rule: covariant
    returns.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在子类中重写父类的方法时，如果返回类型是原始类型，那么重写方法的返回类型必须匹配。然而，如果返回类型是非原始类型，那么有一个例外：协变返回。
- en: What a covariant return means is that if you return a type, `X`, in the parent
    method, then you can return `X` and any subtype of `X` in the overriding method.
    For example, if a parent method is returning `Animal`, then the overriding method
    can return `Animal`, (naturally) as well as any subtype of `Animal`; for example,
    `Cow`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 协变返回的含义是，如果你在父方法中返回类型`X`，那么你可以在重写方法中返回`X`及其任何子类型。例如，如果父方法返回`Animal`，那么重写方法可以返回`Animal`（自然地），以及`Animal`的任何子类型；例如，`Cow`。
- en: The rules
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则
- en: 'As we discuss the rules, it is helpful to bear in mind that the compiler checks
    against the reference type. These overriding rules ensure that the runtime object
    cannot do something that the compiler (and thus your code) does not expect. The
    rules are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论规则时，记住编译器是针对引用类型进行检查是有帮助的。这些重写规则确保运行时对象不能做编译器（以及你的代码）没有期望的事情。规则如下：
- en: The method signatures must match exactly in the parent and subclass; otherwise,
    you are just overloading the method.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法签名必须在父类和子类中完全匹配；否则，你只是在重载方法。
- en: The return types must match also, except for covariant returns.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型也必须匹配，除了协变返回。
- en: The access modifier on the overriding method cannot be more restrictive. So,
    if the parent method defines a method as `public`, the subclass cannot override
    it with a `private` method. This makes sense, as your code, verified by the compiler,
    is expecting access to the method. *If*, however, you were allowed to reduce access
    when overriding, the compiler would have said “It is okay to access this method,”
    whereas the JVM would not! This rule helps keep the compiler and JVM in sync.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写方法上的访问修饰符不能更严格。所以，如果父方法将方法定义为`public`，子类不能使用`private`方法来重写它。这很有意义，因为你的代码，经过编译器的验证，期望可以访问该方法。然而，如果你被允许在重写时降低访问级别，编译器会说“可以访问这个方法”，而JVM则不会！这条规则有助于保持编译器和JVM同步。
- en: Again, to keep the compiler and JVM in sync, an overriding method cannot throw
    (generate) new or broader checked exceptions ([*Chapter 11*](B19793_11.xhtml#_idTextAnchor266)).
    Briefly, an exception is an error and checked exceptions must have code present
    to handle them. This is enforced by the compiler. If, at runtime, the overriding
    method threw/generated an exception for which there was no code to handle it,
    the JVM would be in trouble. So, the compiler steps in and prevents that from
    happening.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，为了保持编译器和JVM同步，重写方法不能抛出（生成）新的或更广泛的已检查异常（[*第11章*](B19793_11.xhtml#_idTextAnchor266)）。简而言之，异常是一个错误，已检查异常必须有代码来处理它们。这是由编译器强制执行的。如果在运行时，重写方法抛出/生成了一个没有代码来处理的异常，JVM就会遇到麻烦。因此，编译器介入并阻止这种情况发生。
- en: Now, let’s look at an example of method overriding in code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码中方法重写的一个例子。
- en: Method overriding example
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重写示例
- en: '*Figure 9**.8* presents the example code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.8*展示了示例代码：'
- en: '![Figure 9.8 – Method overriding](img/B19793_09_8.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 方法重写](img/B19793_09_8.jpg)'
- en: Figure 9.8 – Method overriding
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 方法重写
- en: The code in this figure demonstrates what you can and cannot do when overriding
    a method. In the `Dog` class (lines 5-8), we have a `walk()` method that returns
    nothing (`void`). There is also a `run()` method that returns `Dog`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该图中的代码演示了在重写方法时可以做什么和不能做什么。在`Dog`类（第5-8行）中，我们有一个返回无内容（`void`）的`walk()`方法。还有一个返回`Dog`的`run()`方法。
- en: The `Terrier` class subclasses from `Dog` (line 9). Therefore, any `Terrier`
    “is-a” `Dog`. As the two methods in `Dog` are `public`, `Terrier` automatically
    inherits them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Terrier`类从`Dog`类继承（第9行）。因此，任何`Terrier`都是`Dog`的子类。由于`Dog`中的两个方法都是`public`，`Terrier`自动继承它们。'
- en: Let’s examine the lines in `Terrier` in turn.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次检查`Terrier`中的行。
- en: Line 10 does not compile because, while the method signatures match (both are
    `walk()`), the return types are different. The parent return type is `void` and
    thus, the overriding return type must match; it does not, it is `String`, causing
    the compiler error.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第10行无法编译，因为虽然方法签名匹配（两者都是`walk()`），但返回类型不同。父类返回类型是`void`，因此，重写返回类型必须匹配；它不匹配，是`String`，导致编译器错误。
- en: Line 11 does not compile because you cannot weaken the access modifier when
    overriding. The `walk()` method in `Dog` is `public`, so `walk()` in `Terrier`
    cannot be `private`. *If* this was allowed, then when the JVM went to execute
    the `walk()` method in `Terrier`, using a `Dog` reference (as on line 24), there
    would be a serious problem. The compiler, looking at the `public` `Dog` version,
    said “All is well;” but the JVM would, polymorphically, encounter the `private`
    version in `Terrier`!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第11行无法编译，因为在重写时不能弱化访问修饰符。`Dog`中的`walk()`方法是`public`，所以`Terrier`中的`walk()`不能是`private`。*如果*这被允许，那么当JVM执行`Terrier`中的`walk()`方法时（如第24行所示），将会有严重问题。编译器查看`public`的`Dog`版本，会说“一切正常；”但JVM会多态地遇到`Terrier`中的`private`版本！
- en: Line 12 fails to compile because the overridden method did not throw any exceptions
    but the overriding method is attempting to throw a new checked exception (`IOException`).
    This is similar to the previous access issue – the compiler will have checked
    the `walk()` version in `Dog` and as it throws no exceptions (errors), no code
    is present to handle (cater) for these exceptions. *If* the overriding method
    was allowed to throw new checked exceptions, what would the JVM do with them (as
    there is no code in place to handle them)?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第12行无法编译，因为被重写的方法没有抛出任何异常，但重写的方法正在尝试抛出一个新的已检查异常（`IOException`）。这与之前的访问问题类似——编译器将检查`Dog`中的`walk()`版本，并且因为它没有抛出异常（错误），没有代码来处理（适应）这些异常。*如果*重写方法被允许抛出新的已检查异常，JVM将如何处理它们（因为没有代码来处理它们）？
- en: Line 13 is simply an overload. `Dog` defines a `walk()` method; `Terrier` defines
    a `walk(int)` method. Two separate method signatures means two separate methods.
    As the methods have the same name, this is method overloading.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第13行只是一个重载。`Dog`定义了一个`walk()`方法；`Terrier`定义了一个`walk(int)`方法。两个不同的方法签名意味着两个不同的方法。由于方法具有相同的名称，这属于方法重载。
- en: Line 14 is a correct method override. We used the `@Override` annotation to
    ensure that we have overridden properly (no typos, for example).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第14行是一个正确的方法重写。我们使用了`@Override`注解来确保我们已经正确地重写了（例如，没有打字错误）。
- en: Line 16 is an exact duplication of the `run()` method defined on line 7\. We
    just included it for demonstration purposes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第16行是第7行定义的`run()`方法的精确复制。我们只是为了演示目的而包含它。
- en: Line 17 demonstrates covariant returns because it defines a `Terrier` return
    type. This is a valid covariant return because `Terrier` is a subtype of the parent
    return type, `Dog` (line 7). The code for the overridden method (line 17) simply
    returns a `Terrier` object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第17行展示了协变返回，因为它定义了`Terrier`返回类型。这是一个有效的协变返回，因为`Terrier`是父类返回类型`Dog`（第7行）的子类型。重写方法的代码（第17行）简单地返回一个`Terrier`对象。
- en: 'Line 18 is almost identical to line 17 except that the return type is now `Dog`.
    Thus, there is an upcast going on in the background. The code for `walk()` on
    line 18 is shorthand for the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第18行几乎与第17行相同，除了返回类型现在是`Dog`。因此，在后台发生了向上转型。第18行的`walk()`代码是以下代码的简写：
- en: '[PRE6]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let’s look at the `main()` method in `OverridingTest`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`OverridingTest`中的`main()`方法。
- en: Line 23 creates a `Terrier` object that can be accessed via a `Dog` reference,
    `dt`. Line 24 invokes the polymorphic `walk()` method in `Terrier`. As `Terrier`
    overrode the `walk()` method it inherited from `Dog`, the `Terrier` version is
    dynamically executed at runtime, resulting in `Terrier::walk()` being output.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Line 25 executes the `run()` method using the `dt` reference created on line
    23\. As `run()` is an instance method where `Terrier` overrode the version inherited
    from `Dog`, the version in `Terrier` is executed, resulting in the `d` reference
    (line 25) referring to a `Terrier` object (line 18). This is proven by the use
    of the `instanceof` operator (line 26). As the `Dog` reference, `d`, is indeed
    referring to a `Terrier` object, the `if` statement is `true`, resulting in *Terrier
    object* being output to the screen.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'That concludes our discussion of method overloading and method overriding.
    Now, let’s examine a keyword that is pivotal in inheritance: `super`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the super keyword
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `super` keyword is used in a subclass in two specific scenarios: to call
    a parent constructor and to access parent members (typically methods). When an
    object is constructed, the order of constructor calls is very important. Bearing
    in mind that we now have the possibility of having many classes in an inheritance
    hierarchy, *the order of constructor calls is from the top down*. This means that,
    the parent constructor is *always* called before the subclass constructor. If
    you have a hierarchy where `Toyota` “is-a” `Car` and `Car` “is-a” `Vehicle`, then
    when you go to create a `Toyota` object, the order of constructor calls is as
    follows: `Vehicle` is first, `Car` is second, and `Toyota` is last.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: There is a good reason for this. Firstly, remember that the constructor’s role
    is to initialize the instance members of the class. Now, given that the subclass
    constructor *may use inherited members* from its parent when initializing its
    own members, it stands to reason that the parent must first get a chance to initialize
    those members.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the situations where the `super` keyword is very often used. We
    will then present code, supported by a UML diagram, where both contexts are demonstrated.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: super()
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the parentheses after `super`, as in `super()`, you are invoking
    the parent constructor. If required, you can pass in arguments inside the parentheses
    as constructors are just (special) methods. There are two rules for the use of
    `super()`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The call to `super()` can only appear inside a constructor and not a regular
    method
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If present, the call to `super()` must be the very first line in the constructor
    (there is one exception – see the callout)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have coded several constructors so far and none of them had a call to `super()`
    present. How did that work? Well, if you *do not* provide any constructor at all,
    the default constructor will be synthesized by the compiler for you and its first
    line of code is `super();`. Please refer back to *Figure 8**.1* and *Figure 8**.2*
    for examples of this. If you *do* provide a constructor, then the compiler will
    also insert `super();` as the first line (unless the first line is already a call
    to `super()` or `this()` ).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The first line of any constructor
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The very first line of any constructor is `this()` or `super()`. You cannot
    have both. A call to `this()` is a call to another constructor in the same class.
    From the inheritance hierarchy perspective, this is a sideways call. Remember
    that the parent constructor must be called before the subclass constructor. Regardless
    of whether `this()` is present or not, the order of constructor calls is from
    the top down. Now, if the subclass constructor has a `this()` call present, it
    is only delaying the call to `super()`. At some point, either explicitly or implicitly,
    the call to `super()` will execute. Note that, as with `super()`, the call to
    `this()` can contain arguments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: So, `super()` relates only to constructors and must be the first line of code
    (assuming `this()` is not there already). Now, let’s examine the other scenario.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: super.
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access a parent member (not the constructor), you can use the `super.` dot
    notation syntax. As with the `this` keyword, the `super` keyword relates to instances
    and thus cannot be used from within a `static` context (`static` methods or `static`
    blocks). This can be very useful when you want to piggyback on parent functionality.
    For example, the subclass method can invoke its parent version first and then
    execute its own version. This is what we will demonstrate in the example.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: So, rather than call a parent constructor from a subclass constructor (which
    is what `super()` is for), `super.` gives us access to the other (non-constructor)
    members.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: An example of using super
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine both `super()` and `super.` in code. *Figure 9**.9* presents
    the UML inheritance diagram:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – UML for demonstrating super() and super.](img/B19793_09_9.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – UML for demonstrating super() and super.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have three classes representing a class inheritance hierarchy.
    `Employee` is at the top of the hierarchy. `Manager` “is-a” `Employee` and `Director`
    “is-a” `Manager`. Indirectly, `Director` “is-a” `Employee` also. Each of the classes
    has `private` instance variables that its respective constructors will initialize,
    based on the arguments passed into the respective constructor. For example, the
    `Employee` constructor takes in two parameters, `int` followed by `String`; these
    parameters will be used to initialize the `Employee` instance variables, namely
    `empId` (`int`) and `name` (`String`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`EmployeeTest` is simply the driver to ensure the code is working as it should.
    Let’s examine the code. *Figure 9**.10* is the code for the UML in *Figure 9**.9*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Code demonstrating super](img/B19793_09_10.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Code demonstrating super
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the `Employee` class initializes its instance variables (lines
    8-9). The `toString()` method for `Employee` (line 11) returns a `String` outlining
    the values in the `empId` and `name` instance variables. Line 11 also uses the
    `@Override` annotation because it is overriding the `toString()` method inherited
    from `Object`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The `Manager` class “is-a” `Employee` (line 13). `Manager` contains (is composed
    of) a `String` instance variable, namely `deptName`. This is known as composition.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Composition versus inheritance
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Composition defines a *“has-a”* relationship whereas, inheritance defines an
    *“is-a”* relationship. Composition is where an object is “composed” of other objects.
    For example, `Car` has `Engine`. In *Figure 9**.10*, `Manager` “is-a” `Employee`
    (line 13), but `Manager` “has-a” department, which is represented by the `String`
    instance variable `deptName` (line 14).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The `Manager` constructor (lines 16-19) is where things get interesting. Line
    17, `super(empId, name)`, is the call to the parent constructor in `Employee`
    passing up the employee ID (`empId`) and employee name (`name`) that are required
    by the `Employee` constructor. That is why the `Manager` constructor requires
    those parameters in the first place – it needs the employee ID and employee name
    so it can invoke its parent `Employee` constructor. The `Manager` constructor
    also requires the department name so that it can initialize its own instance variable,
    `deptName`. Thus, when executing a `Manager` constructor, the `Employee` constructor
    is executed first and then the `Manager` constructor executes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Note that if line 17 is commented out, the code will not compile. Why? Because
    the compiler will now insert `super()`; which is attempting to call the `Employee`
    constructor with no-arguments (the `no-args` constructor, namely `Employee()`).
    There is no such constructor in `Employee`. Additionally, as `Employee` has already
    defined a constructor, the compiler will not insert the default (`no-args`) constructor.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The `Manager` classes’ `toString()` method (lines 21-24), overrides the version
    inherited from `Employee`. However, `Manager` can still access the `Employee`
    version, which it does by using `super.toString()` on line 23\. Thus, the `toString()`
    method in `Manager` first executes the `toString()` method in `Employee`, which
    returns the employee ID and employee name. The `Manager` classes’ `toString()`
    method then appends its own instance variable, `deptName`, to the overall `String`
    to be returned.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Director` class behaves similarly to `Manager`. The constructor “supers
    up” (line 30) the required data for the `Manager` constructor; in turn, the `Manager`
    constructor supers up the required data for the `Employee` constructor. So, when
    creating a `Director` object, the order of constructor calls is as follows: `Employee`
    is first; `Manager` is second; `Director` is last. On line 31, `Director` initializes
    its own instance data.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The `Director` version of `toString()`, on line 33, first calls the `Manager`
    version of `toString()` using `super.toString()`. The `Manager` version (line
    23) then calls the `Employee` classes’ `toString()` method, which is on line 11\.
    So, the employee’s ID and name are the first employee details in the string. Next,
    the manager data (`deptName`) is appended (after the call to the `Employee` classes’
    `toString()` method returns). Lastly, the `Director` data (`budget`) is appended
    to the string (after the call to the `Manager` classes’ `toString()` method returns).
    Note that you cannot bypass a level in the hierarchy; meaning that, `super.super.`
    is not allowed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`EmployeeTest` is the driver class. In `main()` on line 39, we create a `Director`
    object that can be accessed via an `Employee` reference of `emplDir` (implicit
    upcasting). Using `super()` as outlined, this results in the `Employee` constructor
    being executed first, followed by the `Manager` constructor, and lastly the `Director`
    constructor being executed.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 40 passes the `emplDir` reference to `System.out.println()`, resulting
    in a polymorphic call to the `Director` classes’ `toString()` method. Using `super.toString()`,
    `Director` invokes the `Manager` classes’ `toString()` method, which also has
    a `super.toString()` method resulting in `Employee` `toString()` being executed
    first. Then, the `Manager` classes’ `toString()` method finishes, and lastly,
    the `Director` classes’ `toString()` method finishes. The output shows this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Regarding the output, `ID: 754, Name: Joe Bloggs` is output from `Employee
    toString()`, `Department: Marketing` is output from the `Department toString()`,
    and `Budget: 10000.0` is output from `Director toString()`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our discussion on `super`. Now that we understand inheritance,
    as promised in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), let’s return to
    the `protected` access modifier.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the protected access modifier
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall that a `protected` member is accessible from within its own package
    and any subclasses outside of the package: *protected = package + children*. On
    the face of it, this seems very straightforward. However, some nuances lead to
    confusion. The subclasses that access the `protected` member (via inheritance),
    can only do so *in a very specific way*. A subclass from outside the package cannot
    use a superclass reference to access the `protected` member! In addition, an unrelated
    class from outside the package cannot use a reference to the subclass outside
    the package either to access the `protected` member. In effect, once the subclass
    that’s outside the package inherits the `protected` member, that member becomes
    `private` to the subclass (and subclasses of the subclass). This is quite tricky
    and definitely needs an example.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The UML diagram
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.11* shows the UML diagram for this example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – UML for “protected” code](img/B19793_09_11.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – UML for “protected” code
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have two packages, namely `ch9.pkgA` and `ch9.pkgB`. In `ch9.pkgA`,
    we have a `Book` class and its subclass, `NonFictionBook`. The `read()` method
    in `Book` is marked with the `#` symbol, which means it is `protected`. The `Magnifier`
    class is not related to `Book` and is simply another class in the same package.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In `ch9.pkgB`, `FictionBook` subclasses `Book` from `ch9.pkgA` and provides
    a `doThings()` method, which we will use to demonstrate what is/is not allowed.
    In addition, `SpaceFictionBook` subclasses `FictionBook` and overrides the `doThings()`
    method inherited from `FictionBook`. Lastly, `Reader` is a completely separate
    class from the `Book` hierarchy; its `doThings()` method is also a sample method
    for demo purposes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Recall from the previous chapter that we had not fully completed the access
    modifiers table (as we had not covered inheritance at that point). *Table 9.1*
    represents the completed access modifiers table. Bear in mind that the table represents
    annotating a member in the `Book` class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 - Access modifiers table with ‘protected’ row fully filled out](img/B19793_09_Table_01.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Table 9.1 - Access modifiers table with ‘protected’ row fully filled out
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Examining the `protected` row, we can now see that subclasses, regardless of
    the package, can access inherited protected members.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Now let us examine the code for each of the packages in turn. Firstly, we will
    examine the package that defines the `protected` member.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The package with the protected member
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.12* shows the code for the first package, `ch9.pkgA`, from *Figure
    9**.11*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Code for “ch9.pkgA” from UML](img/B19793_09_12.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Code for “ch9.pkgA” from UML
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a class called `Book` (lines 3-5) that defines a `protected`
    `read()` method (line 4). `NonFictionBook` is a subclass of `Book` and has its
    own `doThings()` method (lines 7-9). In addition, there is a completely unrelated
    class to `Book`, namely `Magnifier`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that, as the `read()` method is `protected`, other
    code in the same package can access it, even if the code is *not* a subclass.
    This is demonstrated by line 14, where the `read()` method in `Book` is accessed
    from `Magnifier`, a completely unrelated class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Of course, regardless of the package, subclasses can access the `protected`
    member. This is shown on line 8, where the `NonFictionBook` subclass invokes `read()`.
    Remember that line 8 is essentially `this.read()`. So, whichever `NonFictionBook`
    object is used to invoke `doThings()` on line 7 will be used to invoke the inherited
    (and `protected`) `read()` method on line 4.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The interesting code is in the other package, namely `ch9.pkgB`. Let’s examine
    that now.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The other package
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.13* presents the code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Code for “ch9.pkgB” from UML](img/B19793_09_13.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Code for “ch9.pkgB” from UML
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we can see that `FictionBook` “is-a” `Book` (line 5) and `SpaceFictionBook`
    “is-a” `FictionBook` (line 19). For this hierarchy to be possible, the `Book`
    class needed to be imported from the other package (line 3). We were only able
    to import `Book` from another package because `Book` is a `public` class. In addition,
    we have a completely unrelated class called `Reader` (lines 27-36).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the fun! Let’s examine the `dothings()` method in `FictionBook` (lines
    6-17). Lines 7 and 8 are essentially equivalent and show that subclasses outside
    the package, when using *inheritance directly*, can access `protected` members.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Lines 9-10 also show that when inside the subclass outside the package, if you
    create an instance of that particular subclass (`FictionBook`, in this instance),
    then all is ok. This makes sense because the two references used to invoke `read()`
    without issue, namely `this` and `fb`, are both of type `FictionBook`, where the
    code resides.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Note that line 15, where we instantiate a `Book` object, compiles because the
    `Book` class (*Figure 9**.12*, line 3) is `public`. The `Book` class did not define
    a constructor, so the default constructor was created for us. This default constructor
    takes on the same access as the class, namely `public`, and as a result, we can
    invoke the constructor from a different package.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Line 16, which does not compile, is very interesting. When inside the subclass
    outside the package, you cannot access the `protected` member using the superclass
    reference – even though the `protected` member resides in that superclass! Remember
    that, once outside the package, the `protected` member becomes `private` to subclasses
    (and their subclasses). In other words, you must use inheritance in a very specific
    way.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '`SpaceFictionBook` (lines 19-26) shows that access is available to subclasses
    of the subclass outside the package. Line 21 is the same as line 7, except that
    they are in two separate classes. As this line compiles, it demonstrates that
    subclasses of the subclass outside the package have access to the `protected`
    member in the base class.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Lines 22 and 23 both fail to compile. Line 22 tries to access the `protected`
    member via a `Book` reference and line 23 tries to access it via a `FictionBook`
    reference. Both fail. Contrast this with line 24, which uses an instance of the
    current class, namely `SpaceFictionBook`, which works. Note that line 24 is similar
    to line 21 in that a `SpaceFictionBook` reference is used in both instances (as
    line 21 is equivalent to `this.read()`). In addition, line 24 is very similar
    to lines 9-10\. Therefore, when in a subclass outside the package, access the
    `protected` member directly, as on lines 7, 21; or use a reference to the current
    subclass, as on lines 10, 24.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The `Reader` class (lines 27-36) is a completely separate class from the `Book`
    hierarchy. Line 30 attempts to access the `protected` member using a reference
    to the class that defines the `protected` member, namely `Book`, and fails. Line
    34 attempts to access the `protected` member using a reference to the subclass
    outside the package that inherits the `protected` member, namely `FictionBook`,
    and also fails.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: So `protected` is somewhat tricky. While we are revisiting previous topics,
    it is an ideal opportunity to revisit `switch`. To be more specific, to discuss
    pattern matching for `switch`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for switch
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As promised from [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087), now that
    we understand inheritance and polymorphism, we are going to revisit the `switch`.
    Given the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Assume that `Car`, `Boat`, and `Train` all extend from `Vehicle` and that `Car`
    has a custom method `onRoad()`. As you can see, in this `switch` expression, the
    selector expression, `v`, can be any reference type (`Boat`, `Train`, `Car`, and
    so forth). The `case` labels demonstrate *type patterns and pattern matching*;
    for example, `Boat b`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In addition, both `case` labels for `Car` are known as *guarded patterns*. A
    guarded pattern is a `case` label protected by a “guard” on the right-hand side
    of a `when` clause. A guard is a conditional expression, evaluating to true or
    false. Note the use of the custom `Car` method `onRoad()` and the fact that no
    cast is required, as the cast is done for us in the background (provided we are
    dealing with a `Car`).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The last case `label`, containing `default`, ensures exhaustiveness is catered
    for, thereby keeping the compiler happy. In other words, all possible `Vehicle`s
    are catered for. Note also the use of `null` as a valid label and the fact that
    `null` and `default` can be comma separated.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the effect on inheritance of two particular keywords, namely
    `abstract` and `final`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the abstract and final keywords
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, when coding methods, we can apply the access modifier keywords,
    namely `private`, `protected`, `public`, and package-private (no keyword). Two
    other keywords have special significance regarding inheritance: `abstract` and
    `final`. Both are opposites of each other, which is why both cannot be applied
    to a method at the same time. Let’s discuss them now, starting with `abstract`.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The abstract keyword
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `abstract` keyword is applied to classes and methods. While `abstract`
    classes will be discussed more fully in [*Chapter 10*](B19793_10.xhtml#_idTextAnchor249),
    we will be discussing them here also (for reasons that will soon become obvious).
    An `abstract` method has no implementation (code). In other words, the method
    signature, rather than following it with curly braces, `{}`, which represents
    the implementation, an `abstract` method signature is simply followed by a semi-colon.
    Marking a method as `abstract` implies the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The class must be `abstract` also
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first concrete (non-`abstract`) subclass must provide an implementation
    for the `abstract` method
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s discuss this in more detail. When you mark a method (or methods) as `abstract`,
    you are saying that this method has no implementation code. As there is something
    “missing,” the class itself must be marked as `abstract` also. This tells the
    compiler that the class is incomplete and as a result, you cannot instantiate
    (create) an object based on an `abstract` class. In other words, you cannot execute
    `new` on an abstract class (although a reference is perfectly ok). The whole rationale
    for `abstract` methods (and thus `abstract` classes) is for them to be overridden
    by subclasses, where the “missing” implementation code is provided. Now, if the
    direct subclass does not provide the implementation code for the inherited `abstract`
    method, that subclass must also be `abstract`. Therefore, the first non-abstract
    (concrete) subclass of an `abstract` class must provide the implementation code
    for the `abstract` method. *Figure 9**.14* demonstrates these principles:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The “abstract” keyword in action](img/B19793_09_14.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The “abstract” keyword in action
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an `abstract` method, namely `write()`, on line 4\.
    Notice how there are no curly braces for the method; we just have the semi-colon
    immediately after the parentheses. As the `Pencil` class (lines 3-5) contains
    an `abstract` method, the class itself must be `abstract`; which it is (line 3).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: On line 6, `CharcoalPencil` attempts to subclass `Pencil`. But because (a) it
    does not provide an implementation for the `abstract` method `write()`, which
    it inherited from `Pencil`, and (b) `CharcoalPencil` *itself* is not `abstract`,
    `CharcoalPencil` fails to compile.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Contrast line 6 with line 7\. As we saw, line 6 does not compile. However, line
    7, `WaterColorPencil`, does compile. Why? Because `WaterColorPencil` is `abstract`;
    the fact that it does not provide an implementation for the `abstract` method
    `write()` is no problem.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes do not have to have abstract methods
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: As we know, if you have 1 (or more) `abstract` methods, then the class must
    be `abstract`. However, the opposite is not true. In other words, an `abstract`
    class does not have to have any `abstract` methods at all! Note that `WaterColorPencil`
    (line 7 in *Figure 9**.14*) is an example of such a class. It is `abstract` and
    yet has no methods at all. This is fine. This could be a design decision whereby,
    even if the class contains only concrete methods, you simply want this class to
    be used as a reference type and not as an object type (as you cannot `new` it).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The `GraphitePencil` class (lines 8-13) is a concrete, non-abstract class. As
    it `extends` the `abstract` class, `Pencil`, it must provide an implementation
    for the `abstract` method `write()`. This is done on lines 10 to 12 and we use
    the `@Override` annotation to emphasize this.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Line 17 demonstrates that you cannot instantiate an object of an `abstract`
    class. The reference part of the `Pencil pp` statement is fine. The issue is with
    the `new` `Pencil()` part.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Line 18 shows what is allowed. Again, we are using a `Pencil` reference but
    this time, we are referring to a `GraphitePencil` object. `GraphitePencil` is
    a concrete class (line 8). Line 19 polymorphically calls the `write()` method
    provided by `GraphitePencil` (lines 10-12). Assuming lines 6 and 17 are commented
    out (so the code will compile), line 19 outputs `GraphitePencil::write()`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand `abstract` methods and classes, let’s examine the `final`
    keyword.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The final keyword
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `final` keyword can be applied in various contexts. Inheritance is the main
    focus here, but we will examine other situations also. We will examine each in
    turn and then look at code that demonstrates them. We will start with `final`
    methods.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: final methods
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `final` method cannot be overridden in a subclass. This prevents any unwanted
    changes by subclasses. We can take this a stage further with `final` classes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: final classes
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class that is marked `final` cannot be used as a base type. This means you
    cannot extend from a `final` class. All the methods in the class are implicitly
    `final`. Java uses this in its API to guarantee behavior. For example, the `String`
    class is `final` so that nobody can extend it and provide a custom implementation.
    Therefore, Java always knows how strings behave. Now, we will examine `final`
    method parameters.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: final method parameters
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `final` method parameter is a parameter that cannot be changed. However, be
    aware that the semantics are subtly different depending on the parameter type.
    If the parameter type is a primitive, such as `int`, then you cannot change the
    value of the `int` parameter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: However, if the parameter in question is a reference (as opposed to a primitive),
    `final` applies to the reference and therefore, it is the reference that cannot
    be changed. In other words, the object the reference is pointing to is modifiable,
    but the reference itself is not. What this means is that, for example, if the
    method accepts a `Dog` reference, namely `dog`, then using the `dog` reference,
    you can change the properties of the object, such as `dog.setAge(10)`. You cannot,
    however, change `dog` to refer to a different object, such as `dog =` `new Dog()`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: final (constants)
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A constant is a value that cannot change. It is customary and good practice
    to use capital letters as the identifiers for constants, with each word separated
    by an underscore. This makes them stand out and developers know they cannot change
    them. One example from the Java API is the *PI* constant from the `Math` class
    (in the auto-imported `java.lang` package). It is `final` so that it cannot be
    changed. To provide easy access, *PI* is also `public` and `static`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a code example to re-enforce the use of `final`. *Figure
    9**.15* presents the code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The “final” keyword in action](img/B19793_09_15.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The “final” keyword in action
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a `final` class called `Earth` (line 3). Line 5 demonstrates,
    via a compiler error, that you cannot extend from a `final` class.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Line 8 defines a `final` method called `write()` in the `Pen` class. Consequently,
    the `FountainPen` class encounters a compiler error (line 15) when attempting
    to override `write()`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Line 11 shows that you cannot annotate a method as both `abstract` and `final`
    – `abstract` implies that this method is to be overridden in a subclass; `final`
    means that this method must not be overridden.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Line 18 declares a constant called `ONE_YEAR` and sets it to `1`. Line 27 attempts
    to change the constant value – as this is not allowed, the compiler complains.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` method (lines 19-28) outlines what `final` means for method parameters.
    The method parameters (line 19) are `final String name` and `final int age`, respectively.
    `String` is a non-primitive type and therefore `name` is a reference. In other
    words, the value inside `name` is a memory location (reference) of where the object
    is on the heap. On the other hand, `age` is simply a primitive `int`, whose value
    is simply a whole number, such as `1`. It is easy to understand what you can and
    cannot do with `final` parameters when you view the *value* as `final`. Thus,
    if `1` is in `age`, it cannot be changed and neither can the reference (address)
    in `name`. However, the object referred to by `name` can be modified.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Line 21 is a compiler error and demonstrates that `final` primitives cannot
    be changed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Line 23 shows us that the object that the reference is referring to can be accessed
    (and changed if required). Note that, in this particular example, as `String`s
    are immutable objects, the `toUpperCase()` method returns the new, uppercase `String`,
    as opposed to changing the original. We will talk more about `String`s in [*Chapter
    12*](B19793_12.xhtml#_idTextAnchor293). The important thing to note is that the
    compiler had no issue with line 23.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Line 25 attempts to change the `String` reference `name` to refer to a different
    `String`. As the reference is `final`, the compiler complains. Once again, the
    separation of reference and object makes things much easier to understand.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we know how to create (unlimited) inheritance hierarchies (using
    `extends`). We also know that `final` disables inheritance. What if we wanted
    a “middle ground,” where we could customize our hierarchy to certain types? This
    is what sealed classes enable. Let’s discuss them now.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Applying sealed classes
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sealed classes were introduced in Java 17\. What we are going to cover here
    relates to classes but the same logic applies to interfaces ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249)).
    With inheritance, you can extend from any class (or interface) using the `extends`
    keyword, unless the class is `final` of course.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces cannot be `final` because their whole rationale is to be implemented.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario: what if you wanted your class to be available
    for inheritance, but only for certain classes? In other words, you want to scope
    the subclasses allowed. So far, inheritance, using `extends`, enables every class
    to become a subclass, whereas `final` prevents a class from having subclasses.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: This is where sealed classes are useful – they enable you to specify what subclasses
    are allowed. Just to reiterate, this also applies to interfaces, where we can
    specify what classes are allowed to implement the interface.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at an example, there are some new keywords that we need to understand.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: sealed and permits
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These keywords work together. To state that a class is sealed, you can simply
    specify that it is just that, `sealed`. Once you do that, however, you must specify
    which classes can extend from this class. To do that, you use the `permits` keyword,
    followed by the comma-separated list of classes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: non-sealed
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you start to scope/restrict a hierarchy, you must use certain keywords
    when specifying the subclasses. A subclass involved in a sealed hierarchy must
    state one of the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: It is also sealed. This means, we have further scoping to perform and therefore
    we must use the `sealed`/`permits` pairing on this subclass to specify the subclasses
    allowed.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the `final` class in the hierarchy (no more subclasses allowed).
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ends the scoping. In effect, you want to open up the hierarchy again for
    extension. To do this, we use the `non-sealed` keyword as `non-sealed` classes
    can be subclassed.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s look at an example.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Example using sealed, permits, and non-sealed
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 9**.16* presents a UML diagram for the code example we will use:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – UML diagram for “sealed” classes](img/B19793_09_16.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – UML diagram for “sealed” classes
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a `Vehicle` hierarchy. The parts we are going to restrict
    (seal) are the `Vehicle`, `Car`, and `Saloon` classes. Therefore, the only class
    that can subclass `Vehicle` is `Car`; and the only class that can subclass `Car`
    is `Saloon`. Note that even though the diagram implies `Truck` “is-a” `Vehicle`
    and `Convertible` “is-a” `Car`, for this example, we will prevent that in code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the code is to ensure that the only `Vehicle`s we are interested
    in are `Car`s and the only `Car`s we are interested in are `Saloon`s. In addition,
    all `Saloon`s (`Ford` and `Volvo`) are of interest. *Figure 9**.17* presents the
    code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – “sealed” code](img/B19793_09_17.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – “sealed” code
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, line 3 states that we have a `sealed` class called
    `Vehicle` and that the only subclass allowed (permitted) is `Car`. At this point,
    the `Car` class must exist; otherwise, the compiler will complain.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Line 4 defines a sealed class called `Car` as a subclass of `Vehicle` (which
    it must do due to line 3) and that the only subclass permitted is `Saloon`. Note
    that when we were defining `Car`, we had to specify that `Car` was either `sealed`,
    `non-sealed`, or `final`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Line 5 is the `Truck` class attempting to subclass `Vehicle`. However, as we
    have sealed `Vehicle` to only allow `Car` as a subclass, this generates a compiler
    error.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Line 6 defines `Saloon` as a subclass of `Car` (as expected from line 4). In
    this instance, we have chosen to open up the hierarchy for further extension (by
    any class) by stating that `Saloon` is `non-sealed`. Lines 7 and 8 demonstrate
    that `Saloon` is a non-sealed class by allowing `Volvo` and `Ford` to extend from
    it, respectively.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, on line 9, `Convertible` attempts to subclass `Car`. This is not allowed
    as line 4 states that the only subclass of `Car` allowed is `Saloon`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on now and discuss both instance and `static` blocks.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Understanding instance and static blocks
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, in Java, a block is delimited by curly braces, `{}`, and these code
    blocks are no different. What is different about instance and `static` code blocks
    is *where* these blocks appear – in other words, their scope. Both of these code
    blocks appear outside every method but inside the class.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss each in turn and then present a code example to demonstrate
    them in operation. We will start with instance blocks.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Instance blocks
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance block is a set of braces that appear outside of any method but inside
    the class. Assuming an instance block is present in a class, every time an object
    is created (using `new`), the instance block is executed. Note that the instance
    block executes *before* the constructor. To be technically accurate, `super()`
    is executed first so that the parent constructor has a chance to execute; this
    is followed by the instance block, after which the rest of the constructor executes.
    Use the “sic” (*s*uper, *i*nstance block, *c*onstructor) acronym to help remember
    the order. You can think of the compiler inserting the instance block into the
    constructor code just after the call to `super()`. If more than one instance block
    exists in a class, they are executed in order of appearance, from top to bottom.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: As instance blocks execute as part of every constructor, they are an ideal location
    for inserting code that you want every constructor to have. In other words, code
    that is common across all constructors should go into an instance block. This
    saves you from duplicating code across constructors.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the parent constructor must execute before the child constructor.
    The same occurs with instance blocks. In other words, the parent instance blocks
    must execute before the child instance blocks. We will see this in the code example.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: static blocks
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `static` block is a set of braces, preceded by the `static` keyword, that
    appears outside of any method but inside the class. The `static` block is only
    executed once, the very first time the class is loaded. This could occur when
    the first object of the class is created or the first time a `static` member is
    accessed. Static blocks execute before instance blocks (as we have to load the
    class file/bytecode before we can execute a constructor). Once executed, given
    that the class file is now loaded into memory, the `static` block is never executed
    again.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: As with instance blocks, if more than one `static` block exists in a class,
    they are executed in order of appearance, from top to bottom. Similarly, as with
    instance blocks, if inheritance is involved, then the parent `static` blocks execute
    before the child `static` blocks.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: This will all make a lot more sense with a code example, where we will be able
    to compare and contrast both types of code blocks in an inheritance hierarchy.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.18* presents the code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Instance and “static” code blocks example](img/B19793_09_18.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Instance and “static” code blocks example
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a parent class called `Parent` and a child class called
    `Child` (it took a while to come up with those names!). Both classes have two
    instance initialization blocks, two `static` initialization blocks, and a constructor.
    Notice that the `static` initialization blocks (lines 7, 12, 16, and 21) are all
    simply blocks of code preceded by the `static` keyword. Also, note their location/scope
    – outside the methods but inside the class. The same is true for the instance
    initialization blocks (lines 5, 11, 15, and 20), except that the instance blocks
    have no keyword preceding them.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The main driver class, `InitializationBlocks`, also has one `static` and one
    instance initialization block (lines 24 and 25, respectively).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these blocks simply outputs a tracer message so that we know which
    block of code is currently executing. The tracer messages are annotated with ascending
    numbers so we can follow the order of execution more easily. *Figure 9**.19*,
    presents the output from the code in *Figure 9**.18*:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Output from the code in Figure 9.18](img/B19793_09_19.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Output from the code in Figure 9.18
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: To avoid confusion between numbers representing output in *Figure 9**.19* with
    line numbers in *Figure 9**.18*, all numbers mentioned here refer to output numbers
    in *Figure 9**.19*. Any line numbers relating to *Figure 9**.18* will be explicitly
    annotated as “line....”
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: All Java programs start with the `main()` method. Therefore, the JVM has to
    find, using the `CLASSPATH` environment variable, the `.class` file containing
    `main()`, namely `InitializationBlocks.class`. As the JVM loads the class, if
    the class has a parent, it loads the parent first. In this example, as `InitializationBlocks`
    is not a subclass, this does not apply. However, there is a `static` block and
    this gives us our first line of output. Note that the instance block for `InitializationBlocks`
    is never executed. This is because no instance of `InitializationBlocks` was ever
    created. In other words, there is no `new` `InitializationBlocks()` in the code.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Line 27 simply outputs `"---> Creating first Child object…"`. What is interesting
    to note is that it is not the first line output to the screen – the output from
    the `static` block is first.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Line 28 creates a `Child` object. Its output is represented by numbers 2-11\.
    As this is the first time a `Child` object has been created (as no `static` member
    in `Child` has been accessed before this), the class file for `Child` is loaded.
    During this process, the JVM realizes that `Child` is a subclass of `Parent`,
    so it loads the `Parent` class first. Therefore, the `static` blocks in `Parent`
    are executed first, in order of appearance (2 and 3); followed by the `Child`
    static blocks, also in order of appearance (4 and 5).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `static` blocks are done, the instance blocks and constructors
    are executed. First, the superclass `Parent` instance blocks are executed in order
    of appearance (6 and 7), followed by the `Parent` constructor (8). Then, the subclass
    `Child` instance blocks are executed in order of appearance (9 and 10), followed
    by the `Child` constructor (11). That is a lot of processing from a simple `new
    Child()` line of code.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Line 29 simply outputs `"---> Creating second` `Child object…"`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Line 30 creates another `Child` object. As the class was already loaded previously,
    the `static` blocks will already have run for both `Child` and its superclass,
    `Parent`. Therefore, they do not run again. So, we run the `Parent` instance blocks
    (6 and 7), followed by the `Parent` constructor (8). Then, we run the `Child`
    instance blocks (9 and 10), followed by the `Child` constructor (11).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Note the repetition of line numbers 6-11 when creating a `Child` object. The
    `Parent` instance blocks are executed in order; followed by the `Parent` constructor.
    The `Child` instance blocks and constructor follow in a similar fashion.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'That covers `static` and instance initialization blocks. Before we conclude
    this chapter on inheritance, we would just like to delve a little deeper into
    one of the topics we touched on earlier: upcasting and downcasting.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Mastering upcasting and downcasting
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we touched upon why we get `ClassCastException` errors. The rule is
    that a reference can refer to objects of its own type or objects of subclasses.
    In effect, a reference can point across and down the inheritance hierarchy, but
    never up. If a reference does point up the hierarchy, you will get a `ClassCastException`
    error. Recall that the reason this occurs is that the subclass reference could
    have extra methods that any superclass object would have no code for. Whether
    that is the case or not is immaterial, *could have* is enough.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that assignment works from right to left; so, when reading code
    involving upcasting/downcasting, the direction in the hierarchy is from right
    to left as well. In addition, remember that the compiler is always looking at
    the reference type.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss, with the aid of code examples, both upcasting and downcasting.
    Let’s start with upcasting.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With upcasting, you are going from a more specific type “up to” a more general
    type. For example, let’s look at the following line of code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are going from `Car` *up* to `Vehicle`. The more specific type (`Car`)
    is further down the hierarchy and potentially has extra methods. Due to inheritance,
    whatever methods the parent reference has access to, the subclass will also have.
    So, any methods available to the `Vehicle` reference, `vc`, will exist in the
    `Car` object! Therefore, upcasting is never an issue, and an explicit cast is
    not required.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.20* presents upcasting in code:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Upcasting in action](img/B19793_09_20.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Upcasting in action
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a class called `Machine` (lines 3-5) and a subclass
    called `Tractor` (lines 6-9). The `on()` method in `Tractor` (line 7) overrides
    the `on()` method in `Machine` (line 4).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 involves an implicit upcast. Reading it right to left (as assignment
    is right to left), we are going from `Tractor` “up to” `Machine`. This is possible
    because every `Tractor` “is-a” `Machine`. Thus, line 15 results in a `Machine`
    reference referring to a `Tractor` object.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Line 16 invokes the `doAction()` method while passing in the reference created
    on line 15, namely `mt`. This `mt` reference is copied (remember Java is call
    by value) into the `Machine` reference, namely `machine`, on line 11\. Thus, the
    `mt` reference in the `main()` method and the `machine` reference in the `doAction()`
    method are pointing at the one and same object, which was created on line 15.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `doAction()` method, we invoke the `on()` method using the `machine`
    reference (line 12). As the `machine` references type, namely `Machine`, has an
    `on()` method, the compiler is happy. At runtime, the object that `machine` is
    referring to, namely `Tractor`, is used. In other words, the `on()` method from
    `Tractor` is dynamically executed (polymorphically).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 17 is just accomplishing in one line what was coded over lines 15 and
    16\. With the invocation of `doAction()` on line 17, the upcasting is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Machine` reference, namely `machine`, is provided by the `doAction()` signature
    (line 11), and the `Tractor` instance creation comes from line 17.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Both lines 16 and 17 result in the same output: `Tractor::on()`. Now, let’s
    discuss the trickier of the two: downcasting.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Downcasting
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With downcasting, you are going from a more general type “down to” a more specific
    type. For example, let’s look at the following line of code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reading it from right to left, we are going from `Vehicle` *down* to `Car`.
    Again, the more specific type (`Car`) is further down the hierarchy and potentially
    has extra methods. The compiler spots this and complains. We can overrule the
    compiler by inserting a (down)cast, `(Car)`. This is what we have done here. However,
    at runtime, this line of code results in a `ClassCastException` error. This is
    because, on the right-hand side of the assignment statement, we are attempting
    to create a `Car` reference that will point up the inheritance tree at a `Vehicle`
    object!
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.21* presents downcasting in code:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Downcasting in action](img/B19793_09_21.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Downcasting in action
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: The code in this figure is very similar to the code in *Figure 9**.20*. The
    inheritance hierarchy is the same. The changes are in the `doAction()` and `main()`
    methods. Line 12 works normally and we have commented it out to focus on downcasting.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Our goal, as stated on line 14, is to *safely* invoke the `Tractor` object’s
    `drive()` method. Note that this method is specific to `Tractor`. Let’s look at
    the changes in baby steps.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, as `drive()` is specific to `Tractor` (and not `Machine`), this means
    that we need a `Tractor` reference to get the code to compile. The fact that line
    15 does not compile demonstrates this – the `machine` reference is of the `Machine`
    type and `Machine` does not have a `drive()` method.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Line 16 addresses the compiler error from line 15\. Line 16 compiles because
    it (down)casts the machine reference to a `Tractor` reference *before* it calls
    the `drive()` method. That is why the extra set of parentheses are needed – method
    invocation has higher precedence than casting, so we change the order of precedence
    by using parentheses. Without the extra set of parentheses, we have `(Tractor)machine.drive()`,
    and this does not compile (for the same reason as line 15 does not compile). However,
    the extra set of parentheses forces the cast from `Machine` to `Tractor` to be
    performed first, and thus the compiler looks for `drive()` in `Tractor`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: However, we are still not “out of the woods.” Yes, the compiler is happy, but
    the JVM is vulnerable to `ClassCastException` errors at runtime. If line 16 were
    uncommented, then line 22 would cause a `ClassCastException` error at runtime.
    This is because line 22 passes in a `Machine` object, so inside the `doAction()`
    method, the `machine` reference is referring to a `Machine` object. Therefore,
    on line 16, we would be trying to create a `Tractor` reference to point *up* to
    the `Machine` object, which is a `ClassCastException` all day long.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Line 17 uses the `instanceof` keyword, in conjunction with a type pattern and
    pattern matching. Line 17 is only true if the reference `machine` refers to a
    `Tractor` object; when it is, the cast is done for us in the background and `t`
    is initialized to refer to the `Tractor` object. This is why line 22 outputs nothing
    – the `Machine` object passed in, fails the `instanceof` test and therefore line
    18 is *not* executed. However, as line 23 passes in a `Tractor` object, it passes
    the `instanceof` test. This means that line 18 is executed and outputs `Tractor::drive()`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: That completes another hugely important chapter. Now, let’s apply what we have
    learned!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our park is full of diversity, not just in the species of dinosaurs but also
    in the roles of our employees. To model this diversity, we will be incorporating
    the concept of inheritance into our applications:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Not all dinosaurs are the same. Some are small, others big. Some are herbivores,
    others carnivores. Create at least three subclasses for different types of dinosaurs
    that inherit from the base `Dinosaur` class.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you need inspiration, you can create a `FlyingDinosaur` subclass and an `AquaticDinosaur`
    subclass from the `Dinosaur` class, each with its unique properties. (This is
    not the most optimal way to model this, but don’t worry about that now.)
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just like our dinosaurs, our employees also have diverse roles. Some are park
    managers, while others are security officers or veterinarians. Create subclasses
    for these employee roles that inherit from the `Employee` base class. Come up
    with at least three subclasses.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance doesn’t just stop at properties and methods. Even the behavior of
    some methods can be customized in subclasses. Provide a custom implementation
    of the `toString()` method in the `Dinosaur` and `Employee` classes (from exercises
    1 and 2) and their subclasses to display detailed information about each object.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, override the `equals()` method in the `Dinosaur` and `Employee` classes
    to compare objects of these classes.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class called `App` with a `main` method. In there, add functionality
    to check if an employee is qualified to work in a specific enclosure, considering
    the employee’s role and the enclosure’s safety level.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The park offers regular tickets and season tickets. Create a `SeasonTicket`
    class that extends the `Ticket` class and add properties such as start date and
    end date.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will be developing a more advanced version of the Mesozoic Eden park manager
    console application. Your task is to implement the concept of polymorphism to
    handle different types of dinosaurs and employees. By incorporating polymorphism,
    the application can accommodate an even wider range of dinosaur species and employee
    roles. The key features of the system should now include the following:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: The ability to manage diverse types of dinosaur profiles, representing a variety
    of species
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to manage different types of park employee profiles that represent
    a variety of roles, such as park rangers, janitors, veterinarians, and more
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All previous features, such as editing and removing profiles, real-time dinosaur
    tracking, employee scheduling, guest admissions, and handling special events,
    should now accommodate these new varieties
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s what you need to do, broken down into smaller steps if you need it:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` classes into different subclasses to represent different
    types of dinosaurs and employee roles. Make sure these subclasses demonstrate
    the principle of polymorphism.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` objects, where each object could be an instance of
    any subclass.'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Update the interaction**: Modify your interactive console-based interface
    to handle the new types of dinosaurs and employees. You might need to add more
    options or submenus.'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enhance menu creation**: Your menu should now handle different types of dinosaurs
    and employees. Make sure each option corresponds to a particular function in the
    program.'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handle actions**: Each menu item should trigger a function that is now able
    to handle different types of dinosaurs and employees. For example, the “Manage
    Dinosaurs” option could now trigger a function to add, remove, or edit a profile
    of any dinosaur species.'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exit the program**: Ensure your program continues to provide an option for
    the user to exit the program.'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The starting code snippet will remain mostly the same as the previous one.
    However, when implementing `manageDinosaurs()`, `manageEmployees()`, and other
    similar functions, you’ll need to handle different types of dinosaurs and employees:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `manageDinosaurs()`, `manageEmployees()`, `manageTickets()`, `checkParkStatus()`,
    and `handleSpecialEvents()` methods now need to be updated to be able to handle
    the increased complexity.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined one of the cornerstones of OOP, namely inheritance.
    Inheritance defines an “is-a” relationship between the sub- and parent classes
    – for example, `Fox` “is-a” `Animal`, and `Train` “is-a” `Vehicle`. Inheritance
    promotes code reuse as inheritable base class members are automatically available
    to subclasses. Class inheritance is enabled via the `extends` keyword and interface
    inheritance is enabled via the `implements` keyword.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Regarding methods, the subclasses are free to override (replace) the base class
    implementation. This is how we enable another cornerstone of OOP, namely polymorphism.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is a feature where the instance method from the object is only
    selected at runtime. Hence, other terms for polymorphism are “late binding,” “runtime
    binding,” and “dynamic binding,” For polymorphism to work, the signature of the
    instance method in the subtype must match that of the parent method. The only
    caveat to that rule is covariant returns, where, in the overriding method, a subtype
    of the parent return type is allowed. The overriding method, when comparing it
    with its parent version, must not reduce the access privileges or add extra checked
    exceptions.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading, on the other hand, is where the method signatures must be
    different (apart from the matching method name). Thus, the number of parameters,
    their types and/or their order, must be different. The return type and parameter
    names do not matter (as they are not part of the method signature). Method overloading
    can occur at any level in the hierarchy.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: With inheritance, the reference type and object types are often different. As
    assignment works right to left, when we discuss upcasting and downcasting, we
    refer to going “up” or “down” the inheritance tree. Upcasting is always safe as
    the subtype will always have the methods accessible via the supertype reference.
    Downcasting, however, is not safe and requires a cast for the compiler to be happy.
    Even at that, if you end up creating a reference that is pointing up the hierarchy
    tree, you will get a `ClassCastException` error at runtime. Pointing up the hierarchy
    is not allowed because the subclass reference type could have methods that the
    parent type object has no code for.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: The `super` keyword is used in two situations. The first is to access the parent
    constructor using `super()`. This call is only allowed as the very first line
    in any constructor. If not coded explicitly, `super()` will be inserted by the
    compiler to ensure that the parent constructor executes before the subtype constructor.
    Construction occurs from the base down because a subtype may rely on parent members
    and thus, the parent must have a chance to initialize them first. The second scenario
    is accessing a parent member from subtype code, using `super.parentMember`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: We already know from [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), that the
    `protected` access modifier ensures members are available within the package and
    also to any subclasses, regardless of the package. We revisited this and demonstrated
    that, when accessing a `protected` member from a subclass in a different package,
    you have to do so, via inheritance, in a very specific way.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: An `abstract` method is a method with no code (implementation). Even though
    a class does not need to have any `abstract` methods to be `abstract` itself;
    once the class has even one `abstract` method, the class must be `abstract`. Any
    subclass of an `abstract` class must provide the implementation code for the `abstract`
    method(s) inherited, or the subclass must also be `abstract`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Concerning inheritance, a `final` class cannot be inherited from. A `final`
    method cannot be overridden. Other uses for `final` are for defining constants
    and ensuring that (the values of) method parameters are constant.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: The use of sealed classes enables us to restrict parts of a hierarchy to certain
    types. Rather than the general `extends`, which allows a class to subclass any
    base class it wants; and without turning off inheritance altogether using `final`;
    sealed classes achieve a custom restriction using the `sealed`, `non-sealed`,
    and `permits` keywords.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Instance and `static` initialization blocks are coded outside the methods but
    inside the class. The `static` block precedes the block with the `static` keyword.
    The instance uses no keyword (instance semantics are implied). Both enable initialization
    at various points. Static initialization occurs just once – the first time a class
    is loaded. Instance initialization occurs every time a constructor is called.
    Consequently, instance blocks are perfect locations for inserting code that is
    common across all constructors.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we took a deeper dive into upcasting and downcasting. This helped deepen
    our understanding as to why upcasting is not an issue, why downcasting needs a
    cast, and why we get `ClassCastException` errors. In addition, using the `instanceof`
    operator ensures that we prevent `ClassCastException` errors from occurring.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on inheritance – this was a big chapter! We will
    now move on to interfaces and `abstract` classes.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
