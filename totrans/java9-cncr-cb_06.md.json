["```java\n        public class Person implements Comparable<Person> { \n\n          private int id; \n          private String firstName; \n          private String lastName; \n          private Date birthDate; \n          private int salary; \n          private double coeficient;\n\n```", "```java\n          public int compareTo(Person otherPerson) { \n            int compareLastNames = this.getLastName().compareTo\n                                        (otherPerson.getLastName()); \n            if (compareLastNames != 0) { \n              return compareLastNames; \n            } else { \n            return this.getFirstName().compareTo\n                                        (otherPerson.getFirstName()); \n          } \n        }\n\n```", "```java\n        public class PersonGenerator { \n\n          public static List<Person> generatePersonList (int size) { \n            List<Person> ret = new ArrayList<>(); \n\n            String firstNames[] = {\"Mary\",\"Patricia\",\"Linda\",\n                                   \"Barbara\",\"Elizabeth\",\"James\",\n                                   \"John\",\"Robert\",\"Michael\",\n                                   \"William\"}; \n            String lastNames[] = {\"Smith\",\"Jones\",\"Taylor\",\n                                  \"Williams\",\"Brown\",\"Davies\",\n                                  \"Evans\",\"Wilson\",\"Thomas\",\n                                  \"Roberts\"}; \n\n            Random randomGenerator=new Random(); \n            for (int i=0; i<size; i++) { \n              Person person=new Person(); \n              person.setId(i); \n              person.setFirstName(firstNames[randomGenerator\n                                             .nextInt(10)]); \n              person.setLastName(lastNames[randomGenerator\n                                           .nextInt(10)]); \n              person.setSalary(randomGenerator.nextInt(100000)); \n              person.setCoeficient(randomGenerator.nextDouble()*10); \n              Calendar calendar=Calendar.getInstance(); \n              calendar.add(Calendar.YEAR, -randomGenerator\n                                                 .nextInt(30)); \n              Date birthDate=calendar.getTime(); \n              person.setBirthDate(birthDate); \n              ret.add(person); \n            } \n            return ret; \n          }\n\n```", "```java\n        public class MySupplier implements Supplier<String> {\n\n```", "```java\n        private final AtomicInteger counter; \n        public MySupplier() { \n          counter=new AtomicInteger(0); \n        }\n\n```", "```java\n          @Override \n          public String get() { \n            int value=counter.getAndAdd(1); \n            return \"String \"+value; \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        System.out.printf(\"From a Collection:\\n\"); \n        List<Person> persons=PersonGenerator.generatePersonList(10000); \n        Stream<Person> personStream=persons.parallelStream();        \n        System.out.printf(\"Number of persons: %d\\n\",\n                          personStream.count());\n\n```", "```java\n        System.out.printf(\"From a Supplier:\\n\"); \n        Supplier<String> supplier=new MySupplier(); \n        Stream<String> generatorStream=Stream.generate(supplier); \n        generatorStream.parallel().limit(10).forEach(s->\n                                           System.out.printf(\"%s\\n\",s));\n\n```", "```java\n        System.out.printf(\"From a predefined set of elements:\\n\"); \n        Stream<String> elementsStream=Stream.of(\"Peter\",\"John\",\"Mary\"); \n        elementsStream.parallel().forEach(element ->\n                                    System.out.printf(\"%s\\n\", element));\n\n```", "```java\n        System.out.printf(\"From a File:\\n\"); \n        try (BufferedReader br = new BufferedReader(new\n                                 FileReader(\"data\\\\nursery.data\"));) {                                    Stream<String> fileLines = br.lines(); \n          System.out.printf(\"Number of lines in the file: %d\\n\\n\",\n                            fileLines.parallel().count()); \n          System.out.printf(\"********************************\n                             ************************\\n\"); \n          System.out.printf(\"\\n\"); \n          br.close(); \n        } catch (FileNotFoundException e) { \n          e.printStackTrace(); \n        } catch (IOException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        System.out.printf(\"From a Directory:\\n\"); \n        try { \n          Stream<Path> directoryContent = Files.list(Paths.get\n                                    (System.getProperty(\"user.home\"))); \n          System.out.printf(\"Number of elements (files and\n                             folders):%d\\n\\n\",\n                            directoryContent.parallel().count()); \n          directoryContent.close(); \n          System.out.printf(\"********************************\n                             ************************\\n\"); \n          System.out.printf(\"\\n\"); \n        } catch (IOException e) { \n          e.printStackTrace();\n        }\n\n```", "```java\n        System.out.printf(\"From an Array:\\n\"); \n        String array[]={\"1\",\"2\",\"3\",\"4\",\"5\"}; \n        Stream<String> streamFromArray=Arrays.stream(array); \n        streamFromArray.parallel().forEach(s->System.out.printf(\"%s : \",\n                                                                s));\n\n```", "```java\n        Random random = new Random(); \n        DoubleStream doubleStream = random.doubles(10); \n        double doubleStreamAverage = doubleStream.parallel().peek\n                                     (d -> System.out.printf(\"%f :\",d))\n                                     .average().getAsDouble();\n\n```", "```java\n        System.out.printf(\"Concatenating streams:\\n\"); \n        Stream<String> stream1 = Stream.of(\"1\", \"2\", \"3\", \"4\"); \n        Stream<String> stream2 = Stream.of(\"5\", \"6\", \"7\", \"8\"); \n        Stream<String> finalStream = Stream.concat(stream1, stream2); \n        finalStream.parallel().forEach(s -> System.out.printf(\"%s : \",\n                                                              s));\n\n```", "```java\n        public class DoubleGenerator { \n\n          public static List<Double> generateDoubleList(int size,\n                                                        int max) { \n            Random random=new Random(); \n            List<Double> numbers=new ArrayList<>(); \n\n            for (int i=0; i<size; i++) { \n              double value=random.nextDouble()*max; \n              numbers.add(value); \n            } \n            return numbers; \n          }\n\n```", "```java\n        public static DoubleStream generateStreamFromList(List<Double>\n                                                          list) { \n          DoubleStream.Builder builder=DoubleStream.builder(); \n\n          for (Double number : list) { \n            builder.add(number); \n          } \n          return builder.build(); \n        }\n\n```", "```java\n        public class PointGenerator { \n          public static List<Point> generatePointList (int size) {\n\n            List<Point> ret = new ArrayList<>(); \n            Random randomGenerator=new Random(); \n            for (int i=0; i<size; i++) { \n              Point point=new Point(); \n              point.setX(randomGenerator.nextDouble()); \n              point.setY(randomGenerator.nextDouble()); \n              ret.add(point); \n            } \n            return ret; \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String args[]) { \n\n            List<Double> numbers = DoubleGenerator.generateDoubleList\n                                                        (10000, 1000);\n\n```", "```java\n        DoubleStream doubleStream = DoubleGenerator\n                                      .generateStreamFromList(numbers); \n        long numberOfElements = doubleStream.parallel().count(); \n        System.out.printf(\"The list of numbers has %d elements.\\n\",\n                          numberOfElements); \n\n        doubleStream = DoubleGenerator.generateStreamFromList(numbers); \n        double sum = doubleStream.parallel().sum(); \n        System.out.printf(\"Its numbers sum %f.\\n\", sum); \n\n        doubleStream = DoubleGenerator.generateStreamFromList(numbers); \n        double average = doubleStream.parallel().average()\n                                                   .getAsDouble(); \n        System.out.printf(\"Its numbers have an average value of %f.\\n\",\n                          average); \n\n        doubleStream = DoubleGenerator.generateStreamFromList(numbers); \n        double max = doubleStream.parallel().max().getAsDouble(); \n        System.out.printf(\"The maximum value in the list is %f.\\n\",\n                          max); \n\n        doubleStream = DoubleGenerator.generateStreamFromList(numbers); \n        double min = doubleStream.parallel().min().getAsDouble(); \n        System.out.printf(\"The minimum value in the list is %f.\\n\",\n                          min);\n\n```", "```java\n        List<Point> points=PointGenerator.generatePointList(10000);        \n        Optional<Point> point=points.parallelStream().reduce((p1,p2) -> { \n          Point p=new Point(); \n          p.setX(p1.getX()+p2.getX()); \n          p.setY(p1.getY()+p2.getY()); \n          return p; \n        }); \n        System.out.println(point.get().getX()+\":\"+point.get().getY());\n\n```", "```java\n        System.out.printf(\"Reduce, second version\\n\"); \n        List<Person> persons = PersonGenerator.generatePersonList\n                                                               (10000); \n        long totalSalary=persons.parallelStream().map\n                         (p -> p.getSalary()).reduce(0, (s1,s2) -> s1+s2); \n        System.out.printf(\"Total salary: %d\\n\",totalSalary);\n\n```", "```java\n        Integer value=0; \n        value=persons.parallelStream().reduce(value, (n,p) -> { \n          if (p.getSalary() > 50000) { \n            return n+1; \n          } else { \n            return n; \n          } \n        }, (n1,n2) -> n1+n2); \n        System.out.printf(\"The number of people with a salary bigger\n                           that 50,000 is %d\\n\",value);\n\n```", "```java\n        @Override \n        public String toString() { \n          return firstName + \" \" + lastName; \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String args[]) { \n            List<Person> persons = PersonGenerator.generatePersonList\n                                                                (100);\n\n```", "```java\n        Map<String, List<Person>> personsByName = persons\n                        .parallelStream().collect(Collectors\n                        .groupingByConcurrent(Person::getFirstName)); \n        personsByName.keySet().forEach(key -> { \n          List<Person> listOfPersons = personsByName.get(key); \n          System.out.printf(\"%s: There are %d persons with that name\\n\",\n                            key, listOfPersons.size());\n\n```", "```java\n        String message = persons.parallelStream().map\n                  (p -> p.toString()).collect(Collectors.joining(\",\")); \n        System.out.printf(\"%s\\n\", message);\n\n```", "```java\n        Map<Boolean, List<Person>> personsBySalary = persons\n                        .parallelStream().collect(Collectors\n                        .partitioningBy(p -> p.getSalary() > 50000));\n\n```", "```java\n        personsBySalary.keySet().forEach(key -> { \n          List<Person> listOfPersons = personsBySalary.get(key); \n          System.out.printf(\"%s: %d \\n\", key, listOfPersons.size()); \n        });\n\n```", "```java\n        ConcurrentMap<String, String> nameMap = persons\n                        .parallelStream().collect(Collectors\n                        .toConcurrentMap(p -> p.getFirstName(),\n                                         p -> p.getLastName(),\n                                         (s1, s2) -> s1 + \", \" + s2)); \n        nameMap.forEach((key, value) -> { \n          System.out.printf(\"%s: %s \\n\", key, value); \n        });\n\n```", "```java\n        List<Person> highSalaryPeople = persons\n                        .parallelStream().collect(\n          ArrayList::new, (list, person) -> {  \n            if (person.getSalary() > 50000) { \n              list.add(person); \n            } \n          }, \n          ArrayList::addAll \n        ); \n        System.out.printf(\"High Salary People: %d\\n\",\n                          highSalaryPeople.size());\n\n```", "```java\n        System.out.printf(\"Collect, second example\\n\"); \n        ConcurrentHashMap<String, Counter> peopleNames = persons\n                                .parallelStream().collect( \n          ConcurrentHashMap::new, (hash, person) -> { \n            hash.computeIfPresent(person.getFirstName(), (name,\n                                                          counter) -> { \n              counter.increment(); \n              return counter; \n            }); \n            hash.computeIfAbsent(person.getFirstName(), name -> { \n              Counter c=new Counter(); \n              c.setValue(name); \n              return c; \n            }); \n          }, \n          (hash1, hash2) -> { \n            hash2.forEach (10, (key, value) -> { \n              hash1.merge(key, value, (v1,v2) -> { \n                v1.setCounter(v1.getCounter()+v2.getCounter()); \n                return v1; \n              }); \n            }); \n          }); \n\n          peopleNames.forEach((name, counter) -> { \n            System.out.printf(\"%s: %d\\n\", name, counter.getCounter()); \n          });\n\n```", "```java\n        private static Comparator<Person> comparator=Comparator\n                                .comparing(Person::getLastName)\n                                .thenComparing(Person::getFirstName); \n\n        @Override \n        public int compareTo(Person otherPerson) { \n          return comparator.compare(this, otherPerson); \n        }\n\n```", "```java\n        @Override \n        public boolean equals(Object object) { \n          return this.compareTo((Person)object)==0; \n        }\n\n```", "```java\n        public int hashCode() { \n          String sequence=this.getLastName()+this.getFirstName(); \n          return sequence.hashCode(); \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) { \n            List<Person> persons=PersonGenerator.generatePersonList(10);\n\n```", "```java\n        persons.parallelStream().forEach(p -> { \n           System.out.printf(\"%s, %s\\n\", p.getLastName(),\n                             p.getFirstName()); \n        });\n\n```", "```java\n        List<Double> doubles= DoubleGenerator.generateDoubleList(10, 100); \n        System.out.printf(\"Parallel forEachOrdered() with numbers\\n\"); \n        doubles.parallelStream().sorted().forEachOrdered(n -> { \n          System.out.printf(\"%f\\n\",n); \n        });\n\n```", "```java\n        System.out.printf(\"Parallel forEach() after sorted()\n                           with numbers\\n\"); \n        doubles.parallelStream().sorted().forEach(n -> { \n          System.out.printf(\"%f\\n\",n); \n        });\n\n```", "```java\n        persons.parallelStream().sorted().forEachOrdered( p -> { \n          System.out.printf(\"%s, %s\\n\", p.getLastName(),\n                            p.getFirstName()); \n        });\n\n```", "```java\n        doubles \n          .parallelStream() \n          .peek(d -> System.out.printf(\"Step 1: Number: %f\\n\",d)) \n          .peek(d -> System.out.printf(\"Step 2: Number: %f\\n\",d)) \n          .forEach(d -> System.out.printf(\"Final Step: Number: %f\\n\",d));\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n            List<Person> persons=PersonGenerator\n                                        .generatePersonList(10); \n            persons.parallelStream().forEach(p-> { \n              System.out.printf(\"%s, %s\\n\", p.getLastName(),\n                                p.getFirstName()); \n            });\n\n```", "```java\n        persons.parallelStream().distinct().forEach(p-> { \n          System.out.printf(\"%s, %s\\n\", p.getLastName(),\n                            p.getFirstName()); \n        });\n\n```", "```java\n        Integer[] numbers={1,3,2,1,2,2,1,3,3,1,1,3,2,1}; \n        Arrays.asList(numbers).parallelStream().mapToInt(n -> n)\n                                        .distinct().forEach( n -> { \n          System.out.printf(\"Number: %d\\n\", n); \n        });\n\n```", "```java\n        persons.parallelStream().filter(p -> p.getSalary() < 30000)\n                                                .forEach( p -> { \n          System.out.printf(\"%s, %s\\n\", p.getLastName(),\n                        p.getFirstName()); \n        });\n\n```", "```java\n        Arrays.asList(numbers).parallelStream().mapToInt(n -> n)\n                                .filter( n -> n<2).forEach(  n-> { \n          System.out.printf(\"%d\\n\", n); \n        });\n\n```", "```java\n        persons.parallelStream().mapToDouble(p -> p.getSalary())\n                                       .sorted().limit(5).forEach(s-> { \n          System.out.printf(\"Limit: %f\\n\",s); \n        });\n\n```", "```java\n        persons.parallelStream().mapToDouble(p -> p.getSalary())\n                                        .sorted().skip(5).forEach(s-> { \n          System.out.printf(\"Skip: %f\\n\",s); \n        });\n\n```", "```java\n        public class FileGenerator { \n          public static List<String> generateFile(int size) { \n            List<String> file=new ArrayList<>(); \n            for (int i=0; i<size; i++) { \n              file.add(\"Lorem ipsum dolor sit amet,\n                        consectetur adipiscing elit. Morbi lobortis\n                        cursus venenatis. Mauris tempus elit ut \n                        malesuada luctus. Interdum et malesuada fames\n                        ac ante ipsum primis in faucibus. Phasellus\n                        laoreet sapien eu pulvinar rhoncus. Integer vel\n                        ultricies leo. Donec vel sagittis nibh.\n                        Maecenas eu quam non est hendrerit pu\"); \n            } \n            return file; \n          } \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) { \n\n            // Create list of persons \n            List<Person> persons = PersonGenerator.generatePersonList(100);\n\n```", "```java\n        DoubleStream ds = persons.parallelStream().mapToDouble\n                                                (p -> p.getSalary()); \n        ds.distinct().forEach(d -> { \n          System.out.printf(\"Salary: %f\\n\", d); \n        }); \n        ds = persons.parallelStream().mapToDouble(p -> p.getSalary()); \n        long size = ds.distinct().count(); \n        System.out.printf(\"Size: %d\\n\", size);\n\n```", "```java\n        List<BasicPerson> basicPersons = persons.parallelStream().map\n                                                                (p -> { \n          BasicPerson bp = new BasicPerson(); \n          bp.setName(p.getFirstName() + \" \" + p.getLastName()); \n          bp.setAge(getAge(p.getBirthDate())); \n          return bp; \n        }).collect(Collectors.toList()); \n\n        basicPersons.forEach(bp -> { \n          System.out.printf(\"%s: %d\\n\", bp.getName(), bp.getAge()); \n        });\n\n```", "```java\n        List<String> file = FileGenerator.generateFile(100); \n        Map<String, Long> wordCount = file.parallelStream()\n          .flatMap(line -> Stream.of(line.split(\"[ ,.]\"))) \n          .filter(w -> w.length() > 0).sorted()\n          .collect(Collectors.groupingByConcurrent(e -> e, Collectors\n            .counting())); \n\n        wordCount.forEach((k, v) -> { \n          System.out.printf(\"%s: %d\\n\", k, v); \n        });\n\n```", "```java\n        private static long getAge(Date birthDate) { \n          LocalDate start = birthDate.toInstant()\n                        .atZone(ZoneId.systemDefault()).toLocalDate(); \n          LocalDate now = LocalDate.now(); \n          long ret = ChronoUnit.YEARS.between(start, now); \n          return ret; \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String args[]) { \n            int[] numbers={9,8,7,6,5,4,3,2,1,2,3,4,5,6,7,8,9}; \n            Arrays.stream(numbers).parallel().sorted().forEachOrdered\n                                                                (n -> { \n            System.out.printf(\"%d\\n\", n); \n          });\n\n```", "```java\n        List<Person> persons=PersonGenerator.generatePersonList(10); \n        persons.parallelStream().sorted().forEachOrdered(p -> { \n          System.out.printf(\"%s, %s\\n\",p.getLastName(),p.getFirstName()); \n        });\n\n```", "```java\n        TreeSet<Person> personSet=new TreeSet<>(persons); \n        for (int i=0; i<10; i++) {\n\n```", "```java\n        Person person= personSet.stream().parallel().limit(1)\n                                .collect(Collectors.toList()).get(0); \n        System.out.printf(\"%s %s\\n\", person.getFirstName(),\n                          person.getLastName());\n\n```", "```java\n        person=personSet.stream().unordered().parallel().limit(1)\n                                .collect(Collectors.toList()).get(0); \n        System.out.printf(\"%s %s\\n\", person.getFirstName(),\n                          person.getLastName());\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n            List<Person> persons=PersonGenerator.generatePersonList(10);\n\n```", "```java\n        int maxSalary = persons.parallelStream().map(p -> p.getSalary())\n                                        .max(Integer::compare).get(); \n        int minSalary = persons.parallelStream().mapToInt(p -> p\n                                        .getSalary()).min().getAsInt(); \n        System.out.printf(\"Salaries are between %d and %d\\n\", minSalary,\n                          maxSalary);\n\n```", "```java\n        boolean condition; \n        condition=persons.parallelStream().allMatch\n                                              (p -> p.getSalary() > 0); \n        System.out.printf(\"Salary > 0: %b\\n\", condition);\n\n```", "```java\n        condition=persons.parallelStream().allMatch\n                                          (p -> p.getSalary() > 10000); \n        System.out.printf(\"Salary > 10000: %b\\n\",condition); \n        condition=persons.parallelStream().allMatch\n                                          (p -> p.getSalary() > 30000); \n        System.out.printf(\"Salary > 30000: %b\\n\",condition);\n\n```", "```java\n        condition=persons.parallelStream().anyMatch\n                                         (p -> p.getSalary() > 50000); \n        System.out.printf(\"Any with salary > 50000: %b\\n\",condition); \n        condition=persons.parallelStream().anyMatch\n                                         (p -> p.getSalary() > 100000); \n        System.out.printf(\"Any with salary > 100000: %b\\n\",condition);\n\n```", "```java\n        condition=persons.parallelStream().noneMatch\n                                         (p -> p.getSalary() > 100000); \n        System.out.printf(\"None with salary > 100000: %b\\n\",condition);\n\n```", "```java\n        Person person = persons.parallelStream().findAny().get(); \n        System.out.printf(\"Any: %s %s: %d\\n\", person.getFirstName(),\n                          person.getLastName(), person.getSalary());\n\n```", "```java\n        person = persons.parallelStream().findFirst().get(); \n        System.out.printf(\"First: %s %s: %d\\n\", person.getFirstName(),\n                          person.getLastName(), person.getSalary());\n\n```", "```java\n        person = persons.parallelStream().sorted((p1,p2) -> {  \n          return p1.getSalary() - p2.getSalary(); \n        }).findFirst().get(); \n        System.out.printf(\"First Sorted: %s %s: %d\\n\",\n                          person.getFirstName(), person.getLastName(),\n                          person.getSalary());\n\n```", "```java\n        public class Consumer1 implements Flow.Subscriber<Item> { \n\n          @Override \n          public void onComplete() { \n            System.out.printf(\"%s: Consumer 1: Completed\\n\",\n                              Thread.currentThread().getName()); \n\n          }\n\n```", "```java\n        @Override \n        public void onError(Throwable exception) { \n          System.out.printf(\"%s: Consumer 1: Error\\n\",\n                            Thread.currentThread().getName()); \n          exception.printStackTrace(System.err); \n        }\n\n```", "```java\n        @Override \n        public void onNext(Item item) { \n          System.out.printf(\"%s: Consumer 1: Item received\\n\",\n                            Thread.currentThread().getName()); \n          System.out.printf(\"%s: Consumer 1: %s\\n\",\n                            Thread.currentThread().getName(),\n                            item.getTitle()); \n          System.out.printf(\"%s: Consumer 1: %s\\n\",\n                            Thread.currentThread().getName(),\n                            item.getContent()); \n        }\n\n```", "```java\n        @Override \n        public void onSubscribe(Flow.Subscription subscription) { \n          System.out.printf(\"%s: Consumer 1: Subscription received\\n\",\n                            Thread.currentThread().getName()); \n          System.out.printf(\"%s: Consumer 1: No Items requested\\n\",\n                            Thread.currentThread().getName()); \n        }\n\n```", "```java\n        public class Consumer2 implements Flow.Subscriber<Item> { \n\n          private Subscription subscription; \n\n          @Override \n          public void onComplete() { \n            System.out.printf(\"%s: Consumer 2: Completed\\n\",\n                              Thread.currentThread().getName());      \n          }\n\n```", "```java\n          @Override \n          public void onError(Throwable exception) { \n            System.out.printf(\"%s: Consumer 2: Error\\n\",\n                              Thread.currentThread().getName()); \n            exception.printStackTrace(System.err); \n          }\n\n```", "```java\n        @Override \n        public void onNext(Item item) { \n          System.out.printf(\"%s: Consumer 2: Item received\\n\",\n                            Thread.currentThread().getName()); \n          System.out.printf(\"%s: Consumer 2: %s\\n\",\n                            Thread.currentThread().getName(),\n                            item.getTitle()); \n          System.out.printf(\"%s: Consumer 2: %s\\n\",\n                            Thread.currentThread().getName(),\n                            item.getContent()); \n          subscription.request(1); \n        }\n\n```", "```java\n        @Override \n        public void onSubscribe(Flow.Subscription subscription) { \n          System.out.printf(\"%s: Consumer 2: Subscription received\\n\",\n                            Thread.currentThread().getName()); \n          this.subscription=subscription; \n          subscription.request(1); \n        }\n\n```", "```java\n        public class Consumer3 implements Flow.Subscriber<Item> { \n\n          @Override \n          public void onComplete() { \n            System.out.printf(\"%s: Consumer 3: Completed\\n\",\n                              Thread.currentThread().getName()); \n\n          }\n\n```", "```java\n\n          @Override \n          public void onError(Throwable exception) { \n            System.out.printf(\"%s: Consumer 3: Error\\n\",\n                              Thread.currentThread().getName()); \n            exception.printStackTrace(System.err); \n          }\n\n```", "```java\n        @Override \n        public void onNext(Item item) { \n          System.out.printf(\"%s: Consumer 3: Item received\\n\",\n                            Thread.currentThread().getName()); \n          System.out.printf(\"%s: Consumer 3: %s\\n\",\n                            Thread.currentThread().getName(),\n                            item.getTitle()); \n          System.out.printf(\"%s: Consumer 3: %s\\n\",\n                            Thread.currentThread().getName(),\n                            item.getContent()); \n        }\n\n```", "```java\n        @Override \n        public void onSubscribe(Flow.Subscription subscription) { \n          System.out.printf(\"%s: Consumer 3: Subscription received\\n\",\n                            Thread.currentThread().getName()); \n          System.out.printf(\"%s: Consumer 3: Requested three items\\n\",\n                            Thread.currentThread().getName()); \n          subscription.request(3); \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n\n            Consumer1 consumer1=new Consumer1(); \n            Consumer2 consumer2=new Consumer2(); \n            Consumer3 consumer3=new Consumer3();\n\n```", "```java\n        SubmissionPublisher<Item> publisher=new SubmissionPublisher<>(); \n\n        publisher.subscribe(consumer1); \n        publisher.subscribe(consumer2); \n        publisher.subscribe(consumer3);\n\n```", "```java\n        for (int i=0; i<10; i++) { \n          Item item =new Item(); \n          item.setTitle(\"Item \"+i); \n          item.setContent(\"This is the item \"+i); \n          publisher.submit(item); \n          try { \n            TimeUnit.SECONDS.sleep(1); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n            publisher.close(); \n          } \n        }\n\n```"]