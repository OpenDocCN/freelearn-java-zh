<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating an Online Bookstore</h1>
                </header>
            
            <article>
                
<p class="mce-root">It is always beneficial to develop any web application in a layered fashion. A prominent n-tier (or sometimes 3-tier) solution is the layered architecture, which has been widely adopted as the standard pattern for designing most applications. It is not a new concept, and we have been using it for a long time.</p>
<p class="mce-root">A layered architecture separates the whole application into various layers of concerns, which are logically different from each other:</p>
<ul>
<li class="mce-root"><strong>Presentation layer</strong>: This layer contains the artifacts that are responsible for building a user interface or displaying the output to the end user</li>
<li class="mce-root"><strong>Application layer</strong>: This layer contains business logic and interacts with the presentation and persistence layers to makeup the flow of the application</li>
<li class="mce-root"><strong>Persistence layer</strong>: This layer stores the data in data stores such as databases, the filesystem, and external sources, and also retrieves it</li>
</ul>
<p class="mce-root">There are numerous advantages of a layered architecture, such as increased reusability, flexibility, and consistency, because the layers are logically separated. Applications built with a layered architecture are self-contained in nature and can be executed <span>independently of </span>other applications. They are referred to as <strong>monolithic applications</strong>.</p>
<p class="mce-root">Since the beginning of this book, we have been creating a monolithic application to showcase and explore various concepts. Though logically separated as an n-tier architecture, monolithic applications face a maintenance nightmare once their size and complexity reach a certain level over a period of time. Such applications hold all the features and functionalities in one single package, which is wrapped as a single deployable unit.</p>
<p class="mce-root"><strong>Microservices</strong>, on the other hand, are a different architectural approach, adopted by organizations such as Google, Amazon, Netflix, and many others, with the aim of meeting modern business needs and developing an application that is inherently complex in nature. The microservice architecture helps to solve the various problems that arise with monolithic applications.</p>
<p class="mce-root">The concept of microservices is not new; it has come to the fore to overcome the limitations of previous architectures. In this chapter, we will closely observe the evolution of microservice architecture by developing an online bookstore application along with following topics:</p>
<ul>
<li class="mce-root">Introduction to microservice architecture</li>
<li class="mce-root">Principles and characteristics of microservice architecture</li>
<li class="mce-root">Various approaches to designing a microservice frontend</li>
<li>Defining the structure of the database</li>
<li class="mce-root">Exploring various Spring Cloud and Netflix OSS components to design microservices</li>
<li class="mce-root">Making a microservice application secure</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06</a>. The code can be executed on any operating system, although it has only been tested on Windows.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices introduction</h1>
                </header>
            
            <article>
                
<p class="mce-root">Microservices have emerged as a promising architecture pattern that is widely accepted as a solution to modern trends in business. Enterprises use various channels, such as mobile platforms, analytics with big data, and social media interaction, as elements to grow the business and find new customers at a rapid pace. With all these artifacts, organizations are trying to design innovations that will help them to gain a strong market share, which is a quite a difficult goal to achieve with conventional delivery methodologies.</p>
<p class="mce-root">In the past, enterprises developed single monolithic and accumulated applications for their business needs. Today, this has changed, as the goal has shifted to developing a smart solution with a short turnaround time that focuses on a specific business need.</p>
<p class="mce-root">A good example is a traveling company that executes their business with a single monolithic application. What if they want to improve the customer experience by suggesting new traveling ideas based on user searches or, more specifically, their old trips, any special occasion or festival season, user preferences, or interests?</p>
<p class="mce-root">There are many scenarios where organizations wish to implement independent solutions for each of these use cases and plug them into core business logic, instead of keeping everything together as a single application, which means they have to keep updating and testing the whole application for any future business changes, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/80eb0165-de74-49f6-9c80-63bcdb00abe1.png" style="width:43.08em;height:26.75em;"/></p>
<p>Instead of putting all these independent functionalities together with the core business logic, they can be plugged in independently. This approach is more flexible in terms of allowing new changes with a lower adoption cost. Additionally, they can be tested independently and more effectively. Any further changes can be accommodated with ease.</p>
<p class="mce-root">Such business scenarios expect an architecture that can adopt changes with minimal impact and cost, which makes it more agile. This is why the microservice approach has been developed.</p>
<p class="mce-root">Microservice architectures focus on designing an application in small parts, each of which is concerned with a specific function, instead of making the whole application a black box in a monolithic architecture.</p>
<p class="mce-root">In the last few years, the revolution in technological paradigms has completely changed the way we develop an application. This includes the frontend layer, with various popular frameworks for responsive capabilities and flexibility, such as Angular, React, Backbone, and Bootstrap, which completely change the user front.</p>
<p class="mce-root">With the introduction of cloud-aware and container mechanisms, the approach to designing and implementing the middle layer has been influenced. It also includes a change in the way we design persistence from using a relational database to NoSQL, which solved specific architectural concerns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice architecture </h1>
                </header>
            
            <article>
                
<p class="mce-root">As time passes, architectural styles have improved significantly. Various architecture patterns, such as mainframes, client-server, n-tier, and <strong>s<span>ervice-oriented architecture</span></strong> (<strong><span>SOA</span></strong>), have been popular at various points in history. However, these architectural were all involved in developing some sort of monolithic application, either directly or indirectly.</p>
<p class="mce-root">As the revolution happened in the technology stack, microservice architecture has come to the fore as a result of improvements in all previous architectures. The aim is to provide agility, reduce the turnaround time for adopting new changes, achieve scalable performance, and take full advantage of modern tools and frameworks.</p>
<p class="mce-root">Microservice architecture breaks an application into small, independent subsystems. They also can be referred to as a system of systems, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7272ea49-c82b-48e0-b2b1-b3bdc8460292.png" style="width:61.42em;height:38.17em;"/></p>
<p>Though the components are stored in different logical layers in a monolithic architecture, they are packaged in a single application structure. On the other hand, the microservice system is a set of independent subsystems, each packaged in their own project structure and deployed as independent units. You can consider a microservice architecture as a jigsaw puzzle where each microservice is a building block of a whole application.</p>
<p class="mce-root">In short, in a monolithic system, the components are logically different but part of single physical application, whereas in a microservice architecture, the subsystems are actual physical applications that form a giant logical application.</p>
<p class="mce-root">The microservice architecture is widely used now as a set of standards to refactor monolithic applications. Emerging from a hexagonal pattern, a microservice architecture promotes the encapsulation of a business function into an individual independent unit that is isolated from other functionality.</p>
<p class="mce-root">A <strong>Hexagonal Architecture</strong> puts input and output on the edges of a hexagon and keeps <strong>Business Logic</strong> at the center. This arrangement isolates the application from outside concerns, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e48881f-2c05-4aca-b911-3accc56e4bdc.png" style="width:27.75em;height:15.75em;"/></p>
<p class="mce-root">The inside part consists of <strong>Business Logic</strong>, whereas the outside consist of the UI, messaging, <strong>REST</strong>, database, and others. The outside parts can be swapped without affecting the core application functions. Each business function can be designed with the hexagonal model, which then interacts with others with a standard communication mechanism.</p>
<p class="mce-root">Let's look at the hexagonal pattern by taking an example. Consider you are developing an EMI calculator application that calculates the principal and interest amount based on total loan amount, interest rate, and tenure. This application keeps the provision of scanning the user input to calculate the loan data. The logic for taking user input is closely associated with the EMI calculator application. After a period of time, another application needs to use the EMI calculator application. In this case, the input mechanism needs to be updated.</p>
<p class="mce-root">To overcome this problem, the hexagonal pattern suggests isolating the EMI calculating logic from the input receiving mechanism by defining some sort of standard interface. This way, the EMI calculator is completely unaware of where the inputs come from. In this scenario, the interface for receiving input is referred to as a <strong>Port</strong>, while its implementation is known as an <strong>Adapter</strong>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8b0e6111-8fe2-4bae-82dd-f40fa0546866.png" style="width:34.17em;height:25.33em;"/></p>
<p>The hexagonal pattern is also referred to as the <strong>Port </strong>and<strong> Adapter </strong>pattern. The concept of the microservice architecture is derived from the hexagonal pattern, in which each hexagonal structure represents a self-contained and loosely coupled service (subsystem). Adding more hexagonal models is equivalent to adding more independent services. </p>
<p>That is why the microservice concept is logically compared with a honeycomb, in which multiple hexagons form a large and solid structure. Similarly, individual services (equivalent to individual hexagonal structures) form a larger application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice principles</h1>
                </header>
            
            <article>
                
<p>Although there is no straight definition or standard for defining microservices, there are certain qualities, criteria, and principles that must be considered while designing microservice applications. Let's take a look at some of them in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">High cohesion with a single responsibility</h1>
                </header>
            
            <article>
                
<p><strong>High cohesion</strong> means a module or unit should execute a single business function. In the microservice architecture, an individual service should perform a single responsibility for a given application context. Sharing a single responsibility between multiple services should not be allowed. Also, a single service should not handle multiple responsibilities, in order to make the whole system truly modular.</p>
<p>This is one of the striking differences between the monolithic and microservice architectures. The components are logically separated but are still part of a single application and share some common responsibilities in the former, but they are designed as independent small applications in the latter.</p>
<p><span>While designing microservices, the goal should be the </span>scope<span> of the business function executed by the microservice instead of making it smaller. The term <strong>micro</strong> is sometimes misleading, suggesting you should make the service as small as possible. The scope should be given the highest priority, instead of the size of the service. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service autonomy</h1>
                </header>
            
            <article>
                
<p>While building a microservice application, the prime goal is to make each member (service) a standalone and independent building block. To make sure each service runs with optimal performance and provides reliable output, they must take full control over the underlying resources they use.</p>
<p class="mce-root">This can be achieved with the service autonomy principle. It recommends each service should be designed with autonomy in mind. By doing so, the control and ownership a service has over its own execution environment will be more effective, which would otherwise be difficult to achieve with shared resources in a monolithic architecture. This will greatly help in dealing with the scalability of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loose coupling</h1>
                </header>
            
            <article>
                
<p class="mce-root">An application should be designed with microservice architecture in such a way that each unit (service) should have (ideally) zero or the bare minimum impact on other components or services. If any sort of interaction or communication is required between services, they also should be loosely coupled in nature. This is the reason synchronous calls with RESTful APIs or asynchronous calls with a messaging framework are preferable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hide implementation through encapsulation</h1>
                </header>
            
            <article>
                
<p class="mce-root">Microservices must isolate underlying implementation details from the outside world and define a standard interface to interact with it. This will not only reduce complexity, but also enhance the ability to adopt new changes easily, making the whole system more flexible and robust.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Domain-driven design</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Domain-driven design</strong> (<strong>DDD</strong>) is a way to design a system with respect to the actual domain models used in the application. The architectural style of DDD is used to develop an application in independent units, each representing a specific domain model. It also suggests the way to behave and communicate between domain models. An ideal DDD has all the <span>qualities </span>required to develop a modular application. Due to this, it is an ideal candidate for consideration while implementing microservice architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice characteristics</h1>
                </header>
            
            <article>
                
<p>Here are some characteristics of a microservice architecture:</p>
<ul>
<li class="mce-root">It is a way of designing an application as a group of small services, each executed in its own procedure.</li>
<li class="mce-root">Microservices can interact with each other internally, mostly through the HTTP API or some time-messaging mechanism such as AMQP or JMS.</li>
<li class="mce-root">Each microservice is built to execute a specific business requirement. In other words, they are aligned to specific business needs or capabilities.</li>
<li class="mce-root">Microservices can be deployed independently with an automated mechanism.</li>
<li class="mce-root">Some sort of common or central process is required to manage microservices, which may or may not use the same technology stack as the individual microservices.</li>
<li class="mce-root">Microservices manage their life cycle independently of others.</li>
<li class="mce-root">Changes to one microservice do not impact on others as they run independently.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices with Spring Cloud</h1>
                </header>
            
            <article>
                
<p>Generally, microservices are designed to be deployed in a distributed system. There are certain common patterns across distributed environments. Spring Cloud provides a predefined implementation of patterns that we can use to build a microservice application quickly. They are considered Spring Cloud sub-projects. We are going to take a brief look at a few of them, and we will also see how to use them while developing our online bookstore application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration management</h1>
                </header>
            
            <article>
                
<p>Configurations are part of any application, and in the Spring world they are in the form of the properties file, generally bundled with the application code. It is a tedious job to deploy the entire service any time there's a configuration change. What if a configuration can be managed outside of the application? This is a good idea because managing configurations externally allows us to reflect changes without deploying or even restarting a service. This is exactly <span>what </span>configuration management does. Configurations are allowed on the fly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service discovery</h1>
                </header>
            
            <article>
                
<p>As we have seen, microservice applications are a collection of self-contained and independently deployable services that are running on the same or different physical machines, or on the cloud. Each service can be considered as an individual process that performs a specific responsibility.</p>
<p>Though they are separated in terms of executing different business functions, they are interconnected as a part of the whole application, and hence some sort of communication mechanism, with well-defined standards, is required.</p>
<p>For interprocess communication, as well as accessing a particular service, we need to know the location in terms of the port and IP of the service. Traditional monolithic applications are generally deployed and accessible with a static port and IP address. Also, they are deployed in a single package so that all the components/services are accessible with the same port and IP. The likelihood of changing the port and IP is also very low.</p>
<p>In contrast, microservice applications are distributed in nature and may be deployed on different machines or in the cloud. Additionally, more instances of the services may be added to improve the scalability of the system. In future, new services may be added dynamically. Due to this, the locations of microservices are dynamic.</p>
<p>Spring Cloud provides a <strong>service discovery</strong> functionality, which is actually used to locate the services in the distributed environment. Spring Cloud provides a Netflix Eureka-based discovery service out of the box. Alternatively, we can use Consul, Cloud Foundry, or Apache ZooKeeper with Spring Cloud as service discovery support.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Circuit breakers</h1>
                </header>
            
            <article>
                
<p>Though microservices are designed to handle a single responsibility, they sometimes rely on other services to perform a set of actions owned by others. In this dependency channel, if one service goes down, the error will propagate to other services on the same channel. To avoid it, Spring Cloud provides a Netflix Hystrix-based fault tolerance solution, which is an implementation of the circuit breaker pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing</h1>
                </header>
            
            <article>
                
<p>Since the location of microservices can be changed dynamically, a routing mechanism is required to send the request to the specific service endpoint. Spring Cloud provides a simple and effective way to route APIs with advanced cross-cutting capabilities such as security, monitoring, filtering, and authentication through Zuul—another tool from Netflix, which is a server-side load balancer that's used for routing purposes as well. Zuul can also be used as a micro proxy, which routes the application using the proxy URL that was configured.</p>
<div class="packt_infobox">Another component used for routing is Spring Cloud Gateway, which is natively developed by Spring. It is built on Spring Framework 5 and may provide a better developer experience as it's closely integrated with Spring.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Cloud Security</h1>
                </header>
            
            <article>
                
<p>Though microservices are accessed with standard interfaces, they need authentication and authorization in some use cases. Securing a microservice system is more complex than securing a monolithic system. Spring supports authentication with microservices through Spring Cloud Security with the Auth2 protocol to propagate the security context across the microservices in a distributed environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distributed tracing service</h1>
                </header>
            
            <article>
                
<p>In the microservice architecture, the application flow may pass through a chain of multiple service calls to execute a single business use case. Manually tracing the activities with the logs of multiple microservices is not an efficient solution. We may not get exactly what we want out of it. It is important to understand what is happening between the series of service call. This is quite helpful in debugging if an issue arises. Spring Cloud provides an effective way to trace the application flow in a distributed system through <strong>Spring Cloud Sleuth</strong>. It collects the call tracking data, which can be exported to <strong>Zipkin</strong>—another tool for visualizing the call trace.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Cloud Stream</h1>
                </header>
            
            <article>
                
<p>To handle the high volumes of data streams, we may need to work with message broker implementations such as RabbitMQ or Apache Kafka. Spring Cloud provides an easy integration of a message broker with a high-level abstraction through Spring Cloud Stream. So, instead of actually implementing the message broker, Spring Cloud Stream will handle the messages and pass them to the actual broker client at runtime, based on its configuration. This makes the code portable and loosely coupled with any message broker implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing an online bookstore application</h1>
                </header>
            
            <article>
                
<p>Now that we've looked at the microservice architecture, let's now do a practical exercise to understand the concept in more detail. We will follow the microservice pattern to develop a simple online bookstore application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application architecture</h1>
                </header>
            
            <article>
                
<p>We need to start by designing the application's architecture first. While designing microservice-based applications, first we need to think of a single monolithic application and then derive various parts or components that are independent of each other and can be thought of as possible candidates for being individual microservices.</p>
<p>We will break the application into small parts based on the criteria we looked at in the previous sections, such as single responsibility, service autonomy, loose coupling, encapsulation, and DDD, as follows:</p>
<ul>
<li>User management</li>
<li>Order management</li>
<li>Catalog management</li>
<li>Inventory management</li>
</ul>
<p>They are considered independent domains or business functions. We will create individual microservices for each of them with the following high-level architecture:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e4f061d5-1704-48f2-9542-48f117b862d6.png" style="width:36.67em;height:21.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database design</h1>
                </header>
            
            <article>
                
<p>While decomposing the application to adopt the microservice architecture, we need to rethink database design as well. In a distributed environment, there are multiple options for database design.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single monolithic database for all microservices</h1>
                </header>
            
            <article>
                
<p>In this approach, though the microservices are independently designed as a separate subsystem, they still share a single monolithic database, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1cfdb862-0c96-49ab-b189-d552314e7e2e.png" style="width:35.67em;height:26.08em;"/></p>
<p>Each microservice has its own set of tables, but all are part of a single database schema. The clear benefit of this option is simplicity, as a single database can be operated with ease. Also, transactions can be carried out in a more consistent way.</p>
<p>However, according to best practices, microservice should be independently deployable to get better scaling optimization. Another benefit of being independently deployable is the quick adoption of changes. As soon as multiple services depend on a single monolithic data store, this flexibility is reduced to take full advantage of the distributed environment, such as high cohesion and loose coupling.</p>
<p>Also, multiple teams generally work on the application side. They also need to face coupling with other teams while dealing with database changes. This will slow down the development and eventually add a delay in delivery. So, this is not an ideal scenario.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Separate service to handle database interaction</h1>
                </header>
            
            <article>
                
<p>In this scenario, instead of sharing a common database with all services, a separate service will be developed that will interact with the database only. All other services will talk to this service for any database operations instead of directly connecting with the database, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/02ad11c0-408e-45f7-a251-6a0a9b7d861b.png" style="width:37.50em;height:25.50em;"/></p>
<p>Though the dependency of managing database-related actions is shifted to a separate service, it is still kind of a monolithic approach and has all the limitations of the first option. So, this is also not an optimized way to design the database for a microservice architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Each microservice has its own database</h1>
                </header>
            
            <article>
                
<p>This option has a separate database for each individual service, as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/c8262572-6f27-411d-8f99-e3d003a07825.png" style="width:34.50em;height:22.25em;"/></p>
<p>Instead of a single shared database across services, each service's database is an integral part of that service and cannot be accessed by other services directly. Another flexibility in this option is that each service is allowed to choose the type of data store that is the best fit for its capabilities. For example, if you have a search service, to perform the search in the system, you can use <strong>Elasticsearch</strong> as a data store.</p>
<p>This model has two <span>further </span>options:</p>
<ul>
<li><strong>Individual database schema per service:</strong> Still use a single database server, but have a separate schema for each microservice. This option makes ownership <span>cleaner, and</span> it is an ideal option for most cases.</li>
<li><strong>Individual database server per service:</strong> Design separate database servers for each microservice. This option can be considered for services that require high throughput.</li>
</ul>
<p>For simplicity, we will use MySQL to store the data. As per the system architecture, there will be a separate database schema for each microservice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User schema</h1>
                </header>
            
            <article>
                
<p>This schema contains the tables that store user-related data. The <strong>user</strong> table holds user-specific data, which will be used for authentication, while the <strong>delivery_address</strong> table contains delivery address information:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7c432a3d-4f22-4b60-b66c-871a24a7dec1.png" style="width:27.00em;height:17.25em;"/></p>
<p>There is a <em>one-to-many </em>relationship between the <strong>user</strong> and <strong>delivery_address</strong> tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Order schema</h1>
                </header>
            
            <article>
                
<p>This schema contains two tables, <strong>order</strong> and <strong>order_item</strong>. The relationship between them is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d60f603-f7e3-46ba-9840-8ca9911869a1.png" style="width:28.42em;height:12.00em;"/></p>
<p>The <strong>order</strong> table holds the generic details of each order, such as orderId, userId, order date, total amount, and shipping address. The <strong>order_item</strong> table saves individual item details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catalog schema</h1>
                </header>
            
            <article>
                
<p>This schema contains the product details. Since this is an online bookstore application, the <strong>book</strong> table contains details of the book. The <strong>category</strong> and <strong>publisher</strong> tables contain details about categories and publishers respectively. The relationship between these tables is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1d912f18-69b8-4c08-8648-9a8aef0d02bc.png" style="width:25.00em;height:19.92em;"/></p>
<p><span>The</span> <strong>book</strong> <span>table has a <em>many-to-one</em> relationship to the </span><strong>category</strong> <span>and</span> <strong>publisher</strong> <span>tables.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inventory schema</h1>
                </header>
            
            <article>
                
<p>Every store has an inventory. This schema stores the <span>inventory containing </span>information about the books. There are two tables that store this information. The <strong>inventory</strong> table contains the current stock of the product (books in our case), while the <strong>inventory_history</strong> table shows the history of adding new books into the system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3076c017-f24e-4e23-ac82-11822265584d.png" style="width:23.58em;height:10.17em;"/></p>
<p><span>There is no relation between these tables.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating microservices with Spring Boot</h1>
                </header>
            
            <article>
                
<p>We are going to develop an online bookstore application with an architecture of <span>small and independently deployable microservices that can be developed by individual teams. They are expected to be developed with a quick turnaround time. This is what Spring Boot is designed for. It is a tool used to create production-grade Spring-based enterprise applications with a little configuration in no time.</span></p>
<p><span>We will first develop individual services with Spring Boot to develop them quickly. Spring Cloud also has solid integration capabilities with Spring Boot. While developing microservices, Spring Boot takes care of all the low-level things and allows us to concentrate on the business logic. </span></p>
<p>First, we will create Spring Boot applications for specific functionalities. Once they are created, we will then add microservice-specific capabilities to each of them:</p>
<ul>
<li><kbd>user-service</kbd>: This service is intended to execute various operations related to users, such as registration, login, and user interaction</li>
<li><kbd>inventory-service</kbd>: This service performs various inventory operations performed by admin only</li>
<li><kbd>catalog-service</kbd>: This service is responsible for managing catalog information such as adding books, categories, and publisher details</li>
<li><kbd>order-service</kbd>: This service handles orders placed by a user</li>
</ul>
<p>While creating an application with either the spring-io initializer or <strong><span>Spring Tool Suite</span></strong> (<span><strong>STS</strong>, </span>an Eclipse-based IDE provided by Spring), initially we will add following dependencies:</p>
<ul>
<li><strong>DevTools</strong>: Used to improve the development time experience by adding auto-deploy/restart capabilities as a Maven dependency.</li>
<li><strong>JPA</strong>: This will add a JPA-specific starter dependency, which is used to add JPA capabilities. We are going to use JPA (Hibernate implementation) to interact with the database.</li>
<li><strong>MySQL</strong>: This will add a MySQL connector JAR to connect to the database.</li>
<li><strong>Web</strong>: This is used to add Spring MVC capabilities to the application. We will use a REST controller to access individual microservice applications.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding microservice-specific capabilities</h1>
                </header>
            
            <article>
                
<p>We have created various Spring Boot applications for each individual functionality. They all are accessible (by default) on <span>port </span><kbd>8080</kbd> one by one. However, they are not ready to be executed as microservices. Now we will add microservice-specific capabilities by adding a dependencies entry in the <kbd>pom.xml</kbd> file of each individual Spring Boot application.</p>
<p>Add the following entry in the <kbd>dependencies</kbd> section of <kbd>pom.xml</kbd>:</p>
<pre> &lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;<br/> &lt;/dependency&gt;</pre>
<p>You also need to add an entry for the current version of Spring Cloud next to the <kbd>&lt;java-version&gt;</kbd> entry as follows:</p>
<pre>&lt;spring-cloud.version&gt;Greenwich.RC2&lt;/spring-cloud.version&gt;</pre>
<p>Add the following entry after the <kbd>dependencies</kbd> section is complete in <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependencyManagement&gt;<br/>    &lt;dependencies&gt;<br/>      &lt;dependency&gt;<br/>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;<br/>        &lt;version&gt;${spring-cloud.version}&lt;/version&gt;<br/>        &lt;type&gt;pom&lt;/type&gt;<br/>        &lt;scope&gt;import&lt;/scope&gt;<br/>      &lt;/dependency&gt;<br/>    &lt;/dependencies&gt;<br/>  &lt;/dependencyManagement&gt;<br/><br/>&lt;repositories&gt;<br/>   &lt;repository&gt;<br/>     &lt;id&gt;spring-milestones&lt;/id&gt;<br/>     &lt;name&gt;Spring Milestones&lt;/name&gt;<br/>     &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;<br/>   &lt;/repository&gt;<br/>&lt;/repositories&gt;</pre>
<p>Make these changes in all four Spring Boot applications that we have developed. After applying these changes, they will no longer run <span>independently </span>as Spring Boot applications because we are now moving towards a microservice architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Develop a service discovery server</h1>
                </header>
            
            <article>
                
<p>The real challenge in a microservice architecture is to access particular services because they are dynamically created and destroyed, so their location keeps changing. Additionally, we also need some sort of inter-service communication to fulfill certain business use cases that span the microservices. Also, multiple instances of each microservice can be created to scale up the application's performance.</p>
<p>In this situation, there must be a mechanism for locating the microservices. Spring Cloud provides a Netflix Eureka-based service discovery component for this purpose. Microservices can register themselves with the discovery server so that they can be accessed and interacted with by other services. Eureka Server is basically used for discovery, self-registration, and load balancing. </p>
<p>Next up is to create a Eureka-based service that acts as a <strong>service discovery server</strong>. Creating a Eureka-based discovery service is similar to creating Spring Boot application with just a few configuration changes. Create a new Spring starter project with the following data:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d4906690-2cc9-49f8-aac4-c10aabbf09bf.png" style="width:36.42em;height:21.75em;"/></p>
<p>On next screen, select <span class="packt_screen">Eureka Server</span> under the <span class="packt_screen">Cloud Discovery</span> option as a dependency and click <span class="packt_screen">Finish</span>. Once the project is created, open the <kbd>bootstrap</kbd> class and add the code highlighted in bold as follows:</p>
<pre>@SpringBootApplication<br/><strong>@EnableEurekaServer</strong><br/>public class EurekaDiscoveryServiceApplication {<br/><br/>  public static void main(String[] args) {<br/>    SpringApplication.run(EurekaDiscoveryServiceApplication.class, args);<br/>  }<br/>}</pre>
<p>By default, the <span class="packt_screen">Eureka Server</span> option is not enabled. The <kbd>@EnableEurekaServer</kbd> annotation is used to make it active for this application. That means this application will run as a Eureka discovery server. Next, we will add certain properties in the <kbd>application.properties</kbd> file as follows:</p>
<pre>#Configure this Discovery Server<br/>eureka.client.registerWithEureka = false<br/>eureka.client.fetch-registry=false<br/><br/>#In case if Eureka port need to be changed from default 8080<br/>server.port = 8761</pre>
<p>By default, the current Eureka server is also a Eureka client and will try to register itself as a Eureka client with the Eureka server. Since we want this application to behave as a server only, we need to explicitly set the <kbd>eureka.client.registerWithEureka</kbd> <span>property </span>to <kbd>false</kbd>. By default, Eureka server is accessible through port <kbd>8080</kbd> and it can be changed with the <kbd>server.port</kbd> <span>property.</span></p>
<p><span>Each Eureka client will fetch registry details from Eureka server. In our case, we do not want to fetch the registry details, so, we explicitly set the <kbd>eureka.client.fetch-registry</kbd> property to <kbd>false</kbd>. Now r</span>un the application, and Eureka Server is accessible through <kbd>http://localhost:8761</kbd>. It will show the server details and all registered service details, as follows: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9936ba3b-c502-41cc-8bb9-9a57b39229e4.png" style="width:58.67em;height:53.33em;"/></p>
<p>Currently, no services are registered with our Eureka discovery server, so it shows nothing in the <span class="packt_screen">Instances currently registered with Eureka</span> section.</p>
<div class="packt_infobox">Eureka Server can be started in standalone or clustered mode. For simplicity, we have chosen standalone mode.</div>
<p>Next up is to register the four microservices that we have developed with the Eureka discovery server. We have already added microservice-specific dependencies to them. Now, we need to add the Eureka client configurations. Because of the way we have configured Eureka server, we need to configure the Eureka client in each of the service's <kbd>bootstrap</kbd> classes. For example, the Eureka client configuration for the user service's bootstrap class is highlighted in bold as follows:</p>
<pre>@SpringBootApplication<br/><strong>@EnableDiscoveryClient</strong><br/>public class UserServiceApplication {<br/>  public static void main(String[] args) {<br/>    SpringApplication.run(UserServiceApplication.class, args);<br/>  }<br/>}</pre>
<p>The <kbd>@EnableDiscoveryClient</kbd> annotation will enable client configuration. Additionally, we need to add the following properties in the <kbd>application.properties</kbd> file:</p>
<pre>spring.application.name=user-service<br/>server.port=8791</pre>
<p>The <kbd>spring.application.name</kbd> property will be used to register the application with a specific name. Add client configurations and start other services, and you will see them registered with Eureka server as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7f7bb03-bb50-42a1-8161-f6f5f4c0d7bd.png" style="width:37.50em;height:13.17em;"/></p>
<div class="packt_infobox">Another annotation, <span><kbd>@EnableEurekaClient</kbd>, can also be used for </span>Eureka client configuration. The difference between <span><kbd>@EnableDiscoveryClient</kbd> and <kbd>@EnableEurekaClient</kbd> is that the former is more Spring-aware and works with discovery implementations other than Eureka, such as Consul and ZooKeeper; the latter is specific to Eureka only. So, if Eureka is present in the classpath, there is no difference between them.</span></div>
<p>Spring Cloud Eureka consists of client and server components. All the microservices are registered in the server registry, whereas each individual service behaves as a client. Any service that wants to discover other services should also be Eureka client-aware. The registration in the server happens with client identity (with its name) and URL (with its port).</p>
<p>The flow of communication between client and server happens as follows:</p>
<ol>
<li>On starting the microservice, it reaches out to the server component and provides metadata for registration.</li>
<li>Eureka server validates the metadata and does the registration.</li>
<li>After registration, the microservice endpoint sends the ping to the server registry every 30 seconds (by default) to mark its presence.</li>
<li>The server will continuously verify the ping requests, and if no request comes for a certain period of time, it will remove the service from the registry automatically.</li>
<li>The server shares the registry information with all Eureka-aware clients, and they store it in the local cache. This information is then used by a microservice client to locate other clients in the distributed environment.</li>
<li>The server pushes the updates of registry information to all clients every 30 seconds (by default).</li>
<li>Microservices registered with a server can be grouped into a zone. In this case, the zone information can be supplied at registration.</li>
<li>When any microservice sends a request for another microservice, Eureka server will try to search service instances running in the same zone to reduce the latency.</li>
<li>The interaction between the Eureka client and server happens through REST and JSON.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing an API gateway</h1>
                </header>
            
            <article>
                
<p>In typical microservice applications, it is quite possible that more than a hundred microservices are interacting with each other. There are certain common features that are required to be implemented for all these microservices: </p>
<ul>
<li><strong>Security</strong>: We may need to check that authentication and authorization, or any other security policies required to make calls to microservices</li>
<li><strong>Restrict call rate</strong>: This allows only a certain number of calls for a specific microservice in a given time</li>
<li><strong>Fault toleration</strong>: If any service fails to respond, this sends an appropriate error signal</li>
<li><strong>Monitor</strong>: This is used to monitor for specific events or values passed across the microservices</li>
<li><strong>Service aggregation</strong>: This provides an aggregate response from multiple microservices in a single response, specifically in a bandwidth-restricted environment</li>
<li><strong>Routing</strong>: Based on certain criteria (if call forwarding is required, for example), route all the calls from a specific user to a particular region to a specific service</li>
<li><strong>Load balancing</strong>: This maintains the flow of calls to balance the load on the service instance</li>
</ul>
<p>Apart from this, we may want to restrict some of the services to end users and keep them private. To achieve these goals, we need some sort of API gateway, which will intercept all the calls from end users and all inter-service communication. So, instead of microservices talking with each other directly through REST calls, they will now interact with each other through an API gateway, which will provide all the features previously listed. Since all the calls are routed from the API gateway, it can also be used for debugging and analytic purposes.</p>
<p>Spring Cloud provides API gateway support through another Netflix implementation called <strong>Zuul</strong>. Next up, let's see how to set up Zuul.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Zuul as an API gateway</h1>
                </header>
            
            <article>
                
<p>We will create a Zuul proxy server as an independent Spring Boot service and register it with the Eureka discovery server. Create a new Spring starter project in Spring STS with Zuul, Eureka Discovery, and DevTool as dependencies.</p>
<p>Once created, open the <kbd>bootstrap</kbd> class and update it as follows:</p>
<pre><strong>@EnableZuulProxy</strong><br/><strong>@EnableDiscoveryClient</strong><br/>@SpringBootApplication<br/>public class ZuulApiGatewayApplication {<br/>  public static void main(String[] args) {<br/>    SpringApplication.run(ZuulApiGatewayApplication.class, args);<br/>  }<br/>}</pre>
<p>The <kbd>@EnableZuulProxy</kbd> annotation will make this service a Zuul server. We also need to register it with the Eureka discovery server with the <kbd>@EnableDiscoveryClient</kbd> annotation. Every service registered with the Eureka name server needs a name (and a port). Add these details for the Zuul server in the <kbd>application.properties</kbd> file as follows: </p>
<pre>spring.application.name=zuul-api-gateway<br/>server.port=8781</pre>
<p>Now the API gateway server is ready and configured, but we did not specify what to do when intercepting requests. Zuul provides request handling support through various filters. They are categories in pre, post, routing, and error filters, each targeted for specific service call life cycles. <span>Since Zuul is a Spring Boot-based service, we can customize the API gateway programmatically. Additionally, f</span>or any special requirement, Zuul supports developing custom filters. We will see how to add custom filters and examine how requests can be intercepted with it in a short while. </p>
<div class="packt_infobox">The Zuul API gateway server is also referred to as an Edge server.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the UI</h1>
                </header>
            
            <article>
                
<p>As we have seen, the microservice architecture is the best fit for modern applications that are big and distributed in nature. This type of architecture helps split the team that's working on a single monolithic application into a set of small and independent teams, focusing on one single module or functionality.</p>
<p>A microservice pattern has its own benefits, such as managing scalability and complexity, and easily adopting new changes in a short time frame. We have explored how Spring Cloud components help build a distributed application in the Spring Framework. So far, we have only talked about the middle and backend layers. This section is dedicated to an interesting topic: how to design a microservice frontend.</p>
<p><span>Unlike monolithic architectures, the f</span>rontend of a microservice application can be designed with different approaches, as follows:</p>
<ul>
<li>Monolithic front</li>
<li>Micro front</li>
<li>Composite or modular front</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monolithic front</h1>
                </header>
            
            <article>
                
<p>Though the microservice pattern divides the monolithic backend into multiple independent services, this may not be straightforward for the frontend. In the monolithic front approach, we keep the whole user interface in a single big frontend application that will talk to corresponding services through REST calls to perform tasks or to show data to the end user, as per the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c86ced6f-0e67-4947-a5ac-6a7c40309ecb.png" style="width:66.08em;height:35.58em;"/></p>
<p>The clear benefits of this approach are an easy implementation and UI consistency across the application because everything is in a single place. On the downside, there may be a good amount of conflict regarding library versions, styling, and so on, as multiple teams are working on a single UI application.</p>
<p>Since everything is under one roof, it becomes harder to adopt changes as the application grows. Over a period of time, when business demand increases, it eventually becomes harder to maintain the application's UI as multiple teams spend most of their time solving problems. </p>
<p>Choose this approach only when you are sure that the application is divided into just a few microservices with limited scope for growth in the future.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Micro front</h1>
                </header>
            
            <article>
                
<p>In this approach, each microservice has its own UI limited to the functionality it performs. So, along with the backend, the frontend is also decomposed as per the scope of the individual microservices, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/107ebd29-6907-433e-b8c9-80b55929a67d.png" style="width:39.25em;height:30.42em;"/></p>
<p>This approach eliminates all the limitations of the monolithic frontend but then introduces certain new challenges. Though microservices are split as self-contained and independent executable units, and the final frontend should be presented with a single interface. In the micro front approach, the challenge is to combine the UIs of individual microservices in a single format. There are a number of ways of doing this. Though they overcome the limitations of the first approach, they introduce certain other issues:</p>
<ul>
<li><strong>Synchronize the UI across the microservices:</strong> In this way, just copy and paste the UI of all services to each other and use the API gateway. Though this seems simple, it produces huge maintenance issues.</li>
<li><strong>IFrame:</strong> Use a separate layout where the output of individual microservices can be clubbed with IFrame. However, this approach is also not brilliant because IFrame has its own limitations.</li>
<li><strong>HTML fragments:</strong> You can write your own JavaScript code and glue the content of the microservices through HTML fragments. However, there are some limitations, and also lots of custom script you have to write on your own. Also, there may be a chance of services' scripts and styles clashing. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite front</h1>
                </header>
            
            <article>
                
<p>This approach is a micro font approach with the right solution to aggregate the microservice output. The layout will be created with a single UI application, whereas the business UI of individual microservices will be plugged in from of web components, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/73dda3ad-a484-4091-910a-a683ad891fa5.png"/></p>
<p>Each microservice is responsible for producing a small UI area on the page. Composite UIs can be easily designed by creating a component in popular frontend frameworks such as Angular and React. On top of this, a framework such as <em>single-spa</em> (<a href="https://single-spa.js.org">https://single-spa.js.org</a>) is designed to show aggregate output. It is basically a JavaScript library that shows a composite output of microservices as a single-page application running in a browser. Single-spa allows the coexistence of microservices developed in different frameworks.</p>
<p>This means that you can develop one microservice in Angular, a second in React, a third with Vue, and so on. This brings great flexibility and fulfills the aim of the microservice architecture being developed completely independently from the backend to the UI. As an enhanced version of the second approach, the composite font approach not only overcomes the limitation of the monolithic front approach but also suggests the right way to develop the front layer in a microservice architecture. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other Spring Cloud and Netflix OSS components</h1>
                </header>
            
            <article>
                
<p>Spring Cloud provides a wrapper on top of various Netflix components that are used in microservice applications extensively. We have already explored the Eureka discovery server and Zuul. In this section, we will explore a few more Netflix OSS components, along with other Spring Cloud features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic configuration in Spring Cloud</h1>
                </header>
            
            <article>
                
<p>As we know, the microservice architecture <span><span>consists of </span></span>a number of small and independently deployable microservices that handle end-user calls and interact with each other. Based on the project's needs, they may run in various environments, such as development, testing, staging, production, and so on. To improve the scaling capabilities of an application, there may be multiple instances of microservices configured to work with the load balancer.</p>
<p>Each microservice possesses a set of configurations, including database configurations, <span>interaction with </span>other services, message broker configurations, and custom configurations. Handling microservice configurations between various environments is one of the most challenging parts of a microservice architecture.</p>
<p>Maintaining each microservices configuration manually would be too complex and difficult for the operations team. The best possible solution is to separate the configuration out from each microservice and maintain them all in one central place. This way, the dependency of environments on configuration can be handled more effectively. </p>
<p>Spring Cloud provides a component called <strong>Spring Cloud Config</strong>, which is used to externalize the microservice configuration. It uses a Git repository to store all the configurations in one place, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ad89b25b-5d72-4f41-8b14-386b396e11b6.png" style="width:23.17em;height:16.83em;"/></p>
<p>We will create a separate service for central configuration with the Spring Cloud Config feature. The next few sections explain how to do this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 1 – creating a Spring Boot service for the configuration server</h1>
                </header>
            
            <article>
                
<p>This is the most straightforward way of creating a component as a Spring Boot application. Create an application with STS and select the DevTool and Config server dependencies. Once the project is created, you can see the dependency in <kbd>pom.xml</kbd> that is responsible for adding Spring Cloud Config capabilities to the Spring Boot application, as follows:</p>
<pre>    &lt;dependency&gt;<br/>      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>      &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;<br/>    &lt;/dependency&gt;</pre>
<p>Next up, let's enable the Spring Cloud Config feature. Open the main <kbd>bootstrap</kbd> class and add the <kbd>@EnableConfigServer</kbd> <span>annotation, </span>which is used to enable external configuration:</p>
<pre><strong>@EnableConfigServer</strong><br/>@SpringBootApplication<br/>public class SpringCloudConfigServerApplication {<br/>  public static void main(String[] args) {<br/>    SpringApplication.run(SpringCloudConfigServerApplication.class, args);<br/>  }<br/>}</pre>
<p>Since the configuration server will also be registered with the naming server (Eureka server), we need to define certain properties in the <kbd>application.properties</kbd> file as follows: </p>
<pre>spring.application.name=spring-cloud-config-server<br/>server.port=8901</pre>
<p>Next up, let's install and configure Git.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 2 – configuring Spring Cloud Config with a Git repository</h1>
                </header>
            
            <article>
                
<p>The Spring Cloud Config server is ready. Now, we need to do the necessary configuration for Git repository integration. First, install the latest version of Git (<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>) on your local machine and make sure it is available on a path. Create a directory on your local machine and initialize the Git repository with the following command:</p>
<pre><strong>git init</strong></pre>
<p>This will create an empty Git repository on the local machine. Next, add a properties file that holds the configuration details. Since the configuration server can hold configuration details for multiple microservices in Git, we need to follow a certain naming <span>convention </span>for the property file, as follows:</p>
<pre>{microserivce-name}.properties<br/>{microservice-name}-{active-profile}.properties</pre>
<p>As we have seen, microservices' IDs (or names) are defined with the <kbd>spring.application.name</kbd> property in the <kbd>application.properties</kbd> file. So, we need to create a property file with this name in the Git repository. For example, if the microservice name is <kbd>catalog-service</kbd>, then you need to create a <kbd>catalog-service.properties</kbd> file and store all the configurations for that microservice.</p>
<p>For different environments, you can create a property file with an active profile appended after the microservice name. For example, the name of the property file for <span>the development environment </span>would be <kbd>catalog-service-dev.properties</kbd>. Once you have created the files, add the configuration details and commit them to the Git repository with the following command: </p>
<pre><strong>git add -A</strong><br/><strong>git commit -m "Comment for commit"</strong></pre>
<p>The Git repository is now ready, so we need to point the configuration server to it. Open the <kbd>application.properties</kbd> file of the configuration server as follows: </p>
<pre> spring.cloud.config.server.git.uri=file://D:/projects/book_writing/git_central_config</pre>
<p>Since this is the local Git repository, the location of the repository folder is given with <kbd>file://</kbd> to point it to the local filesystem. The configuration server also allows configuration with a remote Git repository. In this case, you need to give the Git clone URL something like <kbd>https://github.com/&lt;&lt;accoun-tname&gt;&gt;/&lt;&lt;repo-name&gt;&gt;.git</kbd> for the <kbd>spring.cloud.config.server.git.uri</kbd> property.</p>
<p>We will add some sample configurations and see how they can be reflected in the corresponding microservice. Create a<em> </em><kbd>service.properties</kbd> file and add the following property:</p>
<pre>catalog.sample.data=Hello world !!</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 3 – making each microservice Spring Cloud Config-aware using the Spring Cloud Config Client component</h1>
                </header>
            
            <article>
                
<p>The last step is to make the necessary changes to the microservice (configuration client) so that the configuration will be propagated by the configuration server once it is updated in the Git repository. The important point at this moment is to create a new property file called <kbd>bootstrap.properties</kbd> and copy all the properties from the <kbd>application.properties</kbd> file, or you can directly rename <kbd>application.properties</kbd> to <kbd>bootstrap.properties</kbd>.</p>
<p>The reason is that Spring will process the <kbd>bootstrap.properties</kbd> file first, even before the bootstrap application and configuration server linked with it for configuration updates. You need to add a specific property in the <kbd>bootstrap.application</kbd> file, which will be used to connect the microservice with the configuration server, as follows:</p>
<pre>spring.cloud.config.uri=http://localhost:8901</pre>
<p>The configuration server is accessible at <kbd>http://localhost:8901</kbd>. The microservice will fetch the configuration details with this URL. Next, we will access the configuration that we declared in the Git repository in the microservice with the REST controller, as follows:</p>
<pre>@RestController<br/>@RequestMapping("/api/test")<br/>@RefreshScope<br/>public class TestRESTController {<br/>  Logger logger = LoggerFactory.getLogger(this.getClass());<br/>  <br/>  @Value("${catalog.sample.data}")<br/>  private String data;<br/><br/>  @GetMapping("/getSampleData")<br/>  public String getSampleData() {<br/>    logger.info(" sample data value is --&gt;"+this.data);<br/>    return this.data;<br/>  }<br/>}</pre>
<p>In this controller, we are accessing the configuration with <kbd>catalog.sample.data</kbd> with the <kbd>@Value</kbd> annotation. This annotation is used to read the properties defined in the local <kbd>application.properties</kbd> file. The magic is that we haven't defined any such property for the category service, but it will connect to the configuration server and fetch this property value from the Git repository internally. </p>
<p>The <kbd>@RefreshScope</kbd> annotation will be used to fetch the latest configuration value whenever any change happens in the Git repository. You need to declare <span><kbd>@RefreshScope</kbd> for </span>the component where you are reading the configuration value. <span>When you start the <kbd>catalog-service</kbd> microservice, it will try to read the configuration from the configuration server, and you can verify it from the log as follows:</span></p>
<pre>[restartedMain] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://localhost:8901</pre>
<p>On startup, the <kbd>catalog-service</kbd> <span>microservice </span>will fetch the configuration from Git through the configuration server. This can be verified with the <kbd>http://localhost:8792/api/test/getSampleData</kbd> <span>REST URL. </span>When we make changes in the configuration and commit them to Git, they must be propagated to the microservice. This will not be done automatically, and you need to manually refresh it with Actuator—a tool provided by Spring Boot to monitor and manage applications. We will use the <kbd>/refresh</kbd> endpoint of Actuator to refresh the microservice with the latest configuration changes.</p>
<p>Staring with Spring Boot 2.0, certain endpoints of Actuator (including <kbd>/refresh</kbd>) are not enabled by default. To enable them, you need to add the following property in the <kbd>bootstrap.properties</kbd> file of the <kbd>catalog-service</kbd> microservice:</p>
<pre>management.endpoints.web.exposure.include=*</pre>
<p>Now, all endpoints are available, and configuration propagation can be done through a POST request to <kbd>http://localhost:8792/actuator/refresh</kbd>. Since this is a POST call, you need to use a REST client such as Postman. Once the refresh is completed, you will see the following output:</p>
<pre>[<br/>    "config.client.version",<br/>    "catalog.sample.data"<br/>]</pre>
<p>This is how configuration can be applied on the fly without restarting the microservice. The whole process can be performed in a series of actions in the following order:</p>
<ol>
<li>Update the files in the Git repository</li>
<li>Do the Git commit</li>
<li>Execute the refresh operation, and you will see the changes reflected in the corresponding microservice</li>
</ol>
<p>This is a great feature of managing configuration in one central place, and it can be applied to specific microservices with ease. However, not all properties can be applied this way. For example, application name and database-specific properties cannot be applied at runtime through Spring Cloud Config. However, custom configurations can be applied dynamically. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making RESTful calls across microservices with Feign </h1>
                </header>
            
            <article>
                
<p>In microservice architecture, generally microservices interact with each other through HTTP REST web service calls. Typically, <kbd>RestTemplate</kbd> is used as a client to make REST API call programmatically in Spring-based applications. However, it requires a good amount of code to make a simple REST call. To make this simple, Spring Cloud provides Feign, another REST client that makes REST communication alot simpler than <kbd>RestTemplate</kbd>. Let's see how Feign makes calls to other services easy. </p>
<p>For example, <kbd>inventory-service</kbd> needs to talk with the <kbd>catalog-service</kbd> <span>microservice </span>to fetch book details. In this case, <kbd>inventory-service</kbd> will make a REST call to fetch a <kbd>Book</kbd> object for a given <kbd>bookId</kbd>. This would typically happen with the <kbd>RestTemplate</kbd> client as follows: </p>
<pre> @GetMapping("/get-inventory/{bookId}")<br/>  public ResponseEntity&lt;BookDTO&gt; getInventory(@PathVariable("bookId") Integer bookId) {<br/>    String url = "http://localhost:8792/api/catalog/get-book/"+bookId;<br/>    RestTemplate restTemplate = new RestTemplate();<br/>    ResponseEntity&lt;BookDTO&gt; returnValue = restTemplate.getForEntity(url, BookDTO.class);<br/>    return returnValue;<br/>  }</pre>
<p>We are using <kbd>RestTemplate</kbd> to call the <kbd>catalog-service</kbd> <span>microservice </span>to fetch the book details for the given <kbd>bookId</kbd>. Spring Cloud inherits another component, called <strong>Feign</strong>, from Netflix, which can be used as a declarative REST client with great simplification. It is easily integrated with Ribbon, which can be used as a client-side load-balancer; we will talk about this in the next section. To use Feign, you need to add the following starter dependency:</p>
<pre>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Next, let's enable Feign. Open the <kbd>bootstrap</kbd> class and add a <kbd>@EnableDiscoveryClient</kbd> annotation to scan the Feign client, as follows:</p>
<pre>@SpringBootApplication<br/>@EnableDiscoveryClient<br/>@EnableFeignClients(basePackages="com.bookstore.inventory")<br/>public class InventoryServiceApplication {<br/>  public static void main(String[] args) {<br/>    SpringApplication.run(InventoryServiceApplication.class, args);<br/>  }<br/>}</pre>
<p>Now, we will use Feign to invoke the service. We need to create a Feign proxy to talk to other services, just like we use the JPA repository to interact with the database. A Feign proxy can be created with Java as follows:</p>
<pre>@FeignClient(name="catalog-service",url="http://localhost:8792", path="/api/catalog")<br/>public interface CatalogServiceProxy {<br/>  @GetMapping("/get-book/{bookId}")<br/>  public ResponseEntity&lt;BookDTO&gt; getInventory(@PathVariable("bookId") Integer bookId);<br/>}</pre>
<p>The <kbd>@FeignClient</kbd> annotation is used to define the Feign proxy. The <kbd>name</kbd> attribute points to the name of the target microservice declared in the Eureka naming server (specified with the <kbd>spring.application.name</kbd> property in the <kbd>application.properties</kbd> or <kbd>bootstrap.properties</kbd> file) we want to talk to. <kbd>url</kbd> is the address at which the target microservice is accessible. The <kbd>path</kbd> attribute is used to add the path prefix used by all method-level mapping.</p>
<p>We have created the interface method with the same method signature that we created in the REST controller. We will use this proxy in the REST controller as follows:</p>
<pre>@RestController<br/>@RequestMapping("/api/inventory")<br/>public class InventoryRESTController {<br/><br/>  @Autowired<br/>  CatalogServiceProxy catalogServiceProxy;<br/>  <br/>  @GetMapping("/get-inventory/{bookId}")<br/>  public ResponseEntity&lt;BookDTO&gt; getInventory(@PathVariable("bookId") Integer bookId) {<br/>    return catalogServiceProxy.getInventory(bookId);<br/>  }<br/>}</pre>
<p>The instance of <kbd>CatalogServiceProxy</kbd> is injected by Spring through the <kbd>@Autowired</kbd> annotation. You can see how simple it is to make a RESTful web service. All the details are shifted from the controller to the Feign proxy. You will get the same output as <kbd>RestTemplate</kbd>, but the code is decoupled and simplified. </p>
<p>Assume the scenario where you are making more <span>than a dozen </span>REST calls to the <kbd>catalog-service</kbd> microservice. In this case, the Feign proxy helps us to manage all the code in one place. Other component classes do not need to know the underlying details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Load balancing with Ribbon</h1>
                </header>
            
            <article>
                
<p>In the last section, we saw how <kbd>inventory-service</kbd> can call <kbd>catalog-service</kbd> to fetch book details through Feign. However, in a distributed environment, it is quite possible that multiple instances of microservices are created to handle the enormous application load.</p>
<p>In a multi-instance environment, a mechanism is required to balance and divide a load of input requests <span>seamlessly</span> to send them to available instances. The system becomes fault tolerant. It also increases throughput, reduces response time, and optimizes resource utilization by avoiding single instances being overloaded. This will make the system more reliable and highly available.</p>
<p>Netflix provides a component called Ribbon, which works as a client-side load balancer that provides lots of flexibility and control while making HTTP and TCP calls. The term <strong>client-side</strong> refers to an individual microservice as Ribbon can be used to balance the flow of calls a microservice makes to other services. </p>
<p>Eureka can be easily integrated with Ribbon; however, we can configure Ribbon without Eureka. We will see how to configure Ribbon with and without Eureka. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Ribbon without Eureka</h1>
                </header>
            
            <article>
                
<p>We are going to configure Ribbon while making calls from <kbd>inventory-service</kbd> to <kbd>catalog-service</kbd>, so if you have configured Eureka server, just remove it for the time being while we learn how Ribbon works without Eureka. The very first thing is to add the Ribbon starter dependency. Since we want to handle the call initiated from <kbd>inventory-service</kbd>, and add the dependency in <kbd>inventory-service</kbd> as follows:</p>
<pre>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>In the previous section, we configured the Feign client to handle REST calls. We will use Ribbon along with the Feign client. Open the proxy class that we created in the previous section and add the Ribbon configuration as follows:</p>
<pre>@FeignClient(name="catalog-service", path="/api/catalog" )<br/>@RibbonClient(name="catalog-service")<br/>public interface CatalogServiceProxy {<br/>  @GetMapping("/get-book/{bookId}")<br/>  public ResponseEntity&lt;BookDTO&gt; getInventory(@PathVariable("bookId") Integer bookId);<br/>}</pre>
<p>The <kbd>@RibbonClient</kbd> annotation is used to declare the Ribbon configuration with the <kbd>name</kbd> attribute pointing to the application on which we want to implement load balancing. The URL that we have configured with <kbd>FeignClient</kbd> is now removed and can be defined in the <kbd>application.properties</kbd> file as follows:</p>
<pre>catalog-service.ribbon.listOfServers=http://localhost:8792,http://localhost:8799</pre>
<p>The property name will start with the name of the application that we have used with the <kbd>@RibbonClient</kbd> annotation. We need to define comma-separated URLs, each pointing to an individual instance of the <kbd>catalog-service</kbd> microservice. As per this configuration, the Ribbon client will handle the call from <kbd>invoice-service</kbd> to <kbd>catalog-service</kbd>, which has two instances running on <span>ports </span><kbd>8792</kbd> and <kbd>8799</kbd>.</p>
<p>We will make the call to the Feign client on <kbd>inventory-service</kbd>, which eventually triggers the call to <kbd>catalog-service</kbd>. We will observe that the requests are divided into two instances of the <kbd>catalog-service</kbd> microservice. To verify which instance the request comes from, we will add the current server port in <kbd>BookDTO</kbd>, which will be shown in the response. The current server port can be obtained as follows:</p>
<pre>@Autowired<br/>private Environment env;<br/><br/>@GetMapping("/get-book/{bookId}")<br/>  public ResponseEntity&lt;BookDTO&gt; getBook(@PathVariable("bookId") Integer bookId) {<br/>   ......<br/>      bookDto.setSmallDesc(bookObject.getSmallDesc());<br/>      bookDto.setTitle(bookObject.getTitle());<br/>      bookDto.setPort(env.getProperty("local.server.port"));<br/>   ......<br/>}</pre>
<p>Spring injects the instance of the <kbd>Environment</kbd> class, which can be used to get current environment details. The current port is accessible with the <kbd>local.server.port</kbd> property. Next up, we will run two instances of the <kbd>catalog-service</kbd> microservice on these ports.</p>
<p>To start the Spring Boot application on a specific port, you need to right-click on the microservice project, select <span class="packt_screen">Run As | </span><span class="packt_screen">Run Configurations</span>, and add the port in the <span class="packt_screen">Arguments</span> tab with the <span class="packt_screen">-Dserver.port</span> argument. You can also append the port in <span class="packt_screen">Name</span> so that it can be easily identified as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f40a1aed-d764-49c7-8917-ea345252b22e.png" style="width:38.92em;height:27.00em;"/></p>
<p>To add another instance, you need to right-click on the same instance of <kbd>catalog-service</kbd> created in the previous window, select <span class="packt_screen">Duplicate</span>, and follow the same steps. The second time, use <span>port </span><kbd>8799</kbd> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f2b1602-77fb-4fc1-b903-eea34d132573.png" style="width:38.25em;height:25.42em;"/></p>
<p>Run these two instances along with <kbd>inventory-service</kbd>. When you access <kbd>http://localhost:8793/api/inventory/get-inventory/3</kbd>, you will see the port is <kbd>8792</kbd> in the first request and <kbd>8799</kbd> in the second request. This is how the request is routed to a specific instance turn by turn. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Ribbon with Eureka</h1>
                </header>
            
            <article>
                
<p>The problem in the first approach is that we still have to define the instance URLs manually. With Eureka, we can use its ability to resolve the microservice name dynamically and no more hardcore URLs are required. With Eureka, things are more straightforward. The Ribbon and Feign configuration will be changed as follows:</p>
<pre>@FeignClient(name="catalog-service", path="/api/catalog" )<br/>@RibbonClient(name="catalog-service")<br/>public interface CatalogServiceProxy {<br/>  @GetMapping("/get-book/{bookId}")<br/>  public ResponseEntity&lt;BookDTO&gt; getInventory(@PathVariable("bookId") Integer bookId);<br/>}</pre>
<p>No more <kbd>url</kbd> attributes are required for the <kbd>@FeignClient</kbd> annotation. Also, you can remove the <kbd>catalog-service.ribbon.listOfServers</kbd> <span>property </span>from the <kbd>application.properties</kbd> file of the <kbd>inventory-service</kbd> microservice. Start two instances of <kbd>catalog-service</kbd> along with <kbd>inventory-service</kbd> and make sure Eureka is running before you do. You will see two instances of <kbd>catalog-service</kbd> running in the Eureka console, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b591341b-b3d4-4f6e-ba89-4a2ee6feeaf1.png" style="width:35.50em;height:13.00em;"/></p>
<p>When you go to <kbd>http://localhost:8793/api/inventory/get-inventory/3</kbd>, you will get the same behavior. Once the request reaches the instance on port <kbd>8792</kbd>, the second is on <kbd>8799</kbd>, and the third is also on <kbd>8792</kbd>. This is how Ribbon is configured with Feign to achieve load balancing. You can try creating a few more instances and check the behavior. Also, if any of the instances are down, Ribbon will stop sending requests to them, which makes the system fault tolerant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Load balancing using RestTemplate</h1>
                </header>
            
            <article>
                
<p>Spring Cloud also supports the implementation of load balancing using <kbd>RestTemplate</kbd>. In this case, you need to expose the <kbd>RestTemplate</kbd> instance with load balancing capabilities instead of using it directly, as follows: </p>
<pre class="prettyprint b-c-s prettyprinted"><span class="lit">@LoadBalanced</span><span class="pln">
</span><span class="lit">@Bean</span><span class="pln">
</span><span class="typ">RestTemplate</span><span class="pln"> restTemplate</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RestTemplate</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}<br/><br/>@Autowired<br/>RestTemplate restTemplate;<br/></span></pre>
<p>In the previous case, the <kbd>@LoadBalanced</kbd> annotation will do the magic of balancing the load between the instances of other services to which we make a REST call. You need to inject this object in your controller and make the call with it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the API gateway</h1>
                </header>
            
            <article>
                
<p>In previous sections, we saw how to define Zuul as an API gateway. In subsequent sections, we explored other Netflix components, such as Feign and Ribbon, to make RESTful calls for inter-service communication. However, the interaction that we created happened directly between services. Though we have configured an API gateway with Zuul, we have not used it as a central point of the request flow. In this section, we will make the necessary configuration changes so that every request passes through our API gateway.</p>
<p>The very first thing we will learn is to implement a custom filter and configure it to the API gateway to trace the request and print it in the log. For simplicity, we will capture a few details about the current request. Open the Spring Boot application that we created for Zuul and add a filter class as follows: </p>
<pre>@Component<br/>public class CustomPreFilter extends ZuulFilter {<br/>  private static Logger _logger = LoggerFactory.getLogger(ZuulFilter.class);<br/>  <br/>  @Override<br/>  public boolean shouldFilter() {<br/>    return true;<br/>  }<br/>  @Override<br/>  public Object run() throws ZuulException {<br/>    HttpServletRequest request = RequestContext.<br/>                getCurrentContext().getRequest();<br/>    _logger.info("********** REQUEST STARTED ******************");<br/>    _logger.info("Port :"+ request.getLocalPort());<br/>    _logger.info("HTTP Method :"+ request.getMethod());<br/>    return null;<br/>  }<br/>  @Override<br/>  public String filterType() {<br/>    return "pre";<br/>  }<br/>  @Override<br/>  public int filterOrder() {<br/>    return 0;<br/>  }<br/>}</pre>
<p>For any custom filter, you need to extend an abstract class, <kbd>ZuulFilter</kbd>, which is provided by Netflix. There are certain abstract methods that we need to provide the implementation, as follows: </p>
<ul>
<li><kbd>shouldFilter()</kbd>: We apply this filter or not based on the return value of this method.</li>
<li><kbd>filterType()</kbd>: As we have seen, Zuul supports various filters type such as <kbd>pre</kbd>, <kbd>post</kbd>, <kbd>error</kbd><em>,</em> and so on. The <kbd>pre</kbd> <span>filter </span>will be executed after the request reaches Zuul and before it is routed to other microservices. Similarly, the <kbd>post</kbd> filter will be executed once the response returns from other microservices, and the <kbd>error</kbd> filter type will be triggered when an error happens in between.</li>
<li><kbd>filterOrder()</kbd>: We can define as many filters as we want. This method defines their order of priority.</li>
<li><kbd>run()</kbd>: This method is the placeholder where you can write your filter logic.</li>
</ul>
<p>We use will another filter that will be triggered once the response comes back, filter type <kbd>post</kbd>, as follows:</p>
<pre>@Component<br/>public class CustomPostFilter extends ZuulFilter {<br/>  private static Logger _logger = LoggerFactory.getLogger(ZuulFilter.class);<br/>  <br/>  @Override<br/>  public boolean shouldFilter() {<br/>    return true;<br/>  }<br/>  @Override<br/>  public Object run() throws ZuulException {<br/>    _logger.info("********* REQUEST ENDED *************");<br/>    return null;<br/>  }<br/>  @Override<br/>  public String filterType() {<br/>    return "post";<br/>  }<br/>  @Override<br/>  public int filterOrder() {<br/>    return 0;<br/>  }<br/>}</pre>
<p>Next, let's see how to access microservices through our API gateway. We have exposed a REST API for <kbd>inventory-service</kbd> as <kbd>http://localhost:8793/api/inventory/get-inventory/3</kbd>, and we will now update this URL to route the request from the API gateway. The pattern for the API gateway URL would be as follows:</p>
<pre>http://&lt;API_Gateway_Host&gt;:&lt;API_Gateway_Port&gt;/{service-name}/{uri}</pre>
<p>The Zuul API gateway will use the Eureka naming server to connect to the desired microservice. The service name in the previous pattern is the name <span>(with the </span><kbd>spring.application.name</kbd><span> property in the <kbd>application.properties</kbd> or <kbd>bootstrap.properties</kbd> file) </span>of the service registered in the Eureka naming server. The API gateway is accessible with <kbd>http://localhost:8781</kbd>, so to access the <kbd>inventory-service</kbd> URL with <span>the </span>API gateway, the new URL would be <kbd>http://localhost:8781/inventory-service/api/inventory/get-inventory/3</kbd>. You will get the request details in <span>the</span> Zuul log as follows:</p>
<pre>o.s.web.servlet.DispatcherServlet : Completed initialization in 9 ms <br/>com.netflix.zuul.ZuulFilter : ******************* REQUEST STARTED ***********<br/>com.netflix.zuul.ZuulFilter : Port :8781 <br/>com.netflix.zuul.ZuulFilter : HTTP Method :GET <br/>......... <br/>com.netflix.zuul.ZuulFilter : ******************* REQUEST ENDED *************</pre>
<p>This is how we can trace the request with various filters with the Zuul API gateway. However, the call is forwarded from <kbd>inventory-service</kbd> to <kbd>catalog-service</kbd> with Feign, which is still bypassing the API gateway and making a direct call to <span>the </span>microservice. Now, let's see how to configure Feign so that the call is routed through <span>the </span>Zuul API gateway. The original Feign proxy was as follows: </p>
<pre>@FeignClient(name="catalog-service", path="/api/catalog")<br/>@RibbonClient(name="catalog-service")<br/>public interface CatalogServiceProxy {<br/>...<br/>}</pre>
<p>The updated Feign proxy interface would be as follows:</p>
<pre><strong>@FeignClient(name="zuul-api-gateway", path="y/api/catalog")</strong><br/>@RibbonClient(name="catalog-service")<br/>public interface CatalogServiceProxy {<br/>....<br/>}</pre>
<p>The change happened in the service name of the <kbd>@FeignClient</kbd> annotation. Previously, it was directly pointing to <kbd>catalog-service</kbd>, but now it is pointing to <span>the </span>Zuul API gateway service. <kbd>zuul-api-gateway</kbd> is the name of the Zuul API gateway service defined with <span>the </span><kbd>spring.application.name</kbd> property in the <kbd>application.properties</kbd> file. </p>
<p>Run the URL again, and you will see the logs are printed twice. <span>The</span><span> loges are printed first,</span> when the request reaches <kbd>inventory-service</kbd>, and second when the request is routed from <kbd>inventory-service</kbd> to <kbd>catalog-service</kbd> through Feign. This is how Zuul is configured to trace every request made across the microservices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing an application</h1>
                </header>
            
            <article>
                
<p>In a typical monolithic application, when the user logs in, an HTTP session will be created to hold user-specific information, which will be then used until the session expires. The session will be maintained by a common security component on the server side and <span>all the requests are passed through it. So, it is straightforward to handle user authentication and authorization in a monolithic application.</span></p>
<p>If we want to follow the same pattern for microservice architecture, we need to implement a security component at every microservice level as well as in a central place (the gateway API) from where all the requests are routed. This is because microservices interact over the network, so the approach of applying security constraints is different.</p>
<p>Using Spring Security is a standard practice to meet the security needs of Spring-based Java applications. For microservices, Spring Cloud Security (another component from Spring Cloud) provides a one-stop solution to integrate Spring Security features with various components of the microservice architecture, such as the gateway proxy, a configuration server, load balancers, and so on.</p>
<p>In a microservice environment, security concerns can be addressed through widely used standard security protocols such as OAuth2 and OpenID Connect. In <a href="e36170b7-dbc6-4a4c-b7ba-e4830cd71efd.xhtml">Chapter 4</a>, <em>Building a Central Authentication Server</em>, we talked about OAuth2 in detail. Now, we will see how it can be used to meet security needs in a microservice architecture.</p>
<p>Let's see how the OAuth security system works in a microservice architecture. The high-level flow of authorization looks as follows: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2ea779af-d78b-45a3-816f-835331fe7f9a.png" style="width:36.33em;height:25.00em;"/></p>
<p>To understand the series of actions, let's take a use case of an order being placed by a user of the online bookstore. The whole process happens in the following steps:</p>
<ol>
<li>A user tries to access the order page through the Zuul proxy server (API gateway) and does not have a session or an access token.</li>
<li>The Zuul proxy then redirects a user to an authorization server with pre-configured <span>parameters such as </span>grant type, client ID, token URL, and authorization URL. </li>
<li>If the user does not log in, the authorization server redirects to the login page. </li>
<li><span>Once the user does log in w</span>ith valid credentials, the authorization server generates a token and sends it back to the API gateway.</li>
<li>On receiving the token, the API gateway (the Zuul proxy server) propagates the token downstream to the microservices it is proxying. </li>
<li>For restricted resources, the system will check whether a valid token exists. If not, the user will be redirected to the login page (or the token will be refreshed based on the grant type configured in the system).</li>
</ol>
<p>The authentication server will be implemented as a separate microservice and registered in the Eureka discovery server. It can be created as a Spring Boot application with security-specific starter dependencies as follows:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Spring Cloud Security has different starters for OAuth and standard Spring Security for the microservice architecture. Next, we will add the required configurations to make this application an authorization server, as follows:</p>
<pre>@Configuration<br/>@EnableAuthorizationServer<br/>public class CustomAuthorizationConfig extends AuthorizationServerConfigurerAdapter {<br/><br/>  @Autowired<br/>  @Qualifier("authenticationManager")<br/>  private AuthenticationManager authenticationManager;<br/>  <br/>  @Override<br/>  public void configure(ClientDetailsServiceConfigurer clients) throws Exception {<br/>    clients.inMemory()<br/>    .withClient("testClientId")<br/>    .secret(new BCryptPasswordEncoder().encode("test123"))<br/>    .authorizedGrantTypes("authorization_code", "refresh_token", "implicit", "password", "client_credentials")<br/>    .scopes("registeredUser","admin")<br/>    .redirectUris("http://localhost:8781/inventory-test/api/inventory/home")<br/>    .resourceIds("oauth2-server");<br/>  }<br/>  @Bean<br/>  public JwtAccessTokenConverter accessTokenConverter() {<br/>    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();<br/>    converter.setSigningKey("123");<br/>    return converter;<br/>  }<br/>  @Bean<br/>  public TokenStore tokenStore() {<br/>    return new JwtTokenStore(accessTokenConverter());<br/>  }<br/>  @Override<br/>  public void configure(<br/>      AuthorizationServerEndpointsConfigurer endpoints)<br/>          throws Exception {<br/>     endpoints<br/>    .authenticationManager(authenticationManager)<br/>    .tokenServices(tokenServices())<br/>    .tokenStore(tokenStore())<br/>    .accessTokenConverter(accessTokenConverter());<br/>  }<br/>  @Bean("resourceServerTokenServices")<br/>  @Primary<br/>  public DefaultTokenServices tokenServices() {<br/>    DefaultTokenServices defaultTokenServices = new<br/>        DefaultTokenServices();<br/>    defaultTokenServices.setTokenStore(tokenStore());<br/>    defaultTokenServices.setSupportRefreshToken(false);<br/>    defaultTokenServices.setAccessTokenValiditySeconds(120);<br/>    defaultTokenServices.setTokenEnhancer(accessTokenConverter());<br/>    return defaultTokenServices;<br/>  }<br/>  <br/>}</pre>
<p>The <kbd>@EnableAuthorizationServer</kbd> annotation is used to declare the component as an authorization server. OAuth can be done with various third-party clients, and Spring Security provides support for Google, Facebook, Okta, and GitHub out of the box. In our case, we will define a custom authorization server.</p>
<p class="mce-root">The <kbd>configure(ClientDetailsServiceConfigurer clients)</kbd> method of this class is used to define configuration for the custom authorization client. It initializes the client with various configurations, such as <kbd>ClientId</kbd>, secret (a kind of client password), possible authorization grant types you want the client to support, various scopes that can be used to fine-tune access control, and user authority and <kbd>resourceId</kbd>. </p>
<p>Spring OAuth is flexible enough to allow various mechanisms to generate the access token, and JWT is one of them. The <kbd>tokenStore()</kbd> and <kbd>tokenService<span><span>()</span></span></kbd> methods are used to apply the required configuration for JWT. The <kbd>configure(AuthorizationServerEndpointsConfigurer endpoints)</kbd> method is used to configure tokens, along with the authentication manager. The <kbd>AuthenticationManager</kbd> object is injected from the <kbd>WebSecurityConfig</kbd> class as follows:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>public class WebSecurityConfig extends WebSecurityConfigurerAdapter{<br/><br/>  @Override<br/>  @Bean("authenticationManager")<br/>  public AuthenticationManager authenticationManagerBean() throws<br/>  Exception {<br/>    AuthenticationManager authenticationManager = <br/>        super.authenticationManagerBean();<br/>    return authenticationManager;<br/>  }<br/>  @Override<br/>  public void configure(WebSecurity web) throws Exception {<br/>    web.ignoring().antMatchers("/js/**");<br/>    web.ignoring().antMatchers("/css/**");<br/>  }<br/>  @Override<br/>  protected void configure(AuthenticationManagerBuilder auth)<br/>      throws Exception {<br/>    auth.inMemoryAuthentication()<br/>    .withUser("john").password(<br/>        encoder().encode("999")).authorities("USER");<br/>  }<br/>  @Override<br/>  protected void configure(HttpSecurity http) throws Exception {<br/>    http<br/>    .authorizeRequests()<br/>    .antMatchers("/oauth/authorize","/oauth/token","/").permitAll()<br/>    .and()<br/>    .formLogin().loginPage("/login").permitAll();<br/>  }<br/>  @Bean("encoder")<br/>  public BCryptPasswordEncoder encoder(){<br/>    return new BCryptPasswordEncoder();<br/>  }<br/>}</pre>
<p>This class is responsible for configuring various endpoints, static resources, and the login page, along with the authentication mechanism. This is all about authorization server configuration. As we know, all requests are routed through the Zuul proxy server (an API Gateway), so we must configure it to route the requests for restricted resources to the authorization server.</p>
<p>The authorization server provides an access token that will be routed along with the request (in the header). When other microservices read it, they will verify the access token with the authorization server to allow the user to access restricted resources. In short, access tokens will be routed to various microservices. This requires some sort of SSO implementation, and with Spring Cloud Security, we can do it. </p>
<p>Additionally, particular functionality (for example, placing an order) initiated by a user will eventually involve interaction with other microservices along with the Zuul proxy server, so they are considered resource servers in OAuth terminology. First, add the <kbd>@EnableOAuth2Sso</kbd> annotation to a <kbd>bootstrap</kbd> class of the Zuul proxy application, as follows: </p>
<pre>@EnableZuulProxy<br/><strong>@EnableOAuth2Sso</strong><br/>@EnableDiscoveryClient<br/>@SpringBootApplication<br/>public class ZuulApiGatewayApplication {<br/>...<br/>}</pre>
<p>This annotation allows the Zuul proxy server to forward the access token generated by the authorization server downstream to other services involved in processing the request. The resource server configuration for the Zuul proxy server, as well as other microservices, should be as follows:</p>
<pre>@EnableResourceServer<br/>public class ResourceServerConfig extends ResourceServerConfigurerAdapter{<br/><br/>  private static final String RESOURCE_ID = "oauth2-server";<br/>  @Override<br/>  public void configure(ResourceServerSecurityConfigurer resources) {<br/>    resources<br/>    .tokenStore(tokenStore())<br/>    .resourceId(RESOURCE_ID);<br/>  }<br/>  @Override<br/>  public void configure(HttpSecurity http) throws Exception {<br/>    http<br/>    .requestMatcher(new RequestHeaderRequestMatcher("Authorization"))<br/>    .authorizeRequests()<br/>    // Microservice specific end point configuration will go here.<br/>    .antMatchers("/**").authenticated()<br/>    .and().exceptionHandling().accessDeniedHandler(new<br/>        OAuth2AccessDeniedHandler());<br/>  }<br/>  @Bean<br/>  public TokenStore tokenStore() {<br/>    return new JwtTokenStore(accessTokenConverter());<br/>  }<br/>  @Bean<br/>  public JwtAccessTokenConverter accessTokenConverter() {<br/>    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();<br/>    converter.setSigningKey("123");<br/>    return converter;<br/>  }<br/>}</pre>
<p>The <kbd>@EnableResourceServer</kbd> annotation will enable the component as a resource server. <kbd>resourceId</kbd> should be the same as we configured in the authorization server. Also, we are using the same JWT token configuration that we set in the authorization server. The <kbd>configure</kbd> method is used to set the configuration for individual microservice endpoints. </p>
<p>We also need to set certain properties in the <kbd>application.properties</kbd> file, which will be used by the resource server to interact with the authorization server as follows:</p>
<pre>#security.oauth2.sso.login-path=/login<br/>security.oauth2.client.access-token-uri=http://localhost:9999/oauth/token<br/>security.oauth2.client.user-authorization-uri=http://localhost:9999/oauth/authorize<br/>security.oauth2.client.client-id=testClientId<br/>security.oauth2.client.client-secret=test123<br/>security.oauth2.client.scope=registeredUser,admin,openid<br/>security.oauth2.client.grant-type=implicit<br/>security.oauth2.resource.id=oauth2-server<br/>security.oauth2.resource.jwt.key-value=123</pre>
<p>The authorization server is configured to access <kbd>localhost:9999</kbd>. The resource server configuration, along with previous properties, need to be placed with every microservice that we want to access securely through OAuth.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Unlike other chapters and applications that we have seen so far in this book, this chapter introduced a new type of application development in a distributed environment. The term <strong>microservice</strong> has existed since 2011. It has emerged as an enhancement of previous architectures. </p>
<p>With the introduction of Spring Cloud, developers can provide an implementation of various common patterns in a distributed environment. Starting with Spring Boot, creating a microservice application just takes a few configurations.</p>
<p>At the beginning of this chapter, we have explored what a microservice is and how it differs from the monolithic architecture, followed by various principles and criteria that need to be adhered to if you want to develop a microservice system. We then explored various Spring Cloud components and other Netflix OSS components in brief.</p>
<p>We have also learned how to create a microservice application by building a real-life example—an online bookstore application. We started with the application's architecture and the database design. We looked at creating microservices as Spring Boot applications with the required configurations.</p>
<p>We then saw practical examples of how to build various Netflix OSS and Spring Cloud components, such as a Eureka discovery server, a Zuul proxy server, a Feign client, Ribbon, and Spring Cloud Config. These components are the building blocks for developing a distributed application. We also saw various options and approaches to building a microservice frontend. Finally, we secured the application with Spring Cloud Security.</p>
<p>Java was the only de facto programming language for building Spring-based applications for quite a long time. However, the team at Pivotal (the company behind Spring) has started to support other functional programming languages, such as Scala. Starting with version 5, Spring announced support for Kotlin, a JVM-based language mainly used for Android applications. In the next chapter, we will dive into an altogether new way of building Spring applications with Kotlin.</p>


            </article>

            
        </section>
    </body></html>