- en: Chapter 3. Introducing Java EE 7 – EJBs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned some basics about how to set up and deploy
    a Hello World application on WildFly. In this chapter, we will go a little deeper
    and learn how to create, deploy, and assemble Enterprise JavaBeans, which are
    at the heart of most Enterprise applications. Additionally, you will learn how
    to use Maven, a popular build tool, which can ease the packaging process of our
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, here is what you will learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What changes are introduced by the new EJB 3.2 specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a Java EE 7 Maven project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to develop a singleton EJB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create stateless and stateful Enterprise JavaBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add and manage schedulers and timers to your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make use of asynchronous APIs in an EJB project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EJB 3.2 – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the **Enterprise JavaBeans** (**EJB**) specification, Enterprise JavaBeans
    are components that typically implement the business logic of Java Enterprise
    Edition applications (for Java EE, note that Oracle advises against using JEE
    as the acronym for Java Enterprise Edition; for more information about acronyms
    for Java-related technologies, visit [https://java.net/projects/javaee-spec/pages/JEE](https://java.net/projects/javaee-spec/pages/JEE)).
    Because of their transactional nature, EJBs are also commonly used for the construction
    of the data access layer in many applications. However, in the newest version
    of the specification, container-managed transactions are no longer exclusive for
    Enterprise JavaBeans and can be reused in other parts of the Java EE platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are basically three types of Enterprise JavaBeans:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session beans**: This is the most commonly used EJB type. The container manages
    multiple instances of every class that is defined as a session bean (with an exception
    for singletons, which have only one instance). When an operation implemented by
    EJB must be executed (for example, because a user has requested an update of an
    entity in the database), the container assigns a session bean instance for the
    specific user. This code is then executed on behalf of the calling client. The
    container is responsible for providing session beans with multiple system-level
    services, for example, security, transactions, or distribution of beans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven beans** (**MDB**): MDBs are Enterprise beans that can asynchronously
    process messages sent by any JMS producer. (We will discuss MDBs in [Chapter 6](part0035_split_000.html#page
    "Chapter 6. Developing Applications with JBoss JMS Provider"), *Developing Applications
    with JBoss JMS Provider*.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity objects**: An EJB is used to represent entities in a database. The
    newest version of the specification made this type of Enterprise JavaBeans optional,
    so they may not be supported in all containers (their support has also been dropped
    in WildFly). Entity objects will be removed from the specification in Java EE
    8\. Currently, in Java EE 7, the main persistence technology is Java Persistence
    API. We will discuss JPA in [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining
    Persistence with CDI"), *Combining Persistence with CDI*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, session beans can be divided into three subtypes based on their
    characteristics and usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless session beans** (**SLSB**): These are objects whose instances have
    no conversational state with the client that has invoked an operation on them.
    This means that all these bean instances are equal when they are not servicing
    a client, and the container can prepare a pool for them to handle multiple requests
    in parallel. Because they do not store any state, their performance overhead is
    quite low. A common usage scenario for an SLSB would be a stateless service responsible
    for retrieving objects from a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateful session beans** (**SFSB**): SFSB supports conversational services
    with tightly coupled clients. A stateful session bean accomplishes a task for
    a particular client and it cannot be shared between multiple callers. It maintains
    the state for the duration of a client session. After session completion, the
    state is not retained. The container may decide to passivate (serialize and store
    for future usage) a stale SFSB. This is done to save resources of the application
    server or in some cases, to support SFSB failover mechanism in a domain of application
    servers (this is the case in JBoss AS 7 and WildFly). Starting from EJB 3.2, it
    is possible to disable passivation for a specific SFSB, although it may affect
    the server''s stability and failover capability. A shopping cart could serve as
    a simple use case for an SFSB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton EJB**: This is essentially similar to a stateless session bean;
    however, it uses a single instance to serve client requests. So, you can guarantee
    the use of the same instance across invocations. Singletons can use a richer life
    cycle for a set of events, along with the possibility to control when a bean is
    initialized. Also, a more strict locking policy to control concurrent access to
    the instance can be enforced, so that the shared state of the singleton bean can
    be used by multiple clients. If the application is distributed on multiple nodes
    of a domain, then every running JVM will have its own instance of the singleton
    bean. We will discuss this a little further in [Chapter 11](part0057_split_000.html#page
    "Chapter 11. Clustering WildFly Applications"), *Clustering WildFly Applications*.
    Because of their special characteristics, singletons can be used to save the state
    of the application, cache, or initialize some resources during the application''s
    startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the container manages the instances of the beans,
    but the clients should call them through business interfaces. There are three
    types of a session bean''s views available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local business interface**: This session bean is used when the bean and its
    client are in the same container. It uses the pass-by-reference semantic, so the
    return values and method parameters are based on references and not copies of
    the objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote business interface**: In this session bean, the locations of the client
    and the bean are independent (the client may reside in another container or without
    a container at all, for example, as a standalone application). Every parameter
    and return value is serialized and copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No-interface view**: This session bean is a variant of the local business
    view that does not require a separate interface, that is, all `public` methods
    of the bean class are automatically exposed to the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since EJB 3.1, it is possible to use asynchronous methods. These are able to
    process client requests asynchronously, just like MDBs, except that they expose
    a typed interface and follow a more complex approach to process client requests.
    It is possible to use two approaches to achieve this kind of behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire-and-forget asynchronous void methods, which are invoked by the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve-result-later asynchronous methods, which have the `Future<?>` return
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What more should you know about EJBs before proceeding? When you develop an
    Enterprise JavaBean, you have to follow some general rules, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using nonfinal static fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't manually create threads (we will cover this topic more deeply in [Chapter
    12](part0062_split_000.html#page "Chapter 12. Long-term Tasks' Execution"), *Long-term
    Tasks' Execution*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use synchronization primitives (except in singletons with bean-managed
    concurrency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual file operations on the filesystem and listening on sockets are forbidden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native libraries should not be loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disobeying these rules could cause security and stability issues with the EJB
    container. A comprehensive list of disallowed activities can be found at [http://www.oracle.com/technetwork/java/restrictions-142267.html](http://www.oracle.com/technetwork/java/restrictions-142267.html)
    along with some explanations for specific points.
  prefs: []
  type: TYPE_NORMAL
- en: Since it's easier to grasp the concepts with real examples, in the next section,
    we will provide a concrete application example that introduces some of the features
    that we described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing singleton EJBs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name implies, `javax.ejb.Singleton` is a session bean that guarantees
    that there is at most one instance in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides this, singleton EJBs fill a well-known gap in EJB applications, that
    is, the ability to have an EJB notified when the application starts and also when
    the application stops. So, you can do all sorts of things with an EJB that you
    previously (before EJB 3.1) could only do with a load-on-startup servlet. EJB
    also gives you a place to hold data that pertains to the entire application and
    all the users using it, without the need for static class fields.
  prefs: []
  type: TYPE_NORMAL
- en: In order to turn your EJB into a singleton, all that is needed is to apply the
    `@javax.ejb.Singleton` annotation on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A singleton bean is similar to a stateful bean, in that, state information is
    maintained across method invocations. However, there is just one singleton bean
    for each server JVM, and it is shared by all of the EJBs and clients of an application.
    This type of bean provides a convenient means to maintain the overall state of
    an application. However, if the application is distributed on multiple machines
    (and therefore multiple JVMs), the singleton is unique on every one of them. Any
    application state must be synchronized between the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Another annotation that is worth learning is `@javax.ejb.Startup`, which causes
    the bean to be instantiated by the container when the application starts. This
    invokes the method decorated with the `@javax.annotation.PostConstruct` annotation
    if you have defined one in your EJB.
  prefs: []
  type: TYPE_NORMAL
- en: We now have enough information to understand our first EJB example. There is
    more than one alternative to create a Java Enterprise project. In the earlier
    chapter, we illustrated how to start from a project based on Eclipse Java EE (a
    dynamic web project), binding it later to a WildFly runtime installation. This
    is obviously the simplest choice, and you can easily run the examples contained
    in this book using this pattern; however, when it comes to enterprise solutions,
    it's no surprise that almost every project now uses some kind of build automation
    tool. For this book, we will propose Apache Maven, as it is one of the most popular
    choices, but not the only one. Gradle is a similar project that uses the Groovy
    language to describe project structure, dependencies, and build workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the benefits that you will achieve when turning to Maven projects include
    a well-defined dependency structure, the conventions of a project build's best
    practices, and project modular design, just to mention a few. Additionally, when
    you have an automated build process, you can use continuous integration tools
    (such as Jenkins) to schedule automated tests and deployments of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: All major IDEs have built-in Maven support. This includes the Eclipse Java EE
    Luna release.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create our first Maven project directly from Eclipse. Navigate to
    **File** | **New** | **Other** | **Maven** | **Maven Project**. This is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing singleton EJBs](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Next**; you will be taken to the following intermediary screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing singleton EJBs](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Maven allows the use of archetypes when creating a new project. They define
    a project's basic dependencies, resources, structure, and so on. For example,
    you can use a web application archetype in order to get an empty project skeleton,
    which you can just build and deploy. Unfortunately, archetypes are often outdated,
    and you still need to adjust them for your needs. In order to use some Java EE
    7 archetypes, you have to first define a repository and archetypes you would like
    to use, and then you can create a project. In real life, you will probably create
    every new project by just looking at your previous ones, without using any archetypes.
    So, here we will show how to create a project from scratch. You might also be
    interested in some additional Java EE-related tools such as JBoss Forge, whose
    description you will find in the [Appendix](part0067_split_000.html#page "Appendix A. Rapid
    Development Using JBoss Forge"), *Rapid Development Using JBoss Forge*.
  prefs: []
  type: TYPE_NORMAL
- en: On the visible screen, check the **Create a simple project** checkbox. With
    this option, we will skip the archetype selection. You can click on **Next**.
    Now, you have to complete some basic project information. We are creating a server-side
    EJB application, which also has a standalone client. These two projects can share
    some common information, for example, about dependencies and their versions. Hence,
    we want to create a Maven multimodule project. In this first step, let's create
    a parent project that has a POM packaging. POM is a Maven convention used to describe
    the structure of a project and its modules. More information on this can be found
    in Sonatype free books that we mentioned in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can complete the wizard by entering some package-specific information,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing singleton EJBs](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For **Group ID** (an abstract identifier with a similar role as in Java packages),
    you can use `com.packtpub.wflydevelopment.chapter3`. For **Artifact ID** (a simplified
    name of our project), just use `ticket-agency`. Set the **Packaging** field to
    **pom**, and you can leave the default selection for the project's **Version**
    field. Click on **Finish** in order to complete the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at our newly created project. At the moment, it contains only `pom.xml`,
    which will be the base for new modules. Navigate again to **File** | **New** |
    **Other** | **Maven** but now choose the **New Maven Module**. You can now see
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing singleton EJBs](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Again, we want to skip the archetype selection, so check the **Create a simple
    project** option. Under the **Parent Project**, click on **Browse** and select
    the parent we created a while ago. Under **Module Name**, enter `ticket-agency-ejb`.
    Click on **Next**. You will be presented with the following screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing singleton EJBs](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s discuss the packaging type. There are a few possible archive types
    for Java EE deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The EJB module**: This module usually contains classes for EJBs, packed as
    a .`jar` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The web module**: This archive can additionally contain web elements such
    as servlets, static web files, REST endpoints, and so on. It is packed as a `.war`
    file (web archive) file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The resource adapter module**: This archive contains files related to JCA
    connectors (described in [Chapter 6](part0035_split_000.html#page "Chapter 6. Developing
    Applications with JBoss JMS Provider"), *Developing Applications with JBoss JMS
    Provider*). It is packed as a `.rar` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Enterprise archive**: This archive aggregates multiple Java EE modules
    (EJB, Web) with related descriptors. It is packed as a `.ear` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we want to deploy only EJBs without any web elements, so let's set the
    packaging to EJB (if it is not visible in the Eclipse drop-down menu, just manually
    type it) and click on **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the same steps to add a second module with the name `ticket-agency-ejb-client`
    and JAR packaging . This will be a simple client for services exposed in `ticket-agency-ejb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at our parent project `pom.xml`. It should define two recently created
    modules, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected outcome of these operations should match the following screenshot,
    which has been taken from the Project Explorer view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing singleton EJBs](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the **ticket-agency-ejb** and **ticket-agency-ejb-client**
    projects have been organized as a standard Maven project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/java` will contain our source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/resources` is meant for the configuration (containing a bare-bones
    `ejb-jar.xml` configuration file for the EJB project)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/test/java` is used to store the test classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the moment, we will focus on the main file `pom.xml`, which needs to be aware
    of the Java EE dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the EJB project object module (pom.xml)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before digging into the code, first you need to configure Maven's `pom.xml`
    configuration file further. This file is quite verbose, so we will illustrate
    just the core elements here that are required to understand our example, leaving
    the full listing to the code example package of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we are going to add just after the properties section is a
    reference to Java EE 7 API, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This dependency will add all Java EE 7.0 APIs' definitions. Scope is set to
    be provided, which means the dependency is available on the target environment
    (in our case, the application server), and does not need to be included in the
    built archive. This dependency is universal, and should work with all Application
    Servers that are compatible with Java EE 7.0, not only with WildFly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to add a second dependency, which is the JBoss logging API. Place
    this definition in the same `<dependencies> </dependencies>` tags, for example,
    below `javaee-api`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scope provided includes the enterprise dependencies and corresponds to
    adding a library to the compilation path. Therefore, it expects the JDK or a container
    to provide the dependency at runtime. Besides dependencies, we would like to configure
    the build process. The created project specifies the EJB packaging, but the build
    is performed with the JDK 1.5 compliance level and an old EJB version. This is
    why we want to add an additional block to `pom.xml`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This block does two things, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `maven-compiler-plugin` configuration enforces the usage of Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `maven-ejb-plugin` configuration defines that EJB 3.2 version was used,
    and enables generation of the EJB client (disabled by default) package for EJB
    client applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, check the `src/main/resources/META-INF/ejb-jar.xml` file. It might contain
    the configuration from EJB 2.1\. Instead, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you will be able to compile your project; so, we will start adding
    classes, but we will return to the `pom.xml` file when it's time to deploy your
    artifact.
  prefs: []
  type: TYPE_NORMAL
- en: Coding our EJB application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating EJB classes does not require getting mixed up with fancy wizards; all
    you need to do is add bare Java classes. Therefore, from the **File** menu, go
    to **New** | **Java Class**, and enter `TheatreBox` as the classname and `com.packtpub.wflydevelopment.chapter3.control`
    as the package name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the following implementation to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see our application code in detail; the void method `setupTheatre` is
    invoked as soon as the application is deployed and takes care of assembling the
    theatre seats, creating a simple map of the `Seat` objects. Seat identifiers are
    key factors in this map. This happens right after deployment because our bean
    is annotated with `@Singleton` and `@Startup` that force the container to initialize
    the bean during startup. Each `Seat` object is constructed using a set of three
    field constructors, which includes the seat ID, its description, and the price
    (the booked field is initially set as false). This is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that our `Seat` object is an immutable one. After we create an instance,
    we will not be able to change its state (the value of the fields, all of them
    are final, and no setters are exposed). This means that when we return a `Seat`
    object to the client (local or remote), it will be only available for reading.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the singleton bean exposes four public methods; the `getSeats` method
    returns an unmodifiable collection of `Seat` objects, which will return the information
    regarding whether they have been reserved or not to the user. The collection must
    be unmodifiable because our Singleton exposes a no-interface view, which means
    that we are using the pass-by-reference semantic. If we will not protect the collection,
    then every change on an element of the returned collection will be done on our
    cache. What's more, the client can add or remove elements to our internal collection!
  prefs: []
  type: TYPE_NORMAL
- en: The `getSeatPrice` method is an utility method, which will pick up the seat
    price and return it as `int`, so it can be used to verify whether the user can
    afford to buy the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: The `getSeat` method returns an immutable `Seat` object for a given ID. Once
    more, we return an immutable `Seat` because we don't want the client to change
    the object without using the `TheatherBox` bean.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `buyTicket` method is the one that actually buys the ticket and,
    therefore, sets the ticket as booked. We cannot change the value of an immutable
    object, but we can replace it with a new one, which contains another value. The
    newly created object is placed in the hashmap instead of the old one.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling bean concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might have noticed, the bean includes a `@Lock` annotation on top of
    the methods managing our collection of `Seat` objects. This kind of annotation
    is used to control the concurrency of the singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent access to a singleton EJB is, by default, controlled by the container.
    Read/write access to a singleton is limited to one client at a time. However,it
    is possible to provide a finer level of concurrency control through the use of
    annotations. This can be achieved using the `@Lock` annotation, whose arguments
    determine the type of concurrency access permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a `@Lock` annotation of type `javax.ejb.LockType.READ`, multithreaded
    access will be allowed to the bean. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we apply `javax.ejb.LockType.WRITE`, the single-threaded
    access policy is enforced, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The general idea is to use `READ` type locks on methods that just read values
    from the cache and `WRITE` type locks for methods that change the values of elements
    contained in the cache. Keep in mind that `WRITE` type locks block all methods
    with `READ` type locks. It is crucial that the singleton will have exclusive control
    of the modifications of its state. Lack of proper encapsulation mixed with the
    pass-by-reference semantic (used in local and no-interface views of EJBs) can
    lead to hard-to-find concurrency bugs. Using immutable objects as return values
    for singletons is a good strategy to solve these kind of problems. Another strategy
    would be to return only copies of our objects or switching to the pass-by-value
    semantic. The last strategy can be applied by switching to a remote business interface
    in the singleton.
  prefs: []
  type: TYPE_NORMAL
- en: In the `TheatreBox` code, you have probably noticed a `@AccessTimeout` annotation
    (with value `5` and unit `TimeUnit.MINUTES`). When you execute a query against
    a method with `@Lock (WRITE)`, and if some other thread is already accessing it,
    then after 5 seconds of waiting, you will get a timeout exception. In order to
    change this behavior (for example, by prolonging the allowed wait time), you can
    specify a `@javax.ejb.AccessTimout` annotation at the method or class level.
  prefs: []
  type: TYPE_NORMAL
- en: Using bean-managed concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other possible option is to use a bean-managed concurrency strategy that
    can be pursued by applying the `@javax.ejb.ConcurrencyManagement` annotation with
    an argument of `ConcurrencyManagementType.BEAN`. This annotation will disable
    the effect of the `@Lock` annotation we have used so far, putting the responsibility
    of ensuring that the singleton cache does not get corrupted on the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to ensure that our bookings are preserved, we will need to use
    a well-known synchronized keyword on top of the `buyTicket` method, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since concurrent access is restricted when a thread enters the synchronized
    block, no other methods are allowed to access the object while the current thread
    is in the block. Using a synchronized block is equivalent to having a container-managed
    concurrency with default locks of type `WRITE` on all methods. This is one of
    the few places in Java EE when the developer may use synchronization primitives
    without affecting the stability of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Cooking session beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our singleton EJB is equipped with the methods to handle our store of theatre
    seats. We will now add a couple of session beans to our project to manage the
    business logic, a stateless session bean that will provide a view of the theatre
    seats and stateful beans that will behave as a payment gateway to our system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The choice of splitting our information system into two different beans is not
    part of a design pattern in particular, but serves a different purpose. That is,
    we would like to show how to look up both types of beans from a remote client.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a stateless bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, the first bean we will create is `com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfo`,
    which barely contains the logic to look up the list of theatre seats. In practice,
    this bean acts as a facade for our singleton bean, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since we are planning to invoke this EJB from a remote client, we defined a
    remote interface for it with the `@Remote(TheatreInfoRemote.class)` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, take a look at the `@EJB TheatreBox` `box`, which can be used to safely
    inject an EJB into your class without the need of a manual JNDI lookup. This practice
    can be used to increase the portability of your application between different
    application servers, where different JNDI rules might exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remote interface of your bean will be as simple as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are planning to expose your EJB to local clients only (for example, to
    a servlet), you can leave out the remote interface definition and simply annotate
    your bean with `@Stateless`. The application server will create a no-interface
    view of your session bean, which can safely be injected into your local clients
    such as servlets or other EJBs. Be mindful that this also changes the semantics
    of the methods parameters and return values. For remote views, they will be serialized
    and passed by value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a stateful bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to keep track of how much money our customer has got in his pocket,
    we will need a session-aware component. Turning a Java class into a stateful session
    bean is just a matter of adding a `@Stateful` annotation on top of it, as in our
    example `com.packtpub.wflydevelopment.chapter3.boundary.TheatreBooker` class.
    This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the previous bean bears a `@PostConstruct` annotation to initialize
    a session variable (money) that will be used to check whether the customer has
    enough money to buy the ticket. When using EJBs, we don't use `constructors` and
    `destructors` to perform actions on an object to create or destroy. The reason
    is that the point object might not have injected all objects it depends on. The
    method annotated with `@PostConstruct` is executed when object creation is already
    finished, that is, all objects are injected to it. There is a second annotation
    related to the EJB life cycle, `@PreDestroy`, which is executed before the object
    is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, the ultimate purpose of our SFSB is to invoke the `buyTicket`
    method of our singleton after having performed some business checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the business checks do not pass, the application will issue some exceptions.
    This is the case, for example, if the seat has already been booked or if the customer
    hasn''t got enough money to buy the ticket. In order to keep our conversation
    going, it''s important that our exception will be an extension of the generic
    `Exception` class. Refer to the following code for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we use a runtime exception (for example, `EJBException`), the bean instance
    will be discarded, and the communication between the remote client and server
    will be dropped. So, always take care to choose the appropriate type of exception
    when dealing with EJBs—choose to throw a runtime exception if you are dealing
    with an unrecoverable scenario (the connection with the enterprise information
    system is dropped). This kind of exception is called a System Exception. On the
    other hand, consider throwing a checked exception (or simply not throwing exceptions
    at all), if you are dealing with a business kind of exception; for example, if
    the booked seat is already engaged. Recoverable exceptions are called Application
    Exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a possibility to mark a runtime exception (which would normally
    be a System Exception) as a recoverable exception, using the `@ApplicationException`
    annotation. You may even decide if the current transaction should be rolled back
    (which is the default behavior for system exceptions) using `@ApplicationException`
    (with rollback `true`) on an exception class or the `EJBContext.setRollbackOnly`
    statement inside a business method. The decision to roll back a transaction is
    up to the developer, and in most cases, it depends on the business scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the EJB application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As it is, you should be able to package your EJB project by issuing the following
    Maven goal and starting a command-line prompt from your project root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will compile and package the application that needs to
    be copied into the `deployments` folder of your application server. This is fine;
    however, we can expect lots more from Maven by installing just a couple of plugins.
    In our case, we will configure our project to use Maven''s WildFly plugin by adding
    the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the first part of the XML fragment, we specified the project's `finalName`
    attribute, which will dictate the name of the packaged artifact (in our example,
    the project's name corresponds to our project's artifact ID, so it will be named
    `ticket-agency-ejb.jar`).
  prefs: []
  type: TYPE_NORMAL
- en: The artifact ID named `wildfly-maven-plugin` will actually trigger the WildFly
    Maven plugin that will be used to deploy our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once you have configured the WildFly plugin, your application can be deployed
    automatically by entering from your project root. This can be done by typing the
    following command in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since deployment is a repetitive task for a developer, it would be convenient
    to execute this operation from within the Eclipse environment. All you need is
    to create a new **Run Configurations** setting from the upper menu by navigating
    to **Run** | **Run Configurations**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the project''s base directory (hint: the **Browse Workspace...** utility
    will help you pick up the project from your project list) and type your Maven
    goal into the **Goals** textbox, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the EJB application](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once this is done, please ensure that your WildFly instance is running. Click
    on **Apply** to save your configuration and then click on **Run** to execute the
    deployment of the application. The Maven plugin will activate and once it is verified
    that all classes are up to date, start deploying the applications to WildFly using
    the remote API. Note that you do not need to pass any username or password for
    the deployment. This is possible because you are deploying your application from
    the same machine that WildFly is installed on. A local user authentication is
    done under the hood so that programmers will not need to cover this on their development
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'After issuing the command, you should expect a success message on the Maven
    console, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, on the WildFly console, you have quite a verbose output
    that points out some important EJB JNDI bindings (we will return to it in a minute)
    and informs us that the application has been deployed correctly. This is depicted
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Despite the fact that we are working on WildFly, we can quite frequently see
    information from JBoss AS subsystems on the console. This is because WildFly is
    built straight on the JBoss AS 7 codebase, and should not be worried about.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a remote EJB client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a remote EJB client for the WildFly application server is very similar
    to AS7\. The big difference can be noticed between AS6 and newer releases.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, previous versions of WildFly (JBoss AS versions before
    7.x) used the JBoss naming project as the JNDI naming implementation, so developers
    are familiar with `jnp:// PROVIDER_URL` to communicate with the application server.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with AS7, the JNP project is no longer used—neither on the server side
    nor on the client side. The client side of the JNP project has now been replaced
    by the jboss-remote-naming project. There were various reasons why the JNP client
    was replaced by the jboss-remote-naming project. One of them was that the JNP
    project did not allow fine-grained security configurations while communicating
    with the JNDI server. The jboss-remote-naming project is backed by the jboss-remoting
    project which allows much more and better control over security.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the new naming implementation in AS7 and WildFly, there is no longer
    any support to bind custom JNDI names to EJBs. So the beans are always bound to
    the spec's mandated `java:global`, `java:app`, and `java:module` namespaces. Therefore,
    setting the JNDI name for the session bean element via an annotation or configuration
    file is no longer supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what will be the JNDI name used to invoke a stateless session bean? Here
    it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A bit verbose, isn''t it? However, the following table will help you get through
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `app-name` | This is the enterprise application name (without `ear`), if
    your EJB has been packed in an EAR |'
  prefs: []
  type: TYPE_TB
- en: '| `module-name` | This is the module name (without `.jar` or `.war`), where
    your EJB has been packed |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct-name` | Using this, you can optionally set a distinct name for
    each deployment unit |'
  prefs: []
  type: TYPE_TB
- en: '| `bean-name` | This is the bean''s class name |'
  prefs: []
  type: TYPE_TB
- en: '| `fully-qualified-classname-of-the-remote-interface` | This is the fully qualified
    class name of the remote interface |'
  prefs: []
  type: TYPE_TB
- en: 'So the corresponding JNDI binding for your `TheatreInfo EJB`, packaged into
    a file named `ticket-agency-ejb.jar`, will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, stateful EJBs will contain one more attribute, `?stateful`,
    at the bottom of the JNDI string; this will result in the following JNDI naming
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, here''s the corresponding binding for the `TheatreBooker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you pay attention to the server logs, you will see that once your application
    is deployed, a set of JNDI bindings will be displayed on the server console. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Some of these bindings reflect the standard bindings as per Java EE specifications
    plus JBoss custom bindings (`java:/jboss`). This information, as it is, is not
    relevant for us but can be use to build our EJB client lookup string by replacing
    the Java EE (or JBoss-specific prefix) with `ejb:/`. For example, replace `java:/global`
    with `ejb:`, and you will save yourself the headache of referring to the EJB lookup
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are done with decoding the JNDI binding string, we will code our EJB
    client. We have already created a separate subproject for it (`ticket-agency-ejb-client`)
    at the beginning of this chapter, but we must still complete its configuration
    before we dive into coding.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the client's project object module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring the client dependencies (in `pom.xml`) will basically require all
    the libraries that connect and transport data to the server, along with the required
    EJB client dependencies. The first thing we will add, just as we did for the server
    project, is the BOM for the EJB client dependencies, which is demonstrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a set of dependencies that are needed to resolve the EJB
    interfaces (`ticket-agency-ejb artifact`), the JBoss'' transaction API (needed
    as EJBs are transaction-aware components), the `jboss-ejb-api` and `ejb-client`
    APIs, the `org.jboss.xnio` and `org.jboss.xnio` APIs (which provide a low-level
    input/output implementation), the `org.jboss.remoting3` API (the core transport
    protocol), which in turn requires `org.jboss.sasl` (to secure the transport),
    and finally, the `org.jboss.marshalling` API (to serialize the objects that are
    sent to and received from the server). This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Many of these dependencies use the runtime scope. This means that classes that
    are provided by them are not used directly by our code; they are not needed to
    be bundled within our application package, but they are required at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the EJB client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are done with the configuration. We will finally proceed with adding a new
    Java class `com.packtpub.wflydevelopment.chapter3.client.TicketAgencyClient`,
    which will communicate with the ticket booking machine''s EJB application. This
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Maven, the appropriate location for most of the resource files (like mentioned
    properties) is the `src/main/resources` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `jboss-ejb-client.properties` file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `remote.connectionprovider.create.options.org .xnio.Options.SSL_ENABLED`
    property, which enables the encryption of the XNIO connection; otherwise, plaintext
    will be used. (In [Chapter 10](part0054_split_000.html#page "Chapter 10. Securing
    WildFly Applications"), *Securing WildFly Applications*, we will discuss using
    SSL to secure the connection between the client and server.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remote.connections` property can be set to define a list of logical names
    that will be used for connection purposes by the `remote.connection.[name].host`
    and `remote.connection.[name].port` attributes. If you define more than one connection,
    as in the following example, the connections will be split across various destinations,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The default port used by the remoting framework is `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder how EJB remoting can work on the same port as the HTTP protocol.
    Starting from WildFly, remoting uses the HTTP protocol upgrade mechanism. The
    first connection is done on the `8080` port (via HTTP), then it is upgraded to
    EJB remoting, and switched to another port (chosen by WildFly).
  prefs: []
  type: TYPE_NORMAL
- en: Running the client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to run your client application, the last requirement will be to add
    the required Maven plugins, which are needed to run the remote EJB client. This
    is given in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the plugins are in place, you can compile and execute your project
    by issuing the following Maven goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command can be executed either from a shell (positioned in the
    project''s `root` folder) or from your Eclipse runtime configuration, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the client application](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If executed from the Eclipse environment, you should be able to see the following
    GUI screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the client application](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the moment, our application provides three functions: a book to book a seat,
    a list to list all the theatre seats, and money to retrieve the account balance.
    In the next sections, we will enrich our application by adding some more commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding user authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are running this example from a client that is located on the same machine
    as the application server, the remoting framework will silently allow communication
    between the client and your EJB's classes. On the other hand, for a client located
    on a remote system, you will be required to provide authentication for your requests.
    In order to add an application user, launch the `add-user.sh` (or `add-user.bat`)
    script, which is located at `JBOSS_HOME/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a transcript of a user creation example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The defined user will be added for you in the `application-user.properties`
    file located in your `configuration` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file contains the default security realm named `ApplicationRealm`. This
    security realm uses the following format to store passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the passwords you''ve just entered, the file will contain the following
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, insert the username and password information into `jboss-ejb-client.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, with all the previous information in the right place, you will be able
    to connect to your EJB application from a client that does not reside on the same
    machine as the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also force the normal authentication process on your local machine,
    by adding the following line to the `jboss-ejb-client` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using the EJB timer service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications that model business workflows often rely on timed notifications.
    The timer service of the enterprise bean container enables you to schedule timed
    notifications for all types of enterprise beans, except for stateful session beans.
    You can schedule a timed notification to occur according to a calendar schedule
    either at a specific time, after the duration of a time period, or at timed intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be two main types of EJB timers: programmatic timers and automatic
    timers. Programmatic timers are set by explicitly calling one of the timer creation
    methods of the `TimerService` interface. Automatic timers are created upon the
    successful deployment of an enterprise bean, which contains a method annotated
    with the `java.ejb.Schedule` or `java.ejb.Schedules` annotations. Let''s see both
    approaches in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic timer creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a timer, the bean invokes one of the `create` methods of the `TimerService`
    interface. These methods allow for either single-action, interval, or calendar-based
    timers to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to get a `TimerService` instance is to use resource injection.
    For example, in the `TheatreBox` singleton EJB, we will use the `@Resource` annotation
    to inject a `TimerService` object, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The duration specifies the time (in milliseconds) when the single timer is
    fired. The method that will fire the timer will use the `TimerService` instance
    to invoke `createSingleActionTimer`, passing the duration and an instance of the
    `TimerConfig` class as an argument, which may optionally contain some basic information
    (such as the description of the timer). This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a callback method named `timeout` and use the `@Timeout`
    annotation on top of the method. In the `timeout` method, we could, for example,
    reinitialize our singleton by invoking the `setupTheatre` method. Nothing fancy;
    however, this should give you an idea of how to get working with a single action
    timer. Refer to the following code for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling timer events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we should account for is the resource injection of the `Timer`
    object `[1]`, which will be used in the `cancelTimers` method `[4]` to cancel
    all the scheduling when the theatre is fully booked. Please note that the `timerService.getTimers()`
    method retrieves all active timers associated only with the current bean. In order
    to get all timers from your application module, you have to use the `timerService.getAllTimers()`
    method, which was added recently in EJB 3.2.
  prefs: []
  type: TYPE_NORMAL
- en: Next, pay attention to the `Schedule` annotation `[2]` we are using, which will
    fire a non-persistent timer each minute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Persistent timers (the default option) can survive application and server crashes.
    When the system recovers, any persistent timers will be recreated and missed callback
    events will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: When a replay of missed timer events is not desired, a non-persistent timer
    should be used, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: When an action is fired, the `automaticCustomer` method starts scanning the
    theatre seats for an available seat. (Nothing too complex; `findSeat` starts looking
    from the first available seat.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if there are seats still available, the `buyTicket` method `[3]` of
    the `TheatreBox` singleton will be used to short circuit the purchase of the seat
    (obviously, we won't need to check the money for our automatic customer).
  prefs: []
  type: TYPE_NORMAL
- en: Adding asynchronous methods to our EJBs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the EJB 3.1 specification, the only way to provide asynchronous capabilities
    to enterprise applications was using message-driven bean recipes. This remains
    substantially a best practice, and we are going to discuss this in depth in [Chapter
    6](part0035_split_000.html#page "Chapter 6. Developing Applications with JBoss
    JMS Provider"), *Developing Applications with JBoss JMS Provider*; however, in
    some cases, it might be desirable (and easier) to use these asynchronous features
    from a component that follows the classical request-reply pattern.
  prefs: []
  type: TYPE_NORMAL
- en: You can make the EJB's method asynchronous by simply tagging it with the `@Asynchronous`
    annotation. Each time this method is invoked, it will immediately return, regardless
    of how long the method actually takes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be used in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The first technique is a fire-and-forget manner, where the request is made up
    of the EJB and the client is not concerned about the success or failure of the
    request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second modus operandi invokes the method but does not wait for the method
    to be completed. The method returns a `Future` object. This object is used later
    to determine the result of the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fire-and-forget asynchronous calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t care about the async result, you can just have your `async` method
    return void. For this purpose, we will add a new method named `bookSeatAsync`
    to `TheatreBooker` and simply tag it as `@Asynchronous`. This is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this method does not return anything; it just executes our synchronous
    `bookSeet` method. We will need to use some other instruments to check whether
    the transaction was completed successfully. For example, we can check from the
    theatre list whether the seat has been booked successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a Future object to the client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other available option consists of returning a `java.util.concurrent.Future`
    object, which can later be inspected by our clients so that they know the outcome
    of our transaction. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, calls to the asynchronous `bookSeatAsync` method simply results,
    behind the scenes, in a `Runnable` or `Callable Java` object being created, which
    wraps the method and parameters you provide. This `Runnable` (or callable) object
    is given to an `Executor` object, which is simply a work queue attached to a thread
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: After adding the work to the queue, the proxy version of the method returns
    a Future implementation that is linked to `Runnable`, which is now waiting in
    the queue.
  prefs: []
  type: TYPE_NORMAL
- en: When `Runnable` finally executes the `bookSeatAsync` method, it takes the return
    value and sets it to `Future`, making it available to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with `Future` objects, the client code needs to be adapted. As
    a matter of fact, in standard synchronous calls, we used exceptions to intercept
    some events such as when the customer does not have enough money to complete the
    transaction. When using `Future` calls, there's a change in this paradigm. The
    call to the asynchronous method is detached from the client; however, we have
    the option to check if the `Future` work has been completed with the `isDone`
    method issued on the Future return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, let''s add a `bookasync` command to `TicketAgencyClient`,
    which will issue asynchronous booking and a mail command that will simulate the
    reading of the outcome by e-mail, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of our richer client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Returning a Future object to the client](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the EJB basics and changes in EJB 3.2 by following
    a simple lab example, which was enriched progressively. This example showed how
    the Maven project can be used from within the Eclipse environment to assist you
    in assembling the project with all the necessary dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have just coded a remote standalone client for our application.
    In the next chapter, we will see how to add a web frontend to our example using
    the context and dependency injections, to bridge the gap between the web tier
    and enterprise tier.
  prefs: []
  type: TYPE_NORMAL
