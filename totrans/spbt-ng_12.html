<html><head></head><body>
		<div id="_idContainer098">
			<h1 class="chapter-number" id="_idParaDest-214"><a id="_idTextAnchor224"/>12</h1>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor225"/>Managing States with NgRx</h1>
			<p>In the previous chapter, we learned about the concepts and features of Reactive forms. We implemented <strong class="source-inline">FormGroup</strong>, <strong class="source-inline">FormBuilder</strong>, and <strong class="source-inline">formControlName</strong> to bind input values in the form elements in the application. We also discussed how to group form control to bind nested properties and create form arrays in our <span class="No-Break">Reactive forms.</span></p>
			<p>After that, we learned how to implement validations for form controls to handle and verify user input. This will be beneficial for the user experience and help us avoid <span class="No-Break">unexpected errors.</span></p>
			<p>In this chapter, we will add a new recipe to our application and learn how to implement state management, specifically <strong class="bold">NgRx</strong>, for handling data in our <span class="No-Break">Angular application.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding complexities in managing the states of <span class="No-Break">large applications</span></li>
				<li>State management and the <span class="No-Break">global state</span></li>
				<li>Getting started and setting <span class="No-Break">up NgRx</span></li>
				<li>Writing <span class="No-Break">an action</span></li>
				<li>Writing <span class="No-Break">an effect</span></li>
				<li>Writing <span class="No-Break">a reducer</span></li>
				<li>Writing a selector and using a selector and dispatching it in <span class="No-Break">a component</span></li>
				<li>Configuring <span class="No-Break">the store</span></li>
			</ul>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor226"/>Technical requirements</h1>
			<p>The following link will take you to the finished version of code for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor227"/>Understanding complexities in managing the states of large applications</h1>
			<p>Data management in frontend applications is very important, just like how essential data management is <a id="_idIndexMarker940"/>in backend applications and databases. As we add more features to our application, we know that the number of components, modules, and services working inside our Angular project is <span class="No-Break">also growing.</span></p>
			<p>This also means that the data flow in the application is growing and becoming complex. A complex data flow can lead to an unmaintainable application, inconsistent and scattered states in different components, and nested input and output bindings that result in complex code structures. Due to these possible issues when it comes to managing data in Angular, a solution <a id="_idIndexMarker941"/>called <strong class="bold">state management</strong> was introduced as a standard solution for maintaining data in <span class="No-Break">frontend applications.</span></p>
			<p>State management is an extension or library that is mainly used for managing and handling data in frontend applications. It introduces a pattern where all data being used is stored in <a id="_idIndexMarker942"/>one big object that acts as the state of the whole application. This concept is also known as a <strong class="bold">single source of truth</strong>. In this case, no matter how many components or how many services are added to our application, there is always a single object where we can retrieve the data we need. You can compare this state to an acting database for the <span class="No-Break">frontend application.</span></p>
			<p>Before proceeding with state management, let’s compare the flow of data without and with <span class="No-Break">state management.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor228"/>The flow of data without state management</h2>
			<p>Data flow <a id="_idIndexMarker943"/>in Angular starts on the services. We call endpoints in the services to retrieve and manage the data that we need for our application. As the number of features increases, the number of services added and called increases, resulting in a more complex data flow. Let’s look at a graphical illustration of the flow of data without <span class="No-Break">state management:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 12.1 – The flow of data without state management" src="image/B18159_12_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The flow of data without state management</p>
			<p>In the preceding graphical illustration, we can see that we have four different services that are responsible for managing different kinds of data; each feature retrieves the data it needs from <span class="No-Break">these services.</span></p>
			<p>As we <a id="_idIndexMarker944"/>can see, the retrieval that occurs is scattered as the features are retrieving the data on different sources or services. This results in multiple data flows, and they can get larger as more services and features <span class="No-Break">are required.</span></p>
			<p>This can also lead to inconsistencies in data being held by each component as the source is coming from different services, leading to some unexpected bugs in the application. Now, let’s look at the flow of data with <span class="No-Break">state management.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor229"/>The flow of data with state management</h2>
			<p>In the <a id="_idIndexMarker945"/>previous data flow, we saw that the flow of data is not optimized, which can result in several problems in our application as the data flow’s direction is very complex. When implementing state management in our Angular application, we will have the following <span class="No-Break">data flow:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer095">
					<img alt="Figure 12.2 – The flow of data with state management" src="image/B18159_12_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – The flow of data with state management</p>
			<p>In the <a id="_idIndexMarker946"/>preceding graphical illustration, we can see that all of the services of our application are handled by state management. We are still using services to retrieve data in our database. The significant difference here is that our features are now accessing all the retrieved data in the state instead of directly accessing it in <span class="No-Break">the services.</span></p>
			<p>This allows the data to flow in one direction and has a single origin for all the data being used in the application. With this approach, inconsistency in the states, possible bugs, and multiple API calls can <span class="No-Break">be avoided.</span></p>
			<p>With that, we have learned about the importance of state management in developing applications, especially <span class="No-Break">enterprise-level apps.</span></p>
			<p>Now, let’s discuss more state management concepts and <span class="No-Break">global states.</span></p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor230"/>State management and the global state</h1>
			<p>State management, as <a id="_idIndexMarker947"/>discussed in the previous section, is an extension or library that allows us to manage the flow of our data in the application in just <span class="No-Break">one direction.</span></p>
			<p>This is possible due to global states, which will contain all of the data. To understand how state management works, let’s discuss each of the building blocks of <span class="No-Break">state management.</span></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor231"/>Global state/store</h2>
			<p>The <strong class="bold">global state</strong>, also <a id="_idIndexMarker948"/>known as the <strong class="bold">store</strong>, is the most crucial element in state management. The primary responsibility of a global state is to store all the data <a id="_idIndexMarker949"/>retrieved by the API or simply data being used in <span class="No-Break">the application.</span></p>
			<p>This means <a id="_idIndexMarker950"/>that all components in an Angular application will retrieve the data in the global state. Think of it as a database of the Angular application but in the form of a JSON object where we can get each property <span class="No-Break">as slices.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor232"/>Actions</h2>
			<p><strong class="bold">Actions</strong> express unique <a id="_idIndexMarker951"/>events in your application. They are <a id="_idIndexMarker952"/>directly called in our components using the <strong class="source-inline">dispatch()</strong> function, which helps identify what events should be performed, such as modifying the state or calling APIs to <span class="No-Break">retrieve data.</span></p>
			<p>Actions are just simple interfaces; the <strong class="source-inline">type</strong> property identifies what action is dispatched. This simple string is just a definition of the action, and we can add properties to the actions for the data we require in the API <span class="No-Break">or state.</span></p>
			<p>Let’s have a look at an example of an <span class="No-Break">action interface:</span></p>
			<pre class="source-code">
{
type: '[Blog] Add Blog',
title: string;
author: string;
content: string;
}</pre>
			<p>The preceding <a id="_idIndexMarker953"/>example action is dispatched when a new blog <a id="_idIndexMarker954"/>is created. This is called when the <strong class="bold">Submit</strong> button is clicked, and information such as <strong class="source-inline">title</strong>, <strong class="source-inline">author</strong>, and <strong class="source-inline">content</strong> is added as additional metadata to be passed on to the effect <span class="No-Break">or reducer.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor233"/>Reducers</h2>
			<p><strong class="bold">Reducers</strong> are the <a id="_idIndexMarker955"/>decision-makers of state management. They <a id="_idIndexMarker956"/>are the ones that decide which actions to handle based on the action type. Reducers are also the ones that can change the value of <span class="No-Break">the state.</span></p>
			<p>Reducers are pure functions and handle state transitions synchronously; let’s have a look at an example of <span class="No-Break">a reducer:</span></p>
			<pre class="source-code">
export const blogReducer = createReducer( initialState,
  on(BlogActions.addBlog, (state, {blog})=&gt; ({ ...state,
    blogs: […state.blogs, blog]}))
);</pre>
			<p>In the preceding example, we have created a reducer for the <strong class="source-inline">addBlog()</strong> action. This allows us to add a new blog object in the blog’s state once we have dispatched the <span class="No-Break"><strong class="source-inline">addBlog()</strong></span><span class="No-Break"> action.</span></p>
			<p>We will discuss reducers in more detail later in the <em class="italic">Writing a reducer</em> section of <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor234"/>Selectors</h2>
			<p><strong class="bold">Selectors</strong> are pure <a id="_idIndexMarker957"/>functions that allow us to retrieve slices <a id="_idIndexMarker958"/>of data in our store. It is a change detection mechanism where, when the value of the state changes, it compares the parts of the state and only sends the state if the changes are detected. This <a id="_idIndexMarker959"/>is a practice <span class="No-Break">called </span><span class="No-Break"><strong class="bold">memorization</strong></span><span class="No-Break">.</span></p>
			<p>Selectors are used in components to get the data used in the UI. It is returned as an Observable that listens to the <span class="No-Break">state changes.</span></p>
			<p>Let’s look at an example of <span class="No-Break">a selector:</span></p>
			<pre class="source-code">
// selector for list of blogs
// blog.selector.ts
export const selectBlogList = (state: AppState) =&gt; state.blogs;
// blog component
// blog.component.ts
blogs$ = this.store.select&lt;Array&lt;Blog&gt;(selectBlogList);
   this.blogs$.subscribe(data =&gt; {
      console.log(data) // list of blogs from the state;
    });</pre>
			<p>In the <a id="_idIndexMarker960"/>preceding example, we have created a selector for <a id="_idIndexMarker961"/>the blog slice, as well as a function that returns the <em class="italic">blogs</em> metadata, called <strong class="source-inline">selectBlogList()</strong>. We used this function in our <strong class="source-inline">blog</strong> component as a parameter for the <strong class="source-inline">select</strong> function to retrieve the data by subscribing to the selector. The subscription will emit once the value of the blog’s slice changes. We will discuss selectors in more detail in the next section of <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor235"/>Effects</h2>
			<p>Effects are <a id="_idIndexMarker962"/>specific elements that the <strong class="source-inline">NgRx</strong> library uses; this <a id="_idIndexMarker963"/>is an <em class="italic">RxJs-powered</em> side effect model that handles external interactions such as API calls, web socket messages, and time-based events. Using effects, we can isolate our components from interacting with external sources and reduce their responsibilities. Let’s look at a comparison between an application with and without <span class="No-Break">side effects.</span></p>
			<h3>Application without side effects</h3>
			<p>The <a id="_idIndexMarker964"/>following is an application without <span class="No-Break">side effects:</span></p>
			<pre class="source-code">
export class BlogPageComponent {
  movies: Blog[];
  constructor(private blogService: MoviService) {}
  ngOnInit() {
    this.blogService
        .getAll()
        .subscribe(blogs =&gt; this.blogs = blogs);
  }
}</pre>
			<p>In <a id="_idIndexMarker965"/>the preceding code example, we have a component that has several responsibilities, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Managing the state of the blogs (the component has its <span class="No-Break">blog state)</span></li>
				<li>Using the blog service to call an external API to get the list <span class="No-Break">of blogs</span></li>
				<li>Modifying the state of the blog inside <span class="No-Break">the component</span></li>
			</ul>
			<p>This means that every component with a service dependency also has its state of data. Now, let’s look at an example of an application with <span class="No-Break">side effects.</span></p>
			<h3>Application with side effects</h3>
			<p>The <a id="_idIndexMarker966"/>following is an application with <span class="No-Break">side effects:</span></p>
			<pre class="source-code">
export class BlogsPageComponent {
  blogs$: Observable&lt;Blog[]&gt; = this.store.select(state =&gt;
    state.blog);
  constructor(private store: Store&lt;{ blogs: Blog[] }&gt;) {}
  ngOnInit() {
    this.store.dispatch({ type: '[Blog Page] Load Blog'});
  }
}</pre>
			<p>In the preceding code example, we can see that the code for our blog page component has been reduced, and, at the same time, its responsibility is also less complex. Now, the component’s responsibility is to dispatch an action that will allow effects to identify what <a id="_idIndexMarker967"/>service needs to be called to retrieve <span class="No-Break">the data.</span></p>
			<p>Let’s look at an example effect for the <span class="No-Break">blog state:</span></p>
			<pre class="source-code">
@Injectable()
export class BlogEffects {
  loadBlogs$ = createEffect(() =&gt; this.actions$.pipe(
ofType('[Blog Page] Load Blog'),
  mergeMap(() =&gt; this.blogService
     .getAll().pipe(
       map(blogs =&gt; ({ type: '[Blogs API] Blogs Loaded
                      Success', payload: blogs })),
       catchError(() =&gt; EMPTY)
     ))
   )
);
  constructor(private actions$: Actions,
              private blogService: BlogService) {}
}</pre>
			<p>In the preceding code example, we created a new effect named <strong class="source-inline">loadBlogs$</strong>. This effect is responsible for calling the <strong class="source-inline">getAll()</strong> method from the blog service to retrieve the list of blogs from the external endpoint. At the same time, it is also responsible for dispatching a new action that passes the retrieved blog list into the reducer to modify the store. We will discuss how to write effects in the next section of <span class="No-Break">this chapter.</span></p>
			<p>With that, we’ve seen all of the building blocks that make up state management. Let’s look <a id="_idIndexMarker968"/>at a detailed graphical illustration of how data flows in <span class="No-Break">state management:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer096">
					<img alt="Figure 12.3 – How data flows when using NgRx state management" src="image/B18159_12_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – How data flows when using NgRx state management</p>
			<p>In the preceding graphical illustration, we can see that our UI components have only one responsibility, and this is to dispatch actions. If the action needs to call an API, an effect will be called to invoke an API using a service, and after getting the response data, the effect will also dispatch an action to call a reducer to modify <span class="No-Break">the store.</span></p>
			<p>On the other hand, if the action that’s sent from the component will alter the state, it will not need any side effects and call the reducer that matches the type of the action. All of <a id="_idIndexMarker969"/>the changes in the store will be detected by the selectors and emit the latest state to be used in the <span class="No-Break">UI components.</span></p>
			<p>With that, we have learned about the necessary concepts surrounding state management and how data flows together with the building blocks of state management. In the next section, we will learn how to set up and configure one of the most famous state management libraries in <span class="No-Break">Angular: </span><span class="No-Break"><strong class="bold">NgRx</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor236"/>Getting started and setting up NgRx</h1>
			<p>To use NgRx <a id="_idIndexMarker970"/>state management, we must install the <strong class="source-inline">@ngrx/store</strong> library; this will contain all of the functions that will allow us to configure the store and create reducers <span class="No-Break">and actions.</span></p>
			<p>To install the <strong class="source-inline">@ngrx/store</strong> library, we must execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng add @ngrx/store</pre>
			<p>The preceding command will perform the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Update <strong class="source-inline">package.json</strong> by adding <strong class="source-inline">@ngrx/store</strong> to <span class="No-Break">the dependencies.</span></li>
				<li>Run <strong class="source-inline">npm install</strong> to install <span class="No-Break">the dependencies.</span></li>
				<li>Update <strong class="source-inline">src/app/app.module.ts</strong> by adding <strong class="source-inline">StoreModule.forRoot(reducers, {})</strong> to the <span class="No-Break"><strong class="source-inline">imports</strong></span><span class="No-Break"> array.</span></li>
			</ol>
			<p>Before executing this command, make sure that the version of <strong class="source-inline">@ngrx/store</strong> is aligned with the version of your Angular; in our project, our Angular version is version <strong class="source-inline">13.3.0</strong>, which means that we need to use version 13 <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">@ngrx/store</strong></span><span class="No-Break">.</span></p>
			<p>Flags are also available that allow us to install <strong class="source-inline">@ngrx/store</strong> with customizations. The following is the list of flags we <span class="No-Break">can use:</span></p>
			<ul>
				<li><strong class="source-inline">--path</strong>: Specifies the path to the module where you want to <span class="No-Break">import </span><span class="No-Break"><strong class="source-inline">StoreModule</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--project</strong>: The name of the project that is defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">angular.json</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--module</strong>: The name of the file containing the module where you want to <span class="No-Break">import </span><span class="No-Break"><strong class="source-inline">StoreModule</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--minimal</strong>: This provides <a id="_idIndexMarker971"/>the minimal setup for the root state management if set to <strong class="source-inline">true</strong>. It imports <strong class="source-inline">StoreModule.forRoot()</strong> in the module with an <span class="No-Break">empty object.</span></li>
				<li><strong class="source-inline">--statePath</strong>: This is the path where the state will <span class="No-Break">be created.</span></li>
				<li><strong class="source-inline">--stateInterface</strong>: The interface that defines <span class="No-Break">the state.</span></li>
			</ul>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor237"/>Adding NgRx to our Angular project</h2>
			<p>Now, let’s <a id="_idIndexMarker972"/>add this to our Angular project. We only want <a id="_idIndexMarker973"/>to use the minimal setup as we will add the reducers and store step by step. After successfully executing the <strong class="source-inline">ng add @ngrx/store</strong> command, we will have the following changes in <span class="No-Break">our project:</span></p>
			<pre class="source-code">
// app.module.ts
 imports: [
    … other modules
    StoreModule.forRoot({}, {}),
  ],
// package.json
"dependencies": {
     … other dependencies
    "@ngrx/store": "^13.2.0",
  },</pre>
			<p>In the preceding code example, we can see that <strong class="source-inline">StoreModule.forRoot()</strong> has been added without any objects; this means that we initially imported the store <span class="No-Break">without reducers.</span></p>
			<p>With that, we have successfully installed <strong class="source-inline">@ngrx/store</strong> in our Angular project. Now, we will install another extension to help us debug <span class="No-Break">the state.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor238"/>Installing NgRx DevTools</h2>
			<p>NgRx DevTools is a valuable extension that provides developer tools and instrumentation for the store. It allows us to check the values of the state, implement time travel <a id="_idIndexMarker974"/>debugging, and have a visual representation of the previous and current values of the data in <span class="No-Break">our store.</span></p>
			<p>We must execute the following command to install NgRx DevTools in our <span class="No-Break">Angular project:</span></p>
			<pre class="console">
ng add @ngrx/store-devtools</pre>
			<p>After successfully executing this command, the following changes will be implemented in <span class="No-Break">our project:</span></p>
			<pre class="source-code">
// app.module.ts
imports: [
… other modules
// Instrumentation must be imported after importing
// StoreModule (config is optional)
StoreDevtoolsModule.instrument({
  maxAge: 25, // Retains last 25 states
  logOnly: environment.production, // Restrict extension to
                                   // log-only mode
  autoPause: true, // Pauses recording actions and state
                   // changes when the extension window is
                   //not open
}),
],</pre>
			<p>In the preceding code example, we can see that a new module called <strong class="source-inline">StoreDevtoolsModule</strong> has been added; this will allow DevTools to be used once we run our <span class="No-Break">application locally.</span></p>
			<p>The next <a id="_idIndexMarker975"/>step to using DevTools is to add the Redux <a id="_idIndexMarker976"/>extension to our browser. To add this extension, go to one of the following links for your <span class="No-Break">respective browser:</span></p>
			<ul>
				<li><strong class="bold">Google </strong><span class="No-Break"><strong class="bold">Chrome</strong></span><span class="No-Break">: </span><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd"><span class="No-Break">https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd</span></a></li>
				<li><strong class="bold">Mozilla </strong><span class="No-Break"><strong class="bold">Firefox</strong></span><span class="No-Break">: </span><a href="https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/"><span class="No-Break">https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/</span></a></li>
			</ul>
			<p>After <a id="_idIndexMarker977"/>adding this extension to your preferred browser, running your Angular project with the imported <strong class="source-inline">StoreDevToolModule</strong> module will be automatically detected by this extension. It will provide an interface for viewing <span class="No-Break">the state:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer097">
					<img alt="Figure 12.4 – Interface of the Redux DevTools extension" src="image/B18159_12_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Interface of the Redux DevTools extension</p>
			<p>The preceding screenshot shows that our Redux DevTools extension has been activated; once we open our Angular project in our browser tab, we will see more Redux DevTools in action as we write <span class="No-Break">our code.</span></p>
			<p>Now that <a id="_idIndexMarker978"/>we have configured our store and installed NgRx DevTools in our application, we are ready to write the building blocks for our <span class="No-Break">state management.</span></p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor239"/>Writing an action</h1>
			<p>The first <a id="_idIndexMarker979"/>building block of state management is that we will write our actions. When writing actions, we have several rules we can follow so that we have good actions <a id="_idIndexMarker980"/>in <span class="No-Break">our application:</span></p>
			<ul>
				<li><strong class="bold">Upfront</strong>: Writing actions should always come first before developing the features. This gives us an overview of what should be implemented in <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Divide</strong>: We should always categorize the actions based on the event source and the <span class="No-Break">associated data.</span></li>
				<li><strong class="bold">Many</strong>: Writing more number actions is not an issue. It is more beneficial as more actions create a better overview of the flow of <span class="No-Break">your application.</span></li>
				<li><strong class="bold">Event-Driven</strong>: Capture <em class="italic">events</em> as you separate the description of an event and how <span class="No-Break">it’s handled.</span></li>
				<li><strong class="bold">Descriptive</strong>: Always provide meaningful information using type metadata. This helps debug <span class="No-Break">the state.</span></li>
			</ul>
			<p>Let’s look at an example action that will set the list of blogs in <span class="No-Break">our state:</span></p>
			<pre class="source-code">
import { createAction, props } from '@ngrx/store';
export const setBlogList = createAction(
 '[Blog] Set Blog List',
  props&lt;{ blogs: ReadonlyArray&lt;Blog&gt; }&gt;(),
);</pre>
			<p>In the preceding code example, we used the <strong class="source-inline">createAction()</strong> function to create our action. The <strong class="source-inline">createAction()</strong> function also returns a function that returns an object of the action interface; in this case, it will return <strong class="source-inline">"[Blog] Set blog list"</strong> as the action type and the array of blogs as the <span class="No-Break">additional properties.</span></p>
			<p>To dispatch <a id="_idIndexMarker981"/>the action, we will use the <strong class="source-inline">dispatch()</strong> function and use <strong class="source-inline">setBlogList</strong> as <span class="No-Break">a parameter:</span></p>
			<pre class="source-code">
ngOnInit() {
     store.dispatch(setBlogList ({ blogs: this.blogs}));
}</pre>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor240"/>Implementing actions in the project</h2>
			<p>Our primary <a id="_idIndexMarker982"/>goal for our project is to create the entire cycle to get the list of anti-heroes in our API and place it in our store. The first step is to take the actions we need; let’s look at the two actions that we should make for <span class="No-Break">this feature:</span></p>
			<ul>
				<li><strong class="source-inline">getAntiHeroList</strong>: This <a id="_idIndexMarker983"/>action will retrieve the list of blogs from the external API provided by our <span class="No-Break">Spring project.</span></li>
				<li><strong class="source-inline">setAntiHeroList</strong>: This <a id="_idIndexMarker984"/>action will place the retrieved list of blogs in <span class="No-Break">our store.</span></li>
			</ul>
			<p>Now that we have identified the list of actions we will create, in the <strong class="source-inline">anti-heroes</strong> folder, we will create a <strong class="source-inline">state/anti-hero.actions.ts</strong> file where we will place all of <span class="No-Break">our actions.</span></p>
			<p>Let’s place the following code in the <span class="No-Break"><strong class="source-inline">anti-hero.actions.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import { createAction, props } from '@ngrx/store';
import { AntiHero } from '../models/anti-hero.interface';
export enum AntiHeroActions {
  GET_ANTI_HERO_LIST = '[Anti-Hero] Get Anti-Hero list',
  SET_ANTI_HERO_LIST = '[Anti-Hero] Set Anti-Hero list',
}
export const getAntiHeroList = createAction(
    AntiHeroActions.GET_ANTI_HERO_LIST,
);
export const setAntiHeroList = createAction(
  AntiHeroActions.SET_ANTI_HERO_LIST,
  props&lt;{ antiHeroes: ReadonlyArray&lt;AntiHero&gt; }&gt;(),
);</pre>
			<p>In the preceding code example, we have created two actions for getting and setting the anti-hero list. The first action, <strong class="source-inline">getAntiHeroList</strong>, has a single parameter, which is the type. This does not need any additional properties as this will only call the API to retrieve the list of anti-heroes through the use <span class="No-Break">of effects.</span></p>
			<p>On the <a id="_idIndexMarker985"/>other hand, the second action, <strong class="source-inline">setAntiHeroList</strong>, has two parameters: the type and an additional property called <strong class="source-inline">antiHero</strong>. This will <a id="_idIndexMarker986"/>set the value of the store with the retrieved list of anti-heroes through the use <span class="No-Break">of reducers.</span></p>
			<p>It is also excellent practice to make our action definitions enums in our code as this will help us avoid typographical errors when using the definition in other parts of <span class="No-Break">the application.</span></p>
			<p>With that, we have successfully created the required action for our anti-heroes list feature. Now, we will discuss how to write effects that will be used to call the API and retrieve the <span class="No-Break">anti-hero list.</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor241"/>Writing an effect</h1>
			<p>We successfully <a id="_idIndexMarker987"/>created our actions in the previous section. Now, we will make the effects that will be responsible for calling our <span class="No-Break">external API.</span></p>
			<p>Effects are not included in the <strong class="source-inline">@ngrx/store</strong> library; we will install a separate library that will allow us to use the functions <span class="No-Break">for effects.</span></p>
			<p>To install effects in our application, we must execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng add @ngrx/effects</pre>
			<p>The preceding command will perform the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Update the <strong class="source-inline">package.json</strong> file with the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">ngrx/effects</strong></span><span class="No-Break"> dependency.</span></li>
				<li>Run <strong class="source-inline">npm install</strong> to install the <span class="No-Break">added dependency.</span></li>
				<li>Add <strong class="source-inline">EffectsModule.forRoot()</strong> to the imports array of your <span class="No-Break"><strong class="source-inline">app.module.ts</strong></span><span class="No-Break"> file.</span></li>
			</ol>
			<p>Some flags <a id="_idIndexMarker988"/>are available that allow us to install <strong class="source-inline">@ngrx/effects</strong> with customizations; the following is the list of flags we <span class="No-Break">can use:</span></p>
			<ul>
				<li><strong class="source-inline">--path</strong>: Specifies the path to the module where you want to <span class="No-Break">import </span><span class="No-Break"><strong class="source-inline">EffectsModule</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--project</strong>: The name of the project defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">angular.json</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--skipTests</strong>: This creates a test file when it is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--module</strong>: The name of the file containing the module where you want to <span class="No-Break">import </span><span class="No-Break"><strong class="source-inline">EffectsModule</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--minimal</strong>: This provides the minimal setup for the root effects if set to <strong class="source-inline">true</strong>. It imports <strong class="source-inline">EffectsModule.forRoot()</strong> in the module with an <span class="No-Break">empty object.</span></li>
				<li><strong class="source-inline">--group</strong>: Group the <strong class="source-inline">effects</strong> files within the <span class="No-Break"><strong class="source-inline">effects</strong></span><span class="No-Break"> folder.</span></li>
			</ul>
			<p>After successfully adding the dependency of the effect to our application, we can create our effects. Under the <strong class="source-inline">anti-heroes/state</strong> folder, we must create a new file named <strong class="source-inline">anti-hero.effects.ts</strong>. The first thing we need to do is create a class that has an <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Injectable</strong></span><span class="No-Break"> annotation:</span></p>
			<pre class="source-code">
@Injectable()
export class AntiHeroEffects {
  constructor(
    private actions$: Actions,
    private antiHeroService: AntiHeroService,
    private router: Router
  ) {}
}</pre>
			<p>In the preceding code example, we can see that effects are also service classes and can be injected by other services; we have injected the following services <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">AntiHeroEffects</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">Actions</strong>: A service from <strong class="source-inline">@ngrx/effects</strong> that returns an observable that we can assign a type to. This will act as the identifier when an action <span class="No-Break">is dispatched.</span></li>
				<li><strong class="source-inline">AntiHeroService</strong>: Our created service that contains the external APIs for our anti-heroes, found <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">anti-hero/services/anti-hero.service.ts</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">Router</strong>: Used for redirection once an API call <span class="No-Break">is made.</span></li>
			</ul>
			<p>After creating our <strong class="source-inline">AntiHeroEffect</strong> class and injecting our services, we can begin making <a id="_idIndexMarker989"/>our effects. The first thing we need to think of is what kind of effect we need to get the anti-heroes since we have the <strong class="source-inline">GET_ANTI_HERO LIST</strong> and <span class="No-Break"><strong class="source-inline">SET_ANTI_HERO_LIST</strong></span><span class="No-Break"> actions.</span></p>
			<p>We should create an effect that has a type of <strong class="source-inline">GET_ANTI_HERO_LIST</strong> and can call the <strong class="source-inline">getAntiHeroes()</strong> function <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">AntiHeroService</strong></span><span class="No-Break">.</span></p>
			<p>To create this API, we can write the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { Actions, createEffect, ofType } from '@ngrx/effects';
getAntiHeroes$ = createEffect(() =&gt; {
    return this.actions$.pipe(
        ofType(AntiHeroActions.GET_ANTI_HERO_LIST),
        mergeMap(() =&gt; this.antiHeroService.getAntiHeroes()
        )
    }, {dispatch: true}
  );</pre>
			<p>In the preceding code example, we used the <strong class="source-inline">createEffect()</strong> function to create our effects; this returns <a id="_idIndexMarker990"/>an action that has <span class="No-Break">two parameters:</span></p>
			<ul>
				<li><strong class="source-inline">ofType(AntiHeroActions.GET_ANTI_HERO_LIST)</strong>: The first parameter uses the <strong class="source-inline">ofType</strong> operator, which defines the action type of the effect. This means that if the <strong class="source-inline">GET_ANTI_HERO_LIST</strong> action is dispatched, this effect will <span class="No-Break">be called.</span></li>
				<li><strong class="source-inline">mergeMap(() =&gt; this.antiHeroService.getAntiHeroes()</strong>: The second parameter uses the <strong class="source-inline">mergeMap</strong> operator, which will allow us to invoke the <strong class="source-inline">getAntiHeroes()</strong> function to call <span class="No-Break">the endpoint.</span></li>
			</ul>
			<p>With that, we have our effect for the <strong class="source-inline">GET_ANTI_HERO_LIST</strong> actions, but this is not complete yet. After getting the list of anti-heroes, we want to dispatch another action that sets <a id="_idIndexMarker991"/>the anti-heroes list in our state. To implement this, we can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
  mergeMap(() =&gt; this.antiHeroService.getAntiHeroes()
          .pipe(
            map(antiHeroes =&gt; ({ type: AntiHeroActions.SET_ANTI_HERO_LIST, antiHeroes })),
            catchError(() =&gt; EMPTY)
          ));</pre>
			<p>In the preceding code, we have added a pipe to our <strong class="source-inline">mergeMap</strong> operator; this calls a <strong class="source-inline">map</strong> operator that returns <strong class="source-inline">({ type: AntiHeroActions.SET_ANTI_HERO_LIST, antiHeroes }))</strong>. This will dispatch another action that has a type of <strong class="source-inline">SET_ANTI_HERO_LIST</strong> and has additional <strong class="source-inline">antiHeroes</strong> objects coming from the list of anti-heroes retrieved from <span class="No-Break">the API.</span></p>
			<p>Our effects for getting the list of anti-heroes feature is complete. The last step is to add <strong class="source-inline">AntiHeroEffects</strong> to our <strong class="source-inline">effects</strong> module. As we may recall, our <strong class="source-inline">anti-heroes</strong> module is lazy loaded, which means that we will not add <strong class="source-inline">AntiHeroEffects</strong> to <strong class="source-inline">EffectsModule.forRoot([])</strong> located in the <strong class="source-inline">app.module.ts</strong> file; otherwise, we would need to add <strong class="source-inline">EffectsModule.forFeature([AntiHeroEffects])</strong> in the imports of the <strong class="source-inline">anti-hero.module.ts</strong> file. This means that this <strong class="source-inline">effects</strong> class is only used under <span class="No-Break">this module.</span></p>
			<p>With that, we have <a id="_idIndexMarker992"/>successfully configured and created our effects for the anti-hero list feature. In the next section, we will write the reducers that will modify <span class="No-Break">our state.</span></p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor242"/>Writing a reducer</h1>
			<p>NgRx states <a id="_idIndexMarker993"/>are immutable objects; we cannot modify their values through direct assignment, and the only way we can change their states is <span class="No-Break">through reducers.</span></p>
			<p>Reducers have different parts that we should implement, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The interface or type that defines the properties of <span class="No-Break">the state</span></li>
				<li>The arguments, which consist of the initial state and the <span class="No-Break">current action</span></li>
				<li>The list of functions that handle that state changes based on the <span class="No-Break">dispatched actions</span></li>
			</ul>
			<p>We will create these reducer parts under the <span class="No-Break"><strong class="source-inline">anti-heroes/state/anti-hero.reducers.ts</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor243"/>The state interface</h2>
			<p>The state interface <a id="_idIndexMarker994"/>defines the shape of the state; this contains the <a id="_idIndexMarker995"/>properties or the slices of the state. In our application, we need a property that will hold the list <span class="No-Break">of anti-heroes.</span></p>
			<p>To implement the interface, we can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export interface AntiHeroState {
    antiHeroes: ReadonlyArray&lt;AntiHero&gt;;
}</pre>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor244"/>The initial state</h2>
			<p>The next <a id="_idIndexMarker996"/>part we need to implement is the initial state; this defines what the initial <a id="_idIndexMarker997"/>values of the state slices are. In our anti-hero state, we will set the <strong class="source-inline">antiHeroes</strong> slice to an <span class="No-Break">empty array.</span></p>
			<p>To implement this, we can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export const initialState: AntiHeroState = {
    antiHeroes: []
}</pre>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor245"/>The reducer function</h2>
			<p>After creating our initial state, we can implement our reducer function; this will hold the list of <a id="_idIndexMarker998"/>functions that will be called, depending on the type of action that <span class="No-Break">is dispatched.</span></p>
			<p>To implement the reducer function, we can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export const antiHeroReducer = createReducer(
  initialState,
  on(setAntiHeroList, (state, { antiHeroes }) =&gt; { return {...state, antiHeroes}}),
  );</pre>
			<p>In the preceding code example, we can see that we have used a <strong class="source-inline">createReducer()</strong> function from the <strong class="source-inline">@ngrx/store</strong> library; this will contain all the functions that will modify our anti-hero state. The first parameter is our initial state, while the second parameter is a function that will be called when an action of <strong class="source-inline">SET_ANTI_HERO_LIST</strong> <span class="No-Break">is dispatched.</span></p>
			<p>This means that the effect we created earlier will call this once the API has retrieved the anti-hero list successfully; this function contains two parameters – one that holds the current state and another that holds the list of anti-heroes objects from the API. To modify the <strong class="source-inline">antiHeroes</strong> state with the retrieved list, we have returned <strong class="source-inline">{…</strong><span class="No-Break"><strong class="source-inline">state, antiHeroes}</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have finished writing the reducers for our state, the last step is to register our reducers in the store. We will apply the same rules that we applied for the effects; since our anti-heroes module is lazy loaded, we will register our anti-hero reducer in our <strong class="source-inline">anti-hero.module.ts</strong> file by adding <strong class="source-inline">StoreModule.forFeature('antiHeroState,' antiHeroReducer)</strong>. The first parameter is the key for our anti-hero state, while the second is the function returned from the <span class="No-Break"><strong class="source-inline">createReducer()</strong></span><span class="No-Break"> function.</span></p>
			<p>With that, we have <a id="_idIndexMarker999"/>successfully created and registered our reducer for the anti-hero list feature. Now, let’s discuss the NgRx selectors to get the state and how to dispatch actions <span class="No-Break">in components.</span></p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor246"/>Writing a selector and using a selector and dispatching it in a component</h1>
			<p>In the previous section, we successfully implemented reducers that can mutate the values of <a id="_idIndexMarker1000"/>our state. This means that our state contains valuable data that <a id="_idIndexMarker1001"/>we can get from the Angular components; we can use selectors <a id="_idIndexMarker1002"/>to <span class="No-Break">do this.</span></p>
			<p>Selectors are pure functions that allow us to retrieve slices of state; we can use several helper functions, such as <strong class="source-inline">createSelector()</strong> and <strong class="source-inline">createFeatureSelector()</strong>, to create our selectors for <span class="No-Break">the store.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor247"/>Selecting root states</h2>
			<p>While selecting the root states, we will be using a pure function to create our selector. Let’s look <a id="_idIndexMarker1003"/>at an example of a selector selecting the list of <a id="_idIndexMarker1004"/>blogs under the root <span class="No-Break">state (</span><span class="No-Break"><strong class="source-inline">AppState</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
// blogs.selectors.ts
export const selectBlogs = (state: AppState) =&gt; state.blogs</pre>
			<p>In the preceding code example, we have only created a function that returns the <strong class="source-inline">blogs</strong> slice; this is feasible when we select slices under the project’s root state. To use the created selector in our component, we can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
//blogs.page.ts
blogs$ = this.store.select(selectBlogs())
constructor(private store: Store&lt;AppState&gt;,){
   this.blogs$.subscribe((data) =&gt; {
      this.blogs = data;
    });
}</pre>
			<p>In the <a id="_idIndexMarker1005"/>preceding code example, we injected <strong class="source-inline">Store</strong> from the <strong class="source-inline">@ngrx/store</strong> library. <strong class="source-inline">Store</strong> provides a <strong class="source-inline">select</strong> function that accepts selectors <a id="_idIndexMarker1006"/>as a parameter and returns an observable that returns the slice of state that is defined by <span class="No-Break">the selector.</span></p>
			<p>In this case, we have subscribed to the <strong class="source-inline">blogs$</strong> observable from the <strong class="source-inline">select(selectBlogs()</strong> function to retrieve the <strong class="source-inline">blogs</strong> slice that holds the list <span class="No-Break">of blogs.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor248"/>Selecting feature states</h2>
			<p>While selecting <a id="_idIndexMarker1007"/>feature states, we will use the <strong class="source-inline">createSelector()</strong> and <strong class="source-inline">createFeatureSelector()</strong> functions to create the selector. Let’s look <a id="_idIndexMarker1008"/>at an example of a selector selecting the list of blogs found under the feature <span class="No-Break">state (</span><span class="No-Break"><strong class="source-inline">BlogState</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
// blogs.selectors.ts
import { createSelector, createFeatureSelector } from '@ngrx/store';
export const selectBlogsState = createFeatureSelector&lt;BlogsState&gt;('blogsState')
export const selectBlogs = () =&gt; createSelector
    selectBlogsState,
    (state: BlogsState) =&gt; state.blogs
)</pre>
			<p>In the preceding code example, the first step is to create the feature selector that will return the whole <strong class="source-inline">BlogState</strong>. Here, we have used <strong class="source-inline">createFeatureSelector()</strong> and the state’s key to identify the feature state we want <span class="No-Break">to select.</span></p>
			<p>The second <a id="_idIndexMarker1009"/>step is to create the main selector of the blog slice; <strong class="source-inline">createSelector()</strong> has two parameters, where the first one is the <strong class="source-inline">BlogState</strong> feature <a id="_idIndexMarker1010"/>selector, and the second one is a function where the returned <strong class="source-inline">BlogState</strong> from the feature selector is the parameter. The returned value is the <span class="No-Break">blog slice.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor249"/>Implementing selectors in our project</h2>
			<p>So far, we have learned how to create selectors using the <strong class="source-inline">createFeatureSelector()</strong> and <strong class="source-inline">createSelector()</strong> functions. Now, let’s implement <a id="_idIndexMarker1011"/>them in our project. The first thing we need to identify is the states or slices. The first slice that needs a selector is a blog slice located under <strong class="source-inline">AnitHeroState</strong>. Remember that <strong class="source-inline">AntiHeroState</strong> is not our root state; this means that we will have a feature selector for the <span class="No-Break">following state.</span></p>
			<p>The second selector we need is the selector for the <strong class="source-inline">antiHeroes</strong> slice, which contains the array of anti-heroes retrieved in the API. Finally, the third selector we want will need to select specific <strong class="source-inline">antiHero</strong> data from the list based on the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> parameter.</span></p>
			<p>To create all of these selectors, place the following code in the <span class="No-Break"><strong class="source-inline">anti-hero/state/anti-hero.selectors.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
// select the AntiHeroState
export const selectAntiHeroState = createFeatureSelector&lt;AntiHeroState&gt;('antiHeroState')
// selecting all antiheroes
export const selectAntiHeroes = () =&gt; createSelector(
    selectAntiHeroState,
    (state: AntiHeroState) =&gt; state.antiHeroes
)
// selecting an antihero base on id
export const selectAntiHero = (id: string) =&gt; createSelector(
    selectAntiHeroState,
    (state: AntiHeroState) =&gt; state.antiHeroes.find(d =&gt;
      d.id === id)
)</pre>
			<p>After successfully <a id="_idIndexMarker1012"/>creating all of the selectors, we can use the <strong class="source-inline">on anti-hero/pages/list.component.ts</strong> file by adding the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
antiHeroes$ = this.store.select(selectAntiHeroes());
constructor(
    private router: Router,
    private store: Store&lt;AppState&gt;,
    ) { }
  ngOnInit(): void {
    this.assignAntiHeroes();
  }
  assignAntiHeroes() {
    this.antiHeroes$.subscribe((data) =&gt; {
      this.antiHeroes = data;
    });
  }</pre>
			<p>In the preceding code example, we used the <strong class="source-inline">selectAntiHeroes()</strong> selector to get the array of anti-heroes from the state. <strong class="source-inline">antiHeroes$</strong> is an Observable that returns the current state of the <strong class="source-inline">antiHero</strong> slice <span class="No-Break">once subscribed.</span></p>
			<p>Finally, we must get the anti-heroes list feature. We can do this by dispatching the <strong class="source-inline">GET_ANTI_HERO_LIST</strong> action in the list component in the <strong class="source-inline">ngOnInit()</strong> hook. This will call the effect that we created earlier, which invokes the endpoint for getting the list <span class="No-Break">of anti-heroes:</span></p>
			<pre class="source-code">
  ngOnInit(): void {
this. store.dispatch({type:   AntiHeroActions.GET_ANTI_HERO_LIST});
    this.assignAntiHeroes();
  }</pre>
			<p>With that, we have <a id="_idIndexMarker1013"/>successfully created selectors for the components to retrieve data from the state. In the next section, we will discuss the available configurations we can implement for <span class="No-Break">the store.</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor250"/>Configuring the store</h1>
			<p>In the previous <a id="_idIndexMarker1014"/>sections, we created all of the building blocks of NgRx that complete a fully functional store for the application. In this section, we will learn how to configure the NgRx store using <span class="No-Break">runtime checks.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor251"/>Runtime checks</h2>
			<p>Runtime checks <a id="_idIndexMarker1015"/>are used to configure the NgRx store to allow developers <a id="_idIndexMarker1016"/>to follow the NgRx and Redux core concepts and best practices. This is very useful, especially for developers new to NgRx; they display errors regarding development based on the activated <span class="No-Break">runtime checks.</span></p>
			<p><strong class="source-inline">@ngrx/store</strong> provides six built-in <span class="No-Break">runtime checks:</span></p>
			<ul>
				<li><strong class="source-inline">strictStateImmutability</strong>: Checks if the state isn’t mutated (<span class="No-Break">default: </span><span class="No-Break"><em class="italic">On</em></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">strictActionImmutability</strong>: Checks if the actions aren’t mutated (<span class="No-Break">default: </span><span class="No-Break"><em class="italic">On</em></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">strictStateSerializability</strong>: Checks if the state is serializable (<span class="No-Break">default: </span><span class="No-Break"><em class="italic">On</em></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">strictActionSerializability</strong>: Checks if the actions are serializable (<span class="No-Break">default: </span><span class="No-Break"><em class="italic">Off</em></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">strictActionWithinNgZone</strong>: Checks if actions are dispatched within NgZone (<span class="No-Break">default: </span><span class="No-Break"><em class="italic">Off</em></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">strictActionTypeUniqueness</strong>: Checks if the registered action types are unique (<span class="No-Break">default: </span><span class="No-Break"><em class="italic">Off</em></span><span class="No-Break">)</span></li>
			</ul>
			<p>To change <a id="_idIndexMarker1017"/>the default configuration of the runtime checks, we will use the <strong class="source-inline">runtimeChecks</strong> property on the root store’s config object. The value of each runtime check <a id="_idIndexMarker1018"/>can be assigned with <strong class="source-inline">true</strong> to activate the check or <strong class="source-inline">false</strong> to deactivate <span class="No-Break">the check:</span></p>
			<pre class="source-code">
@NgModule({
imports: [
  StoreModule.forRoot(reducers, {
            runtimeChecks: {
                  strictStateImmutability: true,
                  strictActionImmutability: true,
                  strictStateSerializability: true,
                  strictActionSerializability: true,
                  strictActionWithinNgZone: true,
                  strictActionTypeUniqueness: true,
                         },
         }),
       ],
})</pre>
			<h3>strictStateImmutability</h3>
			<p>This is <a id="_idIndexMarker1019"/>the number one rule of NgRx. It is activated <a id="_idIndexMarker1020"/>by default, and the runtime checks verify if the developer modifies the <span class="No-Break">state object.</span></p>
			<p><strong class="bold">Example violation of </strong><span class="No-Break"><strong class="bold">this rule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export const reducer = createReducer(initialState, on(addBlog, (state, { blog }) =&gt; ({
// Violation 1: we assign a new value to loading
state.loading = false,
 // Violation 2: `push` modifies the array
 // state.blogs.push(blog) })) );</pre>
			<p><strong class="bold">Fix for </strong><span class="No-Break"><strong class="bold">this violation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export const reducer = createReducer( initialState, on(addBlog, (state, { blog }) =&gt;
// Fix: We are returning the state as a whole object with
// the new values
  ({ ...state,
   loading: false,
   blogs: [...state.blogs, blog],
})) );</pre>
			<h3>strictActionImmutability</h3>
			<p>This <a id="_idIndexMarker1021"/>runtime check is similar to <strong class="source-inline">strictStateImmutability</strong> but is for actions. This runtime check verifies if the developer <a id="_idIndexMarker1022"/>modifies the action. This check is activated <span class="No-Break">by default.</span></p>
			<p><strong class="bold">Example violation of </strong><span class="No-Break"><strong class="bold">this rule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export const reducer = createReducer(initialState, on(addBlog, (state, { blog }) =&gt; ({
// Violation: it's not allowed to modify an action
blog.id = uniqueID();
return { ...state, blogs: [...state.blogs, blog]
} })) );</pre>
			<p><strong class="bold">Fix for </strong><span class="No-Break"><strong class="bold">this violation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
//blog.actions.ts
export const addBlog = createAction( '[Blog List] Add Blog',
// Fix: we will return the object in the action with the
// new value
(description: string) =&gt;
({ id: uniqueID(), description }) );
//blog.reducer.ts
export const reducer = createReducer(
initialState,
on(addBlog, (state, { blog }) =&gt; ({
...state,
blogs: [...state.blogs, blog],
})) );</pre>
			<h3>strictStateSerializability</h3>
			<p>This <a id="_idIndexMarker1023"/>runtime check verifies if the values placed in <a id="_idIndexMarker1024"/>the state are serializable. This is essential for persisting <a id="_idIndexMarker1025"/>the state so that it can be rehydrated in the future. This <a id="_idIndexMarker1026"/>is deactivated <span class="No-Break">by default.</span></p>
			<p><strong class="bold">Example violation of </strong><span class="No-Break"><strong class="bold">this rule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export const reducer = createReducer(
initialState,
on(addBlog, (state, { blog }) =&gt; ({
...state,
blogs: [...state.blogs, blog],
// Violation: a Date type is not a serializable value.
createdOn: new Date()
})) );</pre>
			<p><strong class="bold">Fix for </strong><span class="No-Break"><strong class="bold">this violation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export const reducer = createReducer(
initialState,
on(addBlog, (state, { blog }) =&gt; ({
...state,
blogs: [...state.blogs, blog],
// Fix: We should convert the date into a JSON Object.
createdOn: new Date().toJSON()
})) );</pre>
			<h3>strictActionSerializability</h3>
			<p>This <a id="_idIndexMarker1027"/>runtime check is similar to <strong class="source-inline">strictStateSerializability</strong>, but for actions. It checks if the states are serializable. This <a id="_idIndexMarker1028"/>is done by Redux DevTools to <span class="No-Break">debug errors.</span></p>
			<p><strong class="bold">Example violation of </strong><span class="No-Break"><strong class="bold">this rule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const createBlog = createAction(
'[Blog List] Add Blog,
blog =&gt; ({ blog,
// Violation, a function is not serializable
logBlog: () =&gt; { console.log(blog); }, }));</pre>
			<p><strong class="bold">Fix for </strong><span class="No-Break"><strong class="bold">this violation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const createBlog = createAction(
'[Blog List] Add Blog,
// Fix: we should use props to receive parameters
 props&lt;{blog: Blog}&gt;()
);</pre>
			<h3>strictActionWithinNgZone</h3>
			<p>This <a id="_idIndexMarker1029"/>runtime check verifies if the actions are dispatched <a id="_idIndexMarker1030"/>by asynchronous tasks within <strong class="source-inline">NgZone</strong>. This check is deactivated <span class="No-Break">by default.</span></p>
			<p><strong class="bold">Example violation of </strong><span class="No-Break"><strong class="bold">this rule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// Callback outside NgZone
// Violation: the createBlog actions is invoked outside the
// ngZone
callbackOutsideNgZone() {
        this.store.dispatch(createBlog ());
}</pre>
			<p><strong class="bold">Fix for </strong><span class="No-Break"><strong class="bold">this violation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import { NgZone } from '@angular/core';
constructor(private ngZone: NgZone){}
 // use run() function to call the dispatch inside the
 // NgZone
function callbackOutsideNgZone(){
  this.ngZone.run(
    () =&gt; {  this.store.dispatch(createBlog());
  }
}</pre>
			<h3>strictActionTypeUniqueness</h3>
			<p>This <a id="_idIndexMarker1031"/>runtime check prevents developers <a id="_idIndexMarker1032"/>from registering the same action type more than once. This check is deactivated <span class="No-Break">by default.</span></p>
			<p><strong class="bold">Example violation of </strong><span class="No-Break"><strong class="bold">this rule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
//Violation: two actions have the same type
export const addBlog = createAction('[Blog] Add Blog'); export const modifyBlog = createAction('[Blog] Add Blog');</pre>
			<p><strong class="bold">Fix for </strong><span class="No-Break"><strong class="bold">this violation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
//Violation: two actions have the same type
export const addBlog = createAction('[Blog] Add Blog'); export const modifyBlog = createAction('[Blog] Modify Blog');</pre>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor252"/>Summary</h1>
			<p>With that, we have reached the end of this chapter. Let’s revisit the valuable things you have learned regarding the concepts and importance of having state management <span class="No-Break">in applications.</span></p>
			<p>A store serves as a single source of truth that provides a unidirectional flow of data to prevent inconsistency and <span class="No-Break">mishandled subscriptions.</span></p>
			<p>You also learned how to install and configure the NgRx store and NgRx DevTools library with parameters for custom configuration. Lastly, you learned about the concepts surrounding state management and how to write the different blocks of NgRx, such as actions, reducers, effects, <span class="No-Break">and selectors.</span></p>
			<p>In the next chapter, we will complete the CRUD functionality of our application by using the building blocks of NgRx. We will add, remove, and update items using actions, effects, <span class="No-Break">and reducers.</span></p>
		</div>
	</body></html>