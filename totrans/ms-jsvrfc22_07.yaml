- en: Chapter 7. JSF and AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF and AJAX have been a great team for a long time. The potential of this combination
    has been heavily exploited by many JSF extensions (Ajax4Jsf, OmniFaces, PrimeFaces,
    RichFaces, ICEfaces, and so on) that provide many AJAX built-in components, extend
    AJAX default capabilities, increase AJAX security and reliability, and add more
    control to developers who need to manipulate the *bowels* of AJAX mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, JSF contains a JavaScript library that encapsulates AJAX methods
    for dealing with AJAX requests or responses. This library can be loaded in the
    following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `<f:ajax>` tag, the built-in AJAX library is loaded implicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `jsf.ajax.request()`, the AJAX library is loaded explicitly and developers
    have access to AJAX code. This approach is commonly used when the default AJAX
    behavior must be altered. It should be performed only by developers with high
    expertise, because modifying the default AJAX behavior may lead to undesirable
    issues and gaps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of the JSF-AJAX lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple JSF-AJAX example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the `execute`, `render`, `listener`, and `event` attributes work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring AJAX state on client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring AJAX errors on client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping components under the `<f:ajax>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating input fields with AJAX after a validation error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing AJAX and flow scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How postback and AJAX work together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to determine whether a request is AJAX or non-AJAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How AJAX and `<f:param>` work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue control for AJAX requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `jsf.js` can be loaded explicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write an AJAX progress bar / indicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of the JSF-AJAX lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AJAX's request-response cycle is characterized by **partial processing** and
    **partial rendering** stages; this means that AJAX partially affects the current
    view. As such, requests are not typical JSF requests, they follow a different
    lifecycle dictated by the `javax.faces.context.PartialViewContext` class. The
    methods of this class know how to deal with AJAX requests, which means that they
    are responsible for solving partial processing and rendering of the component
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel of an AJAX request is represented by two attributes of the `<f:ajax>`
    tag: `execute` and `render`. The `execute` attribute indicates the components
    that should be processed on the server (partial processing), while the `render`
    attribute indicates the components that should be rendered (or re-rendered) on
    the client (partial rendering).'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, you will see many examples of how these attributes
    works.
  prefs: []
  type: TYPE_NORMAL
- en: A simple JSF-AJAX example to get started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest JSF-AJAX example can be written in a matter of a few seconds.
    Let''s consider a JSF form with an input text and a button that sends the user
    input to the server. The user input (a string) is converted by the server to uppercase
    and is displayed to the user in an output text component. Next, you can ajaxify
    this scenario as shown in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The presence of the `<f:ajax>` tag is sufficient to transform this request into
    an AJAX request. Well, it is true that this request is not very useful because
    we did not specify which components should be executed and what components should
    be re-rendered. But the good part is that you will not receive any errors; JSF
    will use the default values for the `execute` and `render` attributes, which ask
    JSF to process the element that triggered the request and to re-render nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the `execute` or `render` attribute is missing, JSF will process the element
    that triggered the request and re-render nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the `execute` attribute with the value of the `inputText` ID (`nameInputId`)
    tag will tell JSF to pass to the server the user input. This means that the user
    input will be available in the `ajaxAction` method and will be converted to uppercase.
    You can check the effect of this method in the application server log because
    it is not visible on the client side, since the `render` attribute still defaults
    to nothing. Therefore, you need to add the `render` attribute and indicate the
    IDs of the components that should be re-rendered; in this case, the output text
    with the ID `nameOutputId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Done! This is a simple and functional AJAX application. You can find the complete
    code in the code bundle of this chapter, named `ch7_1`.
  prefs: []
  type: TYPE_NORMAL
- en: The JSF-AJAX attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will see what the main attributes supported by `<f:ajax>`
    are. We start with `execute` and `render`, continue with `listener` and `event`,
    and finish with `onevent` and `onerror`.
  prefs: []
  type: TYPE_NORMAL
- en: The execute and render attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, the `execute` and `render` attributes affect a single
    component indicated by its ID. When multiple components are affected, we can specify
    a list of IDs separated by space, or we can use the following keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@form`: This keyword refers to all component IDs in the form that contains
    the AJAX component. If it is present in the `execute` attribute, then the entire
    `<h:form>` is submitted and processed. In case of the `render` attribute, the
    entire `<h:form>` is rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@this`: This keyword refers to the ID of the element that triggers the request
    (default when `execute` is missing). For the `execute` attribute, `@this` will
    submit and process only the component that contains the AJAX component, while
    for the `render` attribute, it will render only the component that contains the
    AJAX component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@none`: No component will be processed/re-rendered. But for the `execute`
    attribute, JSF will still execute the lifecycle, including its phase listeners;
    while for the `render` attribute, JSF will perform the *Render Response* phase,
    including firing any `preRenderView` events. This is the default value for the
    `render` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@all`: This keyword represents all components IDs. For `execute`, all components
    in a page are submitted and processed—like a full page submit. For the `render`
    attribute, JSF will render all components in the page; this will update the page,
    but will allow preserving some client-side states outside the JSF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depending on the application''s needs, these keywords and component IDs can
    be mixed to obtain cool AJAX requests. For example, go through the following AJAX
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process and re-render the current form using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process form, re-render none, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process the element that triggers the request and re-renders the form, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process the form and re-render all as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process the form and re-render the components with IDs `nameInputId phoneInputId`
    inside the form as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can continue with many other examples, but I think you got the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keywords (`@form`, `@this`, `@all`, and `@none`) and component IDs can be
    mixed in the same value of the `render` and `execute` attribute. Don't forget
    to separate them with spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be seen in the code bundle of this chapter, and
    is named as `ch7_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special case consists in re-rendering components outside the form that contains
    the AJAX element that triggers the request. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `:` notation for updating components outside the form, which contains
    the element that triggers the AJAX request. This notation represents the default
    separator returned by the `UINamingContainer.getSeparatorChar` method. This can
    be specified via the `javax.faces.SEPARATOR_CHAR` context parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_3`.
  prefs: []
  type: TYPE_NORMAL
- en: The listener attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important attribute of `<f:ajax>` is named `listener`. This attribute
    indicates a server-side method that should be executed when an AJAX request is
    fired by a client action. For example, you can do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, using the `listener` attribute you can transform the preceding code into
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'An obvious question arises here. What is the difference between these two and
    why should I use `listener` and not `action`? Well, there are a few differences
    between these two, and the following are the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: A server-side method called through the `action` attribute can return `String`
    representing a navigation case (outcome), while a server-side method called through
    `listener` cannot provide a navigation case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the client disables JavaScript in the browser configuration, the `listener`
    attribute will not work anymore—the server-side method will not be called. The
    `action` attribute still works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components that do not support the `action` attribute can use `listener` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server-side method called through the `listener` attribute accepts an argument
    of type `AjaxBehaviorEvent`, which represents the component behavior specific
    to AJAX. This is not accepted in case of the `action` attribute. For example,
    refer to the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the client behavior (the `ClientBehavior` interface) is responsible
    for generating reusable JavaScript code that can be added to JSF components. The
    AJAX (`<f:ajax>`) is a client-side behavior, which means it is always attached
    as a behavior to another UI component(s). You can find more details about `ClientBehavior`
    in the *Working with client behavior functionality* section in [Chapter 5](ch05.html
    "Chapter 5. JSF Configurations Using XML Files and Annotations – Part 2"), *JSF
    Configurations Using XML Files and Annotations – Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_4`.
  prefs: []
  type: TYPE_NORMAL
- en: The event attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each AJAX request is fired by an event indicating a user or programmatic action.
    JSF defines default events based on the parent components; according to documentation
    "The default event is `action` for `ActionSource` components such as `<h:commandButton>`,
    and `valueChange` for `EditableValueHolder` components such as `<h:inputText>`".
    Most of the time, the default events are exactly what you need, but in case that
    you want to explicitly set an event for a component, you can use the `event` attribute.
    Some of the most common values for this attribute are `click`, `focus`, `blur`,
    `keyup`, and `mouseover`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse these events with JavaScript events, which are prefixed with
    the `on` notation (`onclick`, `onkeyup`, `onblur`, and so on). The JavaScript
    events are *behind* AJAX events; or, with other words, AJAX events are based on
    JavaScript events. For example, AJAX `click` event is based on the `onclick` JavaScript
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the event that triggers the AJAX action is `keyup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_5`.
  prefs: []
  type: TYPE_NORMAL
- en: The onevent attribute – monitoring AJAX state on client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During an AJAX request, JSF is capable of calling a client-defined JavaScript
    method and passing an object named `data` to it, containing information about
    the current state of the request. The JavaScript function is called when the request
    begins, completes, and succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data` objects encapsulate the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: This property gives the type of the AJAX call, `event`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: This property returns the `begin`, `complete`, or `success` status
    (can be used to implement an indeterminate progress bar).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When the `status` property has the value `begin`, which means that the AJAX
    request has not been sent yet. When it equals `complete`, it means that the AJAX
    response has successfully reached to the client, but it hasn't been processed
    yet. If the received response is successfully processed (without errors), the
    `status` value becomes `success`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`source`: This property returns the DOM element representing the source of
    the AJAX event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseXML`: This is the AJAX response in XML format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseText`: This is the AJAX response in text format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseCode`: This is the AJAX response code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to indicate the name of the JavaScript method through the `onevent`
    attribute (in `jsf.js`, the JavaScript method representing implementation of this
    attribute is named `addOnEvent`(callback)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `ajaxMonitoring` function can use the `data` object and its properties
    to accomplish different client-side tasks. For example, the following implementation
    feeds up some `div` tags with details about the AJAX request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, you can see a possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The onevent attribute – monitoring AJAX state on client](img/6466EN_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_21`.
  prefs: []
  type: TYPE_NORMAL
- en: The onerror attribute – monitoring AJAX errors on client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, you saw how to monitor the state of AJAX requests
    using a client-defined JavaScript function and the `data` object. Based on the
    same technique, we can obtain information about the possible errors that can occur
    during AJAX requests. The passed `data` object encapsulates the following properties
    (notice that this is the same `data` object from the preceding section; therefore
    you still have access to those properties): `description`, `errorName`, and `errorMessage`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data.type` property will be `error` and the `data.status` property will
    be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serverError`: This is the response of the AJAX request that contains an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malformedXML`: This is an XML well-formed error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpError`: This is a valid HTTP error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emptyResponse`: This is a server-side code that did not provide a response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name of the JavaScript method is indicated through the `onerror` attribute
    (in `jsf.js`, the JavaScript method representing implementation of this attribute
    is named `addOnError` (callback)). So at this point, we can update the application
    from the previous section to report errors on the client as well, as shown in
    the following code (note that `onevent` and `onerror` calls the same method, `ajaxMonitoring`;
    however this is not mandatory as you can use separate JavaScript methods as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can test this code by adding an intentional error, such as calling
    nonexistent server-side method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The onerror attribute – monitoring AJAX errors on client](img/6466EN_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application can be found in code bundle of this chapter, and is
    named `ch7_6`.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping components under <f:ajax> tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it may be useful to group multiple components under the same `<f:ajax>`
    tag. For example, the following code snippet groups two `<h:inputText>` components
    under the same `<f:ajax>` tag (you can nest other components as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, how does it work? When you click either of the input components, an AJAX
    request is fired for the input component and one for the form (two requests in
    our example) and all the components in the form are re-rendered. Since the `click`
    event will generate AJAX requests/responses, you will not be able to enter keys
    in those `<h:inputText>` unless you are using the *Tab* key to gain focus in each
    `<h:inputText>` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The components grouped under `<f:ajax>` can still use inner (or locally used)
    `<f:ajax>` tags. In this case, the effect is cumulative. Of course, you have to
    be extra careful when you use this technique, because undesired behaviors may
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_7`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating input fields with AJAX after validation error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating input fields with AJAX after validation error is a very old, well-known,
    and annoying issue for JSF developers. When an AJAX request fails in the validation
    phase, there is no built-in way to update the input fields with some valid values
    because JSF does not allow access to the model value after a validation error
    (usually, you want to clear up those fields or provide some default values, or
    even some old values provided by the same user). Of course, JSF developers found
    different workarounds, or used other libraries, such as PrimeFaces or OmniFaces,
    but a JSF solution was required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JSF 2.2, all components that should be re-rendered (components
    indicated in the `render` attribute) will be reset if we set the `resetValues`
    attribute to `true`. The easiest way to understand this is to proceed with a comparison
    test. First, let''s use an AJAX request without `resetValues`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose that a valid value for our input field is an alphanumeric string
    (with respect to the [^a-zA-Z0-9] pattern). In the following screenshot, on the
    left-hand side, you can see the AJAX result after inserting a valid value, and
    on the right-hand side, you can see the AJAX result after inserting an invalid
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating input fields with AJAX after validation error](img/6466EN_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, on the right-hand side, the invalid
    value was not reset. The invalid value retains and is very annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we proceed with the same case, but we add the `resetValues` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we repeat the test. In the following screenshot, on the left-hand side,
    the submitted value is valid, while on the right-hand side, it is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating input fields with AJAX after validation error](img/6466EN_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, when the submitted value was invalid, the input field was reset (in this
    case, cleared).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From this example, you may misunderstand that `resetValues` works as a clear
    (empty) field's action. Well, it does not! When an input field is reset, the valid
    value that replaces the invalid one is related to the managed bean (the renderer
    will pick up the value from the bean). If the managed bean is in the request scope,
    the replacer (valid value) will be the one used for initialization of corresponding
    property (which may be anything, not just an empty string). But, if the managed
    bean is in view scope, then the replacer will be the currently valid value of
    the corresponding property, which may be the initialization value, or the previous
    valid value inserted by the user (of course, altered or not altered in a server-side
    method).
  prefs: []
  type: TYPE_NORMAL
- en: Keep this note in mind while testing the complete application available in the
    code bundle of this chapter, named `ch7_8_1`. By default, this application comes
    with a request scoped managed bean, but you can easily transform it into a view
    scoped for more tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `resetValues` attribute for AJAX requests, JSF 2.2 comes with a
    tag, named `<f:resetValues>`, for non-AJAX requests. Basically, this is an action
    listener that can be easily attached to any `ActionSource` instance (for example,
    `<h:commandButton>`). The effect will consist of resetting all components that
    are given in its `render` attribute (use only component IDs, not keywords such
    as `@form`, `@all`, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_8_2`. This tag is not recognized in all JSF 2.2 (Mojarra and MyFaces)
    versions, therefore you have to test it in order to be sure that you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: The Cancel and Clear buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Buttons of type **Cancel** (which resets the form''s fields to the initial
    state or to the most recent valid state) and **Clear** (which clears up the form''s
    fields) are not very popular in web applications, but sometimes they can be useful
    to end users. When implementing the **Cancel**/**Clear** buttons, you need to
    find a way to skip the *Process Validation* phase (which is needed for the **Submit**
    button). The motivation is simple: when a user cancels/clears a form''s values,
    we certainly don''t need valid values in order to accomplish these tasks; therefore,
    no validation is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: In non-AJAX requests, a common technique consists of using the `immediate="true"`
    attribute, which, for command components (for example, `<h:commandButton>`), will
    transfer the invocation of action in *Apply Request Values* phase. This attribute
    is available for AJAX requests as well, but AJAX provides a better solution for
    these kinds of tasks. Instead of using `immediate="true"`, we can use the `@this`
    keyword. Furthermore, we can use the `resetValues` feature to simplify and fortify
    the **Cancel**/**Clear** buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at some scenarios. We will keep things simple, therefore we
    need a form with a single input field and three buttons: **Submit**, **Cancel**,
    and **Clear**. The validator will allow only alphanumeric characters (with respect
    to the `[^a-zA-Z0-9]` pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: Value submitted to a view scoped managed bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Press the **Submit** button. In case of an invalid value, you will see a specific
    error message (`<h:message>`), and `resetValues` will reset the input field to
    the initial value (empty string or some suggestion) or the most recent valid value.
  prefs: []
  type: TYPE_NORMAL
- en: Press the **Cancel** button. Since we are using `execute="@this"`, the input
    field will not be processed on the server; therefore no validation happens. The
    re-render process will have the same effect as `resetValues` for the input field,
    but will clear the `<h:message>` tag as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the **Clear** button. This button uses `execute="@this"`, too. But, instead
    of resetting the input field to `resetValues`, it clears up the input field and
    `<h:message>`. For this, an additional method is needed in the managed bean as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_9_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple tip and trick, for the **Clear** button you may want to use a place
    holder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Value submitted to a request scoped managed bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the submitted value is not persisted across multiple AJAX requests, the
    `resetValues` method and the **Cancel** button will reset the input field to the
    initialization value (empty string or suggestion). The **Cancel** button will
    also reset the `<h:message>` tag. The **Clear** button will clear up input text
    and `<h:message>`. Of course, under some circumstances (such as using an empty
    string for initialization), the **Cancel** and **Clear** buttons will do the same
    thing; therefore, you can drop one of them.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be seen in the code bundle of this chapter, and
    is named `ch7_9_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More examples of how to use `resetValues` and implement the **Cancel** and
    **Clear** buttons can be found in the source code that accompanies this book.
    A set of examples using the `keyup` event in an input field with cancel/clear
    facilities contain the following applications: `ch7_9_3`, `ch7_9_4`, `ch7_9_5`,
    and `ch7_9_6`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything seems to work pretty straightforward, but there is an issue that
    we have to fix. Let''s take a closer look at the following code (there is nothing
    tricky in it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's focus on the submit process. When we submit a valid name and surname,
    the form is re-rendered and everything looks as expected, but if one value (or
    both) is invalid, then the input fields are not reset and the corresponding error
    messages appear. This is normal since the `resetValues` method is not present;
    therefore, the first thought would be to add `resetValues="true"` to `<f:ajax>`
    that corresponds to the **Submit** button. However, this will not work as expected,
    because nothing happens in case of invalid values. While you may think that the
    input fields will be reset for invalid values, you will be surprised to see that
    everything remains unchanged and the invalid values are still there after re-render.
    The cause seems to be the presence of `@form` in the `render` attribute of the
    **Submit** button. If you replace this with the components IDs that should be
    re-rendered (`nameId`, `msgNameId`, `surnameId`, and `msgSurnameId`), the `resetValues`
    method works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: But, what you can do if there are many input fields and you don't want to list
    all the components IDs? Or you just want to use the `@form` keyword in the `render`
    attribute? In this case, you should be aware that the invalid input fields will
    not be automatically reset (the `resetValues` method is useless) and the end user
    should manually cancel/clear input fields by clicking on the **Cancel** or **Clear**
    button. While the **Cancel** button works fine, there is a big *Oops!* for the
    **Clear** button because JSF will not clear the input fields that are not executed
    (listed in the `execute` attribute) and are re-rendered (listed in the `render`
    attribute), unless you submit only valid values. In other words, if the name is
    valid and the surname is not (or any other combination involving invalid values),
    then after submit and clear, the input field for the name is not cleared.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution to this problem is given on OmniFaces ([https://code.google.com/p/omnifaces/](https://code.google.com/p/omnifaces/)),
    which provides an action listener named `org.omnifaces.eventlistener.ResetInputAjaxActionListener`
    ([http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener](http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener)).
    This listener is capable of fixing the **Clear** button and other issues of the
    same category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_9_7`.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing AJAX and flow scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AJAX requests are usually associated with beans in view scope (`@ViewScoped`),
    which means that data can be persisted (stored) over multiple AJAX requests as
    long as the current view is not destroyed by a navigation case (or other causes).
    A flow is defined as a collection of logical related pages/views; therefore AJAX
    cannot survive across flow transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For better understanding, we will adapt the application developed in [Chapter
    3](ch03.html "Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication"),
    *JSF Scopes – Lifespan and Use in Managed Beans Communication* (the `ch3_7_3`
    application, which you need to be familiar with) to support AJAX requests in the
    `registration.xhtml` view (the first page in flow). The main idea is to write
    a view scoped bean that may populate the player name and surname defined in the
    flow scoped bean, `RegistrationBean`. The view-scoped bean, named `ViewRegistrationBean`,
    will randomly generate a name-surname pair and will present them as a suggestion
    to the end user. The user can provide the name and surname or he can choose to
    use the suggested ones. So, the flow-scoped bean looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getReturnValue` method represents a flow return (exits flow),
    while the `registrationAction` method navigates to the next page in the flow.
    Both of them will break down the current view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the view-scoped bean is the method annotated with `@PostConstruct` that
    will help us to see if AJAX uses the same instance of this bean over multiple
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily monitor the values of name and surname by displaying them in
    `registration.xhtml` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, two buttons will fire AJAX requests. One button will call the server-side
    method `credentialsUpperCase` (from flow-scoped bean, `RegistrationBean`) and
    the other one will call the server-side method `generateCredentials` (from view-scoped
    bean, `ViewRegistrationBean`). In both cases, we will re-render the player name
    and surname from the beans as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the end user can register to the tournament in two ways: by manually inserting
    the name and surname through the input fields and register by pressing the first
    button (the result will be the inserted name and surname in uppercase), or he/she
    can choose to use the suggested name and surname and register by pressing the
    second button (the result will be the random name and surname in uppercase).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important things can be noticed here, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Firing AJAX requests, by pressing the first button, will put the submitted name
    and surname in the flow scope (manually entered or imported from random suggestion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing AJAX requests, by pressing the second button, will assign the suggested
    name and surname to their counterparts in the flow-scoped bean. It will not generate
    new names and surnames for each request, since we are in the same view across
    multiple AJAX requests, and the `init` method is called only when a new instance
    of the `ViewRegistrationBean` bean is created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we exit and re-enter in the flow, the persisted name and surname lose their
    values. When we exit from the flow, we reach the flow-scope boundaries, which
    means a new `RegistrationBean` instance must be created when entering in the flow
    again. Moreover, this outcome will change the current view; therefore, a new instance
    of `ViewRegistrationBean` is also needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we navigate to the next page in the flow, the submitted name and surname
    have the same values because they were persisted in flow scope; while the suggested
    name and surname are randomly generated again, the outcome has changed the view,
    even if we are in the same flow, as shown in the following screenshot:![Mixing
    AJAX and flow scope](img/6466EN_07_05.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you know how AJAX works with flow scope combined with view scope. The complete
    application can be found in the code bundle of this chapter, which is named `ch7_10`.
  prefs: []
  type: TYPE_NORMAL
- en: Postback and AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have mentioned the postback request several times.
    For those who are not familiar with it, or just need a quick reminder, let's say
    that JSF recognizes the initial request and the postback request.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial request** (for example, `HTTP GET`) is the first request that the
    browser sends for loading the page. You can obtain such a request by accessing
    the application URL in a browser or by following a link (it can be a link to any
    page of the application). Moreover, the initial request happens in `page_B` when
    `page_A` contains a redirection (`faces-redirect=true`) to `page_B` (this is not
    true for forwarding mechanism). This kind of request is processed in *Restore
    View* phase and *Render Response* phase.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Postback request** happens when we click on a button/link for submitting
    a form. Unlike the initial request, the postback request passes through all the
    phases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF provides a method named `isPostback` that returns a Boolean value: it returns
    `true` for postback request and `false` for initial request. Speaking in the code
    lines, we can:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the initial/postback request in a managed bean using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the initial/postback request in the page using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, you can check the initial/postback request for AJAX with a simple
    application. The JSF page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The managed bean is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is very simple; therefore we can jump directly to inspect the initial/postback
    requests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First request**: The first page of the application is loaded by accessing
    the application URL. The client side indicates an initial request as it is shown
    in the following screenshot on the left-hand side, and the server side indicates
    the same, as shown in the same screenshot on the right-hand side:![Postback and
    AJAX](img/6466EN_07_06.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second request**: The **Click Me!** button is clicked for the first time
    (the result is `true` for the second time, third time, and so on). The client
    side (in the browser) indicates a postback request as it is shown in the following
    screenshot on the left-hand side, and the server side indicates the same as shown
    in the same screenshot on the right-hand side:![Postback and AJAX](img/6466EN_07_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be useful to know when the request is initial or postback. For example,
    you may want to accomplish a task a single time, at initial request (for example,
    the initialization tasks), or every time, except for the first time (for example,
    display a message, which is not proper to appear when a page is displayed as a
    result of the initial request).
  prefs: []
  type: TYPE_NORMAL
- en: Postback request's conditional rendering/executing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use initial/postback request detection to conditionally render UI components
    (of course, you can use it for partial processing also). Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s see how it works! When the page is loaded, we have an initial request
    (`#{facesContext.postback}` returns `false`), which means that the server response
    will contain something like the following code snippet (we need to focus on the
    `<f:ajax>` component):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: On the server side, the log line from the `getRequest_number` method will also
    reveal an initial request. Moreover, notice that the reported request number is
    `1`, which is the initial value of the `request_number` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s click once on the **Click Me!** button. Now, the AJAX request
    will look like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code provides important information! This is a postback request,
    but the `render` attribute contains the ID of the `<h:form>` component, not the
    ID of the `<h:panelGrid>` component (as you may have thought); this happens because
    the `#{facesContext.postback}` expression was evaluated to `false` in the previous
    request. So, with the first click on our button, AJAX will not re-render the `<h:panelGrid>`
    component. Meanwhile, on the server side, the `request_number` property was successfully
    incremented to `2`; however for the end user, it still appears as `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the server response for this AJAX will contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `postbackId`, which is the `<h:panelGrid>` ID, is present in
    the response. The next click (the second click) on the button will generate the
    next AJAX request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the AJAX request completes, the `<h:panelGrid>` component will be
    re-rendered. The `request_number` property reaches the value `3`, and it will
    be displayed on the client side. Further AJAX requests will be the postback requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the initial request, first click on
    the button and second click from client and server sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postback request''s conditional rendering/executing](img/6466EN_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It would be helpful to know this behavior of AJAX with initial/postback requests—it
    is not a bug. Of course, once you know this *issue*, there are many workarounds
    depending on what you really want to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Further, you can try to test the `execute` attribute in a similar approach.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_11`.
  prefs: []
  type: TYPE_NORMAL
- en: Is it a non-AJAX request?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSF can answer this question by inspecting request headers or checking the
    `PartialViewContext.isAjaxRequest` method. The request headers that provide information
    about the request type are `Faces-Request` and `X-Requested-With`. For an AJAX
    request, the `Faces-Request` header will have the value `partial/ajax`, while
    the `X-Requested-With` request type will have the value `XMLHttpRequest` (in JSF
    2.2, `X-Requested-With` doesn''t seem to work; however, for the sake of completeness,
    you can test them again). In the following screenshot, you can see the headers
    of a typical JSF 2.2 AJAX request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Is it a non-AJAX request?](img/6466EN_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a managed bean, you can determine the type of the request, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, on a JSF page, you can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_12`.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX and <f:param>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<f:param>` tag can be used to pass request parameters to a managed bean.
    Since we have discussed this tag in detail in [Chapter 2](ch02.html "Chapter 2. Communication
    in JSF"), *Communication in JSF*, we can continue here with an example of using
    it inside `<f:ajax>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the parameter that was passed is available in the request parameter
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that `<f:param>` can be used with buttons and links only. Trying
    to add `<f:param>` in inputs will not work. Further details are available in [Chapter
    2](ch02.html "Chapter 2. Communication in JSF"), *Communication in JSF*.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_13`.
  prefs: []
  type: TYPE_NORMAL
- en: Queue control for AJAX requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queuing AJAX requests on the client side is a common practice meant to ensure
    that only one request is processed at a time. The goal of this approach is to
    protect the server from being overwhelmed and the client browser from blocking
    or receiving AJAX responses in an undefined order. While AJAX queuing is available
    in JSF 2.0, queue control for AJAX is available starting with JSF 2.2.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide AJAX queue control, JSF 2.2 introduced an attribute named
    `delay` for the `<f:ajax>` tag. The value of this attribute is a string that represents
    a number of milliseconds (defaults to `none`). During this time interval, only
    the most recent request is actually sent to the server, while the rest of them
    are ignored. In other words, JSF will wait *n* milliseconds until the most recent
    AJAX request is executed. By default, it will not wait.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of using the default `delay` attribute, and an explicit delay
    of 1000 milliseconds. In order to point out the delay effect, we've built a simple
    application that sends an AJAX request (submit an input text value) on the `keyup`
    event, and waits for a suggestion text as a server response. In the following
    screenshot, you can compare the number of entered keys until the server responds
    with the first suggestion text. In both the cases, this is the first triggered
    AJAX request. It is obvious that in the second case, a number of seven requests
    (keystrokes) were not sent because they were fired during the1000 milliseconds
    range. Generally speaking, every time a new key is entered, prior AJAX requests
    are removed, and only the last request is taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: '![Queue control for AJAX requests](img/6466EN_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_14`. You may also want to check out the *Customizing jsf.js* section,
    where you'll see the `delay` attribute at work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can disable the effect of the `delay` attribute by setting its value to
    `none`. This is the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit loading of jsf.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AJAX mechanism used by JSF is encapsulated in a JavaScript file, named `jsf.js`.
    This file is available in the `javax.faces` library. When we are using `<f:ajax>`,
    this file is loaded behind the scene without any explicit requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `jsf.js` can be loaded explicitly with any of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `<h:outputScript>` component as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `@ResourceDependency` keyword as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Focusing on `<h:outputScript>`, you can attach AJAX to a component as shown
    in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `jsf.ajax.request` method defined in `jsf.js` is capable of dealing with
    AJAX requests. It takes the following three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source`: This is the DOM element (for example, `<h:commandButton>`, `<h:commandLink>`,
    and so on) that triggers the AJAX request (this is a mandatory parameter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event`: This is an optional parameter representing the DOM event that triggers
    the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: This is an optional parameter that can contain the values: `execute`,
    `render`, `onevent`, `onerror`, `delay`, and `params`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete application for explicitly loading the `jsf.js` file is available
    in the code bundle of this chapter, which is named `ch7_15`.
  prefs: []
  type: TYPE_NORMAL
- en: Depicting the params value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the `execute`, `render`, `delay`, `onevent`, and `onerror` values are
    very well known from previous sections, the `params` value is something new, so
    let's give it some attention. The `params` value is actually an object that allows
    us to add supplementary parameters into the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code is a fancy solution for sending a JavaScript
    JSON object to a managed bean. The code is straightforward as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, the `params` value is available in the request parameter
    map as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_16`.
  prefs: []
  type: TYPE_NORMAL
- en: Non-UICommand components and jsf.ajax.request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `<f:ajax>` tag is far more popular than `jsf.ajax.request`. This is absolutely
    normal, since `<f:ajax>` fits more natural in *context* and is much more easy
    to use and understand. Moreover, `<f:ajax>` supports the `listener` attribute,
    which allows us to call the server-side methods even when the `<f:ajax>` tag is
    nested in other components than in `UICommand`. By default, `jsf.ajax.request`
    cannot do that!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that we have a table (`<h:dataTable>`) that displays
    a `Map` object containing several tennis players (the `Map` key is an integer
    of type: `1`, `2`,`3`, ... *n*, and the `Map` value is the player name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to add a column labeled **Delete** that contains a delete icon
    for each row, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Non-UICommand components and jsf.ajax.request](img/6466EN_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We want to capture the client-side `onclick` event and trigger an AJAX request
    using `jsf.ajax.request` for each icon. The idea is to send the player number
    (`1`, `2`, `3`, ... *n*) to a server-side method named `deletePlayerAction`. This
    method will find and delete the record from the `Map` object and when the table
    is re-rendered, the corresponding row will disappear. So, the code can be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `params` value to send the player number to delete; this will
    be available through the request parameter map. But the big issue here is that
    we can't call the server-side method, `deletePlayerAction`, because we don't have
    a `UICommand` component (such as a button) and `jsf.ajax.request` doesn't have
    a `listener` value for the `options` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the solution comes from the JSF extensions such as PrimeFaces (check
    `<p:remoteCommand>`), OmniFaces (check `<o:commandScript>`), or RichFaces (check
    `<a4j:jsfFunction>`), but you can also solve the problem through pure JSF. First,
    you need to add a `UICommand` component that is not visible, such as a `<h:commandLink>`
    tag, as added in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we bind the AJAX request to this `UICommand` component, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, when we click on a delete icon, the server-side method is executed.
    The code of this method is pretty simple, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application can be found in the code bundle of this chapter,
    which is named `ch7_17`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as the section name suggests, this was an example of using `jsf.ajax.request`,
    not the best solution to this scenario. Nevertheless, there are simple solutions
    for this, such as using a `<h:commandLink>` tag in conjunction with the icon and
    ajaxify the link (proposed by Michael Muller at [http://blog.mueller-bruehl.de/tutorial-web-development/](http://blog.mueller-bruehl.de/tutorial-web-development/)),
    The following code snippet shows this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The complete example can be found in the code bundle of this chapter named `ch7_18`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing jsf.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest advantage of explicitly loading `jsf.js` is the fact that we can
    customize the AJAX mechanism by altering the default code. First, we need to isolate
    the default `jsf.js` file in a separate place—you can easily save it in a folder
    such as `resources/default/js` in the web pages folder. Afterwards, you can edit
    the JavaScript file and perform the desired modifications. Of course, modify this
    code only if you really know what you are doing, because you may cause undesired
    issues! It is not recommended that you modify the code, unless you really need
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can modify the Mojarra, the `jsf.js` code to see how the
    AJAX queue works. More precisely, to see how requests are added in queue and removed
    from queue depending on the `delay` value, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `jsf.js`, find the `enqueue` function. This function is called by JSF to
    add an AJAX request in queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify this function to call a JavaScript custom function and pass to it the
    AJAX queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do the same thing in the `dequeue` function. This function is called by JSF
    to remove an AJAX request from the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify this function to call the same JavaScript custom function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, a JavaScript custom function will be called every time an AJAX
    request is added/removed in/from the queue and the current queue will be passed
    in. Each entry in the queue is an AJAX request; therefore, we can loop the queue
    and extract information about each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Each request object has a suit of properties, which can be easily seen in the
    following code (this is extracted directly from the `jsf.js` source code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'All you have to do now is to trigger some AJAX requests and monitor the queue
    report generated in the `monitorQueue` function. As you can see in the following
    code, each button has a different `delay` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, all AJAX requests are referring the same server-side method,
    `ajaxAction`. This method can easily simulate some business logic by sleeping
    for a random number of milliseconds for each request, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Once you know how to monitor the queue content, you can go further and alter
    its content by queuing only certain requests, changing their priority of execution,
    accepting a limited number of entries in queue, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_19`.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX and the progress bar/indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While testing on `localhost`, AJAX requests seem pretty fast, but in real production
    environments they cannot be solved as fast because many aspects slow down the
    process (Internet connection speed, number of concurrent users, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: A common practice consists of using a progress bar/indicator that signals the
    user that requests are being processed and he/she should wait until the AJAX response
    is received and rendered accordingly. For example, PrimeFaces provides a cool
    determinate progress bar for upload tasks (`<p:fileUpload>`) and an indeterminate
    progress indicator for any other AJAX request (check `<p:ajaxStatus>`). RichFaces
    also have similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will see how to implement a progress bar for upload
    tasks. Without writing a custom component, such as `<p:ajaxStatus>`, we can easily
    implement a progress indicator using the `onevent` attribute, the `data` object,
    and a small piece of CSS, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see an example of running the complete
    application, named `ch7_20` in the code bundle of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AJAX and the progress bar/indicator](img/6466EN_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the AJAX support in JSF 2.2 Core. Besides common
    tasks such as using `render`, `execute`, `listener`, and other attributes, you
    learned how to use AJAX with JSF 2.2 flow scope, how to use the JSF 2.2 `delay`
    attribute, and how to update input fields with AJAX after validation error, using
    the new JSF 2.2 `resetValues` attribute and the `<f:resetValues>` tag. Moreover,
    you saw how to use postback with AJAX, how to determine if a request is AJAX or
    non-AJAX, customize jsf.js, how to write a progress bar/indicator, how to create
    the **Cancel**/**Clear** buttons, how to monitor AJAX queue, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, JSF framework (including major extensions, such as PrimeFaces,
    OmniFaces, RichFaces, ICEfaces, and so on) has the most comprehensive and easy-to-use
    AJAX capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will cover the JSF 2.2 support for HTML5
    and the new upload mechanism.
  prefs: []
  type: TYPE_NORMAL
