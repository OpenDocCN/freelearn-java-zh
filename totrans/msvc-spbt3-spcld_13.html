<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer313" class="Basic-Text-Frame">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-330" class="chapterTitle">Improving Resilience Using Resilience4j</h1>
    <p class="normal">In this chapter, we will learn how to use Resilience4j to make our microservices more resilient, that is, how to mitigate and recover from errors. As we already discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, in the <em class="italic">Circuit breaker</em> section, and <em class="chapterRef">Chapter 8</em>, <em class="italic">Introduction to Spring Cloud</em>, in the <em class="italic">Using Resilience4j for improved resilience</em> section, a circuit breaker can be used to minimize the damage that a slow or unresponsive downstream microservice can cause in a large-scale system landscape of synchronously communicating microservices. We will see how the circuit breaker in Resilience4j can be used together with a time limiter and retry mechanism to prevent two of the most common error situations:</p>
    <ul>
      <li class="bulletList">Microservices that start to respond slowly or not at all</li>
      <li class="bulletList">Requests that randomly fail from time to time, for example, due to temporary network problems</li>
    </ul>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Introducing the three Resilience4j mechanisms: circuit breaker, time limiter, and retry</li>
      <li class="bulletList">Adding the mechanisms to the source code</li>
      <li class="bulletList">Trying out the mechanisms when deployed in the system landscape</li>
    </ul>
    <h1 id="_idParaDest-331" class="heading-1">Technical requirements</h1>
    <p class="normal">For instructions on how to install the tools used in this book and how to access the source code for this book, see:</p>
    <ul>
      <li class="bulletList"><em class="chapterRef">Chapter 21</em>, <em class="italic">Installation Instructions for macOS</em></li>
      <li class="bulletList"><em class="chapterRef">Chapter 22</em>, <em class="italic">Installation Instructions for Microsoft Windows with WSL 2 and Ubuntu</em></li>
    </ul>
    <p class="normal">The code examples in this chapter all come from the source code in <code class="inlineCode">$BOOK_HOME/Chapter13</code>.</p>
    <p class="normal">If you want to view the changes applied to the source code in this chapter, that is, see what it took to add resilience using Resilience4j, you can compare it with the source code for <em class="chapterRef">Chapter 12</em>, <em class="italic">Centralized Configuration</em>. You can use your favorite <code class="inlineCode">diff</code> tool and compare the two folders, <code class="inlineCode">$BOOK_HOME/Chapter12</code> and <code class="inlineCode">$BOOK_HOME/Chapter13</code>.</p>
    <h1 id="_idParaDest-332" class="heading-1">Introducing the Resilience4j resilience mechanisms</h1>
    <p class="normal">The circuit <a id="_idIndexMarker871"/>breaker, time<a id="_idIndexMarker872"/> limiter, and retry mechanisms<a id="_idIndexMarker873"/> are potentially useful in any<a id="_idIndexMarker874"/> synchronous communication between two software components, for example, microservices. In this chapter, we will apply these mechanisms in one place, in calls from the <code class="inlineCode">product-composite</code> service to the <code class="inlineCode">product</code> service. This is illustrated in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_01.png" alt="Diagram  Description automatically generated" width="877" height="407"/></figure>
    <p class="packt_figref">Figure 13.1: Adding resilience capabilities to the system landscape</p>
    <p class="normal">Note that the <a id="_idIndexMarker875"/>synchronous calls to the discovery and config servers from the other microservices are not shown in the preceding diagram (to make it easier to read).</p>
    <div class="packt_tip">
      <p class="normal">With the Spring Cloud Hoxton release in November 2019, the <strong class="keyWord">Spring Cloud Circuit Breaker</strong> project<a id="_idIndexMarker876"/> was added. It provides an abstraction layer for circuit breakers. Resilience4j can be configured to be used under the hood. This project does not provide other resilience mechanisms such as retries, time limiters, bulkheads, or rate limiters in an integrated way as the <a id="_idIndexMarker877"/>Resilience4j project does. For more information on the project, see <a href="https://spring.io/projects/spring-cloud-circuitbreaker"><span class="url">https://spring.io/projects/spring-cloud-circuitbreaker</span></a>.</p>
      <p class="normal">A number of other alternatives exist as well. For example, the Reactor project comes with built-in support for retries and timeouts; see <code class="inlineCode">Mono.retryWhen()</code> and <code class="inlineCode">Mono.timeout()</code>. Spring also has a <a id="_idIndexMarker878"/>retry mechanism (see <a href="https://github.com/spring-projects/spring-retry"><span class="url">https://github.com/spring-projects/spring-retry</span></a>), but it does not support a reactive programming model.</p>
      <p class="normal">However, none of the alternatives provide such a cohesive and well-integrated approach to providing a set of resilience mechanisms as Resilience4j does, specifically, in a Spring Boot environment, where dependencies, annotations, and configuration are used in an elegant and consistent way. Finally, it is worth noting that the Resilience4j annotations work independently of the programming style used, be it reactive or imperative.</p>
    </div>
    <h2 id="_idParaDest-333" class="heading-2">Introducing the circuit breaker</h2>
    <p class="normal">Let’s quickly revisit the <a id="_idIndexMarker879"/>state diagram for a circuit breaker from <em class="chapterRef">Chapter 8</em>, <em class="italic">Introduction to Spring Cloud</em>, in the <em class="italic">Using Resilience4j for improved resilience</em> section:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_02.png" alt="Diagram  Description automatically generated" width="593" height="316"/></figure>
    <p class="packt_figref">Figure 13.2: Circuit breaker state diagram</p>
    <p class="normal">The key features of a circuit breaker are as follows:</p>
    <ul>
      <li class="bulletList">If a<a id="_idIndexMarker880"/> circuit breaker detects too many faults, it will open its circuit, that is, not allow new calls.</li>
      <li class="bulletList">When the circuit is open, a circuit breaker will perform fail-fast logic. This means that it doesn’t wait for a new fault, for example, a timeout, to happen on subsequent calls. Instead, it directly redirects the call to a <strong class="keyWord">fallback method</strong>. The fallback method can apply various business logic to <a id="_idIndexMarker881"/>produce a best-effort response. For example, a fallback method can return data from a local cache or simply return an immediate error message. This will prevent a microservice from becoming unresponsive if the services it depends on stop responding normally. This is specifically useful under high load.</li>
      <li class="bulletList">After a while, the circuit breaker will be half-open, allowing new calls to see whether the issue that caused the failures is gone. If new failures are detected by the circuit breaker, it will open the circuit again and go back to the fail-fast logic. Otherwise, it will close the circuit and go back to normal operation. This makes a microservice resilient to faults, or self-healing, a capability that is indispensable in a system<a id="_idIndexMarker882"/> landscape of microservices that communicate synchronously with each other.</li>
    </ul>
    <p class="normal">Resilience4j exposes information <a id="_idIndexMarker883"/>about circuit breakers at runtime in a number of ways:</p>
    <ul>
      <li class="bulletList">The current state of a circuit breaker can be monitored using the microservice’s <code class="inlineCode">actuator</code> <code class="inlineCode">health</code> endpoint, <code class="inlineCode">/actuator/health</code>.</li>
      <li class="bulletList">The circuit breaker also publishes events on an <code class="inlineCode">actuator</code> endpoint, for example, state transitions and <code class="inlineCode">/actuator/circuitbreakerevents</code>.</li>
      <li class="bulletList">Finally, circuit breakers are integrated with Spring Boot’s metrics system and can use it to publish metrics to monitoring tools such as Prometheus.</li>
    </ul>
    <p class="normal">We will try out the <code class="inlineCode">health</code> and <code class="inlineCode">event</code> endpoints in this chapter. In <em class="chapterRef">Chapter 20</em>, <em class="italic">Monitoring Microservices</em>, we will see Prometheus in action and how it can collect metrics that are exposed by Spring Boot, for example, metrics from our circuit breaker.</p>
    <p class="normal">To control the logic in a circuit breaker, Resilience4j can be configured using standard Spring Boot configuration files. We will use the following configuration parameters:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">slidingWindowType</code>: To<a id="_idIndexMarker884"/> determine if a circuit breaker needs to be opened, Resilience4j uses a sliding window, counting the most recent events to make the decision. The sliding windows can either be based on a fixed number of calls or a fixed elapsed time. This parameter is used to configure what type of sliding window is used. <p class="normal">We will use a count-based sliding window, setting this parameter to <code class="inlineCode">COUNT_BASED</code>.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><code class="inlineCode">slidingWindowSize</code>: The number of calls in a closed state, which are used to determine whether the circuit should be opened. <p class="normal">We will set this parameter to <code class="inlineCode">5</code>.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><code class="inlineCode">failureRateThreshold</code>: The threshold, in percent, for failed calls that will cause the circuit to be opened. <p class="normal">We will set this parameter to <code class="inlineCode">50%</code>. This setting, together with <code class="inlineCode">slidingWindowSize</code> set to <code class="inlineCode">5</code>, means that if three or more of the last five calls are faults, then the circuit will open.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><code class="inlineCode">automaticTransitionFromOpenToHalfOpenEnabled</code>: Determines whether the circuit breaker will automatically transition to the half-open state once the waiting period is over. Otherwise, it will wait for the first call after the waiting period is over until it transitions to the half-open state. <p class="normal">We will set this parameter to <code class="inlineCode">true</code>.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><code class="inlineCode">waitDurationInOpenState</code>: Specifies how long the circuit stays in an open state, that is, before it transitions to the half-open state. <p class="normal">We will set this parameter to <code class="inlineCode">10000 ms</code>. This setting, together with enabling the automatic transition to the half-open state, set by the previous parameter, means that the circuit breaker will keep the circuit open for 10 seconds and then transition to the half-open state.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><code class="inlineCode">permittedNumberOfCallsInHalfOpenState</code>: The number of calls in the half-open state, which are used to determine whether the circuit will be opened again or go back to the normal, closed state. <p class="normal">We will set this parameter to <code class="inlineCode">3</code>, meaning that the circuit breaker will decide whether the circuit will be opened or closed based on the first three calls after the circuit has transitioned to the half-open state. Since the <code class="inlineCode">failureRateThreshold</code> parameters are set to 50%, the circuit will be open again if two or all three calls fail. Otherwise, the circuit will be closed.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><code class="inlineCode">ignoreExceptions</code>: This can be used to specify exceptions that should not be counted as faults. Expected business exceptions such as <code class="inlineCode">not found</code> or <code class="inlineCode">invalid input</code> are typical exceptions that the circuit breaker should ignore; users who search for non-existing data or enter invalid input should not cause the circuit to open. <p class="normal">We will set this<a id="_idIndexMarker885"/> parameter to a list containing the exceptions <code class="inlineCode">NotFoundException</code> and <code class="inlineCode">InvalidInputException</code>.</p>
        <p class="normal">Finally, to configure Resilience4j to report the state of the circuit breaker in the <code class="inlineCode">actuator</code> <code class="inlineCode">health</code> endpoint in the correct way, the following parameters are set:</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><code class="inlineCode">registerHealthIndicator = true</code> enables Resilience4j to fill in the <code class="inlineCode">health</code> endpoint with information regarding the state of its circuit breakers.</li>
      <li class="bulletList"><code class="inlineCode">allowHealthIndicatorToFail = false</code> tells Resilience4j not to affect the status of the <code class="inlineCode">health </code>endpoint. This means that the <code class="inlineCode">health</code> endpoint will still report <code class="inlineCode">"UP"</code> even if one of the component’s circuit breakers is in an open or half-open state. It is very important that the health state of the component is not reported as <code class="inlineCode">"DOWN"</code> just because one of its circuit breakers is not in a closed state. This means that the component is still considered to be OK, even though one of the components it depends on is not.</li>
    </ul>
    <div class="note">
      <p class="normal">This is actually the core value of a circuit breaker, so setting this value to <code class="inlineCode">true</code> would more or less spoil the value of bringing in a circuit breaker. In earlier versions of Resilience4j, this was actually the behavior. In more recent versions, this has been corrected, and <code class="inlineCode">false</code> is actually the default value for this parameter. But since I consider it very important to understand the relation between the health state of the component and the state of its circuit breakers, I have added it to the configuration.</p>
    </div>
    <ul>
      <li class="bulletList">Finally, we must also configure Spring Boot Actuator to add the circuit breaker health information that Resilience4j produces in the response to a request to its <code class="inlineCode">health</code> endpoint:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">management.health.circuitbreakers.enabled:</span> <span class="hljs-literal">true</span>
</code></pre>
      </li>
    </ul>
    <p class="normal">For a full list of available configuration parameters, see <a href="https://resilience4j.readme.io/docs/circuitbreaker#create-and-configure-a-circuitbreaker"><span class="url">https://resilience4j.readme.io/docs/circuitbreaker#create-and-configure-a-circuitbreaker</span></a>.</p>
    <h2 id="_idParaDest-334" class="heading-2">Introducing the time limiter</h2>
    <p class="normal">To help a circuit <a id="_idIndexMarker886"/>breaker handle slow or unresponsive services, a timeout mechanism can be helpful. Resilience4j’s timeout mechanism, called a <strong class="keyWord">TimeLimiter</strong>, can be<a id="_idIndexMarker887"/> configured using standard Spring Boot configuration files. We will use the following configuration parameter:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">timeoutDuration</code>: Specifies how long a <code class="inlineCode">TimeLimiter</code> instance waits for a call to complete before it throws a timeout exception. We will set it to <code class="inlineCode">2s</code>.</li>
    </ul>
    <h2 id="_idParaDest-335" class="heading-2">Introducing the retry mechanism</h2>
    <p class="normal">The <strong class="keyWord">retry</strong> mechanism is <a id="_idIndexMarker888"/>very useful for random and infrequent faults, such as temporary network glitches. The retry mechanism can simply retry a failed request a number of times with a configurable delay between the attempts. One very important restriction on the use of the retry mechanism is that the services that it retries must be <strong class="keyWord">idempotent</strong>, that is, calling the service one or many times with the same request parameters gives the same result. For example, reading information is idempotent, but creating information is typically not. You don’t want a retry mechanism to accidentally create two orders just because the response from the first order’s creation got lost in the network.</p>
    <p class="normal">Resilience4j exposes retry information in the same way as it does for circuit breakers when it comes to events and metrics but does not provide any health information. Retry events are accessible on the <code class="inlineCode">actuator</code> endpoint, <code class="inlineCode">/actuator/retryevents</code>. To control the retry logic, Resilience4j can be configured using standard Spring Boot configuration files. We will use the following configuration <a id="_idIndexMarker889"/>parameters:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">maxAttempts</code>: The number of attempts before giving up, including the first call. We will set this parameter to <code class="inlineCode">3</code>, allowing a maximum of two retry attempts after an initial failed call.</li>
      <li class="bulletList"><code class="inlineCode">waitDuration</code>: The wait time before the next retry attempt. We will set this value to <code class="inlineCode">1000</code> ms, meaning that we will wait 1 second between retries.</li>
      <li class="bulletList"><code class="inlineCode">retryExceptions</code>: A list of exceptions that will trigger a retry. We will only trigger retries on <code class="inlineCode">InternalServerError</code> exceptions, that is, when HTTP requests respond with a <code class="inlineCode">500</code> status code.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">Be careful when configuring retry and circuit breaker settings so that, for example, the circuit breaker doesn’t open the circuit before the intended number of retries has been completed!</p>
    </div>
    <p class="normal">For a full list of available configuration parameters, see <a href="https://resilience4j.readme.io/docs/retry#create-and-configure-retry"><span class="url">https://resilience4j.readme.io/docs/retry#create-and-configure-retry</span></a>.</p>
    <p class="normal">With this introduction, we are ready to see how to add these resilience mechanisms to the source code in the <code class="inlineCode">product-composite</code> service.</p>
    <h1 id="_idParaDest-336" class="heading-1">Adding the resilience mechanisms to the source code</h1>
    <p class="normal">Before we add the<a id="_idIndexMarker890"/> resilience mechanisms to the source code, we will add code that makes it possible to force an error to occur, as a delay and/or as a random fault. Next, we will add a circuit breaker together with a time limiter to handle slow or unresponsive APIs, as well as a retry mechanism that can handle faults that happen randomly. Adding these features from Resilience4j follows the Spring Boot way, which we have been using in the previous chapters:</p>
    <ul>
      <li class="bulletList">Add a starter dependency on Resilience4j in the build file</li>
      <li class="bulletList">Add annotations in the source code where the resilience mechanisms will be applied</li>
      <li class="bulletList">Add a configuration that controls the behavior of the resilience mechanisms</li>
    </ul>
    <p class="normal">Handling resilience challenges is a responsibility of the integration layer; therefore, the resilience mechanisms will be placed in the <code class="inlineCode">ProductCompositeIntegration</code> class. The source code in the business logic, implemented in the <code class="inlineCode">ProductCompositeServiceImpl</code> class, will not be aware of the presence of the resilience mechanisms.</p>
    <p class="normal">Once we have the <a id="_idIndexMarker891"/>mechanisms in place, we will finally extend our test script, <code class="inlineCode">test-em-all.bash</code>, with tests that automatically verify that the circuit breaker works as expected when deployed in the system landscape.</p>
    <h2 id="_idParaDest-337" class="heading-2">Adding programmable delays and random errors</h2>
    <p class="normal">To be able to test our resilience mechanisms, we need a way to control when errors happen. A<a id="_idIndexMarker892"/> simple way to <a id="_idIndexMarker893"/>achieve this is by adding optional query parameters in the API used to retrieve a product and a composite product.</p>
    <div class="packt_tip">
      <p class="normal">The code and API parameters added in this section to force delays and errors to occur should only be used during development and tests, not in production. When we learn about the concept of a service mesh in <em class="chapterRef">Chapter 18</em>, <em class="italic">Using a Service Mesh to Improve Observability and Management</em>, we will learn about better methods that can be used in production to introduce delays and errors in a controlled way. Using a service mesh, we can introduce delays and errors, typically used for verifying resilience capabilities, without affecting the source code of the microservices.</p>
    </div>
    <p class="normal">The composite product API will simply pass on the parameters to the product API. The following query parameters have been added to the two APIs:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">delay</code>: Causes the <code class="inlineCode">getProduct</code> API on the <code class="inlineCode">product</code> microservice to delay its response. The parameter is specified in seconds. For example, if the parameter is set to <code class="inlineCode">3</code>, it will cause a delay of three seconds before the response is returned.</li>
      <li class="bulletList"><code class="inlineCode">faultPercentage</code>: Causes the <code class="inlineCode">getProduct</code> API on the <code class="inlineCode">product</code> microservice to throw an exception randomly with the probability specified by the query parameter, from 0 to 100%. For example, if the parameter<a id="_idIndexMarker894"/> is set to <code class="inlineCode">25</code>, it will cause every fourth call to the API, on average, to <a id="_idIndexMarker895"/>fail with an exception. It will return an <code class="inlineCode">HTTP error 500 (Internal Server Error)</code> in these cases.</li>
    </ul>
    <h3 id="_idParaDest-338" class="heading-3">Changes in the API definitions</h3>
    <p class="normal">The two query <a id="_idIndexMarker896"/>parameters that we introduced above, <code class="inlineCode">delay</code> and <code class="inlineCode">faultPercentage</code>, have been defined in the <code class="inlineCode">api</code> project in the following two Java interfaces:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductCompositeService</code>:
        <pre class="programlisting code"><code class="hljs-code">Mono&lt;ProductAggregate&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span>
<span class="hljs-params">    </span><span class="hljs-meta">@PathVariable</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> productId,</span>
<span class="hljs-params">    </span><span class="hljs-meta">@RequestParam(value = "delay", required = false, defaultValue =</span>
<span class="hljs-meta">    "0")</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> delay,</span>
<span class="hljs-params">    </span><span class="hljs-meta">@RequestParam(value = "faultPercent", required = false, </span>
<span class="hljs-meta">    defaultValue = "0")</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent</span>
<span class="hljs-params">)</span>;
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">ProductService</code>:
        <pre class="programlisting code"><code class="hljs-code">Mono&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span>
<span class="hljs-params">     </span><span class="hljs-meta">@PathVariable</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> productId,</span>
<span class="hljs-params">     </span><span class="hljs-meta">@RequestParam(value = "delay", required = false, defaultValue</span>
<span class="hljs-meta">     = "0")</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> delay,</span>
<span class="hljs-params">     </span><span class="hljs-meta">@RequestParam(value = "faultPercent", required = false, </span>
<span class="hljs-meta">     defaultValue = "0")</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent</span>
<span class="hljs-params">)</span>;
</code></pre>
      </li>
    </ul>
    <p class="normal">The query parameters are declared optional with default values that disable the use of the error mechanisms. This means that if none of the query parameters are used in a request, neither a delay will be applied nor an error will be thrown.</p>
    <h3 id="_idParaDest-339" class="heading-3">Changes in the product-composite microservice</h3>
    <p class="normal">The <code class="inlineCode">product-composite</code> microservice<a id="_idIndexMarker897"/> simply passes the parameters to the product API. The service implementation receives the API request and passes on the parameters to the integration component that makes the call to the product API:</p>
    <ul>
      <li class="bulletList">The call from the <code class="inlineCode">ProductCompositeServiceImpl</code> class to the integration component looks like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> Mono&lt;ProductAggregate&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId,</span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent)</span> {
    <span class="hljs-keyword">return</span> Mono.zip(
        ...
        integration.getProduct(productId, delay, faultPercent),
        ....
</code></pre>
      </li>
      <li class="bulletList">The call from the <code class="inlineCode">ProductCompositeIntegration</code> class to the product API looks like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> Mono&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId, </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent)</span> {
  
    <span class="hljs-type">URI</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> UriComponentsBuilder.fromUriString(
      PRODUCT_SERVICE_URL + <span class="hljs-string">"/product/{productId}?delay={delay}"</span> 
      + <span class="hljs-string">"&amp;faultPercent={faultPercent}"</span>)
      .build(productId, delay, faultPercent);
  <span class="hljs-keyword">return</span> webClient.get().uri(url).retrieve()...
</code></pre>
      </li>
    </ul>
    <h3 id="_idParaDest-340" class="heading-3">Changes in the product microservice</h3>
    <p class="normal">The <code class="inlineCode">product</code> microservice implements the actual delay and random error generator<a id="_idIndexMarker898"/> in the <code class="inlineCode">ProductServiceImpl</code> class by extending the existing stream used to read product information from the MongoDB database. It looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> Mono&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId, </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent)</span> {
  ...
  <span class="hljs-keyword">return</span> repository.findByProductId(productId)
    .map(e -&gt; throwErrorIfBadLuck(e, faultPercent))
    .delayElement(Duration.ofSeconds(delay))
    ...
}
</code></pre>
    <p class="normal">When the stream returns a response from the Spring Data repository, it first applies the <code class="inlineCode">throwErrorIfBadLuck</code> method to see whether an exception needs to be thrown. Next, it applies a delay using the <code class="inlineCode">delayElement</code> function in the <code class="inlineCode">Mono</code> class.</p>
    <p class="normal">The random<a id="_idIndexMarker899"/> error generator, <code class="inlineCode">throwErrorIfBadLuck()</code>, creates a random number between <code class="inlineCode">1</code> and <code class="inlineCode">100</code> and throws an exception if it is higher than, or equal to, the specified fault percentage. If no exception is thrown, the product entity is passed on in the stream. The source code looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> ProductEntity <span class="hljs-title">throwErrorIfBadLuck</span><span class="hljs-params">(</span>
<span class="hljs-params">  ProductEntity entity, </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent)</span> {
  <span class="hljs-keyword">if</span> (faultPercent == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> entity;
  }
  <span class="hljs-type">int</span> <span class="hljs-variable">randomThreshold</span> <span class="hljs-operator">=</span> getRandomNumber(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);
  <span class="hljs-keyword">if</span> (faultPercent &lt; randomThreshold) {
    LOG.debug(<span class="hljs-string">"We got lucky, no error occurred, {} &lt; {}"</span>, 
      faultPercent, randomThreshold);
  
  } <span class="hljs-keyword">else</span> {
    LOG.info(<span class="hljs-string">"Bad luck, an error occurred, {} &gt;= {}"</span>,
      faultPercent, randomThreshold);
  
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(<span class="hljs-string">"</span><span class="hljs-string">Something went wrong..."</span>);
  }
  <span class="hljs-keyword">return</span> entity;
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">randomNumberGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>();
<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title">getRandomNumber</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> min, </span><span class="hljs-type">int</span><span class="hljs-params"> max)</span> {
  <span class="hljs-keyword">if</span> (max &lt; min) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(<span class="hljs-string">"Max must be greater than min"</span>);
  }
  <span class="hljs-keyword">return</span> randomNumberGenerator.nextInt((max - min) + <span class="hljs-number">1</span>) + min;
}
</code></pre>
    <p class="normal">With the <a id="_idIndexMarker900"/>programmable delays and random error functions in place, we are ready to start adding resilience mechanisms to the code. We will start with the circuit breaker and the time limiter.</p>
    <h2 id="_idParaDest-341" class="heading-2">Adding a circuit breaker and a time limiter</h2>
    <p class="normal">As we mentioned <a id="_idIndexMarker901"/>previously, we need to add dependencies, annotations, and <a id="_idIndexMarker902"/>configuration. We also need to add some code for implementing fallback logic for fail-fast scenarios. We will see how to do this in the following sections.</p>
    <h3 id="_idParaDest-342" class="heading-3">Adding dependencies to the build file</h3>
    <p class="normal">To add a circuit breaker<a id="_idIndexMarker903"/> and a time limiter, we have to add dependencies to the appropriate Resilience4j libraries in the build file, <code class="inlineCode">build.gradle</code>. </p>
    <p class="normal">From the product documentation (<a href="https://resilience4j.readme.io/docs/getting-started-3#setup"><span class="url">https://resilience4j.readme.io/docs/getting-started-3#setup</span></a>), we can learn that the following three dependencies need to be added. We will use the latest available version (<code class="inlineCode">v2.0.2</code>, when this chapter was written):</p>
    <pre class="programlisting code"><code class="hljs-code">ext {
   resilience4jVersion = <span class="hljs-string">"2.0.2"</span>
}
<span class="hljs-keyword">dependencies</span> {
    implementation <span class="hljs-string">"io.github.resilience4j:resilience4j-spring-</span>
<span class="hljs-string">boot2:${resilience4jVersion}"</span>
    implementation <span class="hljs-string">"io.github.resilience4j:resilience4j-reactor:${resilience4jVersion}"</span>
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-aop'</span>
    ...
</code></pre>
    <p class="normal">To avoid Spring Cloud overriding the version used with the older version of Resilience4j that it bundles, we also import a <code class="inlineCode">resilience4j-bom </code>(Bill Of Material) file, as described in the Spring Boot 3 demo project <a href="https://github.com/resilience4j/resilience4j-spring-boot3-demo"><span class="url">https://github.com/resilience4j/resilience4j-spring-boot3-demo</span></a>. We add this <code class="inlineCode">bom</code> file to the <a id="_idIndexMarker904"/>existing <code class="inlineCode">bom</code> file for Spring Cloud in the <code class="inlineCode">dependencyManagement</code> section:</p>
    <pre class="programlisting code"><code class="hljs-code">dependencyManagement {
    imports {
        mavenBom <span class="hljs-string">"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"</span>
        mavenBom <span class="hljs-string">"io.github.resilience4j:resilience4j-bom:${resilience4jVersion}"</span>
    }
}
</code></pre>
    <h3 id="_idParaDest-343" class="heading-3">Adding annotations in the source code</h3>
    <p class="normal">The circuit breaker can <a id="_idIndexMarker905"/>be applied by annotating the method it is expected to protect with <code class="inlineCode">@CircuitBreaker(...)</code>, which, in this case, is the <code class="inlineCode">getProduct()</code> method in the <code class="inlineCode">ProductCompositeIntegration</code> class. The circuit breaker is triggered by an exception, not by a timeout itself. To be able to trigger the circuit breaker after a timeout, we will add a time limiter that can be applied with the annotation <code class="inlineCode">@TimeLimiter(...)</code>. The source code looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@TimeLimiter(name = "product")</span>
<span class="hljs-meta">@CircuitBreaker(</span>
<span class="hljs-meta">     name = "product", fallbackMethod = "getProductFallbackValue")</span>
<span class="hljs-keyword">public</span> Mono&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> productId, </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent)</span> {
  ...
}
</code></pre>
    <p class="normal">The <code class="inlineCode">name</code> of the circuit breaker and the time limiter annotation, <code class="inlineCode">"product"</code>, is used to identify the configuration that will be applied. The <code class="inlineCode">fallbackMethod</code> parameter in the circuit breaker annotation is used to specify what fallback method to call (<code class="inlineCode">getProductFallbackValue</code>, in this case) when the circuit breaker is open; see below for information on how it is used.</p>
    <p class="normal">To activate the circuit breaker, the annotated method must be invoked as a Spring bean. In our case, it’s the integration class that’s injected by Spring into the service implementation class, <code class="inlineCode">ProductCompositeServiceImpl</code>, and therefore used as a Spring bean:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ProductCompositeIntegration integration;
<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">ProductCompositeServiceImpl</span><span class="hljs-params">(... ProductCompositeIntegration integration)</span> {
  <span class="hljs-built_in">this</span>.integration = integration;
}
<span class="hljs-keyword">public</span> Mono&lt;ProductAggregate&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId, </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent)</span> {
  <span class="hljs-keyword">return</span> Mono.zip(
    ..., 
    integration.getProduct(productId, delay, faultPercent), 
    ...
</code></pre>
    <h3 id="_idParaDest-344" class="heading-3">Adding fail-fast fallback logic</h3>
    <p class="normal">To be able to apply<a id="_idIndexMarker906"/> fallback logic when the circuit breaker is<a id="_idIndexMarker907"/> open, that is, when a request fails fast, we can specify a fallback method on the <code class="inlineCode">CircuitBreaker</code> annotation, as seen in the previous source code. The method must follow the signature of the method the circuit breaker is applied for and also have an extra last argument used for passing the exception that triggered the circuit breaker. In our case, the method signature for the fallback method looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> Mono&lt;Product&gt; <span class="hljs-title">getProductFallbackValue</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId, </span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent, CallNotPermittedException ex)</span> {
</code></pre>
    <p class="normal">The last parameter specifies that we want to be able to handle exceptions of type <code class="inlineCode">CallNotPermittedException</code>. We are only interested in exceptions that are thrown when the circuit breaker is in its open state so that we can apply fail-fast logic. When the circuit breaker is open, it will not permit calls to the underlying method; instead, it will immediately throw a <code class="inlineCode">CallNotPermittedException</code> exception. Therefore, we are only interested in catching <code class="inlineCode">CallNotPermittedException</code> exceptions.</p>
    <p class="normal">The fallback logic can look up information based on the <code class="inlineCode">productId</code> from alternative sources, for example, an internal cache. In our case, we will return hardcoded values based on the <code class="inlineCode">productId</code>, to simulate a hit in a cache. To simulate a miss in the cache, we will throw a <code class="inlineCode">not found</code> exception in the case where the <code class="inlineCode">productId</code> is <code class="inlineCode">13</code>. </p>
    <p class="normal">The implementation of the fallback method looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> Mono&lt;Product&gt; <span class="hljs-title">getProductFallbackValue</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId, </span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent, CallNotPermittedException ex)</span> {
  <span class="hljs-keyword">if</span> (productId == <span class="hljs-number">13</span>) {
    <span class="hljs-type">String</span> <span class="hljs-variable">errMsg</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Product Id: "</span> + productId 
      + <span class="hljs-string">" not found in fallback cache!"</span>;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">NotFoundException</span>(errMsg);
  }
  <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> <span class="hljs-title">Product</span>(productId, <span class="hljs-string">"Fallback product"</span> 
    + productId, productId, serviceUtil.getServiceAddress()));
}
</code></pre>
    <h3 id="_idParaDest-345" class="heading-3">Adding configuration</h3>
    <p class="normal">Finally, the configuration of <a id="_idIndexMarker908"/>the circuit breaker and time limiter is added to the <code class="inlineCode">product-composite.yml</code> file in the config repository, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">resilience4j.timelimiter:</span>
  <span class="hljs-attr">instances:</span>
    <span class="hljs-attr">product:</span>
      <span class="hljs-attr">timeoutDuration:</span> <span class="hljs-string">2s</span>
<span class="hljs-attr">management.health.circuitbreakers.enabled:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">resilience4j.circuitbreaker:</span>
  <span class="hljs-attr">instances:</span>
    <span class="hljs-attr">product:</span>
      <span class="hljs-attr">allowHealthIndicatorToFail:</span> <span class="hljs-literal">false</span>
      <span class="hljs-attr">registerHealthIndicator:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">slidingWindowType:</span> <span class="hljs-string">COUNT_BASED</span>
      <span class="hljs-attr">slidingWindowSize:</span> <span class="hljs-number">5</span>
      <span class="hljs-attr">failureRateThreshold:</span> <span class="hljs-number">50</span>
      <span class="hljs-attr">waitDurationInOpenState:</span> <span class="hljs-number">10000</span>
      <span class="hljs-attr">permittedNumberOfCallsInHalfOpenState:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">automaticTransitionFromOpenToHalfOpenEnabled:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">ignoreExceptions:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">se.magnus.api.exceptions.InvalidInputException</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">se.magnus.api.exceptions.NotFoundException</span>
</code></pre>
    <p class="normal">The values in the configuration have already been described in the previous sections, <em class="italic">Introducing the circuit breaker</em> and <em class="italic">Introducing the time limiter</em>.</p>
    <h2 id="_idParaDest-346" class="heading-2">Adding a retry mechanism</h2>
    <p class="normal">In the same way as for the<a id="_idIndexMarker909"/> circuit breaker, a retry mechanism is set up by adding dependencies, annotations, and configuration. The dependencies were added previously in the <em class="italic">Adding dependencies to the build file</em> section, so we only need to add the annotation and set up the configuration.</p>
    <h3 id="_idParaDest-347" class="heading-3">Adding the retry annotation</h3>
    <p class="normal">The retry mechanism can be applied to <a id="_idIndexMarker910"/>a method by annotating it with <code class="inlineCode">@Retry(name="nnn")</code>, where <code class="inlineCode">nnn</code> is the name of the configuration entry to be used for this method. See the following <em class="italic">Adding configuration</em> section for details on the configuration. The method, in our case, is the same as it is for the circuit breaker and time limiter, <code class="inlineCode">getProduct()</code> in the <code class="inlineCode">ProductCompositeIntegration</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-meta">@Retry(name = "product")</span>
  <span class="hljs-meta">@TimeLimiter(name = "product")</span>
  <span class="hljs-meta">@CircuitBreaker(name = "product", fallbackMethod =</span>
<span class="hljs-meta">    "getProductFallbackValue")</span>
  <span class="hljs-keyword">public</span> Mono&lt;Product&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId, </span><span class="hljs-type">int</span><span class="hljs-params"> delay, </span>
<span class="hljs-params">    </span><span class="hljs-type">int</span><span class="hljs-params"> faultPercent)</span> {
</code></pre>
    <h3 id="_idParaDest-348" class="heading-3">Adding configuration</h3>
    <p class="normal">Configuration for the retry <a id="_idIndexMarker911"/>mechanism is added in the same way as for the circuit breaker and time limiter in the <code class="inlineCode">product-composite.yml</code> file in the config repository, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">resilience4j.retry:</span>
  <span class="hljs-attr">instances:</span>
    <span class="hljs-attr">product:</span>
      <span class="hljs-attr">maxAttempts:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">waitDuration:</span> <span class="hljs-number">1000</span>
      <span class="hljs-attr">retryExceptions:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">org.springframework.web.reactive.function.client.WebClientResponseException$InternalServerError</span>
</code></pre>
    <p class="normal">The actual values were discussed in the <em class="italic">Introducing the retry mechanism</em> section above.</p>
    <div class="packt_tip">
      <p class="normal">While using multiple mechanisms of Resilience4j (in our case, the circuit breaker, time limiter, and retry mechanism), understanding the order of how these aspects are applied is of importance. For information, see <a href="https://resilience4j.readme.io/docs/getting-started-3#aspect-order"><span class="url">https://resilience4j.readme.io/docs/getting-started-3#aspect-order</span></a>.</p>
    </div>
    <p class="normal">That is all the<a id="_idIndexMarker912"/> dependencies, annotations, source code, and configuration required. Let’s wrap up by extending the test script with tests that verify that the circuit breaker works as expected in a deployed system landscape.</p>
    <h2 id="_idParaDest-349" class="heading-2">Adding automated tests</h2>
    <p class="normal">Automated tests for the <a id="_idIndexMarker913"/>circuit breaker have been added to the <code class="inlineCode">test-em-all.bash</code> test script in a separate function, <code class="inlineCode">testCircuitBreaker()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">...
<span class="hljs-keyword">function</span> <span class="hljs-title">testCircuitBreaker</span>() {
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Start Circuit Breaker tests!"</span>
    ...
}
...
testCircuitBreaker
...
<span class="hljs-built_in">echo</span> <span class="hljs-string">"End, all tests OK:"</span> `<span class="hljs-built_in">date</span>`
</code></pre>
    <p class="normal">To be able to perform some of the required verifications, we need to have access to the <code class="inlineCode">actuator</code> endpoints of the <code class="inlineCode">product-composite</code> microservice, which are not exposed through the edge server. Therefore, we will access the <code class="inlineCode">actuator</code> endpoints by running a command in the <code class="inlineCode">product-composite</code> microservice using the Docker Compose <code class="inlineCode">exec</code> command. The base image used by the microservices, <code class="inlineCode">Eclipse Temurin</code>, bundles <code class="inlineCode">curl</code>, so we can simply run a <code class="inlineCode">curl</code> command in the <code class="inlineCode">product-composite</code> container to get the information required. The command looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec -T product-composite curl -s http://product-composite:8080/actuator/health
</code></pre>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">-T</code> argument is used to disable the use of a terminal for the <code class="inlineCode">exec</code> command. This is important to make it possible to run the <code class="inlineCode">test-em-all.bash</code> test script in an environment where no terminals exist, for example, in an automated build pipeline used for CI/CD.</p>
    </div>
    <p class="normal">To be able to extract the information we need for our tests, we can pipe the output to the <code class="inlineCode">jq</code> tool. For example, to extract the actual state of the circuit breaker, we can run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec -T product-composite curl -s http://product-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state
</code></pre>
    <p class="normal">It will return either <code class="inlineCode">CLOSED</code>, <code class="inlineCode">OPEN</code>, or <code class="inlineCode">HALF_OPEN</code>, depending on the actual state.</p>
    <p class="normal">The test starts by doing exactly this, that is, verifying that the circuit breaker is closed before the tests are executed:</p>
    <pre class="programlisting code"><code class="hljs-code">assertEqual <span class="hljs-string">"CLOSED"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(docker-compose exec -T product-composite curl -s </span><span class="url">http://product</span><span class="hljs-subst">-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state)</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">Next, the test will force<a id="_idIndexMarker914"/> the circuit breaker to open up by running three commands in a row, all of which will fail on a timeout caused by a slow response from the <code class="inlineCode">product</code> service (the <code class="inlineCode">delay</code> parameter is set to <code class="inlineCode">3</code> seconds):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> ((n=<span class="hljs-number">0</span>; n&lt;<span class="hljs-number">3</span>; n++))
<span class="hljs-keyword">do</span>
    assertCurl 500 <span class="hljs-string">"curl -k </span><span class="url">https://$HOST:$PORT</span><span class="hljs-string">/product-composite/</span><span class="hljs-variable">$PROD_ID_REVS_RECS</span><span class="hljs-string">?delay=3 </span><span class="hljs-variable">$AUTH</span><span class="hljs-string"> -s"</span>
    message=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$RESPONSE</span> | jq -r .message)
    assertEqual <span class="hljs-string">"Did not observe any item or terminal signal within 2000ms"</span> <span class="hljs-string">"</span><span class="hljs-variable">${message:0:57}</span><span class="hljs-string">"</span>
<span class="hljs-keyword">done</span>
</code></pre>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">A quick reminder of the configuration</strong>: The timeout of the <code class="inlineCode">product</code> service is set to two seconds so that a delay of three seconds will cause a timeout. The circuit breaker is configured to evaluate the last five calls when closed. The tests in the script that precede the circuit breaker-specific tests have already performed a couple of successful calls. The failure threshold is set to 50%; three calls with a three-second delay are enough to open the circuit. </p>
    </div>
    <p class="normal">With the circuit <a id="_idIndexMarker915"/>open, we expect a fail-fast behavior, that is, we won’t need to wait for the timeout before we get a response. We also expect the <code class="inlineCode">fallback</code> method to be called to return a best-effort response. This should also apply to a normal call, that is, without requesting a delay. This is verified with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">assertEqual <span class="hljs-string">"OPEN"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(docker-compose exec -T product-composite curl -s </span><span class="url">http://product</span><span class="hljs-subst">-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state)</span><span class="hljs-string">"</span>
assertCurl 200 <span class="hljs-string">"curl -k </span><span class="url">https://$</span><span class="hljs-variable">HOST</span><span class="hljs-string">:</span><span class="hljs-variable">$PORT</span><span class="hljs-string">/product-composite/</span><span class="hljs-variable">$PROD_ID_REVS_RECS</span><span class="hljs-string">?delay=3 </span><span class="hljs-variable">$AUTH</span><span class="hljs-string"> -s"</span>
assertEqual <span class="hljs-string">"Fallback product</span><span class="hljs-variable">$PROD_ID_REVS_RECS</span><span class="hljs-string">"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(echo </span><span class="hljs-string">"</span><span class="hljs-variable">$RESPONSE</span><span class="hljs-string">"</span><span class="hljs-subst"> | jq -r .name)</span><span class="hljs-string">"</span>
assertCurl 200 <span class="hljs-string">"curl -k </span><span class="url">https://$</span><span class="hljs-variable">HOST</span><span class="hljs-string">:</span><span class="hljs-variable">$PORT</span><span class="hljs-string">/product-composite/</span><span class="hljs-variable">$PROD_ID_REVS_RECS</span><span class="hljs-string"> </span><span class="hljs-variable">$AUTH</span><span class="hljs-string"> -s"</span>
assertEqual <span class="hljs-string">"Fallback product</span><span class="hljs-variable">$PROD_ID_REVS_RECS</span><span class="hljs-string">"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(echo </span><span class="hljs-string">"</span><span class="hljs-variable">$RESPONSE</span><span class="hljs-string">"</span><span class="hljs-subst"> | jq -r .name)</span><span class="hljs-string">"</span>
</code></pre>
    <div class="packt_tip">
      <p class="normal">The product ID <code class="inlineCode">1</code> is stored in a variable, <code class="inlineCode">$PROD_ID_REVS_RECS</code>, to make it easier to modify the script if required.</p>
    </div>
    <p class="normal">We can also verify that the simulated <code class="inlineCode">not found</code> error logic works as expected in the fallback method, that is, the fallback method returns <code class="inlineCode">404, NOT_FOUND</code> for product ID <code class="inlineCode">13</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">assertCurl 404 <span class="hljs-string">"curl -k </span><span class="url">https://$</span><span class="hljs-variable">HOST</span><span class="hljs-string">:</span><span class="hljs-variable">$PORT</span><span class="hljs-string">/product-composite/</span><span class="hljs-variable">$PROD_ID_NOT_FOUND</span><span class="hljs-string"> </span><span class="hljs-variable">$AUTH</span><span class="hljs-string"> -s"</span>
assertEqual <span class="hljs-string">"Product Id: </span><span class="hljs-variable">$PROD_ID_NOT_FOUND</span><span class="hljs-string"> not found in fallback cache!"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(echo $RESPONSE | jq -r .message)</span><span class="hljs-string">"</span>
</code></pre>
    <div class="packt_tip">
      <p class="normal">The product ID <code class="inlineCode">13</code> is stored in a variable, <code class="inlineCode">$PROD_ID_NOT_FOUND</code>.</p>
    </div>
    <p class="normal">As configured, the circuit breaker will change its state to half-open after <code class="inlineCode">10</code> seconds. To be able to verify that, the test waits for <code class="inlineCode">10</code> seconds:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">echo</span> <span class="hljs-string">"Will sleep for 10 sec waiting for the CB to go Half Open..."</span>
<span class="hljs-built_in">sleep</span> 10
</code></pre>
    <p class="normal">After verifying the <a id="_idIndexMarker916"/>expected state (half-open), the test runs three normal requests to make the circuit breaker go back to its normal state, which is also verified:</p>
    <pre class="programlisting code"><code class="hljs-code">assertEqual <span class="hljs-string">"HALF_OPEN"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(docker-compose exec -T product-composite curl -s </span><span class="url">http://product</span><span class="hljs-subst">-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state)</span><span class="hljs-string">"</span>
<span class="hljs-keyword">for</span> ((n=<span class="hljs-number">0</span>; n&lt;<span class="hljs-number">3</span>; n++))
<span class="hljs-keyword">do</span>
    assertCurl 200 <span class="hljs-string">"curl -k </span><span class="url">https://$</span><span class="hljs-variable">HOST</span><span class="hljs-string">:</span><span class="hljs-variable">$PORT</span><span class="hljs-string">/product-composite/</span><span class="hljs-variable">$PROD_ID_REVS_RECS</span><span class="hljs-string"> </span><span class="hljs-variable">$AUTH</span><span class="hljs-string"> -s"</span>
    assertEqual <span class="hljs-string">"product name C"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(echo </span><span class="hljs-string">"</span><span class="hljs-variable">$RESPONSE</span><span class="hljs-string">"</span><span class="hljs-subst"> | jq -r .name)</span><span class="hljs-string">"</span>
<span class="hljs-keyword">done</span>
assertEqual <span class="hljs-string">"CLOSED"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(docker-compose exec -T product-composite curl -s </span><span class="url">http://product</span><span class="hljs-subst">-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state)</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">The test code also verifies that it got a response with data from the underlying database. It does that by comparing the returned product name with the value stored in the database. For the product with product ID <code class="inlineCode">1</code>, the name is <code class="inlineCode">"product name C"</code>.</p>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">A quick reminder of the configuration</strong>: The circuit breaker is configured to evaluate the first three calls when in the half-open state. Therefore, we need to run three requests where more than 50% are successful before the circuit is closed.</p>
    </div>
    <p class="normal">The test wraps up by using the <code class="inlineCode">/actuator/circuitbreakerevents</code> actuator API, which is exposed by the circuit breaker to reveal internal events. It is used to find out what state transitions the circuit breaker has performed. We expect the last three state transitions to be as follows:</p>
    <ul>
      <li class="bulletList">First state transition: Closed to open</li>
      <li class="bulletList">Next state transition: Open to half-open</li>
      <li class="bulletList">Last state transition: Half-open to closed</li>
    </ul>
    <p class="normal">This is verified by the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">assertEqual <span class="hljs-string">"CLOSED_TO_OPEN"</span>      <span class="hljs-string">"</span><span class="hljs-subst">$(docker-compose exec -T product-composite curl -s </span><span class="url">http://product</span><span class="hljs-subst">-composite:8080/actuator/circuitbreakerevents/product/STATE_TRANSITION | jq -r</span>
<span class="hljs-subst">.circuitBreakerEvents[-3].stateTransition)</span><span class="hljs-string">"</span>
assertEqual <span class="hljs-string">"OPEN_TO_HALF_OPEN"</span>   <span class="hljs-string">"</span><span class="hljs-subst">$(docker-compose exec -T product-composite curl -s </span><span class="url">http://product</span><span class="hljs-subst">-composite:8080/actuator/circuitbreakerevents/product/STATE_TRANSITION | jq -r .circuitBreakerEvents[-2].stateTransition)</span><span class="hljs-string">"</span>
assertEqual <span class="hljs-string">"HALF_OPEN_TO_CLOSED"</span> <span class="hljs-string">"</span><span class="hljs-subst">$(docker-compose exec -T product-composite curl -s </span><span class="url">http://product</span><span class="hljs-subst">-composite:8080/actuator/circuitbreakerevents/product/STATE_TRANSITION | jq -r .circuitBreakerEvents[-1].stateTransition)</span><span class="hljs-string">"</span>
</code></pre>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">jq</code> expression, <code class="inlineCode">circuitBreakerEvents[-1]</code>, means the last entry in the array of circuit breaker events, <code class="inlineCode">[-2]</code> is the second to last event, while <code class="inlineCode">[-3]</code> is the third to last event. Together, they are the three latest events, the ones we are interested in.</p>
    </div>
    <p class="normal">We added quite <a id="_idIndexMarker917"/>a lot of steps to the test script, but with this, we can automatically verify that the expected basic behavior of our circuit breaker is in place. In the next section, we will try it out. We will run tests both automatically by running the test script and manually by running the commands in the test script by hand.</p>
    <h1 id="_idParaDest-350" class="heading-1">Trying out the circuit breaker and retry mechanism</h1>
    <p class="normal">Now, it’s<a id="_idIndexMarker918"/> time to try<a id="_idIndexMarker919"/> out the circuit breaker and retry mechanism. We will start, as usual, by building the Docker images and running the test script, <code class="inlineCode">test-em-all.bash</code>. After that, we will manually run through the tests we described previously to ensure that we understand what’s going on! We will perform the following manual tests:</p>
    <ul>
      <li class="bulletList">Happy days tests of the circuit breaker, to verify that the circuit is closed under normal operations</li>
      <li class="bulletList">Negative tests of the circuit breaker, to verify that the circuit opens up when things start to go wrong</li>
      <li class="bulletList">Going back to normal operation, to verify that the circuit goes back to its closed state once the problems are resolved</li>
      <li class="bulletList">Trying out <a id="_idIndexMarker920"/>the<a id="_idIndexMarker921"/> retry mechanism with random errors</li>
    </ul>
    <h2 id="_idParaDest-351" class="heading-2">Building and running the automated tests</h2>
    <p class="normal">To build and run the automated tests, we need to <a id="_idIndexMarker922"/>do the<a id="_idIndexMarker923"/> following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, build the Docker images with the following commands:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter13
./gradlew build &amp;&amp; docker-compose build
</code></pre>
      </li>
      <li class="numberedList">Next, start the system landscape in Docker and run the usual tests with the following command:
        <pre class="programlisting con"><code class="hljs-con">./test-em-all.bash start
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">When the test script prints out <strong class="keyWord">Start Circuit Breaker tests!</strong>, the tests we described previously have been executed!</p>
    </div>
    <h2 id="_idParaDest-352" class="heading-2">Verifying that the circuit is closed under normal operations</h2>
    <p class="normal">Before we can call <a id="_idIndexMarker924"/>the API, we need an access token. Run the following commands to acquire an access token:</p>
    <pre class="programlisting con"><code class="hljs-con">unset ACCESS_TOKEN
ACCESS_TOKEN=$(curl -k https://writer:secret-writer@localhost:8443/oauth2/token -d grant_type=client_credentials -d scope="product:read product:write" -s | jq -r .access_token)
echo $ACCESS_TOKEN
</code></pre>
    <div class="packt_tip">
      <p class="normal">An access token issued by the authorization server is valid for 1 hour. So, if you start to get <code class="inlineCode">401 – Unauthorized</code> errors after a while, it is probably time to acquire a new access token.</p>
    </div>
    <p class="normal">Try a normal request and verify that it returns the HTTP response code <code class="inlineCode">200</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">curl -H "Authorization: Bearer $ACCESS_TOKEN" -k https://localhost:8443/product-composite/1 -w "%{http_code}\n" -o /dev/null -s
</code></pre>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">-w "%{http_code}\n"</code> switch is used to print the HTTP return status. As long as the command returns <code class="inlineCode">200</code>, we are not interested in the response body, so we suppress it with the switch <code class="inlineCode">-o /dev/null</code>.</p>
    </div>
    <p class="normal">Verify that the<a id="_idIndexMarker925"/> circuit breaker is closed using the <code class="inlineCode">health</code> API:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec product-composite curl -s http://product-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state
</code></pre>
    <p class="normal">We expect it to respond with <code class="inlineCode">CLOSED</code>.</p>
    <h2 id="_idParaDest-353" class="heading-2">Forcing the circuit breaker to open when things go wrong</h2>
    <p class="normal">Now, it’s <a id="_idIndexMarker926"/>time to make things go wrong! By that, I mean it’s time to try out some negative tests to verify that the circuit opens up when things start to go wrong. Call the API three times and direct the <code class="inlineCode">product</code> service to cause a timeout on every call, that is, delay the response by <code class="inlineCode">3</code> seconds. This should be enough to trip the circuit breaker:</p>
    <pre class="programlisting con"><code class="hljs-con">curl -H "Authorization: Bearer $ACCESS_TOKEN" -k https://localhost:8443/product-composite/1?delay=3 -s | jq .
</code></pre>
    <p class="normal">We expect a response such as the following each time:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_03.png" alt="Text  Description automatically generated" width="676" height="259"/></figure>
    <p class="packt_figref">Figure 13.3: Response after a timeout</p>
    <p class="normal">The circuit breaker <a id="_idIndexMarker927"/>is now open, so if you make a fourth attempt (within <code class="inlineCode">waitInterval</code>, that is, <code class="inlineCode">10</code> seconds), you will see fail-fast behavior and the <code class="inlineCode">fallback</code> method in action. You will get a response back immediately instead of an error message once the time limiter kicks in after <code class="inlineCode">2</code> seconds:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_04.png" alt="Graphical user interface, text  Description automatically generated" width="376" height="137"/></figure>
    <p class="packt_figref">Figure 13.4: Response when the circuit breaker is open</p>
    <p class="normal">The response will <a id="_idIndexMarker928"/>come from the fallback method. This can be recognized by looking at the value in the name field, <code class="inlineCode">Fallback product1</code>.</p>
    <div class="packt_tip">
      <p class="normal">Fail-fast and fallback methods are key capabilities of a circuit breaker. A configuration with a wait time set to only 10 seconds in the open state requires you to be rather quick to be able to see fail-fast logic and fallback methods in action! Once in a half-open state, you can always submit three new requests that cause a timeout, forcing the circuit breaker back to the open state, and then quickly try the fourth request. Then, you should get a fail-fast response from the fallback method. You can also increase the wait time to a minute or two, but it can be rather boring to wait that amount of time before the circuit switches to the half-open state.</p>
    </div>
    <p class="normal">Wait 10 seconds for the circuit breaker to transition to half-open, and then run the following command to verify that the circuit is now in a half-open state:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec product-composite curl -s http://product-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state
</code></pre>
    <p class="normal">Expect it to respond with <code class="inlineCode">HALF_OPEN</code>.</p>
    <h2 id="_idParaDest-354" class="heading-2">Closing the circuit breaker again</h2>
    <p class="normal">Once the circuit breaker<a id="_idIndexMarker929"/> is in a half-open state, it waits for three calls to see whether it should open the circuit again or go back to normal by closing it.</p>
    <p class="normal">Let’s submit three normal requests to close the circuit breaker:</p>
    <pre class="programlisting con"><code class="hljs-con">curl -H "Authorization: Bearer $ACCESS_TOKEN" -k https://localhost:8443/product-composite/1 -w "%{http_code}\n" -o /dev/null -s
</code></pre>
    <p class="normal">They should all respond with <code class="inlineCode">200</code>. Verify that the circuit is closed again by using the <code class="inlineCode">health</code> API:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec product-composite curl -s http://product-composite:8080/actuator/health | jq -r .components.circuitBreakers.details.product.details.state
</code></pre>
    <p class="normal">We expect it to respond with <code class="inlineCode">CLOSED</code>.</p>
    <p class="normal">Wrap this up by listing the last three state transitions using the following command: </p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec product-composite curl -s http://product-composite:8080/actuator/circuitbreakerevents/product/STATE_TRANSITION | jq -r '.circuitBreakerEvents[-3].stateTransition, .circuitBreakerEvents[-2].stateTransition, .circuitBreakerEvents[-1].stateTransition'
</code></pre>
    <p class="normal">Expect it to respond with the following:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_05.png" alt="Text  Description automatically generated" width="270" height="144"/></figure>
    <p class="packt_figref">Figure 13.5: Circuit breaker state changes</p>
    <p class="normal">This response tells <a id="_idIndexMarker930"/>us that we have taken our circuit breaker through a full lap of its state diagram:</p>
    <ul>
      <li class="bulletList">From closed to open when the timeout errors start to prevent requests from succeeding</li>
      <li class="bulletList">From open to half-open to see whether the error is gone</li>
      <li class="bulletList">From half-open to closed when the error is gone, that is, when we are back to normal operation</li>
    </ul>
    <p class="normal">With that, we are done with testing the circuit breaker; let’s move on and see the retry mechanism at play.</p>
    <h2 id="_idParaDest-355" class="heading-2">Trying out retries caused by random errors</h2>
    <p class="normal">Let’s simulate that<a id="_idIndexMarker931"/> there is a – hopefully temporary – random issue with our <code class="inlineCode">product</code> service or the communication with it.</p>
    <p class="normal">We can do this by using the <code class="inlineCode">faultPercent</code> parameter. If we set it to <code class="inlineCode">25</code>, we expect every fourth request on average to fail. We hope that the retry mechanism will kick in to help us by automatically retrying failed requests. One way of noticing that the retry mechanism has kicked in is to measure the response time of the <code class="inlineCode">curl</code> command. A normal response should take around 100 ms. Since we have configured the retry mechanism to wait 1 second (see the <code class="inlineCode">waitDuration</code> parameter in the section on the configuration of the retry mechanism), we expect the response time to increase by 1 second per retry attempt. To force a random error to occur, run the following command a couple of times:</p>
    <pre class="programlisting con"><code class="hljs-con">time curl -H "Authorization: Bearer $ACCESS_TOKEN" -k https://localhost:8443/product-composite/1?faultPercent=25 -w "%{http_code}\n" -o /dev/null -s
</code></pre>
    <p class="normal">The command should respond with <code class="inlineCode">200</code>, indicating that the request succeeded. A response time prefixed with <code class="inlineCode">real</code>, for example, <code class="inlineCode">real 0m0.078s</code>, means that the response time was 0.078 s, or 78 ms. A normal response, that is, without any retries, should report a response time of around 100 ms as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_06.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated" width="256" height="125"/></figure>
    <p class="packt_figref">Figure 13.6: Elapsed time for a request without a retry</p>
    <p class="normal">A response <a id="_idIndexMarker932"/>after one retry should take a little over 1 second and look as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_07.png" alt="Graphical user interface, application  Description automatically generated" width="269" height="132"/></figure>
    <p class="packt_figref">Figure 13.7: Elapsed time for a request with one retry</p>
    <div class="packt_tip">
      <p class="normal">The HTTP status code <code class="inlineCode">200</code> indicates that the request has succeeded, even though it required one retry before succeeding!</p>
    </div>
    <p class="normal">After you<a id="_idIndexMarker933"/> have noticed a response time of 1 second, indicating that the request required one retry to succeed, run the following command to see the last two retry events:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose exec product-composite curl -s http://product-composite:8080/actuator/retryevents | jq '.retryEvents[-2], .retryEvents[-1]'
</code></pre>
    <p class="normal">You should be able to see the failed request and the next successful attempt. The <code class="inlineCode">creationTime</code> timestamps are expected to differ by 1 second. Expect a response such as the following:</p>
    <figure class="mediaobject"><img src="../Images/B19825_13_08.png" alt="Text, chat or text message  Description automatically generated" width="878" height="559"/></figure>
    <p class="packt_figref">Figure 13.8: Retry events captured after a request with one retry</p>
    <div class="packt_tip">
      <p class="normal">If you are really unlucky, you will get two faults in a row, and then you will get a response time of 2 seconds instead of 1. If you repeat the preceding command, you will be able to see that the <code class="inlineCode">numberOfAttempts</code> field is counted for each retry attempt, which is set to <code class="inlineCode">1</code> in this case: <code class="inlineCode">"numberOfAttempts": 1</code>. If calls continue to fail, the circuit breaker will kick in and open its circuit, that is, subsequent calls will apply fail-fast logic and the fallback method will be applied!</p>
    </div>
    <p class="normal">This concludes the chapter. Feel free to experiment with the parameters in the configuration to learn more about the resilience mechanisms.</p>
    <p class="normal">Don’t forget to shut down the system landscape:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose down
</code></pre>
    <h1 id="_idParaDest-356" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have seen Resilience4j and its circuit breaker, time limiter, and retry mechanism in action.</p>
    <p class="normal">A microservice that has synchronous dependencies to other services can become unresponsive or even crash if these services stop responding as expected, especially under a high load. These types of error scenarios can be avoided by using a circuit breaker, which applies fail-fast logic and calls fallback methods when it is open. A circuit breaker can also make a microservice resilient by allowing requests when it is half-open to see whether the failing service is operating normally again and close the circuit if so. To support a circuit breaker in handling unresponsive services, a time limiter can be used to maximize the time a circuit breaker waits before it kicks in.</p>
    <p class="normal">A retry mechanism can retry requests that randomly fail from time to time, for example, due to temporary network problems. It is very important to only apply retry requests on idempotent services, that is, services that can handle the same request being sent two or more times.</p>
    <p class="normal">Circuit breakers and retry mechanisms are implemented by following Spring Boot conventions: declaring dependencies and adding annotations and configuration. Resilience4j exposes information about its circuit breakers and retry mechanisms at runtime, using <code class="inlineCode">actuator</code> endpoints. For circuit breakers, information regarding health, events, and metrics is available. For retries, information regarding events and metrics is available.</p>
    <p class="normal">We have seen the usage of endpoints for both health and events in this chapter, but we will have to wait until <em class="chapterRef">Chapter 20</em>, <em class="italic">Monitoring Microservices</em>, before we use any of the metrics.</p>
    <p class="normal">In the next chapter, we will cover the last part of using Spring Cloud, where we will learn how to trace call chains through a set of cooperating microservices using Spring Cloud Sleuth and Zipkin. Head over to <em class="chapterRef">Chapter 14</em>, <em class="italic">Understanding Distributed Tracing</em>, to get started!</p>
    <h1 id="_idParaDest-357" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What are the states of a circuit breaker and how are they used?</li>
      <li class="numberedList">How can we handle timeout errors in the circuit breaker?</li>
      <li class="numberedList">How can we apply fallback logic when a circuit breaker fails fast?</li>
      <li class="numberedList">How can a retry mechanism and a circuit breaker interfere with each other?</li>
      <li class="numberedList">Provide an example of a service that you can’t apply a retry mechanism to.</li>
    </ol>
  </div>
</div>
</div>
</body></html>