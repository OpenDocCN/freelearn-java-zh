- en: Chapter 4. Scala Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered functional programming with Scala and how
    object-oriented and functional approaches complete each other. We also covered
    generic classes, which are often used with pattern matching. Finally, we covered
    how to create user-defined pattern matching and why it is useful.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the Scala Collection library. We will start by
    learning how to work with lists, which will make us familiar with some design
    principles of the whole collections library. Afterward, we'll generalize to sequences
    and cover some more relevant data structures. At the end, we'll look at how collections
    relate to monads and how we can use that knowledge to make some powerful abstractions
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Scala's collection library is very rich, being comprised of data structures
    for very different use cases and performance considerations. It is particularly
    rich in immutable data structures, which we will be covering in greater detail
    during this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Collections available in the Scala collection library inherit from common high-level
    abstract classes and traits and, as such, share some common functionalities, which
    makes working with them easier once you become familiar with certain methods and
    design principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the Scala collections available in the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify how to abstract sequences by using higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the important design principles for working with Scala collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are probably the most commonly used data structures in Scala programs.
    Learning how to work with lists is important both from a data structure standpoint
    but also as an entry point to designing programs around recursive data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to be able to use l `ists`, one must learn how to construct them.
    `Lists` are recursive in nature, and build upon two basic building blocks: `Nil`
    (representing the empty list) and `::` (pronounced cons, from the `cons` function
    of most Lisp dialects).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create Lists in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Scala `REPL`, which should provide you with a prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `list` of strings using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Show that the `::` operation is the right associative by omitting the parentheses
    and getting the same result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create lists of different types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Show that the `apply` method of the `List` companion object offers a convenient
    way to create a list from a variable number of arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering how is it possible for the `::` operator to be right-associative,
    note that the associativity of an operator is determined by the operator's last
    character. Operators ending in a colon `:` are right-associative. All other operators
    are left-associative. Since `::` ends with a colon, it is right-associative.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `List` class provides the `head`, `tail,` and `isEmpty` methods. `head`
    returns the first element of the list, while the `tail` method returns the list
    without its first element. The `isEmpty` method returns `true` if the list is
    empty, and `false` otherwise. `head` and `tail` are only defined for non-empty
    lists and throw an exception on empty ones.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling `head` and `tail` in empty lists (such as `Nil.head` and `Nil.tail`)
    throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `evenInts` method with the following signature, use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The method should return a list with all even integers of list l. Use the `head`,
    `tail,` and `isEmpty` methods of `List`. A possible solution for this problem
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pattern Matching on Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching is a powerful mechanism for checking a value against a pattern
    in Scala and provides an idiomatic way to decompose lists. You can pattern match
    on `::`, which mimics the list structure, or on `List(...)` to match all of the
    list's values.
  prefs: []
  type: TYPE_NORMAL
- en: Let's experiment with pattern matching in the Scala `REPL`. Make sure to show
    examples of both pattern matching with `List(...)` and with `::`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible example to show is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using pattern matching is generally more idiomatic than using `if` and `else`
    to structure programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will implement the method `evenInts` again. This time, we will not
    use the `head`, `tail,` and `isEmpty` methods of `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file where we have written the `evenInts` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not use the `head`, `tail`, and `isEmpty` methods of `list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A possible solution for this problem is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First-Order Methods on List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `List` class provides various helpful first-order methods. A first-order
    method is one that does not take a function as an argument. We'll cover some of
    the most-used methods in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Appending and Concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've learned about `::` to append an element at the head of a list. If we want
    to append an element at the end of a list, we can use the `:+` operator. In order
    to concatenate two lists, we can use the `:::` operator. Note, however, that the
    `:+` operator has a time complexity of `O(n)`, where `n` is the number of elements
    in the list. The `:::` operator has a time complexity of `O(n)`, `n` being the
    number of elements in the first list. Note that the `:::` operator also has right-associativity,
    like the `::` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Taking the Length of a List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking the length of a list is a useful operation. All lists have a definite
    size and, as such, they provide the `length` method that returns their size. We'll
    be covering potentially infinite data structures in another topic.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `length` is an expensive operation on lists, as it needs to traverse
    the whole list to find its end, taking time proportional to the number of elements
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing a List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you require frequent access to the end of a list, it is convenient to reverse
    it once and work with the result. The `reverse` method creates a new list with
    the elements of the original list reversed. The reverse method has linear complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Prefixes and Suffixes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `take` and `drop` methods of `List` return arbitrary prefixes or suffixes
    of a list. They both take an integer as an argument: the number of elements to
    take or drop, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Element Selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though it is not a common operation for lists, the `List` class supports
    random element selection through its apply method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since apply is implicitly inserted when an object appears in the function position
    in a method call, we can also do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `toString` to get the canonical string representation of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mkString` method is a bit more flexible as it allows you to specify the
    prefix to print before all elements, the separator to print between elements,
    and the suffix to print after all elements. The `mkString` method has two overloaded
    variants which allow you to drop the prefix and suffix arguments if they''re empty
    strings. You can also call `mkString` without arguments if you want an empty string
    as a separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the Scaladoc for the `scala.collection.` `immutable.List` class at
    [https://www.scala-lang.org/api/current/scala/collection/immutable/List.html](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html).
    If you are interested in other useful methods, you can take a look at what the
    class has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Creating a New Mode for Chatbot Using Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will be building a new mode for the Chatbot that we created
    on the first day of this book. This new mode will be capable of keeping and updating
    a `todo` list of entries. We will be using `lists` as the primary data structure
    to hold our information, and we want to support at least the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`todo list`: Lists all current items the bot is currently aware of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo new <item description>`: Inserts a new TODO item with the provided description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo done <item number>:` Removes the item numbered <item number> from the
    list. The number of the item should be shown when using `todo` list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo done <item description>`: Removes the item whose description matches
    <item description>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by defining a new class that extends `ChatbotMode`. It''s enough to model
    our TODO list items as strings, so our new mode could just be defined as `case
    class TodoList(todos: List[String]) extends ChatbotMode`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the required `process` method. Regexes might come in handy to parse
    the `line` argument. Depending on the provided input, we want to create a new
    instance of `TodoList` with the value of `todos` possibly modified. Return `None`
    in invalid inputs (unrecognizable commands or attempts to delete a non-existent
    item, for example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with your newly defined mode in the previously implemented Chatbot.
    See how well it plays with the other already defined modes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we covered lists in the perspective of one of the major workhorses
    of Scala programs. We've learned the operations we can perform on lists and covered
    some idiomatic ways to handle lists in Scala code.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting on Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All Scala collections descend from a common trait called `Traversable`. The
    design adopted for Scala collections allows one to use higher-order functions
    similarly in nearly all collections, with proper return types in specific instances.
    Treating collections as sequences, or as containers of elements, allows one to
    use different data structures seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: The Traversable Trait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the root of the collections hierarchy is the `Traversable` trait. The `Traversable`
    trait has a single abstract method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of this method is sufficient for the `Traversable` trait
    to provide a series of useful higher-order methods.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to focus on the `map` operations. The `map` method takes a function
    and applies it to every element of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s experiment with the `map` method in the Scala `REPL` and show how it
    applies to different types of collections. For now, create a function that multiplies
    an integer by 2 and apply it to a `List` and an `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the return type of the `map` method varies according to the collection
    type it is called on.
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` is slightly different. It takes a function from the type of elements
    in the collection to another collection which is then "flattened" in the returned
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example for the `flatMap` method, consider a function that takes an integer
    and creates a list of the integer size filled with 1\. See what the return value
    is when that function is applied to a `list` via `map` and `flatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how the lists are flattened in the `flatMap` call.
  prefs: []
  type: TYPE_NORMAL
- en: These kind of operations closely resemble those of a m `onad`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `monad` is a wrapper and a mechanism of sequencing operations. It provides
    two basic operations: `identity`, to wrap a value in a `monad`, and `bind`, to
    transform the underlying value of a m `onad`. `Monads` will be covered in greater
    detail in [Chapter 7](ch07.html "Chapter 7. Functional Idioms"), *Functional Idioms*,
    so don''t worry if you don''t quite grasp all the intricacies of them just yet.'
  prefs: []
  type: TYPE_NORMAL
- en: The monadic mechanism of chaining `flatMaps` is so common that Scala provides
    a special syntax for it in for-comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: Monadic operations provide the programmer with a way to abstract and chain computations,
    where `map` and `flatMap` are the glue. The fact that `map` and `flatMap` are
    higher-order functions, in other words, they take other functions as arguments,
    allows the programmer to reuse components ( `functions`) in their code.
  prefs: []
  type: TYPE_NORMAL
- en: Other important higher-order functions provided by the collections API are `folds`.
    Generically, folds provide ways to combine elements of a container with some binary
    operator. Folds are different from reduces in the sense that with fold you provide
    a starter value, whereas with `reduce` you only use the elements of the container.
    The `*Left` and `*Right` variants determine the order in which the elements are
    combined.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now implement sum on a List by using foldLeft. A possible solution
    to this problem is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right beneath the `Traversable` trait in the Scala collections hierarchy is
    the `Iterable` trait. An `Iterable` is a trait with a single abstract method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: An `Iterator` provides a method to step through the collection's elements one
    by one. One important thing to note is that an `Iterator` is mutable, as most
    of its operations change its state. Namely, calling `next` on an `iterator` changes
    the in-place position of its `head`. Since an `Iterator` is simply something with
    `next` and `hasNext` methods, it is possible to create an iterator that isn't
    backed by any collection. Since all Scala collections also descend from `Iterable`,
    all of them have an `iterator` method to return an `Iterator` for its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Streams** provide an implementation of lazy lists where elements are only
    evaluated when they are needed. Streams also have a recursive structure, similar
    to `Lists,` based on the `#::` and `Stream.empty` building blocks (analogous to
    `::` and `Nil`). The biggest difference is that `#::` is lazy, and will only evaluate
    the tail when elements from it are needed. One important feature of Streams is
    that they''re memoized, so values won''t be recomputed if they were already computed
    once. The disadvantage of this is that if you keep hold of a reference to the
    head of a `Stream`, you will keep references to all the elements of the `Stream`
    computed so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Implementing Fibonacci Series Using Streams and Iterators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematics, the sequence known as Fibonacci is defined by the number which
    generated by adding the two integers prior to the number. By definition, the first
    two integers in the series should be 1 and 1, or 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the infinite sequence of Fibonacci numbers using Streams and Iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible solution for these implementations is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we've covered `Traversables` as an abstract way to use and
    reason about collections in Scala. We also covered Iterators and Streams and their
    usefulness in implementing potentially infinite sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Other Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered the List and some relevant `Traversables` in the Scala
    standard library, we should also visit some other useful collections Scala provides.
    Even though this section has less theoretical material, this means that we'll
    have more time on the final activities of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Sets` are `Iterables` that contain no duplicate elements. The `Set` class
    provides methods to check for the inclusion of an element in the collection, as
    well as combining different collections. Note that since `Set` inherits from `Traversable`,
    you can apply all the higher-order functions we''ve seen previously on it. Due
    to the nature of its `apply` method, a `Set` can be seen as a function of type
    `A =>` `Boolean`, which returns `true` if the element is present in the set, and
    `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is a class capable of containing an arbitrary number of elements of
    different types. A tuple is created by enclosing its elements in parentheses.
    A tuple is typed according to the type of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create tuples in REPL and access their elements by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create some tuples in the `REPL` and access their elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the type of the tuples created, and how it depends on the enclosing
    elements' types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use pattern matching as a way to destructure tuples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The full code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Map` is an `Iterable` of tuples of size two (pairs of key/values), which
    are also called mappings or associations. A `Map` can't have repeated keys. One
    interesting fact about maps in Scala is that `Map[A, B]` extends `PartialFunction[A,
    B]`, so you can use a `Map` in places where you need a `PartialFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information, refer to the Scaladoc of the Map trait here: [https://www.scala-lang.org/api/current/scala/collection/Map.html](https://www.scala-lang.org/api/current/scala/collection/Map.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable and Immutable Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've been covering mostly immutable collections (with the exception
    of `Iterators`, which are inherently mutable since most operations over it change
    its state—do note that iterators obtained from the `iterator` method of Scala
    collections are not expected to mutate the underlying collection). It is important
    to note, however, that Scala also provides a set of mutable collections in the
    `scala.collection.mutable` package. Mutable collections provide operations to
    change the collection in place.
  prefs: []
  type: TYPE_NORMAL
- en: A useful convention for using both immutable and mutable collections in the
    same place is to import the `scala.collection.mutable` package and prefix collection
    declaration with the mutable keyword, which is `Map` vs `mutable.Map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the difference between the immutable and mutable Maps
    of Scala, showing that the latter has an `update` method that changes the collection
    in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Implementing the Tower of Hanoi Problem'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to create a solver for the Tower of Hanoi problem. If you are not familiar
    with the puzzle, visit the Wikipedia page at [https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi)
    This is a good entry point for it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `paths``inner` function of the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `path` function should return the shortest path from the `from` node to
    the `to` node in the `graph` graph. The `graph` is defined as an adjacency list
    encoded as a `Map[Int, List[Int]]`. The `path's` `inner` function should return
    a `Stream` of paths in increasing length (in a breadth-first search manner).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `nextHanoi` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `nextHanoi` function should return a list of valid states one can achieve
    from the current `HanoiState`. For example: `nextHanoi((List(1, 2, 3), Nil, Nil))`
    should return `List((List` `(2, 3),List(1),List()), (List(2, 3),List(),List(1)))`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generalize the previously implemented path method to be parameterized on the
    type of state we''re operating on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this new implementation, you should be able to solve the Tower of Hanoi
    problem by calling, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A possible implementation of the proposed activity is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Scala Collection library. We covered how to
    work with lists, which will make us familiar with some design principles of the
    whole collections library. We also covered how to generalize to sequences and
    covered some more relevant data structures. Finally, we also covered how collections
    relate to monads and how we can use that knowledge to use some powerful abstractions
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the `type` system and polymorphism. We will
    also cover the different types of variance, which provides a way to constrain
    parameterized types. Finally, we will cover some advanced `types` like abstract
    type members, option, and so on.
  prefs: []
  type: TYPE_NORMAL
