- en: Chapter 4. Scala Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered functional programming with Scala and how
    object-oriented and functional approaches complete each other. We also covered
    generic classes, which are often used with pattern matching. Finally, we covered
    how to create user-defined pattern matching and why it is useful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the Scala Collection library. We will start by
    learning how to work with lists, which will make us familiar with some design
    principles of the whole collections library. Afterward, we'll generalize to sequences
    and cover some more relevant data structures. At the end, we'll look at how collections
    relate to monads and how we can use that knowledge to make some powerful abstractions
    in our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Scala's collection library is very rich, being comprised of data structures
    for very different use cases and performance considerations. It is particularly
    rich in immutable data structures, which we will be covering in greater detail
    during this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Collections available in the Scala collection library inherit from common high-level
    abstract classes and traits and, as such, share some common functionalities, which
    makes working with them easier once you become familiar with certain methods and
    design principles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Identify the Scala collections available in the standard library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify how to abstract sequences by using higher-order functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the important design principles for working with Scala collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Lists
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are probably the most commonly used data structures in Scala programs.
    Learning how to work with lists is important both from a data structure standpoint
    but also as an entry point to designing programs around recursive data structures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Lists
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to be able to use l `ists`, one must learn how to construct them.
    `Lists` are recursive in nature, and build upon two basic building blocks: `Nil`
    (representing the empty list) and `::` (pronounced cons, from the `cons` function
    of most Lisp dialects).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create Lists in Scala:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Scala `REPL`, which should provide you with a prompt:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `list` of strings using the following:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Show that the `::` operation is the right associative by omitting the parentheses
    and getting the same result:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create lists of different types.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Show that the `apply` method of the `List` companion object offers a convenient
    way to create a list from a variable number of arguments:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering how is it possible for the `::` operator to be right-associative,
    note that the associativity of an operator is determined by the operator's last
    character. Operators ending in a colon `:` are right-associative. All other operators
    are left-associative. Since `::` ends with a colon, it is right-associative.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Operations on Lists
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `List` class provides the `head`, `tail,` and `isEmpty` methods. `head`
    returns the first element of the list, while the `tail` method returns the list
    without its first element. The `isEmpty` method returns `true` if the list is
    empty, and `false` otherwise. `head` and `tail` are only defined for non-empty
    lists and throw an exception on empty ones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling `head` and `tail` in empty lists (such as `Nil.head` and `Nil.tail`)
    throws an exception.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `evenInts` method with the following signature, use the following
    code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method should return a list with all even integers of list l. Use the `head`,
    `tail,` and `isEmpty` methods of `List`. A possible solution for this problem
    is the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pattern Matching on Lists
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching is a powerful mechanism for checking a value against a pattern
    in Scala and provides an idiomatic way to decompose lists. You can pattern match
    on `::`, which mimics the list structure, or on `List(...)` to match all of the
    list's values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Let's experiment with pattern matching in the Scala `REPL`. Make sure to show
    examples of both pattern matching with `List(...)` and with `::`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible example to show is:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using pattern matching is generally more idiomatic than using `if` and `else`
    to structure programs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will implement the method `evenInts` again. This time, we will not
    use the `head`, `tail,` and `isEmpty` methods of `List`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Open the file where we have written the `evenInts` method.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not use the `head`, `tail`, and `isEmpty` methods of `list`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A possible solution for this problem is the following:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First-Order Methods on List
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `List` class provides various helpful first-order methods. A first-order
    method is one that does not take a function as an argument. We'll cover some of
    the most-used methods in the following subsection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Appending and Concatenation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've learned about `::` to append an element at the head of a list. If we want
    to append an element at the end of a list, we can use the `:+` operator. In order
    to concatenate two lists, we can use the `:::` operator. Note, however, that the
    `:+` operator has a time complexity of `O(n)`, where `n` is the number of elements
    in the list. The `:::` operator has a time complexity of `O(n)`, `n` being the
    number of elements in the first list. Note that the `:::` operator also has right-associativity,
    like the `::` operator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Example code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Taking the Length of a List
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking the length of a list is a useful operation. All lists have a definite
    size and, as such, they provide the `length` method that returns their size. We'll
    be covering potentially infinite data structures in another topic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Note that `length` is an expensive operation on lists, as it needs to traverse
    the whole list to find its end, taking time proportional to the number of elements
    in the list.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Reversing a List
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you require frequent access to the end of a list, it is convenient to reverse
    it once and work with the result. The `reverse` method creates a new list with
    the elements of the original list reversed. The reverse method has linear complexity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Prefixes and Suffixes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `take` and `drop` methods of `List` return arbitrary prefixes or suffixes
    of a list. They both take an integer as an argument: the number of elements to
    take or drop, respectively.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Example code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Element Selection
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though it is not a common operation for lists, the `List` class supports
    random element selection through its apply method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since apply is implicitly inserted when an object appears in the function position
    in a method call, we can also do:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Display
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `toString` to get the canonical string representation of a list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `mkString` method is a bit more flexible as it allows you to specify the
    prefix to print before all elements, the separator to print between elements,
    and the suffix to print after all elements. The `mkString` method has two overloaded
    variants which allow you to drop the prefix and suffix arguments if they''re empty
    strings. You can also call `mkString` without arguments if you want an empty string
    as a separator:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the Scaladoc for the `scala.collection.` `immutable.List` class at
    [https://www.scala-lang.org/api/current/scala/collection/immutable/List.html](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html).
    If you are interested in other useful methods, you can take a look at what the
    class has to offer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Creating a New Mode for Chatbot Using Lists'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will be building a new mode for the Chatbot that we created
    on the first day of this book. This new mode will be capable of keeping and updating
    a `todo` list of entries. We will be using `lists` as the primary data structure
    to hold our information, and we want to support at least the following commands:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`todo list`: Lists all current items the bot is currently aware of.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo new <item description>`: Inserts a new TODO item with the provided description.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo done <item number>:` Removes the item numbered <item number> from the
    list. The number of the item should be shown when using `todo` list.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo done <item description>`: Removes the item whose description matches
    <item description>.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by defining a new class that extends `ChatbotMode`. It''s enough to model
    our TODO list items as strings, so our new mode could just be defined as `case
    class TodoList(todos: List[String]) extends ChatbotMode`.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the required `process` method. Regexes might come in handy to parse
    the `line` argument. Depending on the provided input, we want to create a new
    instance of `TodoList` with the value of `todos` possibly modified. Return `None`
    in invalid inputs (unrecognizable commands or attempts to delete a non-existent
    item, for example).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with your newly defined mode in the previously implemented Chatbot.
    See how well it plays with the other already defined modes.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we covered lists in the perspective of one of the major workhorses
    of Scala programs. We've learned the operations we can perform on lists and covered
    some idiomatic ways to handle lists in Scala code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting on Sequences
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All Scala collections descend from a common trait called `Traversable`. The
    design adopted for Scala collections allows one to use higher-order functions
    similarly in nearly all collections, with proper return types in specific instances.
    Treating collections as sequences, or as containers of elements, allows one to
    use different data structures seamlessly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The Traversable Trait
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the root of the collections hierarchy is the `Traversable` trait. The `Traversable`
    trait has a single abstract method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The implementation of this method is sufficient for the `Traversable` trait
    to provide a series of useful higher-order methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We would like to focus on the `map` operations. The `map` method takes a function
    and applies it to every element of the collection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s experiment with the `map` method in the Scala `REPL` and show how it
    applies to different types of collections. For now, create a function that multiplies
    an integer by 2 and apply it to a `List` and an `Array`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the return type of the `map` method varies according to the collection
    type it is called on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` is slightly different. It takes a function from the type of elements
    in the collection to another collection which is then "flattened" in the returned
    collection.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example for the `flatMap` method, consider a function that takes an integer
    and creates a list of the integer size filled with 1\. See what the return value
    is when that function is applied to a `list` via `map` and `flatMap`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how the lists are flattened in the `flatMap` call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: These kind of operations closely resemble those of a m `onad`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'A `monad` is a wrapper and a mechanism of sequencing operations. It provides
    two basic operations: `identity`, to wrap a value in a `monad`, and `bind`, to
    transform the underlying value of a m `onad`. `Monads` will be covered in greater
    detail in [Chapter 7](ch07.html "Chapter 7. Functional Idioms"), *Functional Idioms*,
    so don''t worry if you don''t quite grasp all the intricacies of them just yet.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The monadic mechanism of chaining `flatMaps` is so common that Scala provides
    a special syntax for it in for-comprehensions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Monadic operations provide the programmer with a way to abstract and chain computations,
    where `map` and `flatMap` are the glue. The fact that `map` and `flatMap` are
    higher-order functions, in other words, they take other functions as arguments,
    allows the programmer to reuse components ( `functions`) in their code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Other important higher-order functions provided by the collections API are `folds`.
    Generically, folds provide ways to combine elements of a container with some binary
    operator. Folds are different from reduces in the sense that with fold you provide
    a starter value, whereas with `reduce` you only use the elements of the container.
    The `*Left` and `*Right` variants determine the order in which the elements are
    combined.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now implement sum on a List by using foldLeft. A possible solution
    to this problem is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Iterators
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right beneath the `Traversable` trait in the Scala collections hierarchy is
    the `Iterable` trait. An `Iterable` is a trait with a single abstract method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An `Iterator` provides a method to step through the collection's elements one
    by one. One important thing to note is that an `Iterator` is mutable, as most
    of its operations change its state. Namely, calling `next` on an `iterator` changes
    the in-place position of its `head`. Since an `Iterator` is simply something with
    `next` and `hasNext` methods, it is possible to create an iterator that isn't
    backed by any collection. Since all Scala collections also descend from `Iterable`,
    all of them have an `iterator` method to return an `Iterator` for its elements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Streams** provide an implementation of lazy lists where elements are only
    evaluated when they are needed. Streams also have a recursive structure, similar
    to `Lists,` based on the `#::` and `Stream.empty` building blocks (analogous to
    `::` and `Nil`). The biggest difference is that `#::` is lazy, and will only evaluate
    the tail when elements from it are needed. One important feature of Streams is
    that they''re memoized, so values won''t be recomputed if they were already computed
    once. The disadvantage of this is that if you keep hold of a reference to the
    head of a `Stream`, you will keep references to all the elements of the `Stream`
    computed so far.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Implementing Fibonacci Series Using Streams and Iterators'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematics, the sequence known as Fibonacci is defined by the number which
    generated by adding the two integers prior to the number. By definition, the first
    two integers in the series should be 1 and 1, or 0 and 1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the infinite sequence of Fibonacci numbers using Streams and Iterators:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One possible solution for these implementations is the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this section, we've covered `Traversables` as an abstract way to use and
    reason about collections in Scala. We also covered Iterators and Streams and their
    usefulness in implementing potentially infinite sequences.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Other Collections
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered the List and some relevant `Traversables` in the Scala
    standard library, we should also visit some other useful collections Scala provides.
    Even though this section has less theoretical material, this means that we'll
    have more time on the final activities of the chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Sets` are `Iterables` that contain no duplicate elements. The `Set` class
    provides methods to check for the inclusion of an element in the collection, as
    well as combining different collections. Note that since `Set` inherits from `Traversable`,
    you can apply all the higher-order functions we''ve seen previously on it. Due
    to the nature of its `apply` method, a `Set` can be seen as a function of type
    `A =>` `Boolean`, which returns `true` if the element is present in the set, and
    `false` otherwise.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is a class capable of containing an arbitrary number of elements of
    different types. A tuple is created by enclosing its elements in parentheses.
    A tuple is typed according to the type of its elements.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create tuples in REPL and access their elements by following these
    steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Create some tuples in the `REPL` and access their elements.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the type of the tuples created, and how it depends on the enclosing
    elements' types.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use pattern matching as a way to destructure tuples.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The full code looks as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Maps
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Map` is an `Iterable` of tuples of size two (pairs of key/values), which
    are also called mappings or associations. A `Map` can't have repeated keys. One
    interesting fact about maps in Scala is that `Map[A, B]` extends `PartialFunction[A,
    B]`, so you can use a `Map` in places where you need a `PartialFunction`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information, refer to the Scaladoc of the Map trait here: [https://www.scala-lang.org/api/current/scala/collection/Map.html](https://www.scala-lang.org/api/current/scala/collection/Map.html).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Mutable and Immutable Collections
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've been covering mostly immutable collections (with the exception
    of `Iterators`, which are inherently mutable since most operations over it change
    its state—do note that iterators obtained from the `iterator` method of Scala
    collections are not expected to mutate the underlying collection). It is important
    to note, however, that Scala also provides a set of mutable collections in the
    `scala.collection.mutable` package. Mutable collections provide operations to
    change the collection in place.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: A useful convention for using both immutable and mutable collections in the
    same place is to import the `scala.collection.mutable` package and prefix collection
    declaration with the mutable keyword, which is `Map` vs `mutable.Map`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the difference between the immutable and mutable Maps
    of Scala, showing that the latter has an `update` method that changes the collection
    in place:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Activity: Implementing the Tower of Hanoi Problem'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to create a solver for the Tower of Hanoi problem. If you are not familiar
    with the puzzle, visit the Wikipedia page at [https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi)
    This is a good entry point for it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `paths``inner` function of the following function:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `path` function should return the shortest path from the `from` node to
    the `to` node in the `graph` graph. The `graph` is defined as an adjacency list
    encoded as a `Map[Int, List[Int]]`. The `path's` `inner` function should return
    a `Stream` of paths in increasing length (in a breadth-first search manner).
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`path`函数应该返回`graph`图中从`from`节点到`to`节点的最短路径。`graph`被定义为编码为`Map[Int, List[Int]]`的邻接表。`path`的`inner`函数应该返回按长度递增的路径`Stream`（以广度优先搜索的方式）。'
- en: 'Implement the `nextHanoi` function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下`nextHanoi`函数：
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `nextHanoi` function should return a list of valid states one can achieve
    from the current `HanoiState`. For example: `nextHanoi((List(1, 2, 3), Nil, Nil))`
    should return `List((List` `(2, 3),List(1),List()), (List(2, 3),List(),List(1)))`.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`nextHanoi`函数应该返回一个列表，其中包含从当前`HanoiState`可以实现的合法状态。例如：`nextHanoi((List(1, 2,
    3), Nil, Nil))`应该返回`List((List(2, 3),List(1),List()), (List(2, 3),List(),List(1)))`。'
- en: 'Generalize the previously implemented path method to be parameterized on the
    type of state we''re operating on:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前实现的路径方法泛化，使其参数化为我们正在操作的状态类型：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this new implementation, you should be able to solve the Tower of Hanoi
    problem by calling, for example:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新的实现，你应该能够通过调用，例如，来解决汉诺塔问题：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A possible implementation of the proposed activity is the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建议的活动的可能实现如下：
- en: '[PRE27]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the Scala Collection library. We covered how to
    work with lists, which will make us familiar with some design principles of the
    whole collections library. We also covered how to generalize to sequences and
    covered some more relevant data structures. Finally, we also covered how collections
    relate to monads and how we can use that knowledge to use some powerful abstractions
    in our code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Scala集合库。我们介绍了如何处理列表，这将使我们熟悉整个集合库的一些设计原则。我们还介绍了如何泛化到序列，并介绍了一些相关的数据结构。最后，我们还介绍了集合与单子之间的关系，以及我们如何利用这些知识在我们的代码中使用一些强大的抽象。
- en: In the next chapter, we will cover the `type` system and polymorphism. We will
    also cover the different types of variance, which provides a way to constrain
    parameterized types. Finally, we will cover some advanced `types` like abstract
    type members, option, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍`type`系统和多态性。我们还将介绍不同类型的变异性，这提供了一种约束参数化类型的方法。最后，我们还将介绍一些高级`type`，如抽象类型成员、选项等。
