<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting Familiar with Scala Collections</h1>
                
            
            <article>
                
<p class="calibre2"/>
<div class="packt_quote">"The code that you write should absorb more meaning without becoming bloated or losing comprehensibility."</div>
<div class="packt_quote1">- Anonymous</div>
<p class="calibre2">In any programming language, one of the essential requirements is to have a way of working with a set of data, or, in other words, a collection of data. If you have worked with any programming language, you must already know the importance of its collection framework. Scala has a rich variety of collections; a rich set of helper functions makes it a lot easier to work with any Scala collection. In this chapter, we'll go through all the essentials of Scala collections. We'll be able to distinguish between several collection options, and also make efficient use of all collections. Along the way, we'll learn about:</p>
<ul class="calibre7">
<li class="calibre8">Immutable and mutable Scala collections</li>
<li class="calibre8">Scala's collection hierarchy</li>
<li class="calibre8">Commonly used collections in Scala</li>
<li class="calibre8">Rich operations performed on collections</li>
<li class="calibre8">Parallel collections</li>
<li class="calibre8">Conversion from a Java to a Scala collection</li>
<li class="calibre8">Choosing a collection</li>
<li class="calibre8">Collection performance</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Motivation</h1>
                
            
            <article>
                
<p class="calibre2">Before we start learning about immutable and mutable collections in Scala, we'll try to solve a simple problem using powerful methods provided by Scala collections. For that, let's take a look at a scenario:</p>
<div class="cdpaligncenter"><img class="image-border7" src="../images/00018.jpeg"/></div>
<div class="cdpaligncenter1">RESTful APIs</div>
<p class="calibre2">As shown in the preceding image, we have a set of APIs with method types such as <kbd class="calibre11">GET</kbd>, <kbd class="calibre11">POST</kbd>, and <kbd class="calibre11">PUT</kbd>, and their associated URIs. As these are two entities (method and URI), think of all these as a list of tuples<em class="calibre18">.</em> Now we want to segregate them, so we can create a map, as shown in the right column of the preceding image. A map is a collection that stores values in a key-value pair. Hence, on the right side you can see API information as key-value pairs, where key is the method name, and the value is a list of URIs for that particular request type. So, the idea is to convert <kbd class="calibre11">List[(String, String)]</kbd> to <kbd class="calibre11">Map[String, List[String]]</kbd><em class="calibre18">.</em> You may want to think about the solution, and come up with your own.</p>
<p class="calibre2">Meanwhile, let's see if Scala helps us in any way with our solution:</p>
<pre class="calibre19">object RESTFulAPIs extends App { 
    //List of Method and URI 
    val listOfAPIs = List(("GET", "/user/:id"), 
                          ("GET", "user/:id/profile/:p_id"), 
                          ("POST", "/user"), 
                          ("POST", "/profile"), 
                          ("PUT", "/user/:id")) 
 
    /* 
     * Returns a scala.collection.immutable.Map[String,  List[(String,String)]] 
     */ 
    val groupedListOfAPIs = listOfAPIs.groupBy(_._1) 
    println(s"APIs grouped to a Map :: $groupedListOfAPIs") 
 
    /* 
     * Returns a scala.collection.immutable.Map[String, List[String]] 
     */ 
    val apisByMethod = groupedListOfAPIs.mapValues(_.map(_._2)) 
    println(s"APIs By Method :: $apisByMethod") 
} </pre>
<p class="calibre2">Here's the result:</p>
<pre class="calibre19">APIs grouped to a Map :: Map(POST -&gt; List((POST,/user), (POST,/profile)), GET -&gt; List((GET,/user/:id), (GET,user/:id/profile/:p_id)), PUT -&gt; List((PUT,/user/:id))) 
APIs By Method :: Map(POST -&gt; List(/user, /profile), GET -&gt; List(/user/:id, user/:id/profile/:p_id), PUT -&gt; List(/user/:id)) </pre>
<p class="calibre2">If you have come up with a set of <kbd class="calibre11">for</kbd> loops or recursive methods to accomplish what can be done using a single method, you may want to rethink, or take a look at the solution we have here. Here, we used two utility methods that fulfill our purpose. The first one is <kbd class="calibre11">groupBy</kbd><em class="calibre18">,</em> defined in the <kbd class="calibre11">TraversableLike</kbd> trait, which converts our <kbd class="calibre11">List[(String, String)]</kbd> to a <kbd class="calibre11">Map[String, List[String]]</kbd> grouped by the first element of the tuple, the method names. This <kbd class="calibre11">groupBy</kbd> operation gives us this:</p>
<pre class="calibre19">Map(POST -&gt; List((POST,/user), (POST,/profile)), GET -&gt; List((GET,/user/:id), (GET,user/:id/profile/:p_id)), PUT -&gt; List((PUT,/user/:id))) </pre>
<p class="calibre2">The latter is the <kbd class="calibre11">mapValues</kbd> method from <kbd class="calibre11">MapLike</kbd> trait, which is used to wrap the given map with the same key. The value for each key is simply <kbd class="calibre11">f(this(key))</kbd>:</p>
<pre class="calibre19">def mapValues[W](f: V =&gt; W): Map[K, W] </pre>
<p class="calibre2">These two methods were enough to provide the solution, and helped us avoid many traversals using loops. This is just one example, and a lot can be done within only few lines of code that would otherwise have taken several lines. This really makes Scala collections powerful. Scala's collection framework is easy to use; most of the helper methods are universal, with a few exceptions. Also, there is no compromise with performance; these are performance-tuned methods. One can rely on these methods to accomplish any logic; it makes your code look nicer. But that's not all, it's just the beginning. Usually, collections are prone to code that is written with the current environment in mind. That usually makes it hard to debug what went wrong, specifically when mutable collections are in place. So, just to remove this complication, Scala has these immutable data collections. Once created, the immutable collections can't be updated. But how do they work, and how are they different from mutable collections? Let's go through and try to understand.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Immutable and mutable collections</h1>
                
            
            <article>
                
<p class="calibre2">A collection is used to contain data that is used by the program later in time. In a multithreaded environment, if multiple threads try to access a collection at the same time, this can give you a hard time debugging what went wrong. That is a problem programmers usually face when working with collections in a multithreaded environment. But there's a universal solution for that, which expects you to use an immutable collection. Immutable means you can't change/mutate it. Scala provides you options to choose from: <kbd class="calibre11">root</kbd>, <kbd class="calibre11">mutable</kbd>, and <kbd class="calibre11">immutable</kbd> collections. These three are variants that exist in three separate packages: <kbd class="calibre11">scala.collection</kbd><em class="calibre18">,</em> <kbd class="calibre11">scala.collection.mutable</kbd>, and <kbd class="calibre11">scala.collection.immutable</kbd><em class="calibre18">.</em> If you don't specify the collection and use one, it'll be an immutable one by default. But how do these work, exactly? Let's take a look:</p>
<pre class="calibre19">scala&gt; val studentsPresent = List("Alex", "Bob", "Chris") 
 
studentsPresent: List[String] = List(Alex, Bob, Chris) </pre>
<p class="calibre2">A collection that does not allow us to update or delete its elements is of not much use. So, why do we say these are rich collections? The reason is that even though these are immutable collections, there are ways to add and remove elements, but these actions return a new collection altogether. We'll see how these are constructed and then how adding an element affects the collection later in this chapter; but for now, it's important to know that immutable collections can be updated, although doing so returns another collection with the same set of elements, along with the updated collection.</p>
<p class="calibre2">On the other hand, we have mutable collections, which work similar to most object-oriented programming languages. You can declare and instantiate a collection with a few elements. Then, based on any requirements afterwards, you can change its elements, or remove them. With these mutable collections, Scala gives you a choice to make when selecting a collection to work with. When you use mutable collections, you get an extra set of methods to mutate the collection. Be sure, though, about the instances where you may mutate collections. That'll make your program world free of mutability complications.</p>
<p class="calibre2">The third variant, root collections, resides in the <kbd class="calibre11">scala.collection</kbd><em class="calibre18"> </em><span>package</span><em class="calibre18">.</em> <span>When you use a root collection, it can be mutable or immutable. What does that mean? It means that a particular collection is a superclass of a collection from the same family residing in both the </span><kbd class="calibre11">scala.collection.mutable</kbd> <span>and</span> <kbd class="calibre11">scala.collection.immutable</kbd> <span>packages. To understand what we just said, take a look at the following method:</span></p>
<pre class="calibre19">def afunction(xs: scala.collection.Iterable[String]) = ??? </pre>
<p class="calibre2">The <kbd class="calibre11">afunction</kbd> function can take both mutable and immutable collections, as long as they are Iterable, which is one of the traits available in Scala's collection hierarchy<em class="calibre18">.</em></p>
<p class="calibre2">There are few extra methods that let you mutate your collection, and as we may expect, those are defined only for collections in the <kbd class="calibre11">scala.collection.mutable</kbd> <span>package,</span><span> </span><span>not the </span><kbd class="calibre11">scala.collection</kbd> <span>or</span> <kbd class="calibre11">scala.collection.immutable</kbd> packages<em class="calibre18">.</em> <span>In that case, it's clear that while writing your root collection, the Scala compiler is not going to allow you to update your collection. We talked about one of the use cases of root collections where, regardless of the type of your collection, you can define a function—that is, </span><kbd class="calibre11">afunction</kbd><span>, that takes all sorts of collections. There are more ways we can find the use cases, or differentiate root and immutable collections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Differences between the root and immutable collections</h1>
                
            
            <article>
                
<p class="calibre2">The differences between the <kbd class="calibre11">root</kbd> and <kbd class="calibre11">immutable</kbd> collection use cases are easy to understand with the help of a scenario. Think of a scenario where:</p>
<ul class="calibre7">
<li class="calibre8">A function declaration expects a collection as a parameter</li>
<li class="calibre8">The function is not going to mutate the collection as part of the definition</li>
<li class="calibre8">The function can work well, regardless of the fact that the collection values can be changed by other threads in time</li>
</ul>
<p class="calibre2">If these three scenarios are fulfilled, you're welcome to use the <kbd class="calibre11">root</kbd> collection type as the parameter for your function definition. It means that the following declaration will work for you:</p>
<pre class="calibre19">def afunction(xs: scala.collection.Iterable[String]) </pre>
<p class="calibre2">If the third scenario is not what you wish for, then use <kbd class="calibre11">scala.collection.immutable</kbd><em class="calibre18">.</em> The scenario explains where we can use root collections. Just because you don't have access to methods that mutate collections, it doesn't put a constraint on the runtime modification of the collection.</p>
<p class="calibre2">It's also important to know that even in these three packages, collections are present in a hierarchical manner. So, let's take a look at the hierarchy of collections in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hierarchy of collections in Scala</h1>
                
            
            <article>
                
<p class="calibre2">The hierarchical structure of Scala collections is easy to understand. When you start working with collections, it becomes easy to use any method that is already defined in a super trait, and for specific implementations you can define your own versions. The structure has been classified in three distinct categories, that is: <kbd class="calibre11">root</kbd><em class="calibre18">,</em> <kbd class="calibre11">mutable</kbd><em class="calibre18">,</em> and <kbd class="calibre11">immutable</kbd><em class="calibre18">.</em> We've discussed the differences between them. To strengthen our discussion, let's take a look at the hierarchy of <kbd class="calibre11">root</kbd> package collections:</p>
<div class="cdpaligncenter"><img src="../images/00019.jpeg" class="calibre30"/></div>
<div class="cdpaligncenter1">Root collection hierarchy</div>
<p class="calibre2">The preceding hierarchy is for collections in the <kbd class="calibre11">root</kbd> package. All the collections inherited from the super trait are called <strong class="calibre1">Traversable</strong><em class="calibre18">.</em> Traversable defines the <kbd class="calibre11">foreach</kbd> abstract method, along with other helper methods that can relate to any collection in the hierarchy. So, it's clear that every other collection needs to give a definition of the <kbd class="calibre11">foreach</kbd> <span>method</span><span> </span><span>in its implementation. We'll have a look at</span> Traversable <em class="calibre18">trait</em><span> in the next few topics.</span></p>
<p class="calibre2">After Traversable<em class="calibre18">,</em> there's a <em class="calibre18">trait</em> named <strong class="calibre1">Iterable</strong>, which inherits <em class="calibre18">Traversable</em>, implements the <kbd class="calibre11">foreach</kbd> method from Traversable, and has its own <em class="calibre18">iterator</em> abstract method. From there, the hierarchy splits into three different categories:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">Seq</kbd></li>
<li class="calibre8"><kbd class="calibre11">Set</kbd></li>
<li class="calibre8"><kbd class="calibre11">Map</kbd></li>
</ul>
<p class="calibre2">These three categories are different in implementation, context, and use cases. The first one is a sequence that's used to contain a sequence of elements, such as a sequence of numbers. Sequences are further classified as <kbd class="calibre11">LinearSeq</kbd> and <kbd class="calibre11">IndexedSeq</kbd><em class="calibre18">.</em> The second one is a set, and it is a collection of distinct elements, which means elements can't be repeated. Sets are classified as <kbd class="calibre11">SortedSet</kbd> and <kbd class="calibre11">BitSet</kbd><em class="calibre18">.</em> The last one is a map, which is a key-value-based collection that can have a <kbd class="calibre11">SortedMap</kbd><em class="calibre18">.</em> These are all part of the <kbd class="calibre11">scala.collection</kbd> package.</p>
<p class="calibre2">After the root package, let's take a look at the collections hierarchy in <span>the </span><kbd class="calibre11">scala.collection.mutable</kbd> <span>package:</span></p>
<div class="cdpaligncenter"><img src="../images/00020.jpeg" class="calibre31"/></div>
<div class="cdpaligncenter1">The scala.collection.mutable collections package</div>
<p class="calibre2">It may be frightening when you first see these, but it works as a utility when you use these collections wisely. Collections in the <kbd class="calibre11">scala.collection.mutable</kbd> <span>package,</span><span> as expected, contain methods that can be used to add/remove elements in the collection. The hierarchy of this package is similar to</span> <kbd class="calibre11">Seq</kbd><span>,</span> <kbd class="calibre11">Set</kbd><span>, and</span> <kbd class="calibre11">Map</kbd> traits<span>. Afterwards, more concrete implementations that are specific to some use cases are part of the package. The figure itself is self-explanatory; more and more implementations of these collection traits are there for us to use. <kbd class="calibre11">IndexedSeq</kbd> has more implementations now, such as</span> <kbd class="calibre11">ArraySeq</kbd><em class="calibre18">,</em> <kbd class="calibre11">StringBuilder</kbd><span>, and</span> <kbd class="calibre11">ArrayBuffer</kbd><em class="calibre18">.</em> <span>Another</span> trait<span>, named</span> <kbd class="calibre11">Buffer</kbd><span>, is introduced. A few implementations, such as </span><kbd class="calibre11">Stack</kbd><em class="calibre18">,</em> <kbd class="calibre11">ArrayStack</kbd><span>,</span> and <kbd class="calibre11">PriorityQueue</kbd> <span>extend directly from</span> <kbd class="calibre11">Seq</kbd> trait. In the same way, the other two traits, Set and Map, also have a few concrete implementations. HashSet and BitSet are for sets, and HashMap, LinkedHashMap, and ListMap extend Map.</p>
<p class="calibre2">Finally, let's take a look at the hierarchy of the <kbd class="calibre11">scala.collection.immutable</kbd><em class="calibre18"> </em><span>package:</span></p>
<div class="cdpaligncenter"><img src="../images/00021.jpeg" class="calibre32"/></div>
<div class="cdpaligncenter1">The scala.collection.immutable package</div>
<p class="calibre2">The collections hierarchy is similar to mutable collections apart from the fact that <em class="calibre18">immutable</em> collections, don't have the <kbd class="calibre11">Buffer</kbd> trait; the difference is that these collections do not have methods that let you mutate the same collection. Though it's possible to transform collections, it means that these collections have higher-order methods that can traverse and apply a function to each element, resulting in another collection. This is one of the ways to deal with immutable collections.</p>
<p class="calibre2">This hierarchy also has the <em class="calibre18">Traversable</em> and <em class="calibre18">Iterable</em> super traits<em class="calibre18">.</em> These traits consist of most helper methods. These are universal methods that can be used with almost any collection in Scala. By default, Scala assumes a collection to be of the <kbd class="calibre11">immutable</kbd> type. It's good if you use them. It's good to know that you can also create your own custom collections. For this, there's a sub-package named <kbd class="calibre11">generic</kbd> in the <kbd class="calibre11">scala.collection</kbd> package that consists of the helpers <span>required</span><span> </span><span>to create a collection implementation.</span></p>
<p class="calibre2">When we implement these collections, we assume there are ways to use and manipulate these collections, and indeed there are many higher-order helper functions that let you do so. Most of the basic and universal helpers are defined in super traits that other collections implement. Let's take a look at these traits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traversable</h1>
                
            
            <article>
                
<p class="calibre2">This is a super trait of all other implementations for collections in Scala. Traversable defines a few methods that help to access collection elements, or perform operations on them. These operations can be categorized as follows:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Additions</strong>: Methods that append two traversables together. For two traversable collections, such as <kbd class="calibre11">xs</kbd> and <kbd class="calibre11">ys</kbd>:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs ++ ys</kbd></li>
</ul>
</li>
</ul>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Transformations</strong>: Methods such as <kbd class="calibre11">map</kbd>, <kbd class="calibre11">flatMap</kbd>, and <kbd class="calibre11">collect</kbd> come in this category:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.map(elem =&gt; elem.toString + "default")</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Conversions</strong>: Methods with a format such as <kbd class="calibre11">toXXX</kbd> <em class="calibre18">or</em> <kbd class="calibre11">mkString</kbd><em class="calibre18">.</em> These are used to convert one collection to another suitable collection:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.toArray</kbd>, <kbd class="calibre11">xs.mkString</kbd>, and <kbd class="calibre11"><kbd class="calibre33">xs.toStream</kbd></kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Copying</strong>: Helper methods that copy elements from a collection to another collection, such as an array or buffer:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.copyToBuffer(arr)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Information retrievals</strong>: Methods that retrieve information such as size, or whether the collection has elements or not:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.isEmpty</kbd>, <kbd class="calibre11">xs.isNonEmpty</kbd>, and <kbd class="calibre11">xs.hasDefiniteSize</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Element retrievals</strong>: Methods that retrieve an element from a collection:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.head</kbd> and <kbd class="calibre11">xs.find(elem =&gt; elem.toCharArray.length == 4)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Sub collections</strong>: Methods that return a sub-collection, based on ordering, or a predicate:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.tail</kbd>, <kbd class="calibre11">xs.init</kbd>, <kbd class="calibre11">xs.filter(elem =&gt; elem.toCharArray.length == 4)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Folding</strong>: Methods that apply a binary operation on each of the successive elements of a collection. Also, there are some special forms of folding operations:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.foldLeft(z)(op)</kbd>, and <kbd class="calibre11">xs.product</kbd></li>
</ul>
</li>
</ul>
<p class="calibre2">We'll go through implementation details of almost all these methods later in the chapter. For now, it's important to know that the <kbd class="calibre11">Traversable</kbd> trait mixes in with <kbd class="calibre11">TraversableLike</kbd> and few other traits. If you don't understand what a mix-in of traits is<em class="calibre18">,</em> we'll discuss that when we talk about object-oriented programming in Scala in subsequent chapters:</p>
<pre class="calibre19">trait Traversable[+A] extends TraversableLike[A, Traversable[A]] with GenTraversable[A] with TraversableOnce[A] with GenericTraversableTemplate[A, Traversable] </pre>
<p class="calibre2">Traversable has an abstract <kbd class="calibre11">foreach</kbd><em class="calibre18"> </em><span>method</span><em class="calibre18">.</em> <span>Any implementation that mixes in </span><kbd class="calibre11">Traversable</kbd><span> needs to define this abstract</span> <kbd class="calibre11">foreach</kbd><em class="calibre18"> </em><span>method:</span></p>
<pre class="calibre19">def foreach[U](f: Elem =&gt; U) </pre>
<p class="calibre2">As shown in the <kbd class="calibre11">foreach</kbd> <span>method</span><span> </span><span>signature, it has a type parameter, </span><kbd class="calibre11">U</kbd><span>, which stands for the type of data that we'll impose when we'll use the method. The</span> <kbd class="calibre11">foreach</kbd> <span>method traverses the collection, applying a function to each of its elements. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Iterable</h1>
                
            
            <article>
                
<p class="calibre2">Iterable is also a trait that other collections mix in with. Iterable mixes in <em class="calibre18">Traversable</em>, and also defines the <kbd class="calibre11">foreach</kbd> abstract method. Iterable also has an abstract method named <kbd class="calibre11">iterator</kbd><em class="calibre18">.</em> Implementations that mix in the <em class="calibre18">Iterable</em> trait have to define this abstract method:</p>
<pre class="calibre19">def iterator: Iterator[A] </pre>
<p class="calibre2">You can see that the <kbd class="calibre11">iterator</kbd> method returns an <kbd class="calibre11">Iterator</kbd><em class="calibre18">,</em> which has the <kbd class="calibre11">hasNext</kbd> and <kbd class="calibre11">next</kbd> methods. Using an Iterator, we can fetch all elements <span>one by one,</span><span> </span><span>or perform an operation. A closer look will tell you that Traversable can traverse the whole collection in one go, while for an Iterable, the pull approach works well. Each iteration gives an element.</span></p>
<p class="calibre2">Of course, Iterables support all methods from <em class="calibre18">Traversable</em>. Along with that, there are a few more methods:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Sub-iterations</strong>: Methods that return another chunked iterator:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.grouped(size)</kbd>, and <kbd class="calibre11">xs.sliding(size)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Sub-collections</strong>: Methods that return parts of collections:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.takeRight(n)</kbd>, and <kbd class="calibre11">xs.dropRight(n)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Zipping</strong>: Methods that return iterable collection elements in pairs:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.zip(ys)</kbd>, and <kbd class="calibre11">xs.zipWithIndex</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Comparisons</strong>: Methods that compare two iterable collections according to the order of elements:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs sameElements ys</kbd></li>
</ul>
</li>
</ul>
<p class="calibre2">One possible declaration of <kbd class="calibre11">Iterable</kbd> is as follows:</p>
<pre class="calibre19">trait Iterable[+A] extends Traversable[A] with GenIterable[A] with GenericTraversableTemplate[A, Iterable] with IterableLike[A, Iterable[A]] </pre>
<p class="calibre2">As you can see, the <kbd class="calibre11">Iterable</kbd> <span>trait</span><span> </span><span>mixes in </span><kbd class="calibre11">Traversable</kbd><span>, along with a few others. That's how it exists in the hierarchy. The following Iterables are three traits, named</span> <kbd class="calibre11">Seq</kbd><em class="calibre18">,</em> <kbd class="calibre11">Set</kbd><em class="calibre18">,</em> <span>and</span> <kbd class="calibre11">Map</kbd><em class="calibre18">.</em> <span>Let's go through them.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Seq</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">Seq</kbd> represents a sequence of elements. Its signature is as follows:</p>
<pre class="calibre19">trait Seq[+A] extends PartialFunction[Int, A] with Iterable[A] with GenSeq[A] with GenericTraversableTemplate[A, Seq] with SeqLike[A, Seq[A]]</pre>
<p class="calibre2">As shown, <kbd class="calibre11">Seq</kbd> extends <kbd class="calibre11">PartialFunction</kbd>, but what does that mean? Remember, we discussed <span>partial functions </span><span>in the previous chapter. These functions are defined for a particular set of values from the domain. In the case of <kbd class="calibre11">Seq</kbd>, that domain is the</span> <kbd class="calibre11">length -1</kbd><em class="calibre18">.</em> <span>It is clear from the signature that a</span> <kbd class="calibre11">Seq</kbd> <span>can take an</span> <kbd class="calibre11">Int</kbd>, <span>and responds with an element of type</span> <kbd class="calibre11">A</kbd><em class="calibre18">.</em> <span>Here,</span> <kbd class="calibre11">A</kbd> <span>is the type of the collection element. Let's look at an example:</span></p>
<pre class="calibre19">scala&gt; val aSeq = scala.collection.LinearSeq[Int](1,2,3,4) 
aSeq: scala.collection.LinearSeq[Int] = List(1, 2, 3, 4) 
 
scala&gt; aSeq(1) 
res0: Int = 2 </pre>
<p class="calibre2">In the preceding example, when we define the sequence, it becomes a partial function of type <kbd class="calibre11">PartialFunction[Int, Int]</kbd>. It means that passing any value from its length - 1 as a parameter to our sequence will result in a value from the sequence of type A<em class="calibre18">,</em> which in our case, is also an <kbd class="calibre11">Int</kbd><em class="calibre18">.</em> The reason that a <kbd class="calibre11">Seq</kbd> is defined for <span>only</span><span> </span><span>some particular values from the domain is to show that if we pass an index for which</span> <kbd class="calibre11">aSeq</kbd> <span>does not have a value, it will give an exception:</span></p>
<pre class="calibre19">scala&gt; aSeq(5) 
java.lang.IndexOutOfBoundsException: 5 
  at scala.collection.LinearSeqOptimized.apply(LinearSeqOptimized.scala:63) 
  at scala.collection.LinearSeqOptimized.apply$(LinearSeqOptimized.scala:61) 
  at scala.collection.immutable.List.apply(List.scala:86) 
  ... 29 elided </pre>
<p class="calibre2">A <kbd class="calibre11">Seq</kbd>, being a <kbd class="calibre11">PartialFunction</kbd>, can prove a boon for us as developers, as there are many instances where very complex logic can become so easy to implement. There's also a method, <kbd class="calibre11">isDefinedAt</kbd><em class="calibre18">.</em> As you may be aware, we can use it to check whether the partial function is defined for the value. A sequence is said to have a length, and encompasses two variants, named <kbd class="calibre11">IndexedSeq</kbd> and <kbd class="calibre11">LinearSeq</kbd><em class="calibre18">.</em> These names imply most of what these collections are there for. An indexed sequence is recommended to use when we access them via indexing; in other words, by calling the <kbd class="calibre11">length</kbd> or <kbd class="calibre11">apply</kbd> methods.  A linear sequence, however, is used where the performance of a subsection of a collection is important. It means that calling a method on a collection and breaking it into sub-sequences is important. Now, after knowing all this, let's take a look at the categories of operations that can be performed on these sequences:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Length and indexing</strong>: Methods that depend on the length of the sequence, mainly via index or size:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.apply(1)</kbd>, <kbd class="calibre11">xs.length</kbd>, <kbd class="calibre11">xs.indices</kbd>, and<kbd class="calibre11"><kbd class="calibre33"> xs.indexWhere(predicate)</kbd></kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Additions</strong>: Methods that add an element at the beginning or at the end of a sequence:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">x+:(xs)</kbd> and <kbd class="calibre11">xs.:+(x)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Updates</strong>: Methods that update an element in a sequence:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs(1) = 12</kbd> and <kbd class="calibre11">xs updated (1, 12)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Sorting</strong>: Methods that sort a given sequence:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.sorted</kbd> and <kbd class="calibre11">xs sortWith op</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Reversing</strong>: Methods that reverse a sequence:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.reverse</kbd>, and so on</li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Comparisons and checks</strong>: Methods that reverse a sequence:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.contains(x)</kbd> and <kbd class="calibre11">xs.endsWith(x)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Multi-set operations</strong>: Methods that results based on some set operations like union and distinct:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.union(ys)</kbd> and <kbd class="calibre11">xs.distinct</kbd></li>
</ul>
</li>
</ul>
<p class="calibre2">We'll go through the implementation details of these methods in subsequent sections. Now, let's take a look at different variants of sequences:</p>
<div class="cdpaligncenter"><img class="image-border8" src="../images/00022.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sequences</h1>
                
            
            <article>
                
<p class="calibre2">There's another form of sequences, named <em class="calibre18">Buffer</em>, that is mutable. It allows addition, update, removal, and other mutating operations on it. These mutations are done via methods such as +=, ++=, and <em class="calibre18">insert.</em> There's another sub-trait of <em class="calibre18">Iterable</em> which is called <kbd class="calibre11">Map</kbd><em class="calibre18">.</em> Let's go through it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Map</h1>
                
            
            <article>
                
<p class="calibre2">A <kbd class="calibre11">Map</kbd> can be represented as a collection containing elements in the form of a key-value pair:</p>
<pre class="calibre19">trait Map[K, +V] extends Iterable[(K, V)] with GenMap[K, V] with MapLike[K, V, Map[K, V]] </pre>
<p class="calibre2">As we've just shown, <kbd class="calibre11">Map</kbd> mixes in <kbd class="calibre11">Iterable</kbd> and <kbd class="calibre11">MapLike</kbd> traits, and <kbd class="calibre11">MapLike</kbd> extends the <kbd class="calibre11">PartialFunction</kbd> trait, so we can also use maps as a partial function. Also, it is worth noting the type parameters <kbd class="calibre11">K</kbd> and <kbd class="calibre11">V</kbd><em class="calibre18">.</em> Here, type <kbd class="calibre11">K</kbd> binds a key to value <kbd class="calibre11">V</kbd><em class="calibre18">.</em> Here's how we can define a <kbd class="calibre11">Map</kbd>:</p>
<pre class="calibre19">scala&gt; val aMap = Map("country" -&gt; "capital", "Poland" -&gt; "Warsaw") 
<br class="title-page-name"/>aMap: scala.collection.immutable.Map[String, String] = Map(country -&gt; capital, Poland -&gt; Warsaw) </pre>
<p class="calibre2">The preceding code is a map of type <kbd class="calibre11">string</kbd> to string, which means it maps a string key to a string value. As for any other collection, we need a few methods to access maps. There is more than one category for doing so. Let's go through them:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Associations and lookups</strong>: Methods that look up an element from a map:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">as.get(key)</kbd>, and <kbd class="calibre11">as(key)</kbd>, <kbd class="calibre11">as</kbd> contains key</li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Additions</strong>: Methods that adds key-value pairs to an existing map:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">as + (key -&gt; value)</kbd> and <kbd class="calibre11">as ++ kvs</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Removals</strong>: Methods that remove a pair from a given map:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">as - (key)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Sub-collections</strong>: Methods that return a sub-collection from a given map:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">as.keys</kbd>, <kbd class="calibre11">as.keySet</kbd>, and <kbd class="calibre11">as.values</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Transformations</strong>: Methods that transform a map by applying a function to each value of a given map:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">as mapValues func</kbd></li>
</ul>
</li>
</ul>
<p class="calibre2">A <kbd class="calibre11">Map</kbd> can have several different variants based on the category, whether it's mutable or immutable:</p>
<div class="cdpaligncenter"><img class="image-border9" src="../images/00023.jpeg"/></div>
<div class="cdpaligncenter1">Maps</div>
<p class="calibre2">In the preceding image, we have a couple of variants of maps in Scala. Did you notice that we have the same <kbd class="calibre11">HashMap</kbd> available in both the versions in different packages, <em class="calibre18">mutable</em> as well as <em class="calibre18">immutable</em>? We use these different maps depending on our requirements. After <kbd class="calibre11">Seq</kbd> and <kbd class="calibre11">Map</kbd>, there's another sub-trait of <kbd class="calibre11">Iterable</kbd>, named <kbd class="calibre11">Set</kbd><em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Set</h1>
                
            
            <article>
                
<p class="calibre2">A <kbd class="calibre11">Set</kbd> is a collection that contains multiple elements with no duplication at all:</p>
<pre class="calibre19">trait Set[A] extends (A) ⇒ Boolean with Iterable[A] with GenSet[A] with GenericSetTemplate[A, Set] with SetLike[A, Set[A]] </pre>
<p class="calibre2">As shown in the preceding code, the <kbd class="calibre11">Set extends (A) =&gt; Boolean</kbd> expression<em class="calibre18">,</em> which means that passing a parameter of type A to a set of type A will result in a Boolean. The Boolean result shows whether the <kbd class="calibre11">Set</kbd> contains the element passed as a parameter or not. Let's see this in an example:</p>
<pre class="calibre19">scala&gt; val aSet = Set(1,2,3,4) 
aSet: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4) 
 
scala&gt; aSet(2) 
res0: Boolean = true 
 
scala&gt; aSet(5) 
res1: Boolean = false 
 
scala&gt; aSet(0) 
res2: Boolean = false </pre>
<p class="calibre2">It can be seen that the value 2 is present in <kbd class="calibre11">aSet</kbd>, and the values 5 and 0 are not, so therefore passing 5 or 0 results in false. Let's go through a few methods defined in <kbd class="calibre11">Set</kbd>:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Comparisons and checks</strong>: Methods that check for a condition:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs.contains(x)</kbd>, and <kbd class="calibre11">xs.subsetOf(x)</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Additions</strong>: Methods that add an element or a collection of elements to a set:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs + x</kbd> and <kbd class="calibre11">xs ++ ys</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Removals</strong>: Methods that remove an element or collection of elements from a set:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs - x</kbd> and <kbd class="calibre11">xs -- ys</kbd></li>
</ul>
</li>
<li class="calibre8"><strong class="calibre1">Binary operations</strong>: Methods that perform binary operations between two different sets:
<ul class="calibre28">
<li class="calibre8">For example, <kbd class="calibre11">xs | ys</kbd>, <kbd class="calibre11">xs &amp; ys</kbd>, <kbd class="calibre11">xs</kbd> intersect <kbd class="calibre11">ys</kbd>, <kbd class="calibre11">xs</kbd> union <kbd class="calibre11">ys</kbd>, and so on</li>
</ul>
</li>
</ul>
<p class="calibre2">A <kbd class="calibre11">Set</kbd> can have several different variants based on whether it's mutable or immutable:</p>
<div class="cdpaligncenter"><img class="image-border10" src="../images/00024.jpeg"/></div>
<div class="cdpaligncenter1">Sets</div>
<p class="calibre2">A few variants of sets contain different types, such as <kbd class="calibre11">HashSet</kbd>, <kbd class="calibre11">BitSet</kbd>, and <kbd class="calibre11">SynchronizedSet</kbd>, and based on the need, we can utilize them.</p>
<p class="calibre2">Now that we have an idea of some top-level collection traits in Scala, let's take a look at some concrete implementations of them. We'll talk about the common collections we use in Scala, the way they can be constructed, and how Scala treats a particular collection when we add or remove an element. It'll give you a brief idea of how Scala collections behave.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Commonly used collections in Scala</h1>
                
            
            <article>
                
<p class="calibre2"><span>Let's</span> start  by discussing a few immutable concrete collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">List</h1>
                
            
            <article>
                
<p class="calibre2">A list is a linear sequence and can be defined simply, as follows:</p>
<pre class="calibre19">val aList = List(1,2,3,4) </pre>
<p class="calibre2">The syntax shown declares and instantiates the linear sequence with the elements provided. The runtime representation of the list constructed will look like this:</p>
<pre class="calibre19">1 :: 2 :: 3 :: 4 :: Nil </pre>
<p class="calibre2">Here, <kbd class="calibre11">Nil</kbd> represents the end of the list. It's normal to represent an empty list as <kbd class="calibre11">Nil</kbd>. The preceding representation is also a way to construct a list, and this is possible because of the "::" operator. This is called the <em class="calibre18">cons</em> operator, and it is used to construct a list. It's a right-associative operator:</p>
<pre class="calibre19">scala&gt; aList.::(5) 
res2: List[Int] = List(5, 1, 2, 3, 4) </pre>
<p class="calibre2">Calling the <em class="calibre18">cons</em> operator on the list results in a list with the new element added at the beginning of the list. This is equivalent to calling the same, using the following code:</p>
<pre class="calibre19">scala&gt; 5 :: aList<br class="title-page-name"/>res0: List[Int] = List(5, 1, 2, 3, 4)</pre>
<p class="calibre2">We've mentioned that operations such as adding an element to a list don't affect the list that was previously created, but it copies the same list to another, with an added element. The reason for this is that lists are immutable. A pictorial representation of how this might look will give you an insight into what is happening. So, let's take a look at this:</p>
<div class="cdpaligncenter"><img class="image-border11" src="../images/00025.jpeg"/></div>
<div class="cdpaligncenter1">Adding an element to a List</div>
<p class="calibre2">The figure is self-explanatory, and represents the concept of adding an element to a list. Lists provide many higher-order functions, such as <kbd class="calibre11">map</kbd>, <kbd class="calibre11">flatMap</kbd>, and <kbd class="calibre11">filter</kbd>, which make it easy to work with. With this construction syntax and easier access to the list's head (the first element of the list) and tail (which represents every element in the list except the first), it is easy to create patterns of lists and use them in pattern matching based on your needs. Operations such as <em class="calibre18">fold</em> and <em class="calibre18">reduce</em> are also of higher importance, as they provide a mechanism to perform binary operations on elements within the sequence. These are high-performing data structures, and provide constant time access to their elements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Map</h1>
                
            
            <article>
                
<p class="calibre2">The standard immutable map can be instantiated as easily as this:</p>
<pre class="calibre19">scala&gt; val aMap = Map(1 -&gt; "one", 2 -&gt; "two", 3 -&gt; "three") 
aMap: scala.collection.immutable.Map[Int,String] = Map(1 -&gt; one, 2 -&gt; two, 3 -&gt; three) </pre>
<p class="calibre2">We can provide as many key-value pairs as we want. We associate a key to its corresponding value by using the "-<em class="calibre18">&gt;" </em><span>operator</span><span> </span><em class="calibre18">.</em> <span>It can be seen that the default implementation of a map corresponds to</span> <kbd class="calibre11">scala.collection.immutable.Map[Int, String]</kbd>, <span>and it's not possible if we try to mutate the pairs. Though it's possible to add new pairs to construct another map with updated elements using the</span> <em class="calibre18">+ </em><span>method:</span></p>
<pre class="calibre19">scala&gt; aMap.+(4 -&gt; "four") 
res5: scala.collection.immutable.Map[Int, String] = Map(1 -&gt; one, 2 -&gt; two, 3 -&gt; three, 4 -&gt; four) </pre>
<p class="calibre2">But this will not change the map we declared <kbd class="calibre11">aMap</kbd>:</p>
<pre class="calibre19">scala&gt; println(aMap) 
Map(1 -&gt; one, 2 -&gt; two, 3 -&gt; three) </pre>
<p class="calibre2">We also discussed that map and sequences are also a <kbd class="calibre11">PartialFunction</kbd>, so we can check whether a value has been defined for a particular key:</p>
<pre class="calibre19">scala&gt; aMap.isDefinedAt(4) 
res8: Boolean = false 
 
scala&gt; aMap.isDefinedAt(2) 
res9: Boolean = true </pre>
<p class="calibre2">Other versions of <kbd class="calibre11">Map</kbd> also exist, such as <kbd class="calibre11">ListMap</kbd><em class="calibre18">,</em> and <kbd class="calibre11">SynchronizedMap</kbd><em class="calibre18">.</em> These can be used if you need them. For example, you might prefer to use a <kbd class="calibre11">ListMap</kbd> when you need to traverse linearly on a map with better performance. Also, when mutable map implementation is needed in a thread-safe manner, one would prefer to use <kbd class="calibre11">SynchronizedMap</kbd><em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">SortedSet</h1>
                
            
            <article>
                
<p class="calibre2">A <kbd class="calibre11">SortedSet</kbd> is a trait that represents a set of elements. It produces elements in a sorted manner based on ordering, because the default implementation stores elements in the form of a binary tree. One of the forms of <kbd class="calibre11">SortedSet</kbd> is a <kbd class="calibre11">TreeSet</kbd><em class="calibre18">.</em> Creating a <kbd class="calibre11">TreeSet</kbd> expects you to provide an implicit <kbd class="calibre11">Ordering[A]</kbd> that takes care of the way elements will be ordered:</p>
<pre class="calibre19">TreeSet()(implicit ordering: Ordering[A]) </pre>
<p class="calibre2">So, to create a <kbd class="calibre11">TreeSet</kbd>, we'll create an <kbd class="calibre11">Ordering</kbd> object in the current scope. Without <kbd class="calibre11">Ordering</kbd><em class="calibre18">,</em> the compiler won't allow you to create a <kbd class="calibre11">TreeSet</kbd>:</p>
<pre class="calibre19">package chapter5 
 
import scala.collection.immutable.TreeSet 
 
object TreeSetImpl extends App { 
 
  //implicit val ordering = Ordering.fromLessThan[Int](_ &gt; _) 
 
  val treeSet = new TreeSet() + (1, 3, 12, 3, 5) 
 
  println(treeSet) 
} </pre>
<p class="calibre2">Here is the result:</p>
<pre class="calibre19">Error:(9, 17) diverging implicit expansion for type scala.math.Ordering[T1] 
starting with method Tuple9 in object Ordering 
  val treeSet = new TreeSet() + (1, 3, 12, 3, 5) 
Error:(9, 17) not enough arguments for constructor TreeSet: (implicit ordering: Ordering[A])scala.collection.immutable.TreeSet[A]. 
Unspecified value parameter ordering. 
  val treeSet = new TreeSet() + (1, 3, 12, 3, 5) </pre>
<p class="calibre2">Uncommenting the line where we define an implicit value for <kbd class="calibre11">Ordering</kbd> will work fine. So, uncomment that and try running it. This will result in the following output:</p>
<pre class="calibre19">TreeSet(12, 5, 3, 1) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Streams</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre1">Streams</strong> are powerful. Let's see why. Streams can be of infinite length; it may sound impractical having a sequence of infinite length, but when the computation happens lazily, this works OK. Streams serve the same purpose and the computation happens lazily. Let's see how we can create streams:</p>
<pre class="calibre19">scala&gt; val aStream = Stream(1,2,3,4,55,6) 
aStream: scala.collection.immutable.Stream[Int] = Stream(1, ?) </pre>
<p class="calibre2">We didn't do anything extraordinary, except replace the <kbd class="calibre11">List</kbd> <span>keyword</span><span> </span><span>with <kbd class="calibre11">Stream</kbd>, but REPL gives us back something different:</span></p>
<pre class="calibre19">scala.collection.immutable.Stream[Int] = Stream(1, ?) </pre>
<p class="calibre2">You can see here that <kbd class="calibre11">Stream</kbd> is computed only till the very first element, because there's no need to go and compute other elements as of now. That's what we call <em class="calibre18">lazy computation.</em> Streams can also be constructed using <em class="calibre18">cons</em> like this:</p>
<pre class="calibre19">scala&gt; val anotherStream = 1 #:: 2 #:: 3 #:: Stream.empty 
anotherStream: scala.collection.immutable.Stream[Int] = Stream(1, ?) </pre>
<p class="calibre2">It's understandable that wherever we require our elements to compute lazily, we can use streams. One of the example use cases is when you require short-circuited evaluation from your function. You may pass a stream and evaluate. It's worth noting that a stream is not lazy with its head element, so your function will be evaluated for the first element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Vector</h1>
                
            
            <article>
                
<p class="calibre2">The difference between the performance of a linear sequence and an indexed sequence starts to matter when our requirement is to manipulate elements in the middle of a sequence. And because of the linear performance of sequences such as a list, the performance degrades for them. Therefore, indexed sequences come to the rescue! Vector is an example of an immutable indexed sequence. The way to create a vector is to simply use the <kbd class="calibre11">Vector</kbd> keyword with its <kbd class="calibre11">apply</kbd> method, or to simply represent it as follows:</p>
<pre class="calibre19">scala&gt; val vector = Vector(1,2,3) 
vector: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3) 
 
scala&gt; println(vector) 
Vector(1, 2, 3) </pre>
<p class="calibre2">To add elements to <kbd class="calibre11">vector</kbd>, we can use methods such as ":+" and "+:":</p>
<pre class="calibre19">scala&gt; vector :+ 4 
res12: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4) 
 
scala&gt; 4 +: vector  
res15: scala.collection.immutable.Vector[Int] = Vector(4, 1, 2, 3) </pre>
<p class="calibre2">These are indexed in order to retrieve a value by passing an index:</p>
<pre class="calibre19">scala&gt; vector(2) 
res16: Int = 3 </pre>
<p class="calibre2">We got the value 3, because the index starts from 0. It's good that we can check whether a value is defined at a particular index, because it is a sequence:</p>
<pre class="calibre19">scala&gt; vector.isDefinedAt(5) 
res17: Boolean = false </pre>
<p class="calibre2">It's possible to update an element at a certain position by using the <kbd class="calibre11">updated</kbd> method:</p>
<pre class="calibre19">scala&gt; vector.updated(2,10) 
res19: scala.collection.immutable.Vector[Int] = Vector(1, 2, 10) </pre>
<p class="calibre2">A call to this <kbd class="calibre11">updated</kbd> <span>method </span><span>with an index and an element replaces the element at the passed index with the element passed as a parameter. The good thing about this operation is that it takes constant time and doesn't affect the original sequence. Hence, if you try to print the sequence we created, you'll get the elements unchanged:</span></p>
<pre class="calibre19">scala&gt; println(vector) 
Vector(1, 2, 3) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Immutable stack</h1>
                
            
            <article>
                
<p class="calibre2">You may need a collection with <em class="calibre18">last in first out</em> traversal. For that, Scala provides the <kbd class="calibre11">stack</kbd> implementation. It's easy to create a stack, and <kbd class="calibre11">push</kbd> and <kbd class="calibre11">pop</kbd> elements in the stack:</p>
<pre class="calibre19">scala&gt; val stack = Stack(1,2,3) 
stack: scala.collection.immutable.Stack[Int] = Stack(1, 2, 3) 
 
scala&gt; stack.pop 
res24: scala.collection.immutable.Stack[Int] = Stack(2, 3) 
 
scala&gt; stack.push(4) 
res26: scala.collection.immutable.Stack[Int] = Stack(4, 1, 2, 3) </pre>
<p class="calibre2">Stacks are immutable, so performing any operation will not change the elements from the stack that was created previously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Immutable queue</h1>
                
            
            <article>
                
<p class="calibre2">For those who don't know it already, a queue is <em class="calibre18">first in first out</em> data structure. Two helper methods to put an element into a queue and remove them are <kbd class="calibre11">enqueue</kbd> and <kbd class="calibre11">dequeue</kbd><em class="calibre18">.</em> Let's create a queue:</p>
<pre class="calibre19">scala&gt; val queue = Queue(1,2,3) 
queue: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3) 
 
scala&gt; queue.enqueue(4) 
res27: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3, 4) 
 
scala&gt; queue.dequeue 
res28: (Int, scala.collection.immutable.Queue[Int]) = (1,Queue(2, 3)) </pre>
<p class="calibre2">The preceding code is the method for enqueuing an element in a queue. It can be seen that <kbd class="calibre11">dequeue</kbd> returns the element removed along with the rest of the queue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ranges</h1>
                
            
            <article>
                
<p class="calibre2">Range describes a range of numbers. There are a few helper methods we can use to create a range in Scala. Let's take a look at them:</p>
<pre class="calibre19">scala&gt; val oneTo10 = 1 to 10 
oneTo10: scala.collection.immutable.Range.Inclusive = Range 1 to 10 
 
scala&gt; val oneTo10By2 = 1 to 10 by 2 
oneTo10By2: scala.collection.immutable.Range = inexact Range 1 to 10 by 2 
 
scala&gt; oneTo10 foreach println 
1 
2 
3 
4 
. . . remaining elements 
 
scala&gt; oneTo10By2 foreach println 
1 
3 
5 
7 
9 </pre>
<p class="calibre2">We created two ranges. The first one simply contains numbers ranging from 1 to 10, inclusive. Then we created numbers ranging from 1 to 10 with a step size of 2. There's also a way to create a range that does not include the last element. This can be done using the <kbd class="calibre11">util</kbd> method:</p>
<pre class="calibre19">scala&gt; val oneUntil5 = 1 until 5 
oneUntil5:scala.collection.immutable.Range = Range 1 until 5 
 
scala&gt; oneUntil5 foreach println 
1 
2 
3 
4 </pre>
<p class="calibre2">Here, we created a range using the <kbd class="calibre11">Until</kbd> method containing numbers 1 to 5. Printing this range yielded the numbers from 1 to 4, because <kbd class="calibre11">Until</kbd> does not include the last element. <kbd class="calibre11">Range</kbd> is also an immutable collection. Now, after going through these immutable collections, let's take a look at few mutable concrete collections. We'll start with the most common, <kbd class="calibre11">ArrayBuffer</kbd><em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ArrayBuffer</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">ArrayBuffer</kbd> is only available as a mutable sequence in Scala. These are efficient collections; they make it easy to add an element at the end of a collection. <kbd class="calibre11">ArrayBuffer</kbd> is also an indexed sequence, so retrieving an element via an index doesn't degrade the performance. Let's see how we can create and use <kbd class="calibre11">ArrayBuffer</kbd> in Scala:</p>
<pre class="calibre19">scala&gt; import scala.collection.mutable._ 
import scala.collection.mutable._ 
 
scala&gt; val buff = ArrayBuffer(1,2,3) 
buff: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)  
 
scala&gt; println(buff) 
ArrayBuffer(1, 2, 3) </pre>
<p class="calibre2">We can create <kbd class="calibre11">ArrayBuffer</kbd> by first importing the <kbd class="calibre11">scala.collection.mutable</kbd><em class="calibre18"> </em><span>package.</span><span> We can instantiate it by providing elements in the constructor. We can add </span><span>and remove </span><span>elements to the buffer using methods provided for</span> <kbd class="calibre11">ArrayBuffer</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">scala&gt; buff += 4 
res35: buff.type = ArrayBuffer(1, 2, 3, 4) 
 
scala&gt; println(buff) 
ArrayBuffer(1, 2, 3, 4) 
 
scala&gt; buff -= 4 
res36: buff.type = ArrayBuffer(1, 2, 3) 
 
scala&gt; println(buff) 
ArrayBuffer(1, 2, 3) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ListBuffer</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">ArrayBuffer</kbd> uses an array to store elements <span>internally</span><span>, whereas </span><kbd class="calibre11">ListBuffer</kbd> <span>uses a linked list representation. Operations performed on these buffers are similar to that of</span> <kbd class="calibre11">ArrayBuffers</kbd>:</p>
<pre class="calibre19">scala&gt; val listBuffer = ListBuffer("Alex", "Bob", "Charles") 
listBuffer: scala.collection.mutable.ListBuffer[String] = ListBuffer(Alex, Bob, Charles) 
 
scala&gt; listBuffer += "David" 
res39: listBuffer.type = ListBuffer(Alex, Bob, Charles, David) 
 
scala&gt; println(listBuffer) 
ListBuffer(Alex, Bob, Charles, David) </pre>
<p class="calibre2">It's worth noting that because of the internal linked list representation, it's recommended to use <kbd class="calibre11">ListBuffer</kbd> instead of <kbd class="calibre11">ArrayBuffer</kbd> if our requirement is to convert our collection to a list. It's applicable vice versa, if the requirement is to convert our collection to an array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">StringBuilder</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">StringBuilder</kbd> is used to build a sequence of strings. A simple call to <kbd class="calibre11">toString</kbd> will convert it to <kbd class="calibre11">String</kbd>:</p>
<pre class="calibre19">scala&gt; val builder = new StringBuilder 
builder: StringBuilder = 
 
scala&gt; builder ++= "aa" 
res45: builder.type = aa 
 
scala&gt; builder ++= "b" 
res46: builder.type = aab 
 
scala&gt; builder.toString 
res48: String = aab </pre>
<p class="calibre2">There're other mutable versions of stacks, queues, and maps. There are methods provided to update these mutable collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Array</h1>
                
            
            <article>
                
<p class="calibre2">Array in Scala is defined as follows; it extends the <kbd class="calibre11">Serializable</kbd> and <kbd class="calibre11">Cloneable</kbd> traits from Java. Also, it can be seen that arrays are generic:</p>
<pre class="calibre19">final class Array[T] extends java.io.Serializable with java.lang.Cloneable </pre>
<p class="calibre2">In Scala, arrays are mutable. Defining an array is simple:</p>
<pre class="calibre19">scala&gt; val array = Array("about", "to", "declare") 
array: Array[String] = Array(about, to, declare) </pre>
<p class="calibre2">Here, it's possible to perform the operations that we perform on sequences. Arrays are indexed and mutable as well:</p>
<pre class="calibre19">scala&gt; array(0) = "Where" 
 
scala&gt; array foreach println 
Where 
to 
declare </pre>
<p class="calibre2">It's also possible to perform map operations on an array, which makes Scala's arrays better than their Java counterparts.</p>
<p class="calibre2">Up to now, we have introduced all the common collections, and have a basic idea about how these collections can be declared and used. But what makes Scala collections powerful is the set of rich operations performed on these collections. There's a set of operations that can be performed using some higher-order methods available with these collections. It's time to go and take a look at those.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rich operations performed on collections</h1>
                
            
            <article>
                
<p class="calibre2">We have quite a few methods for our collections, which we can use to simplify almost every problem regarding collections in Scala. We are going to take a look at some important methods. First, let's set the stage: so consider a scenario where you have some structured data related to football players. and you have to perform manipulations based on that. We'll perform a set of operations on the data using our collection. We'll also learn about methods, their signatures, and use cases along the way. Here's a simple code snippet that shows what we just said—nothing too interesting as of now:</p>
<pre class="calibre19">package chapter5 
 
object CollectionOperations extends App { 
 
  val source = io.Source.fromFile("../src/chapter5/football_stats.csv")   // Give pathString for the csv file 
 
} </pre>
<p class="calibre2">Here's the thing—we have a CSV file that contains some data as comma-separated values. We can read the data in our program as a <kbd class="calibre11">BufferredSource</kbd>:</p>
<pre class="calibre19">io.Source.fromFile("filePath") </pre>
<p class="calibre2">This will load the CSV file's contents. The first thing we can do is to convert the data into a readable format so that it gets easier for us to perform any operation on it. For that, we have a case class, <kbd class="calibre11">Player</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">case class Player(name: String, nationality: String, age: String, club: String, domesticLeague: String, rawTotal: String, finalScore: String, ranking2016: String, ranking2015: String) </pre>
<p class="calibre2">We'll try to read the content from the file and create a collection of players. The following expression reads from the buffered source, and converts each line to an element in a <kbd class="calibre11">List</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">source.getLines().toList </pre>
<p class="calibre2">Here, the <kbd class="calibre11">getLines</kbd> method converts the buffered source to an <kbd class="calibre11">Iterator</kbd> object of string type. A call to the <kbd class="calibre11">toXXX</kbd> form of the method can be used to convert between <em class="calibre18">traversables.</em> We've made a call to the <kbd class="calibre11">toList</kbd> method on our <kbd class="calibre11">Iterator</kbd> object. This converts the <em class="calibre18">Iterable</em> of type string to a list of strings. There are other versions such as <kbd class="calibre11">toIterable</kbd><em class="calibre18">,</em> <kbd class="calibre11">toSeq</kbd><em class="calibre18">,</em> <kbd class="calibre11">toIndexedSeq</kbd><em class="calibre18">,</em> <kbd class="calibre11">toBuffer</kbd><em class="calibre18">,</em> <kbd class="calibre11">toSet</kbd><em class="calibre18">,</em> and <kbd class="calibre11">toVector</kbd><em class="calibre18">.</em> All these methods reside in a trait named <kbd class="calibre11">TraversableOnce</kbd><em class="calibre18">.</em></p>
<p class="calibre2">We can use the <kbd class="calibre11">toXXX</kbd> method to convert into another Traversable of type <kbd class="calibre11">XXX</kbd>, where <kbd class="calibre11">XXX</kbd> is a placeholder for <kbd class="calibre11">Set</kbd>, <kbd class="calibre11">Vector</kbd>, <kbd class="calibre11">Buffer</kbd>, and so on.</p>
<p class="calibre2">After reading the content from the CSV file, we <span>now</span><span> </span><span>have a list of strings, with each string containing information about a player in the following format:</span></p>
<pre class="calibre19">2016,Up/down,2015,2014,2013,Name,Nationality, Club at Dec 20 2016,Domestic league, Age at 20 Dec 2016,RAW TOTAL,HIGHEST SCORE REMOVED,FINAL SCORE,VOTES CAST,No1 PICK </pre>
<p class="calibre2">Each line has information such as the ranking of the player in the past few years, his/her name, nationality, club, <span>points</span><span> </span><span>scored, and age. We'll parse the string and map all the information to our</span> <kbd class="calibre11">Player</kbd> <span>object. Let's do it:</span></p>
<pre class="calibre19">def giveMePlayers(list: List[String]): List[Player] = list match { 
    case head :: tail =&gt; tail map {line =&gt; 
      val columns = line.split((",")).map(_.trim) 
      Player(columns(5),columns(6),columns(9),columns(7), 
        columns(8),columns(10), columns(12), columns(0),columns(2)) 
    } 
    case Nil =&gt; List[Player]() 
  } </pre>
<p class="calibre2">In this method, we see one important method that works for collections. Our <kbd class="calibre11">giveMePlayers</kbd> <span>function</span><span> </span><span>parses the list of string, and as its name suggests, it returns a list of players. The function performs a pattern match on the list of strings. We have matched the list as</span> <kbd class="calibre11">head :: tail</kbd>; <span>it treats the head as the first element of the list, and the tail as the rest of the elements. It can also be seen that the list can be empty; in that case, the second scenario will be executed, and the function will return an empty list. As we know from the CSV, the first line contains the meta-information about the rest of the file. So we omit the</span> <kbd class="calibre11">head</kbd> <span>and perform a</span> <kbd class="calibre11">map</kbd> <span>operation on</span> <kbd class="calibre11">tail</kbd><span>, that is, the rest of the list. The</span> <kbd class="calibre11">map</kbd><span> </span><span>method</span><span> </span><span>basically performs the given operation on each element and returns the collection with the resulting values. In our case, we're splitting the comma-separated values from each line and converting values to the </span><kbd class="calibre11">Player</kbd> <span>object. At the end of the call to the </span><kbd class="calibre11">map</kbd> <span>method, we'll get a list of players.</span></p>
<p class="calibre2">The <kbd class="calibre11">map</kbd> method composes another collection, applying an operation passed to it.</p>
<p class="calibre2">The definition of the <kbd class="calibre11">map</kbd> method looks as follows:</p>
<pre class="calibre19">def map[B](f: (A) ⇒ B): Traversable[B] </pre>
<p class="calibre2">The <kbd class="calibre11">map</kbd> method takes a function that converts type <kbd class="calibre11">A</kbd> to type <kbd class="calibre11">B</kbd>, and performs that operation to each element of the collection, and finally returns a collection of type B. In our case, types <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd> were <kbd class="calibre11">String</kbd> and <kbd class="calibre11">Player</kbd><em class="calibre18">.</em></p>
<p class="calibre2">At this point, our code looks like this:</p>
<pre class="calibre19">package chapter5 
 
object CollectionOperations extends App { 
 
  val source = io.Source.fromFile("/Users/vika/Documents/LSProg/LSPWorkspace/FirstProject/src/chapter5/football_stats.csv") 
  val bufferedSourceToList: List[String] = { 
    val list = source.getLines().toList 
    source.close() 
    list 
  } 
 
  def giveMePlayers(list: List[String]): List[Player] = list match { 
      case head :: tail =&gt; tail map {line =&gt; 
        val columns = line.split((",")).map(_.trim) 
        Player(columns(5),columns(6),columns(9),columns(7), 
          columns(8),columns(10), columns(12), columns(0),columns(2)) 
      } 
      case Nil =&gt; List[Player]() 
    } 
 
  val players = giveMePlayers(bufferedSourceToList)} 
 
case class Player(name: String, nationality: String, age:String, club: String, domesticLeague: String, rawTotal: String, finalScore: String, ranking2016: String, ranking2015: String) </pre>
<p class="calibre2">Now, we have a fully formed collection of <kbd class="calibre11">Players</kbd>, thanks to our <kbd class="calibre11">map</kbd> method. We can perform lots and lots of different operations. We can make a list of top 10 players. How can this be done? By using our <kbd class="calibre11">filter</kbd> method:</p>
<pre class="calibre19">val filterTop10 = players filter(_.ranking2016.toInt &lt; 11)</pre>
<p class="calibre2">This is simple; it's just a call to filter, then we tell it what predicate to filter elements upon. It'll do the filtering for you. We have checked the ranking for each player and preserved those for whom the value is less than 11:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">filter</kbd> method filters the collection elements that satisfy the predicate</li>
<li class="calibre8">The <kbd class="calibre11">filterNot</kbd> method filters the collection elements that do not satisfy the predicate</li>
</ul>
<p class="calibre2">The signature of the <kbd class="calibre11">filter</kbd> method looks as follows:</p>
<pre class="calibre19">def filter(p: A =&gt; Boolean): Repr </pre>
<p class="calibre2">This <kbd class="calibre11">filter</kbd> method takes a predicate, based on the predicate. The method filters out the Traversable. Here, <kbd class="calibre11">Repr</kbd> is a type parameter for the collection, and our Traversable collection looks like <kbd class="calibre11">TraversableLike[+A, +Repr]</kbd>.</p>
<p class="calibre2">To check whether the method filters out the right players, you may want to print it and see. Why not print our players in some structured way? Take a look at the following code:</p>
<pre class="calibre19">def showPlayers(players: List[Player]) = players.foreach{p =&gt; 
  <span>println</span>(<span>s"""Player: </span><span>$</span>{p.name}<span>    Country: </span><span>$</span>{p.nationality}<span>   Ranking 2016: </span><span>$</span>{p.ranking2016}<span><br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>***** Other Information *****<br class="title-page-name"/></span><span>Age: </span><span>$</span>{p.age}<span>  |  Club: </span><span>$</span>{p.club}<span>  |  Domestic League: </span><span>$</span>{p.domesticLeague}<span><br class="title-page-name"/></span><span>Raw Total: </span><span>$</span>{p.rawTotal}<span>  |  Final Score: </span><span>$</span>{p.finalScore}<span>  |  Ranking 2015: </span><span>$</span>{p.ranking2015}<span><br class="title-page-name"/></span><span>##########################################################"""</span>)<br class="title-page-name"/> }</pre>
<p class="calibre2">We have defined the <kbd class="calibre11">showPlayers</kbd> <span>function,</span><span> which</span><span> takes a list and prints player information in the following manner:</span></p>
<pre class="calibre19">Player: Cristiano Ronaldo  Country: Portugal       Ranking 2016: 1  
 
***** Other Information *****  
Age: 32  |  Club: Real Madrid  |  Domestic League: Spain  
Raw Total: 4829  |  Final Score: 4789  |  Ranking 2015: 2 
########################################################## </pre>
<p class="calibre2">I think you're keen enough to see that the filter traverses through the whole list to check whether the ranking is less than 11, bravo! Also, understand that this is not the way we would do this to our collection if the list were sorted. In that case, we've a few other methods, and one of them is <kbd class="calibre11">takeWhile</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">val takeTop10 = players takeWhile(_.ranking2016.toInt &lt; 11) </pre>
<p class="calibre2">This <kbd class="calibre11">takeWhile</kbd> <span>method</span><span> </span><span>also takes a predicate, the same in our case, and returns a list of elements for which the predicate is true. In our case, it works, and we get the top 10 players:</span></p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">takeWhile</kbd> method takes the longest sub-collection of elements that satisfies the predicate</li>
<li class="calibre8">The <kbd class="calibre11">dropWhile</kbd> method drops the longest sub-collection of elements that satisfies the predicate</li>
</ul>
<p class="calibre2">The signature looks almost exactly like our <kbd class="calibre11">filter</kbd> method. It takes a predicate, and returns a Traversable:</p>
<pre class="calibre19">def takeWhile(p: (A) ⇒ Boolean): Traversable[A] 
 
def dropWhile(p: (A) ⇒ Boolean): Traversable[A] </pre>
<p class="calibre2">There's also a <kbd class="calibre11">dropWhile</kbd> version of the method. Its intent is almost the same as <kbd class="calibre11">takeWhile</kbd>; the only thing that differs is that it drops those elements that satisfy the predicate. There can be more of this sort of method, based on the requirements we can use. One of them is the <kbd class="calibre11">partition</kbd> method, which splits apart our list into a tuple of two lists: one that satisfies the predicate, and other that doesn't. Take a look at the following code snippet:</p>
<pre class="calibre19">val first50Players = players take 50 
val (top20,least30) = first50Players partition(_.ranking2016.toInt &lt; 21) 
showPlayers(top20) </pre>
<p class="calibre2">First, the <kbd class="calibre11">take</kbd><em class="calibre18"> </em><span>method</span><span> selects 50 players from our list of</span> <em class="calibre18">players.</em> <span>Then, we call the </span><kbd class="calibre11">partition</kbd> <span>method on our first 50 players, whic</span>h splits our list int<span>o two sub-lists based on the predicate we pass. Here, we want to divide the first 50 players into two separate collections of 20 and 30 players. After calling this function, we get two new values, </span><kbd class="calibre11">top20</kbd> <span>and</span> <kbd class="calibre11">least30</kbd><span>, which have the top 20 players and the bottom 30 players out of the first 50.</span></p>
<p class="calibre2"><span>A simple one-liner can do this much with the collection of elements; that's the power of Scala collections:</span></p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">take</kbd> method selects the first <kbd class="calibre11">n</kbd> elements from the collection</li>
<li class="calibre8">The <kbd class="calibre11">drop</kbd> method drops the first <kbd class="calibre11">n</kbd> elements from the collection</li>
<li class="calibre8">The <kbd class="calibre11">partition</kbd> method drops the first <kbd class="calibre11">n</kbd> elements from the collection</li>
</ul>
<p class="calibre2">The signatures of these methods are simple:</p>
<pre class="calibre19">def drop(n: Int): Traversable[A] 
 
def take(n: Int): Traversable[A] 
 
def partition(p: (A) ⇒ Boolean): (Traversable[A], Traversable[A]) </pre>
<p class="calibre2">The <kbd class="calibre11">take</kbd> and <kbd class="calibre11">drop</kbd> methods take the number of elements to select or drop. The other method, <kbd class="calibre11">partition</kbd>, expects a predicate, splits the collection into two sub-collections, and returns a tuple of those two sub-collections. There are a few more of these methods; let's take a look at them:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">slice</kbd> method selects an interval of elements</li>
<li class="calibre8">The <kbd class="calibre11">span</kbd> method splits the collection into two collections based on the predicate, where the order of elements is not preserved</li>
<li class="calibre8">The <kbd class="calibre11">splitAt</kbd> method splits a collection at a given position</li>
</ul>
<p class="calibre2">These methods are simple, as they do exactly what their description implies. Their description also explains the same:</p>
<pre class="calibre19">def slice(from: Int, until: Int): Traversable[A] 

def span(p: (A) ⇒ Boolean): (Traversable[A], Traversable[A]) <br class="title-page-name"/> 
def splitAt(n: Int): (Traversable[A], Traversable[A]) </pre>
<p class="calibre2">The <kbd class="calibre11">slice</kbd> method takes the initial and last index, and returns that number of elements as a collection. The second method, <kbd class="calibre11">span</kbd>, works exactly the same as the <kbd class="calibre11">partition</kbd> method. It takes a predicate and returns a pair of collections: the first satisfies the predicate, and second does not. It's possible that the order of elements has not been preserved.</p>
<p class="calibre2">The last of the three, <kbd class="calibre11">splitAt</kbd>, takes a value <kbd class="calibre11">n</kbd> and returns a pair of sub-collections, split at <kbd class="calibre11">n</kbd>. These methods make it easy to implement scenarios such as this:</p>
<pre class="calibre19">Select Players from Germany who have ranking in Top 50. 
 
first50Players filter(_.nationality.equals("Germany")) </pre>
<p class="calibre2">Let's take a look at one more set of methods, using which we can check for a predicate in our collection:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">count</kbd> method counts the number of elements that satisfy a given predicate</li>
<li class="calibre8">The <kbd class="calibre11">exists</kbd> method checks whether a predicate holds true for even a single element in a given collection</li>
<li class="calibre8">The <kbd class="calibre11">forAll</kbd> method checks whether a predicate holds true for all elements in a given collection</li>
<li class="calibre8">The <kbd class="calibre11">find</kbd> method finds the first element that satisfies a predicate</li>
</ul>
<p class="calibre2">We can count the number of players from a particular country like this: </p>
<pre class="calibre19">val isGermanPlayer: (Player =&gt; Boolean) = _.nationality.equalsIgnoreCase("Germany") 
 
val numberOfGermanPlayers = players count isGermanPlayer 
println(s"German Players: $numberOfGermanPlayers") 
 
Run: 
German Players: 17 </pre>
<p class="calibre2">The partial function <kbd class="calibre11">isGermanPlayer</kbd> checks for a player's nationality. We then passed this partial function as a predicate to the <kbd class="calibre11">count</kbd><em class="calibre18"> </em><span>method</span><em class="calibre18">,</em> <span>which gives the number of players. We may also want to check whether there are any players with an age above 45, and we may check that using the </span><kbd class="calibre11">exists</kbd> <span>method:</span></p>
<pre class="calibre19">val isAnyPlayerAbove45 = players exists(p =&gt; p.age.toInt &gt; 40) 
println(s"isAnyPlayerAbove45: $isAnyPlayerAbove45") 
 
Run: 
isAnyPlayerAbove45: false </pre>
<p class="calibre2">The are two other methods, <kbd class="calibre11">forAll</kbd> and <kbd class="calibre11">find</kbd><em class="calibre18">.</em> We'll check the top player with an age of more than 35 years:</p>
<pre class="calibre19">val topPlayerWithAge35plus = players find(p =&gt; p.age.toInt &gt; 35) 
printPlayer(topPlayerWithAge35plus.get) 
 
Run: 
Player: Zlatan Ibrahimovic       Country: Sweden   Ranking 2016: 20  
 
***** Other Information *****  
Age: 36  |  Club: Manchester United  |  Domestic League: England  
Raw Total: 1845  |  Final Score: 1809  |  Ranking 2015: 7 
########################################################## </pre>
<p class="calibre2">These methods are simple yet powerful, and composing them can bring down our solution approach to easy. Let's find the top 5 players by ranking, with ages over 35:</p>
<pre class="calibre19">val top5PlayerWithAge35plus = players filter isAge35plus take 5 
showPlayers(top5PlayerWithAge35plus) 
 
Run: 
Player: Zlatan Ibrahimovic       Country: Sweden   Ranking 2016: 20  
 
***** Other Information *****  
Age: 36  |  Club: Manchester United  |  Domestic League: England  
Raw Total: 1845  |  Final Score: 1809  |  Ranking 2015: 7 
########################################################## 
. . . and next 4 player information </pre>
<p class="calibre2">One of the examples is where we first called the <kbd class="calibre11">filter</kbd> method on our list of players, then called take 5 to select first 5 from results. We've seen these examples, so let's take a look at the definitions of these methods:</p>
<pre class="calibre19">def find(p: (A) ⇒ Boolean): Option[A] 
 
def count(p: (A) ⇒ Boolean): Int 
 
def exists(p: (A) ⇒ Boolean): Boolean 
 
def forall(p: (A) ⇒ Boolean): Boolean </pre>
<p class="calibre2">All methods take a predicate and respond differently. The <kbd class="calibre11">find</kbd> <span>method</span><span> </span><span>selects the very first element from a collection for which the predicate is satisfied. The next ones,</span> <kbd class="calibre11">count</kbd> <span>and</span> <kbd class="calibre11">exists</kbd><span>, check for the total number of elements that satisfy the predicate, and whether any single element for which the predicate is satisfied exists, respectively.</span></p>
<p class="calibre2"><span>Finally, the </span><kbd class="calibre11">forAll</kbd> <span>method checks whether the predicate is satisfied for all elements in the collection.</span> We can also call for a check if there's any element in our list using <kbd class="calibre11">isEmpty</kbd>, because it's obvious your filter on a collection results is an empty list. There're few methods to use to check information about the list:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">isEmpty</kbd> method counts the number of elements that satisfy a given predicate</li>
<li class="calibre8">The <kbd class="calibre11">hasDefiniteSize</kbd> method checks whether a predicate holds true for even a single element in a given collection</li>
<li class="calibre8">The <kbd class="calibre11">size</kbd> method checks whether a predicate holds true for all elements in a given collection</li>
</ul>
<p class="calibre2">These methods, as their names suggest, are simple to use and clear to understand as well. You remember we did a pattern match on a list using <kbd class="calibre11">head :: tail</kbd>? Well, we can also call these methods on our collection in the same way. There exists a few more utility methods to access list elements:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">head</kbd> method returns the head element of the collection</li>
<li class="calibre8">The <kbd class="calibre11">tail</kbd> method returns all elements except the head element</li>
<li class="calibre8">The <kbd class="calibre11">init</kbd> method returns all but the last element</li>
<li class="calibre8">The <kbd class="calibre11">last</kbd> method returns the last element of the collection</li>
<li class="calibre8">The <kbd class="calibre11">reverse</kbd> method returns the list in reverse</li>
</ul>
<p class="calibre2">We can use these methods while doing a pattern match, or whenever we may have to retrieve the first or last elements. Using the <kbd class="calibre11">init</kbd> or <kbd class="calibre11">tail</kbd> methods recursively is also a way to utilize list elements. Finally, one of the most important operations we can perform on a list of elements is to fold or reduce the list into a value—a single value. So, we can fold our list of players and construct another list of country names from that. How we can do this? Let's take a look at how we can use <kbd class="calibre11">fold</kbd> operations:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">fold</kbd> method folds collections using a binary associative operation</li>
<li class="calibre8">The <kbd class="calibre11">foldLeft</kbd> method folds collections by applying a binary operation to the initial, and then each element going from left to right</li>
<li class="calibre8">The <kbd class="calibre11">foldRight</kbd> method <span>folds collections by applying a binary operation to the initial, and then each element going from right to left</span></li>
</ul>
<p class="calibre2">Suppose we want to construct a list of country names from our top 20 players' information. We can do this as follows:</p>
<pre class="calibre19">val Top20Countries = top20.foldLeft(List[String]())((b,a) =&gt; a.nationality :: b)</pre>
<p class="calibre2">We'll get the following on running the code:</p>
<pre class="calibre19">List(Sweden, England, Germany, France, France, Spain, Argentina, Belgium, Croatia, Argentina, Algeria, Chile, Gabon, Poland, Wales, Brazil, France, Uruguay, Argentina, Portugal)</pre>
<p class="calibre2">This can also be done by going from right to left through the list:</p>
<pre class="calibre19">val top20Countries = top20.foldRight(List[String]())((b,a) =&gt; b.nationality :: a) </pre>
<p class="calibre2"><span>We'll get the following on running the code</span>:</p>
<pre class="calibre19">List(Portugal, Argentina, Uruguay, France, Brazil, Wales, Poland, Gabon, Chile, Algeria, Argentina, Croatia, Belgium, Argentina, Spain, France, France, Germany, England, Sweden) </pre>
<p class="calibre2">The definition of the <kbd class="calibre11">fold</kbd> methods look as follows:</p>
<pre class="calibre19">def foldLeft[B](z: B)(op: (B, A) ⇒ B): B 
 
def foldRight[B](z: B)(op: (A, B) =&gt; B): B </pre>
<p class="calibre2">The method takes an initial value; in our case, it's a list. Then we pass a function that works on each element from our collection, and the value passed works as a seed to our operator function. The <kbd class="calibre11">foldLeft</kbd> and <kbd class="calibre11">foldRight</kbd> <span>methods</span><span> </span><span>perform a binary operation on these two elements until it processes the last element in the collection, thus producing the final value for us. If you take a look at both of these methods, you'll be able to see that the order of parameters has changed. Also, the signatures of these</span> <kbd class="calibre11">foldLeft</kbd> <span>and</span> <kbd class="calibre11">foldRight</kbd> <span>methods are curried. The first curried parameter is the initial element, which works as an accumulator as we traverse through or fold our collection. The second parameter, which is a binary function, takes place and is applied to collection elements. This <kbd class="calibre11">fold</kbd> function results in one value over a collection that's an accumulated response for the whole collection.</span></p>
<p class="calibre2">After working with all these methods that make it easier to work with collections, let's take a look at a method that can convert our collection to a parallel collection, which can be processed in parallel. The method is <kbd class="calibre11">par</kbd><em class="calibre18">:</em> when you call the method on our collection, it returns a <kbd class="calibre11">ParSeq</kbd><em class="calibre18">, </em>that is, a parallel sequence. This parallel sequence is a parallel equivalent of our collection.</p>
<p class="calibre2">If you try to print the elements from this sequence quite a few times, the order will not be preserved, because of the parallel nature of the sequence:</p>
<pre class="calibre19">top20Countries.par map(println(_)) </pre>
<p class="calibre2"><span>We'll get the following on running the code</span><span>: </span></p>
<pre class="calibre19">Wales 
Portugal 
Argentina 
France 
Croatia 
Argentina 
Poland 
France 
Uruguay 
. .. remaining elements </pre>
<p class="calibre2">Now that we know we can convert our collections into their parallel equivalents, there should be other ways to build parallel collections. Let's go through parallel collections in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Parallel collections in Scala</h1>
                
            
            <article>
                
<p class="calibre2">It's obvious that if the number of elements in a collection is very large, then you would want to minimize the time it takes to manipulate the collection data. That's where breaking down the tasks and executing them parallel is an option, and a good one. Scala provides parallelism in the form of parallel collections, which works like a charm in scenarios where we have to deal with a big chunk of data. The good thing is that our  <kbd class="calibre11">par</kbd> <span>method </span><span>can easily convert a normal sequential collection to its parallel counterpart implicitly, and the</span> <kbd class="calibre11">map</kbd><em class="calibre18">,</em> <kbd class="calibre11">fold</kbd><span>, and</span> <kbd class="calibre11">filter</kbd><span> </span><span>methods</span><span> </span><span>work great with parallel collections as well.</span></p>
<p class="calibre2">Understanding the architecture of parallel collections, or how these work on JVM, is out of the scope of this book. We'll keep our discussion limited to concrete implementations of parallel collections, and how we can use them in Scala. If you're into understanding parallel collections, Scala's documentation gives a brief overview at <a href="http://docs.scala-lang.org/overviews/parallel-collections/overview" class="calibre10">http://docs.scala-lang.org/overviews/parallel-collections/overview</a>. Another resource is the book <em class="calibre18">Learning Concurrent Programming in Scala</em> by Aleksandar Prokopec<em class="calibre18">.</em> For now, let's start with the concrete implementations of parallel collections in Scala. There are a few parallel collection classes, such as <kbd class="calibre11">ParArray</kbd><em class="calibre18">,</em> <kbd class="calibre11">ParVector</kbd><em class="calibre18">,</em> and <kbd class="calibre11">ParRange</kbd><em class="calibre18">,</em> and also a few <kbd class="calibre11">set</kbd> and <kbd class="calibre11">map</kbd> implementations such as <kbd class="calibre11">ParHashMap</kbd> and <kbd class="calibre11">ParHashSet</kbd><em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ParArray</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">ParArray</kbd> constructor is the parallel implementation of <kbd class="calibre11">ArraySeq</kbd>, and holds elements in a linear fashion. It resides in the <kbd class="calibre11">scala.collection.parallel.mutable</kbd> package. To create a parallel array, we can import this package as follows:</p>
<pre class="calibre19">scala&gt; import scala.collection.parallel.mutable._ 
import scala.collection.parallel.mutable._ 
 
scala&gt; val pararr = ParArray(1,2,3,4,5,6,7,8,9,10) 
pararr: scala.collection.parallel.mutable.ParArray[Int] = ParArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) </pre>
<p class="calibre2">Here, we have created a parallel array named <kbd class="calibre11">pararr</kbd> by simply using the <kbd class="calibre11">ParArray</kbd> constructor, with elements passed as arguments. For demonstration purposes, we're using a limited number of elements in our implementation, but it's obvious we would like parallel abstractions to contain a higher number of elements to really work effectively. It's also possible to convert a parallel collection into its sequential counterpart using the <kbd class="calibre11">seq</kbd> method:</p>
<pre class="calibre19">scala&gt; pararr.seq 
res1: scala.collection.mutable.ArraySeq[Int] = ArraySeq(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) </pre>
<p class="calibre2">A parallel array is a parallel mutable collection. We also have immutable versions of parallel collections. <kbd class="calibre11">ParVector</kbd> is one of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ParVector</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">ParVector</kbd> is an immutable parallel sequence. We can create a parallel vector in a similar fashion to how we created a parallel array:</p>
<pre class="calibre19">scala&gt; val parvec = Vector(1,2,3,4,5,6,7,8,9,10) 
parvec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) </pre>
<p class="calibre2">We can perform the same operations using methods such as <kbd class="calibre11">map</kbd><em class="calibre18">,</em> which we can use from its sequential counterpart. Let's take integers that are greater than 5 from our <kbd class="calibre11">parvec</kbd> parallel vector:</p>
<pre class="calibre19">scala&gt; parvec.filter(_ &gt; 5) 
res0: scala.collection.immutable.Vector[Int] = Vector(6, 7, 8, 9, 10) 
 
And yes we can anytime convert our collection to it's sequential version using seq method. 
 
scala&gt; parvec.seq 
res1: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) </pre>
<p class="calibre2">In a similar fashion, we can also create <kbd class="calibre11">ParHashSet</kbd> and <kbd class="calibre11">ParHashMap</kbd><em class="calibre18">.</em> These are immutable parallel collections. <kbd class="calibre11">ParHashMap</kbd> avoids collision internally by using a chaining mechanism.</p>
<p class="calibre2">It's worth knowing that the basic idea of parallelizing a collection is to split it into smaller parts using algorithms such as Divide and Conquer. These smaller parts are then operated upon using multiple tasks. Scala's parallel collection does this task scheduling through a <kbd class="calibre11">scala.collection.parallel.TaskSupport</kbd> object that is configurable. Also one should keep in mind that <em class="calibre18">side-effecting</em> operations are unpredictable, and when executed in parallel, they can produce deadlocks or race conditions. So as programmers, it's our responsibility to write code in a manner that avoids these race conditions. Parallel collections make it easier to solve problems where large amounts of data are to be processed. They make collections more powerful in Scala. You may also want to utilize this power when you use any Java collection from a library; in that case, you may want to read the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting a Java collection into a Scala collection</h1>
                
            
            <article>
                
<p class="calibre2">Scala interoperates with a lot of Java libraries, so you may have to deal with Java code as well. It's possible for you to encounter a situation where you've a Java collection and you're expected to convert it into Scala. With this idea of converting a collection from Java to Scala, it may look a little bit scary that we've got to traverse through elements from Java's collection, and then append them to a Scala collection. But here's the catch: there're already ways you can do this. It's easy: we've a <kbd class="calibre11">JavaConverters</kbd> object in the <kbd class="calibre11">scala.collection</kbd> <span>package,</span><span> </span><span>which takes care of this conversion. Actually, what happens behind the scenes when you call these conversion methods is that the implicit conversion takes place. Why not take a look at an example:</span></p>
<pre class="calibre19">package chapter5<br class="title-page-name"/><br class="title-page-name"/><span>import </span>java.time.LocalDate<br class="title-page-name"/><span>import </span>scala.collection.JavaConverters._<br class="title-page-name"/><br class="title-page-name"/><span>object </span>CollectionConvertors <span>extends </span>App {<br class="title-page-name"/>    /*<br class="title-page-name"/>     We'll create a java collection of a couple of days and convert it to Scala Collection<br class="title-page-name"/>     */<br class="title-page-name"/>    <span>val </span><span>aJavaList </span>= <span>new </span>java.util.ArrayList[LocalDate]()<br class="title-page-name"/>    <span>aJavaList</span>.add(LocalDate.<span>now</span>())<br class="title-page-name"/>    <span>aJavaList</span>.add(<span>aJavaList</span>.get(<span>0</span>).plusDays(<span>1</span>))<br class="title-page-name"/><br class="title-page-name"/>    <span>println</span>(<span>s"Java List of today and tomorrow: </span><span>$</span><span>aJavaList</span><span>"</span>)<br class="title-page-name"/><br class="title-page-name"/>    <span>val </span><span>scalaDates </span>= <span>aJavaList</span>.asScala<br class="title-page-name"/>    <span>scalaDates </span>map { date =&gt;<br class="title-page-name"/>      <span>println</span>(<span>s"Date :: </span><span>$</span>date<span>"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    <span>val </span><span>backToJavaList </span>= <span>scalaDates</span>.asJavaCollection<br class="title-page-name"/>    <span>println</span>(<span>backToJavaList</span>)<br class="title-page-name"/>}</pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Java List of today and tomorrow: [2017-10-01, 2017-10-02]<br class="title-page-name"/>Date :: 2017-10-01<br class="title-page-name"/>Date :: 2017-10-02<br class="title-page-name"/>[2017-10-01, 2017-10-02]</pre>
<p class="calibre2">Here's the program. We've a Java list named <kbd class="calibre11">aJavaList</kbd><em class="calibre18">,</em> which is a list of dates with a few date objects in it. Yes, it's not a complex problem; what we simply have to do is to convert this list into a Scala collection so that we can perform our higher order operations such as <kbd class="calibre11">map</kbd> or <kbd class="calibre11">flatMap</kbd><em class="calibre18">.</em> For that, as we can see, we imported the <kbd class="calibre11">scala.collection.JavaConvertors</kbd> object. After importing this object, we now have access to a converter method, <kbd class="calibre11">asScala</kbd>, which converts your Java collection to a Scala counterpart, which internally checks for the suitable collection to convert in, and the conversion happens implicitly. Finally, after conversion, we're able to use the <kbd class="calibre11">map</kbd> function on the <kbd class="calibre11">scalaDates</kbd> object, which is not a Scala collection.</p>
<p class="calibre2">It's also possible to convert a Scala collection to a Java counterpart using <kbd class="calibre11">asJava</kbd><em class="calibre18">.</em> So it'll be totally fine to write something like this:</p>
<pre class="calibre19">val backToJavaList = scalaDates.asJava 
println(backToJavaList) </pre>
<p class="calibre2">It'll convert the Scala collection into a Java collection. It's good that when you perform one conversion from the source collection to the target collection and then reconvert it, you actually get the main real object. Now that you've seen all the collections from Scala, and also have an idea that Java collections can also be converted to Scala collections, you've so many options to choose from for any requirement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Choosing a collection</h1>
                
            
            <article>
                
<p class="calibre2">Here's the problem: after learning so many ways to make a collection of elements in Scala, it appears that we've got a big dilemma. We have quite a few options to choose from. Almost every collection has higher order functions to operate with. These are high-performing, type parameterized, and immutable collections. So how do we decide which collection to use? Now, we've the answer for that. And the answer is, it depends. Yes, it depends on multiple factors; for example, in which format would you like to have the data. Is it a simple sequence or in pair format? It's obvious that we've been talking about sequences, and maps up to now. In the majority of situations, we come up with <kbd class="calibre11">Map</kbd>, <kbd class="calibre11">Set</kbd><em class="calibre18">,</em> <kbd class="calibre11">List</kbd><em class="calibre18">,</em> <kbd class="calibre11">ArrayBuffer</kbd>, or a <kbd class="calibre11">Vector</kbd><em class="calibre18">.</em> Let's talk about the factors that matter:</p>
<ul class="calibre7">
<li class="calibre8">If the requirement is to have a key-value lookup, we use Maps.</li>
<li class="calibre8">We use <kbd class="calibre11">HashMap</kbd> when order is of no importance, and <kbd class="calibre11">ListMap</kbd> when we want to store the key-value pairs in a sequence. <kbd class="calibre11">ListMap</kbd> operations take linear time, as the number of elements increases. So using a <kbd class="calibre11">Map</kbd> is recommended in normal cases; if, somehow, the requirement is that we've got to operate on the first of a few collection elements, then <kbd class="calibre11">ListMap</kbd> can become a better choice.</li>
<li class="calibre8">Sets<em class="calibre18">,</em> as you know already, contain no duplicate elements, so to remove duplicates we may choose to use a <kbd class="calibre11">Set</kbd>, or convert our collection to a <kbd class="calibre11">Set</kbd><em class="calibre18">.</em> In Scala, a <kbd class="calibre11">Set</kbd> also extends <kbd class="calibre11">(A) ⇒ Boolean</kbd>, and this means that we may use a set to check the presence of an element in our collection. So it's simple: if you're required to check the presence of an element often, or to remove duplicates, use a <kbd class="calibre11">Set</kbd>.</li>
<li class="calibre8">If you need to store finite elements, traverse through them, or perform some operation on them, please choose a <kbd class="calibre11">List</kbd>. An <kbd class="calibre11">ArrayBuffer</kbd> is also a good choice in case you need it to be mutable. A <kbd class="calibre11">List</kbd> is a linear sequence, so performing operations is costly when the number of elements increases due to linear performance.</li>
<li class="calibre8">If the requirement is random access, and traversal is not of much importance, an indexed sequence is recommended, so please give <kbd class="calibre11">ArrayBuffer</kbd> a chance<em class="calibre18">.</em></li>
<li class="calibre8">If you want faster random access and a persistent sequence, use <kbd class="calibre11">Vector</kbd><em class="calibre18">.</em> And yes, Vector is persistent, because it preserves the previous version of itself. That's not possible with an <kbd class="calibre11">ArrayBuffer</kbd><em class="calibre18">,</em> because of mutability.</li>
<li class="calibre8">Lazy evaluation can be an asset when working with Streams<em class="calibre18">.</em> It's a wise choice when the requirement is to evaluate a collection element on a need basis. We've seen how the <kbd class="calibre11">Stream</kbd> is represented, because of elements being lazily computed.</li>
<li class="calibre8">Finally, the immutables. We can create a <em class="calibre18">Range </em>on the go with some collection's size, or something of that sort. It's easy to create a <kbd class="calibre11">Range</kbd> with <kbd class="calibre11">in</kbd><em class="calibre18">,</em> <kbd class="calibre11">until</kbd>, and <kbd class="calibre11">by</kbd> methods.</li>
</ul>
<p class="calibre2">So, it mostly all depends on what are we going to do with our collection elements. Of course, performance is of the utmost importance to us, because collections take up a big part of writing logic into our programs. We can start with a wrong choice of collection, then based on the need, we can convert those. It may look easy, but it's going to impact performance for sure. For example, it's wise to use a <kbd class="calibre11">ListBuffer</kbd> if later in the program you decide to convert it into a list. The reason is that a <kbd class="calibre11">ListBuffer</kbd> stores elements internally in a linked list format. So it's easy to convert to a list, rather than an array. Different operations, from instantiating a collection to updating, appending, or calling head or tail on your collection, all take different amounts of time, and thus can make your code less performant. So the idea is to choose wisely, based on what's of importance to your program. So why not compare the performance of several collections?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collection performance</h1>
                
            
            <article>
                
<p class="calibre2">What are all the things you can do with a collection? Let's think of some use cases:</p>
<ul class="calibre7">
<li class="calibre8">First, create a collection object</li>
<li class="calibre8">Insert an element</li>
<li class="calibre8">Perform an operation on each element of a collection, which is only possible when you access each element</li>
<li class="calibre8">Traverse through the collection</li>
<li class="calibre8">Break it down into parts, perhaps one part with a single first element, and another with the rest of the collection (which are <kbd class="calibre11">head</kbd> and <kbd class="calibre11">tail</kbd>, obviously)</li>
<li class="calibre8">Randomly seek out a particular element</li>
<li class="calibre8">Update an element</li>
<li class="calibre8">Reverse the collection</li>
</ul>
<p class="calibre2">So, this covers pretty much everything you can do with a collection. The good thing is that if you're sure about the kinds of operations you're going to perform on your collection, you can make a performant program. The bad news is we hardly think about the operations we're going to perform later in programs, unless you're fortunate. But we've got an idea about all the collections and their performance. You may want to refer to the performance characteristics table in Scala's official documentation at <a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html" class="calibre10">http://docs.scala-lang.org/overviews/collections/performance-characteristics.html<span>.</span></a></p>
<p class="calibre2">The following observations will help with the idea of calling <kbd class="calibre11">apply</kbd>, <kbd class="calibre11">append</kbd>, <kbd class="calibre11">head</kbd>, or <kbd class="calibre11">tail</kbd> operations on a collection:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">List</strong><strong class="calibre1">:</strong> List is a linear sequence, so methods such as <kbd class="calibre11">apply</kbd> and <kbd class="calibre11">append</kbd> take more time as the number of elements increases. But accessing <kbd class="calibre11">head</kbd> and <kbd class="calibre11">tail</kbd> elements takes <span>a fixed amount of </span>time:</li>
</ul>
<table class="msotablegrid">
<tbody class="calibre21">
<tr class="calibre22">
<td class="calibre23"><kbd class="calibre34">apply =&gt; Linear</kbd></td>
<td class="calibre23"><kbd class="calibre34">append =&gt; Linear</kbd></td>
<td class="calibre23"><kbd class="calibre34">head =&gt; Constant</kbd></td>
<td class="calibre23"><kbd class="calibre34">tail =&gt; Constant</kbd></td>
</tr>
</tbody>
</table>
<ul class="calibre7">
<li class="calibre8">The same goes for a <kbd class="calibre11">Stream</kbd> as well.</li>
</ul>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Vector:</strong> Vector is more performant than a list on a few grounds, and <kbd class="calibre11">apply</kbd> and <kbd class="calibre11">append</kbd> operations are definitely more performant than a list.</li>
</ul>
<table class="msotablegrid">
<tbody class="calibre21">
<tr class="calibre22">
<td class="calibre23"><kbd class="calibre34">apply =&gt; Effectively Constant</kbd></td>
<td class="calibre23"><kbd class="calibre34">append =&gt; Effectively Constant</kbd></td>
</tr>
<tr class="calibre22">
<td class="calibre23"><kbd class="calibre34">head =&gt; Effectively Constant</kbd></td>
<td class="calibre23"><kbd class="calibre34">Tail =&gt; Effectively Constant</kbd></td>
</tr>
</tbody>
</table>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Range</strong>: Range is a good option for those going for constant time access <span>to</span> <kbd class="calibre11">apply</kbd><em class="calibre18">,</em> <kbd class="calibre11">head</kbd><span>, or</span> <kbd class="calibre11">tail</kbd> <span>operations.</span></li>
</ul>
<table class="msotablegrid">
<tbody class="calibre21">
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">apply =&gt; Constant</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">head =&gt; Constant</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">tail =&gt; Constant</kbd></p>
</td>
</tr>
</tbody>
</table>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">String</strong>: String and Array work well for <kbd class="calibre11">apply</kbd> and <kbd class="calibre11">head</kbd> operations with a constant time response, but <kbd class="calibre11">tail</kbd> is a costly operation for these.</li>
</ul>
<table class="msotablegrid">
<tbody class="calibre21">
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">apply =&gt; Constant</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">head =&gt; Constant</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">tail =&gt; Linear</kbd></p>
</td>
</tr>
</tbody>
</table>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Maps</strong>: Maps are used to do value lookups based on keys or add/remove key-value pairs. <kbd class="calibre11">HashMap</kbd> effectively provides constant time for these operations.</li>
</ul>
<table class="msotablegrid">
<tbody class="calibre21">
<tr class="calibre22">
<td class="calibre23"><kbd class="calibre34">lookup =&gt; Effectively Constant</kbd></td>
<td class="calibre23"><kbd class="calibre34">add =&gt; Effectively Constant</kbd></td>
<td class="calibre23"><kbd class="calibre34">remove =&gt; Effectively Constant</kbd></td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Knowing the structure of a collection provides almost all the information about its performance. We now have an idea about all the collections in Scala, so it's time for you to practice more and experiment <span>more</span><span> </span><span>with these collections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was an introduction to the implementation of Scala's collections. We started learning about immutable and mutable collections. After that, we discussed Scala's collection hierarchy, where we learned about various super traits such as <kbd class="calibre11">Traversable</kbd> and <kbd class="calibre11">Iterable</kbd><em class="calibre18">.</em> We also talked about three abstract collection types: <kbd class="calibre11">Seq</kbd>, <kbd class="calibre11">Set</kbd>, and <kbd class="calibre11">Map</kbd>. Then we took a look at the most commonly used collections in Scala. After that, we went the extra mile to learn about all the important functions used to work with collections. Then we learned about how we can convert collections from Java to Scala and vice versa, and found out that it was easy. After that, we discussed which collection to choose from all these options, which led us to consider the performance characteristics of collections.</p>
<p class="calibre2">With this, we've come to the end of part 1. In the next part, we'll start with the object-oriented and functional constructs provided by Scala. The next chapter is about the basics of object-oriented constructs in Scala, such as classes, traits, and objects. Learning them will enable us to utilize functional constructs efficiently in later parts of this book.</p>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>