<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer287">
<h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor180"/>12</h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor181"/>Evaluating, Recommending, and Presenting Your Solutions</h1>
<p>We started our journey with the basics of data engineering and learned various ways to solve data ingestion and data publishing problems. We learned about various architectural patterns, as well as the governance and security of the solution. In the preceding chapter, we discussed how we can achieve performance engineering and how to create a performance benchmark for our solution.</p>
<p>By now, we have acquired multiple skills to architect efficient, scalable, and optimized data engineering solutions. However, as discussed in the <em class="italic">Responsibilities and challenges of a Java data architect</em> section of <a href="B17084_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Basics of Modern Data Architecture</em>, a data architect has multiple roles to play. In an executive role, the data architect becomes the bridge between business and technology who can communicate ideas effectively and easily with the respective stakeholders. An architect’s job is not only to create the solution but also to present and sell their idea to executives and leadership (both functional and technical). In this chapter, we will focus on how to recommend and present a solution.</p>
<p>In this chapter, we will start our discussion by talking about infrastructure and human resource estimation. As data architects, we need to recommend solutions. To do that, we will discuss how we can create a decision matrix to evaluate our solution and compare different alternatives. Then, we will learn about using decision charts effectively to choose an optimal architectural alternative. Finally, we’ll learn about a few basic tips and tricks to present the solution effectively.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Creating cost and resource estimations</li>
<li>Creating an architectural decision matrix</li>
<li>Data-driven architectural decisions to mitigate risk</li>
<li>Presenting the solution and recommendations </li>
</ul>
<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>Creating cost and resource estimations </h1>
<p>In this section, we will discuss various considerations, methods, and techniques that we apply to create estimations. We will briefly discuss both infrastructure estimations as well as human resource estimations. Infrastructure <a id="_idIndexMarker1280"/>estimations are closely related to capacity planning. So, we will start our discussion with capacity planning.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>Storage and compute capacity planning</h2>
<p>To create an infrastructure <a id="_idIndexMarker1281"/>estimate, you have to find out the data storage needs (RAM, hard disks, volumes, and so on) and the compute needs (the number of CPUs/vCPUs and cores it should have). This process of figuring out the storage and compute needs is called capacity planning. We will start by learning about the factors that need to be considered while conducting capacity planning.</p>
<h3>Factors that need to be considered while conducting capacity planning</h3>
<p>The following are the various<a id="_idIndexMarker1282"/> factors that should be taken into consideration while creating a capacity plan:</p>
<ul>
<li><strong class="bold">Input data rate</strong>: Based on the<a id="_idIndexMarker1283"/> type of application, data rates need to be factored in. For example, for a real-time or near-real-time application, the peak data rate should be considered while planning for the storage and compute capacity. For batch-based applications, either the median data rate or the average data rate should be considered. If the batch job runs daily, it is advisable to use median data rates for capacity planning. Median data rates are preferred over average data rates because median data rates are based on the densest distribution of data rates. So, it denotes the middle point of the most frequently recorded data rate. Hence, the median value is never affected by any outlier. On the other hand, the average data rate finds the average of all the data rates over time, including a few exceptional high or low data rates.</li>
<li><strong class="bold">Data replication and RAID configurations</strong>: Replication ensures high availability and data locality. Since it replicates the data to multiple nodes, systems, or partitions, we<a id="_idIndexMarker1284"/> must consider the replication factor as well while planning for storage capacity. For example, if 5 GB of data is stored with a replication factor of 3, this means it stores two replicas in different systems, along with the original message. So, the total storage requirement to store 5 GB of data is 15 GB. The replication factor is often mistaken for RAID. While the replication factor ensures high availability using data locality, RAID ensures data safety at the physical storage level by ensuring redundancy at the storage array layer. For mission-critical use cases, it is advisable to take both replication and RAID into consideration while planning for storage capacity.</li>
<li><strong class="bold">Data retention</strong>: Another important factor is data retention. Data retention is the time for which data needs to<a id="_idIndexMarker1285"/> be retained in storage before it’s purged. This plays an important role as it determines how much storage is needed for accumulation purposes. One of the other things that comes into play in the cloud is the need for archival. Does data need to be archived? If that’s true, when should it be archived? </li>
</ul>
<p>Initially, data may be frequently accessed. Then, it can be infrequently accessed, and the company may want to store the data in an archival zone for long-term audit and reporting requirements. Such a scenario can be handled in the cloud by using specific strategies to save money. For example, we can use S3 intelligent tiering, which sends the data automatically from the S3 standard access to S3 infrequent access layers <a id="_idIndexMarker1286"/>to the S3 Glacier layers based on the access frequency. This reduces <strong class="bold">Operating Expenses</strong> (<strong class="bold">OpEx</strong>) costs as you can make a lot of savings as you move your data from the standard access layer to Glacier.</p>
<ul>
<li><strong class="bold">Type of data platform</strong>: It also<a id="_idIndexMarker1287"/> matters whether you are running your application on-premises or in the public cloud. Capacity planning should consider the maximum required capacity while planning for on-premise deployment. But if you are planning for the cloud, it is advisable to go with a median capacity requirement and configure auto-scaling for peak loads. Since the cloud gives you the option <a id="_idIndexMarker1288"/>of instant scaling as well as paying for only what you use, it makes sense to spin up the resources required to process the usual data volumes. </li>
<li><strong class="bold">Data growth</strong>: Another thing you <a id="_idIndexMarker1289"/>must consider is the growth rate of data. Based on various factors, growth rates may vary. It is important to factor in the growth rate since data engineering pipelines are usually long-term investments.</li>
<li><strong class="bold">Parallel executions in shared mode</strong>: One of the other factors that we must take into account is shared <a id="_idIndexMarker1290"/>resources and their effect on concurrent executions. For example, it helps us to correctly estimate the resource requirement of a big data cluster if we know that 10 jobs with an average approximate load of 100 GB may run simultaneously on the cluster. Similarly, to estimate the resource requirements of a Kubernetes cluster, we should be aware of the maximum number of pods that will be running simultaneously. This will help determine the size and number of physical machines and VMs you want to spawn.</li>
</ul>
<p>With that, we have learned about the various factors that need to be considered while doing storage and compute capacity planning. In the next section, we will look through a few examples of how these factors help in capacity planning.</p>
<h3>Applying these considerations to calculate the capacity</h3>
<p>In this section, we will discuss a few examples where the aforementioned factors are used judiciously to calculate capacity. The following are <a id="_idIndexMarker1291"/>a few use cases:</p>
<ul>
<li><strong class="bold">Example 1</strong>: Consider that we need to create a capacity plan for a big data cluster in an on-premise data center. Here, the input data rate is <em class="italic">R</em> records per second and each record is <em class="italic">B</em> bytes. The storage requirement for a day (<img alt="" height="55" src="image/B17084_12_001.png" width="65"/>) can be calculated by multiplying <em class="italic">R</em> by <em class="italic">B</em> and multiplying the result by 86,400 seconds. However, this calculation doesn’t include the replication or RAID factors. We must multiply the replication factor (here, <em class="italic">RF</em>) by it, as well as the overload factor (here, <em class="italic">OF</em>), due to RAID configurations (the overload factor for RAID 0 is 1, RAID 5 is 1.5, and RAID 10 is 2). Hence, the formula to calculate the storage requirements for a day is as follows:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer264">
<img alt="" height="88" src="image/B17084_12_002.jpg" width="600"/>
</div>
</div>
<p>But the actual capacity requirement may be more than this. If there is a requirement to retain data <a id="_idIndexMarker1292"/>for 7 days, we will get the total required storage by multiplying 7 by <img alt="" height="51" src="image/B17084_12_003.png" width="65"/>. Now, let’s see how the growth factor can affect capacity planning. Based on the technology stack, volume of data and data access, and read pattern and frequency, we can set the total memory and compute. Let’s say that the <a id="_idIndexMarker1293"/>calculated storage capacity is <img alt="" height="42" src="image/B17084_12_004.png" width="45"/>, memory is <img alt="" height="49" src="image/B17084_12_005.png" width="60"/>, compute is <img alt="" height="43" src="image/B17084_12_006.png" width="47"/>, and <strong class="bold">Input/Output Operations per Second</strong> (<strong class="bold">IOPS</strong>) is <img alt="" height="50" src="image/B17084_12_007.png" width="122"/>. Also, let’s say that the growth rate is <em class="italic">g</em> per year. So, the final resource requirement for the next year would be as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer270">
<img alt="" height="56" src="image/B17084_12_008.jpg" width="415"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer271">
<img alt="" height="54" src="image/B17084_12_009.jpg" width="415"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer272">
<img alt="" height="51" src="image/B17084_12_010.jpg" width="390"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer273">
<img alt="" height="53" src="image/B17084_12_011.jpg" width="510"/>
</div>
</div>
<p>In this example, we saw how our factors help size a Hadoop big data cluster. Hardware <strong class="bold">Capital Expenditure</strong> (<strong class="bold">CapEx</strong>) represents <a id="_idIndexMarker1294"/>a significant investment upfront and requires recurring OpEx, hence a balance between the two needs to be attained for better TOC.. In the next example, we’ll explore how to size a Kafka cluster for real-time loads.</p>
<ul>
<li><strong class="bold">Example 2</strong>: In this example, we <a id="_idIndexMarker1295"/>are trying to predict the capacity of a Kafka cluster that receives 100 messages per second, where the retention period is 1 week and the average message size is 10 KB. Also, all topics have a replication factor of 3. Here, a Kafka cluster contains two primary clusters – a Kafka cluster and a zookeeper cluster. For a zookeeper cluster in production, a dual-core or higher CPU should be used, along with a memory of 16 to 24 GB. 500 GB to 1 TB disk space should be fine for zookeeper nodes. For the Kafka broker nodes, we should run multi-core servers with 12 nodes and higher. It should also support hyperthreading. The usual normal memory requirement for a Kafka broker is between 24 to 32 GB. Now, let’s calculate the storage needs for the broker. The following formula helps calculate the storage needs for each node:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer274">
<img alt="" height="96" src="image/B17084_12_012.jpg" width="630"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer275">
<img alt="" height="60" src="image/B17084_12_013.jpg" width="713"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer276">
<img alt="" height="58" src="image/B17084_12_014.jpg" width="482"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer277">
<img alt="" height="58" src="image/B17084_12_015.jpg" width="505"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer278">
<img alt="" height="60" src="image/B17084_12_016.jpg" width="600"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer279">
<img alt="" height="58" src="image/B17084_12_017.jpg" width="620"/>
</div>
</div>
<p>By applying this formula to our example, we get the storage needs of each broker as 604 GB.</p>
<p>With these examples, we’ve seen <a id="_idIndexMarker1296"/>how we can apply various factors to predict the capacity requirement of a solution. This helps create detailed CapEx and OpEx estimations for the business.</p>
<p>Now that we have learned how infrastructure estimations are calculated, we will discuss how to estimate the human resource-related costs and time for executing a project.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor184"/>Effort and timeline estimation</h2>
<p>Apart from the various<a id="_idIndexMarker1297"/> responsibilities that an architect has to handle, effort and time estimation is an important responsibility for a<a id="_idIndexMarker1298"/> data architect. Usually, the architect is responsible for creating a high-level estimate at the start of the project’s implementation. Considering most teams follow the agile methodology of software development, detailed effort estimation is done by the agile team during the implementation phase. The following activities need to be done to create a good estimate:</p>
<ul>
<li><strong class="bold">Create tasks and dependency charts</strong>: First, to create an estimate, we must analyze the solution and divide it into high-level development and quality assurance tasks. We should also factor in all performance engineering tasks while creating the high-level task list. Then, we must create a dependency task list, which will specify whether a particular task is dependent on another task(s) or not. The following table shows one of the formats for creating a task and dependency list: </li>
</ul>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Task no.</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Task name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Dependency</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p>Creating Git user registration and a master repository</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>2</p>
</td>
<td class="No-Table-Style">
<p>Creating local repositories on a PC</p>
</td>
<td class="No-Table-Style">
<p>Task 1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3</p>
</td>
<td class="No-Table-Style">
<p>Creating a simple Hello World whose output will be shown in Hindi in Java</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>4</p>
</td>
<td class="No-Table-Style">
<p>Creating R2</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>5</p>
</td>
<td class="No-Table-Style">
<p>Reviewing the code of R2</p>
</td>
<td class="No-Table-Style">
<p>Task 4</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>6</p>
</td>
<td class="No-Table-Style">
<p>Pushing the code of R2</p>
</td>
<td class="No-Table-Style">
<p>Task 2 and Task 5</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>7</p>
</td>
<td class="No-Table-Style">
<p>Creating a data model of R2</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>8</p>
</td>
<td class="No-Table-Style">
<p>Creating a data model of R3-b</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>9</p>
</td>
<td class="No-Table-Style">
<p>Reviewing the data model of R3-b</p>
</td>
<td class="No-Table-Style">
<p>Task 8</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>10</p>
</td>
<td class="No-Table-Style">
<p>Pushing the data model of R3-b</p>
</td>
<td class="No-Table-Style">
<p>Task 1 and Task 8</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Sample task and dependency list</p>
<p>In the preceding table, note that task 2 is dependent on task 1 and, similarly, task 6 is dependent on tasks 2 and 5. Note how we can denote such dependencies by<a id="_idIndexMarker1299"/> adding a dependency column. This dependency matrix helps us understand the risks and dependencies. It also helps us understand how various tasks can run in parallel. This helps create a roadmap for various feature releases.</p>
<ul>
<li><strong class="bold">Classify the tasks based on their complexity</strong>: One of the things that an architect must do is classify the tasks into one of three categories: high complexity, medium complexity, and low complexity. However, for some exceptional use cases, more granular complexity levels can be defined.</li>
<li><strong class="bold">Classify based on technology</strong>: Another classification that helps with estimation is technology. This is because a complex task for a Spark-based job can be different than a complex task for a DataStage-based job. So, the average effort that needs to be spent not only depends on the complexity but also on the technology.</li>
<li><strong class="bold">Create the estimated time taken for a task</strong>: To create a time estimate, first, we must create a map consisting of the time taken for a specific combination of technology and complexity if it is a technical task. If it is an analytical task, we must create a mapping for the time taken by a task versus its complexity. For example, a complex task for a Spark job may take 8 man-days to finish, while a complex task for an Informatica job may take 5 man-days to finish. Based on such a mapping, we can estimate the total time taken to finish the project in man-days or man-hours. For some agile projects, this effort can be estimated using a point system. For example, a complex analysis task may take 5 points of effort. </li>
<li><strong class="bold">Create total effort estimates</strong>: Based on the estimation done in the previous steps, we can calculate the total effort by summing up all individual task efforts required to deliver the solution.</li>
<li><strong class="bold">Add a buffer to estimates</strong>: As mentioned in the book <em class="italic">The Pragmatic Programmer (Hunt et al., 1999)</em>, we should remember that <em class="italic">Rather than construction, software is more like gardening – it is more organic than concrete. You constantly monitor the health of the garden and make adjustments (to the soil, the plants, the layout) as needed</em>. Since developing any application or data pipeline is organic, we must add a buffer to our estimates so that any organic changes may be accommodated in the project schedule.</li>
<li><strong class="bold">Create a product roadmap and timeline for releases</strong>: Based on the total estimate, dependency, risks, and expected delivery range, we can create a roadmap and timeline. It is important to understand the expected delivery timelines to ensure we can<a id="_idIndexMarker1300"/> do proper resource loading and deliver the project in the time range that the business is looking for. Having said that, a lot of times, the business has unrealistic expectations of delivery timelines. It is the job of an architect (with the help of the project manager and product owner) to communicate and justify the estimates to the business so that both the technical and business teams can come to a common ground in terms of the delivery timeline.</li>
<li><strong class="bold">List all risks and dependencies alongside the estimate</strong>: While creating an estimate, it is important to list all the risks, dependencies, and assumptions so that all stakeholders are aware of what is being delivered and the risks involved in delivering the solution.</li>
</ul>
<p>Now that we have learned how to create and document a well-thought effort estimate, we have to figure out the total delivery or development cost of a solution. To do that, we must perform human resource loading. Human resource loading is a process by which we identify how many developers, testers, and analysts with specific skill sets are required to deliver the project in the<a id="_idIndexMarker1301"/> agreed-upon time. Finding the right mix of people with specific roles is the key to delivering the solution. Then, we assign a specific per-hour cost based on the role, demographics, and technology. </p>
<p>After that, we factor in the number of hours required by a role or resource and multiply it by the assigned rate to reach the total cost of a human resource for the project. By summing up the total cost of each resource, we can find the total development cost (or the labor cost; any infra or license costs are not included).</p>
<p>With that, we have learned how to create cost and resource estimates to implement a solution. Earlier in this book, we learned how to develop different architectures for various kinds of data engineering problems. We also learned how to run performance tests and benchmarks. </p>
<p>In this section, we learned how to create cost and resource estimates to implement a solution. <em class="italic">Is there a way to stitch all this information together to recommend the best-suited solution?</em> In real-world scenarios, each data engineering problem can be solved by multiple architectural solutions. <em class="italic">How do we know which is the most suitable solution? Is there a logical way to determine the best-suited solution?</em> Let’s find out.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor185"/>Creating an architectural decision matrix</h1>
<p>Concerning data engineering, an<a id="_idIndexMarker1302"/> architectural decision matrix is a tool that helps architects evaluate the different architectural approaches with clarity and objectivity. A decision matrix is a grid that outlines the various desirable criteria for making architectural decisions. This tool helps rank different architectural alternatives, based on the score for each criterion. Decision matrices are used by other decision-making processes. For example, decision matrices are used by business analysts to analyze and evaluate their options. </p>
<p>The decision matrix, also known as the Pugh matrix, decision<a id="_idIndexMarker1303"/> grid, or grid analysis, can be used for many types of decision-making processes. However, it is best suited for scenarios where we have to choose one option among a group of alternatives. Since we must choose one architecture for the recommendation, it makes sense to use a decision matrix to arrive at a conclusion. Now, let’s discuss <a id="_idIndexMarker1304"/>a step-by-step guide to creating a decision matrix for architectural decision-making. The steps to create a decision matrix are as follows:</p>
<ol>
<li><strong class="bold">Brainstorm and finalize the various criteria</strong>: To create a decision matrix that can be used for architectural evaluation, it is important to brainstorm and finalize the various criteria that the decision depends on. It is important to involve leadership and business executives as stakeholders in this brainstorming session. If you are an architect from a services firm who is developing a solution for the client, it is important to involve an architect from the client side as well. This step is very important as various criteria and their priorities help narrow down our final recommendation among a set of architectural alternatives.</li>
<li><strong class="bold">Create the matrix table</strong>: Next, we should create the decision matrix table, where each row denotes a specific criterion, while each column denotes a specific architectural alternative. These are selected sets of criteria that help us determine the appropriateness of the architecture for the current use case. The following diagram shows what the table will look like:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer280">
<img alt="Figure 12.2 – Creating the decision matrix table " height="254" src="image/B17084_12_0021.jpg" width="815"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Creating the decision matrix table</p>
<ol>
<li value="3"><strong class="bold">Assign rank or scale</strong>: Now, we must assign rank or scale to each of the criteria of the architecture. Rank or scale is a relative measure where the higher the scale, the better it fits the criteria. The following diagram shows how scale is assigned to different architectures based on various criteria:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer281">
<img alt="Figure 12.3 – Assigning scale values for each architecture against each criterion " height="221" src="image/B17084_12_003.jpg" width="918"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Assigning scale values for each architecture against each criterion</p>
<p>As we can see, different scales are assigned to each architecture against each criterion on a relative scale of 1 to 5. Here, 5 is the highest match possible for the given criterion, while 1 is the lowest match possible for the given criterion. In this example, <em class="italic">Architecture 1</em> gets a score of <em class="italic">3</em> in terms of <em class="italic">Scale</em>. <em class="italic">Architecture 2</em> gets a score of <em class="italic">2</em>, while <em class="italic">Architecture 3</em> and <em class="italic">Architecture 4</em> get a score of <em class="italic">4</em> for <em class="italic">Criteria 1</em>. Hence, <em class="italic">Architecture 3</em> and <em class="italic">Architecture 4</em> are the most suitable as far as <em class="italic">Criteria 1</em> is concerned.</p>
<ol>
<li value="4"><strong class="bold">Assign weights</strong>: Next, we must assign weights to each criterion. This will help set the priority for various criteria. The following diagram shows how weights are assigned to each architecture against each criterion:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer282">
<img alt="Figure 12.4 – Assigning weights to each criterion " height="389" src="image/B17084_12_004.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Assigning weights to each criterion</p>
<p>As we can see, the weight that’s assigned to each criterion is independent of the architecture. This attaches a priority to each of the criteria. So, the most desirable criteria get the highest preference. The higher the weight, the higher the priority. In this example, <em class="italic">Criteria 1</em> and <em class="italic">Criteria 2</em> get the least priority with a priority score of <em class="italic">2</em>, while <em class="italic">Criteria 4</em> and <em class="italic">Criteria 5</em> get the highest priority with a priority score of <em class="italic">4</em>.</p>
<ol>
<li value="5"><strong class="bold">Calculate the score</strong>: The individual scores for each architecture against a criterion are calculated by multiplying scale values by the weight of the criteria. The total desirability score of the architecture is calculated by summing up all the scores of each criterion. The following diagram shows what such a decision matrix looks like:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer283">
<img alt="Figure 12.5 – Example of a completed decision matrix for architectural decisions " height="467" src="image/B17084_12_005.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Example of a completed decision matrix for architectural decisions</p>
<p>As we can see, <em class="italic">Architecture 4</em> looks like the most desirable solution as it has the highest total desirability score of <em class="italic">57.5</em>, while <em class="italic">Architecture 1</em> is the least desirable with a score of <em class="italic">43.5</em>.</p>
<p>In this section, we learned about how to create a decision matrix. Now, the question is, <em class="italic">is the total desirability score always enough to recommend an architecture?</em> In the next section, we’ll learn how to further evaluate an architecture by using the techniques we learned earlier.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Data-driven architectural decisions to mitigate risk</h1>
<p>A decision matrix helps us evaluate the desirability of an architecture. However, it is not always necessary to opt for the architectural option that has the highest desirability score. Sometimes, each criterion needs to have a minimum threshold score for an architecture to be selected. Such scenarios can be handled by a spider chart.</p>
<p>A spider chart, also known as a radar chart, is often used to display data across multiple dimensions. Each dimension is represented by an axis. Usually, the dimensions are quantitative and normalized to match a particular range. Then, each option is plotted against all the dimensions to create a closed polygon structure, as shown in the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer284">
<img alt="Figure 12.6 – Spider or radar chart " height="1091" src="image/B17084_12_006.jpg" width="1110"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Spider or radar chart</p>
<p>In our case, each criterion for making an architectural decision can be considered a dimension. Also, each architectural alternative is plotted as a graph on the radar chart. Let’s look at the use case for the decision matrix shown in <em class="italic">Figure 12.5</em>. The following diagram shows the radar chart for the same use case:</p>
<div>
<div class="IMG---Figure" id="_idContainer285">
<img alt="Figure 12.7 – Radar chart for the example scenario discussed earlier " height="1288" src="image/B17084_12_007.jpg" width="983"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Radar chart for the example scenario discussed earlier</p>
<p>As we can see, each axis denotes a criterion such as <em class="italic">Criteria 1</em>, <em class="italic">Criteria 2</em>, and so on. Each criterion has a total score of 25 points, divided into five equal parts along its axis. The division markers for each criterion are connected to the division marker of the adjacent criteria, creating a spider web of symmetrical pentagons. The maximum score of each criterion is 25 because it is the product of the maximum scale value (5) and the maximum weightage (5). We also create a threshold polygon, as denoted by the dotted lines in the preceding diagram. This is created by joining the threshold marker (in this case, a score of 8 points) for every criterion. An optimal solution is one whose polygon is either bigger or equal to the threshold polygon. All the criteria of an optimal solution should score more points than the threshold score of each criterion. </p>
<p>As shown in the preceding diagram, our threshold score for each criterion is 8. Based on the score of each criterion for the architecture, we draw the polygon plot. Here, the plot of <em class="italic">Architecture 1</em> is blue, <em class="italic">Architecture 2</em> is pink, <em class="italic">Architecture 3</em> is green, and <em class="italic">Architecture 4</em> is violet. Based on the plots, we can see that only <em class="italic">Architecture 3</em> is optimal in this use case. Although the total desirability score of <em class="italic">Architecture 4</em> is greater than that of <em class="italic">Architecture 3</em>, it doesn’t fulfill the condition of having the minimum threshold score of 8 for each criterion as it only scores 7.5 in <em class="italic">Criteria 2</em>. Also, if the individual score of each criterion for <em class="italic">Architecture 3</em> is more than or equal to the threshold score. Hence, <em class="italic">Architecture 3</em> is the best-suited option for this use case.</p>
<p>An alternative way to evaluate a decision matrix to find the most optimized solution is using a decision tree. <strong class="bold">Decision trees</strong> are decision support tools that use tree-like models for questions and categorize or prune the results based on the answer to those questions. Usually, the leaf nodes denote the category or the decision. The following diagram shows an example of a decision tree for evaluating the scenario that we just discussed using a spider/radar chart:</p>
<div>
<div class="IMG---Figure" id="_idContainer286">
<img alt="Figure 12.8 – Decision tree to evaluate architectural alternatives " height="1280" src="image/B17084_12_0081.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Decision tree to evaluate architectural alternatives</p>
<p>As we can see, we can create <a id="_idIndexMarker1305"/>a decision tree based on the scores recorded earlier in the decision matrix to find the most optimal solution. Here, we are asking questions such as <em class="italic">Is the score for Criteria 1 greater than 8?</em>, <em class="italic">Is the score for Criteria 2 greater than 8?</em>, and so on. Based on the answer, we are pruning out the non-optimal solutions at that level. Finally, we ask, <em class="italic">Is this the max score for the candidate architecture and it can’t be pruned?</em> The answer to this question helps us figure out the most optimal solution.</p>
<p>In this section, we learned how to use a data-driven methodical approach to find and evaluate the most optimal solution for the problem. Now, it is the job of the architect to present the solution as a recommendation. In the next section, we will discuss the guidelines for how to present your <a id="_idIndexMarker1306"/>solution effectively.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor187"/>Presenting the solution and recommendations</h1>
<p>As an architect, your job doesn’t end<a id="_idIndexMarker1307"/> when you create and evaluate the most optimal architectural alternative based on the problem, platform, criteria, and priorities. As a Janus between business and technology, the architect is also responsible for effectively communicating the solution and recommending the most optimal alternative. Based on the kind of project and the type of business you are in, you may be required to convince stakeholders to invest in the solution. The following are a few guidelines that will help you present your solution and convince your stakeholders more effectively:</p>
<ul>
<li><strong class="bold">Present the presentation before the presentation</strong>: If possible, engage the customer or end client early and give them a glimpse of what possible solutions you are thinking of. Also, tell them how much time will it take for you to evaluate each of the solutions. Keep them engaged and in the loop while developing the architecture. It is always helpful if stakeholders are involved in the process and kept in the loop. It’s a win-win situation for both the stakeholders and the architect. Stakeholders feel that they are part of the solution, and they get enough time to understand or anticipate any impact of implementing the solution. On the other hand, the architect gets constant feedback about the priorities and criteria, which helps them come up with a very well-researched decision matrix. A more accurate decision matrix eventually helps architects make the most desired recommendation.</li>
<li><strong class="bold">Know your audience and ensure they are present</strong>: Although this is true for any presentation, it is important to understand the audience before presenting the solution. It is important to understand whether they are from business, executive leadership, or the technical side. It is also important to consider if any external teams or vendors are involved. Understanding the demographics of your audience will help you customize your presentation so that it is relatable to their work. If it is a mixed audience, make sure that you have something relatable for all the different audience groups. It is also important that you invite all the important stakeholders so that your solution reaches every intended audience.</li>
<li><strong class="bold">Present the Return on Investment (ROI) for the solution</strong>: Usually, there are top-level leaders, executives, and business heads present in a solution presentation. For them, it is important to understand how the solution can either generate or save<a id="_idIndexMarker1308"/> dollars. It could be that the solution will create additional revenue generation sources, or it could be as trivial as a lesser total cost of ownership or a lesser cost of development. To showcase the ROI for the solution, you can include if the solution adds any value to the customer experience or acceptance of the product. A good data architect should carefully brainstorm and figure out how the solution can add value to the business. </li>
<li><strong class="bold">Recommend by comparing alternatives</strong>: Although we, as architects, usually recommend one architecture, it is a good practice to present all the alternative architectures and their pros and cons. Then, we must establish the most suitable architecture. It is also a good idea to present why we chose that architecture.</li>
<li><strong class="bold">Make the presentation better by using their language</strong>: Each company and business has its own language. Since a lot of stakeholders are from the business side of things, it is better to adapt to the common language that’s popular in the organization when presenting. This ensures that the audience is easily getting what we are presenting and can connect the dots.</li>
<li><strong class="bold">Mind the context</strong>: It is also important for the presentation to be contextual. Based on the audience, your presentation should be customized so that it has the correct balance between technical versus business content.</li>
<li><strong class="bold">Ensure your presentation is visually appealing and relatable</strong>: Diagrams speak more than words. Presentations must have clear diagrams that are relatable and self-explanatory. Avoid too much text in a presentation. A visually appealing presentation is easier to explain and keeps the various stakeholders interested in the presentation. </li>
</ul>
<p>In this section, we discussed a few tips and tricks for presenting a solution to stakeholders in a concise, effective, and impactful way. Apart from developing and architecting a solution, we are <a id="_idIndexMarker1309"/>aware of how to evaluate, recommend, and present a solution effectively. Now, let’s summarize what we learned in this chapter.</p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor188"/>Summary</h1>
<p>We started this chapter by learning how to plan and estimate infrastructure resources. Then, we discussed how to do an effort estimation, how to load human resources, and how to calculate the total development cost. By doing so, we learned how to create an architectural decision matrix and how to perform data-driven comparisons between different architectures. Then, we delved into the different ways we can use the decision matrix to evaluate the most optimal solution by using spider/radar charts or decision trees. Finally, we discussed some guidelines and tips for presenting the optimized solution in a more effective and impactful way to various business stakeholders.</p>
<p>Congratulations – you have completed all 12 chapters of this book, where you learned all about a Java data architect’s role, the basics of data engineering, how to build solutions for various kinds of data engineering problems, various architectural patterns, data governance and security, and performance engineering and optimization. In this final chapter, you learned how to use data-driven techniques to choose the best-suited architecture and how to present it to the executive leadership. I hope you have learned a lot, and that it will help you develop your career as a successful data architect and help you grow in your current role. </p>
</div>
</div>
</body></html>