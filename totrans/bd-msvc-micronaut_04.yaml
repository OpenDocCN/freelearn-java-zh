- en: '*Chapter 2*: Working on Data Access'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any microservice adoption is incomplete without integrating with persistence
    or data storage. In this chapter, we will explore various aspects of persistence
    and data access in the Micronaut framework. We will begin by using an **object-relational
    mapping** (**ORM**) framework to integrate with a relational database. Then, we
    will dive into integrating a database using a persistence framework. Furthermore,
    in the end, we will see an example of integrating a NoSQL database. To cover these
    topics, we will work on a pet clinic application. This application will be composed
    of the following microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pet-owner`: A microservice to integrate with a relational database using an
    ORM framework in Micronaut'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic`: A microservice to integrate with a relational database using
    a persistence framework in Micronaut'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-review`: A microservice to integrate with a NoSQL database in Micronaut'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have good and hands-on knowledge of working
    with various kinds of persistence frameworks and how to integrate persistence
    frameworks with different kinds of databases (relational as well as NoSQL) in
    the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and macOS. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development IDE**: Based on your preferences, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL**: Instructions to download and install PostgreSQL can be found
    at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if the local database is preferred, then instructions
    to download and install can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Studio 3T for MongoDB**: With the MongoDB local installation, we used Studio
    3T for the GUI. Instructions to download and install Studio 3T can be found at
    [https://studio3t.com/download/](https://studio3t.com/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with persistence in the Micronaut framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To exhibit integration with persistence (database) in the Micronaut framework,
    we will work on three different microservices within the `pet-clinic` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Microservices in the pet-clinic application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Microservices in the pet-clinic application
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate and MyBatis are persistence frameworks for relational databases, whereas
    to integrate with NoSQL (MongoDB), we will use its native synchronous driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will cover each integration technique by doing
    hands-on work with the respective microservice. Each microservice (for the scope
    of this chapter) will be componentized into the following types of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity**: To encapsulate ORMs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: To encapsulate interaction to the underlying Hibernate framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: To contain any business logic as well as concierge calls to the
    downstream repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLI client**: To connect **create-read-update-delete** (**CRUD**) requests
    to the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram depicts these components and their interaction with each
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Microservice components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Microservice components
  prefs: []
  type: TYPE_NORMAL
- en: We will follow the service-repository pattern to separate the concerns and decouple
    components within a microservice. We will cover these components in a bottom-up
    fashion by kickstarting with entities, then repositories, and finally services.
    In the next section, we will explore integrating with a relational database using
    an ORM framework.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with a relational database using an ORM (Hibernate) framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ORM framework enables you to store, query, or manipulate data using the object-oriented
    paradigm. It provides an object-oriented approach to access the data from the
    database or, in other words, instead of using SQL, you can use Java objects to
    interact with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, as a standard specification, the **Java Persistence API** (**JPA**)
    specifies the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Which Java objects ought to be persisted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these objects should be persisted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA is not a framework or tool but it dictates the standard protocol and covers
    the core concepts of what to persist and how to persist. Various implementing
    frameworks such as Hibernate and EclipseLink have adopted these JPA standards.
    We will be using **Hibernate** as our ORM framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get hands-on with Hibernate in the Micronaut framework, we will work on
    the small `pet-clinic` application and, specifically for Hibernate, we will focus
    on the `pet-owner` microservice. The following diagram captures the schema design
    for the `pet-owner` microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The pet-owner schema'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – The pet-owner schema
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, in the `pet-owner` schema, one owner can have zero or more pets
    (of a certain type) and a pet can have zero or more vet visits. In the next section,
    we will get started with setting up the `pet-owner` schema.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the pet-owner schema in PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate the `pet-owner` schema, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download DB-SQL from [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open PostgreSQL's PgAdmin and open the query tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the preceding SQL `pet-owner` user, schema, and tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, run the SQL data to ingest some dummy data into these tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After finishing setting up the schema, we will focus our attention on working
    on the Micronaut project next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Micronaut application for the pet-owner microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to generate boilerplate source code for the `pet-owner` microservice,
    we will use Micronaut Launch. Micronaut Launch is an intuitive interface to generate
    boilerplate and it can be accessed at [https://micronaut.io/launch/](https://micronaut.io/launch/).
    Once opened, this interface will look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Using Micronaut Launch to generate the pet-owner project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Using Micronaut Launch to generate the pet-owner project
  prefs: []
  type: TYPE_NORMAL
- en: 'In Micronaut Launch, we will choose the following features (by clicking on
    the **FEATURES** button):'
  prefs: []
  type: TYPE_NORMAL
- en: '**data-jpa**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hibernate-jpa**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jdbc-hikari**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**logback**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**postgres**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After specifying the aforementioned options, click on the **GENERATE PROJECT**
    button. A ZIP file will be downloaded onto your system. Unzip the downloaded source
    code into your workspace and open the project in your preferred IDE.
  prefs: []
  type: TYPE_NORMAL
- en: In the `pet-owner` microservice application, we will follow the service-repository
    pattern to separate the concerns and decouple components within the microservice.
    As discussed before, we will take a bottom-up approach in covering these components
    by kickstarting with entities, and then exploring repositories and finally services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An entity is a `@Entity` annotation. An entity class definition usually contains
    a set of mappings for each column in the table. Therefore, an entity object instance
    will represent one row in the mapped table.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a domain package to contain all the entity classes. We will create
    the `com.packtpub.micronaut.domain` package under the root package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To map the owners table, we can define an `Owner` entity. Let''s begin with
    mapping basic columns (skipping foreign keys or any relationships):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we are declaring an `Owner` entity class for
    the owners table. To map the primary key, we are using the `@Id` annotation in
    tandem with `@GeneratedValue`. You can generate getters and setters for the mapped
    columns. Similarly, we can define other entity classes: `Pet` for the pets table,
    `Visit` for the visits table, and `PetType` for the types table. We will take
    a look at defining the relationships in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining relationships among entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the Hibernate framework, we can define the following relationship types:'
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-many/many-to-one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-to-many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each relationship type.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a one-to-one relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `pet-owner` example, we do not have a one-to-one relationship between
    any entities. However, let''s consider that all the address information from the
    owners table has been taken out into an addresses table; the resultant schema
    will look as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – One-to-one relationship between owners and addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – One-to-one relationship between owners and addresses
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, one owner will have one address in the preceding schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Owner` entity, to define this relationship, we can use `@OneToOne`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`@JoinColumn` will refer to joining the `address_id` column in the owners table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas this relationship in the `Address` entity will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may note in the `Owner` entity we have defined a one-to-one relationship
    using `@JoinColumn` because the owners table contains `address_id`. However, in
    the `Address` entity, we can simply use `mappedBy` and point to the `address`
    variable defined in the `Owner` entity. JPA will take care of managing this bi-directional
    relationship behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a one-to-many/many-to-one relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fortunately, in the `pet-owner` schema, we have various instances of one-to-many
    or many-to-one relationships (many-to-one is just a flip of a one-to-many relationship).
    To keep it focused, let''s consider the following relationship between the owners
    and pets tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – One-to-many relationship between owners and pets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.6_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – One-to-many relationship between owners and pets
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Owner` entity, the preceding one-to-many relationship will be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Pet` entity, this relationship will be mapped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, if you notice in the `Pet` entity we have a crisply defined relationship
    with `Owner` using `@JoinColumn` (because the pets table contains `owner_id`),
    whereas in the `Owner` entity, we simply used `mappedBy = "owner"`. JPA will take
    care of defining and managing this bi-directional relationship behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a many-to-many relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mapping and managing a many-to-many relationship is a tad more complex. In
    the `pet-owner` schema, we don''t have an instance of a many-to-many relationship,
    so let''s assume a hypothetical relationship between two imaginary entities, `Foo`
    and `Bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Many-to-many relationship between foos and bars'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.7_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Many-to-many relationship between foos and bars
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned many-to-many relationship will be defined as follows in
    the `Foo` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We use `@JoinTable` to map the relationship with a many-to-many table. `joinColumns`
    refers to the column that is owned by the entity, whereas `inverseJoinColumns`
    refers to the column in the co-joining entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Bar` entity will define this relationship as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Just like previous examples, we have crisply defined the many-to-many relationship
    in the `Foo` entity using `@JoinTable`, whereas in the `Bar` entity we have simply
    used `mappedBy`.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we have covered how to define different kinds of relationships
    in the entity classes. Next, we will divert our attention to how to create data
    access repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data access repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hibernate framework enables us to define CRUD access to the database very
    intuitively. For each of the entities, we will define a repository abstract class,
    wherein each repository abstract class will implement `JpaRepository`. `JpaRepository`
    is an out-of-the-box interface defined in `io.micronaut.data.jpa.repository`,
    which further extends `CrudRepository` and `PageableRepository` to declare and
    define standard methods to support common CRUD operations. This reduces the syntactic
    sugar and frees us from defining these methods ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the outset, we will create a new package called `com.packtpub.micronaut.repository`
    to contain all the repositories. All the repository abstract classes will look
    the same and here''s how the `OwnerRepository` will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`OwnerRepository` is using Micronaut''s standard `@Repository` annotation and
    it leverages `JpaRepository` to declare and define standard CRUD methods for the
    `Owner` entity.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can define these abstract classes for other entities as well –
    such as `Pet`, `Visit`, and `PetType` in `io.micronaut.data.jpa.repository`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating services for entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services will contain any business logic as well as downstream access to the
    repositories. We can define standard interfaces for each entity service, which
    will outline basic operations supported in a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To contain all services, we will create a package called `com.packtpub.micronaut.service`.
    The interface for `OwnerService` will be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OwnerService` interface provides an abstract declaration of all service
    methods. We can implement all declared methods in a concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Service method definitions essentially delegate execution to the downstream
    repository. We will repeat steps to declare service interfaces and define concrete
    service classes for the rest of the entities – `Pet`, `Visit`, and `PetType`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus our attention on creating a small command-line
    utility to perform common CRUD operations in the `pet-owner` database.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to exhibit basic CRUD operations on the entities, we will create a
    simple utility. We can create a new package called `com.packtpub.micronaut.utils`
    to define `PetOwnerCliClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This utility will inject all services using the constructor method. Any CRUD
    calls made in this utility will be executed using the injected services.
  prefs: []
  type: TYPE_NORMAL
- en: Performing read/fetch operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define a simple utility method in `PetOwnerCliClient` that can call
    `OwnerService` to fetch all owners. Moreover, since `Owner` has multiple pets
    and each pet can have multiple visits, fetching an owner will fetch pretty much
    everything in the `pet-owner` schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`performFindAll()` will fetch all owners and their pets (along with pet visits).'
  prefs: []
  type: TYPE_NORMAL
- en: Performing a save operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To save an owner with a pet and a visit, we can define a method in `PetOwnerCliClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`initOwner()` initializes an owner with a pet and pet visit, and it will be
    used by `performSave()` to invoke the downstream service class method to save
    this owner.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing a delete operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `PetOwnerCliClient`, we will define a delete method to delete an owner (along
    with their pets and visits):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`performDelete()` first iterates through pets and pet visits; after deleting
    pet visits and pets, it will finally delegate the call to delete the owner.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform `PetOwnerCliClient` CRUD operations, we will add the following code
    logic to `Application.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, when we run our application, the aforementioned `@EventListener` will
    invoke `PetOwnerCliClient` to perform database operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, through the `pet-owner` microservice, we covered how to integrate
    a Micronaut-based microservice with a relational database. We also discussed how
    to define entities, repositories, and services, and lastly exhibited CRUD operations.
    In the next section, we will explore how to integrate with a relational database
    using another type of persistence framework (MyBatis).
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with a relational database using a persistence (MyBatis) framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MyBatis** is a Java persistence framework. Unlike Hibernate (an ORM framework),
    MyBatis does not support the direct mapping of Java objects to the database but
    instead maps Java methods to SQL statements.'
  prefs: []
  type: TYPE_NORMAL
- en: MyBatis is commonly used in migration or transformational projects where a legacy
    database(s) already exists. Since a lot of tables, views, and other data objects
    are already defined and used in the database, it may not be an ideal scenario
    to refactor and normalize these table/view definitions to map them directly to
    Java objects (using an ORM framework). MyBatis offers an ideal way of mapping
    Java methods to SQL statements. These SQL statements, which manage any CRUD access
    thereof, are defined in an XML mapper or POJO mapper using MyBatis annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as an ORM framework (such as Hibernate) manages child entities
    on its own and hides the SQL part completely, some developers prefer to have control
    of interacting with SQL. Therefore, MyBatis can chime in as a preferred persistence
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Micronaut supports integration with relational databases through MyBatis. In
    order to exhibit this integration, we will work on another microservice that will
    manage the veterinary aspect of the pet clinic application. This microservice
    will integrate with the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Pet clinic schema'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.8_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Pet clinic schema
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, one vet can have many specialties and one specialty can belong
    to multiple vets. In the next section, we will get started with setting up the
    `pet-clinic` schema.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the pet-clinic schema in PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate the `pet-clinic` schema, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download DB-SQL from [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open PostgreSQL's PgAdmin and open the query tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the preceding SQL `pet-owner` user, schema, and tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, run the data SQL to ingest some dummy data into these tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After finishing setting up the schema, we will turn our attention to working
    on the Micronaut project next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Micronaut application for the pet-clinic microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to generate boilerplate source code for the `pet-clinic` microservice,
    we will use Micronaut Launch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Using Micronaut Launch for generating the pet-clinic project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.9_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Using Micronaut Launch for generating the pet-clinic project
  prefs: []
  type: TYPE_NORMAL
- en: 'In Micronaut Launch, we will choose the following features (by clicking on
    the **FEATURES** button):'
  prefs: []
  type: TYPE_NORMAL
- en: '**jdbc-hikari**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**logback**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**postgres**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After specifying the aforementioned options, click on the **GENERATE PROJECT**
    button. A ZIP file will be downloaded onto your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unzip the downloaded source code into your workspace and open the project in
    your preferred IDE. Once the project is open in the IDE, add the following dependency
    in `pom.xml` (or `gradle build`) for MyBatis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This dependency is core to our integration with the `pet-clinic` schema in Micronaut.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent with the service-repository pattern, we will explore MyBatis integration
    in a bottom-up fashion. First, we will define entities, and then repositories,
    and finally, we will work on services.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a MyBatis factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To execute various SQL statements, MyBatis would need a `SqlSessionFactory`
    object at runtime. We will begin by adding a package – `com.packtpub.micronaut.config`.
    Add the following class to this newly created package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using standard properties in `application.yml`, Micronaut will define a Hikari-based
    data source, which will be injected to define `SqlSessionFactory`. While defining
    the environment, you can choose any name (as we have given `pet-clinic`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to Hibernate entities, a MyBatis entity fundamentally defines a Java
    class to integrate upstream Java classes with downstream SQL interactions (defined
    in XML or Java mappers). However, a subtle difference is that any MyBatis entity
    will not contain any mapping logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a `com.packtpub.micronaut.domain` package to contain the domain
    entities. Add an entity to represent `Specialty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can define an entity for the vets table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can note that both the entities do not have any mapping logic to map to
    the specialties or vets tables. In the next section, we will focus our attention
    on how to create data access repositories in MyBatis.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the mappers (repositories) for the entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the `Vet` and `Specialty` entities, we will need to define MyBatis mappers.
    MyBatis interacts with the downstream database using these mappers. In comparison
    to a typical Java application, MyBatis mappers are data access repositories. We
    will add a `com.packtpub.micronaut.repository` package to contain all these repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under this package, we will add the `SpecialtyRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we can see all the actual SQL statements, which
    are then bound to Java methods. Therefore, whenever any upstream caller invokes
    any of the aforementioned methods, MyBatis will execute the corresponding mapped
    SQL. On the same note, we will define `VetRepository` to manage access to the
    vets table.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Hibernate (which provides concrete implementations for abstract repository
    classes), in MyBatis we will have to provide concrete implementation for the repositories.
    We will add the implementations to `com.packtpub.micronaut.repository.impl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A concrete implementation for `SpecialtyRepository` can be defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All the concrete method definitions use `SqlSessionFactory` to obtain a `SqlSession`
    instance. The `getSpecialtyRepository()` method will then return the MyBatis mapper
    using this `SqlSession` instance. Similarly, `VetRepositoryImpl` can be defined
    to provide concrete implementations for `VetRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create upstream service classes for these repositories
    we just defined.
  prefs: []
  type: TYPE_NORMAL
- en: Creating services for entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services will contain any business logic as well as downstream access to the
    preceding repositories. We can define standard interfaces for each entity service,
    which will outline basic operations supported in a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To contain all services, first, we will create a package called `com.packtpub.micronaut.service`.
    We can declare an interface for `SpecialtyService` to abstract our barebones structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For these barebones methods, we will need to provide concrete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a package called `com.packtpub.micronaut.service.impl` under the
    service package. The concrete implementation for `SpecialtyService` will be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Concrete service methods are very simple in nature and concierge any calls to
    downstream repository methods. We will add a similar service interface and concrete
    implementation for `Vet` as `VetService` and `VetServiceImpl`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus our attention on creating a small command-line
    utility to perform common CRUD operations in the `pet-clinic` database.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use services and repositories defined in previous sections and to perform
    basic CRUD operations on the entities, we can create a simple utility. We can
    create a new package called `com.packtpub.micronaut.utils` to define `PetClinicCliClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`PetClinicCliClient` injects `VetService` and `SpecialtyService` using the
    constructor method. These services will then be used to perform various database
    operations on the `vets`, `specialties`, and `vet_specialties` tables.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing read/fetch operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define a simple utility method in `PetClinicCliClient` that can call
    `VetService` to fetch all vets. Moreover, since a vet can have multiple specialties,
    fetching a vet will fetch from the specialties table as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `performFindAll()` method fetches all vets along with their specialties
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a save operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will save a vet with a specialty in `PetClinicCliClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `initVet()` method initializes a new vet with a specialty, which is then
    used by the `performSave()` method to persist this object to database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a delete operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `PetClinicCliClient`, we will define a delete method to delete a vet (along
    with their specialties):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `performDelete()` method delegates a call to `VetService`, which then calls
    the repository to finally delete the vet from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform `PetClinicCliClient` CRUD operations, we will add the following
    code logic to `Application.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we run our application, the aforementioned `@EventListener` will invoke
    `PetClinicCliClient` to perform various database operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we integrated with a relational database using MyBatis. We
    covered how to define entities, repositories, and services, and lastly, we exhibited
    basic CRUD operations through a utility. In the next section, we will explore
    integration with a NoSQL database in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with a NoSQL database (MongoDB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MongoDB** is a document-based database and it stores the data in JSON or
    BSON format. Data is stored in key-value pairs, similar to a JSON object. MongoDB
    is engineered in a scale-out fashion and it is recommended to use it when the
    volume and structure of data are agile and growing very rapidly. There are a few
    key terms in contrast to a relational database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database**: A database in MongoDB is much similar to a database in a relational
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table**: A collection (of documents) is much similar to a table in a relational
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Row**: A BSON or JSON document will be a close analogy to a row in a relational
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to do hands-on work, we will continue with the `pet-clinic` application
    and add a new microservice, that is, `pet-clinic-reviews`. This microservice will
    be responsible for managing vet reviews. As reviews could grow rapidly and a schema
    to store a review could change, we will prefer to store this data in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding JSON document depicts a review stored in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will get started with setting up the `pet-clinic-reviews`
    schema in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a vet-reviews collection in MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the `pet-clinic-reviews` microservice, we will create a database and collection
    in the MongoDB instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Studio 3T or any other preferred GUI for MongoDB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to your localhost instance or any other preferred instance (such as
    MongoDB Atlas).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under `pet-clinic-reviews`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the aforementioned database, we will create a new collection: `vet-reviews`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ingest some dummy data into this collection, use the import option to import
    data (CSV or JSON) from [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After finishing setting up the schema, we will turn our attention to working
    on the Micronaut project next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Micronaut application for the pet-clinic-reviews microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to generate boilerplate source code for the `pet-clinic-reviews` microservice,
    we will use Micronaut Launch. It is an intuitive interface to generate boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Using Micronaut Launch to generate the pet-clinic-reviews project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Using Micronaut Launch to generate the pet-clinic-reviews project
  prefs: []
  type: TYPE_NORMAL
- en: 'In Micronaut Launch, we will choose the following features (by clicking on
    the **FEATURES** button):'
  prefs: []
  type: TYPE_NORMAL
- en: '**mongodb-sync** (synchronous access to MongoDB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**logback**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After specifying the aforementioned options, click on the **GENERATE PROJECT**
    button. A ZIP file will be downloaded onto your system. Unzip the downloaded source
    code into your workspace and open the project in your preferred IDE.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will dive deeper into how to integrate the `pet-clinic-reviews`
    microservice with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring MongoDB in Micronaut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the freshly created `pet-clinic-reviews` project, we would need to update
    the URI in `application.yml` to point to the correct instance of MongoDB. Furthermore,
    we will define two new custom properties – `databaseName` and `collectionName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the aforementioned database and collection across the project, we can
    define a configuration class in a new package – `com.packtpub.micronaut.config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will enable easy access to both the `databaseName` and `collectionName`
    properties across the project and we will not need to use `@Value`. Besides, since
    these properties are read-only, we will only define getters for these properties.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create an entity class to define the vet review object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the entity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the root level, add a new package called `com.packtpub.micronaut.domain`.
    This package will contain the domain/entity for the vet review. We can define
    the following POJO to represent a vet review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`@BsonCreator` and `@JsonCreator` piggyback on the class constructor to map
    an object of `VetReview` to the corresponding BSON or JSON document. This will
    come in handy while fetching or storing a document from MongoDB and therefore
    mapping it to a Java object.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will focus our attention on how to create the data access repository
    for `VetReview`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data access repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage access to the `vet-reviews` collection, we will create a repository.
    We can add `com.packtpub.micronaut.repository` to contain this repository class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To abstract out all the methods that the repository will expose, we can declare
    an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`VetReviewRepository` outlines essential operations supported in this repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to provide a concrete implementation for the `VetReviewRepository`
    interface in the `com.packtpub.micronaut.repository.impl` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `getCollection()` method in this concrete class will get the database and
    collection from MongoDB. Saving to and deleting from this collection is straightforward,
    as shown previously. To find it based on a certain condition, we can use `find()`
    with `eq()`. `eq()` is a BSON filter defined in the MongoDB driver itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service for the entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A service will encapsulate any business logic as well as downstream access to
    the `vet-reviews` collection (in MongoDB). We can declare an interface to abstract
    out core methods in a service. To contain a service, we should first create a
    package called `com.packtpub.micronaut.service` under the root package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VetReviewService` interface can then be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VetReviewService` interface will declare barebones methods supported by
    this service. To provide concrete implementation for these methods, we will create
    a `VetServiceImpl` class under the `com.packtpub.micronaut.service.impl` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Concrete implementations for these methods are essentially delegating the call
    to `VetReviewRepository`. However, for any future needs, these methods can be
    extended to contain any business logic, such as data validations or data transformation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus our attention on creating a small command-line
    utility to perform common CRUD operations on the `pet-clinic-reviews` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to perform basic CRUD operations on the `VetReview` entity, we can
    create a simple utility. We can create a new package called `com.packtpub.micronaut.utils`
    to define `PetClinicReviewCliClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This utility will inject `VetReviewService` using the constructor. We will delegate
    the CRUD calls via this service.
  prefs: []
  type: TYPE_NORMAL
- en: Performing read/fetch operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define a simple utility method in `PetClinicReviewCliClient` that can
    call `VetReviewService` to fetch all vet reviews or a specific vet review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`performFindAll()` will fetch all vet reviews in the collection, whereas `performFindByReviewId()`
    will fetch a specific review by `reviewId`.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing a save operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will save a vet review through a method in `PetClinicReviewCliClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Though we are defining a vet review object in Java, the constructor in the `VetReview`
    entity will take care of mapping this object to `BsonDocument` and downstream
    code in `VetReviewRepository` will save this document to the `vet-reviews` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a delete operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `PetClinicReviewCliClient`, we will define a delete method to `delete` a
    vet review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is a small method and it delegates the call to `VetReviewService` for deletion.
    `VetReviewService` further invokes the repository to delete the given vet review
    from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `Application.java`, we can call `PetClinicReviewCliClient` as a startup
    event, which can then exhibit basic CRUD operations on the `vet-reviews` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When we kickstart our application, the aforementioned `@EventListener` will
    invoke `PetClinicReviewCliClient` to perform database operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered how to integrate a Micronaut application with MongoDB.
    We defined the entity, repository, and service to access the MongoDB database.
    Lastly, we exhibited CRUD operations through a light utility.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various aspects of integrating a Micronaut application
    with relational as well as NoSQL databases. We explored different ways of persistence
    integration, that is, using ORM (Hibernate), a persistence framework (MyBatis),
    or a driver-based framework (MongoDB Sync). In each technique, we covered, in
    depth, how to define entities, relationships, repositories, and services. Each
    microservice defined a simple command-line utility to exhibit common CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has given us the skills to cover almost all the data access aspects
    in Micronaut. In the rest of the book, we will further explore and use these skills
    and learnings by doing more hands-on exercises and covering other aspects of the
    Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on the web layer of the `pet-clinic` application,
    defining various REST endpoints in all the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an **object-relational mapping** (**ORM**) framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Hibernate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you define an entity using Hibernate in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you map a one-to-one relationship using Hibernate in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you map a one-to-many or many-to-one relationship using Hibernate in
    Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you map many-to-many relationships using Hibernate in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you perform CRUD operations using Hibernate in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you integrate with a relational database using MyBatis in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you define MyBatis mappers in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you perform CRUD operations using MyBatis in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you integrate with a NoSQL (MongoDB) database in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you perform CRUD operations in MongoDB in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
