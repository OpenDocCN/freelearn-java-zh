- en: '*Chapter 2*: Working on Data Access'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：数据访问工作'
- en: 'Any microservice adoption is incomplete without integrating with persistence
    or data storage. In this chapter, we will explore various aspects of persistence
    and data access in the Micronaut framework. We will begin by using an **object-relational
    mapping** (**ORM**) framework to integrate with a relational database. Then, we
    will dive into integrating a database using a persistence framework. Furthermore,
    in the end, we will see an example of integrating a NoSQL database. To cover these
    topics, we will work on a pet clinic application. This application will be composed
    of the following microservices:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何微服务的采用如果没有与持久化或数据存储集成都是不完整的。在本章中，我们将探讨 Micronaut 框架中持久化和数据访问的各个方面。我们将首先使用一个
    **对象关系映射**（**ORM**）框架来与关系型数据库集成。然后，我们将深入探讨使用持久化框架集成数据库。此外，最后，我们将看到一个集成 NoSQL 数据库的示例。为了涵盖这些主题，我们将开发一个宠物诊所应用程序。该应用程序将由以下微服务组成：
- en: '`pet-owner`: A microservice to integrate with a relational database using an
    ORM framework in Micronaut'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-owner`：一个使用 Micronaut 中的对象关系映射（ORM）框架与关系型数据库集成的微服务'
- en: '`pet-clinic`: A microservice to integrate with a relational database using
    a persistence framework in Micronaut'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-clinic`：一个使用 Micronaut 中的持久化框架与关系型数据库集成的微服务'
- en: '`pet-clinic-review`: A microservice to integrate with a NoSQL database in Micronaut'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-clinic-review`：一个与 Micronaut 中的 NoSQL 数据库集成的微服务'
- en: By the end of this chapter, you will have good and hands-on knowledge of working
    with various kinds of persistence frameworks and how to integrate persistence
    frameworks with different kinds of databases (relational as well as NoSQL) in
    the Micronaut framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备良好的实践知识，了解如何使用各种类型的持久化框架，以及如何在 Micronaut 框架中将持久化框架与不同类型的数据库（关系型数据库以及
    NoSQL 数据库）集成。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and macOS. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的命令和技术说明都是在 Windows 10 和 macOS 上运行的。本章涵盖的代码示例可在本书的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02)。
- en: 'The following tools need to be installed and set up in the development environment:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在开发环境中安装和设置以下工具：
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**：版本 13 或更高（我们使用了 Java 14）。'
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**：这是可选的，仅当您想使用 Maven 作为构建系统时才需要。然而，我们建议在任何开发机器上设置 Maven。有关下载和安装 Maven
    的说明，请参阅 [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)。'
- en: '**Development IDE**: Based on your preferences, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发 IDE**：根据您的偏好，可以使用任何基于 Java 的 IDE，但为了编写本章，使用了 IntelliJ。'
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：有关下载和安装 Git 的说明，请参阅 [https://git-scm.com/downloads](https://git-scm.com/downloads)。'
- en: '**PostgreSQL**: Instructions to download and install PostgreSQL can be found
    at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**：有关下载和安装 PostgreSQL 的说明，请参阅 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)。'
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if the local database is preferred, then instructions
    to download and install can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：MongoDB Atlas 提供了一个免费的在线数据库即服务，存储空间高达 512 MB。但是，如果您更喜欢本地数据库，则可以找到下载和安装的说明，网址为
    [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)。我们为本章的编写使用了本地安装。'
- en: '**Studio 3T for MongoDB**: With the MongoDB local installation, we used Studio
    3T for the GUI. Instructions to download and install Studio 3T can be found at
    [https://studio3t.com/download/](https://studio3t.com/download/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB Studio 3T**: 在MongoDB本地安装中，我们使用了Studio 3T的图形用户界面。有关下载和安装Studio 3T的说明，请参阅[https://studio3t.com/download/](https://studio3t.com/download/)。'
- en: Integrating with persistence in the Micronaut framework
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Micronaut框架中集成持久化
- en: 'To exhibit integration with persistence (database) in the Micronaut framework,
    we will work on three different microservices within the `pet-clinic` application:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Micronaut框架中展示持久化（数据库）的集成，我们将在`pet-clinic`应用程序中的三个不同的微服务上进行工作：
- en: '![Figure 2.1 – Microservices in the pet-clinic application'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – pet-clinic应用程序中的微服务'
- en: '](img/Figure_2.1_B16585.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.1_B16585.jpg)'
- en: Figure 2.1 – Microservices in the pet-clinic application
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – pet-clinic应用程序中的微服务
- en: Hibernate and MyBatis are persistence frameworks for relational databases, whereas
    to integrate with NoSQL (MongoDB), we will use its native synchronous driver.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate和MyBatis是关系型数据库的持久化框架，而要集成NoSQL（MongoDB），我们将使用其原生的同步驱动程序。
- en: 'In the following sections, we will cover each integration technique by doing
    hands-on work with the respective microservice. Each microservice (for the scope
    of this chapter) will be componentized into the following types of components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将通过分别与各自的微服务进行实际操作来介绍每种集成技术。每个微服务（在本章的范围内）将被组件化为以下类型的组件：
- en: '**Entity**: To encapsulate ORMs'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体（Entity）**: 用于封装ORM'
- en: '**Repository**: To encapsulate interaction to the underlying Hibernate framework'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储库（Repository）**: 用于封装与底层Hibernate框架的交互'
- en: '**Service**: To contain any business logic as well as concierge calls to the
    downstream repository'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务（Service）**: 用于包含任何业务逻辑以及下游存储库的礼宾服务调用'
- en: '**CLI client**: To connect **create-read-update-delete** (**CRUD**) requests
    to the service'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLI客户端（CLI client）**: 将**创建-读取-更新-删除**（**CRUD**）请求连接到服务'
- en: 'The following diagram depicts these components and their interaction with each
    other:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了这些组件及其相互之间的交互：
- en: '![Figure 2.2 – Microservice components'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – 微服务组件'
- en: '](img/Figure_2.2_B16585_Fixed.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.2_B16585_Fixed.jpg)'
- en: Figure 2.2 – Microservice components
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 微服务组件
- en: We will follow the service-repository pattern to separate the concerns and decouple
    components within a microservice. We will cover these components in a bottom-up
    fashion by kickstarting with entities, then repositories, and finally services.
    In the next section, we will explore integrating with a relational database using
    an ORM framework.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循服务-存储库模式来分离关注点并在微服务内部解耦组件。我们将自下而上地介绍这些组件，首先从实体开始，然后是存储库，最后是服务。在下一节中，我们将探讨使用ORM框架集成关系型数据库。
- en: Integrating with a relational database using an ORM (Hibernate) framework
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ORM（Hibernate）框架集成关系型数据库
- en: An ORM framework enables you to store, query, or manipulate data using the object-oriented
    paradigm. It provides an object-oriented approach to access the data from the
    database or, in other words, instead of using SQL, you can use Java objects to
    interact with the database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ORM框架使您能够使用面向对象范式存储、查询或操作数据。它提供了一种面向对象的方法来访问数据库中的数据，换句话说，您可以使用Java对象与数据库交互，而不是使用SQL。
- en: 'In Java, as a standard specification, the **Java Persistence API** (**JPA**)
    specifies the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，作为一个标准规范，**Java持久化API**（**JPA**）规定了以下内容：
- en: Which Java objects ought to be persisted
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该持久化哪些Java对象
- en: How these objects should be persisted
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些对象应该如何持久化
- en: JPA is not a framework or tool but it dictates the standard protocol and covers
    the core concepts of what to persist and how to persist. Various implementing
    frameworks such as Hibernate and EclipseLink have adopted these JPA standards.
    We will be using **Hibernate** as our ORM framework.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JPA不是一个框架或工具，但它规定了标准协议并涵盖了持久化的核心概念以及如何持久化。Hibernate和EclipseLink等各种实现框架已采用这些JPA标准。我们将使用**Hibernate**作为我们的ORM框架。
- en: 'To get hands-on with Hibernate in the Micronaut framework, we will work on
    the small `pet-clinic` application and, specifically for Hibernate, we will focus
    on the `pet-owner` microservice. The following diagram captures the schema design
    for the `pet-owner` microservice:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Micronaut框架中亲身体验Hibernate，我们将工作于小的`pet-clinic`应用程序，并且对于Hibernate，我们将专注于`pet-owner`微服务。以下图表捕捉了`pet-owner`微服务的模式设计：
- en: '![Figure 2.3 – The pet-owner schema'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 宠物所有者模式'
- en: '](img/Figure_2.3_B16585.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.3_B16585.jpg)'
- en: Figure 2.3 – The pet-owner schema
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – pet-owner模式
- en: Essentially, in the `pet-owner` schema, one owner can have zero or more pets
    (of a certain type) and a pet can have zero or more vet visits. In the next section,
    we will get started with setting up the `pet-owner` schema.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，在`pet-owner`模式中，一个所有者可以拥有零个或多个宠物（某种类型的）并且一个宠物可以有零个或多个兽医访问。在下一节中，我们将开始设置`pet-owner`模式。
- en: Generating the pet-owner schema in PostgreSQL
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PostgreSQL中生成pet-owner模式
- en: 'To generate the `pet-owner` schema, follow these instructions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成`pet-owner`模式，请按照以下说明操作：
- en: Download DB-SQL from [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt)下载DB-SQL。
- en: Open PostgreSQL's PgAdmin and open the query tool.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PostgreSQL的PgAdmin并打开查询工具。
- en: Run the preceding SQL `pet-owner` user, schema, and tables.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`pet-owner`用户、模式和表运行前面的SQL。
- en: Finally, run the SQL data to ingest some dummy data into these tables.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行SQL数据将这些表中的某些示例数据导入。
- en: After finishing setting up the schema, we will focus our attention on working
    on the Micronaut project next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完模式后，我们将专注于在Micronaut项目中工作。
- en: Creating a Micronaut application for the pet-owner microservice
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为pet-owner微服务创建Micronaut应用程序
- en: 'In order to generate boilerplate source code for the `pet-owner` microservice,
    we will use Micronaut Launch. Micronaut Launch is an intuitive interface to generate
    boilerplate and it can be accessed at [https://micronaut.io/launch/](https://micronaut.io/launch/).
    Once opened, this interface will look as in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成`pet-owner`微服务的样板源代码，我们将使用Micronaut Launch。Micronaut Launch是一个直观的界面，用于生成样板，并且可以在[https://micronaut.io/launch/](https://micronaut.io/launch/)访问。一旦打开，此界面将看起来如下截图所示：
- en: '![Figure 2.4 – Using Micronaut Launch to generate the pet-owner project'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 使用Micronaut Launch生成pet-owner项目'
- en: '](img/Figure_2.4_B16585_Fixed.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.4_B16585_Fixed.jpg)'
- en: Figure 2.4 – Using Micronaut Launch to generate the pet-owner project
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 使用Micronaut Launch生成pet-owner项目
- en: 'In Micronaut Launch, we will choose the following features (by clicking on
    the **FEATURES** button):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Micronaut Launch中，我们将选择以下功能（通过点击**功能**按钮）：
- en: '**data-jpa**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**data-jpa**'
- en: '**hibernate-jpa**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hibernate-jpa**'
- en: '**jdbc-hikari**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jdbc-hikari**'
- en: '**logback**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logback**'
- en: '**postgres**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**postgres**'
- en: After specifying the aforementioned options, click on the **GENERATE PROJECT**
    button. A ZIP file will be downloaded onto your system. Unzip the downloaded source
    code into your workspace and open the project in your preferred IDE.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定上述选项后，点击**生成项目**按钮。系统将下载一个ZIP文件。将下载的源代码解压到您的工作区，并在您首选的IDE中打开项目。
- en: In the `pet-owner` microservice application, we will follow the service-repository
    pattern to separate the concerns and decouple components within the microservice.
    As discussed before, we will take a bottom-up approach in covering these components
    by kickstarting with entities, and then exploring repositories and finally services.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pet-owner`微服务应用程序中，我们将遵循服务-存储库模式来分离关注点并解耦微服务内的组件。如前所述，我们将采取自下而上的方法来涵盖这些组件，从实体开始，然后探索存储库，最后是服务。
- en: Creating the entity classes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体类
- en: An entity is a `@Entity` annotation. An entity class definition usually contains
    a set of mappings for each column in the table. Therefore, an entity object instance
    will represent one row in the mapped table.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是一个`@Entity`注解。实体类定义通常包含对表中每个列的映射集合。因此，实体对象实例将代表映射表中的一行。
- en: We will create a domain package to contain all the entity classes. We will create
    the `com.packtpub.micronaut.domain` package under the root package.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个域包来包含所有实体类。我们将在根包下创建`com.packtpub.micronaut.domain`包。
- en: 'To map the owners table, we can define an `Owner` entity. Let''s begin with
    mapping basic columns (skipping foreign keys or any relationships):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了映射所有者表，我们可以定义一个`Owner`实体。让我们从映射基本列开始（跳过外键或任何关系）：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code snippet, we are declaring an `Owner` entity class for
    the owners table. To map the primary key, we are using the `@Id` annotation in
    tandem with `@GeneratedValue`. You can generate getters and setters for the mapped
    columns. Similarly, we can define other entity classes: `Pet` for the pets table,
    `Visit` for the visits table, and `PetType` for the types table. We will take
    a look at defining the relationships in the next section.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们为所有者表声明了一个 `Owner` 实体类。为了映射主键，我们使用 `@Id` 注解与 `@GeneratedValue` 一起使用。你可以为映射的列生成
    getter 和 setter。同样，我们可以定义其他实体类：`Pet` 用于宠物表，`Visit` 用于访问表，`PetType` 用于类型表。我们将在下一节中查看定义关系。
- en: Defining relationships among entities
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义实体之间的关系
- en: 'Using the Hibernate framework, we can define the following relationship types:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hibernate 框架，我们可以定义以下关系类型：
- en: One-to-one
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一
- en: One-to-many/many-to-one
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多/多对一
- en: Many-to-many
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多
- en: Let's take a look at each relationship type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种关系类型。
- en: Mapping a one-to-one relationship
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射一对一关系
- en: 'In the `pet-owner` example, we do not have a one-to-one relationship between
    any entities. However, let''s consider that all the address information from the
    owners table has been taken out into an addresses table; the resultant schema
    will look as in the following figure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pet-owner` 示例中，我们没有在任何实体之间定义一对一关系。然而，让我们考虑所有来自所有者表的地址信息已经被提取到一个地址表中；结果架构将如下所示：
- en: '![Figure 2.5 – One-to-one relationship between owners and addresses'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – 所有者和地址之间的一对一关系'
- en: '](img/Figure_2.5_B16585.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B16585.jpg)'
- en: Figure 2.5 – One-to-one relationship between owners and addresses
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 所有者和地址之间的一对一关系
- en: Essentially, one owner will have one address in the preceding schema.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，在先前的架构中，一个所有者将有一个地址。
- en: 'In the `Owner` entity, to define this relationship, we can use `@OneToOne`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Owner` 实体中，为了定义这个关系，我们可以使用 `@OneToOne`：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`@JoinColumn` will refer to joining the `address_id` column in the owners table.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`@JoinColumn` 将引用连接所有者表中的 `address_id` 列。'
- en: 'Whereas this relationship in the `Address` entity will be defined as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 `Address` 实体中的这个关系将定义如下：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may note in the `Owner` entity we have defined a one-to-one relationship
    using `@JoinColumn` because the owners table contains `address_id`. However, in
    the `Address` entity, we can simply use `mappedBy` and point to the `address`
    variable defined in the `Owner` entity. JPA will take care of managing this bi-directional
    relationship behind the scenes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到在 `Owner` 实体中，我们使用 `@JoinColumn` 定义了一个一对一关系，因为所有者表包含 `address_id`。然而，在
    `Address` 实体中，我们可以简单地使用 `mappedBy` 并指向在 `Owner` 实体中定义的 `address` 变量。JPA 将在幕后处理这个双向关系。
- en: Mapping a one-to-many/many-to-one relationship
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射一对多/多对一关系
- en: 'Fortunately, in the `pet-owner` schema, we have various instances of one-to-many
    or many-to-one relationships (many-to-one is just a flip of a one-to-many relationship).
    To keep it focused, let''s consider the following relationship between the owners
    and pets tables:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 `pet-owner` 架构中，我们有许多一对一或多对一关系（多对一只是一对多关系的反转）。为了保持专注，让我们考虑所有者和宠物表之间的以下关系：
- en: '![Figure 2.6 – One-to-many relationship between owners and pets'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – 所有者和宠物之间的一对多关系'
- en: '](img/Figure_2.6_B16585.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.6_B16585.jpg)'
- en: Figure 2.6 – One-to-many relationship between owners and pets
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 所有者和宠物之间的一对多关系
- en: 'In the `Owner` entity, the preceding one-to-many relationship will be defined
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Owner` 实体中，前面的多对一关系将定义如下：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `Pet` entity, this relationship will be mapped as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Pet` 实体中，这个关系将映射如下：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, if you notice in the `Pet` entity we have a crisply defined relationship
    with `Owner` using `@JoinColumn` (because the pets table contains `owner_id`),
    whereas in the `Owner` entity, we simply used `mappedBy = "owner"`. JPA will take
    care of defining and managing this bi-directional relationship behind the scenes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你注意到在 `Pet` 实体中，我们使用 `@JoinColumn` 与 `Owner` 定义了一个清晰的关系（因为宠物表包含 `owner_id`），而在
    `Owner` 实体中，我们简单地使用了 `mappedBy = "owner"`。JPA 将在幕后处理这个双向关系的定义和管理。
- en: Mapping a many-to-many relationship
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射多对多关系
- en: 'Mapping and managing a many-to-many relationship is a tad more complex. In
    the `pet-owner` schema, we don''t have an instance of a many-to-many relationship,
    so let''s assume a hypothetical relationship between two imaginary entities, `Foo`
    and `Bar`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和管理多对多关系稍微复杂一些。在`pet-owner`模式中，我们没有多对多关系的实例，所以让我们假设两个虚构实体`Foo`和`Bar`之间的一种假设关系：
- en: '![Figure 2.7 – Many-to-many relationship between foos and bars'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – `foo`和`bar`之间的多对多关系'
- en: '](img/Figure_2.7_B16585.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.7_B16585.jpg)'
- en: Figure 2.7 – Many-to-many relationship between foos and bars
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – `foo`和`bar`之间的多对多关系
- en: 'The aforementioned many-to-many relationship will be defined as follows in
    the `Foo` entity:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Foo`实体中，上述的多对多关系将被定义为以下内容：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We use `@JoinTable` to map the relationship with a many-to-many table. `joinColumns`
    refers to the column that is owned by the entity, whereas `inverseJoinColumns`
    refers to the column in the co-joining entity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@JoinTable`将关系映射到一个多对多表。`joinColumns`指的是实体拥有的列，而`inverseJoinColumns`指的是联合实体中的列。
- en: 'The `Bar` entity will define this relationship as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bar`实体将如下定义这种关系：'
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just like previous examples, we have crisply defined the many-to-many relationship
    in the `Foo` entity using `@JoinTable`, whereas in the `Bar` entity we have simply
    used `mappedBy`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的例子一样，我们使用`@JoinTable`在`Foo`实体中清晰地定义了多对多关系，而在`Bar`实体中我们只是简单地使用了`mappedBy`。
- en: Up until now, we have covered how to define different kinds of relationships
    in the entity classes. Next, we will divert our attention to how to create data
    access repositories.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何在实体类中定义不同类型的关系。接下来，我们将转向如何创建数据访问仓库。
- en: Creating data access repositories
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据访问仓库
- en: The Hibernate framework enables us to define CRUD access to the database very
    intuitively. For each of the entities, we will define a repository abstract class,
    wherein each repository abstract class will implement `JpaRepository`. `JpaRepository`
    is an out-of-the-box interface defined in `io.micronaut.data.jpa.repository`,
    which further extends `CrudRepository` and `PageableRepository` to declare and
    define standard methods to support common CRUD operations. This reduces the syntactic
    sugar and frees us from defining these methods ourselves.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate框架使我们能够非常直观地定义对数据库的CRUD访问。对于每个实体，我们将定义一个仓库抽象类，其中每个仓库抽象类将实现`JpaRepository`。`JpaRepository`是`io.micronaut.data.jpa.repository`中定义的一个现成接口，它进一步扩展了`CrudRepository`和`PageableRepository`，以声明和定义支持常见CRUD操作的标准方法。这减少了语法糖，并使我们免于自己定义这些方法。
- en: 'At the outset, we will create a new package called `com.packtpub.micronaut.repository`
    to contain all the repositories. All the repository abstract classes will look
    the same and here''s how the `OwnerRepository` will look:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`com.packtpub.micronaut.repository`的新包来包含所有仓库。所有的仓库抽象类看起来都一样，以下是`OwnerRepository`的示例：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`OwnerRepository` is using Micronaut''s standard `@Repository` annotation and
    it leverages `JpaRepository` to declare and define standard CRUD methods for the
    `Owner` entity.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnerRepository`使用Micronaut的标准`@Repository`注解，并利用`JpaRepository`来声明和定义`Owner`实体的标准CRUD方法。'
- en: Similarly, we can define these abstract classes for other entities as well –
    such as `Pet`, `Visit`, and `PetType` in `io.micronaut.data.jpa.repository`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以为其他实体定义这些抽象类，例如在`io.micronaut.data.jpa.repository`中的`Pet`、`Visit`和`PetType`。
- en: Creating services for entities
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体的服务
- en: Services will contain any business logic as well as downstream access to the
    repositories. We can define standard interfaces for each entity service, which
    will outline basic operations supported in a service.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将包含任何业务逻辑以及到仓库的下层访问。我们可以为每个实体服务定义标准接口，这将概述服务中支持的基本操作。
- en: 'To contain all services, we will create a package called `com.packtpub.micronaut.service`.
    The interface for `OwnerService` will be declared as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包含所有服务，我们将创建一个名为`com.packtpub.micronaut.service`的包。`OwnerService`接口的声明如下：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `OwnerService` interface provides an abstract declaration of all service
    methods. We can implement all declared methods in a concrete class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnerService`接口提供了一个所有服务方法的抽象声明。我们可以在一个具体类中实现所有声明的方法：'
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Service method definitions essentially delegate execution to the downstream
    repository. We will repeat steps to declare service interfaces and define concrete
    service classes for the rest of the entities – `Pet`, `Visit`, and `PetType`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 服务方法定义基本上是将执行委托给下游仓库。我们将重复声明服务接口和定义其余实体（`Pet`、`Visit` 和 `PetType`）的具体服务类。
- en: In the next section, we will focus our attention on creating a small command-line
    utility to perform common CRUD operations in the `pet-owner` database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将专注于创建一个小型命令行工具，以在 `pet-owner` 数据库中执行常见的 CRUD 操作。
- en: Performing basic CRUD operations
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行基本的 CRUD 操作
- en: 'In order to exhibit basic CRUD operations on the entities, we will create a
    simple utility. We can create a new package called `com.packtpub.micronaut.utils`
    to define `PetOwnerCliClient`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示实体的基本 CRUD 操作，我们将创建一个简单的实用工具。我们可以在 `com.packtpub.micronaut.utils` 新包中定义
    `PetOwnerCliClient`：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This utility will inject all services using the constructor method. Any CRUD
    calls made in this utility will be executed using the injected services.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此实用工具将通过构造函数方法注入所有服务。在此实用工具中进行的任何 CRUD 调用都将使用注入的服务执行。
- en: Performing read/fetch operations
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行读取/检索操作
- en: 'We can define a simple utility method in `PetOwnerCliClient` that can call
    `OwnerService` to fetch all owners. Moreover, since `Owner` has multiple pets
    and each pet can have multiple visits, fetching an owner will fetch pretty much
    everything in the `pet-owner` schema:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `PetOwnerCliClient` 中定义一个简单的实用方法，该方法可以调用 `OwnerService` 来检索所有所有者。此外，由于
    `Owner` 有多个宠物，每个宠物可以有多个访问记录，因此检索一个所有者将检索 `pet-owner` 模式中的几乎所有内容：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`performFindAll()` will fetch all owners and their pets (along with pet visits).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`performFindAll()` 将检索所有所有者和他们的宠物（包括宠物访问记录）。'
- en: Performing a save operation
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行保存操作
- en: 'To save an owner with a pet and a visit, we can define a method in `PetOwnerCliClient`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存一个拥有宠物和访问记录的所有者，我们可以在 `PetOwnerCliClient` 中定义一个方法：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`initOwner()` initializes an owner with a pet and pet visit, and it will be
    used by `performSave()` to invoke the downstream service class method to save
    this owner.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`initOwner()` 初始化一个拥有宠物和宠物访问记录的所有者，它将被 `performSave()` 用于调用下游服务类方法以保存此所有者。'
- en: Performing a delete operation
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行删除操作
- en: 'In `PetOwnerCliClient`, we will define a delete method to delete an owner (along
    with their pets and visits):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PetOwnerCliClient` 中，我们将定义一个删除方法来删除一个所有者（包括他们的宠物和访问记录）：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`performDelete()` first iterates through pets and pet visits; after deleting
    pet visits and pets, it will finally delegate the call to delete the owner.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`performDelete()` 首先遍历宠物和宠物访问记录；删除宠物访问记录和宠物后，它最终将调用删除所有者的操作。'
- en: Wrapping up
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'To perform `PetOwnerCliClient` CRUD operations, we will add the following code
    logic to `Application.java`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 `PetOwnerCliClient` CRUD 操作，我们将在 `Application.java` 中添加以下代码逻辑：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, when we run our application, the aforementioned `@EventListener` will
    invoke `PetOwnerCliClient` to perform database operations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们运行应用程序时，上述 `@EventListener` 将调用 `PetOwnerCliClient` 来执行数据库操作。
- en: In this section, through the `pet-owner` microservice, we covered how to integrate
    a Micronaut-based microservice with a relational database. We also discussed how
    to define entities, repositories, and services, and lastly exhibited CRUD operations.
    In the next section, we will explore how to integrate with a relational database
    using another type of persistence framework (MyBatis).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，通过 `pet-owner` 微服务，我们介绍了如何将基于 Micronaut 的微服务与关系型数据库集成。我们还讨论了如何定义实体、仓库和服务，最后展示了
    CRUD 操作。在下一节中，我们将探讨如何使用另一种持久化框架（MyBatis）与关系型数据库集成。
- en: Integrating with a relational database using a persistence (MyBatis) framework
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用持久化（MyBatis）框架与关系型数据库集成
- en: '**MyBatis** is a Java persistence framework. Unlike Hibernate (an ORM framework),
    MyBatis does not support the direct mapping of Java objects to the database but
    instead maps Java methods to SQL statements.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**MyBatis** 是一个 Java 持久化框架。与 Hibernate（一个 ORM 框架）不同，MyBatis 不支持直接将 Java 对象映射到数据库，而是将
    Java 方法映射到 SQL 语句。'
- en: MyBatis is commonly used in migration or transformational projects where a legacy
    database(s) already exists. Since a lot of tables, views, and other data objects
    are already defined and used in the database, it may not be an ideal scenario
    to refactor and normalize these table/view definitions to map them directly to
    Java objects (using an ORM framework). MyBatis offers an ideal way of mapping
    Java methods to SQL statements. These SQL statements, which manage any CRUD access
    thereof, are defined in an XML mapper or POJO mapper using MyBatis annotations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: MyBatis通常用于迁移或转换项目中，其中已经存在遗留数据库（s）。由于许多表、视图和其他数据对象已经在数据库中定义并使用，因此将这些表/视图定义重构和规范化以直接映射到Java对象（使用ORM框架）可能不是一个理想的情况。MyBatis提供了一种将Java方法映射到SQL语句的理想方式。这些管理任何CRUD访问的SQL语句，使用MyBatis注解定义在XML映射器或POJO映射器中。
- en: Furthermore, as an ORM framework (such as Hibernate) manages child entities
    on its own and hides the SQL part completely, some developers prefer to have control
    of interacting with SQL. Therefore, MyBatis can chime in as a preferred persistence
    framework.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于ORM框架（如Hibernate）会自行管理子实体并完全隐藏SQL部分，一些开发者更喜欢控制与SQL的交互。因此，MyBatis可以作为首选的持久化框架介入。
- en: 'Micronaut supports integration with relational databases through MyBatis. In
    order to exhibit this integration, we will work on another microservice that will
    manage the veterinary aspect of the pet clinic application. This microservice
    will integrate with the following schema:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut支持通过MyBatis与关系数据库集成。为了展示这种集成，我们将工作在另一个微服务上，该微服务将管理宠物诊所应用程序的兽医方面。此微服务将集成以下架构：
- en: '![Figure 2.8 – Pet clinic schema'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.8 – Pet clinic schema'
- en: '](img/Figure_2.8_B16585.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.8_B16585.jpg)'
- en: Figure 2.8 – Pet clinic schema
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 宠物诊所架构
- en: Essentially, one vet can have many specialties and one specialty can belong
    to multiple vets. In the next section, we will get started with setting up the
    `pet-clinic` schema.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一位兽医可以有许多专长，而一种专长可以属于多位兽医。在下一节中，我们将开始设置`pet-clinic`架构。
- en: Generating the pet-clinic schema in PostgreSQL
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PostgreSQL中生成pet-clinic架构
- en: 'To generate the `pet-clinic` schema, follow these instructions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成`pet-clinic`架构，请遵循以下说明：
- en: Download DB-SQL from [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt)下载DB-SQL。
- en: Open PostgreSQL's PgAdmin and open the query tool.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PostgreSQL的PgAdmin并打开查询工具。
- en: Run the preceding SQL `pet-owner` user, schema, and tables.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`pet-owner`用户、架构和表运行前面的SQL。
- en: Lastly, run the data SQL to ingest some dummy data into these tables.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行数据SQL将这些示例数据导入这些表中。
- en: After finishing setting up the schema, we will turn our attention to working
    on the Micronaut project next.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置架构完成后，我们将把注意力转向Micronaut项目。
- en: Generating a Micronaut application for the pet-clinic microservice
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为pet-clinic微服务生成Micronaut应用程序
- en: 'In order to generate boilerplate source code for the `pet-clinic` microservice,
    we will use Micronaut Launch:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成`pet-clinic`微服务的样板源代码，我们将使用Micronaut Launch：
- en: '![Figure 2.9 – Using Micronaut Launch for generating the pet-clinic project'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.9 – Using Micronaut Launch for generating the pet-clinic project'
- en: '](img/Figure_2.9_B16585_Fixed.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.9_B16585_Fixed.jpg)'
- en: Figure 2.9 – Using Micronaut Launch for generating the pet-clinic project
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 使用Micronaut Launch生成pet-clinic项目
- en: 'In Micronaut Launch, we will choose the following features (by clicking on
    the **FEATURES** button):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Micronaut Launch中，我们将选择以下功能（通过点击**功能**按钮）：
- en: '**jdbc-hikari**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jdbc-hikari**'
- en: '**logback**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logback**'
- en: '**postgres**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**postgres**'
- en: After specifying the aforementioned options, click on the **GENERATE PROJECT**
    button. A ZIP file will be downloaded onto your system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定上述选项后，点击**生成项目**按钮。一个ZIP文件将被下载到您的系统上。
- en: 'Unzip the downloaded source code into your workspace and open the project in
    your preferred IDE. Once the project is open in the IDE, add the following dependency
    in `pom.xml` (or `gradle build`) for MyBatis:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载的源代码解压到您的工作区，并在您首选的IDE中打开项目。一旦项目在IDE中打开，请在`pom.xml`（或`gradle build`）中添加以下依赖项以用于MyBatis：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This dependency is core to our integration with the `pet-clinic` schema in Micronaut.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖对于我们在 Micronaut 中与 `pet-clinic` 模式集成的核心。
- en: Consistent with the service-repository pattern, we will explore MyBatis integration
    in a bottom-up fashion. First, we will define entities, and then repositories,
    and finally, we will work on services.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务-仓库模式一致，我们将从下往上探索 MyBatis 集成。首先，我们将定义实体，然后是仓库，最后我们将处理服务。
- en: Defining a MyBatis factory
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 MyBatis 工厂
- en: 'To execute various SQL statements, MyBatis would need a `SqlSessionFactory`
    object at runtime. We will begin by adding a package – `com.packtpub.micronaut.config`.
    Add the following class to this newly created package:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行各种 SQL 语句，MyBatis 在运行时需要一个 `SqlSessionFactory` 对象。我们将首先添加一个包 - `com.packtpub.micronaut.config`。向这个新创建的包中添加以下类：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using standard properties in `application.yml`, Micronaut will define a Hikari-based
    data source, which will be injected to define `SqlSessionFactory`. While defining
    the environment, you can choose any name (as we have given `pet-clinic`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `application.yml` 中的标准属性，Micronaut 将定义一个基于 Hikari 的数据源，该数据源将被注入以定义 `SqlSessionFactory`。在定义环境时，你可以选择任何名称（正如我们给出的
    `pet-clinic`）。
- en: Creating the entity classes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体类
- en: Similar to Hibernate entities, a MyBatis entity fundamentally defines a Java
    class to integrate upstream Java classes with downstream SQL interactions (defined
    in XML or Java mappers). However, a subtle difference is that any MyBatis entity
    will not contain any mapping logic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Hibernate 实体类似，MyBatis 实体本质上定义了一个 Java 类，以将上游 Java 类与下游 SQL 交互（在 XML 或 Java
    映射器中定义）集成。然而，一个细微的区别是，任何 MyBatis 实体都不会包含任何映射逻辑。
- en: 'We will add a `com.packtpub.micronaut.domain` package to contain the domain
    entities. Add an entity to represent `Specialty`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个 `com.packtpub.micronaut.domain` 包来包含域实体。添加一个表示 `Specialty` 的实体：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similarly, we can define an entity for the vets table:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为兽医表定义一个实体：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can note that both the entities do not have any mapping logic to map to
    the specialties or vets tables. In the next section, we will focus our attention
    on how to create data access repositories in MyBatis.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到这两个实体都没有任何映射逻辑来映射到特殊或兽医表。在下一节中，我们将关注如何在 MyBatis 中创建数据访问仓库。
- en: Defining the mappers (repositories) for the entities
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义实体的映射器（仓库）
- en: For the `Vet` and `Specialty` entities, we will need to define MyBatis mappers.
    MyBatis interacts with the downstream database using these mappers. In comparison
    to a typical Java application, MyBatis mappers are data access repositories. We
    will add a `com.packtpub.micronaut.repository` package to contain all these repositories.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Vet` 和 `Specialty` 实体，我们需要定义 MyBatis 映射器。MyBatis 通过这些映射器与下游数据库交互。与典型的 Java
    应用程序相比，MyBatis 映射器是数据访问仓库。我们将添加一个 `com.packtpub.micronaut.repository` 包来包含所有这些仓库。
- en: 'Under this package, we will add the `SpecialtyRepository` interface:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在此包下，我们将添加 `SpecialtyRepository` 接口：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code snippet, we can see all the actual SQL statements, which
    are then bound to Java methods. Therefore, whenever any upstream caller invokes
    any of the aforementioned methods, MyBatis will execute the corresponding mapped
    SQL. On the same note, we will define `VetRepository` to manage access to the
    vets table.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到所有的实际 SQL 语句，然后绑定到 Java 方法。因此，每当任何上游调用者调用上述任何方法时，MyBatis 将执行相应的映射
    SQL。同样，我们将定义 `VetRepository` 来管理对兽医表的访问。
- en: Unlike Hibernate (which provides concrete implementations for abstract repository
    classes), in MyBatis we will have to provide concrete implementation for the repositories.
    We will add the implementations to `com.packtpub.micronaut.repository.impl`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Hibernate（为抽象仓库类提供具体实现）不同，在 MyBatis 中，我们必须为仓库提供具体实现。我们将将这些实现添加到 `com.packtpub.micronaut.repository.impl`。
- en: 'A concrete implementation for `SpecialtyRepository` can be defined as the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpecialtyRepository` 的具体实现可以定义如下：'
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the concrete method definitions use `SqlSessionFactory` to obtain a `SqlSession`
    instance. The `getSpecialtyRepository()` method will then return the MyBatis mapper
    using this `SqlSession` instance. Similarly, `VetRepositoryImpl` can be defined
    to provide concrete implementations for `VetRepository`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具体方法定义都使用 `SqlSessionFactory` 获取 `SqlSession` 实例。然后 `getSpecialtyRepository()`
    方法将返回使用此 `SqlSession` 实例的 MyBatis 映射器。同样，可以定义 `VetRepositoryImpl` 来为 `VetRepository`
    提供具体实现。
- en: In the next section, we will create upstream service classes for these repositories
    we just defined.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为这些我们刚刚定义的仓库创建上游服务类。
- en: Creating services for entities
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体服务
- en: Services will contain any business logic as well as downstream access to the
    preceding repositories. We can define standard interfaces for each entity service,
    which will outline basic operations supported in a service.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将包含任何业务逻辑以及到先前存储库的下游访问。我们可以为每个实体服务定义标准接口，这将概述服务中支持的基本操作。
- en: 'To contain all services, first, we will create a package called `com.packtpub.micronaut.service`.
    We can declare an interface for `SpecialtyService` to abstract our barebones structure:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包含所有服务，首先，我们将创建一个名为`com.packtpub.micronaut.service`的包。我们可以为`SpecialtyService`声明一个接口以抽象我们的基本结构：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For these barebones methods, we will need to provide concrete implementations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些基本方法，我们需要提供具体实现。
- en: 'We can add a package called `com.packtpub.micronaut.service.impl` under the
    service package. The concrete implementation for `SpecialtyService` will be defined
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在服务包下添加一个名为`com.packtpub.micronaut.service.impl`的包。`SpecialtyService`的具体实现将定义如下：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Concrete service methods are very simple in nature and concierge any calls to
    downstream repository methods. We will add a similar service interface and concrete
    implementation for `Vet` as `VetService` and `VetServiceImpl`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 具体服务方法本质上是简单的，并代理对下游存储库方法的调用。我们将为`Vet`添加一个类似的服务接口和具体实现，如`VetService`和`VetServiceImpl`。
- en: In the next section, we will focus our attention on creating a small command-line
    utility to perform common CRUD operations in the `pet-clinic` database.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将专注于创建一个小型命令行实用程序，以在`pet-clinic`数据库中执行常见的CRUD操作。
- en: Performing basic CRUD operations
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行基本的CRUD操作
- en: 'To use services and repositories defined in previous sections and to perform
    basic CRUD operations on the entities, we can create a simple utility. We can
    create a new package called `com.packtpub.micronaut.utils` to define `PetClinicCliClient`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用上一节中定义的服务和存储库，并执行实体的基本CRUD操作，我们可以创建一个简单的实用程序。我们可以在`com.packtpub.micronaut.utils`包下创建一个新的包来定义`PetClinicCliClient`：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`PetClinicCliClient` injects `VetService` and `SpecialtyService` using the
    constructor method. These services will then be used to perform various database
    operations on the `vets`, `specialties`, and `vet_specialties` tables.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetClinicCliClient`使用构造方法注入`VetService`和`SpecialtyService`。这些服务将用于对`vets`、`specialties`和`vet_specialties`表执行各种数据库操作。'
- en: Performing read/fetch operations
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行读取/检索操作
- en: 'We can define a simple utility method in `PetClinicCliClient` that can call
    `VetService` to fetch all vets. Moreover, since a vet can have multiple specialties,
    fetching a vet will fetch from the specialties table as well:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`PetClinicCliClient`中定义一个简单的实用方法，该方法可以调用`VetService`来检索所有兽医。此外，由于一个兽医可以有多个专业，检索一个兽医将同时从专业表中检索：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `performFindAll()` method fetches all vets along with their specialties
    from the database.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`performFindAll()`方法从数据库中检索所有兽医及其专业。'
- en: Performing a save operation
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行保存操作
- en: 'We will save a vet with a specialty in `PetClinicCliClient`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`PetClinicCliClient`中保存一个具有专业的兽医：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `initVet()` method initializes a new vet with a specialty, which is then
    used by the `performSave()` method to persist this object to database tables.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`initVet()`方法初始化一个新的具有专业的兽医，然后由`performSave()`方法用来将此对象持久化到数据库表中。'
- en: Performing a delete operation
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行删除操作
- en: 'In `PetClinicCliClient`, we will define a delete method to delete a vet (along
    with their specialties):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PetClinicCliClient`中，我们将定义一个删除方法来删除一个兽医（及其专业）：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `performDelete()` method delegates a call to `VetService`, which then calls
    the repository to finally delete the vet from the database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`performDelete()`方法将调用委托给`VetService`，然后`VetService`调用存储库，最终从数据库中删除兽医。'
- en: Wrapping up
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'To perform `PetClinicCliClient` CRUD operations, we will add the following
    code logic to `Application.java`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行`PetClinicCliClient`的CRUD操作，我们将向`Application.java`添加以下代码逻辑：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we run our application, the aforementioned `@EventListener` will invoke
    `PetClinicCliClient` to perform various database operations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的应用程序时，上述的`@EventListener`将调用`PetClinicCliClient`来执行各种数据库操作。
- en: In this section, we integrated with a relational database using MyBatis. We
    covered how to define entities, repositories, and services, and lastly, we exhibited
    basic CRUD operations through a utility. In the next section, we will explore
    integration with a NoSQL database in the Micronaut framework.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用MyBatis与关系型数据库进行了集成。我们介绍了如何定义实体、存储库和服务，最后通过一个实用程序展示了基本的CRUD操作。在下一节中，我们将探索在Micronaut框架中与NoSQL数据库的集成。
- en: Integrating with a NoSQL database (MongoDB)
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 NoSQL 数据库（MongoDB）集成
- en: '**MongoDB** is a document-based database and it stores the data in JSON or
    BSON format. Data is stored in key-value pairs, similar to a JSON object. MongoDB
    is engineered in a scale-out fashion and it is recommended to use it when the
    volume and structure of data are agile and growing very rapidly. There are a few
    key terms in contrast to a relational database:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**MongoDB** 是一个基于文档的数据库，它以 JSON 或 BSON 格式存储数据。数据以键值对的形式存储，类似于 JSON 对象。MongoDB
    采用横向扩展的设计，当数据量和结构敏捷且快速增长时，建议使用它。与关系型数据库相比，有几个关键术语：'
- en: '**Database**: A database in MongoDB is much similar to a database in a relational
    database.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**: MongoDB 中的数据库与关系型数据库中的数据库非常相似。'
- en: '**Table**: A collection (of documents) is much similar to a table in a relational
    database.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表**: 一个（文档的）集合与关系型数据库中的表非常相似。'
- en: '**Row**: A BSON or JSON document will be a close analogy to a row in a relational
    database.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行**: 一个 BSON 或 JSON 文档将类似于关系型数据库中的一行。'
- en: 'In order to do hands-on work, we will continue with the `pet-clinic` application
    and add a new microservice, that is, `pet-clinic-reviews`. This microservice will
    be responsible for managing vet reviews. As reviews could grow rapidly and a schema
    to store a review could change, we will prefer to store this data in MongoDB:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行实际操作，我们将继续使用 `pet-clinic` 应用程序并添加一个新的微服务，即 `pet-clinic-reviews`。这个微服务将负责管理兽医评论。由于评论可能会快速增长，存储评论的模式可能会改变，因此我们更倾向于将此数据存储在
    MongoDB 中：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding JSON document depicts a review stored in MongoDB.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 JSON 文档描述了一个存储在 MongoDB 中的评论。
- en: In the next section, we will get started with setting up the `pet-clinic-reviews`
    schema in MongoDB.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始设置 MongoDB 中的 `pet-clinic-reviews` 模式。
- en: Creating a vet-reviews collection in MongoDB
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 MongoDB 中创建 vet-reviews 集合
- en: 'For the `pet-clinic-reviews` microservice, we will create a database and collection
    in the MongoDB instance:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `pet-clinic-reviews` 微服务，我们将在 MongoDB 实例中创建一个数据库和集合：
- en: Open Studio 3T or any other preferred GUI for MongoDB.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Studio 3T 或任何其他首选的 MongoDB GUI。
- en: Connect to your localhost instance or any other preferred instance (such as
    MongoDB Atlas).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到您的本地实例或任何其他首选实例（例如 MongoDB Atlas）。
- en: Under `pet-clinic-reviews`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pet-clinic-reviews` 下。
- en: 'In the aforementioned database, we will create a new collection: `vet-reviews`.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述数据库中，我们将创建一个新的集合：`vet-reviews`。
- en: To ingest some dummy data into this collection, use the import option to import
    data (CSV or JSON) from [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将一些示例数据导入此集合，请使用导入选项从 [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db)
    导入数据（CSV 或 JSON）。
- en: After finishing setting up the schema, we will turn our attention to working
    on the Micronaut project next.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完模式后，我们将把注意力转向处理 Micronaut 项目。
- en: Generating a Micronaut application for the pet-clinic-reviews microservice
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 pet-clinic-reviews 微服务生成 Micronaut 应用程序
- en: 'In order to generate boilerplate source code for the `pet-clinic-reviews` microservice,
    we will use Micronaut Launch. It is an intuitive interface to generate boilerplate:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 `pet-clinic-reviews` 微服务的样板代码，我们将使用 Micronaut Launch。它是一个直观的界面，用于生成样板代码：
- en: '![Figure 2.10 – Using Micronaut Launch to generate the pet-clinic-reviews project'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.10 – 使用 Micronaut Launch 生成 pet-clinic-reviews 项目'
- en: '](img/Figure_2.10_B16585_Fixed.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B16585_Fixed.jpg)'
- en: Figure 2.10 – Using Micronaut Launch to generate the pet-clinic-reviews project
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 使用 Micronaut Launch 生成 pet-clinic-reviews 项目
- en: 'In Micronaut Launch, we will choose the following features (by clicking on
    the **FEATURES** button):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Micronaut Launch 中，我们将选择以下功能（通过点击 **功能** 按钮）：
- en: '**mongodb-sync** (synchronous access to MongoDB)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mongodb-sync**（对 MongoDB 的同步访问）'
- en: '**logback**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logback**'
- en: After specifying the aforementioned options, click on the **GENERATE PROJECT**
    button. A ZIP file will be downloaded onto your system. Unzip the downloaded source
    code into your workspace and open the project in your preferred IDE.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定上述选项后，点击 **生成项目** 按钮。系统将下载一个 ZIP 文件。将下载的源代码解压到您的工作区，并在您首选的 IDE 中打开项目。
- en: In the following sections, we will dive deeper into how to integrate the `pet-clinic-reviews`
    microservice with MongoDB.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入了解如何将 `pet-clinic-reviews` 微服务与 MongoDB 集成。
- en: Configuring MongoDB in Micronaut
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Micronaut 中配置 MongoDB
- en: 'In the freshly created `pet-clinic-reviews` project, we would need to update
    the URI in `application.yml` to point to the correct instance of MongoDB. Furthermore,
    we will define two new custom properties – `databaseName` and `collectionName`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的 `pet-clinic-reviews` 项目中，我们需要更新 `application.yml` 中的 URI 以指向 MongoDB 的正确实例。此外，我们还将定义两个新的自定义属性
    - `databaseName` 和 `collectionName`：
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use the aforementioned database and collection across the project, we can
    define a configuration class in a new package – `com.packtpub.micronaut.config`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在整个项目中使用上述数据库和集合，我们可以在一个新包中定义一个配置类 - `com.packtpub.micronaut.config`：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will enable easy access to both the `databaseName` and `collectionName`
    properties across the project and we will not need to use `@Value`. Besides, since
    these properties are read-only, we will only define getters for these properties.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得在整个项目中轻松访问 `databaseName` 和 `collectionName` 属性，我们就不需要使用 `@Value`。此外，由于这些属性是只读的，我们只为这些属性定义了获取器。
- en: Next, we will create an entity class to define the vet review object.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个实体类来定义兽医评论对象。
- en: Creating the entity class
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体类
- en: 'At the root level, add a new package called `com.packtpub.micronaut.domain`.
    This package will contain the domain/entity for the vet review. We can define
    the following POJO to represent a vet review:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在根级别，添加一个名为 `com.packtpub.micronaut.domain` 的新包。这个包将包含兽医评论的领域/实体。我们可以定义以下 POJO
    来表示兽医评论：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`@BsonCreator` and `@JsonCreator` piggyback on the class constructor to map
    an object of `VetReview` to the corresponding BSON or JSON document. This will
    come in handy while fetching or storing a document from MongoDB and therefore
    mapping it to a Java object.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`@BsonCreator` 和 `@JsonCreator` 通过类构造函数映射 `VetReview` 对象到相应的 BSON 或 JSON 文档。这在从
    MongoDB 检索或存储文档并将其映射到 Java 对象时非常有用。'
- en: Next, we will focus our attention on how to create the data access repository
    for `VetReview`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注如何为 `VetReview` 创建数据访问仓库。
- en: Creating a data access repository
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据访问仓库
- en: To manage access to the `vet-reviews` collection, we will create a repository.
    We can add `com.packtpub.micronaut.repository` to contain this repository class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理对 `vet-reviews` 集合的访问，我们将创建一个仓库。我们可以在 `com.packtpub.micronaut.repository`
    中添加这个仓库类。
- en: 'To abstract out all the methods that the repository will expose, we can declare
    an interface:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抽象出仓库将公开的所有方法，我们可以声明一个接口：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`VetReviewRepository` outlines essential operations supported in this repository.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`VetReviewRepository` 概述了在此仓库中支持的基本操作。'
- en: 'We will need to provide a concrete implementation for the `VetReviewRepository`
    interface in the `com.packtpub.micronaut.repository.impl` package:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `com.packtpub.micronaut.repository.impl` 包中为 `VetReviewRepository` 接口提供一个具体实现：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `getCollection()` method in this concrete class will get the database and
    collection from MongoDB. Saving to and deleting from this collection is straightforward,
    as shown previously. To find it based on a certain condition, we can use `find()`
    with `eq()`. `eq()` is a BSON filter defined in the MongoDB driver itself.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个具体类中的 `getCollection()` 方法将从 MongoDB 获取数据库和集合。将数据保存到这个集合或从其中删除是直接了当的，如前所述。要基于某个条件查找，我们可以使用
    `find()` 方法配合 `eq()`。`eq()` 是在 MongoDB 驱动程序中定义的一个 BSON 过滤器。
- en: Creating a service for the entity
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体服务
- en: A service will encapsulate any business logic as well as downstream access to
    the `vet-reviews` collection (in MongoDB). We can declare an interface to abstract
    out core methods in a service. To contain a service, we should first create a
    package called `com.packtpub.micronaut.service` under the root package.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务将封装任何业务逻辑以及到 MongoDB 中 `vet-reviews` 集合（在 MongoDB 中）的下游访问。我们可以在服务中声明一个接口来抽象核心方法。为了包含一个服务，我们首先应该在根包下创建一个名为
    `com.packtpub.micronaut.service` 的包。
- en: 'The `VetReviewService` interface can then be declared as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以声明 `VetReviewService` 接口如下：
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `VetReviewService` interface will declare barebones methods supported by
    this service. To provide concrete implementation for these methods, we will create
    a `VetServiceImpl` class under the `com.packtpub.micronaut.service.impl` package:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`VetReviewService` 接口将声明由该服务支持的基本方法。为了为这些方法提供具体实现，我们将在 `com.packtpub.micronaut.service.impl`
    包下创建一个 `VetServiceImpl` 类：'
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Concrete implementations for these methods are essentially delegating the call
    to `VetReviewRepository`. However, for any future needs, these methods can be
    extended to contain any business logic, such as data validations or data transformation.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus our attention on creating a small command-line
    utility to perform common CRUD operations on the `pet-clinic-reviews` collection.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic CRUD operations
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to perform basic CRUD operations on the `VetReview` entity, we can
    create a simple utility. We can create a new package called `com.packtpub.micronaut.utils`
    to define `PetClinicReviewCliClient`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This utility will inject `VetReviewService` using the constructor. We will delegate
    the CRUD calls via this service.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Performing read/fetch operations
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define a simple utility method in `PetClinicReviewCliClient` that can
    call `VetReviewService` to fetch all vet reviews or a specific vet review:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`performFindAll()` will fetch all vet reviews in the collection, whereas `performFindByReviewId()`
    will fetch a specific review by `reviewId`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Performing a save operation
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will save a vet review through a method in `PetClinicReviewCliClient`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Though we are defining a vet review object in Java, the constructor in the `VetReview`
    entity will take care of mapping this object to `BsonDocument` and downstream
    code in `VetReviewRepository` will save this document to the `vet-reviews` collection.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Performing a delete operation
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `PetClinicReviewCliClient`, we will define a delete method to `delete` a
    vet review:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is a small method and it delegates the call to `VetReviewService` for deletion.
    `VetReviewService` further invokes the repository to delete the given vet review
    from the collection.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `Application.java`, we can call `PetClinicReviewCliClient` as a startup
    event, which can then exhibit basic CRUD operations on the `vet-reviews` collection:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When we kickstart our application, the aforementioned `@EventListener` will
    invoke `PetClinicReviewCliClient` to perform database operations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered how to integrate a Micronaut application with MongoDB.
    We defined the entity, repository, and service to access the MongoDB database.
    Lastly, we exhibited CRUD operations through a light utility.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various aspects of integrating a Micronaut application
    with relational as well as NoSQL databases. We explored different ways of persistence
    integration, that is, using ORM (Hibernate), a persistence framework (MyBatis),
    or a driver-based framework (MongoDB Sync). In each technique, we covered, in
    depth, how to define entities, relationships, repositories, and services. Each
    microservice defined a simple command-line utility to exhibit common CRUD operations.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has given us the skills to cover almost all the data access aspects
    in Micronaut. In the rest of the book, we will further explore and use these skills
    and learnings by doing more hands-on exercises and covering other aspects of the
    Micronaut framework.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了覆盖Micronaut中几乎所有数据访问方面的技能。在本书的其余部分，我们将通过进行更多动手练习和涵盖Micronaut框架的其他方面来进一步探索和使用这些技能和知识。
- en: In the next chapter, we will work on the web layer of the `pet-clinic` application,
    defining various REST endpoints in all the microservices.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理`pet-clinic`应用程序的Web层，在所有微服务中定义各种REST端点。
- en: Questions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an **object-relational mapping** (**ORM**) framework?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是**对象关系映射**（**ORM**）框架？
- en: What is Hibernate?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Hibernate？
- en: How can you define an entity using Hibernate in Micronaut?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中使用Hibernate定义一个实体？
- en: How can you map a one-to-one relationship using Hibernate in Micronaut?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中使用Hibernate映射一对一关系？
- en: How can you map a one-to-many or many-to-one relationship using Hibernate in
    Micronaut?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中使用Hibernate映射一对一或一对多关系？
- en: How can you map many-to-many relationships using Hibernate in Micronaut?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中使用Hibernate映射多对多关系？
- en: How can you perform CRUD operations using Hibernate in Micronaut?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中使用Hibernate执行CRUD操作？
- en: How can you integrate with a relational database using MyBatis in Micronaut?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中使用MyBatis与关系型数据库集成？
- en: How can you define MyBatis mappers in Micronaut?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中定义MyBatis映射器？
- en: How can you perform CRUD operations using MyBatis in Micronaut?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中使用MyBatis执行CRUD操作？
- en: How can you integrate with a NoSQL (MongoDB) database in Micronaut?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中与NoSQL（MongoDB）数据库集成？
- en: How can you perform CRUD operations in MongoDB in Micronaut?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Micronaut中在MongoDB中执行CRUD操作？
