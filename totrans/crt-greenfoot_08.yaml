- en: Chapter 8. User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。用户界面
- en: '|   | *"If you can dream it, you can do it."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"如果你能梦想它，你就能做到。" |   |'
- en: '|   | --*Walt Disney* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*沃尔特·迪士尼* |'
- en: 'Aside from user controls for games and simulations, you will, at times, want
    your user to click buttons, view text, and select items from menus. Imagine that
    you are creating a physics simulation and want to have your user set certain simulation
    parameters or that you have a store in your game where players can purchase upgrades.
    Or perhaps you want to create a dialogue between two actors in your scenario.
    In this chapter, we are going to explore techniques to provide various types of
    **user interfaces** (**UIs**). Specifically, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了游戏和模拟的用户控制之外，有时你可能希望用户点击按钮、查看文本和从菜单中选择项目。想象一下，你正在创建一个物理模拟，并希望用户设置某些模拟参数，或者你在游戏中有一个商店，玩家可以在那里购买升级。或者，也许你想要在你的场景中创建两个演员之间的对话。在本章中，我们将探讨提供各种类型
    **用户界面**（**UIs**）的技术。具体来说，我们将探讨以下主题：
- en: Buttons and labels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮和标签
- en: Menus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单
- en: Heads-up display (HUD)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头戴式显示器 (HUD)
- en: Greenfoot provides little direct support to create user interfaces. There are
    only a few classes, such as `Label` and `Counter`, packaged with Greenfoot to
    help in this regard. So, we will have to build our own support. We will use Greenfoot
    `Actors` and the `GreenfootImage` class to create user interfaces and classes
    that will support the creation of user interfaces. Luckily, Greenfoot allows us
    to build just about anything we can dream up, including user interfaces.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot 在创建用户界面方面提供的直接支持很少。只有几个类，如 `Label` 和 `Counter`，被打包在 Greenfoot 中以帮助这方面。因此，我们将不得不自己构建支持。我们将使用
    Greenfoot 的 `Actors` 和 `GreenfootImage` 类来创建用户界面和将支持创建用户界面的类。幸运的是，Greenfoot 允许我们构建我们所能梦想的几乎所有东西，包括用户界面。
- en: UIWorld
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UIWorld
- en: 'In this section, we will explain how to write the following user interface
    elements: buttons, textboxes, menus, and **heads-up displays** (**HUDs**). We
    are going to work through a Greenfoot scenario (shown in *Figure 1*) that only
    contains user interface elements, so we can discuss each element independently.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释如何编写以下用户界面元素：按钮、文本框、菜单和 **头戴式显示器**（**HUDs**）。我们将通过一个 Greenfoot 场景（如图
    1 所示）来操作，该场景只包含用户界面元素，这样我们就可以独立讨论每个元素。
- en: Some of the code we write will be general and able to be applied to many different
    scenarios. In other cases, we will write user interface code that will only need
    minor modification to be used across scenarios. In the next section, we will add
    these elements to the `MazeWorld` scenario that we wrote in the previous chapter,
    to make it a more polished and playable game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的某些代码将是通用的，可以应用于许多不同的场景。在其他情况下，我们将编写需要稍作修改才能跨场景使用的用户界面代码。在下一节中，我们将把这些元素添加到我们在上一章中编写的
    `MazeWorld` 场景中，使其成为一个更加精致和可玩的游戏。
- en: '![UIWorld](img/image00318.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![UIWorld](img/image00318.jpeg)'
- en: 'Figure 1: This shows UI MainWorld'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：这显示了 UI MainWorld
- en: 'To work through this scenario, start with a new Greenfoot scenario named `UIMainWorld`,
    create a subclass of `World` named `UIMainWorld`, and then associate a plain background
    to it. The background I chose was `bluerock.jpg`. Here is the code for `UIMainWorld`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这个场景，从一个名为 `UIMainWorld` 的新 Greenfoot 场景开始，创建一个名为 `UIMainWorld` 的 `World`
    子类，并将其与一个纯背景关联。我选择的背景是 `bluerock.jpg`。以下是 `UIMainWorld` 的代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For now, the lines of code in the `testActors()` method are commented out. Uncomment
    them as we implement the associated actor, so that you can test and play with
    each one in turn. If you prefer, you can download the complete UI scenario from
    [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`testActors()` 方法中的代码已被注释。在我们实现相关演员时取消注释它们，这样你就可以逐一测试和玩每个演员。如果你愿意，你可以从 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    下载完整的 UI 场景。
- en: The Button class
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮类
- en: 'Is there a more prolific UI element than the humble button? It is hard to imagine
    any interface that does not contain several of these buttons. Luckily for us,
    they are very easy to implement in Greenfoot. In your UI scenario, subclass the
    `Actor` class and call this new subclass `Button`. Choose **No Image** for the
    image of `Button`. We will dynamically add the images necessary for this actor.
    Here is the code for the `Actor` class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有比谦逊的按钮更丰富的 UI 元素？很难想象任何界面不包含几个这样的按钮。幸运的是，在 Greenfoot 中实现它们非常简单。在你的 UI 场景中，从
    `Actor` 类派生出一个新子类，并将其命名为 `Button`。为 `Button` 的图像选择 **无图像**。我们将动态添加此演员所需的图像。以下是
    `Actor` 类的代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a button, you need to have one image for the normal state and one image
    for the pressed state. The `first` and `second` instance variables store the names
    of these images. Their values are provided to the class's constructor as input
    parameters. The constructor sets the initial image to the `first` image.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按钮，您需要一个用于正常状态的图像和一个用于按下状态的图像。`first`和`second`实例变量存储这些图像的名称。它们的值作为输入参数提供给类的构造函数。构造函数将初始图像设置为`first`图像。
- en: The `act()` method only contains one method call to handle mouse events for
    this actor—`handleMouseClicks()`. This method displays the `second` image when
    the mouse is pressed and then goes back to displaying the `first` image when the
    click completes. In Greenfoot, the `Greenfoot.mousePressed()` method returns `true`
    when the left mouse button is held down on the given object. The `Greenfoot.mouseClicked()`
    method returns `true` when the left mouse button is pressed down and released
    on the given object. *Figure 2* demonstrates these two mouse events. When we detect
    that the mouse is pressed, we simply change the image to the `second` image. When
    the mouse is released, a full click has occurred, and we do two things. First,
    we set the image back to normal, and then we perform an action by calling the
    `clickedAction()` method. This method is currently empty and serves as a placeholder
    where you could put the code for your own custom action. Another option, would
    be to subclass this class and override the `clickedAction()` method in your new
    subclass.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`act()`方法只包含一个方法调用，用于处理此演员的鼠标事件——`handleMouseClicks()`。当鼠标按下时，此方法显示`second`图像，然后在点击完成后返回显示`first`图像。在Greenfoot中，`Greenfoot.mousePressed()`方法在给定对象上按下左鼠标按钮时返回`true`。`Greenfoot.mouseClicked()`方法在给定对象上按下并释放左鼠标按钮时返回`true`。*图2*演示了这两个鼠标事件。当我们检测到鼠标按下时，我们只需将图像更改为`second`图像。当鼠标释放时，发生了一次完整的点击，我们做两件事。首先，我们将图像恢复到正常状态，然后通过调用`clickedAction()`方法执行一个动作。此方法目前为空，用作可以放置您自己的自定义动作代码的占位符。另一种选择是创建此类的子类，并在您的新子类中重写`clickedAction()`方法。'
- en: '![The Button class](img/image00319.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![按钮类](img/image00319.jpeg)'
- en: 'Figure 2: In Greenfoot, a mouse is considered clicked when the left mouse button
    is both pressed and released'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：在Greenfoot中，当左鼠标按钮同时按下和释放时，认为鼠标被点击
- en: 'The button was added to the screen in the `UIMainWorld` subclass of `World`
    with the following two lines of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是通过在`World`子类`UIMainWorld`中以下两行代码添加到屏幕上的：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `button-blue.png` and `button-green.png` images are the images that come
    with the default installation of Greenfoot (not available in version 2.2). You
    can quickly get these images into your project by creating temporary actors that
    have them as their default image or by copying them from the installation of Greenfoot.
    Uncomment the two lines shown in the `testActors()` method in `UIMainWorld`, compile
    your scenario, and test out your new button.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`button-blue.png`和`button-green.png`图像是Greenfoot默认安装提供的图像（在版本2.2中不可用）。您可以通过创建具有这些图像作为默认图像的临时演员或将它们从Greenfoot的安装中复制来快速将这些图像添加到您的项目中。取消注释`UIMainWorld`中的`testActors()`方法中显示的两行代码，编译您的场景，并测试您的新按钮。'
- en: The TextBox class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextBox类
- en: The functionality of `TextBox` is very similar in functionality to the `Label`
    class that is supplied with Greenfoot. Note that in `UIMainWorld`, we added one
    instance of the `Label` class to our scenario for demonstration and comparison
    purposes. To add the `Label` class to your UI scenario, click on **Edit** in Greenfoot's
    main menu and then click on **Import Class…**. Click on **Label** on the left-hand
    side of the pop-up window that appears, read the documentation on the `Label`
    class (if you are interested), and then click on the **Import** button. We will
    implement our own version of `Label` and call it `TextBox`. The `Textbox` class
    we will write is a bit more concise and provides us with a reason to discuss how
    to work with text in Greenfoot.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`的功能在功能上与Greenfoot提供的`Label`类非常相似。请注意，在`UIMainWorld`中，我们添加了一个`Label`类的实例到我们的场景中，用于演示和比较目的。要将`Label`类添加到您的UI场景中，请点击Greenfoot主菜单中的**编辑**，然后点击**导入类…**。在出现的弹出窗口的左侧点击**Label**，阅读关于`Label`类的文档（如果您感兴趣），然后点击**导入**按钮。我们将实现我们自己的`Label`版本，并将其称为`TextBox`。我们将编写的`Textbox`类更加简洁，这为我们提供了一个讨论如何在Greenfoot中处理文本的理由。'
- en: 'In *Figure 1*, we can see two examples of the `TextBox` class. This class allows
    us to display text on the screen with a custom font, color, background color,
    and optional border. Here is the code for `TextBox`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 1* 中，我们可以看到 `TextBox` 类的两个示例。此类允许我们在屏幕上使用自定义字体、颜色、背景颜色和可选边框显示文本。以下是 `TextBox`
    的代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In `TextBox`, we can configure the foreground color, background color, font
    size, and whether or not to draw a border around the textbox. In addition to the
    actual text to display, the constructor accepts and stores these values. The `display()`
    method is responsible for actually creating our new textbox. First, it creates
    a new image based on the earlier configuration information using Greenfoot's `GreenfootImage()`
    method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TextBox` 中，我们可以配置前景色、背景色、字体大小以及是否在文本框周围绘制边框。除了要显示的实际文本外，构造函数还接受并存储这些值。`display()`
    方法负责实际创建我们的新文本框。首先，它使用 Greenfoot 的 `GreenfootImage()` 方法根据之前的配置信息创建一个新的图像。
- en: When you supply text as the first parameter to `GreenfootImage()`, it will create
    an image of that text. Then, we can just use `setImage()` to display that text.
    The `display()` method checks the `border` instance variable and draws a border
    in the new image we created, if needed. We also supplied a `setText()` method,
    in case we need to dynamically change the text. This method creates a new `GreenfootImage`
    based on the new text and then uses the `display()` method to properly set the
    image of the textbox to the new image created.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将文本作为第一个参数传递给 `GreenfootImage()` 时，它将创建一个该文本的图像。然后，我们只需使用 `setImage()` 来显示该文本。`display()`
    方法检查 `border` 实例变量，并在需要时在新创建的图像上绘制一个边框。我们还提供了一个 `setText()` 方法，以防我们需要动态更改文本。此方法基于新文本创建一个新的
    `GreenfootImage`，然后使用 `display()` 方法正确设置文本框的图像为新创建的图像。
- en: To test our new `TextBox` class, uncomment all the lines in `testActors()` in
    `UIMainWorld` that deal with adding instances of `TextBox`, compile the scenario,
    and run it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的新 `TextBox` 类，请取消注释 `UIMainWorld` 中 `testActors()` 的所有行，这些行涉及添加 `TextBox`
    实例，编译场景，并运行它。
- en: The Menu class
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Menu` 类'
- en: Menus are amazing at accepting user commands. I am sure you have had plenty
    of experience using them and understand their utility. Our implementation of a
    menu involves using the `TextBox` class we just created and a new Java interface
    named `MenuCommands` that we will implement soon. The `TextBox` instances display
    the text, and the actions of the menu choice are performed by classes that implement
    the `MenuCommands` interface. We will explain that more thoroughly soon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单在接收用户命令方面非常出色。我相信你有很多使用它们的经验，并理解它们的实用性。我们实现的菜单涉及使用我们刚刚创建的 `TextBox` 类和一个名为
    `MenuCommands` 的新 Java 接口，我们很快将实现它。`TextBox` 实例显示文本，而菜单选择的动作由实现 `MenuCommands`
    接口的类执行。我们很快会详细解释这一点。
- en: '*Figure 3* provides an overview of the functionality of our `Menu` class. Our
    menu initially looks like `TextBox`, as shown in *Figure 3(a)*. When the user
    clicks on the menu, a pop-up menu appears with a set of actions the user can choose
    from. The pop-up menu is shown in *Figure 3(b)*. Both the menu title and set of
    commands are configurable.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3* 提供了我们的 `Menu` 类的功能概述。我们的菜单最初看起来像 `TextBox`，如图 3(a) 所示。当用户点击菜单时，会出现一个弹出菜单，用户可以选择一系列操作。弹出菜单如图
    3(b) 所示。菜单标题和命令集都是可配置的。'
- en: '![The Menu class](img/image00320.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![菜单类](img/image00320.jpeg)'
- en: 'Figure 3: Initially, menu objects look like TextBox (see (a)). When the user
    clicks on the text, a drop-down menu appears, giving the user multiple items to
    choose from (see (b))'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：最初，菜单对象看起来像 TextBox（见图 (a)）。当用户点击文本时，会出现一个下拉菜单，用户可以选择多个项目（见图 (b)）
- en: 'Here is the code for `Menu`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Menu` 的代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An instance of `Menu` is composed of two `TextBox` instances and one implementation
    of the `MenuCommands` interface. The first `TextBox` instance represents the menu
    title (shown in *Figure 3(a)*), and the second `TextBox` instance represents the
    collection of commands (shown in *Figure3(b)*). The Menu constructor creates both
    `TextBox` instances and stores the supplied `MenuCommands` object for later use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menu` 实例由两个 `TextBox` 实例和一个 `MenuCommands` 接口的实现组成。第一个 `TextBox` 实例表示菜单标题（如图
    3(a) 所示），第二个 `TextBox` 实例表示命令集合（如图 3(b) 所示）。`Menu` 构造函数创建了这两个 `TextBox` 实例，并存储提供的
    `MenuCommands` 对象以供以后使用。'
- en: When `Menu` is added to `World`, we use the `addedToWorld()`method to place
    the menu title bar in the scenario and collect height information needed to properly
    place the pop-up window later.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Menu`被添加到`World`中时，我们使用`addedToWorld()`方法将菜单标题栏放置在场景中，并收集稍后正确放置弹出窗口所需的高度信息。
- en: 'The `act()` method calls one method, `handleMouse()`, that places the menu
    item popup when the title text is clicked on. For the menu item popup, the method
    `handleMouse()` determines whether it was clicked on and where it was clicked
    and then calls the appropriate command. The following code determines the click
    location:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`act()`方法调用一个方法`handleMouse()`，当点击标题文本时放置菜单项弹出。对于菜单项弹出，`handleMouse()`方法确定是否被点击以及点击的位置，然后调用适当的命令。以下代码确定了点击位置：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is based on the current font size and the height of the `TextBox` menu
    item. *Figure 4* shows the calculation pictorially.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这基于当前的字体大小和`TextBox`菜单项的高度。*图4*以图解的形式展示了计算过程。
- en: '![The Menu class](img/image00321.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![菜单类](img/image00321.jpeg)'
- en: 'Figure 4: To determine which menu item was clicked on, use this formula: ((a)-(b)+(c))/(d).
    This formula determines the distance between the center of the image (b) and the
    click location (a), adjusts the value so that it is relative to the top of the
    figure by adding half the height (c) and then dividing by the font size (d) to
    get the actual index of the item'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：为了确定哪个菜单项被点击，使用以下公式：((a)-(b)+(c))/(d)。这个公式确定了图像中心（b）和点击位置（a）之间的距离，通过添加一半的高度（c）来调整值，使其相对于图顶部的位置，然后除以字体大小（d）以获得实际的项目索引
- en: Now that we know the index of the menu item clicked on by the user, we need
    to run the command associated with it. To do this, we simply call the `execute()`
    method on the `MenuCommands` object that was passed to us via the constructor.
    `MenuCommands` is a Java interface that guarantees that any Java class that implements
    this interface will have the `execute()` method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了用户点击的菜单项的索引，我们需要运行与其关联的命令。为此，我们只需在通过构造函数传递给我们的`MenuCommands`对象上调用`execute()`方法。`MenuCommands`是一个Java接口，它保证任何实现此接口的Java类都将具有`execute()`方法。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We first encountered Java interfaces in [Chapter 3](part0024.xhtml "Chapter 3. Collision
    Detection"), *Collision Detection*. Remember that a class that implements a Java
    interface is promising to provide an implementation of every method defined in
    that interface. For more information, review [Chapter 3](part0024.xhtml "Chapter 3. Collision
    Detection"), *Collision Detection*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](part0024.xhtml "第3章。碰撞检测")中首次遇到了Java接口，*碰撞检测*。请记住，实现Java接口的类承诺提供该接口中定义的每个方法的实现。有关更多信息，请参阅[第3章](part0024.xhtml
    "第3章。碰撞检测")，*碰撞检测*。
- en: 'Here is the code for `MenuCommands`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`MenuCommands`类的代码：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, this interface only defines one method, `execute()`, that must
    accept an integer parameter (representing the index of the menu item) and a reference
    to the current `World` instance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，此接口只定义了一个方法，`execute()`，它必须接受一个整数参数（表示菜单项的索引）和当前`World`实例的引用。
- en: 'In our UI scenario, we provide two examples of using the `Menu` class. The
    first is the one that has the menu title bar text, **Destroy Everything?**. The
    menu that pops up only has one option, **Are you sure?**. Here is the code for
    the `DestroyCommands` class, which implements the `MenuCommands` interface:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的UI场景中，我们提供了两个使用`Menu`类的示例。第一个是带有菜单标题栏文本的示例，**销毁一切？**。弹出的菜单只有一个选项，**你确定吗？**。以下是`DestroyCommands`类的代码，它实现了`MenuCommands`接口：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because the pop-up menu only has one choice, we do not need to use the supplied
    `idx` value. We implement the `execute()` method by simply printing **Boooom!!!!**
    to the console window.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为弹出菜单只有一个选项，所以我们不需要使用提供的`idx`值。我们通过简单地向控制台窗口打印**Boooom!!!!**来实现`execute()`方法。
- en: 'The second `Menu` class example mimics the types of commands you would see
    in an application that works with files. This example is shown in *Figure 3*.
    Here is the code for `FileCommands`, which implements the `MenuCommands` interface:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Menu`类示例模仿了在处理文件的应用程序中会看到的命令类型。此示例在*图3*中展示。以下是实现`MenuCommands`接口的`FileCommands`类的代码：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code uses the `idx` value to run one of several available options. For
    simplicity, we simply print messages to the console window to demonstrate that
    the code is working properly. In your own applications, you would substitute the
    print messages with actual relevant code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用`idx`值运行几个可用选项之一。为了简单起见，我们只是向控制台窗口打印消息来演示代码正在正常工作。在你的应用程序中，你会用实际的有关代码替换打印消息。
- en: In [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision
    Detection*, we used interfaces because we needed to conform to the Greenfoot API.
    In this case, we choose to use interfaces because they provided a clean and simple
    way to provide many different types of menu actions without having to change the
    `Menu` class. We have effectively abstracted the need to know about the contents
    of the custom menus and made our `Menu` class applicable to a wide variety of
    uses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0024.xhtml "第3章。碰撞检测")中，我们使用接口，因为我们需要遵守Greenfoot API。在这种情况下，我们选择使用接口，因为它们提供了一种干净简单的方式，可以提供许多不同类型的菜单操作，而无需更改`Menu`类。我们有效地抽象了了解自定义菜单内容的需求，并使我们的`Menu`类适用于广泛的用途。
- en: Now, uncomment the `Menu` actors in the `testActors()` method in `UIMainWorld`
    and test out the menus we created previously.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`UIMainWorld`中的`testActors()`方法中取消注释`Menu`演员，并测试我们之前创建的菜单。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `Menu` class is fairly complicated as it involves managing two `TextBox`
    classes and implementing a `MenuCommands` interface. To improve your understanding
    of it, try creating your own menu and adding it to the UI scenario now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menu`类相当复杂，因为它涉及管理两个`TextBox`类并实现`MenuCommands`接口。为了更好地理解它，现在尝试创建自己的菜单并将其添加到UI场景中。'
- en: Heads-up display
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抬头显示
- en: Often, you want to create a completely custom UI that involves various shapes
    and graphics. In this section, we will learn how to do exactly that. The title
    of this section is heads-up display (HUD) because games often have custom interfaces
    (called HUDs) that provide critical information and controls to their players.
    However, the methodology discussed here applies to any custom UI. For our example,
    we will create the custom user interface element shown in *Figure 5*. In our HUD,
    the user will be able to click the home, favorite, print, and cart icons to perform
    actions of our choosing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你想要创建一个完全自定义的UI，它涉及各种形状和图形。在本节中，我们将学习如何做到这一点。本节的标题是抬头显示（HUD），因为游戏通常有自定义界面（称为HUD），为玩家提供关键信息和控制。然而，这里讨论的方法适用于任何自定义UI。在我们的例子中，我们将创建图5中显示的自定义用户界面元素。在我们的HUD中，用户将能够点击主页、收藏、打印和购物车图标来执行我们选择的操作。
- en: '![Heads-up display](img/image00322.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![抬头显示](img/image00322.jpeg)'
- en: 'Figure 5: This shows a custom user interface element'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：这显示了自定义用户界面元素
- en: The graphic shown in *Figure 5* was created in Adobe Illustrator. Use any graphic
    editor to create something that looks similar. In the UI scenario, create a new
    `HUD` actor and associate the image you created with it. In general, you can create
    any graphic you want in any editor you want. Our method of creating a custom interface
    involves us overlaying invisible Greenfoot actors over the custom graphic, and
    the graphic is not required to be any certain shape or size.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图5中显示的图形是在Adobe Illustrator中创建的。使用任何图形编辑器创建类似的东西。在UI场景中，创建一个新的`HUD`演员，并将你创建的图像与之关联。一般来说，你可以在任何编辑器中创建任何你想要的图形。我们创建自定义界面的方法涉及我们在自定义图形上叠加不可见的Greenfoot演员，并且图形不需要是任何特定的形状或大小。
- en: 'Here is the code for the `HUD` class in our UI scenario:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们UI场景中`HUD`类的代码：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As illustrated in the preceding snippet, there is not a lot of code associated
    with this class. The code creates four new invisible actors and places them over
    objects we want the user to be able to click on in our custom UI. In the `addedToWorld()`
    method, we create home, favorite, print, and cart actors to cover the home, favorite,
    print, and cart icons shown in *Figure 5*. The part of this method that is specific
    to the graphic shown in *Figure 5* is the placement of the invisible actors. If
    you created a different graphic than the one I have shown, then you will need
    to determine the correct locations to place the new actors yourself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文片段所示，与这个类相关的代码并不多。代码创建了四个新的无形演员，并将它们放置在我们希望用户能够点击的我们的自定义UI中的对象上。在 `addedToWorld()`
    方法中，我们创建了家、收藏、打印和购物车演员来覆盖 *图5* 中显示的家、收藏、打印和购物车图标。这个方法中特定于 *图5* 中图形的部分是放置无形演员的位置。如果你创建了一个与我展示不同的图形，那么你需要自己确定放置新演员的正确位置。
- en: You have probably noticed that the invisible actors we created were instances
    of an inner class named `TransparentRectangle`. This is the first time we have
    used an inner class in this book, and they warrant some discussion. At the simplest
    level, an inner class is just a class that was defined inside another class and,
    thus, not generally accessible to other classes in the project. The following
    information box contains additional information about inner classes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们创建的无形演员是名为 `TransparentRectangle` 的内部类的实例。这是我们在这本书中第一次使用内部类，它们值得一些讨论。在最简单的层面上，内部类只是定义在另一个类内部的类，因此通常无法被项目中其他类访问。以下信息框包含有关内部类的更多信息。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More about inner classes**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于内部类的更多内容**'
- en: In object-oriented design, you solve a problem by breaking it up into smaller
    objects and then carefully constructing how those objects communicate or cooperate.
    This is an example of top-down design (discussed in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*) where we break a problem
    up into smaller and smaller subproblems. Sometimes, a class's internal state may
    be quite complex and using inner classes may help manage that internal complexity.
    In essence, this is a form of hierarchical object-oriented design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的设计中，你通过将问题分解成更小的对象，然后仔细构建这些对象如何通信或协作来解决一个问题。这是一个自上而下的设计示例（在第1章中讨论，*Let's
    Dive Right in…*），我们将问题分解成越来越小的子问题。有时，一个类的内部状态可能非常复杂，使用内部类可能有助于管理这种内部复杂性。本质上，这是一种层次化的面向对象设计。
- en: Another use of inner classes is encapsulating classes that only have a very
    specific use for only one class in the project. For example, our `HUD` class is
    the only class in our scenario that uses the `TransparentRectangle` class. By
    hiding `TransparentRectangle` within `HUD`, no other class is exposed to `TransparentRectangle`.
    You will notice that in Greenfoot, `TransparentRectangle` does not appear in the
    **Actor classes…** section of the main scenario window.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类的另一个用途是封装只对项目中一个类有非常特定用途的类。例如，我们的 `HUD` 类是我们场景中唯一使用 `TransparentRectangle`
    类的类。通过在 `HUD` 中隐藏 `TransparentRectangle`，没有其他类会暴露给 `TransparentRectangle`。你将注意到在
    Greenfoot 中，`TransparentRectangle` 并未出现在主场景窗口的 **Actor 类…** 部分中。
- en: 'For more information on inner classes (and nested classes), refer to the article
    at: [http://www.javaworld.com/article/2077411/core-java/inner-classes.html](http://www.javaworld.com/article/2077411/core-java/inner-classes.html)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内部类（以及嵌套类）的更多信息，请参阅以下文章：[http://www.javaworld.com/article/2077411/core-java/inner-classes.html](http://www.javaworld.com/article/2077411/core-java/inner-classes.html)
- en: The last two methods, `act()` and `handleMouseClicks()`, follow a common pattern
    to handle mouse clicks on actors, which we have seen several times in this book
    and discuss again here. As with the `Menu` actors we created in this scenario,
    we print a message to the console when the user clicks on one of the icons.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法，`act()` 和 `handleMouseClicks()`，遵循处理演员上鼠标点击的常见模式，我们在本书中已经多次看到，并在此再次讨论。与我们在本场景中创建的
    `Menu` 演员一样，当用户点击其中一个图标时，我们会向控制台打印一条消息。
- en: Let us test the whole scenario now. Remember to uncomment the `HUD` actor created
    and added to the scenario in the `testActors()` method in `UIMainWorld`. Compile
    and ensure that messages are being sent to the console when you click on the various
    icons.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在测试整个场景。记住在 `UIMainWorld` 中的 `testActors()` 方法中取消注释创建并添加到场景中的 `HUD` 演员记得编译并确保当你点击各种图标时，控制台会收到消息。
- en: Adding a UI to MazeWorld
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 MazeWorld 添加 UI
- en: Now that we have some experience in creating various UI elements, we are going
    to enhance the MazeWorld scenario from the previous chapter. This will give us
    the opportunity to practice what we have learned in a more realistic context.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一些创建各种UI元素的经验，我们将增强上一章的MazeWorld场景。这将给我们一个机会在一个更真实的环境中练习我们所学到的知识。
- en: 'Specifically, we will add:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将添加：
- en: A start screen with a button to start the game and a menu the player can use
    to indicate the difficulty mode of the game
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有开始游戏按钮和玩家可以使用以指示游戏难度模式的菜单的起始界面
- en: A game over screen with a button the player can use to restart the game
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个游戏结束界面，玩家可以使用按钮重新开始游戏
- en: A HUD the player can use to temporarily stun the enemies, slow them, or make
    the snake enemies say, "sssssssss"
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个玩家可以使用它来暂时击昏敌人、减慢他们的速度或让蛇形敌人说，“sssssssss”
- en: Start with the code for MazeWorld you ended with in the previous chapter, or
    download it from [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章结束的MazeWorld代码开始，或者从[http://www.packtpub.com/support](http://www.packtpub.com/support)下载。
- en: Adding menus and buttons
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加菜单和按钮
- en: In this section, we will add an introduction screen and game over screen to
    `MazeWorld`. We will add a button, textbox, and menu to the introduction screen
    (shown in *Figure 6*) and just a button to the game over screen (shown in *Figure
    7*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向`MazeWorld`添加一个介绍界面和游戏结束界面。我们将向介绍界面（如图*图6*所示）添加一个按钮、文本框和菜单，而游戏结束界面（如图*图7*所示）只添加一个按钮。
- en: '![Adding menus and buttons](img/image00323.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![添加菜单和按钮](img/image00323.jpeg)'
- en: 'Figure 6: This is the new introduction screen we are adding to MazeWorld'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：这是我们添加到MazeWorld的新介绍界面
- en: This is how the game over screen will look.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏结束界面的样子。
- en: '![Adding menus and buttons](img/image00324.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![添加菜单和按钮](img/image00324.jpeg)'
- en: 'Figure 7: This is the new game over screen we are adding to MazeWorld'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：这是我们添加到MazeWorld的新游戏结束界面
- en: We created an introduction screen and game over screen in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…* and augmented the game
    over screen in [Chapter 5](part0034.xhtml "Chapter 5. Interactive Application
    Design and Theory"), *Interactive Application Design and Theory* for Avoider Game,
    so the addition of these screens to MazeWorld will only be quickly covered here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](part0014.xhtml "第1章。让我们直接深入…")中创建了一个介绍界面和游戏结束界面，*让我们直接深入…*，并在[第5章](part0034.xhtml
    "第5章。交互式应用程序设计和理论")中增强了游戏结束界面，*交互式应用程序设计和理论*，以避免游戏，所以这些屏幕添加到MazeWorld中只会简要介绍。
- en: 'To start with, we are going to create a new class that both screens will inherit
    from. Create a new subclass of the `World` class and name it, `MazeWorldScreens`;
    don''t associate an image with this class, and add the following code to it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的类，这两个屏幕都将继承它。创建一个新的`World`类的子类，命名为`MazeWorldScreens`；不要将图像与此类关联，并添加以下代码到它中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both the introduction screen and the game over screen will need to store the
    difficulty level the user selects (in the `playMode` instance variable) and implement
    a method to start the game, as both have a **Play MazeWorld** button on them.
    That commonality is captured in the `MazeWorldScreens` class. The `startGame()`
    method passes the mode of play to a new instance of MazeWorld and then switches
    the scenario to that world.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍界面和游戏结束界面都需要存储用户选择的难度级别（在`playMode`实例变量中）并实现一个启动游戏的方法，因为它们都有一个**Play MazeWorld**按钮。这种共性被`MazeWorldScreens`类捕捉。`startGame()`方法将游戏模式传递给一个新的MazeWorld实例，然后切换场景到那个世界。
- en: Create the `MazeWorldIntro` and `MazeWorldGameOver` classes as subclasses of
    `MazeWorldScreens`. Make sure to create an image (minus the UI elements) for the
    introduction screen that looks like *Figure 6* and an image (minus the UI elements)
    for the game over screen that looks like *Figure 7*, and select them as the images
    for your new classes. Our images do not need to contain the UI elements as we
    will be adding them to these screens dynamically.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MazeWorldIntro`和`MazeWorldGameOver`类作为`MazeWorldScreens`的子类创建。确保创建一个看起来像*图6*的介绍界面图像（不包含UI元素）和一个看起来像*图7*的游戏结束界面图像（不包含UI元素），并将它们作为新类的图像选择。我们的图像不需要包含UI元素，因为我们将在这些屏幕上动态添加它们。
- en: Once you have created these `World` classes, you should see what is shown in
    *Figure 8* in the **World classes** area of your main Greenfoot scenario screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这些`World`类，你应该能在你的主要Greenfoot场景屏幕的**World类**区域看到*图8*所示的内容。
- en: '![Adding menus and buttons](img/image00325.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![添加菜单和按钮](img/image00325.jpeg)'
- en: 'Figure 8: This shows the class hierarchy for World classes in MazeWorld'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：这显示了MazeWorld中World类的类层次结构
- en: 'Here is the code you need to add to the `MazeWorldIntro` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要添加到`MazeWorldIntro`类的代码：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `prepare()` method adds the UI elements to the introduction screen. For
    clarity, *Figure 9* shows a close-up view of the specific elements added. The
    play button uses two images I created (one for the pressed state and the other
    for the normal state of the button). You will need to create your own images or
    use two of the default ones provided with Greenfoot. An instance of the `Menu`
    class is placed next to the button. This menu will allow the user to specify whether
    they want to play in easy, medium, or hard mode (later, we will change the `MazeWorld`
    class to honor these selections). To complete the functionality of the menu, we
    need to provide a class that implements the `MenuCommands` interface. In this
    case, we pass a `GameDifficultyCommands` object. Lastly, we add an instance of
    `TextBox` to display the current difficulty level of the game. The message changes
    if the user selects a different difficulty level.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepare()`方法将UI元素添加到介绍屏幕。为了清晰起见，*图9*显示了添加的具体元素的特写视图。播放按钮使用我创建的两个图像（一个用于按钮按下状态，另一个用于按钮的正常状态）。你需要创建自己的图像或使用Greenfoot提供的两个默认图像之一。`Menu`类的一个实例放置在按钮旁边。此菜单将允许用户指定他们想要在简单、中等或困难模式中玩游戏（稍后，我们将更改`MazeWorld`类以尊重这些选择）。为了完成菜单的功能，我们需要提供一个实现`MenuCommands`接口的类。在这种情况下，我们传递一个`GameDifficultyCommands`对象。最后，我们添加一个`TextBox`实例以显示游戏的当前难度级别。如果用户选择不同的难度级别，消息将更改。'
- en: '![Adding menus and buttons](img/image00326.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![添加菜单和按钮](img/image00326.jpeg)'
- en: 'Figure 9: This is a close-up view of the UI elements on the introduction screen
    in MazeWorld.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：这是MazeWorld介绍屏幕上UI元素的特写视图。
- en: 'As with the UI example scenario, you will need to add the `MenuCommands` interface
    to your scenario. For convenience, I have replicated the code for the `MenuCommands`
    interface here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与UI示例场景一样，你需要在你的场景中添加`MenuCommands`接口。为了方便，我在这里复制了`MenuCommands`接口的代码：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `GameDifficultyCommands` class implements the `MenuCommands` interface
    and provides the appropriate commands for the menu choices provided in the popup.
    Here is the code for `GameDifficultyCommands`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameDifficultyCommands`类实现了`MenuCommands`接口，并为弹出菜单中提供的菜单选项提供了适当的命令。以下是`GameDifficultyCommands`的代码：'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For each menu choice, the `execute()` method in the `GameDifficultyCommands`
    class calls the `setMode()` method that we defined in the `MazeWorldIntro` class.
    This method changes the message of `TextBox` in the introductory screen, as well
    as stores the difficulty mode for later use.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个菜单选项，`GameDifficultyCommands`类中的`execute()`方法调用我们在`MazeWorldIntro`类中定义的`setMode()`方法。此方法更改介绍屏幕上`TextBox`的消息，并存储用于后续使用的难度模式。
- en: 'The `MazeWorldGameOver` class is simpler, as it only needs to add a play button.
    Here is the code for the `MazeWorldGameOver` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`MazeWorldGameOver`类更简单，因为它只需要添加一个播放按钮。以下是`MazeWorldGameOver`类的代码：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The game over screen needs the difficulty level passed to it in its constructor
    via the `pm` parameter variable, so that it can pass it to `MazeWorld` when the
    player hits the **Play MazeWorld** button to play again.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束屏幕需要通过构造函数中的`pm`参数变量传递难度级别，以便在玩家点击**Play MazeWorld**按钮再次游戏时将其传递给`MazeWorld`。
- en: Of course, this will not work as we have not added the `Menu`, `TextBox`, and
    `Button` classes we created in `UIWorldScenario`. These classes will be identical
    or very similar to the ones we already discussed earlier in the chapter. We will
    look at the code here now and only discuss the differences.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不会工作，因为我们还没有添加在`UIWorldScenario`中创建的`Menu`、`TextBox`和`Button`类。这些类将与我们在本章前面讨论过的类相同或非常相似。我们现在将查看代码，并只讨论差异。
- en: First, to easily group the UI classes together, let's create an empty class,
    named `UI`, they all can inherit from. This is a useful organizational technique
    in Greenfoot where you may have projects with hundreds of actors in them. As we
    progress through this section and the next section, we will be creating the class
    hierarchy shown in *Figure 10*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了方便地将UI类分组在一起，让我们创建一个空类，命名为`UI`，它们都可以继承。这是Greenfoot中的一种有用的组织技术，其中你可能有一个包含数百个演员的项目。随着我们通过本节和下一节，我们将创建*图10*中显示的类层次结构。
- en: '![Adding menus and buttons](img/image00327.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![添加菜单和按钮](img/image00327.jpeg)'
- en: 'Figure 10: This shows the class structure of the UI elements in MazeWorld'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：这显示了MazeWorld中UI元素的类结构
- en: 'Here is the code for `UI`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`UI`的代码：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code for `TextBox`, `Button`, and `Menu` are exactly the same as they were
    in the UI example scenario we worked on at the beginning of this chapter. Add
    them now to the `MazeWorld` scenario in exactly the same way you added them to
    the UI scenario except for one small change. These classes will subclass `UI`
    instead of `Actor`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`、`Button`和`Menu`的代码与我们在本章开头的工作场景中的UI示例场景中的代码完全相同。现在以完全相同的方式将它们添加到`MazeWorld`场景中，除了一个小变化。这些类将继承自`UI`而不是`Actor`。'
- en: 'Last, we need to create the `PlayButton` class. This class extends the `Button`
    class (as shown in *Figure 9*) and contains the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建`PlayButton`类。这个类扩展了`Button`类（如图9所示）并包含以下代码：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This class overrides the empty `clickedAction()` method found in the `Button`
    class. When the user clicks on an instance of `PlayButton`, the `startGame()`
    method is called. This is the method we implemented in `MazeWorldScreens` earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类覆盖了在`Button`类中找到的空`clickedAction()`方法。当用户点击`PlayButton`实例时，会调用`startGame()`方法。这是我们之前在`MazeWorldScreens`中实现的方法。
- en: We just added a ton of code. We went through it fairly quickly as most of the
    code we added was explained in the first part of this chapter and in earlier chapters.
    We have a few more things to add to complete this new version of MazeWorld. We
    need to add a heads-up display and then augment the `MazeWorld` class to allow
    the game to be played according to the difficulty mode selected by the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了大量代码。我们处理得相当快，因为大部分我们添加的代码都在本章的第一部分和前面的章节中解释过了。我们还需要添加一些内容来完成这个MazeWorld的新版本。我们需要添加一个抬头显示，然后增强`MazeWorld`类，以便游戏可以根据用户选择的难度模式进行游戏。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You should always test your code as often as you can. Sometimes, you will need
    to make small, simple/temporary changes to your code to be able to test it. For
    example, if we change the constructor of the `MazeWorld` class to accept an integer
    parameter, then we can compile and run the code at this point in time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该尽可能频繁地测试您的代码。有时，您可能需要对代码进行一些小的、简单的/临时更改，以便能够测试它。例如，如果我们更改`MazeWorld`类的构造函数以接受一个整数参数，那么我们就可以在此时编译并运行代码。
- en: Adding a HUD
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加HUD
- en: We are going to add a simple set of actions for the main character in the game.
    *Figure 11* shows the three controls we are adding. If the user clicks on the
    first icon, then the enemies will be temporarily stunned. If the user clicks on
    the second icon, then the enemies will move slower for a short period of time.
    If the user clicks on the last icon, then the snake enemies say, "sssssssss".
    Having the snakes hiss does not really help the player beat the game. I just thought
    it was something fun we could add.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为游戏中的主要角色添加一组简单的动作。*图11*显示了我们要添加的三个控制器。如果用户点击第一个图标，敌人将暂时昏迷。如果用户点击第二个图标，敌人将暂时移动得更慢。如果用户点击最后一个图标，蛇形敌人会说，“sssssssss”。让蛇嘶嘶叫并不能真正帮助玩家赢得游戏。我只是觉得我们可以添加一些有趣的东西。
- en: '![Adding a HUD](img/image00328.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![添加HUD](img/image00328.jpeg)'
- en: 'Figure 11: This shows a set of controls we are adding to MazeWorld'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：这显示了我们要添加到MazeWorld的一组控制器
- en: '*Figure 12* is a close-up view of the controls when placed in the game; we
    are adding them to the bottom-middle of the screen.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12*是放置在游戏中的控制器的特写视图；我们将它们添加到屏幕的底部中间。'
- en: '![Adding a HUD](img/image00329.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![添加HUD](img/image00329.jpeg)'
- en: 'Figure 12: This shows the HUD in the game'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：这显示了游戏中的抬头显示
- en: Using your favorite graphics editor, create something similar to the picture
    shown in *Figure 12*. I made my graphic fairly small so that it would be fully
    contained in the bottom black border of the game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的图形编辑器，创建与*图12*中显示的图片类似的东西。我使我的图形相当小，以便它完全包含在游戏的底部黑色边框中。
- en: 'Once you have an appropriate graphic, create the `MazeWorldHUD` class as a
    subclass of `UI`. Associate the graphic you just made with it and add the following
    code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了合适的图形，创建`MazeWorldHUD`类作为`UI`的子类。将您刚刚创建的图形与之关联，并添加以下代码：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code differs from the HUD we added in the UI example scenario, in that
    we now have three controls instead of four and the `handleMouseClicks()` method
    performs the appropriate actions for this scenario. In `addedToWorlds()`, we create
    three `TransparentRectangle` objects and place them over the three icons (stun,
    slow, and talk) in our image. In `handleMouseClicks()`, we obtain a reference
    to the current `World` object and call one of the following three methods on it:
    `stunAllEnemies()`, `slowAllEnemies()`, and `makeSnakesTalk()`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与我们在UI示例场景中添加的HUD不同，我们现在有三个控制按钮而不是四个，并且`handleMouseClicks()`方法执行此场景的适当操作。在`addedToWorlds()`中，我们创建三个`TransparentRectangle`对象，并将它们放置在我们图像中的三个图标（stun、slow和talk）上。在`handleMouseClicks()`中，我们获取当前`World`对象的引用，并对其调用以下三个方法之一：`stunAllEnemies()`、`slowAllEnemies()`和`makeSnakesTalk()`。
- en: This concludes adding a HUD to MazeWorld. Next, we need to modify the `MazeWorld`
    class to change the game, based on the play mode selected by the player and implement
    the `stunAllEnemies()`, `slowAllEnemies()`, and `makeSnakesTalk()` methods.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了向`MazeWorld`添加HUD。接下来，我们需要修改`MazeWorld`类，根据玩家选择的播放模式更改游戏，并实现`stunAllEnemies()`、`slowAllEnemies()`和`makeSnakesTalk()`方法。
- en: Implementing game difficulty settings and HUD controls
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏难度设置和HUD控制
- en: 'We have a few things to take care of before our new version of MazeWorld is
    ready. First, we need to incorporate the difficulty level chosen by the player
    on the introduction screen, and we need to implement the functionality of the
    HUD we added to the game. These changes involve three classes: `MazeWorld`, `ScrollingEnemy`,
    and `Snake`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新版本`MazeWorld`准备好之前，我们有一些事情要处理。首先，我们需要将玩家在介绍屏幕上选择的难度级别整合到游戏中，并且我们需要实现我们添加到游戏中的HUD的功能。这些更改涉及三个类：`MazeWorld`、`ScrollingEnemy`和`Snake`。
- en: 'Here is the code for `MazeWorld` where the changes needed are highlighted:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有所需更改高亮的`MazeWorld`代码：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are going to implement the different difficulty levels by changing the number
    of enemies you have to avoid in the maze. First, we create the `playMode` instance
    variable to store the difficulty level. Next, we need to add another constructor
    that accepts an integer parameter. To do this, we need to change the old constructor
    that had no parameters to have one and add one line of code that sets the `playMode`
    instance variable to that parameter—everything else remains the same. We can then
    add a new constructor that has no parameters and simply calls the other constructor
    method passing in a value of `0` (which corresponds to the easy mode). Finally,
    in the `prepare()` method, we add code at the end of the method to check whether
    to add more actors to the game depending on the value of `playMode`. If `playMode`
    is `1`, then we add an additional snake. If it is `2`, then we add an additional
    snake and mouse to the game.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过改变迷宫中需要避免的敌人数量来实现不同的难度级别。首先，我们创建`playMode`实例变量来存储难度级别。接下来，我们需要添加另一个接受整数参数的构造函数。为此，我们需要将没有参数的老构造函数改为有一个参数，并添加一行代码将`playMode`实例变量设置为该参数——其余保持不变。然后我们可以添加一个新的构造函数，它没有参数，并简单地调用其他构造函数方法，传入值为`0`（这对应于简单模式）。最后，在`prepare()`方法中，我们在方法末尾添加代码来检查是否根据`playMode`的值添加更多演员到游戏中。如果`playMode`是`1`，则添加一个额外的蛇。如果是`2`，则添加一个额外的蛇和老鼠到游戏中。
- en: Next, we need to add the `stunAllEnemies()`, `slowAllEnemies()`, and `makeSnakesTalk()`
    methods to `MazeWorld`. Each method uses the Greenfoot `World` method `getObjects()`
    to get a list of all the objects of the supplied type. When `ScrollingEnemy.class`
    is supplied to `getObjects()`, we get a list of all current enemies. When `Snake.class`
    is passed as a parameter to the `getObjects()` method, we get a list of all the
    `Snake` objects currently in the scenario. We then loop through the list of objects
    and call `stun()`, `slow()`, and `talk()`, respectively, on the objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`stunAllEnemies()`、`slowAllEnemies()`和`makeSnakesTalk()`方法添加到`MazeWorld`中。每个方法都使用Greenfoot的`World`方法`getObjects()`来获取所有指定类型的对象列表。当将`ScrollingEnemy.class`传递给`getObjects()`时，我们得到所有当前敌人的列表。当将`Snake.class`作为参数传递给`getObjects()`方法时，我们得到当前场景中所有`Snake`对象的列表。然后我们遍历对象列表，分别对对象调用`stun()`、`slow()`和`talk()`。
- en: Because all of the enemies inherit from `ScrollingEnemy`, we can implement both
    `stun()` and `slow()` in that class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有敌人都是从`ScrollingEnemy`继承的，因此我们可以在该类中实现`stun()`和`slow()`。
- en: 'Here is the code for `ScrollingEnemy` with the required changes highlighted:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有所需更改高亮的`ScrollingEnemy`代码：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At the beginning of the `Snake` class, we add four instance variables. Two of
    the variables store information about how long the enemies are stunned (`stunTime`)
    and slowed (`slowTime`) and the other two variables track whether or not we are
    presently in a stunned (`stunned`) or slowed (`slowed`) state.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Snake`类的开始部分，我们添加了四个实例变量。其中两个变量存储有关敌人被击晕（`stunTime`）和减速（`slowTime`）的信息，另外两个变量跟踪我们是否处于被击晕（`stunned`）或减速（`slowed`）的状态。
- en: When a `ScrollingEnemy` object is stunned by the player, the `stun()` method
    is invoked on that object (as we saw in our discussion on `MazeWorld`). The `stun()`
    method will do nothing if the object is presently stunned. If not, the method
    will set `stunned` to `true` and set `stunTime` to `100`. These values are used
    in the `act()` method to implement stunning the object. The `slow()` method is
    nearly identical to the `stun()` method, except that `slowTime` is set to `400`.
    This equates to the slowing of an object lasting longer than a stun.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家击晕`ScrollingEnemy`对象时，将对该对象调用`stun()`方法（正如我们在关于`MazeWorld`的讨论中所见）。如果对象当前处于击晕状态，则`stun()`方法将不执行任何操作。如果不是，该方法将`stunned`设置为`true`并将`stunTime`设置为`100`。这些值在`act()`方法中用于实现击晕对象。`slow()`方法与`stun()`方法几乎相同，只是将`slowTime`设置为`400`。这意味着减速对象的持续时间比击晕时间长。
- en: In `act()`, we check the values of the `stunned` Boolean variable and skip calling
    the `sense()`, `reaction()`, and `boundedMove()`methods if `stunned` is `true`.
    The `stunTime` variable serves as a delay variable (covered in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*). If we are not stunned, then the `act()`
    method proceeds to check the `slowed` variable. If not slowed, we proceed as normal.
    The `slowTime` variable serves as a delay variable; however, as it is counting
    down, it toggles the values of `slowed`. This toggling will constrain the `sense()`,
    `reaction()`, and `boundedMove()` methods to only be invoked on every other call
    of the `act()` method. This makes the enemies move at half speed when slowed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`act()`中，我们检查`stunned`布尔变量的值，如果`stunned`为`true`，则跳过调用`sense()`、`reaction()`和`boundedMove()`方法。`stunTime`变量作为延迟变量（在第2章中介绍，*动画*）。如果我们没有被击晕，则`act()`方法将继续检查`slowed`变量。如果没有减速，我们按正常进行。`slowTime`变量作为延迟变量；然而，由于它正在倒计时，它会切换`slowed`的值。这种切换将`sense()`、`reaction()`和`boundedMove()`方法约束为仅在`act()`方法的每次调用中执行一次。这使得减速时敌人移动速度减半。
- en: Since snakes are the only ones that need to talk, we put the implementation
    of the `talk()` method directly into the `Snake` class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于蛇是唯一需要说话的，我们将`talk()`方法的实现直接放入`Snake`类中。
- en: 'Here is the code for `Snake` with the required changes highlighted:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是带有所需更改高亮的`Snake`代码：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like the implementation of `stun()` and `slow()` in the `ScrollingEnemy` class,
    we need a delay variable (`talkTime`) and Boolean (`talking`) to implement the
    `talk()` method. In addition, we need a variable to store—`TextBox` (`sss`)—that
    will contain the `sssssss` text. The `talk()` method is structured in the same
    way as `stun()` and `slow()`. However, `talk()` must also create `TextBox` and
    add it to the world.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ScrollingEnemy`类中`stun()`和`slow()`的实现类似，我们需要一个延迟变量（`talkTime`）和一个布尔值（`talking`）来实现`talk()`方法。此外，我们还需要一个变量来存储`TextBox`（`sss`），它将包含`sssssss`文本。`talk()`方法的结构与`stun()`和`slow()`相同。然而，`talk()`方法还必须创建`TextBox`并将其添加到世界中。
- en: We can see in `reaction()` that if the `Snake` object is in a talking state
    then the `sss TextBox` will be displayed offset from the location of the object
    for a time specified by the `talkTime` instance variable. Once `talkTime` expires,
    it must also remove the `sss TextBox` variable from the world.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reaction()`方法中，我们可以看到如果`Snake`对象处于说话状态，则`sss TextBox`将在对象位置偏移一段时间后显示，这段时间由`talkTime`实例变量指定。一旦`talkTime`到期，它还必须从世界中移除`sss
    TextBox`变量。
- en: Congratulations! You have finished our new version of MazeWorld. Compile it
    and try it out. Click the stun, slow, and talk actions in the game. If you have
    any issues or errors in your game and are having a tough time solving them, compare
    your version to the completed version at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了我们新的MazeWorld版本。编译并尝试运行它。点击游戏中的击晕、减速和说话动作。如果你在游戏中遇到任何问题或错误，并且难以解决，请将你的版本与完成的版本在[http://www.packtpub.com/support](http://www.packtpub.com/support)进行比较。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The MazeWorld scenario was constructed solely to help demonstrate the concepts
    covered in [Chapter 7](part0047.xhtml "Chapter 7. Artificial Intelligence"), *Artificial
    Intelligence*, and the current chapter. Therefore, it is not actually great fun
    to play, but it does have a lot of potential. Using the game design knowledge
    you acquired in [Chapter 5](part0034.xhtml "Chapter 5. Interactive Application
    Design and Theory"), *Interactive Application Design and Theory*, try making changes
    to MazeWorld that will enhance its playability.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: MazeWorld场景仅是为了帮助展示[第7章](part0047.xhtml "第7章。人工智能")中涵盖的概念，即*人工智能*和当前章节。因此，它实际上并不好玩，但它确实有很大的潜力。利用你在[第5章](part0034.xhtml
    "第5章。交互式应用程序设计和理论")，*交互式应用程序设计和理论*中获得的游戏设计知识，尝试对MazeWorld进行修改，以增强其可玩性。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You are now officially a Greenfoot programming ninja. You know how to create
    Greenfoot games and simulations that contain lively and intelligent actors with
    various methods that allow user/player interaction. You can implement keyboard/mouse
    controls, buttons, menus, and customized interfaces.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在正式成为了一名Greenfoot编程忍者。你懂得如何创建包含生动智能演员的Greenfoot游戏和模拟，这些演员拥有各种方法，允许用户/玩家进行交互。你可以实现键盘/鼠标控制、按钮、菜单和自定义界面。
- en: In the next chapter, we are going to add a gamepad controller support to our
    Greenfoot scenarios. Gamepads are a great way to capture user inputs, especially
    for games.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的Greenfoot场景添加游戏手柄控制器支持。游戏手柄是捕捉用户输入的绝佳方式，尤其是对于游戏来说。
