- en: Chapter 8. User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"If you can dream it, you can do it."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Walt Disney* |'
  prefs: []
  type: TYPE_TB
- en: 'Aside from user controls for games and simulations, you will, at times, want
    your user to click buttons, view text, and select items from menus. Imagine that
    you are creating a physics simulation and want to have your user set certain simulation
    parameters or that you have a store in your game where players can purchase upgrades.
    Or perhaps you want to create a dialogue between two actors in your scenario.
    In this chapter, we are going to explore techniques to provide various types of
    **user interfaces** (**UIs**). Specifically, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Buttons and labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heads-up display (HUD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greenfoot provides little direct support to create user interfaces. There are
    only a few classes, such as `Label` and `Counter`, packaged with Greenfoot to
    help in this regard. So, we will have to build our own support. We will use Greenfoot
    `Actors` and the `GreenfootImage` class to create user interfaces and classes
    that will support the creation of user interfaces. Luckily, Greenfoot allows us
    to build just about anything we can dream up, including user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: UIWorld
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explain how to write the following user interface
    elements: buttons, textboxes, menus, and **heads-up displays** (**HUDs**). We
    are going to work through a Greenfoot scenario (shown in *Figure 1*) that only
    contains user interface elements, so we can discuss each element independently.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the code we write will be general and able to be applied to many different
    scenarios. In other cases, we will write user interface code that will only need
    minor modification to be used across scenarios. In the next section, we will add
    these elements to the `MazeWorld` scenario that we wrote in the previous chapter,
    to make it a more polished and playable game.
  prefs: []
  type: TYPE_NORMAL
- en: '![UIWorld](img/image00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: This shows UI MainWorld'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work through this scenario, start with a new Greenfoot scenario named `UIMainWorld`,
    create a subclass of `World` named `UIMainWorld`, and then associate a plain background
    to it. The background I chose was `bluerock.jpg`. Here is the code for `UIMainWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For now, the lines of code in the `testActors()` method are commented out. Uncomment
    them as we implement the associated actor, so that you can test and play with
    each one in turn. If you prefer, you can download the complete UI scenario from
    [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: The Button class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Is there a more prolific UI element than the humble button? It is hard to imagine
    any interface that does not contain several of these buttons. Luckily for us,
    they are very easy to implement in Greenfoot. In your UI scenario, subclass the
    `Actor` class and call this new subclass `Button`. Choose **No Image** for the
    image of `Button`. We will dynamically add the images necessary for this actor.
    Here is the code for the `Actor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For a button, you need to have one image for the normal state and one image
    for the pressed state. The `first` and `second` instance variables store the names
    of these images. Their values are provided to the class's constructor as input
    parameters. The constructor sets the initial image to the `first` image.
  prefs: []
  type: TYPE_NORMAL
- en: The `act()` method only contains one method call to handle mouse events for
    this actor—`handleMouseClicks()`. This method displays the `second` image when
    the mouse is pressed and then goes back to displaying the `first` image when the
    click completes. In Greenfoot, the `Greenfoot.mousePressed()` method returns `true`
    when the left mouse button is held down on the given object. The `Greenfoot.mouseClicked()`
    method returns `true` when the left mouse button is pressed down and released
    on the given object. *Figure 2* demonstrates these two mouse events. When we detect
    that the mouse is pressed, we simply change the image to the `second` image. When
    the mouse is released, a full click has occurred, and we do two things. First,
    we set the image back to normal, and then we perform an action by calling the
    `clickedAction()` method. This method is currently empty and serves as a placeholder
    where you could put the code for your own custom action. Another option, would
    be to subclass this class and override the `clickedAction()` method in your new
    subclass.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Button class](img/image00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: In Greenfoot, a mouse is considered clicked when the left mouse button
    is both pressed and released'
  prefs: []
  type: TYPE_NORMAL
- en: 'The button was added to the screen in the `UIMainWorld` subclass of `World`
    with the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `button-blue.png` and `button-green.png` images are the images that come
    with the default installation of Greenfoot (not available in version 2.2). You
    can quickly get these images into your project by creating temporary actors that
    have them as their default image or by copying them from the installation of Greenfoot.
    Uncomment the two lines shown in the `testActors()` method in `UIMainWorld`, compile
    your scenario, and test out your new button.
  prefs: []
  type: TYPE_NORMAL
- en: The TextBox class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functionality of `TextBox` is very similar in functionality to the `Label`
    class that is supplied with Greenfoot. Note that in `UIMainWorld`, we added one
    instance of the `Label` class to our scenario for demonstration and comparison
    purposes. To add the `Label` class to your UI scenario, click on **Edit** in Greenfoot's
    main menu and then click on **Import Class…**. Click on **Label** on the left-hand
    side of the pop-up window that appears, read the documentation on the `Label`
    class (if you are interested), and then click on the **Import** button. We will
    implement our own version of `Label` and call it `TextBox`. The `Textbox` class
    we will write is a bit more concise and provides us with a reason to discuss how
    to work with text in Greenfoot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 1*, we can see two examples of the `TextBox` class. This class allows
    us to display text on the screen with a custom font, color, background color,
    and optional border. Here is the code for `TextBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In `TextBox`, we can configure the foreground color, background color, font
    size, and whether or not to draw a border around the textbox. In addition to the
    actual text to display, the constructor accepts and stores these values. The `display()`
    method is responsible for actually creating our new textbox. First, it creates
    a new image based on the earlier configuration information using Greenfoot's `GreenfootImage()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: When you supply text as the first parameter to `GreenfootImage()`, it will create
    an image of that text. Then, we can just use `setImage()` to display that text.
    The `display()` method checks the `border` instance variable and draws a border
    in the new image we created, if needed. We also supplied a `setText()` method,
    in case we need to dynamically change the text. This method creates a new `GreenfootImage`
    based on the new text and then uses the `display()` method to properly set the
    image of the textbox to the new image created.
  prefs: []
  type: TYPE_NORMAL
- en: To test our new `TextBox` class, uncomment all the lines in `testActors()` in
    `UIMainWorld` that deal with adding instances of `TextBox`, compile the scenario,
    and run it.
  prefs: []
  type: TYPE_NORMAL
- en: The Menu class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Menus are amazing at accepting user commands. I am sure you have had plenty
    of experience using them and understand their utility. Our implementation of a
    menu involves using the `TextBox` class we just created and a new Java interface
    named `MenuCommands` that we will implement soon. The `TextBox` instances display
    the text, and the actions of the menu choice are performed by classes that implement
    the `MenuCommands` interface. We will explain that more thoroughly soon.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3* provides an overview of the functionality of our `Menu` class. Our
    menu initially looks like `TextBox`, as shown in *Figure 3(a)*. When the user
    clicks on the menu, a pop-up menu appears with a set of actions the user can choose
    from. The pop-up menu is shown in *Figure 3(b)*. Both the menu title and set of
    commands are configurable.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Menu class](img/image00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Initially, menu objects look like TextBox (see (a)). When the user
    clicks on the text, a drop-down menu appears, giving the user multiple items to
    choose from (see (b))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `Menu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An instance of `Menu` is composed of two `TextBox` instances and one implementation
    of the `MenuCommands` interface. The first `TextBox` instance represents the menu
    title (shown in *Figure 3(a)*), and the second `TextBox` instance represents the
    collection of commands (shown in *Figure3(b)*). The Menu constructor creates both
    `TextBox` instances and stores the supplied `MenuCommands` object for later use.
  prefs: []
  type: TYPE_NORMAL
- en: When `Menu` is added to `World`, we use the `addedToWorld()`method to place
    the menu title bar in the scenario and collect height information needed to properly
    place the pop-up window later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `act()` method calls one method, `handleMouse()`, that places the menu
    item popup when the title text is clicked on. For the menu item popup, the method
    `handleMouse()` determines whether it was clicked on and where it was clicked
    and then calls the appropriate command. The following code determines the click
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is based on the current font size and the height of the `TextBox` menu
    item. *Figure 4* shows the calculation pictorially.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Menu class](img/image00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: To determine which menu item was clicked on, use this formula: ((a)-(b)+(c))/(d).
    This formula determines the distance between the center of the image (b) and the
    click location (a), adjusts the value so that it is relative to the top of the
    figure by adding half the height (c) and then dividing by the font size (d) to
    get the actual index of the item'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the index of the menu item clicked on by the user, we need
    to run the command associated with it. To do this, we simply call the `execute()`
    method on the `MenuCommands` object that was passed to us via the constructor.
    `MenuCommands` is a Java interface that guarantees that any Java class that implements
    this interface will have the `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first encountered Java interfaces in [Chapter 3](part0024.xhtml "Chapter 3. Collision
    Detection"), *Collision Detection*. Remember that a class that implements a Java
    interface is promising to provide an implementation of every method defined in
    that interface. For more information, review [Chapter 3](part0024.xhtml "Chapter 3. Collision
    Detection"), *Collision Detection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `MenuCommands`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this interface only defines one method, `execute()`, that must
    accept an integer parameter (representing the index of the menu item) and a reference
    to the current `World` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our UI scenario, we provide two examples of using the `Menu` class. The
    first is the one that has the menu title bar text, **Destroy Everything?**. The
    menu that pops up only has one option, **Are you sure?**. Here is the code for
    the `DestroyCommands` class, which implements the `MenuCommands` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because the pop-up menu only has one choice, we do not need to use the supplied
    `idx` value. We implement the `execute()` method by simply printing **Boooom!!!!**
    to the console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `Menu` class example mimics the types of commands you would see
    in an application that works with files. This example is shown in *Figure 3*.
    Here is the code for `FileCommands`, which implements the `MenuCommands` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `idx` value to run one of several available options. For
    simplicity, we simply print messages to the console window to demonstrate that
    the code is working properly. In your own applications, you would substitute the
    print messages with actual relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision
    Detection*, we used interfaces because we needed to conform to the Greenfoot API.
    In this case, we choose to use interfaces because they provided a clean and simple
    way to provide many different types of menu actions without having to change the
    `Menu` class. We have effectively abstracted the need to know about the contents
    of the custom menus and made our `Menu` class applicable to a wide variety of
    uses.
  prefs: []
  type: TYPE_NORMAL
- en: Now, uncomment the `Menu` actors in the `testActors()` method in `UIMainWorld`
    and test out the menus we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Menu` class is fairly complicated as it involves managing two `TextBox`
    classes and implementing a `MenuCommands` interface. To improve your understanding
    of it, try creating your own menu and adding it to the UI scenario now.
  prefs: []
  type: TYPE_NORMAL
- en: Heads-up display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, you want to create a completely custom UI that involves various shapes
    and graphics. In this section, we will learn how to do exactly that. The title
    of this section is heads-up display (HUD) because games often have custom interfaces
    (called HUDs) that provide critical information and controls to their players.
    However, the methodology discussed here applies to any custom UI. For our example,
    we will create the custom user interface element shown in *Figure 5*. In our HUD,
    the user will be able to click the home, favorite, print, and cart icons to perform
    actions of our choosing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Heads-up display](img/image00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: This shows a custom user interface element'
  prefs: []
  type: TYPE_NORMAL
- en: The graphic shown in *Figure 5* was created in Adobe Illustrator. Use any graphic
    editor to create something that looks similar. In the UI scenario, create a new
    `HUD` actor and associate the image you created with it. In general, you can create
    any graphic you want in any editor you want. Our method of creating a custom interface
    involves us overlaying invisible Greenfoot actors over the custom graphic, and
    the graphic is not required to be any certain shape or size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `HUD` class in our UI scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated in the preceding snippet, there is not a lot of code associated
    with this class. The code creates four new invisible actors and places them over
    objects we want the user to be able to click on in our custom UI. In the `addedToWorld()`
    method, we create home, favorite, print, and cart actors to cover the home, favorite,
    print, and cart icons shown in *Figure 5*. The part of this method that is specific
    to the graphic shown in *Figure 5* is the placement of the invisible actors. If
    you created a different graphic than the one I have shown, then you will need
    to determine the correct locations to place the new actors yourself.
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that the invisible actors we created were instances
    of an inner class named `TransparentRectangle`. This is the first time we have
    used an inner class in this book, and they warrant some discussion. At the simplest
    level, an inner class is just a class that was defined inside another class and,
    thus, not generally accessible to other classes in the project. The following
    information box contains additional information about inner classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More about inner classes**'
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented design, you solve a problem by breaking it up into smaller
    objects and then carefully constructing how those objects communicate or cooperate.
    This is an example of top-down design (discussed in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*) where we break a problem
    up into smaller and smaller subproblems. Sometimes, a class's internal state may
    be quite complex and using inner classes may help manage that internal complexity.
    In essence, this is a form of hierarchical object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of inner classes is encapsulating classes that only have a very
    specific use for only one class in the project. For example, our `HUD` class is
    the only class in our scenario that uses the `TransparentRectangle` class. By
    hiding `TransparentRectangle` within `HUD`, no other class is exposed to `TransparentRectangle`.
    You will notice that in Greenfoot, `TransparentRectangle` does not appear in the
    **Actor classes…** section of the main scenario window.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on inner classes (and nested classes), refer to the article
    at: [http://www.javaworld.com/article/2077411/core-java/inner-classes.html](http://www.javaworld.com/article/2077411/core-java/inner-classes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The last two methods, `act()` and `handleMouseClicks()`, follow a common pattern
    to handle mouse clicks on actors, which we have seen several times in this book
    and discuss again here. As with the `Menu` actors we created in this scenario,
    we print a message to the console when the user clicks on one of the icons.
  prefs: []
  type: TYPE_NORMAL
- en: Let us test the whole scenario now. Remember to uncomment the `HUD` actor created
    and added to the scenario in the `testActors()` method in `UIMainWorld`. Compile
    and ensure that messages are being sent to the console when you click on the various
    icons.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a UI to MazeWorld
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some experience in creating various UI elements, we are going
    to enhance the MazeWorld scenario from the previous chapter. This will give us
    the opportunity to practice what we have learned in a more realistic context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will add:'
  prefs: []
  type: TYPE_NORMAL
- en: A start screen with a button to start the game and a menu the player can use
    to indicate the difficulty mode of the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A game over screen with a button the player can use to restart the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A HUD the player can use to temporarily stun the enemies, slow them, or make
    the snake enemies say, "sssssssss"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start with the code for MazeWorld you ended with in the previous chapter, or
    download it from [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: Adding menus and buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add an introduction screen and game over screen to
    `MazeWorld`. We will add a button, textbox, and menu to the introduction screen
    (shown in *Figure 6*) and just a button to the game over screen (shown in *Figure
    7*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding menus and buttons](img/image00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: This is the new introduction screen we are adding to MazeWorld'
  prefs: []
  type: TYPE_NORMAL
- en: This is how the game over screen will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding menus and buttons](img/image00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: This is the new game over screen we are adding to MazeWorld'
  prefs: []
  type: TYPE_NORMAL
- en: We created an introduction screen and game over screen in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…* and augmented the game
    over screen in [Chapter 5](part0034.xhtml "Chapter 5. Interactive Application
    Design and Theory"), *Interactive Application Design and Theory* for Avoider Game,
    so the addition of these screens to MazeWorld will only be quickly covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we are going to create a new class that both screens will inherit
    from. Create a new subclass of the `World` class and name it, `MazeWorldScreens`;
    don''t associate an image with this class, and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both the introduction screen and the game over screen will need to store the
    difficulty level the user selects (in the `playMode` instance variable) and implement
    a method to start the game, as both have a **Play MazeWorld** button on them.
    That commonality is captured in the `MazeWorldScreens` class. The `startGame()`
    method passes the mode of play to a new instance of MazeWorld and then switches
    the scenario to that world.
  prefs: []
  type: TYPE_NORMAL
- en: Create the `MazeWorldIntro` and `MazeWorldGameOver` classes as subclasses of
    `MazeWorldScreens`. Make sure to create an image (minus the UI elements) for the
    introduction screen that looks like *Figure 6* and an image (minus the UI elements)
    for the game over screen that looks like *Figure 7*, and select them as the images
    for your new classes. Our images do not need to contain the UI elements as we
    will be adding them to these screens dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created these `World` classes, you should see what is shown in
    *Figure 8* in the **World classes** area of your main Greenfoot scenario screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding menus and buttons](img/image00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: This shows the class hierarchy for World classes in MazeWorld'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code you need to add to the `MazeWorldIntro` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `prepare()` method adds the UI elements to the introduction screen. For
    clarity, *Figure 9* shows a close-up view of the specific elements added. The
    play button uses two images I created (one for the pressed state and the other
    for the normal state of the button). You will need to create your own images or
    use two of the default ones provided with Greenfoot. An instance of the `Menu`
    class is placed next to the button. This menu will allow the user to specify whether
    they want to play in easy, medium, or hard mode (later, we will change the `MazeWorld`
    class to honor these selections). To complete the functionality of the menu, we
    need to provide a class that implements the `MenuCommands` interface. In this
    case, we pass a `GameDifficultyCommands` object. Lastly, we add an instance of
    `TextBox` to display the current difficulty level of the game. The message changes
    if the user selects a different difficulty level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding menus and buttons](img/image00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: This is a close-up view of the UI elements on the introduction screen
    in MazeWorld.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the UI example scenario, you will need to add the `MenuCommands` interface
    to your scenario. For convenience, I have replicated the code for the `MenuCommands`
    interface here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GameDifficultyCommands` class implements the `MenuCommands` interface
    and provides the appropriate commands for the menu choices provided in the popup.
    Here is the code for `GameDifficultyCommands`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For each menu choice, the `execute()` method in the `GameDifficultyCommands`
    class calls the `setMode()` method that we defined in the `MazeWorldIntro` class.
    This method changes the message of `TextBox` in the introductory screen, as well
    as stores the difficulty mode for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MazeWorldGameOver` class is simpler, as it only needs to add a play button.
    Here is the code for the `MazeWorldGameOver` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The game over screen needs the difficulty level passed to it in its constructor
    via the `pm` parameter variable, so that it can pass it to `MazeWorld` when the
    player hits the **Play MazeWorld** button to play again.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this will not work as we have not added the `Menu`, `TextBox`, and
    `Button` classes we created in `UIWorldScenario`. These classes will be identical
    or very similar to the ones we already discussed earlier in the chapter. We will
    look at the code here now and only discuss the differences.
  prefs: []
  type: TYPE_NORMAL
- en: First, to easily group the UI classes together, let's create an empty class,
    named `UI`, they all can inherit from. This is a useful organizational technique
    in Greenfoot where you may have projects with hundreds of actors in them. As we
    progress through this section and the next section, we will be creating the class
    hierarchy shown in *Figure 10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding menus and buttons](img/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: This shows the class structure of the UI elements in MazeWorld'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `UI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code for `TextBox`, `Button`, and `Menu` are exactly the same as they were
    in the UI example scenario we worked on at the beginning of this chapter. Add
    them now to the `MazeWorld` scenario in exactly the same way you added them to
    the UI scenario except for one small change. These classes will subclass `UI`
    instead of `Actor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, we need to create the `PlayButton` class. This class extends the `Button`
    class (as shown in *Figure 9*) and contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This class overrides the empty `clickedAction()` method found in the `Button`
    class. When the user clicks on an instance of `PlayButton`, the `startGame()`
    method is called. This is the method we implemented in `MazeWorldScreens` earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We just added a ton of code. We went through it fairly quickly as most of the
    code we added was explained in the first part of this chapter and in earlier chapters.
    We have a few more things to add to complete this new version of MazeWorld. We
    need to add a heads-up display and then augment the `MazeWorld` class to allow
    the game to be played according to the difficulty mode selected by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always test your code as often as you can. Sometimes, you will need
    to make small, simple/temporary changes to your code to be able to test it. For
    example, if we change the constructor of the `MazeWorld` class to accept an integer
    parameter, then we can compile and run the code at this point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add a simple set of actions for the main character in the game.
    *Figure 11* shows the three controls we are adding. If the user clicks on the
    first icon, then the enemies will be temporarily stunned. If the user clicks on
    the second icon, then the enemies will move slower for a short period of time.
    If the user clicks on the last icon, then the snake enemies say, "sssssssss".
    Having the snakes hiss does not really help the player beat the game. I just thought
    it was something fun we could add.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a HUD](img/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: This shows a set of controls we are adding to MazeWorld'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12* is a close-up view of the controls when placed in the game; we
    are adding them to the bottom-middle of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a HUD](img/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: This shows the HUD in the game'
  prefs: []
  type: TYPE_NORMAL
- en: Using your favorite graphics editor, create something similar to the picture
    shown in *Figure 12*. I made my graphic fairly small so that it would be fully
    contained in the bottom black border of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have an appropriate graphic, create the `MazeWorldHUD` class as a
    subclass of `UI`. Associate the graphic you just made with it and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code differs from the HUD we added in the UI example scenario, in that
    we now have three controls instead of four and the `handleMouseClicks()` method
    performs the appropriate actions for this scenario. In `addedToWorlds()`, we create
    three `TransparentRectangle` objects and place them over the three icons (stun,
    slow, and talk) in our image. In `handleMouseClicks()`, we obtain a reference
    to the current `World` object and call one of the following three methods on it:
    `stunAllEnemies()`, `slowAllEnemies()`, and `makeSnakesTalk()`.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes adding a HUD to MazeWorld. Next, we need to modify the `MazeWorld`
    class to change the game, based on the play mode selected by the player and implement
    the `stunAllEnemies()`, `slowAllEnemies()`, and `makeSnakesTalk()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing game difficulty settings and HUD controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a few things to take care of before our new version of MazeWorld is
    ready. First, we need to incorporate the difficulty level chosen by the player
    on the introduction screen, and we need to implement the functionality of the
    HUD we added to the game. These changes involve three classes: `MazeWorld`, `ScrollingEnemy`,
    and `Snake`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `MazeWorld` where the changes needed are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are going to implement the different difficulty levels by changing the number
    of enemies you have to avoid in the maze. First, we create the `playMode` instance
    variable to store the difficulty level. Next, we need to add another constructor
    that accepts an integer parameter. To do this, we need to change the old constructor
    that had no parameters to have one and add one line of code that sets the `playMode`
    instance variable to that parameter—everything else remains the same. We can then
    add a new constructor that has no parameters and simply calls the other constructor
    method passing in a value of `0` (which corresponds to the easy mode). Finally,
    in the `prepare()` method, we add code at the end of the method to check whether
    to add more actors to the game depending on the value of `playMode`. If `playMode`
    is `1`, then we add an additional snake. If it is `2`, then we add an additional
    snake and mouse to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add the `stunAllEnemies()`, `slowAllEnemies()`, and `makeSnakesTalk()`
    methods to `MazeWorld`. Each method uses the Greenfoot `World` method `getObjects()`
    to get a list of all the objects of the supplied type. When `ScrollingEnemy.class`
    is supplied to `getObjects()`, we get a list of all current enemies. When `Snake.class`
    is passed as a parameter to the `getObjects()` method, we get a list of all the
    `Snake` objects currently in the scenario. We then loop through the list of objects
    and call `stun()`, `slow()`, and `talk()`, respectively, on the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Because all of the enemies inherit from `ScrollingEnemy`, we can implement both
    `stun()` and `slow()` in that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `ScrollingEnemy` with the required changes highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the `Snake` class, we add four instance variables. Two of
    the variables store information about how long the enemies are stunned (`stunTime`)
    and slowed (`slowTime`) and the other two variables track whether or not we are
    presently in a stunned (`stunned`) or slowed (`slowed`) state.
  prefs: []
  type: TYPE_NORMAL
- en: When a `ScrollingEnemy` object is stunned by the player, the `stun()` method
    is invoked on that object (as we saw in our discussion on `MazeWorld`). The `stun()`
    method will do nothing if the object is presently stunned. If not, the method
    will set `stunned` to `true` and set `stunTime` to `100`. These values are used
    in the `act()` method to implement stunning the object. The `slow()` method is
    nearly identical to the `stun()` method, except that `slowTime` is set to `400`.
    This equates to the slowing of an object lasting longer than a stun.
  prefs: []
  type: TYPE_NORMAL
- en: In `act()`, we check the values of the `stunned` Boolean variable and skip calling
    the `sense()`, `reaction()`, and `boundedMove()`methods if `stunned` is `true`.
    The `stunTime` variable serves as a delay variable (covered in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*). If we are not stunned, then the `act()`
    method proceeds to check the `slowed` variable. If not slowed, we proceed as normal.
    The `slowTime` variable serves as a delay variable; however, as it is counting
    down, it toggles the values of `slowed`. This toggling will constrain the `sense()`,
    `reaction()`, and `boundedMove()` methods to only be invoked on every other call
    of the `act()` method. This makes the enemies move at half speed when slowed.
  prefs: []
  type: TYPE_NORMAL
- en: Since snakes are the only ones that need to talk, we put the implementation
    of the `talk()` method directly into the `Snake` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `Snake` with the required changes highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Like the implementation of `stun()` and `slow()` in the `ScrollingEnemy` class,
    we need a delay variable (`talkTime`) and Boolean (`talking`) to implement the
    `talk()` method. In addition, we need a variable to store—`TextBox` (`sss`)—that
    will contain the `sssssss` text. The `talk()` method is structured in the same
    way as `stun()` and `slow()`. However, `talk()` must also create `TextBox` and
    add it to the world.
  prefs: []
  type: TYPE_NORMAL
- en: We can see in `reaction()` that if the `Snake` object is in a talking state
    then the `sss TextBox` will be displayed offset from the location of the object
    for a time specified by the `talkTime` instance variable. Once `talkTime` expires,
    it must also remove the `sss TextBox` variable from the world.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have finished our new version of MazeWorld. Compile it
    and try it out. Click the stun, slow, and talk actions in the game. If you have
    any issues or errors in your game and are having a tough time solving them, compare
    your version to the completed version at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MazeWorld scenario was constructed solely to help demonstrate the concepts
    covered in [Chapter 7](part0047.xhtml "Chapter 7. Artificial Intelligence"), *Artificial
    Intelligence*, and the current chapter. Therefore, it is not actually great fun
    to play, but it does have a lot of potential. Using the game design knowledge
    you acquired in [Chapter 5](part0034.xhtml "Chapter 5. Interactive Application
    Design and Theory"), *Interactive Application Design and Theory*, try making changes
    to MazeWorld that will enhance its playability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now officially a Greenfoot programming ninja. You know how to create
    Greenfoot games and simulations that contain lively and intelligent actors with
    various methods that allow user/player interaction. You can implement keyboard/mouse
    controls, buttons, menus, and customized interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to add a gamepad controller support to our
    Greenfoot scenarios. Gamepads are a great way to capture user inputs, especially
    for games.
  prefs: []
  type: TYPE_NORMAL
