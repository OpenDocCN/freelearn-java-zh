<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Spring Boot</h1>
                </header>
            
            <article>
                
<p>Spring Boot has a lot of starters that are already a part of the Spring Boot family. This chapter will provide you with an overview of <a href="http://start.spring.io"><span class="URLPACKT">http://start.spring.io/</span></a>, available starter modules, and will also show you how to make a project Bootiful, as Josh Long likes to call it.</p>
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>Using a Spring Boot template and starter</li>
<li>Creating a simple application</li>
<li>Launching an application using Gradle</li>
<li>Using the command-line runners</li>
<li>Setting up a database connection</li>
<li>Setting up a data repository service</li>
<li>Scheduling executors</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In the fast-paced world of today's software development, the speed of application creation and the need for rapid prototyping are becoming more and more important. If you are developing a software using a JVM language, Spring Boot is exactly the kind of framework that will give you the power combined with the flexibility that will enable you to produce high-quality software at a rapid pace. So, let's take a look at how Spring Boot can help you to make your application Bootiful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a Spring Boot template and starter</h1>
                </header>
            
            <article>
                
<p>Spring Boot comes with over 40 different starter modules, which provide ready-to-use integration libraries for many different frameworks, such as database connections that are both relational and NoSQL, web services, social network integration, monitoring libraries, logging, template rendering, and the list just keeps going on. While it is not practically feasible to cover every single one of these components, we will go over the important and popular ones to get an idea of the possibilities and the ease of application development that Spring Boot provides us with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will start by creating a basic simple project skeleton, and Spring Boot will help us achieve this:</p>
<ol>
<li>Head over to <a href="http://start.spring.io/"><span class="URLPACKT">http://start.spring.io</span></a></li>
<li>Fill out a simple form with the details about our project</li>
<li>Click on <span class="packt_screen">Generate Project alt +</span> a premade project skeleton will download; this is where we begin</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You will see the <span class="packt_screen">Project Dependencies</span> section, where we can choose the kind of functionalities that our application will perform: Will it connect to a database? Will it have a web interface? Do we plan to integrate with any of the social networks bake in operational support? and so on. By selecting the desired technologies, the appropriate starter libraries will be added automatically to the dependency list of our pregenerated project template.</p>
<p>Before we proceed with the generation of our project, let's go over what exactly a Spring Boot starter is and the benefits it provides us with.</p>
<p>Spring Boot aims to make it easy to get started with creating an application. Spring Boot starters are bootstrap libraries that contain a collection of all the relevant transitive dependencies that are needed to start a particular functionality. Each starter has a special file, which contains the list of all the provided dependencies Spring provides. Let's take a look at the following link for a <kbd>spring-boot-starter-test</kbd> definition as an example:</p>
<p><a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/src/main/resources/META-INF/spring.provides">https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/src/main/resources/META-INF/spring.provides</a><a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/src/main/resources/META-INF/spring.provides"/></p>
<p>Here we will see the following code:</p>
<pre>provides: spring-test, spring-boot, junit, mockito, hamcrest-library, jsonassert, json-path </pre>
<p>This tells us that by including <kbd>spring-boot-starter-test</kbd> in our build as a dependency, we will automatically get <kbd>spring-test</kbd>, <kbd>spring-boot</kbd>, <kbd>junit</kbd>, <kbd>mockito</kbd>, <kbd>hamcrest-library</kbd>,<kbd>jsonassert</kbd>, and <kbd>json-path</kbd>. These libraries will provide us with all the necessary things in order to start writing application tests for the software that we will develop, without needing to manually add these dependencies to the build file individually.</p>
<p>With more than 100 starters provided, and with the ongoing community additions increasing the list, it is very likely that unless, we find ourselves with the need to integrate with a fairly common or popular framework, there is already a starter out there that we can use.</p>
<p>The following table shows you the most notable ones so as to give you an idea of what is available:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Starter</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter</kbd></p>
</td>
<td>
<p>This is the core Spring Boot starter that provides you with all the foundational functionalities. It is depended upon by all other starters, so no need to declare it explicitly.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter-actuator</kbd></p>
</td>
<td>
<p>This starter provides you with a functionality to monitor, manage an application, and audit.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter-jdbc</kbd></p>
</td>
<td>
<p>This starter provides you with a support to connect and use JDBC databases, connection pools, and so on.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter-data-jpa</kbd></p>
<p><kbd>spring-boot-starter-data-*</kbd></p>
</td>
<td>
<p>The JPA starter provides you with needed libraries so you can use <strong>Java Persistence API</strong> (<strong>JPA</strong>): Hibernate, and others.</p>
<p>Various <kbd>data-* family</kbd> starters provide support for a number of datastores, such as MongoDB, Data REST, or Solr.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter-security</kbd></p>
</td>
<td>
<p>This brings in all the needed dependencies for Spring Security.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter-social-*</kbd></p>
</td>
<td>
<p>This allows you to integrate with Facebook, Twitter, and LinkedIn.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter-test</kbd></p>
</td>
<td>
<p>This is a starter that contains the dependencies for <kbd>spring-test</kbd> and assorted testing frameworks: JUnit and Mockito, among others.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-boot-starter-web</kbd></p>
</td>
<td>
<p>This gives you all the needed dependencies for web application development. It can be enhanced with <kbd>spring-boot-starter-hateoas</kbd>, <kbd>spring-boot-starter-websocket</kbd>, <kbd>spring-boot-starter-mobile</kbd>, or <kbd>spring-boot-starter-ws</kbd>, and assorted template-rendering starters: <kbd>sping-boot-starter-thymeleaf</kbd> or <kbd>spring-boot-starter-mustache</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spring-cloud-starter-*</kbd></p>
</td>
<td>
<p>Various <kbd>cloud-*</kbd> family starters providing support for a number of frameworks, such as Netflix OSS, Consul, or AWS.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a simple application</h1>
                </header>
            
            <article>
                
<p>Now that we have a basic idea of the starters that are available to us, let's go ahead and create our application template at <a href="http://start.spring.io/"><span class="URLPACKT">http://start.spring.io</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The application that we are going to create is a book catalog management system. It will keep a record of books that were published, who the authors were, the reviewers, publishing houses, and so forth. We will name our project <kbd>BookPub</kbd>, and apply the following steps:</p>
<ol>
<li>First let's switch to the full version by clicking the link below the <span class="packt_screen">Generate Project alt +</span> button</li>
<li>Choose <span class="packt_screen">Gradle Project</span> at the top</li>
<li>Use <span class="packt_screen">Spring Boot</span> version <span class="packt_screen">2.0.0(SNAPSHOT)</span></li>
<li>Use the default proposed <span class="packt_screen">Group</span> name: <kbd>com.example</kbd></li>
<li>Enter <kbd>bookpub</kbd> for an <span class="packt_screen">Artifact</span> field</li>
<li>Provide <kbd>BookPub</kbd> as a <span class="packt_screen">Name</span> for the application</li>
<li>Specify <kbd>com.example.bookpub</kbd> as our <span class="packt_screen">Package Name</span></li>
<li>Select <span class="packt_screen">Jar</span> as <span class="packt_screen">Packaging</span></li>
<li>Use <span class="packt_screen">Java Version</span> as <span class="packt_screen">8</span></li>
<li>Select the <span class="packt_screen">H2</span>, <span class="packt_screen">JDBC</span>, and <span class="packt_screen">JPA</span> starters from the <span><span class="packt_screen">Search for dependencies</span></span> selection so that we can get the needed artifacts in our <kbd>build</kbd> file to connect to an H2 database</li>
<li>Click on <span class="packt_screen">Generate Project alt +</span> to download the project archive</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Clicking on the <span class="packt_screen">Generate Project alt +</span> button will download the <kbd>bookpub.zip</kbd> archive, which we will extract from our working directory. In the newly created <kbd>bookpub</kbd> directory, we will see a <kbd>build.gradle</kbd> file that defines our build. It already comes preconfigured with the right version of a Spring Boot plugin and libraries, and even includes the extra starters, which we have chosen. The following is the code of the <kbd>build.gradle</kbd> file:</p>
<pre>dependencies { 
  compile("org.springframework.boot:spring-boot-starter-data-jpa") 
  compile("org.springframework.boot:spring-boot-starter-jdbc") 
  runtime("com.h2database:h2") 
  testCompile("org.springframework.boot:spring-boot-starter-test")  
} </pre>
<p>We have selected the following starters:</p>
<ul>
<li><kbd>org.springframework.boot:spring-boot-starter-data-jpa</kbd>: This starter pulls in the JPA dependency.</li>
<li><kbd>org.springframework.boot:spring-boot-starter-jdbc</kbd>: This starter pulls in the JDBC supporting libraries.</li>
<li><kbd>com.h2database</kbd>: H2 is a particular type of database implementation, namely H2.</li>
<li><kbd>org.springframework.boot:spring-boot-starter-test</kbd>: This starter pulls all the necessary dependencies for running tests. It is only being used during the test phase of the build, and it is not included during the regular application compile time and runtime. </li>
</ul>
<p>As you can see, the <kbd>runtime("com.h2database:h2")</kbd> dependency is a runtime one. This is because we don't really need, and probably don't even want to know, the exact type of database to which we will connect at the compile time. Spring Boot will autoconfigure the needed settings and create appropriate beans once it detects the presence of the <kbd>org.h2.Driver</kbd> class in the classpath when the application is launched. We will look into the inner workings of how and where this happens later in this chapter.</p>
<p>The <kbd>data-jpa</kbd> and <kbd>jdbc</kbd> are Spring Boot starter artifacts. If we look in these dependency JARs once they are downloaded, or using Maven Central, we will find that they don't contain any actual classes, only the various metadata. The two containing files that are of interest are <kbd>pom.xml</kbd> and <kbd>spring.provides</kbd>. Let's first look at the <kbd>spring.provides</kbd> file in the <kbd>spring-boot-starter-jdbc</kbd> JAR artifact, as follows:</p>
<pre>provides: spring-jdbc,spring-tx,tomcat-jdbc </pre>
<p>This tells us that, by having this starter as our dependency, we will transitively get the <kbd>spring-jdbc</kbd>, <kbd>spring-tx</kbd>, and <kbd>tomcat-jdbc</kbd> dependency libraries in our build. The <kbd>pom.xml</kbd> file contains the proper dependency declarations that will be used by Gradle or Maven to resolve the needed dependencies during the build time. This also applies to our second starter: <kbd>spring-boot-starter-data-jpa</kbd>. This starter will transitively provide us with the <kbd>spring-orm</kbd>, <kbd>hibernate-entity-manager</kbd>, and the <kbd>spring-data-jpa</kbd> libraries.</p>
<p>At this point, we have enough libraries/classes in our application classpath so as to give Spring Boot an idea of what kind of application we are trying to run and what type of facilities and frameworks need to be configured automatically by Spring Boot to stitch things together.</p>
<p>Earlier, we mentioned that the presence of the <kbd>org.h2.Driver</kbd> class in the classpath will trigger Spring Boot to automatically configure the H2 database connection for our application. To see exactly how this will happen, let's start by looking at our newly created application template, specifically at <kbd>BookPubApplication.java</kbd>, which is located in the <kbd>src/main/java/com/example/bookpub</kbd> directory in the root of the project. We do this as follows:</p>
<pre>    package com.example.bookpub; 
 
    import org.springframework.boot.SpringApplication; 
    import org.springframework.boot.autoconfigure.<br/>    SpringBootApplication; 
 
    @SpringBootApplication 
    public class BookPubApplication { 
 
      public static void main(String[] args) { 
        SpringApplication.run(BookPubApplication.class, args); 
      } 
    } </pre>
<p>This is effectively our entire and fully runnable application. There's not a whole lot of code here and definitely no mention of configuration or databases anywhere. The key to making magic is the <kbd>@SpringBootApplication</kbd> meta-annotation. In this, we will find the real annotations that will direct Spring Boot to set things up automatically:</p>
<pre>    @SpringBootConfiguration 
    @EnableAutoConfiguration 
    @ComponentScan (excludeFilters = @Filter(type =  <br/>                                     FilterType.CUSTOM,  
                    classes = TypeExcludeFilter.class)) 
    public @interface SpringBootApplication {...} </pre>
<p>Let's go through the following list of annotations mentioned in the preceding code snippet:</p>
<ul>
<li><kbd>@SpringBootConfiguration</kbd>: This annotation is in itself a meta-annotation; it tells Spring Boot that the annotated class contains Spring Boot configuration definitions, such as the <kbd>@Bean</kbd>, <kbd>@Component</kbd>, and <kbd>@Service</kbd> declarations, and so on. Inside, it uses the <kbd>@Configuration</kbd> annotation, which is a Spring annotation, and not just Spring Boot, as it is a Spring Framework core annotation, used to mark classes containing Spring configuration definitions.</li>
</ul>
<div class="mce-root packt_infobox">It is important to note that using <kbd>@SpringBootConfiguration</kbd> over <kbd>@Configuration</kbd> is helpful when executing tests with Spring Boot Test framework, as this configuration will automatically be loaded by the Test framework when the test is annotated with <kbd>@SpringBootTest</kbd>. As it is noted in the Javadoc, an application should only ever include one <kbd>@SpringApplicationConfiguration</kbd>, and most idiomatic Spring Boot applications will inherit it from <kbd>@SpringBootApplication</kbd>.</div>
<ul>
<li><kbd>@ComponentScan</kbd>: This annotation tells Spring that we want to scan our application packages starting from the package of our annotated class as a default package root for the other classes that may be annotated with <kbd>@Configuration</kbd>, <kbd>@Controller</kbd>, and other applicable annotations, which Spring will automatically include as part of the context configuration. The applied <kbd>TypeExcludeFilter</kbd> class provides filtering out for various classes to be excluded from <kbd>ApplicationContext</kbd>. It is mostly used by <kbd>spring-boot-test</kbd> to exclude classes that should be used only during tests; however, it is possible to add your own beans that extend from <kbd>TypeExcludeFilter</kbd> and provide filtering for other types that are deemed necessary.</li>
<li><kbd>@EnableAutoConfiguration</kbd>: This annotation is a part of the Spring Boot annotation, which is a meta-annotation on its own (you will find that Spring libraries rely very heavily on the meta-annotations so they can group and compose configurations together). It imports the <kbd>EnableAutoConfigurationImportSelector</kbd> and <kbd>AutoConfigurationPackages.Registrar</kbd> classes that effectively instruct Spring to automatically configure the conditional beans depending on the classes available in the classpath. (We will cover the inner workings of autoconfiguration in detail in <a href="6139967b-794e-479a-8461-d3197eb0322e.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Writing Custom Spring Boot Starters.</em>)</li>
</ul>
<p>The <kbd>SpringApplication.run(BookPubApplication.class, args);</kbd> code line in the main method basically creates a Spring application context that reads the annotations in <kbd>BookPubApplication.class</kbd> and instantiates a context, which is similar to how it would have been done had we not used Spring Boot and stuck with just a regular Spring Framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching an application using Gradle</h1>
                </header>
            
            <article>
                
<p>Typically, the very first step of creating any application is to have a basic startable skeleton. As the Spring Boot starter has created the application template for us already, all we have to do is extract the code, build, and execute it. Now let's go to the console and launch the application with Gradle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Change the location of our directory to where the <kbd>bookpub.zip</kbd> archive was extracted from and execute the following command from the command line:</p>
<pre>      <strong>$ ./gradlew clean bootRun</strong>
  </pre>
<div class="packt_tip">If you don't have <kbd>gradlew</kbd> in the directory, then download a version of Gradle from <a href="https://gradle.org/install/"><span class="URLPACKT">https://gradle.org/downloads</span></a> or install it via Homebrew by executing <kbd>brew install gradle</kbd>. After Gradle is installed, run <kbd>wrapper</kbd> in the <kbd>gradle</kbd> folder to get the Gradle <kbd>wrapper</kbd> files generated. Another way is to invoke <kbd>$gradleclean bootRun</kbd>.</div>
<p>The output of the preceding command will be as follows:</p>
<pre>    <strong>...</strong>
    <strong>  .   ____          _            __ _ _</strong>
    <strong> /\ / ___'_ __ _ _(_)_ __  __ _    </strong>
    <strong>( ( )___ | '_ | '_| | '_ / _` |    </strong>
    <strong> \/  ___)| |_)| | | | | || (_| |  ) ) ) )</strong>
    <strong>  '  |____| .__|_| |_|_| |___, | / / / /</strong>
    <strong> =========|_|==============|___/=/_/_/_/</strong>
    <strong> :: Spring Boot ::  (v2.0.0.BUILD-SNAPSHOT)</strong>
    
    <strong>2017-12-16 23:18:53.721 : Starting BookPubApplication on mbp with  <br/>    PID 43850 </strong>
    <strong>2017-12-16 23:18:53.781 : Refreshing org.springframework.context.<br/>    annotation.Annotatio</strong>
    <strong>2017-12-16 23:18:55.544 : Building JPA container <br/>    EntityManagerFactory for persistence </strong>
    <strong>2017-12-16 23:18:55.565 : HHH000204: Processing <br/>    PersistenceUnitInfo [name: default  </strong>
    <strong>2017-12-16 23:18:55.624 : HHH000412: Hibernate Core  <br/>    {5.2.12.Final}</strong>
    <strong>2017-12-16 23:18:55.625 : HHH000206: hibernate.properties not <br/>    found</strong>
    <strong>2017-12-16 23:18:55.627 : HHH000021: Bytecode provider name : <br/>    javassist</strong>
    <strong>2017-12-16 23:18:55.774 : HCANN000001: Hibernate Commons <br/>    Annotations {5.0.1.Final</strong>
    <strong>2017-12-16 23:18:55.850 : HHH000400: Using dialect: <br/>    org.hibernate.dialect.H2Dialect</strong>
    <strong>2017-12-16 23:18:55.902 : HHH000397: Using <br/>    ASTQueryTranslatorFactory</strong>
    <strong>2017-12-16 23:18:56.094 : HHH000227: Running hbm2ddl schema <br/>    export</strong>
    <strong>2017-12-16 23:18:56.096 : HHH000230: Schema export complete</strong>
    <strong>2017-12-16 23:18:56.337 : Registering beans for JMX exposure on <br/>    startup</strong>
    <strong>2017-12-16 23:18:56.345 : Started BookPubApplication in 3.024 <br/>    seconds (JVM running...</strong>
    <strong>2017-12-16 23:18:56.346 : Closing <br/>    org.springframework.context.annotation.AnnotationC..</strong>
    <strong>2017-12-16 23:18:56.347 : Unregistering JMX-exposed beans on <br/>    shutdown</strong>
    <strong>2017-12-16 23:18:56.349 : Closing JPA EntityManagerFactory for <br/>    persistence unit 'def...</strong>
    <strong>2017-12-16 23:18:56.349 : HHH000227: Running hbm2ddl schema <br/>    export</strong>
    <strong>2017-12-16 23:18:56.350 : HHH000230: Schema export complete</strong>
    <strong>BUILD SUCCESSFUL</strong>
    <strong>Total time: 52.323 secs</strong>
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As we can see, the application started just fine, but as we didn't add any functionality or configure any services, it existed straight away. From the startup log, however, we do see that the autoconfiguration did take place. Let's take a look at the following lines:</p>
<pre>    <strong>Building JPA container EntityManagerFactory for persistence unit <br/>    'default'</strong>
    <strong>HHH000412: Hibernate Core {5.2.12.Final}</strong>
    <strong>HHH000400: Using dialect: org.hibernate.dialect.H2Dialect</strong>
  </pre>
<p>This information tells us that, because we added the <kbd>jdbc</kbd> and <kbd>data-jpa</kbd> starters, the JPA container was created and will use Hibernate 5.2.12.Final to manage the persistence using H2Dialect. This was possible because we had the right classes in the classpath.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the command-line runners</h1>
                </header>
            
            <article>
                
<p>With our basic application skeleton ready, let's add some meat to the bones by making our application do something.</p>
<p>Let's start by first creating a class named <kbd>StartupRunner</kbd>. This will implement the <kbd>CommandLineRunner</kbd> interface, which basically provides just one method: <kbd>public void run(String... args)</kbd> --that will get called by Spring Boot only once after the application has started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the file named <kbd>StartupRunner.java</kbd> under the <kbd>src/main/java/com/example/bookpub/</kbd> directory from the root of our project with the following content:</li>
</ol>
<pre>        package com.example.bookpub; <br/><br/>        import com.example.bookpub.repository.BookRepository;
        import org.apache.commons.logging.Log; 
        import org.apache.commons.logging.LogFactory; <br/>        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.boot.CommandLineRunner; <br/>        import org.springframework.scheduling.annotation.Scheduled;<br/><br/>        public class StartupRunner implements CommandLineRunner { 
            protected final Log logger = LogFactory.getLog(getClass()); 
            @Override 
            public void run(String... args) throws Exception { 
                logger.info("Hello"); 
            } <br/>        }</pre>
<ol start="2">
<li>After we have defined the class, let's proceed by defining it as <kbd>@Bean</kbd> in the <kbd>BookPubApplication.java</kbd> application configuration, which is located in the same folder as our newly created <kbd>StartupRunner.java</kbd> file as follows:</li>
</ol>
<pre style="padding-left: 60px">@Bean 
public StartupRunner schedulerRunner() { 
    return new StartupRunner(); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If we run our application again, by executing <kbd>$ ./gradlew clean bootRun</kbd>, we will get an output that is similar to the previous one. However, we will see our <kbd>Hello</kbd> message in the logs as well, which is as follows:</p>
<pre><strong>2017-12-16 21:57:51.048  INFO --- <br/>com.example.bookpub.StartupRunner         : Hello</strong>
  </pre>
<p>Even though the program will get terminated on execution, at least we made it do something!</p>
<p>Command-line runners are a useful functionality to execute the various types of code that only have to be run once, after startup. Some also use this as a place to start various executor threads, but Spring Boot provides a better solution for this task, which will be discussed at the end of this chapter. The command-line runner interface is used by Spring Boot to scan all of its implementations and invoke each instance's <kbd>run</kbd> method with the startup arguments. We can also use an <kbd>@Order</kbd> annotation or implement an <kbd>Ordered</kbd> interface so as to define the exact order in which we want Spring Boot to execute them. For example, <strong>Spring Batch</strong> relies on the runners to trigger the execution of the jobs.</p>
<p>As the command-line runners are instantiated and executed after the application has started, we can use the dependency injection to our advantage to wire in whatever dependencies we need, such as datasources, services, and other components. These can be utilized later while implementing <kbd>run</kbd>.</p>
<div class="packt_infobox">It is important to note that if any exception is thrown in the <kbd>run(String... args)</kbd> method, this will cause the context to close and an application to shut down. Wrapping the risky code blocks with <kbd>try/catch</kbd> is recommended to prevent this from happening.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a database connection</h1>
                </header>
            
            <article>
                
<p>In every application, there is a need to access some data and conduct some operations on it. Most frequently, this source of data is a datastore of some kind, namely a database. Spring Boot makes it very easy to get started in order to connect to the database and start consuming the data via the JPA, among others.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In our previous example, we created the basic application that will execute a command-line runner by printing a message in the logs. Let's enhance this application by adding a connection to a database.</p>
<p>Earlier, we already added the necessary <kbd>jdbc</kbd> and <kbd>data-jpa</kbd> starters as well as an H2 database dependency to our <kbd>build</kbd> file. Now we will configure an in-memory instance of the H2 database.</p>
<div class="packt_tip">In the case of an embedded database, such as H2, <strong>Hyper SQL Database</strong> (<strong>HSQLDB</strong>), or Derby, no actual configuration is required besides including the dependency on one of these in the <kbd>build</kbd> file. When one of these databases is detected in the classpath and a <kbd>DataSource</kbd> bean dependency is declared in the code, Spring Boot will automatically create one for you.</div>
<p>To demonstrate the fact that just by including the H2 dependency in the classpath, we will automatically get a default database, let's modify our <kbd>StartupRunner.java</kbd> file to look as follows:</p>
<pre style="padding-left: 30px">public class StartupRunner implements CommandLineRunner { 
    protected final Log logger = LogFactory.getLog(getClass()); 
    @Autowired 
    private DataSource ds; 
    @Override 
    public void run(String... args) throws Exception { 
        logger.info("DataSource: "+ds.toString()); 
    } 
} </pre>
<p>Now, if we proceed with the running of our application, we will see the name of the datasource printed in the log, as follows:</p>
<pre><strong>2017-12-16 21:46:22.067 com.example.bookpub.StartupRunner   <br/>:DataSource: org.apache.tomcat.jdbc.pool.DataSource@4...  {...driverClassName=org.h2.Driver; ... }</strong>
  </pre>
<p>So, under the hood, Spring Boot recognized that we've autowired a <kbd>DataSource</kbd> bean dependency and automatically created one initializing the in-memory H2 datastore. This is all well and good, but probably not all too useful beyond an early prototyping phase or for the purpose of testing. Who would want a database that goes away with all the data as soon as your application shuts down and you have to start with a clean slate every time you restart the application?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's change the defaults in order to create an embedded H2 database that will not store data in-memory, but rather use a file to persist the data among application restarts, by performing the following steps:</p>
<ol>
<li>Open the file named <kbd>application.properties</kbd> under the <kbd>src/main/resources</kbd> directory from the root of our project and add the following content:</li>
</ol>
<pre style="padding-left: 90px">spring.datasource.url = jdbc:h2:~/test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE 
spring.datasource.username = sa 
spring.datasource.password = </pre>
<ol start="2">
<li>Start the application by executing <kbd>./gradlew clean bootRun</kbd> from the command line</li>
<li>Check your home directory, and you should see the following file in there: <kbd>test.mv.db</kbd></li>
</ol>
<div class="mce-root packt_infobox">The user home directory is located under <kbd>/home/&lt;username&gt;</kbd> on Linux and under <kbd>/Users/&lt;username&gt;</kbd> on macOS X.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Even though, by default, Spring Boot makes certain assumptions about the database configuration by examining the classpath for the presence of supported database drivers, it provides you with easy configuration options to tweak the database access via a set of exposed properties grouped under <kbd>spring.datasource</kbd>.</p>
<p>The things that we can configure are <kbd>url</kbd>, <kbd>username</kbd>, <kbd>password</kbd>, <kbd>driver-class-name</kbd>, and so on. If you want to consume the datasource from a JNDI location, where an outside container creates it, you can configure this using the <kbd>spring.datasource.jndi-name</kbd> property. The complete set of possible properties is fairly large, so we will not go into all of them. However, we will cover more options in <a href="1136c424-e79e-467a-8f7f-8af2099306d7.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Application Testing</em>, where we will talk about mocking data for application tests using a database.</p>
<div class="packt_infobox">By looking at various blogs and examples, you may notice that some places use dashes in property names like <kbd>driver-class-name</kbd>, while others use camel-cased variants: <kbd>driverClassName</kbd>. In Spring Boot, these are actually two equally supported ways of naming the same property, and they get translated into the same thing internally.</div>
<p>If you want to connect to a regular (non-embedded) database, besides just having the appropriate driver library in the classpath, we need to specify the driver of our choice in the configuration. The following code snippet is what the configuration to connect to MySQL would resemble:</p>
<pre>    <strong>spring.datasource.driver-class-name: com.mysql.jdbc.Driver</strong>
    <strong>spring.datasource.url:   <br/>    jdbc:mysql://localhost:3306/springbootcookbook</strong>
    <strong>spring.datasource.username: root</strong>
    <strong>spring.datasource.password:</strong>
  </pre>
<p>If we wanted Hibernate to create the schema automatically, based on our entity classes, we would need to add the following line to the configuration:</p>
<pre>    <strong>spring.jpa.hibernate.ddl-auto=create-drop</strong>
  </pre>
<div class="packt_infobox">Don't do it in the production environment, otherwise, on startup, all the table schemas and data will be deleted! Use the update or validate values instead, where needed.</div>
<p>You can go even further in the abstraction layer and, instead of autowiring a <kbd>DataSource</kbd> object, you could go straight for  <kbd>JdbcTemplate</kbd>. This would instruct Spring Boot to automatically create a DataSource and then create a <kbd>JdbcTemplate</kbd> wrapping the datasource, thus providing you with a more convenient way of interacting with a database in a safe way. The code for <kbd>JdbcTemplate</kbd> is as follows:</p>
<pre style="padding-left: 30px">@Autowired 
private JdbcTemplate jdbcTemplate; </pre>
<p>You can also look in the <kbd>spring-boot-autoconfigure</kbd> source at an <kbd>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</kbd> file to see the code behind the datasource creation magic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a data repository service</h1>
                </header>
            
            <article>
                
<p>Connecting to a database and then executing good old SQL, though simplistic and straightforward, is not the most convenient way to operate on the data, map it in a set of domain objects, and manipulate the relational content. This is why multiple frameworks emerged to aid you with mapping the data from tables to objects, better known as <strong>object-relational mapping</strong> (<strong>ORM</strong>). The most notable example of such a framework is Hibernate.</p>
<p>In the previous example, we covered how to set up a connection to a database and configure the settings for the username and password, and we also discussed which driver to use, and so on. In this recipe, we will enhance our application by adding a few entity objects that define the structure of the data in the database and a <kbd>CrudRepository</kbd> interface to access the data.</p>
<p>As our application is a book-tracking catalogue, the obvious domain objects would be <kbd>Book</kbd>, <kbd>Author</kbd>, <kbd>Reviewers</kbd>, and <kbd>Publisher</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new package folder named <kbd>entity</kbd> under the <kbd>src/main/java/com/example/bookpub</kbd> directory from the root of our project.</li>
<li>In this newly created package, create a new class named <kbd>Book</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 90px">@Entity 
public class Book { 
  @Id 
  @GeneratedValue 
  private Long id; 
  private String isbn; 
  private String title; 
  private String description; 
 
  @ManyToOne 
  private Author author; 
  @ManyToOne 
  private Publisher publisher; 
 
  @ManyToMany 
  private List&lt;Reviewers&gt; reviewers; 
 
  protected Book() {} 
 
  public Book(String isbn, String title, Author author, <br/>       Publisher publisher) { 
    this.isbn = isbn; 
    this.title = title; 
    this.author = author; 
    this.publisher = publisher; 
  } 
  //Skipping getters and setters to save space, but we do need them 
} </pre>
<ol start="3">
<li>As any book should have an author and a publisher, and ideally some reviewers, we need to create these entity objects as well. Let's start by creating an <kbd>Author</kbd> entity class, under the same directory as our <kbd>Book</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 90px">@Entity 
public class Author { 
  @Id 
  @GeneratedValue 
  private Long id; 
  private String firstName; 
  private String lastName; 
  @OneToMany(mappedBy = "author") 
  private List&lt;Book&gt; books; 
 
  protected Author() {} 
 
  public Author(String firstName, String lastName) {...} 
    //Skipping implementation to save space, but we do need <br/>       it all 
} </pre>
<ol start="4">
<li>Similarly, we will create the <kbd>Publisher</kbd> and <kbd>Reviewer</kbd> classes, as shown in the following code:</li>
</ol>
<pre style="padding-left: 90px">@Entity 
public class Publisher { 
  @Id 
  @GeneratedValue 
  private Long id; 
  private String name; 
  @OneToMany(mappedBy = "publisher") 
  private List&lt;Book&gt; books; 
 
  protected Publisher() {} 
 
  public Publisher(String name) {...} 
} 
 
@Entity 
public class Reviewer { 
  @Id 
  @GeneratedValue 
  private Long id; 
  private String firstName; 
  private String lastName; 
 
  protected Reviewer() {} 
 
  public Reviewer(String firstName, String lastName) <br/>     {...}<br/>} </pre>
<ol start="5">
<li>Now we will create our <kbd>BookRepository</kbd> interface by extending Spring's <kbd>CrudRepository</kbd> interface under the <kbd>src/main/java/com/example/bookpub/repository</kbd> package, as follows:</li>
</ol>
<pre style="padding-left: 90px">@Repository 
public interface BookRepository <br/>       extends CrudRepository&lt;Book, Long&gt; { 
   public Book findBookByIsbn(String isbn); 
} </pre>
<ol start="6">
<li>Finally, let's modify our <kbd>StartupRunner</kbd> class in order to print the number of books in our collection, instead of some random datasource string, by autowiring a newly created <kbd>BookRepository</kbd> and printing the result of a <kbd>.count()</kbd> call to the log, as follows:</li>
</ol>
<pre style="padding-left: 90px">public class StartupRunner implements CommandLineRunner { 
  @Autowired private BookRepository bookRepository; 
 
  public void run(String... args) throws Exception { 
    logger.info("Number of books: " + <br/>       bookRepository.count()); 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you have probably noticed, we didn't write a single line of SQL, or even mention anything about database connections, building queries, or things like that. The only hint about the fact that we are dealing with the database-backed data in our code is the presence of class and field annotations: <kbd>@Entity</kbd>, <kbd>@Repository</kbd>, <kbd>@Id</kbd>, <kbd>@GeneratedValue</kbd>, and <kbd>@ManyToOne</kbd>, along with <kbd>@ManyToMany</kbd> and <kbd>@OneToMany</kbd>. These annotations, which are a part of the JPA, along with the extension of the <kbd>CrudRepository</kbd> interface, are our ways of communicating with Spring about the need to map our objects to the appropriate tables and fields in the database and provide us with the programmatic ability to interact with this data.</p>
<p>Let's go through the following annotations:</p>
<ul>
<li><kbd>@Entity</kbd> indicates that the annotated class should be mapped to a database table. The name of the table will be derived from the name of the class, but it can be configured, if needed. It is important to note that every entity class should have a default <kbd>protected</kbd> constructor, which is needed for automated instantiation and Hibernate interactions.</li>
<li><kbd>@Repository</kbd> indicates that the interface is intended to provide you with the access and manipulation of data for a database. It also serves as an indication to Spring during the component scan that this instance should be created as a bean that will be available for use and injection into other beans in the application.</li>
<li>The <kbd>CrudRepository</kbd> interface defines the basic common methods to read, create, update, and delete data from a data repository. The extra methods that we will define in our <kbd>BookRepository</kbd> extension, <kbd>public Book findBookByIsbn(String isbn)</kbd>, indicate that Spring JPA should map the call to this method to a SQL query selecting a book by its ISBN field. This is a convention-named mapping that translates the method name into a SQL query. It can be a very powerful ally, allowing you to build queries, such as <kbd>findByNameIgnoringCase(String name)</kbd> and others.</li>
<li>The <kbd>@Id</kbd> and <kbd>@GeneratedValue</kbd> annotations provide you with an indication that an annotated field should be mapped to a primary key column in the database and that the value for this field should be generated, instead of being explicitly entered.</li>
<li>The <kbd>@ManyToOne</kbd> and <kbd>@ManyToMany</kbd> annotations define the relational field associations that refer to the data stored in the other tables. In our case, multiple books belong to one author, and many reviewers review multiple books.</li>
</ul>
<ul>
<li class="packt_nosymbol">The <kbd>mappedBy</kbd> attribute in the <kbd>@OneToMay</kbd> annotation defines a reverse association mapping. It indicates to Hibernate that the mapping source of truth is defined in the <kbd>Book</kbd> class, in the <kbd>author</kbd> or <kbd>publisher</kbd> fields.</li>
</ul>
<div class="mce-root packt_infobox"><span>For more information about all the vast capabilities of Spring Data, visit</span> <a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/"><span>http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/</span></a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scheduling executors</h1>
                </header>
            
            <article>
                
<p>Earlier in this chapter, we discussed how the command-line runners can be used as a place to start the scheduled executor thread pools to run the worker threads in intervals. While that is certainly a possibility, Spring provides you with a more concise configuration to achieve the same goal: <kbd>@EnableScheduling</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will enhance our application so that it will print a count of books in our repository every 10 seconds. To achieve this, we will make the necessary modifications to the <kbd>BookPubApplication</kbd> and <kbd>StartupRunner</kbd> classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's add an <kbd>@EnableScheduling</kbd> annotation to the <kbd>BookPubApplication</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 90px">@SpringBootApplication 
@EnableScheduling 
public class BookPubApplication {...}</pre>
<ol start="2">
<li>As a <kbd>@Scheduled</kbd> annotation can be placed only on methods without arguments, let's add a new <kbd>run()</kbd> method to the <kbd>StartupRunner</kbd> class and annotate it with the <kbd>@Scheduled</kbd> annotation, as shown in the following line:</li>
</ol>
<pre style="padding-left: 90px">@Scheduled(initialDelay = 1000, fixedRate = 10000) 
public void run() { 
    logger.info("Number of books: " +  
        bookRepository.count()); 
} </pre>
<ol start="3">
<li>Start the application by executing <kbd>./gradlew clean bootRun</kbd> from the command line so as to observe the <kbd>Number of books: 0</kbd> message that shows in the logs every 10 seconds.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>@EnableScheduling</kbd>, as many other annotations that we have discussed and will discuss in this book, is not a Spring Boot; it is a Spring Context module annotation. Similar to the <kbd>@SpringBootApplication</kbd> and <kbd>@EnableAutoConfiguration</kbd> annotations, this is a meta-annotation and internally imports  <kbd>SchedulingConfiguration</kbd> via the <kbd>@Import(SchedulingConfiguration.class)</kbd> instruction, which can be found inside <kbd>ScheduledAnnotationBeanPostProcessor</kbd> that will be created by the imported configuration and will scan the declared Spring beans for the presence of the <kbd>@Scheduled</kbd> annotations. For every annotated method without arguments, the appropriate executor thread pool will be created. It will manage the scheduled invocation of the annotated method.</p>


            </article>

            
        </section>
    </body></html>