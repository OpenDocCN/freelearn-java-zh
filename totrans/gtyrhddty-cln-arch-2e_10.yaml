- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assembling the Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have implemented some use cases, web adapters, and persistence adapters,
    we need to assemble them into a working application. As discussed in [*Chapter
    4*](B19916_04.xhtml#_idTextAnchor037), *Organizing Code*, we rely on a **dependency
    injection** mechanism to instantiate our classes and wire them together at start-up
    time. In this chapter, we’ll discuss some approaches to doing this with plain
    Java and the Spring and Spring Boot frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Why even care about assembly?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why aren’t we just instantiating the use cases and adapters when and where
    we need them? Because we want to keep the code dependencies pointed in the right
    direction. Remember: all dependencies should point inward, toward the domain code
    of our application, so that the domain code doesn’t have to change when something
    in the outer layers changes.'
  prefs: []
  type: TYPE_NORMAL
- en: If a use case needs to call a persistence adapter and just instantiates it itself,
    we have created a code dependency in the wrong direction.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we created outgoing port interfaces. The use case only knows the
    interface and is provided an implementation of this interface at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: A nice side effect of this programming style is that the code we’re creating
    is much easier to test. If we can pass all objects a class needs into its constructor,
    we can choose to pass in mocks instead of the real objects, which makes it easy
    to create an isolated unit test for the class.
  prefs: []
  type: TYPE_NORMAL
- en: So, who’s responsible for creating our object instances? And how do we do it
    without violating the **Dependency Rule**?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that there must be a configuration component that is neutral to
    our architecture and that has a dependency to all classes in order to instantiate
    them, as shown in *Figure 10**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A neutral configuration component may access all classes in
    order to instantiate them](img/Figure_10.1_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A neutral configuration component may access all classes in order
    to instantiate them
  prefs: []
  type: TYPE_NORMAL
- en: In the *Clean Architecture* introduced in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029),
    *Inverting Dependencies*, this configuration component would be in the outermost
    circle, which may access all inner layers, as defined by the Dependency Rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration component is responsible for assembling a working application
    from the parts we provided. It must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create web adapter instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that HTTP requests are actually routed to the web adapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create use case instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide web adapters with use case instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create persistence adapter instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide use cases with persistence adapter instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the persistence adapters can actually access the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides that, the configuration component should be able to access certain sources
    of configuration parameters, such as configuration files or command-line parameters.
    During application assembly, the configuration component then passes these parameters
    on to the application components to control behavior such as which database to
    access or which server to use to send emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are a lot of responsibilities (read: reasons to change). Aren’t we violating
    the **Single Responsibility Principle** here? Yes, we are, but if we want to keep
    the rest of the application clean, we need an outside component that takes care
    of the wiring. And this component has to know all the moving parts to assemble
    them into a working application.'
  prefs: []
  type: TYPE_NORMAL
- en: Assembling via plain code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to implement a configuration component responsible for
    assembling the application. If we’re building an application without the support
    of a dependency injection framework, we can create such a component with plain
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-10.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code snippet is a simplified example of how such a configuration component
    might look. In Java, an application is started from the `main` method. Within
    this method, we instantiate all the classes we need, from the web controller to
    the persistence adapter, and wire them together.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the mystic method `startProcessingWebRequests()`, `w`hich exposes
    the web controller via HTTP.[1](#footnote-034) The application is then ready to
    process requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-034-backlink) The method `startProcessingWebRequests()`is just
    a placeholder for any bootstrapping logic that is necessary to expose our web
    adapters via HTTP. We don’t really want to implement this ourselves. In a real-world
    application, a framework does that for us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This plain code approach is the most basic way of assembling an application.
    It has some drawbacks, however:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the preceding code is for an application that has only a single
    web controller, use case, and persistence adapter. Imagine how much code like
    this we would have to produce to bootstrap a full-blown enterprise application!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, since we’re instantiating all classes ourselves from outside of their
    packages, those classes all need to be public. This means, for example, that the
    Java compiler doesn’t prevent a use case from directly accessing a persistence
    adapter since it’s public. It would be nice if we could avoid unwanted dependencies
    like this by using package-private visibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, there are dependency injection frameworks that can do the dirty work
    for us while still maintaining package-private dependencies. The Spring framework
    is currently the most popular one in the Java world. Spring also provides web
    and database support, among a lot of other things, so we don’t have to implement
    the mystic `startProcessingWebRequests()` method after all.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling via Spring’s classpath scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use the Spring framework to assemble our application, the result is called
    the **application context**. The application context contains all objects that
    together make up the application (**beans** in Java lingo).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring offers several approaches to assemble an application context, each having
    its own advantages and drawbacks. Let’s start by discussing the most popular (and
    most convenient) approach: **classpath scanning**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With classpath scanning, Spring goes through all classes that are available
    in a certain slice of the classpath and searches for classes that are annotated
    with the `@Component` annotation. The framework then creates an object from each
    of these classes. The classes should have a constructor that takes all required
    fields as an argument, like our `AccountPersistenceAdapter` from [*Chapter 7*](B19916_07.xhtml#_idTextAnchor062)*,
    Implementing a* *Persistence Adapter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-10.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we didn’t even write the constructor ourselves, but instead let
    the Lombok library do it for us using the `@RequiredArgsConstructor` annotation,
    which creates a constructor that takes all `final` fields as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Spring will find this constructor and search for `@Component`-annotated classes
    of the required argument types and instantiate them in a similar manner to add
    them to the application context. Once all required objects are available, it will
    finally call the constructor of `AccountPersistenceAdapter` and add the resulting
    object to the application context as well.
  prefs: []
  type: TYPE_NORMAL
- en: Classpath scanning is a very convenient way of assembling an application. We
    only have to sprinkle some `@Component` annotations across the code base and provide
    the right constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create our own stereotype annotation for Spring to pick up. We
    could, for example, create a `@``PersistenceAdapter` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-10.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This annotation is meta-annotated with `@Component` to let Spring know that
    it should be picked up during classpath scanning. We could now use `@PersistenceAdapter`
    instead of `@Component` to mark our persistence adapter classes as parts of our
    application. With this annotation, we have made our architecture more evident
    to people reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: The classpath scanning approach has its drawbacks, however. First, it’s invasive
    in that it requires us to add a framework-specific annotation to our classes.
    If you’re a Clean Architecture hardliner, you’d say that this is forbidden as
    it binds our code to a specific framework.
  prefs: []
  type: TYPE_NORMAL
- en: I’d say that in usual application development, a single annotation on a class
    is not such a big deal and can easily be refactored, if at all necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In other contexts, however, like when building a library or a framework for
    other developers to use, this might be a no-go since we don’t want to encumber
    our users with a dependency on the Spring framework.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential drawback of the classpath scanning approach is that magic
    things might happen. And by *magic*, I mean the bad kind of magic causing inexplicable
    effects that might take days to figure out if you’re not a Spring expert.
  prefs: []
  type: TYPE_NORMAL
- en: Magic happens because classpath scanning is a very blunt weapon to use for application
    assembly. We simply point Spring at the parent package of our application and
    tell it to go looking for `@Component`-annotated classes within this package.
  prefs: []
  type: TYPE_NORMAL
- en: Do you know every single class that exists within your application by heart?
    Probably not. There are bound to be some classes that we don’t actually want to
    have in the application context. Perhaps this class even manipulates the application
    context in evil ways, causing errors that are hard to track.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an alternative approach that gives us a little more control.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling via Spring’s Java Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While classpath scanning is the cudgel of application assembly, Spring’s Java
    Config is the scalpel.[2](#footnote-033) This approach is similar to the plain
    code approach introduced earlier in this chapter, but it’s less messy and provides
    us with a framework so that we don’t have to code everything by hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-033-backlink) Cudgel versus scalpel: if you don’t spend far too
    many hours of your life killing monsters in role-playing video games like me and
    don’t know what a cudgel is, a cudgel is a stick with a weighted end that can
    be used as a weapon. It’s a very blunt weapon that can do a lot of damage without
    having to aim particularly well.'
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, we create configuration classes, each responsible for constructing
    a set of beans that are to be added to the application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could create a configuration class that is responsible for
    instantiating all our persistence adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-10.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `@Configuration` annotation marks this class as a configuration class to
    be picked up by Spring’s classpath scanning. So, in this case, we’re still using
    classpath scanning, but we only pick up our configuration classes instead of every
    single bean, which reduces the chance of evil magic happening.
  prefs: []
  type: TYPE_NORMAL
- en: The beans themselves are created within the `@Bean`-annotated factory methods
    of our configuration classes. In the preceding case, we add a persistence adapter
    to the application context. It needs two repositories and a mapper as input to
    its constructor. Spring automatically provides these objects as input to the factory
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: But where does Spring get the repository objects from? If they are created manually
    in a factory method of another configuration class, then Spring will automatically
    provide them as parameters to the factory methods of the preceding code example.
    In this case, however, they are created by Spring itself, triggered by the `@EnableJpaRepositories`
    annotation. If Spring Boot finds this annotation, it will automatically provide
    implementations for all Spring Data repository interfaces we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with Spring Boot, you might know that we could have added
    the `@EnableJpa` **Repositories** annotation to the main application class instead
    of our custom configuration class. Yes, this is possible, but it will activate
    JPA repositories every time the application is started up, even if we start the
    application within a test that doesn’t actually need persistence. So, by moving
    such “feature annotations” into a separate configuration “module,” we’ve just
    become much more flexible and can start up parts of our application instead of
    always having to start the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: With the `PersistenceAdapterConfiguration` class, we have created a tightly
    scoped persistence module that instantiates all objects we need in our persistence
    layer. It will be automatically picked up by Spring’s classpath scanning while
    we still have full control over which beans are actually added to the application
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we could create configuration classes for web adapters, or for certain
    modules within our application layer. We can now create an application context
    that contains certain modules but mocks the beans of other modules, which gives
    us great flexibility in tests. We could even push the code of each of those modules
    into its own code base, package, or JAR file without much refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this approach does not force us to sprinkle `@Component` annotations all
    over our code base, like the classpath scanning approach does. So, we can keep
    our application layer clean without any dependency on the Spring framework (or
    any other framework, for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: There is a catch with this solution, however. If the configuration class is
    not within the same package as the classes of the beans it creates (the persistence
    adapter classes in this case), those classes must be public. To restrict visibility,
    we can use packages as module boundaries and create a dedicated configuration
    class within each package. This way, we cannot use sub-packages, though, as will
    be discussed in [*Chapter 12*](B19916_12.xhtml#_idTextAnchor105), *Enforcing*
    *Architecture Boundaries*.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring and Spring Boot (and similar frameworks) provide a lot of features that
    make our lives easier. One of the main features is assembling the application
    out of the parts (classes) that we, as application developers, provide.
  prefs: []
  type: TYPE_NORMAL
- en: Classpath scanning is a very convenient feature. We only have to point Spring
    to a package and it assembles an application from the classes it finds. This allows
    for rapid development, with us not having to think about the application as a
    whole.
  prefs: []
  type: TYPE_NORMAL
- en: Once the code base grows, however, this quickly leads to a lack of transparency.
    We don’t know which beans exactly are loaded into the application context. Also,
    we cannot easily start up isolated parts of the application context to use in
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'By creating a dedicated configuration component responsible for assembling
    our application, we can liberate our application code from this responsibility
    (read: “reason for change” – remember the “S” in “SOLID”?). We’re rewarded with
    highly cohesive modules that we can start up in isolation from each other and
    that we can easily move around within our code base. As usual, this comes at the
    price of spending some extra time to maintain this configuration component.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve talked a lot about different options of how to do things “the right way”
    in this and the previous chapters. However, sometimes “the right way” is not feasible.
    In the next chapter, we’ll talk about shortcuts, the price we pay for them, and
    when they’re worth taking.
  prefs: []
  type: TYPE_NORMAL
