- en: '*Chapter 12*: MicroProfile LRA and the Future of MicroProfile'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have reached the final chapter of this book. Congratulations on making it
    this far! In this final chapter, we will briefly discuss the newly released MicroProfile
    **Long-Running Action** (**LRA**) and then look at the future of MicroProfile.
  prefs: []
  type: TYPE_NORMAL
- en: While writing this book, MicroProfile LRA 1.0 was released to address the need
    for microservice transactions. A traditional **transaction**, as we all must know,
    is a movement of money, such as an online payment or a withdrawal of money from
    a bank. In a traditional application, you normally use technologies such as the
    **two-phase commit** or **eXtended Architecture** (**XA**) protocol to manage
    transactions. However, these technologies do not suit cloud-native application
    transactions. In this chapter, we will explore how MicroProfile addresses the
    need to manage cloud-native transactions. We also will have a look at the transaction
    architecture for cloud-native applications. After that, we will take you through
    the latest MicroProfile platform release. Finally, we will learn about the future
    roadmap of MicroProfile as well as its alignment with the Jakarta EE community.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native application transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the latest MicroProfile platform release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile's technical roadmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile and Jakarta EE alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to use MicroProfile LRA for cloud-native
    application transactions and describe the roadmap for MicroProfile, which will
    help you to architect applications for the future.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native application transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloud-native application transactions try to ensure data consistency and integrity,
    similar to a traditional transaction. Traditional transactions normally use the
    two-phase commit or XA protocol. The two-phase commit protocol ensures that transactional
    updates are committed in all databases or are fully rolled back in the case of
    a failure. It is widely supported by many databases. As its name implies, this
    protocol consists of two phases: the **voting** **phase** and the **commit phase**.
    In the voting phase, the transaction manager gets approval or rejection from the
    participating XA resources. In the commit phase, the transaction manager informs
    the participants about the result. If the result is positive, the entire transaction
    will be committed. Otherwise, it will be rolled back. This protocol is very reliable
    and guarantees data consistency. The drawback is that it locks resources and might
    lead to indefinite blocking. Therefore, it is not suitable for cloud-native applications,
    because they do not scale well and the latency of held locks is problematic. Consequently,
    the **saga pattern** was established for cloud-native application transactions
    to achieve eventual data consistency. The saga pattern commits local transactions
    and then either completes or compensates the transactions. MicroProfile LRA is
    a realization of the saga pattern. In the upcoming subsections, we will discuss
    more on LRA.'
  prefs: []
  type: TYPE_NORMAL
- en: Using MicroProfile LRA for cloud-native application transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MicroProfile LRA ([https://download.eclipse.org/microprofile/microprofile-lra-1.0](https://download.eclipse.org/microprofile/microprofile-lra-1.0))
    provides a solution for cloud-native application transactions. It introduces two
    main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LRA participants**: LRA participants are transaction participants, which
    are cloud-native applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LRA coordinator**: The LRA coordinator is a transaction coordinator that
    manages the LRA processing and LRA participants. The LRA coordinator manages all
    LRAs and invokes LRA methods based on the LRA status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following illustrates the relationships between LRA participants and the
    LRA coordinator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – LRA coordinator and participants'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – LRA coordinator and participants
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 12.1*, the LRA participants enlist with the LRA coordinator,
    which will then call back with the relevant JAX-RS methods based on the transaction
    status. We will now discuss LRA participants in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: LRA participants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LRA participants are JAX-RS methods that are involved in a transaction and
    are annotated with the following LRA annotations in the `org.eclipse.microprofile.lra.annotation`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@LRA`: A method with this annotation will be associated with an LRA. The `@LRA`
    annotation registers the method with the LRA coordinator. When using this annotation,
    the following `LRA.Type` is like the `TransactionAttributeType` enum in `LRA.Type`
    variants are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a) `REQUIRED`: With this type, the method invocation will run with a new LRA
    context if called outside an LRA context. Otherwise, it will run with the same
    context.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b) `REQUIRES_NEW`: With this type, the method invocation will always run with
    a new LRA context.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c) `MANDATORY`: With this type, the method invocation will run inside an LRA
    context. If it is called outside an LRA context, an error will be returned.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd) `SUPPORTS`: With this type, if the method is called outside an LRA context,
    it will be executed outside an LRA context. If it is called inside an LRA context,
    it will be executed inside an LRA context.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e) `NOT_SUPPORTED`: With this type, the method is always executed outside an
    LRA context.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'f) `NEVER`: With this type, if the method is called outside an LRA context,
    it will be executed outside an LRA context. If it is called inside an LRA context,
    the method execution will fail and the return code `412` will be returned.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'g) `NESTED`: With this type, when the method is called, a new LRA will be created,
    which can be either top-level or nested based on whether it is called inside an
    LRA context or not. If invoked outside a context, the new LRA will be top-level.
    Otherwise, the new LRA will be nested.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might be wondering how to determine whether a method is called inside an
    LRA context. If the `LRA_HTTP_CONTEXT_HEADER` header is present, it means the
    method is called inside an LRA context.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Complete`: A method with this annotation will be called when the LRA closes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Compensate`: A method with this annotation will be invoked if the LRA is
    canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Forget`: A method with this annotation will be invoked if either the `@Complete`
    or `@Compensate` method invocation fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Leave`: A method with this annotation causes the LRA participant to be removed
    from the LRA participation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Status`: A method with this annotation reports the status of the associated
    LRA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AfterLRA`: A method with this annotation will be called when an LRA ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `@Compensate`, `@Complete`, and `@AfterLRA` annotations are for the `PUT`
    operation, while the `@Status` annotation is for the `GET` operation and `@Forget`
    for the `DELETE` operation. Let''s go through this code snippet to explain these
    annotations further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, when the `bookHotel()`method is called inside an LRA, this
    method will run with the same LRA context. If it is called outside an LRA context,
    the method will run with a new context. This method might call in to another service.
    If this method succeeds, the `completeBooking()` method will be invoked. Otherwise,
    the `cancelBooking()`method will be invoked. You might be wondering which service
    calls the `completeBooking()` and `cancelBooking()`methods. It's the job of the
    LRA coordinator, which will ensure the corresponding method is invoked. In the
    next section, we will discuss how to make the APIs from LRA available to your
    Maven and Gradle projects.
  prefs: []
  type: TYPE_NORMAL
- en: Making MicroProfile LRA available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the MicroProfile LRA APIs, you need to make these APIs available to
    your application. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this, you have learned how to perform transactions in your cloud-native
    application. Congratulations! You have now learned about all the MicroProfile
    specifications. In the next section, let's discuss how best to use the latest
    MicroProfile platform release.
  prefs: []
  type: TYPE_NORMAL
- en: Using the latest MicroProfile platform release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B17377_02_Final_SB_epub.xhtml#_idTextAnchor036), *How Does
    MicroProfile Fit Into Cloud-Native Application Development?*, we mentioned the
    MicroProfile platform release and its content. So far, the latest MicroProfile
    platform release is MicroProfile 4.1, which can be found at [https://download.eclipse.org/microprofile/microprofile-4.1/](https://download.eclipse.org/microprofile/microprofile-4.1/).
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile 4.1 was built on top of MicroProfile 4.0, with MicroProfile Health
    updating from 3.0 to 3.1\. MicroProfile 4.1 aligns with the following Jakarta
    EE 8 specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Contexts and Dependency Injection 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta Annotations 1.3, Jakarta RESTful Web Services 2.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta JSON-B 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta JSON-P 1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta Annotations 1.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also includes the following MicroProfile specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Config 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fault Tolerance 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT Propagation 1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metrics 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAPI 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenTracing 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest Client 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to use a few of the MicroProfile specifications from MicroProfile
    4.1 for your cloud-native applications, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the APIs from MicroProfile 4.1 available for compiling your cloud-native
    applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you build a Maven project, add the following dependency in your `pom.xml`
    to make the APIs available to your cloud-native applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, specify the following dependency for your Gradle projects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose a MicroProfile 4.1 implementation to run your cloud-native applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Liberty was used as the compatible implementation to release MicroProfile
    4.1\. Open Liberty, as mentioned in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146),
    *The MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes,* is a very
    lightweight and performant runtime for supporting MicroProfile specifications.
    It is also a composable runtime. Specifying the following MicroProfile 4.1 feature
    in your `server.xml` causes the implementation of MicroProfile 4.1 to be loaded:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the standalone specifications, such as MicroProfile GraphQL, MicroProfile
    Context Propagation, MicroProfile Reactive Messaging, and MicroProfile LRA, you
    will need to specify the relevant API Maven dependencies as mentioned in the previous
    chapters and then include the corresponding feature elements in your `server.xml`,
    as shown next. The following line pulls in the implementation of MicroProfile
    GraphQL 1.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line enables the support of MicroProfile Context Propagation 1.2:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line pulls in the implementation of MicroProfile Reactive Messaging 1.0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line enables MicroProfile LRA participants of MicroPorfile LRA 1.0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line enables the MicroProfile LRA coordinator of MicroProfile LRA 1.0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The support for MicroProfile LRA 1.0 is available in the Open Liberty beta driver
    from 20.0.0.12-beta onward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this, you have gained up-to-date information about MicroProfile. In the
    next section, we will discuss the future roadmap for MicroProfile.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile's technical roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile is used to define a programming model for developing cloud-native
    applications. It helps to establish a great ecosystem using different cloud infrastructure
    technologies. These cloud infrastructure technologies include some cloud-native
    frameworks such as Kubernetes, Jaeger, Prometheus, Grafana, and OpenTelemetry.
    Kubernetes, Jaeger, Prometheus, and Grafana are mature technologies, and you probably
    know about them already. You might not know a great deal about OpenTelemetry.
    OpenTelemetry is a new sandbox project from the **Cloud Native Computing Foundation**
    (**CNCF**), and we will spend some time explaining it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting OpenTelemetry in MicroProfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**OpenTelemetry** ([https://opentelemetry.io/](https://opentelemetry.io/))
    is a new CNCF observability framework developed by merging of **OpenTracing**
    ([https://opentracing.io/](https://opentracing.io/)) and **OpenCensus** ([https://opencensus.io/](https://opencensus.io/)).
    Since MicroProfile OpenTracing, covered in [*Chapter 6*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123),
    *Observing and Monitoring Cloud-Native Applications*, was based on OpenTracing,
    OpenTelemetry was bound to be adopted by MicroProfile eventually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of effort has been gone to in the MicroProfile community to investigate
    how to utilize OpenTelemetry in MicroProfile. One suggestion is to continue supporting
    the OpenTracing API, but its implementation adopts OpenTelemetry by using the
    following code snippet to transform an OpenTelemetry tracer to an OpenTracing
    tracer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the tracer transformation, the current MicroProfile OpenTracing should
    be able to continue working. However, the OpenTracing Tracer API won't be maintained
    anymore because the community has moved to working on OpenTelemetry APIs. The
    ultimate goal is to expose the Tracer API (`io.opentelemetry.api.trace.Tracer`)
    from OpenTelemetry. The MicroProfile community is trying to find the best way
    of adopting OpenTelemetry.
  prefs: []
  type: TYPE_NORMAL
- en: You might be aware that OpenTelemetry also provides metrics support. Do we need
    to pull OpenTelemetry metrics to MicroProfile? This is an open question. Let's
    discuss the future roadmap of MicroProfile Metrics in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What is the future of MicroProfile Metrics?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MicroProfile Metrics**, explained in [*Chapter 6*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123),
    *Observing and Monitoring Cloud-Native Applications*, was based on **Dropwizard**
    ([https://www.dropwizard.io/en/latest/](https://www.dropwizard.io/en/latest/)),
    a Java framework for developing ops-friendly, high-performance, RESTful web services.
    Dropwizard has been very popular in the past few years. However, recently, **Micrometer**
    ([https://micrometer.io/](https://micrometer.io/)) has gained more momentum and
    become a prominent metrics framework. The MicroProfile Metrics specification team
    is investigating how to adopt Micrometer while keeping the current APIs working
    with either Micrometer or Dropwizard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, OpenTelemetry also contains metrics support. The other
    suggestion is for MicroProfile Metrics to align with OpenTelemetry Metrics. If
    OpenTelemetry Metrics is the new metrics standard in the future, MicroProfile
    should adopt OpenTelemetry Metrics instead. So, MicroProfile offers two metrics
    candidates to choose from. Now, the question arises: *Which one should you choose*?
    It depends on which one will become the mainstream. The ideal situation is that
    Micrometer integrates with OpenTelemetry. if Micrometer integrates well with OpenTelemetry
    Metrics, adopting Micrometer would naturally align with OpenTelemetry Metrics.
    Maybe MicroProfile Metrics should wait for OpenTelemetry Metrics to settle and
    then work out which framework to adopt.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the existing MicroProfile specifications, the MicroProfile community
    is also interested in new initiatives, such as gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting gPRC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the evolution of the current MicroProfile specifications, the community
    is interested in adopting new technologies to provide better support in cloud-native
    applications. One potential new specification is gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: '**gRPC** ([https://grpc.io/](https://grpc.io/)) is a modern high-performance
    **Remote Procedure Call** (**RPC**) framework that can run in any environment.
    To make gRPC easier to use in cloud-native applications, it would be great if
    it can be integrated with CDI, JAX-RS, and so on. If MicroProfile adopts gRPC
    to create a new specification MicroProfile gRPC, this specification will be able
    to work closely and seamlessly with other MicroProfile specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the specification updates, we will discuss MicroProfile
    alignment with Jakarta EE releases.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile and Jakarta EE alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MicroProfile adopts a few Jakarta EE technologies, such as CDI, JAX-RS, JSON-B,
    JSON-P, and Common Annotations. MicroProfile 4.0 and 4.1 align with the Jakarta
    EE 8 release. This book is based on the MicroProfile 4.1 release. MicroProfile
    has been working very closely with Jakarta EE. Most major players in MicroProfile
    are also involved in Jakarta EE. MicroProfile and Jakarta EE form a great ecosystem
    for developing cloud-native applications. It is very important that they always
    keep in sync and are compatible with each other. Jakarta EE 9.1 ([https://jakarta.ee/release/9.1/](https://jakarta.ee/release/9.1/))
    was released in 2021, which adds a requirement for MicroProfile to work with this
    release so that end users can use APIs from both frameworks. Due to this requirement,
    we will discuss MicroProfile 5.0 in the next section, which is planned to align
    with Jakarta EE 9.1\.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning MicroProfile 5.0 with Jakarta EE 9.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The focus of MicroProfile 5.0 is to align with Jakarta EE 9.1\. The eight component
    specifications, including Config, Fault Tolerance, Rest Client, Health, Metrics,
    OpenTracing, OpenAPI, and JWT Propagation, need to be updated so that they are
    aligned with Jakarta EE 9.1\. Some of these specifications do not directly depend
    on the Jakarta specifications in their APIs, but their **Technology Compatibility
    Kits** (**TCKs**) pull in Jakarta specifications. For these specifications, only
    a minor release is needed. To make all the MicroProfile specifications work with
    Jakarta 9.1, the specifications under the standalone releases such as Reactive
    Streams Operators, Reactive Messaging, LRA, GraphQL, and Context Propagation all
    need to be updated to align with Jakarta EE 9.1\.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the alignment with Jakarta EE, some of the MicroProfile specifications
    extend the current Jakarta specifications. Since these MicroProfile specifications
    were created while Java EE was stagnant, it might be the right time for these
    MicroProfile specifications to become Jakarta specifications so that other Jakarta
    specifications can benefit from them. Let's look at those specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Moving some MicroProfile specifications to Jakarta EE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some Jakarta EE specifications, such as **Jakarta NoSQL** (GitHub repository:
    [https://github.com/eclipse-ee4j/nosql](https://github.com/eclipse-ee4j/nosql)),
    would benefit from MicroProfile Config for configuration. If Jakarta EE depended
    on MicroProfile, this would create a circular dependency as MicroProfile aligns
    with Jakarta EE specifications. The other problem is that Jakarta EE specifications
    have traditionally maintained backward compatibility more carefully, while MicroProfile
    specifications can introduce backward-incompatibility changes from time to time.
    Therefore, it might be problematic for Jakarta EE specifications to directly depend
    on MicroProfile specifications. To solve this problem, a new proposal, **Jakarta
    Config**, was put forward to collaborate with MicroProfile Config. Jakarta Config
    (GitHub repository: [https://github.com/eclipse-ee4j/config](https://github.com/eclipse-ee4j/config))
    could become the centerpiece of Jakarta EE. Jakarta Config aims to be included
    in Jakarta Core Profile so that other profiles and MicroProfile can depend on
    this specification.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from alignment with Jakarta EE, MicroProfile is also trying to adopt **Long-Term
    Support** (**LTS**) Java releases such as Java 11 and Java 17\.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might still remember the two releases in MicroProfile: platform and standalone.
    The MicroProfile community needs to look at the specifications included in the
    standalone release to see whether it is time to move some specifications back
    to the platform release bucket. The other area the MicroProfile community needs
    to improve is the end-user experience. The MicroProfile community will continue
    improving its entry page ([https://microprofile.io/](https://microprofile.io/)).'
  prefs: []
  type: TYPE_NORMAL
- en: We can't believe that we have reached the end of this book. There are so many
    topics to cover. For further information on MicroProfile, please go to [https://microprofile.io/](https://microprofile.io/).
    If you would like to learn about anything related to MicroProfile, please visit
    the Open Liberty guides ([https://openliberty.io/guides/](https://openliberty.io/guides/)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With that, we come to the end of this book. Let''s revisit what you have learned.
    Throughout this book, we learned how to create cloud-native applications using
    Jakarta REST, JSON-P, JSON-B, CDI, and the MicroProfile Rest Client; then enhance
    cloud-native applications using MicroProfile Config, Fault Tolerance, Open API,
    and JWT Propagation; and finally monitor cloud-native applications using MicroProfile
    Health, Metrics, and Open Tracing. We then learned about the MicroProfile ecosystem
    with Open Liberty, Docker, Kubernetes, and Istio. After we covered all the technologies,
    we then looked at an end-to-end project that utilized different MicroProfile technologies.
    Afterward, we discussed deployment and day 2 operations. We then looked at the
    standalone specifications: MicroProfile GraphQL, MicroProfile Context Propagation,
    and MicroProfile Reactive Messaging.'
  prefs: []
  type: TYPE_NORMAL
- en: In this final chapter, we discussed the latest release of MicroProfile LRA 1.0\.
    We then discussed the future roadmap in MicroProfile, followed by the plan with
    Jakarta EE alignment. The takeaway from this chapter is that MicroProfile and
    Jakarta EE are complementary to each other, and they form a great ecosystem that
    supports cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you have enjoyed reading this book and learned how to use the amazing
    features of MicroProfile to help you with your cloud-native application development,
    deployment, and management. If you would like to contribute to MicroProfile, please
    click on the **Join The Discussion** link on the microprofile.io website ([https://microprofile.io/](https://microprofile.io/))
    to express your interest in being on the mailing list.
  prefs: []
  type: TYPE_NORMAL
