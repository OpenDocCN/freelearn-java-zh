<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Crafting a RESTful Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Crafting a RESTful Application</h1></div></div></div><p>In this chapter, we will have a look at the main principles of a RESTful architecture. Then, with the help of very handy tools, we will design a friendly API, leveraging Jackson's capabilities to serialize our model in JSON.</p><p>We will document our application with the appropriate error codes and HTTP verbs and automatically generate a neat frontend for our application by using Swagger UI.</p><p>Finally, we will look at the other forms of serialization and learn more about the content negotiation mechanism of Spring MVC.</p><div class="section" title="What is REST?"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>What is REST?</h1></div></div></div><p>
<span class="strong"><strong>REST</strong></span> (<span class="strong"><strong>Representational State Transfer</strong></span>) is an <a id="id274" class="indexterm"/>architectural style that defines best practices for creating scalable web services leveraging the capabilities of the HTTP protocol.</p><p>A RESTful web service should naturally exhibit the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client-server</strong></span>: The <a id="id275" class="indexterm"/>UI is separated from data storage</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stateless</strong></span>: Each <a id="id276" class="indexterm"/>request contains enough information for the server to operate without maintaining any state</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cacheable</strong></span>: The<a id="id277" class="indexterm"/> server's responses contain enough information to allow the clients to make sensible decisions about data storage</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Uniform interface</strong></span>: URIs<a id="id278" class="indexterm"/> uniquely identify resources and hyperlinks allow the API to be discovered</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Layered</strong></span>: Each resource of the <a id="id279" class="indexterm"/>API provides a sensible level of detail</li></ul></div><p>The advantage of such an architecture is that it is simple to maintain and easy to discover. It also scales well because there is no need to maintain a persistent connection between the server and the client, which eliminates the need for load balancing or sticky sessions. Finally, the service is more efficient because the information is neatly laid out and easy to cache.</p><p>Let's see how we can design better APIs incrementally by using Richardson's maturity model.</p></div></div>
<div class="section" title="Richardson's maturity model"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Richardson's maturity model</h1></div></div></div><p>Leonard Richardson is famous<a id="id280" class="indexterm"/> for having defined four levels, ranked from 0 to 3, that describe the level of "RESTfulness" of a web API. Each level requires additional work and investment in the API but also provides additional benefits.</p><div class="section" title="Level 0 – HTTP"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Level 0 – HTTP</h2></div></div></div><p>Level 0 is really easy to<a id="id281" class="indexterm"/> reach; you just have to make your resource available on a network through the HTTP protocol. You can use any data representation you find best suited for your use case (XML, JSON, and so on).</p></div><div class="section" title="Level 1 – Resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Level 1 – Resources</h2></div></div></div><p>Most people think of<a id="id282" class="indexterm"/> resources when they hear the term REST. A resource is a unique identifier for an element of our model, a user or a tweet, for instance. With HTTP, a resource is obviously associated with a unified resource identifier URI, as shown in this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/users</code> contains the list of all our users</li><li class="listitem" style="list-style-type: disc"><code class="literal">/user/42</code> contains a specific user</li><li class="listitem" style="list-style-type: disc"><code class="literal">/user/42/tweets</code> contains the list of all the tweets associated to this particular user</li></ul></div><p>Maybe your API could allow access to a particular tweet related to a user with <code class="literal">/user/42/tweet/3</code> or maybe each tweet is uniquely identified, in which case you might prefer <code class="literal">/tweet/3</code>.</p><p>The goal of this level is to deal with the complexity of an application by exposing multiple specialized resources.</p><p>There is no rule regarding the type of response that your server can return. You might want to include only scarce information when you list all the resources with <code class="literal">/users</code> and give more details when a specific resource is requested. Some APIs even let you list the fields you are interested in before serving them to you.</p><p>It really is up to you to define the form of your API, keeping one simple rule in mind: the principle of least astonishment. Give your users what they expect and your API will already be in good shape.</p></div><div class="section" title="Level 2 – HTTP verbs"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Level 2 – HTTP verbs</h2></div></div></div><p>This level is about <a id="id283" class="indexterm"/>using the HTTP verbs to identify possible actions on the resources. This is a very good way to describe what can be done with your API since the HTTP verbs are a well-known standard among developers.</p><p>The main verbs are listed here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GET</code>: This reads <a id="id284" class="indexterm"/>data on a particular URI.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HEAD</code>: This does the same <a id="id285" class="indexterm"/>as <code class="literal">GET</code> without the response body. This is useful for getting metadata on a resource (cache information and so on).</li><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE</code>: This deletes <a id="id286" class="indexterm"/>a resource.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT</code>: This updates or <a id="id287" class="indexterm"/>creates a resource.</li><li class="listitem" style="list-style-type: disc"><code class="literal">POST</code>: This updates or<a id="id288" class="indexterm"/> creates a resource.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PATCH</code>: This partially <a id="id289" class="indexterm"/>updates a resource.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OPTIONS</code>: This returns the <a id="id290" class="indexterm"/>list of methods that the server supports on a particular resource.</li></ul></div><p>Most applications that allow <span class="strong"><strong>Create Read Update Delete</strong></span> (<span class="strong"><strong>CRUD</strong></span>)<a id="id291" class="indexterm"/> operations get by with only three verbs: <code class="literal">GET</code>, <code class="literal">DELETE</code>, and <code class="literal">POST</code>. The more verbs you implement, the richer and more semantic your API becomes. It helps third parties to interact with your service by allowing them to type a few commands and see what happens.</p><p>The <code class="literal">OPTIONS</code> and <code class="literal">HEAD</code> verbs are rarely seen because they work on the metadata level and are typically not vital to any application.</p><p>At first sight, the <code class="literal">PUT</code> and <code class="literal">POST</code> verbs appear to do the same thing. The main difference is that the <code class="literal">PUT</code> verb is said to be idempotent, which means that sending the same request multiple times should result in the same server state. The implication of that rule is essentially that the <code class="literal">PUT</code> verb should operate on a given URI and contain enough information for the request to succeed.</p><p>For instance, a client can use <code class="literal">PUT</code> data on <code class="literal">/user/42</code>, and the result will be either an update or a creation, depending on whether the entity existed prior to the request.</p><p>On the other hand, <code class="literal">POST</code> should be used when you don't exactly know what URI you should write to. You could send <code class="literal">POST</code> to <code class="literal">/users</code> without specifying an ID in the request and expect the user to be created. You could also send <code class="literal">POST</code> to the same <code class="literal">/users</code> resource, this time specifying a user ID inside the request entity and expect the server to update the corresponding user.</p><p>As you can see, both of these options work. One frequent use case is to use <code class="literal">POST</code> for creation (because, most of the time, the server should be in charge of the IDs) and to use <code class="literal">PUT</code> to update a resource whose ID is already known.</p><p>The <a id="id292" class="indexterm"/>server might also allow a resource to be modified partially (without the client sending the full contents of the resource). It should respond to the <code class="literal">PATCH</code> method in that case.</p><p>At this level, I also encourage you to use meaningful HTTP codes when providing responses. We will see the most common codes in a moment.</p></div><div class="section" title="Level 3 – Hypermedia controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Level 3 – Hypermedia controls</h2></div></div></div><p>Hypermedia controls are also known as<a id="id293" class="indexterm"/> <span class="strong"><strong>Hypertext As The Engine Of Application State</strong></span> (<span class="strong"><strong>HATEOAS</strong></span>). Behind this <a id="id294" class="indexterm"/>barbarous acronym lies the most important property of a RESTful service: making it discoverable through the use of hypertext links. This is essentially the server telling the client what its options are, using the response headers or the response entity.</p><p>For instance, after the creation of a resource with <code class="literal">PUT</code>, the server should return a response with the code <code class="literal">201 CREATED</code> and send a <code class="literal">Location</code> header containing the URI of the created resource.</p><p>There is no standard that defines how the link to the other parts of the API should look. Spring Data REST, a Spring project that allows you to create a RESTful backend with minimal configuration, typically outputs this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  "_links" : {</strong></span>
<span class="strong"><strong>    "people" : {</strong></span>
<span class="strong"><strong>      "href" : "http://localhost:8080/users{?page,size,sort}",</strong></span>
<span class="strong"><strong>      "templated" : true</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Then, go to <code class="literal">/users</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  "_links" : {</strong></span>
<span class="strong"><strong>    "self" : {</strong></span>
<span class="strong"><strong>      "href" : "http://localhost:8080/users{?page,size,sort}",</strong></span>
<span class="strong"><strong>      "templated" : true</strong></span>
<span class="strong"><strong>    },</strong></span>
<span class="strong"><strong>    "search" : {</strong></span>
<span class="strong"><strong>      "href" : "http://localhost:8080/users/search"</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  },</strong></span>
<span class="strong"><strong>  "page" : {</strong></span>
<span class="strong"><strong>    "size" : 20,</strong></span>
<span class="strong"><strong>    "totalElements" : 0,</strong></span>
<span class="strong"><strong>    "totalPages" : 0,</strong></span>
<span class="strong"><strong>    "number" : 0</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>This gives <a id="id295" class="indexterm"/>you a good idea of what you can do with the API, doesn't it?</p></div></div>
<div class="section" title="API versioning"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>API versioning</h1></div></div></div><p>If third-party clients use <a id="id296" class="indexterm"/>your API, you could consider versioning your API to avoid breaking changes when you update your application.</p><p>Versioning an API is often a matter of making a set of stable resources available under subdomains. For instance, GitLab maintains three versions of its API. They are accessible under <code class="literal">https://example/api/v3</code>, and so on. Like a lot of architectural decisions in software, versioning is a tradeoff.</p><p>It will require more work to design such an API and identify breaking changes in the API. Often, the addition of new fields will not be as problematic as removing or transforming the API entity results or requests.</p><p>Most of the time, you will be in charge of both the API and the client, thereby removing the need for such sophistication.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>See this blog post for a <a id="id297" class="indexterm"/>more in-depth discussion about API versioning:</p><p>
<a class="ulink" href="http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html">http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html</a>
</p></div></div></div>
<div class="section" title="Useful HTTP codes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Useful HTTP codes</h1></div></div></div><p>Another important aspect of a <a id="id298" class="indexterm"/>good RESTful API is to use HTTP codes in a sensible way. The HTTP specification defines a lot of standard codes. They should cover 99 percent of what a good API needs to communicate to its users. The following list contains the most important codes, the ones every API should use and every developer should know:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Code</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th><th style="text-align: left" valign="bottom">
<p>Usage</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>2xx - Success</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>These codes are used when everything goes well.</strong></span>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">200</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Everything is okay. </p>
</td><td style="text-align: left" valign="top">
<p>The request succeeded.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">201</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A resource has been created. </p>
</td><td style="text-align: left" valign="top">
<p>The successful creation of a resource. The response should include a list of locations associated with the creation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">204</code>
</p>
</td><td style="text-align: left" valign="top">
<p>There is no content to return. </p>
</td><td style="text-align: left" valign="top">
<p>The server has successfully handled the request but there is no content to return.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>3xx - Redirection</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>These codes are used when further action is needed on the client to fulfill the request</strong></span>.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">301</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Moved permanently</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id299" class="indexterm"/>resource has a changed URI and its new location is indicated in the <code class="literal">Location</code> header.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">304</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The resource has not been modified. </p>
</td><td style="text-align: left" valign="top">
<p>The resource has not changed since the last time. This response must include the date, ETag, and cache information.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>4xx - Client error</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>The request was not successfully performed because of a mistake made by the client</strong></span>.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">400</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Bad request</p>
</td><td style="text-align: left" valign="top">
<p>The data sent by the client could not be understood.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">403</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Forbidden</p>
</td><td style="text-align: left" valign="top">
<p>The request was understood but not allowed. This can be enriched with information describing the error.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">404</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Not found</p>
</td><td style="text-align: left" valign="top">
<p>Nothing matches this URI. This can be used instead of 403 if information about security shouldn't be disclosed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">409</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Conflict</p>
</td><td style="text-align: left" valign="top">
<p>The request <a id="id300" class="indexterm"/>conflicts with another modification. The response should include information on how to resolve the conflict.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>5xx - Server error</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>An error occurred on the server side</strong></span>.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">500</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An internal server error</p>
</td><td style="text-align: left" valign="top">
<p>The server unexpectedly failed to process the request.</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>For a more <a id="id301" class="indexterm"/>detailed list, see <a class="ulink" href="http://www.restapitutorial.com/httpstatuscodes.html">http://www.restapitutorial.com/httpstatuscodes.html</a>.</p></div></div></div>
<div class="section" title="Client is the king"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Client is the king</h1></div></div></div><p>We will allow third-party clients to retrieve the search results via a REST API. These results will be available either in JSON or XML.</p><p>We want to handle requests of the <code class="literal">/api/search/mixed;keywords=springFramework </code>form. This is really similar to the search form we already made, except that the request path begins with <code class="literal">api</code>. Every URI found in this namespace should return binary results.</p><p>Let's create <a id="id302" class="indexterm"/>a new <code class="literal">SearchApiController</code> class in the <code class="literal">search.api</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search.api;

import masterSpringMvc.search.SearchService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.social.twitter.api.Tweet;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/search")
public class SearchApiController {
    private SearchService searchService;

    @Autowired
    public SearchApiController(SearchService searchService) {
        this.searchService = searchService;
    }

    @RequestMapping(value = "/{searchType}", method = RequestMethod.GET)
    public List&lt;Tweet&gt; search(@PathVariable String searchType, @MatrixVariable List&lt;String&gt; keywords) {
        return searchService.search(searchType, keywords);
    }
}</pre></div><p>This is quite<a id="id303" class="indexterm"/> similar to our previous controller, with three subtle differences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The controller class is annotated with a <code class="literal">@RequestMapping</code> annotation. This will be our base address and will prefix every other mapping declared in this controller.</li><li class="listitem" style="list-style-type: disc">We no longer redirect to a view but return a plain object in the search method.</li><li class="listitem" style="list-style-type: disc">The controller is annotated with <code class="literal">@RestController</code> instead of <code class="literal">@Controller</code>.</li></ul></div><p>The <code class="literal">RestController</code> is a shortcut to declare controllers that will return each response as if it were annotated with the <code class="literal">@ResponseBody</code> annotation. It tells Spring to serialize the return type to the appropriate format, which is JSON by default.</p><p>When working with a REST API, a good practice is to always specify the method you will respond to. It's rather unlikely that a request can be handled the same way for a <code class="literal">GET</code> or a <code class="literal">POST</code> method.</p><p>If you go to <code class="literal">http://localhost:8080/api/search/mixed;keywords=springFramework</code>, you should get a really large result, as follows:</p><div class="mediaobject"><img src="graphics/2117_5_1.jpg" alt="Client is the king"/></div><p>Indeed, Spring<a id="id304" class="indexterm"/> handled the serialization of the whole <code class="literal">Tweet</code> class' attributes automatically, using Jackson.</p></div>
<div class="section" title="Debugging a RESTful API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Debugging a RESTful API</h1></div></div></div><p>With your browser, you <a id="id305" class="indexterm"/>will only be able to perform <code class="literal">GET</code> requests on a specific API. The good tools will make your developments much simpler. There are lots of tools to test a RESTful API. I will just list the one I use and love.</p><div class="section" title="A JSON formatting extension"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec39"/>A JSON formatting extension</h2></div></div></div><p>Often, you will just test <a id="id306" class="indexterm"/>the <code class="literal">GET</code> method and your first reflex will be to copy the address into your browser to check the result. In that case, you have the possibility to get more than plain text with extensions such as JSON Formatter for Chrome or JSONView for Firefox.</p></div><div class="section" title="A RESTful client in your browser"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec40"/>A RESTful client in your browser</h2></div></div></div><p>The browser is the <a id="id307" class="indexterm"/>natural tool for dealing with HTTP requests. However, using the address bar will rarely allow you to test your API in detail.</p><p>Postman is an extension for Chrome, and RESTClient is its Firefox counterpart. They both have similar features, such as creating and sharing collections of queries, modification of the headers, and handling authentication (basic, digest, and OAuth). At the time of writing, only RESTClient handles OAuth2.</p></div><div class="section" title="httpie"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec41"/>httpie</h2></div></div></div><p>
<span class="strong"><strong>httpie</strong></span> is a <a id="id308" class="indexterm"/>command<a id="id309" class="indexterm"/> line utility à la curl but oriented towards REST querying. It allows you to type commands such as this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>http PUT httpbin.org/put hello=world</strong></span>
</pre></div><p>It's a lot friendlier than this ugly version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -i -X PUT httpbin.org/put -H Content-Type:application/json -d '{"hello": "world"}'</strong></span>
</pre></div></div></div>
<div class="section" title="Customizing the JSON output"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Customizing the JSON output</h1></div></div></div><p>Using our tools we are able to <a id="id310" class="indexterm"/>easily see the request generated by our server. It is huge. By default, Jackson, the JSON serialization library used by Spring Boot, will serialize everything that is accessible with a getter method.</p><p>We would like something lighter, such as this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  "text": "original text",</strong></span>
<span class="strong"><strong>  "user": "some_dude",</strong></span>
<span class="strong"><strong>  "profileImageUrl": "url",</strong></span>
<span class="strong"><strong>  "lang": "en",</strong></span>
<span class="strong"><strong>  "date": 2015-04-15T20:18:55,</strong></span>
<span class="strong"><strong>  "retweetCount": 42</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>The easiest way to customize which fields will be serialized is by adding annotations to our beans. You can either use the <code class="literal">@JsonIgnoreProperties</code> annotation at the class level to ignore a set of properties or add <code class="literal">@JsonIgnore</code> on the getters of the properties you wish to ignore.</p><p>In our case, the <code class="literal">Tweet</code> class is not one of our own. It is part of Spring Social Twitter, and we do not have the ability to annotate it.</p><p>Using the model classes directly for serialization is rarely a good option. It would tie your model to your serialization library, which should remain an implementation detail.</p><p>When dealing with unmodifiable code, Jackson provides two options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a new class dedicated to serialization.</li><li class="listitem" style="list-style-type: disc">Using mixins, which are simple classes that will be linked to your model. These will be declared in your code and can be annotated with any Jackson annotation.</li></ul></div><p>Since we only <a id="id311" class="indexterm"/>need to perform some simple transformation on the fields of our model (a lot of hiding and a little renaming), we could opt for the mixins.</p><p>It's a good, non-invasive way to rename and exclude fields on the fly with a simple class or interface.</p><p>Another option to specify subsets of fields used in different parts of the application is to annotate them with the <code class="literal">@JsonView</code> annotation. This won't be covered in this chapter, but I encourage you to check out this excellent blog post <a class="ulink" href=" https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring"> https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring</a>.</p><p>We want to be in control of the output of our APIs, so let's just create a new class called <code class="literal">LightTweet</code> that can be constructed from a tweet:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import org.springframework.social.twitter.api.Tweet;
import org.springframework.social.twitter.api.TwitterProfile;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;

public class LightTweet {
    private String profileImageUrl;
    private String user;
    private String text;
    private LocalDateTime date;
    private String lang;
    private Integer retweetCount;

    public LightTweet(String text) {
        this.text = text;
    }

    public static LightTweet ofTweet(Tweet tweet) {
        LightTweet lightTweet = new LightTweet(tweet.getText());
        Date createdAt = tweet.getCreatedAt();
        if (createdAt != null) {
            lightTweet.date = LocalDateTime.ofInstant(createdAt.toInstant(), ZoneId.systemDefault());
        }
        TwitterProfile tweetUser = tweet.getUser();
        if (tweetUser != null) {
            lightTweet.user = tweetUser.getName();
            lightTweet.profileImageUrl = tweetUser.getProfileImageUrl();
        }
        lightTweet.lang = tweet.getLanguageCode();
        lightTweet.retweetCount = tweet.getRetweetCount();
        return lightTweet;
    }

  // don't forget to generate getters
  // They are used by Jackson to serialize objects
}</pre></div><p>We now need to<a id="id312" class="indexterm"/> make our <code class="literal">SearchService</code> class return the <code class="literal">LightTweets</code> class instead of tweets:</p><div class="informalexample"><pre class="programlisting">    public List&lt;<span class="strong"><strong>LightTweet</strong></span>&gt; search(String searchType, List&lt;String&gt; keywords) {
        List&lt;SearchParameters&gt; searches = keywords.stream()
                .map(taste -&gt; createSearchParam(searchType, taste))
                .collect(Collectors.toList());

        <span class="strong"><strong>List&lt;LightTweet&gt;</strong></span> results = searches.stream()
                .map(params -&gt; twitter.searchOperations().search(params))
                .flatMap(searchResults -&gt; searchResults.getTweets().stream())
                <span class="strong"><strong>.map(LightTweet::ofTweet)</strong></span>
                .collect(Collectors.toList());

        return results;
    }</pre></div><p>This will impact the return type of the <code class="literal">SearchApiController</code> class as well as the tweets model attribute in the <code class="literal">SearchController</code> class. Make the necessary modification in those two classes.</p><p>We also need to change the code of the <code class="literal">resultPage.html</code> file because some properties changed (we no longer have a nested <code class="literal">user</code> property):</p><div class="informalexample"><pre class="programlisting">&lt;ul class="collection"&gt;
    &lt;li class="collection-item avatar" th:each="tweet : ${tweets}"&gt;
        &lt;img th:src="${<span class="strong"><strong>tweet.profileImageUrl</strong></span>}" alt="" class="circle"/&gt;
        &lt;span class="title" th:text="${<span class="strong"><strong>tweet.user</strong></span>}"&gt;Username&lt;/span&gt;

        &lt;p th:text="${tweet.text}"&gt;Tweet message&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;</pre></div><p>We're almost <a id="id313" class="indexterm"/>done. If you restart your application and go to <code class="literal">http://localhost:8080/api/search/mixed;keywords=springFramework</code>, you'll see that the date format is not the one we expected:</p><div class="mediaobject"><img src="graphics/2117_05_02.jpg" alt="Customizing the JSON output"/></div><p>That's because Jackson doesn't have built-in support for JSR-310 dates. Luckily, this is easy to fix. Simply add the following library to the dependencies in the <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'</pre></div><p>This indeed changes the date format, but it now outputs an array instead of a formatted date.</p><p>To change that, we need to understand what the library did. It includes a new Jackson module called JSR-310 Module. A Jackson module is an extension point to customize serialization <a id="id314" class="indexterm"/>and deserialization. This one will automatically be registered by Spring Boot at startup in the <code class="literal">JacksonAutoConfiguration</code> class, which will create a default Jackson <code class="literal">ObjectMapper</code> method with support for well-known modules.</p><p>We can see that the former module adds a bunch of serializers and deserializers for all the new classes defined in <a id="id315" class="indexterm"/>JSR-310. This will try to convert every date to an ISO format, whenever possible. See <a class="ulink" href="https://github.com/FasterXML/jackson-datatype-jsr310">https://github.com/FasterXML/jackson-datatype-jsr310</a>.</p><p>If we take a closer look at <code class="literal">LocalDateTimeSerializer</code>, for instance, we can see that it actually has two modes and can switch between the two with a serialization feature called <code class="literal">WRITE_DATES_AS_TIMESTAMPS</code>.</p><p>To define this property, we need to customize Spring's default object mapper. As we can gather from looking at the auto configuration, Spring MVC provides a utility class to create the <code class="literal">ObjectMapper</code> method that we can use. Add the following bean to your <code class="literal">WebConfiguration</code> class:</p><div class="informalexample"><pre class="programlisting">@Bean
@Primary
public ObjectMapper objectMapper(Jackson2ObjectMapperBuilder builder) {
   ObjectMapper objectMapper = builder.createXmlMapper(false).build();
   objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
   return objectMapper;
}</pre></div><p>This time, we are done and the dates are properly formatted, as you can see here:</p><div class="mediaobject"><img src="graphics/2117_05_03.jpg" alt="Customizing the JSON output"/></div></div>
<div class="section" title="A user management API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>A user management API</h1></div></div></div><p>Our search API is <a id="id316" class="indexterm"/>quite good, but let's do something more interesting. Like a lot of web applications, we will need a user management module to identify our users. For that, we will create a new <code class="literal">user</code> package. In this package, we will add a model class as follows:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

public class User {
    private String twitterHandle;
    private String email;
    private LocalDate birthDate;
    private List&lt;String&gt; tastes = new ArrayList&lt;&gt;();

    // Getters and setters for all fields
}</pre></div><p>Since we do not want<a id="id317" class="indexterm"/> to use a database just yet, we will create a <code class="literal">UserRepository</code> class in the same package, backed by a simple <code class="literal">Map</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user;

import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Repository
public class UserRepository {
    private final Map&lt;String, User&gt; userMap = new ConcurrentHashMap&lt;&gt;();

    public User save(String email, User user) {
        user.setEmail(email);
        return userMap.put(email, user);
    }

    public User save(User user) {
        return save(user.getEmail(), user);
    }

    public User findOne(String email) {
        return userMap.get(email);
    }

    public List&lt;User&gt; findAll() {
        return new ArrayList&lt;&gt;(userMap.values());
    }

    public void delete(String email) {
        userMap.remove(email);
    }

    public boolean exists(String email) {
        return userMap.containsKey(email);
    }
}</pre></div><p>Finally, in the <a id="id318" class="indexterm"/><code class="literal">user.api</code> package, we will create a very naive controller implementation:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user.api;

import masterSpringMvc.user.User;
import masterSpringMvc.user.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api")
public class UserApiController {

    private UserRepository userRepository;

    @Autowired
    public UserApiController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @RequestMapping(value = "/users", method = RequestMethod.GET)
    public List&lt;User&gt; findAll() {
        return userRepository.findAll();
    }

    @RequestMapping(value = "/users", method = RequestMethod.POST)
    public User createUser(@RequestBody User user) {
        return userRepository.save(user);
    }

    @RequestMapping(value = "/user/{email}", method = RequestMethod.PUT)
    public User updateUser(@PathVariable String email, @RequestBody User user) {
        return userRepository.save(email, user);
    }

    @RequestMapping(value = "/user/{email}", method = RequestMethod.DELETE)
    public void deleteUser(@PathVariable String email) {
        userRepository.delete(email);
    }
}</pre></div><p>We implemented all the classic CRUD operations with a RESTful repository by using the user's e-mail address as a unique identifier.</p><p>In this scenario, you will quickly face problems as Spring strips contents found after a dot. The solution is very similar to what we use to support semicolons in URLs in the URL mapping with matrix variables section in <a class="link" href="ch04.html" title="Chapter 4. File Upload and Error Handling">Chapter 4</a>, <span class="emphasis"><em>File Upload and Error Handling</em></span>.</p><p>Add the <code class="literal">useRegisteredSuffixPatternMatch</code> property that is set to false in the <code class="literal">configurePathMatch()</code> method that we have already defined in the <code class="literal">WebConfiguration</code> class:</p><div class="informalexample"><pre class="programlisting">@Override
public void configurePathMatch(PathMatchConfigurer configurer) {
    UrlPathHelper urlPathHelper = new UrlPathHelper();
    urlPathHelper.setRemoveSemicolonContent(false);
    configurer.setUrlPathHelper(urlPathHelper);
    <span class="strong"><strong>configurer.setUseRegisteredSuffixPatternMatch(true);</strong></span>
}</pre></div><p>Now that we've got<a id="id319" class="indexterm"/> our API, we can start interacting with it.</p><p>Here are a few sample commands with httpie:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~ $ http get http://localhost:8080/api/users</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Type: application/json;charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Mon, 20 Apr 2015 00:01:08 GMT</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>
<span class="strong"><strong>Transfer-Encoding: chunked</strong></span>

<span class="strong"><strong>[]</strong></span>

<span class="strong"><strong>~ $ http post http://localhost:8080/api/users email=geo@springmvc.com birthDate=2011-12-12 tastes:='["spring"]'</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Length: 0</strong></span>
<span class="strong"><strong>Date: Mon, 20 Apr 2015 00:02:07 GMT</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>



<span class="strong"><strong>~ $ http get http://localhost:8080/api/users</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Type: application/json;charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Mon, 20 Apr 2015 00:02:13 GMT</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>
<span class="strong"><strong>Transfer-Encoding: chunked</strong></span>

<span class="strong"><strong>[</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>        "birthDate": "2011-12-12",</strong></span>
<span class="strong"><strong>        "email": "geo@springmvc.com",</strong></span>
<span class="strong"><strong>        "tastes": [</strong></span>
<span class="strong"><strong>            "spring"</strong></span>
<span class="strong"><strong>        ],</strong></span>
<span class="strong"><strong>        "twitterHandle": null</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>]</strong></span>

<span class="strong"><strong>~ $ http delete http://localhost:8080/api/user/geo@springmvc.com</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Length: 0</strong></span>
<span class="strong"><strong>Date: Mon, 20 Apr 2015 00:02:42 GMT</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>



<span class="strong"><strong>~ $ http get http://localhost:8080/api/users</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Type: application/json;charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Mon, 20 Apr 2015 00:02:46 GMT</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>
<span class="strong"><strong>Transfer-Encoding: chunked</strong></span>

<span class="strong"><strong>[]</strong></span>
</pre></div><p>This is good but <a id="id320" class="indexterm"/>not great. Status codes are not yet handled. We will need more RESTfulness to climb up the Richardson ladder.</p></div>
<div class="section" title="Status codes and exception handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Status codes and exception handling</h1></div></div></div><p>The first thing we <a id="id321" class="indexterm"/>want to do is<a id="id322" class="indexterm"/> to correctly handle response statuses. By default, Spring automatically deals with some statuses:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">500 Server Error</code>: This indicates<a id="id323" class="indexterm"/> that an exception occurred while handling the request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">405 Method not Supported</code>: This comes <a id="id324" class="indexterm"/>up when you use an incorrect method on an existing handler.</li><li class="listitem" style="list-style-type: disc"><code class="literal">404 Not Found</code>: This comes up<a id="id325" class="indexterm"/> when the handler does not exist.</li><li class="listitem" style="list-style-type: disc"><code class="literal">400 Bad Request</code>: This indicates<a id="id326" class="indexterm"/> that the request body or parameter does not match the server's expectation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">200 OK</code>: It is thrown <a id="id327" class="indexterm"/>for any request handled without an error.</li></ul></div><p>With Spring MVC, there are two ways to return status codes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Returning a <code class="literal">ResponseEntity</code> class from a REST controller</li><li class="listitem" style="list-style-type: disc">Throwing an exception that will be caught in dedicated handlers</li></ul></div><div class="section" title="Status code with ResponseEntity"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Status code with ResponseEntity</h2></div></div></div><p>The HTTP protocol specifies <a id="id328" class="indexterm"/>that we should return a <code class="literal">201 Created</code> status when we create a new user. With our API, this can happen with a <code class="literal">POST</code> method. We also need to throw some 404 errors on operation while working on an entity that does not exist.</p><p>Spring MVC has a class that associates an HTTP status with a response entity. It is called <code class="literal">ResponseEntity</code>. Let's update our <code class="literal">UserApiController</code> class to handle error codes:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user.api;

import masterSpringMvc.user.User;
import masterSpringMvc.user.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api")
public class UserApiController {

    private UserRepository userRepository;

    @Autowired
    public UserApiController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @RequestMapping(value = "/users", method = RequestMethod.GET)
    public List&lt;User&gt; findAll() {
        return userRepository.findAll();
    }

    @RequestMapping(value = "/users", method = RequestMethod.POST)
    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {
        HttpStatus status = HttpStatus.OK;
        if (!userRepository.exists(user.getEmail())) {
            status = HttpStatus.CREATED;
        }
        User saved = userRepository.save(user);
        return new ResponseEntity&lt;&gt;(saved, status);
    }

    @RequestMapping(value = "/user/{email}", method = RequestMethod.PUT)
    public ResponseEntity&lt;User&gt; updateUser(@PathVariable String email, @RequestBody User user) {
        if (!userRepository.exists(user.getEmail())) {
            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);
        }
        User saved = userRepository.save(email, user);
        return new ResponseEntity&lt;&gt;(saved, HttpStatus.CREATED);
    }

    @RequestMapping(value = "/user/{email}", method = RequestMethod.DELETE)
    public ResponseEntity&lt;User&gt; deleteUser(@PathVariable String email) {
        if (!userRepository.exists(email)) {
            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);
        }
        userRepository.delete(email);
        return new ResponseEntity&lt;&gt;(HttpStatus.OK);
    }
}</pre></div><p>You can see that we <a id="id329" class="indexterm"/>evolve towards the first level of RESTfulness but there is a lot of boilerplate code involved.</p></div><div class="section" title="Status codes with exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Status codes with exceptions</h2></div></div></div><p>Another way to handle errors in our <a id="id330" class="indexterm"/>API is to throw exceptions. There are two ways to map exceptions with Spring MVC:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using <code class="literal">@ExceptionHandler</code> at the class level, like we did for <code class="literal">IOException</code> in our upload controller in <a class="link" href="ch04.html" title="Chapter 4. File Upload and Error Handling">Chapter 4</a>, <span class="emphasis"><em>File Upload and Error Handling</em></span></li><li class="listitem" style="list-style-type: disc">Using <code class="literal">@ControllerAdvice</code> to catch global exceptions thrown by all controllers or a subset of your controllers</li></ul></div><p>These two options help you make some business-oriented decisions and define a set of practices within your application.</p><p>To associate these handlers with HTTP status codes, we can either inject the response in the annotated method and use the <code class="literal">HttpServletResponse.sendError()</code> method or just annotate the method with the <code class="literal">@ResponseStatus</code> annotation.</p><p>We will define our own exception, <code class="literal">EntityNotFoundException</code>. Our business repositories will throw this exception when the entity the user is working on cannot be found. This will help relieve the API code.</p><p>Here is the code for the <a id="id331" class="indexterm"/>exception. We can put it in a new package called <code class="literal">error</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.error;

public class EntityNotFoundException extends Exception {
    public EntityNotFoundException(String message) {
        super(message);
    }

    public EntityNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}</pre></div><p>Our repository will now throw exceptions in various locations. We will also differentiate between saving and updating a user:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user;

import masterSpringMvc.error.EntityNotFoundException;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Repository
public class UserRepository {
    private final Map&lt;String, User&gt; userMap = new ConcurrentHashMap&lt;&gt;();

    public User update(String email, User user) throws EntityNotFoundException {
        if (!exists(email)) {
            throw new EntityNotFoundException("User " + email + " cannot be found");
        }
        user.setEmail(email);
        return userMap.put(email, user);
    }

    public User save(User user) {
        return userMap.put(user.getEmail(), user);
    }

    public User findOne(String email) throws EntityNotFoundException {
        if (!exists(email)) {
            throw new EntityNotFoundException("User " + email + " cannot be found");
        }
        return userMap.get(email);
    }

    public List&lt;User&gt; findAll() {
        return new ArrayList&lt;&gt;(userMap.values());
    }

    public void delete(String email) throws EntityNotFoundException {
        if (!exists(email)) {
            throw new EntityNotFoundException("User " + email + " cannot be found");
        }
        userMap.remove(email);
    }

    public boolean exists(String email) {
        return userMap.containsKey(email);
    }
}</pre></div><p>Our controller becomes simpler since<a id="id332" class="indexterm"/> it doesn't have to handle the 404 status. We now throw the <code class="literal">EntityNotFound</code> exception from our controller methods:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user.api;

import masterSpringMvc.error.EntityNotFoundException;
import masterSpringMvc.user.User;
import masterSpringMvc.user.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api")
public class UserApiController {

    private UserRepository userRepository;

    @Autowired
    public UserApiController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @RequestMapping(value = "/users", method = RequestMethod.GET)
    public List&lt;User&gt; findAll() {
        return userRepository.findAll();
    }

    @RequestMapping(value = "/users", method = RequestMethod.POST)
    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {
        HttpStatus status = HttpStatus.OK;
        if (!userRepository.exists(user.getEmail())) {
            status = HttpStatus.CREATED;
        }
        User saved = userRepository.save(user);
        return new ResponseEntity&lt;&gt;(saved, status);
    }

    @RequestMapping(value = "/user/{email}", method = RequestMethod.PUT)
    public ResponseEntity&lt;User&gt; updateUser(@PathVariable String email, @RequestBody User user) throws EntityNotFoundException {
        User saved = userRepository.update(email, user);
        return new ResponseEntity&lt;&gt;(saved, HttpStatus.CREATED);
    }

    @RequestMapping(value = "/user/{email}", method = RequestMethod.DELETE)
    public ResponseEntity&lt;User&gt; deleteUser(@PathVariable String email) throws EntityNotFoundException {
        userRepository.delete(email);
        return new ResponseEntity&lt;&gt;(HttpStatus.OK);
    }
}</pre></div><p>If we don't handle this <a id="id333" class="indexterm"/>exception, Spring will throw a 500 error by default. To handle it we will create a small class in the error package, right next to our <code class="literal">EntityNotFoundException</code> class. It will be called <code class="literal">EntityNotFoundMapper</code> class and will be in charge of handling the exception:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.error;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

@ControllerAdvice
public class EntityNotFoundMapper {

    @ExceptionHandler(EntityNotFoundException.class)
    @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Entity could not be found")
    public void handleNotFound() {
    }
}</pre></div><p>The <code class="literal">@ControllerAdvice</code> annotation allows us to add some behaviors to a set of controllers by annotating a bean. Those controller advice can handle exceptions but also declare model attributes with <code class="literal">@ModelAttribute</code> or validator policies with <code class="literal">@InitBinder</code>.</p><p>With the code we just wrote, we handle all the <code class="literal">EntityNotFoundException</code> class thrown by our controllers in one place and associate it with the 404 status. That way, we can abstract this notion and ensure that our application will handle it consistently in all controllers.</p><p>We are not going to deal with hyperlinks in our API at our level. Instead, I encourage you to have a look at Spring HATEOAS and Spring Data REST, which provide very elegant solutions to make your<a id="id334" class="indexterm"/> resources more discoverable.</p></div></div>
<div class="section" title="Documentation with Swagger"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Documentation with Swagger</h1></div></div></div><p>Swagger<a id="id335" class="indexterm"/> is a really awesome project that will allow you to document and interact with your <a id="id336" class="indexterm"/>API within an HTML5 webpage. The following screenshot illustrates the API documentation:</p><div class="mediaobject"><img src="graphics/2117_05_04.jpg" alt="Documentation with Swagger"/></div><p>Swagger used to be big (written in Scala) and somewhat complicated to configure with a Spring setup. Since version 2.0, the library has been rewritten and a really neat project called <code class="literal">spring-fox</code> will allow for easy integration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>
<code class="literal">spring-fox</code>, formerly known as <code class="literal">swagger-springmvc</code>, has been in existence for more than three years and is still a very active project.</p></div></div><p>Add the following dependencies to your build file:</p><div class="informalexample"><pre class="programlisting">compile 'io.springfox:springfox-swagger2:2.1.2'
compile 'io.springfox:springfox-swagger-ui:2.1.2'</pre></div><p>The first one will provide an annotation to enable Swagger in your application as well as an API to describe your resources with annotations. Swagger will then generate a JSON representation of your API.</p><p>The second is a WebJar that contains static resources consuming the generated JSON through a web client.</p><p>The only thing you need to do now is add the <code class="literal">@EnableSwagger2</code> annotation to your <code class="literal">WebConfiguration</code> class:</p><div class="informalexample"><pre class="programlisting">@Configuration
<span class="strong"><strong>@EnableSwagger2</strong></span>
public class WebConfiguration extends WebMvcConfigurerAdapter {
 }</pre></div><p>The <code class="literal">swagger-ui.jar</code> file we just added contains an HTML file in <code class="literal">META-INF/resources</code>.</p><p>It will automatically be served by Spring Boot when you go to <code class="literal">http://localhost:8080/swagger-ui.html</code>.</p><p>By default, Springfox will scan your<a id="id337" class="indexterm"/> whole classpath and show all the request mappings declared in your application.</p><p>In our case, we only want to expose the API:</p><div class="informalexample"><pre class="programlisting">@Bean
public Docket userApi() {
    return new Docket(DocumentationType.SWAGGER_2)
        .select()
        .paths(path -&gt; path.startsWith("/api/"))
        .build();
}</pre></div><p>Springfox works with groups of <code class="literal">Docket</code>s that you have to define as beans in your configuration classes. They are logical grouping for RESTful resources. An application can have many of them.</p><p>Have a look at the<a id="id338" class="indexterm"/> documentation (<a class="ulink" href="http://springfox.github.io/springfox">http://springfox.github.io/springfox</a>) to see all the different setups available.</p></div>
<div class="section" title="Generating XML"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Generating XML</h1></div></div></div><p>RESTful APIs sometimes return<a id="id339" class="indexterm"/> responses in different media types (JSON, XML, and so on). The mechanism responsible for choosing the correct media type is known as content negotiation in Spring.</p><p>By default, in Spring MVC, the <code class="literal">ContentNegotiatingViewResolver</code> bean will be in charge of resolving the correct content according to the content negotiation policies defined in your application.</p><p>You can have a look at <code class="literal">ContentNegotiationManagerFactoryBean</code> to see how these policies are applied within Spring MVC.</p><p>Content type can be resolved with the following strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">According to the <code class="literal">Accept</code> header sent by the client</li><li class="listitem" style="list-style-type: disc">With a parameter such as <code class="literal">?format=json</code></li><li class="listitem" style="list-style-type: disc">With a path extension such as <code class="literal">/myResource.json</code> or <code class="literal">/myResource.xml</code></li></ul></div><p>You can customize these strategies in your Spring configuration by overriding the <code class="literal">configureContentNegotiation()</code> method of the <code class="literal">WebMvcConfigurerAdapter</code> class.</p><p>By default, Spring will use the <code class="literal">Accept</code> header and the path extension.</p><p>To enable XML serialization with Spring Boot, you can add the following dependency to your classpath:</p><div class="informalexample"><pre class="programlisting">compile 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml'</pre></div><p>If you explore your API with your browser and go to <code class="literal">http://localhost:8080/api/users</code>, you will see the result as XML, as follows:</p><div class="mediaobject"><img src="graphics/2117_05_05.jpg" alt="Generating XML"/></div><p>That's because <a id="id340" class="indexterm"/>your browser doesn't usually request JSON, but XML is second after HTML. This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_05_06.jpg" alt="Generating XML"/></div><p>To get JSON back, you can either go to <code class="literal">http://localhost:8080/api/users.json</code> or send the appropriate <code class="literal">Accept</code> header with Postman or httpie.</p></div>
<div class="section" title="The check point"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>The check point</h1></div></div></div><p>In this chapter, we <a id="id341" class="indexterm"/>added a search <code class="literal">ApiController</code> class. Because the tweets returned by the Twitter API were not adapted to our usage, we introduced a <code class="literal">LightTweet</code> class to transform them into a friendlier format.</p><p>We also developed a user API. The <code class="literal">User</code> class is the model. The users are stored and retrieved via the <code class="literal">UserRepository</code> class, and the <code class="literal">UserApiController</code> class exposes HTTP endpoints to perform CRUD operations on the users. We also added a generic exception and a mapper to associate the exception to an HTTP status.</p><p>In the configuration, we added a bean that documents our API, thanks to Swagger, and we customized the serialization of our JSR-310 dates. Our code base should look like the following:</p><div class="mediaobject"><img src="graphics/2117_05_07.jpg" alt="The check point"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to create a RESTful API with Spring MVC. This kind of backend yields great benefits in terms of performance and maintenance and can do wonders when coupled with a JavaScript MVC framework such as Backbone, Angular JS, or React.js.</p><p>We saw how to handle errors and exceptions properly and learned how to leverage the HTTP status to make a better API.</p><p>Finally we added automatic documentation with Swagger and added the ability to produce both XML and JSON.</p><p>In the next chapter, we will learn how to secure our application as well as use the Twitter API to sign our users up.</p></div></body></html>