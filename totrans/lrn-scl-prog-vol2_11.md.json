["```java\nval system = ActorSystem(\"SimpleActorSystem\") \nsystem.actorOf(Props[SimpleActor], \"simple-actor\") \n```", "```java\nval anotherSimpleActor = context.actorOf(Props[AnotherSimplActor], \"another-simple-actor\") \n```", "```java\ncontext.actorOf(Props[AnotherSimpleActor], \"another-simple-actor\") \n```", "```java\nakka://SimpleActorSystem/user/simple-actor/another-simple-actor \n```", "```java\nakka://SimpleActorSystem/user/simple-actor \n```", "```java\nval props = Props[SimpleActor]() \n  .withDispatcher(\"some-simple-dispatcher\") \n\nval simpleActor: ActorRef = system.actorOf(props, \"simple-actor\") \n```", "```java\nval simpleActor: ActorRef = system.actorOf(props, \"simple-actor\")\n```", "```java\ncontext.actorSelection(\"../siblingActor\") \n\ncontext.actorSelection(\"/user/siblingActor\") \n```", "```java\ncontext.actorSelection(\"akka://someActorSystem/user/*/LogicAActor\")\n```", "```java\n    import Dependencies._ \n\n    lazy val root = (project in file(\".\")). \n      settings( \n        inThisBuild(List( \n          organization := \"com.example\", \n          scalaVersion := \"2.12.3\", \n          version      := \"0.1.0-SNAPSHOT\" \n        )), \n        name := \"Hello\", \n        libraryDependencies += scalaTest % Test \n      ) \n```", "```java\nlibraryDependencies ++= Seq( \n  \"com.typesafe.akka\" %% \"akka-actor\" % \"2.5.8\", \n  \"com.typesafe.akka\" %% \"akka-testkit\" % \"2.5.8\", \n  \"org.scalatest\" %% \"scalatest\" % \"3.0.1\" % \"test\" \n  ) \nakka-actor specific dependency. The second is for testing Akka Actors. The last one is specific to Scala testing.\n```", "```java\nimport akka.actor.Actor \n\nclass SimpleActor extends Actor { \n\n  override def receive = Actor.emptyBehavior \n\n} \n```", "```java\nimport akka.actor.ActorSystem \n\nobject AkkaStarter extends App { \n\n  val simpleActorSystem = ActorSystem(\"SimpleActorSystem\") \n\n} \n```", "```java\nimport akka.actor.{Actor, ActorSystem, Props} \n\nclass SimpleActor extends Actor { \n  override def receive = Actor.emptyBehavior \n} \n\nobject SimpleActor { \n  val props = Props[SimpleActor] \n} \n\nobject AkkaStarter extends App { \n\n  val simpleActorSystem = ActorSystem(\"SimpleActorSystem\") \n\n  val simpleActor = simpleActorSystem.actorOf(SimpleActor.props) \n} \n```", "```java\nval simpleActor = simpleActorSystem.actorOf(SimpleActor.props, \"simple-actor\") \n```", "```java\ncase class Player(name: String, nationality: String, age:String, club: String, domesticLeague: String, rawTotal: String, finalScore: String, ranking2016: String, ranking2015: String) \n\nobject Util { \n\n  def bufferedSourceToList(source: BufferedSource): List[String] = { \n      val list = source.getLines().toList \n      source.close() \n      list \n  } \n\n  def asPlayers(listOfPlayersString: List[String]) : List[Player] = listOfPlayersString match { \n    case head :: tail => tail map {line => \n      val columns = line.split((\",\")).map(_.trim) \n      Player(columns(5),columns(6),columns(9),columns(7), \n        columns(8),columns(10), columns(12), columns(0),columns(2)) \n    } \n    case Nil => List[Player]() \n  } \n\n} \n```", "```java\nclass SimpleActor extends Actor { \n  import scala.io.Source \n  import SimpleActor.ShowFootballPlayersRequest \n  import Util._ \n\n  override def receive = { \n    case ShowFootballPlayersRequest(url) => { \n      val playersInfoSource = Source.fromFile(url) \n\n      val players = asPlayers(bufferedSourceToList(playersInfoSource)) \n      players.foreach(player => println(player + \"n\")) \n    } \n  } \n\n} \n\nobject SimpleActor { \n  val props = Props[SimpleActor] \n\n  final case class ShowFootballPlayersRequest(uri: String)\n }\n```", "```java\nval fileSource = \"/Users/vika/Workspace/akkaa/akka-starter/src/main/scala/files/football_stats.csv\" \n\nsimpleActor ! ShowFootballPlayersRequest(fileSource) \n!\", and passed an instance of ShowFootballPlayersRequest with the file source URI. This method, let's call it bang for now, in an ideal caseÂ goes to the actor's mailbox and delivers this message. This happens in a fire-and-forget manner. There's no guarantee of message delivery at the called actor's mailbox. There might be scenarios where you expect a response from called actors; in that case instead of calling bang*,* we make an ask call to our Actors.\n```", "```java\nfinal case class GetPlayerInformationRequest(name: String, source: List[Player]) \nfinal case class PlayerInformationResponse(player: Option[Player]) \n```", "```java\nimport scala.concurrent.Future \nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase GetPlayerInformationRequest(name, listOfPlayers) => { \n  log.info(s\"Executing GetPlayerInformationRequest($name, listOfPlayers)\")\n\nakka.pattern.pipe(\n Future.successful(PlayerInformationResponse(listOfPlayers.find(_.name.contains(name))))\n) to sender()\n\n}\n```", "```java\n    class SimpleActor extends Actor with ActorLogging\n```", "```java\n    akka.pattern.pipe(someFuture) to sender() \n```", "```java\n  import akka.pattern._ \n  someFuture pipeTo sender() \n```", "```java\n//Storing players in a collection! \nval players: List[Player] = Util \n  .asPlayers(bufferedSourceToList( \n    scala.io.Source.fromFile(fileSource) \n  )) \n```", "```java\nsimpleActor ? GetPlayerInformationRequest(\"Cristiano Ronaldo\", players) \n```", "```java\nimport akka.pattern.ask \n```", "```java\nimport akka.util.Timeout \nimport scala.concurrent.duration._ \n\nimplicit val timeout = Timeout(5 seconds) \n```", "```java\nval playerInformation = (simpleActor ? GetPlayerInformationRequest(\"Cristiano Ronaldo\", players)) \n\nplayerInformation \n  .mapTo[PlayerInformationResponse] \n  .map(futureValue => { \n      futureValue.player map println \n    }) \n```", "```java\nclass AnotherActor extends Actor { \n  override def receive = { \n    case ShowFootballPlayersRequest(url) => { \n      val playersInfoSource = Source.fromFile(url) \n\n      val players = asPlayers(bufferedSourceToList(playersInfoSource)) \n      players.foreach(player => println(player + \"n\")) \n    } \n  } \n} \n\nobject AnotherActor { \n  val props = Props[AnotherActor] \n} \n```", "```java\nclass SimpleActor extends Actor with ActorLogging { \n\n  implicit val ec = context.dispatcher \n  // Works as executionContext for actor calls \n\n  val anotherActor = context.actorOf(AnotherActor.props) \n\n  override def receive = { \n    case ShowFootballPlayersRequest(url) => { \n      anotherActor forward ShowFootballPlayersRequest(url) \n    } \n\n    case GetPlayerInformationRequest(name, listOfPlayers) => { \n      log.info(s\"Executing GetPlayerInformationRequest($name, listOfPlayers)\") \n\n      akka.pattern.pipe(       Future.successful(PlayerInformationResponse(listOfPlayers.find(_.name.contins(name)) ))\n) to sender() } } }\n```", "```java\npackage lsp \n\nimport lsp.SimpleActor.{GetPlayerInformationRequest, PlayerInformationResponse, ShowFootballPlayersRequest} \nimport akka.actor.{Actor, ActorLogging, ActorSystem, PoisonPill, Props} \nimport akka.pattern.ask \nimport scala.io.{BufferedSource, Source} \nimport akka.util.Timeout \nimport lsp.Util.{asPlayers, bufferedSourceToList} \nimport scala.concurrent.duration._ \nimport scala.concurrent.Future \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nclass SimpleActor extends Actor with ActorLogging { \n\n  val anotherActor = context.actorOf(AnotherActor.props) \n\n  override def receive = { \n    case ShowFootballPlayersRequest(url) => { \n      anotherActor forward ShowFootballPlayersRequest(url) \n    } \n\n    case GetPlayerInformationRequest(name, listOfPlayers) => { \n      log.info(s\"Executing GetPlayerInformationRequest($name, listOfPlayers)\") \n\n      akka.pattern.pipe( \n        Future { \n          PlayerInformationResponse(listOfPlayers.find(_.name.contains(name))) \n        } \n      ) to sender() \n\n    } \n\n  } \n\n} \nobject SimpleActor { \n  val props = Props[SimpleActor] \n\n  final case class ShowFootballPlayersRequest(uri: String) \n\n  final case class GetPlayerInformationRequest(name: String, source: List[Player]) \n  final case class PlayerInformationResponse(player: Option[Player]) \n} \n```", "```java\nclass AnotherActor extends Actor { \n  override def receive = { \n    case ShowFootballPlayersRequest(url) => { \n      val playersInfoSource = Source.fromFile(url) \n\n      val players = asPlayers(bufferedSourceToList(playersInfoSource)) \n\n      players.foreach(player => println(player)) \n    } \n  } \n\n} \nobject AnotherActor { \n  val props = Props[AnotherActor] \n} \n```", "```java\nobject AkkaStarter extends App { \n  import Util._ \n\n  implicit val timeout = Timeout(5 seconds) \n\n  val simpleActorSystem = ActorSystem(\"SimpleActorSystem\") \n  val simpleActor = simpleActorSystem.actorOf(SimpleActor.props, \"simple-actor\") \n\n  val fileSource = \n    \"/Users/vika/Workspace/akkaa/akka-starter/src/main/scala/files/football_stats.csv\" \n\n  //simpleActor ! ShowFootballPlayersRequest(fileSource) \n\n  //Storing players in a collection! \n  val players: List[Player] = Util \n    .asPlayers(bufferedSourceToList( \n      scala.io.Source.fromFile(fileSource) \n    )) \n\n  val playerInformation = (simpleActor ? GetPlayerInformationRequest(\"Cristiano Ronaldo\", players)) \n\n  playerInformation \n    .mapTo[PlayerInformationResponse] \n    .map(futureValue => { \n        futureValue.player map println \n      }) \n\n  simpleActor ! PoisonPill \n} \n```", "```java\nobject Util { \n\n  def bufferedSourceToList(source: BufferedSource): List[String] = { \n      val list = source.getLines().toList \n\n      source.close() \n      list \n  } \n\n  def asPlayers(listOfPlayersString: List[String]) : List[Player] = listOfPlayersString match { \n    case head :: tail => tail map {line => \n      val columns = line.split((\",\")).map(_.trim) \n      Player(columns(5),columns(6),columns(9),columns(7), \n        columns(8),columns(10), columns(12), columns(0),columns(2)) \n    } \n    case Nil => List[Player]() \n  } \n\n} \n\ncase class Player(name: String, nationality: String, age:String, club: String, \n                  domesticLeague: String, rawTotal: String, finalScore: String, \n                  ranking2016: String, ranking2015: String) \n```", "```java\n[INFO] [12/27/2017 14:40:48.150] [SimpleActorSystem-akka.actor.default-dispatcher-2] [akka://SimpleActorSystem/user/simple-actor] Executing GetPlayerInformationRequest(Cristiano Ronaldo, listOfPlayers) \nPlayer(Cristiano Ronaldo,Portugal,32,Real Madrid,Spain,4829,4789,1,2) \n```", "```java\ncase \"terminate\" => context stop self \n```", "```java\nsimpleActor ! PoisonPill \n```", "```java\noverride def preStart(): Unit = log.info(\"SimpleActor starting!\") \n\noverride def postStop(): Unit = log.info(\"SimpleActor stopping!\") \n```", "```java\n[INFO] [12/27/2017 14:56:54.887] [SimpleActorSystem-akka.actor.default-dispatcher-3] [akka://SimpleActorSystem/user/simple-actor] SimpleActor starting! \n[INFO] [12/27/2017 14:56:54.915] [SimpleActorSystem-akka.actor.default-dispatcher-2] [akka://SimpleActorSystem/user/simple-actor] Executing GetPlayerInformationRequest(Cristiano Ronaldo, listOfPlayers) \nPlayer(Cristiano Ronaldo,Portugal,32,Real Madrid,Spain,4829,4789,1,2) \n[INFO] [12/27/2017 14:56:54.938] [SimpleActorSystem-akka.actor.default-dispatcher-2] [akka://SimpleActorSystem/user/simple-actor] SimpleActor stopping! \n```", "```java\ncase class OneForOneStrategy( \n  maxNrOfRetries:              Int      = -1, \n  withinTimeRange:             Duration = Duration.Inf, \n  override val loggingEnabled: Boolean  = true) \n\ncase class AllForOneStrategy( \n  maxNrOfRetries:              Int      = -1, \n  withinTimeRange:             Duration = Duration.Inf, \n  override val loggingEnabled: Boolean  = true) \n```", "```java\nimport akka.actor.SupervisorStrategy.{Resume, Restart} \n\noverride val supervisorStrategy = \n  OneForOneStrategy( \n    maxNrOfRetries = 3, \n    withinTimeRange = 1 minute \n  ){ \n    case _: ArithmeticException => { \n      log.info(\"Supervisor handling ArithmeticException! n Resuming!\") \n      Resume \n    } \n    case _: Exception => { \n      log.info(\"Supervisor handling Exception! n Restarting!\") \n      Restart \n    } \n  } \n```", "```java\npackage example \n\nimport akka.actor.{Actor, ActorSystem, OneForOneStrategy, Props, ActorLogging} \nimport scala.concurrent.duration._ \n\nobject SupervisionStrategyInPractice extends App { \n  val system = ActorSystem(\"anActorSystem\") \n\n  val topLevelActor = system.actorOf(TopLevelActor.props) \n\n  //Sending StopIt \n  topLevelActor ! TopLevelActor.StopIt \n  //Sending RestartIt \n  topLevelActor ! TopLevelActor.RestartIt \n} \n\nclass TopLevelActor extends Actor with ActorLogging { \n  import akka.actor.SupervisorStrategy.{Resume, Restart \n\n  import TopLevelActor._ \n\n  override val preStart = log.info(s\"TopLevelActor started!\") \n  override val postStop = log.info(s\"TopLevelActor stopping!\") \n\n  val superSimpleActor = context.actorOf(SuperSimpleActor.props) \n\n  override def receive = { \n    case StopIt => superSimpleActor ! SuperSimpleActor.ArithmeticOpRequest \n    case RestartIt => superSimpleActor ! SuperSimpleActor.OtherMessage \n  } \n\n  override val supervisorStrategy = \n    OneForOneStrategy( \n      maxNrOfRetries = 3, \n\n      withinTimeRange = 1 minute \n    ){ \n      case _: ArithmeticException => { \n        log.info(\"Supervisor handling ArithmeticException! n Resuming!\") \n        Resume \n      } \n      case _: Exception => { \n        log.info(\"Supervisor handling Exception! n Restarting!\") \n        Restart \n      } \n    } \n} \n\n object TopLevelActor { \n  val props = Props[TopLevelActor] \n  case object StopIt \n  case object RestartIt \n} \n\nclass SuperSimpleActor extends Actor with ActorLogging { \n  import SuperSimpleActor._ \n\n  override val preStart = log.info(s\"SuperSimpleActor started!\") \n  override val postStop = log.info(s\"SuperSimpleActor stopping!\") \n\n  override def preRestart(reason: Throwable, message: Option[Any]): Unit = \n    log.info(s\"SuperSimpleActor restarting!\") \n\n  override def receive = { \n    case ArithmeticOpRequest => 1 / 0 \n    case OtherMessage => throw new Exception(\"Some Exception Occurred!\") \n  } \n\n} \n\nobject SuperSimpleActor { \n  val props = Props[SuperSimpleActor] \n\n case object ArithmeticOpRequest \n  case object OtherMessage \n\n} \n```", "```java\n[INFO] [12/28/2017 13:35:39.856] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] TopLevelActor started! \n[INFO] [12/28/2017 13:35:39.856] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] TopLevelActor stopping! \n[INFO] [12/28/2017 13:35:39.857] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor started! \n[INFO] [12/28/2017 13:35:39.857] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor stopping! \n[INFO] [12/28/2017 13:35:39.864] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] Supervisor handling ArithmeticException!  \n Resuming! \n[WARN] [12/28/2017 13:35:39.865] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a/$a] / by zero \n[INFO] [12/28/2017 13:35:39.867] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] Supervisor handling Exception!  \n Restarting! \n[ERROR] [12/28/2017 13:35:39.868] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a/$a] Some Exception Occurred! \njava.lang.Exception: Some Exception Occurred! at example.SuperSimpleActor$$anonfun$receive$2.applyOrElse(SupervisionStrategyInPractice.scala:66) \n   at akka.actor.Actor.aroundReceive(Actor.scala:517) \n   at akka.actor.Actor.aroundReceive$(Actor.scala:515) \n   at example.SuperSimpleActor.aroundReceive(SupervisionStrategyInPractice.scala:55) ... \n[INFO] [12/28/2017 13:35:39.868] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor restarting! \n[INFO] [12/28/2017 13:35:39.871] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor started! \n[INFO] [12/28/2017 13:35:39.871] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor stopping! \n```", "```java\npackage lsp \n\nimport akka.actor.ActorSystem \nimport akka.testkit.{ImplicitSender, TestKit} \nimport lsp.SimpleActor.{GetPlayerInformationRequest, PlayerInformationResponse} \nimport org.scalatest.{BeforeAndAfterAll, WordSpecLike} \n\nclass SimpleActorSpec extends TestKit(ActorSystem(\"testActorSystem\")) \n  with ImplicitSender with WordSpecLike with BeforeAndAfterAll { \n\n  override def afterAll(): Unit = super.afterAll() \n\n  val players = List(Player(\"Cristiano Ronaldo\", \"Portuguese\", \"32\", \"Real Madrid\", \"La Liga\", \"1999\", \"1999\", \"1\", \"1\")) \n\n  \"SimpleActor\" must { \n\n    \"test for PlayerInformationRequest\" in { \n\n      val simpleActor = system.actorOf(SimpleActor.props) \n\n      simpleActor ! GetPlayerInformationRequest(\"Cristiano Ronaldo\", players) \n\n      val expectedResponse = \n        PlayerInformationResponse(Some(Player(\"Cristiano Ronaldo\", \"Portuguese\", \"32\", \"Real Madrid\", \"La Liga\", \"1999\", \"1999\", \"1\", \"1\"))) \n\n      expectMsg(expectedResponse) \n    } \n\n  } \n\n} \n```", "```java\nclass SimpleActorSpec extends TestKit(ActorSystem(\"testActorSystem\")) \n  with ImplicitSender with WordSpecLike with BeforeAndAfterAll \n```", "```java\n      simpleActor ! GetPlayerInformationRequest(\"Cristiano Ronaldo\", players) \n```"]