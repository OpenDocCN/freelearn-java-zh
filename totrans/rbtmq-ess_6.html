<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Taking RabbitMQ to Production
                </header>
            
            <article>
                
<p>At this point, <strong>Complete Car </strong>(<strong>CC</strong>) is running a single instance of RabbitMQ in production. Now CC also needs to ensure that the service is highly available. Creating clusters of nodes ensures that information is reachable even if systems go down. This chapter covers how to set up RabbitMQ clusters, including coverage of broker clustering, classic mirrored queues, and quorum queues. CC is also looking for a new elegant solution for log aggregation, where all logs are published to a centralized RabbitMQ node through the federation plugin, so this chapter will cover this topic as well.</p>
<p>To achieve CC's goal of nearly constant uptime, the topics in this chapter will include the following:</p>
<ul>
<li>Adding nodes to the cluster</li>
<li>Discovering the types of RabbitMQ queues</li>
<li>Using federated brokers and log aggregation</li>
</ul>
<h1 id="uuid-2a1da3be-7a49-4b74-a7c9-82e8719a960b"><span class="fontstyle0">Technical requirements</span></h1>
<p class="mce-root">The code files of this chapter can be found on GitHub at<span> <a href="https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter06">https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter06</a></span>.</p>
<h1 id="uuid-f8396427-c83d-4837-a539-7e4c9415cbfa">Adding nodes to the cluster</h1>
<p>Things have been running smoothly for CC, but developers want to ensure that the system can survive a crash. A crash is always possible, even when using RabbitMQ. Power outages happen, sudden packet losses may corrupt updates, and administrators can improperly configure the system by accident. There is still a chance that, due to a glitch or error, an entire instance could be lost. Steps must be taken to address any issues that could lead to data loss, negative customer experience, or even the dreaded 2 a.m. phone call to the team.</p>
<p>The good news is that RabbitMQ provides the features needed to deal with potential crashes and other catastrophes right out of the box. RabbitMQ can be configured to run in an active-active deployment environment, meaning that two or more nodes actively run the same kind of service simultaneously. Several brokers can be engaged in a cluster to act as a single highly available <strong>Advanced Message Queuing Protocol</strong> (<strong>AMQP</strong>) service.</p>
<p>There is no need to resort to manual failover when using active-active deployment. No operation is needed if a broker goes down, sparing the team that 2 a.m. phone call. Depending on the number of active nodes in the high-availability cluster, a cluster can sustain several failures.</p>
<p>To avoid complications resulting from an unreachable broker, CC decides to start by rolling out a second RabbitMQ instance (named <span class="packt_screen">rmq-prod-2</span>), clustering it with the one already used in production.</p>
<p>A RabbitMQ cluster is a logical grouping of one or several nodes, each sharing users, virtual hosts, queues, exchanges, and so on. The system architecture changes only inside the cluster, as seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-861 image-border" src="assets/4f35e1a1-09c1-4582-8569-3d7f1e9425c4.png" style="width:40.92em;height:18.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Fig 6.1: A high-availability cluster of many RabbitMQ brokers</div>
<div>
<p>More nodes are added into the RabbitMQ cluster. CC informs the team when the second instance of RabbitMQ is ready to be clustered with the existing one. To make this happen, the Erlang clustering feature will be used with RabbitMQ to allow local or remote communication between several Erlang nodes. Erlang clustering uses a security cookie as the mechanism for cross-node authentication. To avoid errors, the developers have made sure that the content of <kbd>/var/lib/rabbitmq/.erlang.cookie</kbd> is the same in each instance.</p>
</div>
<div class="mce-root packt_infobox">Note that a cluster will not work if a firewall blocks the RabbitMQ instances from communicating with each other. If that happens, open the specific ports used by AMQP (defaulting to <kbd>5672</kbd>) so that the cluster will work. Get more information at, <a href="http://www.rabbitmq.com/clustering.html#firewall">http://www.rabbitmq.com/clustering.html#firewall</a>.</div>
<p>There is no need to configure any users or virtual hosts on the second node as done in <a href="4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml">Chapter 1</a>, <em>A Rabbit Springs to Life</em>. Just join the cluster and the configuration will automatically synchronize with the existing RabbitMQ instance, including users, virtual hosts, exchanges, queues, and policies.</p>
<div class="mce-root packt_tip">Keep in mind that a node completely resets when it joins a cluster. RabbitMQ deletes all configuration and data before synchronizing with the other nodes.</div>
<p>To join a node to a cluster, first stop RabbitMQ, then join the cluster, and finally restart the RabbitMQ application:</p>
<pre>$ sudo rabbitmqctl stop_app<br/># =&gt; Stopping node rabbit@rmq-prod-2 ...<br/># =&gt; ...done.<br/>$ sudo rabbitmqctl join_cluster rabbit@rmq-prod-1<br/># =&gt; Clustering node rabbit@rmq-prod-2 with rabbit@rmq-prod-1 ...<br/># =&gt; ...done.<br/>$ sudo rabbitmqctl start_app<br/># =&gt; Starting node rabbit@rmq-prod-2 ...<br/># =&gt; ...done.</pre>
<p>Make sure the same major version of Erlang is used by all the RabbitMQ nodes or the <kbd>join_cluster</kbd> command might fail. It is possible to run a cluster with mixed Erlang versions, but there can be incompatibilities that will affect cluster stability.</p>
<p>RabbitMQ also requires the use of the same major/minor version across nodes up to and including 3.7.x. It is possible to run different patch versions (for example, 3.7.X and 3.7.Y) most of the time, except when indicated otherwise in the release notes.</p>
<div class="packt_tip">Feature flags is a mechanism new to RabbitMQ version 3.8. These flags define a RabbitMQ node's ability to become a part of a cluster. Feature flags control which features are considered enabled or available on all cluster nodes, so nodes using the subsystem must have the same dependencies. Read more at <a href="https://www.rabbitmq.com/feature-flags.html">https://www.rabbitmq.com/feature-flags.html</a>.</div>
<p>After running the preceding commands, check to see whether the cluster is active by running the <kbd>cluster_status</kbd> command on any node:</p>
<pre>$ sudo rabbitmqctl cluster_status <br/># =&gt; Cluster status of node rabbit@rmq-prod-1 # -&gt; <br/># =&gt; [{nodes,[{disc,[rabbit@rmq-prod-2,rabbit@rmq-prod-1]}]}, {running_nodes,[rabbit@rmq-prod-2,rabbit@rmq-prod-1]}, {partitions,[]}]<br/># =&gt; ...done.</pre>
<p>Notice how two lists of nodes are given in the status message. In this case, the nodes are the list of configured nodes in the cluster. The list named <kbd>running_nodes</kbd> contains those that are actually active. Configured nodes are persistent, meaning they will survive broker restarts since each broker automatically re-engages with the cluster.</p>
<p>Confirm that the new node will synchronize with the cluster by connecting to the management console on another node (<span class="packt_screen">rmq-prod-2</span>). Use the <span class="packt_screen">cc-admin</span> user to log in and go to the <span class="packt_screen">Queues</span> view.</p>
<p>The configuration should be synchronized as shown in the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-676 image-border" src="assets/8cdb6780-a35f-4970-b496-94435efaa7b4.png" style="width:128.42em;height:50.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 6.2: All configurations are synchronized after joining the cluster</div>
<p>To add more nodes, let each new node join another node in the cluster. The <span class="packt_screen">Overview</span> tab in the management console of the first node shows all the nodes that are in the cluster, which are automatically discovered, as shown in the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-677 image-border" src="assets/41c7dd44-7b0f-46f6-bbe1-df5bea88519e.png" style="width:146.92em;height:58.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.3: The management console overview shows all cluster members</div>
<p>As shown, all members of the cluster are listed along with basic statistics and ports. The different values shown in the <strong>Info</strong> column are as follows:</p>
<ul>
<li><span class="packt_screen">basic</span>: Describes the <kbd>rates_mode</kbd>, which tells how the queues report statistics. This can be one of <kbd>basic</kbd> (the default), <kbd>detailed</kbd>, or <kbd>none</kbd>.</li>
<li><span class="packt_screen">disc</span>: Means that the node persists data to the filesystem, which is the default behavior. It is also possible to start a node in <strong>RAM</strong> mode, where all message data is stored in memory, which can speed up systems provided that they have enough memory.</li>
<li><span class="packt_screen">7</span>: Shows the number of plugins that are enabled.</li>
<li><span class="packt_screen">allocated</span>: Describes the memory calculation strategy.</li>
</ul>
<p>Nodes can be removed (<a href="http://www.rabbitmq.com/clustering.html#breakup">http://www.rabbitmq.com/clustering.html#breakup</a>) from the cluster through <kbd>rabbitmqctl</kbd>, the command-line tool for managing a RabbitMQ server node.</p>
<p>All CC applications are currently connecting to one single RabbitMQ node. This needs to be modified. Applications should try to connect to one node first and fail over to another node if the original attempt fails. Read on to see how that is done.</p>
<h2 id="uuid-e0abafe9-87f8-404e-8673-d4629e1b9600">Connecting to the cluster</h2>
<p>All CC applications currently connect to a single RabbitMQ node, which needs to be modified to benefit from the advantages of the cluster. All applications connecting to RabbitMQ need to be modified. The applications should try to connect to one node first, failing over to another if the original attempt fails. This is the only required change; the applications will interact with the broker as they did before.</p>
<p>First, modify the main application connection Ruby code as follows:</p>
<pre>begin<br/>  connection = Bunny.new(<br/>    hosts: ['rmq-prod-01', 'rmq-prod-02'])<br/>  connection.start<br/>  rescue Bunny::TCPConnectionFailed =&gt; e<br/>    puts "Connection to server failed"<br/>end</pre>
<p class="mce-root">Basically, the list of broker addresses is passed. With this in place, the RabbitMQ Ruby client will connect to the first responsive node in the address list and will try each of the provided broker addresses until it can establish a connection or eventually fails. In the case of failure, the overall reconnect mechanism that's already in place will kick in and the addresses will once again be attempted for connection.</p>
<div class="packt_tip">It is possible to manually synchronize a mirrored queue using the <kbd>rabbitmqctl sync_queue &lt;queue_name&gt;</kbd> <span>command. </span>Cancel the synchronization with <kbd>rabbitmqctl cancel_sync_queue &lt;queue_name&gt;</kbd>.</div>
<div>
<p>At this point, there is only one more step to perform to ensure the high availability of the queue data: enabling a way to spread the data to the other node(s). The options available are <strong>classic mirrored queues</strong> and <strong>quorum queues</strong>. But first, some partition handling strategies.</p>
</div>
<h2 id="uuid-7f533389-6751-4401-8f9d-c52b78461f36">Partition handling strategies</h2>
<p>Adding even more nodes to the cluster is of course possible. However, this brings a new challenge in the form of network connectivity. Split-brains and early message confirmation are common issues when using more than one node. Split-brains occur in distributed systems when a portion of the network becomes unreachable from another portion, creating network partitions (called a <strong>netsplit</strong>). To avoid this situation, set a partition handling strategy. In RabbitMQ, this is set through the <kbd>cluster_partition_handling</kbd> parameter in the configuration file – <a href="https://www.rabbitmq.com/partitions.html#automatic-handling">https://www.rabbitmq.com/partitions.html#automatic-handling</a>.</p>
<p>The <strong>pause-minority</strong> strategy terminates nodes in the minority partition. This is the default way to resolve split-brains in many distributed networks. The <strong>pause-if-all-down</strong> feature only pauses a node if none are reachable. This is inadvisable as it creates large discrepancies between the data in each partition.</p>
<p>Once nodes become available in the <strong>pause-if-all-down</strong> setting, two more options are available to specify how to reconnect the network. Simply ignore another partition or auto-heal the cluster. The nodes the system cannot pause must also be specified. In the <strong>pause-minority</strong> strategy, the partitions reconnect when available.</p>
<p>RabbitMQ ensures synchronization across clusters. Clients can reach their exchanges and queues over any node; however, the messages themselves are not carried over. The next section covers how that can be done.</p>
<h1 id="uuid-8c00c992-2996-4976-93af-de11e5e9e5c1">Discovering the types of RabbitMQ queues</h1>
<p>Queues in RabbitMQ can be durable or transient. Classic mirrored queues are recommended for transient message handling, while quorum queues are a good alternative for durable queues. </p>
<p>Durable queue metadata is stored on disk while a transient queue stores it in memory, when possible. Another queue type, lazy queues, writes the contents to disk as early as possible for both durable and transient messages.</p>
<p>Due to technical limitations in classic mirrored queues, it is difficult to make guarantees on how failures are handled. The RabbitMQ documentation (<a href="https://www.rabbitmq.com/ha.html">https://www.rabbitmq.com/ha.html</a>) recommends that users get familiar with quorum queues and consider them instead of classic mirrored queues where possible.</p>
<h2 id="uuid-96a468c3-0873-4d69-b75f-389ca2d0c6cc">Mirroring queues</h2>
<p>In the case of CC, the data in the queues needs to be highly available. Mirrored queues provide this type of security. Queue mirroring uses a master-mirror design pattern. All message queuing and dequeuing actions happen with the master, and the mirrors receive the updates periodically from the master. If a master becomes unavailable, RabbitMQ promotes a mirror to a master; usually, the oldest mirror becomes the new master, as long as it is synchronized.</p>
<div class="packt_infobox">It is also possible to set up a master-master system by sending data to a different cluster in addition to the original. This provides a useful backup for hardware updates and extreme cases of failure. It can also help speed up interaction in different geographic regions.</div>
<p>Telling the cluster how to mirror queues must in our case be done via the <kbd>Q_TTL_DLX</kbd> policy since only one policy at a time is allowed in a queue or exchange. The first step is to clear the policy created in <a href="bece97d2-6653-459f-bbdc-6e47f343c1d3.xhtml">Chapter 4</a>, <em>Tweaking Message Delivery,</em> then applying a new policy combining the <kbd>Q_TTL_DLX</kbd> policy with one created for queue mirroring.</p>
<p>Run the following commands to change the <kbd>Q_TTL_DLX</kbd> policy and tell RabbitMQ how to mirror queues. Start by clearing the policy:</p>
<pre>$ sudo rabbitmqctl clear_policy -p cc-prod-vhost Q_TTL_DLX<br/># =&gt; Clearing policy "Q_TTL_DLX"<br/># =&gt; ......done.<br/>"Specify the new HA_Q_TTL_DLX policy:"<br/>$ sudo rabbitmqctl set_policy -p cc-prod-vhost HA_Q_TTL_DLX "taxi\.\d+" '{"message-ttl":604800000, "dead-letter-exchange":"<span>taxi-dlx</span>", "ha-mode":"all", "ha-sync-mode":"automatic"}' --apply-to queues <br/># =&gt; Setting policy "HA_Q_TTL_DLX" for pattern "taxi\.\d+" to "{\"ha-mode\":\"all\", \"message-ttl\":604800000, \"dead-letter-exchange\":\"taxi-dlx\"}" with priority "0" <br/># =&gt; ......done.</pre>
<p>Alternatively, add the policy from the management console, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-678 image-border" src="assets/0c6e86cc-eba3-4ca7-8762-804519431010.png" style="width:113.67em;height:58.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.4: Policy added via the RabbitMQ management console</div>
<p>High availability mode has been added to the existing <span class="packt_screen">TTL</span> and <span class="packt_screen">DLX</span> policy rules. The <span class="packt_screen">all</span> value for <span class="packt_screen">ha-mode</span> tells RabbitMQ to mirror queues across all nodes in the cluster, which is exactly what CC wants in their two-node cluster. The other options are <span class="packt_screen">exactly</span> and <span class="packt_screen">nodes</span>, allowing developers to specify the number of nodes when using the exact option and a list of node names when using the <span class="packt_screen">nodes</span> option through the <span class="packt_screen">ha-params</span> parameters.</p>
<p>The <span class="packt_screen">ha-sync-mode</span> parameter is used to specify the synchronization mode for the mirrored queue. This parameter can be set to <span class="packt_screen">manual</span> or <span class="packt_screen">automatic</span>. In manual mode, a newly mirrored queue will not receive any existing messages but will eventually become consistent with the master queue as consumers retrieve messages. This reduces overhead at the cost of losing information. Automatic mode sends messages to each queue, meaning a small hit to the system performance. </p>
<p>CC decides to use immediate queue synchronization so that any existing messages become visible across all nodes nearly instantaneously. CC is fine with the initial unresponsiveness this creates since performance is not critical for user messages.</p>
<p>Navigate to the <span class="packt_screen">Queues</span> tab in the management console after running the preceding command. Observe that the <span class="packt_screen">HA_Q_TTL_DLX</span> policy has been applied to the intended queues:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-679 image-border" src="assets/a7c157a8-f91e-493b-a1cb-8d6574d9db2d.png" style="width:42.92em;height:16.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.5: Mirrored queues with the high availability policies applied</div>
<p class="mce-root"><span>Notice how the mirrored queues have a</span> <span class="packt_screen"><strong>+1</strong></span> <span>next to them. This denotes the fact that the queues are mirrored to another node in the cluster. The master (</span><span class="packt_screen">rabbit@rmq-prod-1</span><span>) and the mirror nodes (</span><span class="packt_screen">rabbit@rmq-prod-2</span><span>) are clearly defined in the</span> <span class="packt_screen">Details</span> <span>section of each queue in the management console as well, as seen in the following screenshot:</span></p>
<div>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-680 image-border" src="assets/7ecc5ce1-9149-4f2e-afa5-558f7ca32c7a.png" style="width:42.25em;height:17.83em;"/></p>
</div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Fig </span>6.6: Master and mirror nodes are detailed</div>
<p>At this point, the RabbitMQ brokers are clustered and taxi order request queues are mirrored. Client applications can benefit from this highly available deployment and connect to different nodes.</p>
<div class="packt_infobox"><strong>Setting the Master Queue Location</strong>: Every queue has a primary replica known as the queue master. This queue is the first to receive messages before synchronization. It is possible to influence how this is set using the <span class="packt_screen">x-queue-master-locator</span> parameter in the <span class="packt_screen">Queues</span> tab of the management console or when creating a queue programmatically.</div>
<p><span>Quorum queues are a new type of queue, often recommended over classic mirrored queues.</span></p>
<h2 id="uuid-95608434-85df-4d51-a176-1b31d9f49701">Quorum queues</h2>
<p>As an alternative to durable mirrored queues, quorum queues ensure that the cluster is up to date by agreeing on the contents of a queue. In doing so, quorum queues avoid losing data, which could occur with mirrored queues when messages are confirmed too early. Quorum queues are available as of RabbitMQ 3.8.0. As detailed in the RabbitMQ documentation (<a href="https://www.rabbitmq.com/quorum-queues.html">https://www.rabbitmq.com/quorum-queues.html</a>), some transient features are not available when using quorum queues.</p>
<p>A quorum queue has a leader that roughly serves the same purpose as it did for the classic mirrored queue master. All communication is routed to the queue leader, which means the queue leader locality has an effect on the latency and bandwidth requirement of the messages; however, the effect should be lower than it was in classic mirrored queues.</p>
<p>In quorum queues, the leader and replication are consensus-driven, which means they agree on the state of the queue and its contents. While mirrored queues may confirm messages too early and lose data, quorum queues will only confirm when the majority of its nodes are available, which thereby avoids data loss. </p>
<p>Declare a quorum queue using the following command:</p>
<pre>rabbitmqadmin declare queue name=&lt;name&gt; durable=true arguments='{“x-queue-type”: “quorum”}'</pre>
<p>These queues must be durable and instantiated by setting the <kbd>x-queue-type</kbd> header to <kbd>quorum</kbd>. If the majority of nodes agree on the contents of a queue, the data is valid. Otherwise, the system attempts to bring all queues up to date.</p>
<p>Quorum queues have support for the handling of poison messages, which are messages that are never consumed completely or positively acknowledged.</p>
<p>The number of unsuccessful delivery attempts can be tracked and displayed in the <kbd>x-delivery-count</kbd> header. A poison message can be dead-lettered when it has been returned more times than configured.</p>
<p>Lazy queues are another queue type worth exploring, so read on.</p>
<h2 id="uuid-a06c22b7-69b9-43be-815f-d373e5512e1c">Lazy queues</h2>
<p>Queues can become long for various reasons including consumer maintenance or the arrival of large batches of messages. While RabbitMQ can support millions of messages, keeping queues as short as possible is recommended by most experts. Messages are stored in memory by default. RabbitMQ then flushes messages (page out) to free up the RAM usage when the queue becomes too long for the underlying instance to handle. Storing messages in RAM enables faster delivery of messages to consumers than storing them to disk.</p>
<p>The page out function usually takes time and often stops the queue from processing messages, which deteriorates the queue speed. For this reason, queues that contain a lot of messages can have a negative impact on the broker's performance. Additionally, it takes a lot of time to rebuild the index after a cluster is restarted and to sync messages between nodes.</p>
<p>Beginning with RabbitMQ version 3.6, a policy called lazy queues was added to enable the storage of messages to disk automatically in order to minimize RAM usage. Lazy queues can be enabled by setting the mode via the <kbd>queue.declare</kbd> arguments or by applying a policy to all queues. </p>
<div class="packt_infobox">Persistent messages can be written to the disk as they enter the broker and be kept in RAM at the same time.</div>
<p>Different queue types have been shown, and it's time to look into how CC should handle log aggregation from all clusters.</p>
<h1 id="uuid-9fd0d706-4fe7-4161-ba78-7bf14e100701">Using federated brokers and log aggregation</h1>
<p>The way a cluster of two RabbitMQ brokers is created is really similar to what is typically done when making a relational database highly available. The database remains a centralized resource offering high guarantees of availability. Still, RabbitMQ is not a one-trick rabbit when it comes to high availability. </p>
<p>To form a picture of a RabbitMQ system, the following two plugins allow broker connection:</p>
<ul>
<li><strong>Shovel</strong>: Connects queues and exchanges between different brokers</li>
<li><strong>Federation</strong>: Forms cross-broker connections for queues to queues, or exchanges to exchanges</li>
</ul>
<p>Both plugins ensure the reliable delivery of messages across brokers by routing them as instructed or offering a safe place for them to remain until they can be dealt with. Neither requires the brokers to be clustered, which simplifies setup and management. Moreover, both plugins work fine over WAN connections, which isn't the case in a clustering scenario.</p>
<p>Configure the destination node in a federation manually. The upstream nodes are configured automatically. On the other hand, shovels must have each source node configured manually to send to a destination node, which itself doesn't require any configuration.</p>
<p>The CC team is requesting a good way to process logs, and they quickly realize that the federation plugin suits the process well.</p>
<h2 id="uuid-c1d3a547-bf54-4e13-9bb3-f2ac3f3c787a">Handling log processing </h2>
<p>CC's system is growing and growing, and so is the team of taxi drivers and developers. The team that is in charge of analytics has been looking for an elegant solution to aggregate logs from different applications in order to roll out new statistics, both for internal and end-user consumption. Fortunately, RabbitMQ can be used for application log processing thanks to its high performance.</p>
<p>In this topology, all applications will write to a local RabbitMQ node, which will act as a store-and-forward broker, pushing all logs to a centralized RabbitMQ node as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-681 image-border" src="assets/0e4ea0d7-dc9c-4cd4-bd9d-79f54c14dedd.png" style="width:36.75em;height:23.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Fig </span>6.7: A topology that federates log messages to a central broker</div>
<p>If this central node is down, the log entries will remain locally accumulated until it comes back up. Messages flow through an exchange in one location (called the <strong>upstream</strong>) to be replicated to exchanges in other locations (the <strong>downstream</strong>), as seen in the following diagram:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-682 image-border" src="assets/b8e50b47-c62f-43b2-805b-433ad9bcc1ff.png" style="width:40.25em;height:11.67em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.8: Exchange federation message flow</div>
<p>Obviously, the assumption here is that the local RabbitMQ nodes are extremely stable. The experience with running RabbitMQ in the past few months will help with this approach. Moreover, logs are considered important but not critical data for CC, so a best-effort approach is acceptable. Knowing this, the team chooses to use the federation plugin, as it's the one that supports federation to queue connectivity (with the shovel plugin, messages would have to be accumulated in a local queue on each node).</p>
<p>Remember, all queues that were mirrored in the previous section were queues that matched the <kbd>taxi-inbox\.\d+</kbd> regex pattern. All log queues mentioned now are left out of the equation. That's how the CC team wants it, as they don't want to mirror such highly trafficked queues. What could be done in order for CC to enjoy the same guarantees for log aggregation? Enter the notion of messaging topologies.</p>
<div class="mce-root packt_infobox">More information on the shovel plugin can be found at <a href="http://www.rabbitmq.com/shovel.html">http://www.rabbitmq.com/shovel.html</a>.</div>
<div class="CDPAlignLeft CDPAlign">
<p>The federation plugin needs to be installed on all RabbitMQ nodes that will engage in the topology by running the following commands on each node:</p>
<pre> $ sudo rabbitmq-plugins enable rabbitmq_federation <br/>Applying plugin configuration to rabbit@app-prod-1...<br/><br/>$ sudo rabbitmq-plugins enable rabbitmq_federation_management<br/>Applying plugin configuration to rabbit@app-prod-1...</pre>
<p>Moreover, unlike with clustering, each node needs to be manually set up to have the desired user and virtual host configured. As discussed in <a href="4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml">Chapter 1</a>, <em>A Rabbit Springs to Life</em>, it is time to run the necessary command. Next, the <kbd>apps-log</kbd> exchange federation itself must be configured. This involves multiple steps (detailed shortly) that are all run on the central broker, the one toward which all logs will converge, the downstream.</p>
<p>First, the upstreams are configured, which are the RabbitMQ nodes that will send data to the central broker. Three upstreams are needed since there are three servers that will send logs, <kbd>app-prod-1</kbd>, <kbd>app-prod-2</kbd>, and <kbd>app-prod-3</kbd>; however, in the interest of brevity, only two nodes will be shown in the following example.</p>
<p>An upstream can be added via <kbd>rabbitmqctl</kbd>:</p>
<pre><span class="hljs-comment"># Adds a federation upstream named "app-prod-logs"</span>
rabbitmqctl -p logs-prod set_parameter federation-upstream app-prod-logs <span class="hljs-string">'{"uri":"amqp://cc-prod:******@app-prod-1:5672/cc-prod-vhost"}'</span></pre></div>
<p>Alternatively, the policy can be added via the management console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-683 image-border" src="assets/492e034a-7261-4b8d-bd87-4ee399fe4e3b.png" style="width:134.25em;height:56.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.9: Add a federation upstream named app-prod-logs to the downstream broker</div>
<p class="mce-root">Once an upstream has been specified in the downstream, a policy that controls the federation can be added to the downstream server as well. The <span class="packt_screen">app-prod-logs</span> federation is added just like any other policy (<a href="https://www.rabbitmq.com/parameters.html#policies">https://www.rabbitmq.com/parameters.html#policies</a>) by using the terminal:</p>
<pre>rabbitmqctl set_policy -p logs-prod --apply-to exchanges log-exchange-federation "^app-logs*" '{"federation-upstream-set":"all"}' --apply-to exchanges</pre>
<p>The policy can also be added through the management console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-684 image-border" src="assets/1049fad9-ee30-4263-8790-44fd71eee88e.png" style="width:166.92em;height:96.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.10: Federation policy added to the downstream server</div>
<p>The CC team does this by applying a policy that matches the exchange names. The pattern argument is a regular expression used to match queue (or exchange) names. In CC's case, the federation policy is applied to all exchanges with names beginning with <kbd>app-prod</kbd>.</p>
<p>A policy can apply to an upstream set or to a single exchange or queue upstream. In this example, <kbd>federation-upstream-set</kbd> is applied to all upstreams.</p>
<div class="packt_tip packt_infobox">
<p>If it is certain that there will never be more than one logical group of upstreams, the creation of an upstream set is skipped in favor of using the implicit set named <kbd>all</kbd>, which automatically contains all the upstreams in a virtual host.</p>
</div>
<p>In this case, it is good to make sure that the user that the federation plugin will use in the central broker to interact with the federated exchange is also configured.</p>
<p>Browse to the <strong><span class="packt_screen">Federation Upstreams</span></strong> tab in the <span class="packt_screen">Admin</span> section of the management console, which will show that the upstream has been correctly configured, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-685 image-border" src="assets/36c5915b-6424-4c89-90c1-0f61ed9f410b.png" style="width:198.75em;height:60.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.11: Upstream nodes are configured in a federation</div>
<p>Switching to <strong>Federation Status</strong> shows an empty screen as it's inactive. Why is that? After all, the topology was just created. The reason is that no exchange or queue is actively engaged in the topology yet. Because of its dynamic nature, the federation is inactive. Creating the <span class="packt_screen">app-logs</span> exchange on both the upstream and the downstream servers and binding the <span class="packt_screen">app-logs</span> exchange to queues is the next step before returning to the <span class="packt_screen">Federation Status</span> tab. It is here noted that the federation is now running links for the <span class="packt_screen">app-logs</span> exchange from the two upstream nodes of the configured set. See the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-686 image-border" src="assets/44088094-165a-49eb-8770-b0ca2dcfb5f4.png" style="width:206.83em;height:89.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Fig </span>6.12: Running upstream links for a federated exchange</div>
<div class="packt_tip">
<p>It's possible to get the status of the federation from the command line by running <kbd>sudo rabbitmqctl eval rabbit_federation_status:status()</kbd> on the downstream node.</p>
</div>
<p class="mce-root">The <span class="packt_screen">Connections</span> and <span class="packt_screen">Channels</span> tabs of the management console now show that the downstream node is connected to the upstream node over the AMQP protocol, as seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-687 image-border" src="assets/b5739316-b32d-44c0-88d7-1ce4267bd0c8.png" style="width:188.75em;height:71.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Fig </span>6.13: Federation link in the Connections tab</div>
<p>Except for the setup of the topology itself, there's nothing magical about the federation. It's been built on top of AMQP, and thus benefits from the same advantages offered by the protocol. Hence, if the RabbitMQ instances are firewalled, no special port other than the one used by AMQP (<kbd>5672</kbd> by default) needs to be opened.</p>
<div class="packt_infobox">Read more about the federation plugin at <a href="http://www.rabbitmq.com/federation.html">http://www.rabbitmq.com/federation.html</a> and <a href="http://www.rabbitmq.com/federation-reference.html">http://www.rabbitmq.com/federation-reference.html</a>.</div>
<h1 id="uuid-553cb596-ab37-4c38-b91b-a239de07b966">Summary</h1>
<p>The CC example has provided information on how to create a basic message queue architecture, add valuable features to meet user demand, and keep a system running flawlessly. This chapter covered how RabbitMQ delivers powerful features through clustering and federation and how these features increase the availability and overall resilience of the messaging infrastructure. Quorum, classic mirrored, and lazy queues were also explored.</p>
<p>Along the way, information and guidance on best practices for a reliable, resilient system were offered. The next chapter highlights these recommendations and provides key takeaways from CC's journey through RabbitMQ. It also explores monitoring of RabbitMQ.</p>


            </article>

            
        </section>
    </body></html>