- en: Getting Familiar with WildFly Swarm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉WildFly Swarm
- en: In this chapter, we will cover WildFly—how it relates to Java EE and its main
    features. We will introduce WildFly Swarm—WildFly's child project—describe its
    purpose, and show how it can be used to develop microservices. We will create
    and deploy our first application using Swarm.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍WildFly——它如何与Java EE相关以及其主要功能。我们将介绍WildFly Swarm——WildFly的子项目——描述其目的，并展示如何使用它来开发微服务。我们将使用Swarm创建和部署我们的第一个应用程序。
- en: Introducing WildFly
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WildFly
- en: Most of you have probably heard about JBoss Application Server; WildFly is its
    successor. It is an open source implementation of the Java EE specification, and,
    more importantly in the context of this book, it is the base of Swarm project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人可能都听说过JBoss应用服务器；WildFly是其继任者。它是对Java EE规范的开放源代码实现，更重要的是，在本书的上下文中，它是Swarm项目的基石。
- en: WildFly has an extensible architecture, which enables building differently sized
    distributions on top of its high-performance core, which, as we will learn in
    the next chapter, is utilized by Swarm to a great extent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly具有可扩展的架构，这使其能够在高性能核心之上构建不同大小的发行版，正如我们将在下一章中学习的，Swarm在很大程度上利用了这一点。
- en: Performance
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: When you hear the phrase *Java EE application server,* the first thing that
    may come to your mind is the word *heavyweight*, as this is the way in which application
    servers are often described. It's worth noting however that the Java EE specification
    doesn't prescribe for its implementation to be slow and bloated, and many modern
    application servers (WildFly included) indeed don't follow that nonexistent rule.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到“Java EE应用服务器”这个短语时，你可能会首先想到“重量级”这个词，因为应用服务器通常就是这样描述的。然而，值得注意的是，Java EE规范并没有规定其实施必须是缓慢和臃肿的，实际上，许多现代应用服务器（包括WildFly）确实没有遵循这个不存在的规则。
- en: WildFly starts within seconds and is highly optimized in terms of resource usage.
    You are going to see it many times throughout the book. We are going to run a
    number of WildFly based services and tests, all of them running immediately and
    with small memory footprint.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly启动仅需几秒钟，在资源使用方面进行了高度优化。你将在整本书中多次看到它。我们将运行多个基于WildFly的服务和测试，所有这些服务和测试都将立即启动，并且占用很小的内存。
- en: Extensible nature
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: As mentioned earlier, WildFly's default distribution is a Java EE application
    server with all necessary libraries. Owing to the extensible nature of WildFly,
    you can easily create your own server distribution. It is possible to trim unused
    subsystems; a good example here may be the web profile, which contains only those
    subsystems that are needed to serve web pages and may be treated as a web server.
    It is also easy to add your own extensions to provide additional functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，WildFly的默认发行版是一个包含所有必要库的Java EE应用服务器。由于WildFly的可扩展性，你可以轻松创建自己的服务器发行版。你可以删除未使用的子系统；这里的一个好例子可能是Web配置文件，它只包含用于服务网页所需的子系统，可能被视为一个Web服务器。添加自己的扩展以提供额外功能也很容易。
- en: As you will learn later in this book, Swarm takes advantage of a great detail
    from both of these abilities, automatically trimming the server so that it uses
    only the libraries needed by your service, and also provides a bunch of microservices-dedicated
    extensions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本书后面学到的那样，Swarm利用了这两种能力的许多细节，自动裁剪服务器，使其仅使用你的服务所需的库，并提供了一组针对微服务的专用扩展。
- en: Whatever distribution you are going to use, whether it is a trimmed-down web
    server, a full distribution extended with your own subsystems, or Swarm microservices,
    it can take advantage of all the features provided by the core, such as high performance,
    modular classloading, and a mature management layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你打算使用哪种发行版，无论是经过裁剪的Web服务器、扩展了你自己子系统的完整发行版，还是Swarm微服务，它都可以利用核心提供的所有功能，例如高性能、模块化类加载和成熟的管理层。
- en: Deployment model
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署模型
- en: Application servers provide enterprise functionality collocated in a JVM, which
    can be used by multitenant applications. Those applications can share services,
    be deployed and undeployed in real time, and communicate with each other in a
    JVM.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器提供在JVM中协同定位的企业功能，这些功能可以被多租户应用程序使用。这些应用程序可以共享服务，实时部署和卸载，并在JVM中相互通信。
- en: In this book, we will concentrate on Swarm-based microservices, but note that
    this is a valid architecture model with benefits that should be taken into consideration
    when choosing the right architectural style for the problems that you are solving.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将专注于基于Swarm的微服务，但请注意，这是一个有效的架构模型，其好处在选择适合您所解决问题的正确架构风格时应予以考虑。
- en: Components of a monolithic application are located in the same JVM, and they
    can communicate directly within its boundaries. In such an application, you don't
    have to think about a number of problems inherent to distributed systems. If you
    decide to distribute your application, you will have to take care of network failures,
    service discovery, monitoring service availability, and dealing with their failures,
    just to name a few problems. Also, in a monolithic application, you can use out-of-the-box
    technologies, such as transactions or security, that have been thoroughly tested
    and have proven to work well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序的组件位于同一个JVM中，并且它们可以在其边界内直接通信。在这样的应用程序中，你不必考虑分布式系统固有的许多问题。如果你决定分发你的应用程序，你必须注意网络故障、服务发现、监控服务可用性以及处理它们的故障，仅举几个问题。此外，在单体应用程序中，你可以使用现成的技术，如事务或安全，这些技术已经过彻底测试，并且已被证明可以很好地工作。
- en: Meet WildFly Swarm
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WildFly Swarm
- en: As we discussed earlier, the application server provides the possibility to
    deploy and manage multiple applications within the same instance. Also, the Java
    EE-compliant application server provides an implementation of all specifications
    gathered around Java EE umbrella so that each application that conforms to it
    can use it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，应用程序服务器提供了在同一个实例中部署和管理多个应用程序的可能性。此外，Java EE兼容的应用程序服务器提供了Java EE伞下所有规范的实现，以便每个符合该规范的应用程序都可以使用它。
- en: Such a functionality is not necessary for all application architectures. In
    services developed in our example application, we might not care much about management,
    hot redeployment, and support for all Java EE libraries. The reason for that is
    that we will be developing small focused microservices. If a microservice is updated,
    we can just kill its container and restart its new version. Also, at the time
    of service creation, we will be able to determine all the libraries that it will
    use during its operations. Because of that, we will be able to build the executable
    JAR with only those necessary dependencies, minimizing the runtime size and memory
    usage. The tool that is most suitable for such a purpose is WildFly Swarm.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的功能对于所有应用程序架构来说并不是必需的。在我们示例应用程序中开发的服务中，我们可能不太关心管理、热部署以及所有Java EE库的支持。原因是我们将开发小型专注的微服务。如果微服务被更新，我们只需终止其容器并重新启动其新版本。此外，在服务创建时，我们将能够确定它在操作期间将使用的所有库。正因为如此，我们才能仅使用那些必要的依赖项构建可执行的JAR文件，从而最小化运行时大小和内存使用。最适合这种目的的工具是WildFly
    Swarm。
- en: WildFly Swarm is a child project of WildFly, whose goal is to make microservice
    application development easy. Before we take a deeper look at Swarm behavior,
    let's get a feel for it using our first `Hello World` JAX-RS Swarm service.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly Swarm是WildFly的一个子项目，其目标是使微服务应用程序开发变得简单。在我们更深入地了解Swarm行为之前，让我们通过我们的第一个`Hello
    World` JAX-RS Swarm服务来感受一下它。
- en: Java EE application
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE应用程序
- en: 'Let''s create a simple Java EE application with a REST resource, which uses
    the `GET` method to serve the `Hello world!` message:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的Java EE应用程序，其中包含一个REST资源，它使用`GET`方法来提供`Hello world!`消息：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the listing above, we create a simple resource taking advantage of JAX-RS
    annotations; we define the main path for the whole class (1) and create the `"hello"`
    method, which is annotated with `GET`(2) and `Path`(3) annotations so that the
    `"hello"` method is executed when the HTML get method is invoked on a `"/hello"`
    path.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的列表中，我们创建了一个简单的资源，利用了JAX-RS注解；我们定义了整个类的主要路径（1），并创建了被`GET`(2)和`Path`(3)注解的`"hello"`方法，这样当在`"/hello"`路径上调用HTML
    get方法时，就会执行`"hello"`方法。
- en: 'Furthermore, we have to define the application on the `Path` (1) root to bootstrap
    the web application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须在`Path`（1）根上定义应用程序以启动Web应用程序：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we have to configure `pom.xml`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须配置`pom.xml`：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are creating the application with the war type (1) so that it can be used
    as a web application. We are referencing the Java EE (2) and `jaxrs` API (3) so
    that we are able to use annotations mentioned in the preceding paragraph. Finally,
    we have to tweak the war plugin to inform it that we will not use the `web.xml`
    file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用战争类型（1）创建应用程序，以便它可以作为一个Web应用程序使用。我们正在引用Java EE（2）和`jaxrs` API（3），这样我们就可以使用前面段落中提到的注解。最后，我们必须调整war插件，通知它我们不会使用`web.xml`文件。
- en: That's it. This is the simple REST `HelloWorld` resource. We will now be able
    to build it and deploy it on a Java EE application server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这是一个简单的REST `HelloWorld` 资源。我们现在将能够构建它并将其部署到Java EE应用程序服务器上。
- en: Adapting to WildFly Swarm
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应WildFly Swarm
- en: Now we all know how to create Java EE applications, described previously, but
    we are here to learn how to use WildFly Swarm, so let's adopt the preceding application
    for it. Let's roll up our sleeves as we have some hard work to do now.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们都知道如何创建之前描述的Java EE应用程序，但我们是来这里学习如何使用WildFly Swarm的，所以让我们采用前面的应用程序来适应它。让我们卷起袖子，因为我们现在有一些艰苦的工作要做。
- en: 'We have to modify `pom.xml`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改`pom.xml`：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We had to add dependencies to Swarm's JAX-RS module (1). Such modules are called
    fractions and you will learn more about them in the next chapter. Please note
    that we don't need to configure the JAX-RS API dependency directly as it will
    be provided as the JAX-RS fraction dependency.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不向Swarm的JAX-RS模块（1）添加依赖项。这样的模块被称为分数，你将在下一章中了解更多关于它们的内容。请注意，我们不需要直接配置JAX-RS
    API依赖项，因为它将作为JAX-RS分数依赖项提供。
- en: Later, we had to configure WildFly Swarm's Maven plugin, which is responsible
    for building Swarm microservices (2). You will also learn more about it in the
    next chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们不得不配置WildFly Swarm的Maven插件，该插件负责构建Swarm微服务（2）。你将在下一章中了解更多关于它的内容。
- en: That's it. Congratulations! You have just created your first WildFly Swarm application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。恭喜！你刚刚创建了你第一个WildFly Swarm应用程序。
- en: 'Examples reference: `chapter2/swarm-hello-world` (the whole example is available
    in the attached code, in the directory: `chapter2/swarm-hello-world` directory.)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter2/swarm-hello-world`（整个示例在附带的代码中可用，在目录：`chapter2/swarm-hello-world`目录中。）
- en: Does it really work?
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这真的有效吗？
- en: 'Before we look in greater detail at what happened, let''s run the application
    to prove that it is indeed working. Open the console, enter the root directory
    of the application, and run the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地查看发生了什么之前，让我们运行应用程序以证明它确实在运行。打开控制台，进入应用程序的根目录，并运行以下命令：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Maven command runs successfully:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Maven命令运行成功：
- en: '![](img/12e3fda6-d51b-4939-9682-7d92377f999d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/12e3fda6-d51b-4939-9682-7d92377f999d.png)'
- en: swarm-hello-world example's console output
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: swarm-hello-world示例的控制台输出
- en: 'We can open the web browser and enter the address of our application, as shown
    in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开网页浏览器并输入我们应用程序的地址，如下面的截图所示：
- en: '![](img/f35c15f4-72b0-407c-a766-6094235b6ad9.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f35c15f4-72b0-407c-a766-6094235b6ad9.png)'
- en: What has just happened here?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: 'The application works indeed. Let''s look step by step what has just happened:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序确实在运行。让我们一步一步地看看刚才发生了什么：
- en: Maven build has been run. A standard maven package plugin has created the war
    archive, which included classes described previously (and which can be as well
    deployed into the standard application server).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven构建已运行。一个标准的maven包插件创建了一个war存档，其中包含了之前描述的类（并且也可以部署到标准应用程序服务器）。
- en: The Swarm plugin built a runtime for our application. The runtime is based on
    WildFly-core and contains only the libraries needed by the service application.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swarm插件为我们的应用程序构建了一个运行时。这个运行时基于WildFly-core，只包含服务应用程序所需的库。
- en: The plugin has built a runnable JAR, which combines the runtime and the application.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件构建了一个可运行的JAR文件，它结合了运行时和应用程序。
- en: Since we have specified the run goal, the plugin has started the service immediately
    after its creation.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们指定了运行目标，插件在创建后立即启动了服务。
- en: 'Let''s take a look at the target directory to note the build output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下目标目录，以记录构建输出：
- en: '![](img/2ca2fa5a-d691-4dc8-83d7-fda48fbeba83.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/2ca2fa5a-d691-4dc8-83d7-fda48fbeba83.png)'
- en: 'As you can see in the preceding screenshot, besides the standard Maven target
    artifact, one more JAR is created: swarm-hello**-world-1.0-swarm.jar**. This is
    the runnable microservice. Its name is created from the archive''s name to which
    the Swarm suffix is added. Also, note that the size of the service is 47,5 MB.
    It is slightly bigger than WildFly web-server profile. The reason for that is
    that some more libraries (enabling REST services) have to be added to the server.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，除了标准的Maven目标构件之外，还创建了一个额外的JAR文件：swarm-hello**-world-1.0-swarm.jar**。这是一个可运行的微服务。其名称由存档名称生成，并添加了Swarm后缀。此外，请注意，服务的大小为47.5
    MB。它比WildFly的web服务器配置略大。原因是必须添加一些额外的库（启用REST服务）到服务器中。
- en: 'This example was supposed to give you an initial feel for WildFly Swarm. As
    you see, the responsibility of the developer here is to implement a business functionality
    and configure the Swarm maven plugin. Swarm takes care of the rest: it creates
    the server with all libraries necessary to make those features work and connects
    the archive with this server to create a runnable microservice. Owing to this
    convention-over-configuration style and automatic server creation, a lot of the
    configuration burden is taken away from the developer so he/she can concentrate
    on business functionality development. Obviously, this standard behavior can be
    changed—you will learn more about it in subsequent parts of this book.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子旨在让您对WildFly Swarm有一个初步的了解。如您所见，开发者的责任是实现业务功能并配置Swarm Maven插件。Swarm负责其余工作：它创建了一个包含所有必要库的服务器，以使这些功能正常工作，并将存档与该服务器连接以创建一个可运行的微服务。由于这种约定优于配置的风格和自动服务器创建，许多配置负担从开发者那里移除，使他们可以专注于业务功能开发。显然，这种标准行为可以更改——您将在本书的后续部分了解更多相关信息。
- en: Summary
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The goal of this chapter was to introduce you to WildFly Swarm—to put it in
    the context of WildFly, its parent project, show its architecture, features, and
    benefits. Finally, to give you your first taste of WildFly Swarm, we created a
    simple web application and used Swarm to create a microservice from it. In the
    next chapter, we will learn more about the modular nature of WildFly Swarm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您介绍WildFly Swarm——将其置于WildFly及其父项目的大背景下，展示其架构、特性和优势。最后，为了让您初步体验WildFly
    Swarm，我们创建了一个简单的Web应用程序，并使用Swarm将其转换为一个微服务。在下一章中，我们将更深入地了解WildFly Swarm的模块化特性。
- en: Further reading
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[http://wildfly.org/](http://wildfly.org/)'
  id: totrans-59
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://wildfly.org/](http://wildfly.org/)'
- en: '[http://wildfly-swarm.io/](http://wildfly-swarm.io/)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://wildfly-swarm.io/](http://wildfly-swarm.io/)'
