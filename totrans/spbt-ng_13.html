<html><head></head><body>
		<div id="_idContainer099">
			<h1 class="chapter-number" id="_idParaDest-243"><a id="_idTextAnchor253"/>13</h1>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor254"/>Saving, Deleting, and Updating with NgRx</h1>
			<p>In the previous chapter, we learned about the concepts and features of NgRx. We learned the importance of state management as it provides a single source for the application to have a unidirectional data flow and reduces the responsibility of components. We also learned the building blocks of NgRx, which are actions, effects, reducers, and selectors. Lastly, we implemented the getting and displaying of the anti-heroes list feature using NgRx in <span class="No-Break">our application.</span></p>
			<p>In this chapter, we will now complete our application’s missing features – saving, deleting, and updating data by still <span class="No-Break">using NgRx.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Removing an item without side effects <span class="No-Break">using NgRx</span></li>
				<li>Removing an item with side effects <span class="No-Break">using NgRx</span></li>
				<li>Adding an item with side effects <span class="No-Break">using NgRx</span></li>
				<li>Updating an item with side effects <span class="No-Break">using NgRx</span></li>
			</ul>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor255"/>Technical requirements</h1>
			<p>The link to the finished version of the code <span class="No-Break">is </span><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor256"/>Removing an item without a side effect using NgRx</h1>
			<p>In this section, we will first <a id="_idIndexMarker1033"/>see how to delete items without using side effects in NgRx. As we learned in the previous chapter, side effects are used to call external APIs to retrieve data. This means that without using effects, we will delete the data by dispatching an action to invoke a reducer base on the dispatched type. This section<a id="_idIndexMarker1034"/> will help us see the difference in the flow and behavior of using effects in <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor257"/>Creating the delete action</h2>
			<p>The first step is to create<a id="_idIndexMarker1035"/> the action for the delete feature. In our project, in the <strong class="source-inline">anti-hero/state/anti-hero.actions.ts</strong> file, we will add a new action interface and a new function <span class="No-Break">for deletion.</span></p>
			<p>Let’s have a look at the implementation of the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export enum AntiHeroActions {
  GET_ANTI_HERO_LIST = '[Anti-Hero] Get Anti-Hero list',
  SET_ANTI_HERO_LIST = '[Anti-Hero] Set Anti-Hero list',
  REMOVE_ANTI_HERO_STATE =
   '[Anti-Hero] Remove ALL Anti-Hero (STATE)',
}
export const removeAntiHeroState = createAction(
    AntiHeroActions.REMOVE_ANTI_HERO_STATE,
  props&lt;{ antiHeroId: string }&gt;()
);</pre>
			<p>In the preceding code example, we can see that we have added a new action named <strong class="source-inline">REMOVE_ANTI_HERO_STATE</strong>. We have also created an action with the newly created type, which has a <strong class="source-inline">props</strong> parameter that accepts an anti-hero ID. The ID is needed for the reducer to identify what data we should delete from <span class="No-Break">our store.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor258"/>Creating the delete reducer</h2>
			<p>Now, let’s create the reducer<a id="_idIndexMarker1036"/> for deleting data from our store. The first thing we need to think of is what our reducer would look like if it could remove a single piece of data from an array using the provided ID. One way we can implement this is by using the <strong class="source-inline">filter()</strong> function to extract the data in <span class="No-Break">the array.</span></p>
			<p>Let’s add the following code in the <span class="No-Break"><strong class="source-inline">anti-hero/state/anti-hero.reducers.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
export const antiHeroReducer = createReducer(
  initialState,
  on(setAntiHeroList, (state, { antiHeroes }) =&gt; { return
    {...state, antiHeroes}}),
  on(removeAntiHeroState, (state, { antiHeroId }) =&gt; {
    return {...state, antiHeroes:
      state.antiHeroes.filter(data =&gt; data.id !=
                              antiHeroId)}
  }),
);</pre>
			<p>In the preceding code <a id="_idIndexMarker1037"/>example, we can see that we have added a new reducer for our delete feature. This accepts the anti-hero ID coming from the <strong class="source-inline">removeAntiHeroState</strong> action and returns the new state with the modified <strong class="source-inline">antiHeroes</strong> value where the anti-hero data that has the given ID is already filtered. If the reducer successfully modifies the value of the <strong class="source-inline">antiHeroes</strong> state, any selectors subscribed to the changes of this state will emit the new value in <span class="No-Break">the component.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor259"/>Dispatching the action</h2>
			<p>The last step we need<a id="_idIndexMarker1038"/> to do is to dispatch the action in our component. To implement this step, we need to call a dispatch when the <strong class="bold">Delete</strong> button for each piece of anti-hero data <span class="No-Break">is clicked.</span></p>
			<p>In the <strong class="source-inline">anti-hero/components/anti-hero-list.component.ts</strong> file, we have added <strong class="source-inline">emittethatch</strong>, which passes the selected anti-hero object and <strong class="source-inline">TableAction</strong>, based on the button clicked by <span class="No-Break">the user.</span></p>
			<p>Let’s have a recap of the code we have<a id="_idIndexMarker1039"/> implemented for this feature in the <span class="No-Break">following files:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">anti-hero-list.component.ts</p>
			<pre class="source-code">
// See full code on https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13 /
export class AntiHeroListComponent implements OnInit {
   // other code for component not displayed
  @Output() antiHero = new EventEmitter&lt;{antiHero:   AntiHero, action :TableActions}&gt;();
  selectAntiHero(antiHero: AntiHero, action: TableActions)  {
    this.antiHero.emit({antiHero, action});
 }
}</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">anti-hero-list.component.html</p>
			<pre class="source-code">
// See full code on https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13
&lt;button (click)="selectAntiHero(element, 1)" mat-raised-button color="warn"&gt;
           &lt;mat-icon&gt;delete&lt;/mat-icon&gt; Delete
&lt;/button&gt;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">table-actions.enum.ts</p>
			<pre class="source-code">
export enum TableActions {
  View,
   Delete
}</pre>
			<p>In the preceding code example, we can see that if the <strong class="bold">Delete</strong> button is clicked, this will emit the whole anti-hero object and the value <strong class="source-inline">1</strong>, which represents the value for <span class="No-Break"><strong class="bold">Delete enum</strong></span><span class="No-Break">.</span></p>
			<p>Now, we need<a id="_idIndexMarker1040"/> to dispatch the <strong class="source-inline">REMOVE_ANTI_HERO_STATE</strong> action in the list component when the <strong class="bold">Delete</strong> button has emitted an event. To implement this part, we will add the following code in the <span class="No-Break">following files:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">list.component.ts</p>
			<pre class="source-code">
  selectAntiHero(data: {antiHero: AntiHero, action:
    TableActions}) {
    switch(data.action) {
      case TableActions.Delete: {
        this.store.dispatch({type:
          AntiHeroActions. REMOVE_ANTI_HERO_STATE,
          antiHeroId: data.antiHero.id});
        return;
      }
      default: ""
    }
  }</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">list.component.html</p>
			<pre class="source-code">
// See full code on https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13
&lt;!-- Dumb component anti hero list --&gt;
&lt;app-anti-hero-list [antiHeroes]="antiHeroes" (antiHero)="selectAntiHero($event)" [headers]="headers"&gt;&lt;/app-anti-hero-list&gt;</pre>
			<p>In the preceding code example, we created a function that checks the action triggered by the user with the <strong class="source-inline">TableActions</strong> value. If <strong class="source-inline">TableActions</strong> has a delete value, we will dispatch <strong class="source-inline">REMOVE_ANTI_HERO_STATE</strong> and pass the ID of the anti-hero object that will be used by the reducer we <span class="No-Break">have created.</span></p>
			<p>We have now successfully<a id="_idIndexMarker1041"/> implemented the delete feature of our application with NgRx, but in this case, we are only deleting the items in our UI, and we are not syncing the changes in <span class="No-Break">the database.</span></p>
			<p>In the next section, we will implement the use of side effects in the deleting <span class="No-Break">of data.</span></p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor260"/>Removing an item with side effects using NgRx</h1>
			<p>In this section, we will improve the delete<a id="_idIndexMarker1042"/> functionality by adding effects in our state. Our current delete feature only removes the data in the store but does not sync the changes in the database. This means that if we refresh our application, the data that we have deleted will be <span class="No-Break">available again.</span></p>
			<p>To sync the changes in the database, what we should do is create an effect that will invoke the delete API. Let’s have a look at the step-by-step changes in our code in the <span class="No-Break">following sections.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor261"/>Creating a new action type</h2>
			<p>The first step we need<a id="_idIndexMarker1043"/> to do is create a new action type. The effects in NgRx will use the new action type for deleting <span class="No-Break">feature later.</span></p>
			<p>We will add <strong class="source-inline">REMOVE_ANTI_HERO_API</strong> in the <strong class="source-inline">AntiHeroActions</strong> enum under the <span class="No-Break"><strong class="source-inline">anti-hero/state/anti-hero.actions.ts</strong></span><span class="No-Break"> file.</span></p>
			<p>Let’s have a look at the added action in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export enum AntiHeroActions {
  GET_ANTI_HERO_LIST = '[Anti-Hero] Get Anti-Hero list',
  SET_ANTI_HERO_LIST = '[Anti-Hero] Set Anti-Hero list',
  REMOVE_ANTI_HERO_API =
    '[Anti-Hero] Remove Anti-Hero (API)',
  REMOVE_ANTI_HERO_STATE =
    '[Anti-Hero] Remove Anti-Hero (STATE)',
}</pre>
			<p>We can see in the preceding<a id="_idIndexMarker1044"/> code example that a new action type was added for our actions. Take note that we do not need to create a new action for this type as we will be calling an effect instead of an action once this action type <span class="No-Break">is dispatched.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor262"/>Creating the delete effect</h2>
			<p>The next step we need<a id="_idIndexMarker1045"/> to do is to create the effect for the delete feature. In the <strong class="source-inline">anti-hero/state/anti-hero.effect.ts</strong> file, we will add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
 // See full code on https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13
 removeAntiHero$ = createEffect(() =&gt; {
    return this.actions$.pipe(
        ofType(AntiHeroActions.REMOVE_ANTI_HERO_API),
        mergeMap((data: { payload: string}) =&gt;
          this.antiHeroService.deleteAntiHero(data.payload)
          .pipe(
            map(() =&gt; ({ type:
              AntiHeroActions.REMOVE_ANTI_HERO_STATE,
              antiHeroId: data.payload })),
            catchError(() =&gt; EMPTY)
          ))
        )
    }, {dispatch: true}
  );</pre>
			<p>In the preceding code example, we can see that we have created a new effect for our delete action; this has a type of <strong class="source-inline">REMOVE_ANTI_HERO_API</strong>, which calls the <strong class="source-inline">deleteAntiHero()</strong> function in <strong class="source-inline">AntiHeroService</strong> for the data deletion based on the passed ID, and once the API <span class="No-Break">is successful.</span></p>
			<p>The effect will dispatch<a id="_idIndexMarker1046"/> another action, <strong class="source-inline">REMOVE_ANTI_HERO_STATE</strong>, which we created in the previous section, which removes the anti-hero from the store. This means that the data we delete from the database will also be deleted from our <span class="No-Break">NgRx store.</span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor263"/>Modifying the dispatch</h2>
			<p>The last step for this feature is to modify<a id="_idIndexMarker1047"/> the action being dispatched in the <strong class="source-inline">list.component.ts</strong> file. In the previous section, we call the <strong class="source-inline">REMOVE_ANTI_HERO_STATE</strong> action directly in our component; we will change this into <strong class="source-inline">REMOVE_ANTI_HERO_API</strong> as we should now call the effect, which will invoke the API and at the same time will call the <span class="No-Break"><strong class="source-inline">REMOVE_ANTI_HERO_STATE</strong></span><span class="No-Break"> action.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
 selectAntiHero(data: {antiHero: AntiHero, action: TableActions}) {
    switch(data.action) {
      case TableActions.Delete: {
        this. store.dispatch({type:
          AntiHeroActions.REMOVE_ANTI_HERO_API,
          payload: data.antiHero.id});
        return;
      }
      default: ""
    }
  }</pre>
			<p>In the preceding code example, we<a id="_idIndexMarker1048"/> are now dispatching the effect in our list component. This will call the API first before updating our store in the application; the changes in our store and database <span class="No-Break">are synced.</span></p>
			<p>In the next section, we will implement the addition of data with side effects to <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor264"/>Adding an item with side effects using NgRx</h1>
			<p>In this section, we will implement<a id="_idIndexMarker1049"/> the <em class="italic">add</em> functionality with side effects in NgRx. The steps are similar to how we implemented the delete feature. We will create the building blocks step by step and create the dispatch logic in <span class="No-Break">our component.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor265"/>Creating the actions</h2>
			<p>The first step we need to do is create<a id="_idIndexMarker1050"/> the required action types and actions for our add feature. To implement the actions, we can think of how we created the actions for the <span class="No-Break">delete feature.</span></p>
			<p>The concept is the same. There are two action types that we need to create, and these are <strong class="source-inline">ADD_ANTI_HERO_API</strong> and <strong class="source-inline">ADD_ANTI_HERO_STATE</strong>. The first type will be used by the effect that will call the API, and the second type will be used by the reducer that will modify the state by adding the newly <span class="No-Break">created data.</span></p>
			<p>After creating the two action types, we also need to create an action using the <strong class="source-inline">createAction()</strong> function for the <strong class="source-inline">ADD_ANTI_HERO_STATE</strong> type. The effect will dispatch this once the API has been <span class="No-Break">successfully called.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
 // See full code on https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13
export enum AntiHeroActions {
  GET_ANTI_HERO_LIST = '[Anti-Hero] Get Anti-Hero list',
  SET_ANTI_HERO_LIST = '[Anti-Hero] Set Anti-Hero list',
  ADD_ANTI_HERO_API = '[Anti-Hero] Add Anti-Hero (API',
  ADD_ANTI_HERO_STATE = '[Ant
    i-Hero] Add Anti-Hero (STATE)',
  REMOVE_ANTI_HERO_API =
    '[Anti-Hero] Remove Anti-Hero (API)',
  REMOVE_ANTI_HERO_STATE =
    '[Anti-Hero] Remove Anti-Hero (STATE)',
}
export const addAntiHeroState = createAction(
  AntiHeroActions.ADD_ANTI_HERO_STATE,
  props&lt;{ antiHero: AntiHero }&gt;()
)</pre>
			<p>In the preceding code example, we can see that we have added the two new types in <strong class="source-inline">AntiHeroActions</strong>. We have also created<a id="_idIndexMarker1051"/> a new action with the <strong class="source-inline">ADD_ANTI_HERO_STATE</strong> type, which accepts an <strong class="source-inline">antiHero</strong> property that will be pushed as a new item in the <span class="No-Break">anti-hero state.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor266"/>Creating the effect</h2>
			<p>The next step<a id="_idIndexMarker1052"/> we need to do is to create the effect for the <em class="italic">add</em> feature. In the <strong class="source-inline">anti-hero/state/anti-hero.effect.ts</strong> file, we will add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// add anti-heroes to the database
  addAntiHero$ = createEffect(() =&gt;{
    return this.actions$.pipe(
        ofType(AntiHeroActions.ADD_ANTI_HERO_API),
        mergeMap((data: {type: string, payload: AntiHero})
          =&gt; this.antiHeroService.addAntiHero(data.payload)
          .pipe(
            map(antiHeroes =&gt; ({ type:
              AntiHeroActions.ADD_ANTI_HERO_STATE,
              antiHero: data.payload })),
            tap(() =&gt;
              this.router.navigate(["anti-heroes"])),
            catchError(() =&gt; EMPTY)
          ))
        )
    }, {dispatch: true})</pre>
			<p>In the preceding code example, we can see that we have created an effect similar to the effect for the delete feature. This effect uses the <strong class="source-inline">ADD_ANTI_HERO_API</strong> type and invokes the <strong class="source-inline">addAntiHero()</strong> function from <strong class="source-inline">antiHeroService</strong> to call the POST API to add new data to <span class="No-Break">the database.</span></p>
			<p>After successfully calling the POST API, the effect<a id="_idIndexMarker1053"/> will dispatch the <strong class="source-inline">ADD_ANTI_HERO_STATE</strong> action and pass the new anti-hero data coming from the API response to be added by the reducer. We have also added a <strong class="source-inline">tap</strong> operator, which calls a <strong class="source-inline">navigate</strong> function that will navigate to the list page after creating the <span class="No-Break">new anti-hero.</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor267"/>Creating the reducer</h2>
			<p>After creating<a id="_idIndexMarker1054"/> the effects, we need to sync the changes implemented in the database with our store, and the reducer will <span class="No-Break">do this.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
export const antiHeroReducer = createReducer(
  initialState,
  on(setAntiHeroList, (state, { antiHeroes }) =&gt; { return
    {...state, antiHeroes}}),
  on(removeAntiHeroState, (state, { antiHeroId }) =&gt; {
    return {...state, antiHeroes:
     state.antiHeroes.filter(data =&gt; data.id !=
       antiHeroId)}
  }),
  on(addAntiHeroState, (state, {antiHero}) =&gt; {
    return {...state, antiHeroes: [...state.antiHeroes,
            antiHero]}
  }),
);</pre>
			<p>In the preceding code example, we can see that we have added a new reducer for our <em class="italic">add</em> feature. This accepts the new anti-hero data coming from the <strong class="source-inline">addAntiHeroState</strong> action and returns the new state with the modified <strong class="source-inline">antiHeroes</strong> value where the new anti-hero is already added in <span class="No-Break">the array.</span></p>
			<p>If the reducer successfully<a id="_idIndexMarker1055"/> modifies the value of the <strong class="source-inline">antiHeroes</strong> state, any selectors subscribed to the changes of this state will emit the new value in <span class="No-Break">the component.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor268"/>Dispatching the action</h2>
			<p>The last step we need to do is to dispatch<a id="_idIndexMarker1056"/> the action in our component. To implement this step, we will invoke the dispatch action once the <strong class="bold">Create</strong> button in the anti-hero form is clicked. In the <strong class="source-inline">anti-hero/components/anti-hero-form.component.ts</strong> file, we have added an emitter that passes the value of the form and the button label to identify if the action is created <span class="No-Break">or updated.</span></p>
			<p>Let’s have a recap<a id="_idIndexMarker1057"/> of the code we have implemented for this <span class="No-Break">anti-hero form:</span></p>
			<pre class="source-code">
export class AntiHeroFormComponent implements OnInit {
  @Input() actionButtonLabel: string = 'Create';
  @Output() action = new EventEmitter();
  form: FormGroup;
  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      id: [''],
      firstName: [''],
      lastName: [''],
      house: [''],
      knownAs: ['']
    })
   }
  emitAction() {
    this.action.emit({value: this.form.value,
                      action: this.actionButtonLabel})
  }
}</pre>
			<p>In the preceding code example, we can see that the anti-hero form emits the form value as an anti-hero object that will be passed to <span class="No-Break">the effect.</span></p>
			<p>This also gives the current action, as we will also be using this anti-hero form component for the update. Once the button is clicked, we need to have a function in the <strong class="source-inline">form.component.ts</strong> file that will dispatch <span class="No-Break">the effect.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
// form.component.html
&lt;app-anti-hero-form [selectedAntiHero]="antiHero" (action)="formAction($event)"&gt;&lt;/app-anti-hero-form&gt;
// form.component.ts
 formAction(data: {value: AntiHero, action: string}) {
    switch(data.action) {
      case "Create" : {
        this.store.dispatch({type:
          AntiHeroActions.ADD_ANTI_HERO_API,
          payload: data.value});
        return;
      }
      default: ""
    }
  }</pre>
			<p>In the preceding code example, we can see that we have created the <strong class="source-inline">formAction()</strong> function, which dispatches an action based on the passed value from the anti-hero <span class="No-Break">form component.</span></p>
			<p>This uses a <strong class="source-inline">switch</strong> statement, as this will also be called<a id="_idIndexMarker1058"/> when the action is <strong class="source-inline">update</strong>. We have now successfully created the <em class="italic">add</em> feature for our application using the building blocks <span class="No-Break">of NgRx.</span></p>
			<p>In the next section, we will implement the modification of data with <span class="No-Break">side effects.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor269"/>Updating an item with a side effect using NgRx</h1>
			<p>In this last section, we will implement<a id="_idIndexMarker1059"/> the final missing feature, which is the <em class="italic">update</em> functionality, where we will create the building blocks step by step and the dispatch logic in our component as we did for the <em class="italic">add</em> and <span class="No-Break"><em class="italic">delete</em></span><span class="No-Break"> features.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor270"/>Creating the actions</h2>
			<p>The first step we need to do is to create<a id="_idIndexMarker1060"/> the required action types and actions for our update feature. We will first create the two action types we need, which are <strong class="source-inline">MODIFY_ANTI_HERO_API</strong> and <strong class="source-inline">MODIFY_ANTI_HERO_STATE</strong>. The first type will be used by the effect that will call the API, and the second type will be used by the reducer that will modify the state by changing the data based on the new <span class="No-Break">anti-hero object.</span></p>
			<p>After creating the two action types, we also need to create an action using the <strong class="source-inline">createAction()</strong> function for the <strong class="source-inline">MODIFY_ANTI_HERO_STATE</strong> type. The effect will dispatch this once the API has been <span class="No-Break">successfully called.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
 // See full code on https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13
export enum AntiHeroActions {
  GET_ANTI_HERO_LIST = '[Anti-Hero] Get Anti-Hero list',
  SET_ANTI_HERO_LIST = '[Anti-Hero] Set Anti-Hero list',
  ADD_ANTI_HERO_API = '[Anti-Hero] Add Anti-Hero (API',
  ADD_ANTI_HERO_STATE =
    '[Anti-Hero] Add Anti-Hero (STATE)',
  REMOVE_ANTI_HERO_API =
    '[Anti-Hero] Remove Anti-Hero (API)',
  REMOVE_ANTI_HERO_STATE =
    '[Anti-Hero] Remove Anti-Hero (STATE)',
  MODIFY_ANTI_HERO_API =
    '[Anti-Hero] Modify Anti-Hero (API)',
  MODIFY_ANTI_HERO_STATE =
    '[Anti-Hero] Modify Anti-Hero (STATE)',
}
export const modifyAntiHeroState = createAction(
    AntiHeroActions.MODIFY_ANTI_HERO_STATE,
    props&lt;{ antiHero: AntiHero }&gt;()
);</pre>
			<p>In the preceding code example, we<a id="_idIndexMarker1061"/> can see that we have added the two new types in <strong class="source-inline">AntiHeroActions</strong>. We have also created a new action with the <strong class="source-inline">MODIFY_ANTI_HERO_STATE</strong> type, which accepts an <strong class="source-inline">antiHero</strong> property that will be used to modify the current values in <span class="No-Break">the store.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor271"/>Creating the effect</h2>
			<p>The next step we need <a id="_idIndexMarker1062"/>to do is to create the effect for the <em class="italic">add</em> feature. In the <strong class="source-inline">anti-hero/state/anti-hero.effect.ts</strong> file, we will add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// modify anti-heroes in the database
   modifyAntiHero$ = createEffect(() =&gt;{
    return this.actions$.pipe(
        ofType(AntiHeroActions.MODIFY_ANTI_HERO_API),
        mergeMap((data: {type: string, payload: AntiHero})
          =&gt; this.antiHeroService.updateAntiHero(
          data.payload.id, data.payload)
          .pipe(
            map(antiHeroes =&gt; ({ type:
                AntiHeroActions.MODIFY_ANTI_HERO_STATE,
                antiHero: data.payload })),
            tap(() =&gt;
              this.router.navigate(["anti-heroes"])),
            catchError(() =&gt; EMPTY)
          ))
        )
    }, {dispatch: true})</pre>
			<p>In the preceding code example, we can see that we have created an effect similar to the effect for the <em class="italic">add</em> and <em class="italic">delete</em> features. This effect uses the <strong class="source-inline">MODIFY_ANTI_HERO_API</strong> type and invokes the <strong class="source-inline">updateAntiHero()</strong> function from <strong class="source-inline">antiHeroService</strong> to call the PUT API to modify the anti-hero with the ID parameter in <span class="No-Break">the database.</span></p>
			<p>After successfully calling the PUT API, the effect<a id="_idIndexMarker1063"/> will dispatch the <strong class="source-inline">MODIFY_ANTI_HERO_STATE</strong> action and pass the modified anti-hero data coming from the API response to be added by the reducer, and the same as with the <em class="italic">add</em> effect, we have also added a <strong class="source-inline">tap</strong> operator, which calls a <strong class="source-inline">navigate</strong> function that will navigate to the list page after modifying <span class="No-Break">the anti-hero.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor272"/>Creating the reducer</h2>
			<p>After creating the effects, we need<a id="_idIndexMarker1064"/> to sync the changes implemented in the database with our store, and the reducer will <span class="No-Break">do this.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
export const antiHeroReducer = createReducer(
  initialState,
  on(setAntiHeroList, (state, { antiHeroes }) =&gt; {
    return {...state, antiHeroes}}),
  on(removeAntiHeroState, (state, { antiHeroId }) =&gt; {
    return {...state, antiHeroes:
      state.antiHeroes.filter(data =&gt; data.id !=
                              antiHeroId)}
  }),
  on(addAntiHeroState, (state, {antiHero}) =&gt; {
    return {...state, antiHeroes: [...state.antiHeroes,
                                   antiHero]}
  }),
  on(modifyAntiHeroState, (state, {antiHero}) =&gt; {
    return {...state, antiHeroes: state.antiHeroes.map(data
      =&gt; data.id === antiHero.id ? antiHero : data)}
  }),
);</pre>
			<p>In the preceding code example, we can see that we have added a new reducer for our update feature. This accepts the modified anti-hero data coming from the <strong class="source-inline">addAntiHeroState</strong> action and returns the new state with the modified <strong class="source-inline">antiHeroes</strong> value, where we replace the anti-hero with the given ID with the new object using the <span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break"> operator.</span></p>
			<p>If the reducer successfully<a id="_idIndexMarker1065"/> modifies the value of the <strong class="source-inline">antiHeroes</strong> state, any selectors subscribed to the changes of this state will emit the new value in <span class="No-Break">the component.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor273"/>Dispatching the action</h2>
			<p>The last step we need<a id="_idIndexMarker1066"/> to do is to dispatch the action to our component. To implement this step, we will do the same steps as we did for the <em class="italic">add</em> feature. We will still use the <strong class="source-inline">anti-hero/components/anti-hero-form.component.ts</strong> file for updating <span class="No-Break">the data.</span></p>
			<p>The only difference here is that we will bind<a id="_idIndexMarker1067"/> the selected anti-hero value in our form; the anti-hero form component should accept an anti-hero object and should patch the value in the <span class="No-Break">form group.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
export class AntiHeroFormComponent implements OnInit {
  @Input() actionButtonLabel: string = 'Create';
  @Input() selectedAntiHero: AntiHero | null = null;
  @Output() action = new EventEmitter();
  form: FormGroup;
  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      id: [''],
      firstName: [''],
      lastName: [''],
      house: [''],
      knownAs: ['']
    })
   }
  ngOnInit(): void {
    this.checkAction();
  }
  checkAction() {
    if(this.selectedAntiHero) {
      this.actionButtonLabel = "Update";
      this.patchDataValues()
    }
  emitAction() {
    this.action.emit({value: this.form.value,
      action: this.actionButtonLabel})
  }
}</pre>
			<p>In the preceding code<a id="_idIndexMarker1068"/> example, we can see that we have added the <strong class="source-inline">checkAction()</strong> function, which checks whether we have passed an anti-hero object in the anti-hero <span class="No-Break">form component.</span></p>
			<p>This indicates that if the object is not null, this will be an <em class="italic">Update</em> action, and we must display the selected anti-hero details in each field by binding the form using the <span class="No-Break"><strong class="source-inline">patchValue()</strong></span><span class="No-Break"> method.</span></p>
			<p>Now let’s have the code implementation for the <span class="No-Break"><strong class="source-inline">form</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
// form.component.html
&lt;app-anti-hero-form [selectedAntiHero]="antiHero" (action)="formAction($event)"&gt;&lt;/app-anti-hero-form&gt;
// form.component.ts
antiHero$: Observable&lt;AntiHero | undefined&gt;;
  antiHero: AntiHero | null = null;
  constructor(private router: ActivatedRoute,
    private store: Store&lt;AppState&gt;) {
    const id = this.router.snapshot.params['id'];
    this.antiHero$ = this.store.select(selectAntiHero(id));
    this.antiHero$.subscribe(d =&gt; {
      if(d) this.antiHero = d;
    });
   }
 formAction(data: {value: AntiHero, action: string}) {
    switch(data.action) {
      case "Create" : {
        this.store.dispatch({type:
          AntiHeroActions.ADD_ANTI_HERO_API,
          payload: data.value});
        return;
      }
     case "Update" : {
        this.store.dispatch({type:
          AntiHeroActions.MODIFY_ANTI_HERO_API,
          payload: data.value});
        return;
      }
      default: ""
    }
  }</pre>
			<p>In the preceding code example, we can<a id="_idIndexMarker1069"/> see that we have added a new case in the <strong class="source-inline">formAction()</strong> function, which also dispatches an action but of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">MODIFY_ANTI_HERO_API</strong></span><span class="No-Break">.</span></p>
			<p>We have also used the <strong class="source-inline">selectAntiHero()</strong> selector to select the anti-hero using the ID in our URL route<a id="_idIndexMarker1070"/> that will be passed in our <span class="No-Break"><strong class="source-inline">anti-hero-form.component.ts</strong></span><span class="No-Break"> file.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor274"/>Summary</h1>
			<p>With this, we have reached the end of this chapter. Let’s have a recap of the valuable things we have learned; we have completed the CRUD features of applications using the building blocks of NgRx, and we have learned the difference between using and not using side effects in state management. Side effects are essential for our changes in the store to be synced with <span class="No-Break">the database.</span></p>
			<p>We have also learned, step by step, how to create the building blocks of NgRx with the different actions we need for <span class="No-Break">our application.</span></p>
			<p>In the next chapter, we will learn how to apply security features in Angular, such as adding user login and logout, retrieving user profile information, protecting application routes, and calling an API with <span class="No-Break">protected endpoints.</span></p>
		</div>
	</body></html>