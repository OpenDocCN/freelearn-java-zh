- en: Chapter 9. Solving Test Puzzles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We make a living by what we get, but we make a life by what we give."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Winston Churchill
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may have worked in greenfield development projects that were written using
    **test-driven development** (**TDD**) and also in brownfield development or maintenance
    projects that were not written with TDD. You must have noticed that the test-first
    code written with TDD is easier to extend than the code with no unit test or unit
    tests written after coding.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A greenfield project starts building from scratch and doesn't consider any prior
    work.
  prefs: []
  type: TYPE_NORMAL
- en: A brownfield project is an extension of prior work or rebuilding a project from
    an existing project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the importance of unit testing in greenfield and brownfield
    projects. The following topics are covered in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with legacy code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing for testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with greenfield code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with legacy code* section covers the legacy code and explains how
    to unit test and refactor the legacy code. The *Designing for testability* section
    explains how to design for testability. The *Working with greenfield code* section
    elaborates on TDD, the TDD life cycle, refactoring, and concludes with an example
    of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **legacy** is frequently used, as slang, to describe complex code,
    which is difficult to understand, is rigid and fragile in nature, and is almost
    impossible to enhance.
  prefs: []
  type: TYPE_NORMAL
- en: However, the fact is that any code with no automated unit tests is legacy code.
    A piece of code can be well written. It can also follow coding guidelines, might
    be easy to understand, can be clean, loosely coupled, and very easy to extend.
    However, if it doesn't have automated unit tests, then it is legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: Statistically, fixing bugs or adding new features to a legacy project is quite
    difficult than doing the same to a greenfield project. In legacy code, either
    automated unit tests do not exist or very few tests are written; the code is not
    designed for testability.
  prefs: []
  type: TYPE_NORMAL
- en: We inherit legacy code from some other source, maybe from a very old project,
    from another team that cannot maintain the code, or we acquire it from another
    company, but it is our duty to improve the quality.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests give us some level of assurance that our code is doing what the code
    is expected to do, and they allow us to change the code quickly and verify the
    change faster.
  prefs: []
  type: TYPE_NORMAL
- en: In general, legacy code is not testable and requires changes to the code structure
    (refactoring) to make it testable. However, the dilemma, most of the time, is
    that the legacy system is so crucial to the business that no one dares to touch
    the code. It makes no sense to modify an existing crucial module unless something
    is seriously wrong. Stalemate! You cannot refactor the code unless you have the
    automated test suite, and you cannot write tests as the code needs refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it feels as though the legacy code, even with unit tests, are hard
    to understand, maintain, and enhance; hence, we need to be careful to make our
    tests readable and to avoid close coupling with the actual implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Working with testing impediments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section explains the nature or quality of code that makes unit testing
    difficult. Automated tests help us develop software quickly even when we have
    a large code base to work on. However, automated tests should be executed very
    fast so that tests can give us quick feedback. We cannot unit test code when it
    exhibits any of the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It performs long running operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It connects to a database and modifies database records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs remote computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It looks up JNDI resources or web/app server objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It accesses the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works with native objects or graphical widgets (UI components, alert, Java
    Swing components, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It accesses network resources such as the LAN printer and downloads data from
    the Internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should not wait for a long running process to complete; it will defeat
    the purpose of quick feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be reliable, and they should fail if and only if the production
    code is broken. However, if your unit test verifies an I/O operation, such as
    connecting to a LAN printer, which is slow, error prone, and unpredictable, then
    your unit test may fail due to some network issue, but it will incorrectly signal
    that the code is broken. So, unit testing a network operation defeats the test
    reliability principle.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests run automatically, so it doesn't make any sense to open a modal dialog
    or show an alert message during test execution because the test will wait, unless
    the UI dialog or the alert is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the preceding features in the production code are barriers during unit
    testing. The following example shows how to avoid test impediments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `book()` method in the preceding example takes a movie, a show time, and
    the number of tickets to book, and it books the tickets or shows an error message.
    If an invalid movie or show time is passed to the `book` method, it shows an error
    message that states the movie or show time is not available. The following is
    the ticket booking logic:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the book method finds a movie hall for the movie and the movie's show
    time, for example, the movie *The HOBBIT*, with show time *Evening* is being screened
    in *SCREEN 2*. If the movie is not being played, an error message is shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then retrieves the available seats, for example, 40 seats are available in
    *SCREEN 2* in the evening.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the requested numbers of seats are greater than the available number of seats,
    an error message is shown, for example, request for 10 tickets but only two seats
    available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the seats requested are available, then it loops through the seats and books
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any error occurs during seat booking, such as someone concurrently books
    the seat or some runtime error occurs, the relevant error message is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `BookingErrorController` class is responsible for displaying error messages.
    The following is the `BookingErrorController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each method calls `JOptionPane` to display messages. `JOptionPane` shows the
    modal dialog box, and the user has to click on the close button or the **Yes**/**No**
    button to close the dialog. If the user doesn't close the dialog box, the program
    keeps waiting for the user action.
  prefs: []
  type: TYPE_NORMAL
- en: So, you cannot unit test the movie ticket booking logic unless you separate
    the error message display from the code logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing to note is the `MovieDao` creation constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `book()` method instantiates a database access object and invokes methods
    on it. We should separate the direct database access object creation from code
    so that we can pass a mock data access object and stub out the database calls;
    otherwise, the `book()` method will instantiate the real `MovieDao` object and
    the test will take time to execute. For now, we'll unit test the code with the
    real data access logic and later refactor the code to separate the `MovieDao`
    object instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `MovieTicketProTest` test class and add a sanity check method to call
    the `book` method with null objects. The following is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the test in Eclipse, it shows an error message pop up, and
    the test waits for user action. The following is the Eclipse output, and you can
    see that the test is waiting for the pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with testing impediments](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we include the test on our automation suite, the automation suite will run
    forever and wait for user intervention. We can localize the problem; extract the
    protected methods for each `BookingErrorController` method call. This change will
    allow us to create a `MovieTicketPro` fake object and replace the protected methods
    with empty implementations. However, the problem is how do we verify the error
    conditions? We can extract an error message interface, create a generic error
    message method, and pass and refactor the `BookingErrorController` class to implement
    the interface. The following are the interface details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `BookingErrorController` class to implement the interface. The following
    is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `MovieTicketPro` class and, inline, all the `BookingErrorController`
    calls. The following is an example of such a change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `BookingErrorController.createAndShowDatabaseSaveError()` and
    `BookingErrorController.createAndShowMovieOrShowTimeNotAvailableError()` methods
    are replaced by the original method content.
  prefs: []
  type: TYPE_NORMAL
- en: Now remove the static error message methods from the `BookingErrorController`
    class. You should not get any compilation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a getter method in `MovieTicketPro` to return an implementation of `ErrorMessageDisplayer`.
    The following is the method body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace all contents of the `JOptionPane.showMessageDialog` code with `getErrorMessageDisplayer()`.
    The following is the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We need to separate the database access, create a getter method to return the
    `MovieDao` object, and call the getter method from the `book` method. From test,
    we can create a fake object and override the `getMovieDao()` method to return
    a mock data access object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the changes in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the modified test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After this change, the test execution finishes very quickly. The following
    is the test execution output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with testing impediments](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next section covers designing for testability.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about testing impediments and how to refactor them. We cannot unit
    test code when testing impediments are present; we refactor the code and move
    the impediments out (to another class or methods), and during testing, the impediments
    are replaced with mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes we cannot mock out the external dependencies because of
    testing an unfriendly design. This section covers the design for testability,
    or rather matters to avoid in code. The following Java constructs go up against
    mocking the testing impediments:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors initialize testing impediments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class-level variable declaration and initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `private` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `final` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `static` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `final` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of `new`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static variable declaration and initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static initialization blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot unit test the legacy code because either it is tightly coupled or
    testing unfavorable language constructs hide the testing impediments. The following
    section explains the testing unfavorable constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To show a testing impediment, we'll throw a special runtime exception `TestingImpedimentException`.
    If your test fails with a `TestingImpedimentException`, then that means you cannot
    automate the test as your code has unfavorable features for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying constructor issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a test, we need to instantiate the class in the test harness, but the
    problem with legacy code is that it is difficult to break dependency and instantiate
    a class in a test harness. One such example is in a constructor, where the class
    instantiates many objects, reads from the properties file, or even creates a database
    connection. There can be many callers of the class, so you cannot change the constructor
    to pass dependencies; otherwise, it will cause a series of compilation errors.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at a sample legacy code and try to write a test for the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a `TestingUnfavorableConstructor` class with two external dependencies
    `DatabaseDependency` and `FileReadDependency`. Both the dependencies are slow
    in nature and are testing impediments. `TestingUnfavorableConstructor` creates
    dependencies in the constructor. Ideally, the dependencies represent the database
    access and the file reads from the `TestingUnfavorableConstructor` constructor.
    The following is the `TestingUnfavorableConstructor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to unit test the `testMe()` behavior of the class, then we need
    to create an object of the `TestingUnfavorableConstructor` class. However, when
    we try to create an instance in a unit test, the class fails to indicate that
    the class cannot be instantiated from an automated test suite. The following is
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying constructor issues](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To overcome this, you should inject the dependencies through a constructor instead
    of creating them in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot modify the default constructor because the class is invoked from
    many other clients. We cannot break the clients. The other two options are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the default constructor as it is. Create another constructor and inject
    dependencies through this new constructor; from test, we can call this new constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a protected method, move the dependency instantiation to that method,
    create two setter methods, and initialize the dependencies through the setter
    injection. In the test, create a fake object of the main class and override the
    protected method to do nothing, and pass the dependencies through the setter methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is relatively straight forward. We'll apply the second approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following unit test overrides the `TestingUnfavorableConstructor` and provides
    an empty implementation of the `createDependencies()` method, creates mock dependencies,
    and calls setter methods to set the mock dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not instantiate dependencies in the constructor; the dependencies may exhibit
    testing impediments and make the class nontestable. Instead of instantiating the
    dependencies in the constructor, you can pass the real implementations (real dependencies)
    to the constructor or the setter method of the code under the test.
  prefs: []
  type: TYPE_NORMAL
- en: Realizing initialization issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Class-level variable declaration and object instantiation at the same time
    creates problems. You don''t get the chance to mock out the variable. The following
    example explains the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VariableInitialization` class has a database dependency, and the dependency
    is instantiated where it is declared, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When you instantiate the `VariableInitialization` class in test, the test fails.
    The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Realizing initialization issues](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To overcome the class-level variable initialization, you can try out the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a default constructor and move the dependency instantiation to the default
    constructor. Create another constructor and inject the dependencies through this
    new constructor; from test, we can call this the new constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a default constructor, and move the dependency instantiation to a protected
    method and call the method from the default constructor. Create a setter method
    and initialize the dependency through a setter injection. In the test, create
    a fake object of the main class and override the protected method to do nothing,
    and pass the dependencies through the setter methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not instantiate variables at the class level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with private methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `private` methods are useful for hiding the internal state and encapsulation,
    but they can also hide the testing impediments. The following example explains
    the details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PrivateMethod` class has a `private` method named `showError()`. This
    `private` method hides a test impediment. When we unit test the `validate()` method
    with a `null` object, the `validate()` method calls the `showError` message, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the test output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with private methods](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can extract the testing impediments to a protected method, or you can separate
    the concern. Create a new class, move the testing impediment to that class, and
    inject the new class as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not hide testing impediments in private methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code refactors the testing impediments and makes the class unit
    testable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `showError` method's access specifier is changed to `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test code extends the class with an anonymous implementation,
    and it overrides the protected method with an empty implementation. The test code
    invokes the `validate()` method on the new anonymous implementation of the `PrivateMethodRefactored`
    class. In turn, the polymorphic behavior will call the empty implementation. Hence,
    the test will always bypass the testing impediments by calling the overridden
    empty implementation of the testing impediment, but the real production code will
    always invoke the protected method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach of bypassing the testing impediments with overridden versions
    of the testing impediments is known as faking or fake object. If the code under
    test contains many testing impediments, then it is not possible to override all
    of them in an anonymous class. Instead, we can create an inner class, and extend
    the code under test and override all the testing unfriendly methods.
  prefs: []
  type: TYPE_NORMAL
- en: Working with final methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a method is final, you cannot override it. If the final method hides any
    testing impediment, you cannot unit test the class. The following example explains
    the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FinalDependency` class has a final method named `doSomething`. This method
    hides a testing unfriendly feature. The following is the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FinalMethodDependency` class has a dependency on `FinalDependency`, and
    in the `testMe` method, it calls the `doSomething` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test, we''ll mock the dependency and unit test the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test, the test still accesses the testing impediment, as the
    mock object cannot stub a final method. When we try to stub the method, we get
    an error. The following test stubs the final method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test, we get the following error message thrown by the Mockito
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with final methods](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not hide the testing impediments in final methods. You cannot override or
    stub a final method.
  prefs: []
  type: TYPE_NORMAL
- en: The only possible way to overcome this is extracting the content of the final
    method to a protected method; call the protected method from the final method,
    and override the protected method in test. Otherwise, you can use the PowerMock
    or PowerMockito framework if you cannot touch the class at all; for example, when
    you only have a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring static method issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `static` methods are good for utility classes, but unnecessary use of `static`
    can hide the testing impediments and create problems in unit testing. The following
    example sheds light on the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SingletonDependency` class is an implementation of the **Gang of Four**
    (**GoF**) singleton design pattern. It has a `private` constructor and a static
    `getInstance()` method to create only a single instance of the class. The static
    `callMe()` method hides a testing impediment. Note that the GoF singleton pattern
    doesn''t define methods as `static`, but in this example, we are defining the
    `callMe()` method as `static` to display a drawback of the `static` methods. The
    following is the singleton implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VictimOfAPatternLover` class has a dependency on `SingletonDependency`.
    The following are the class details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Mockito cannot stub a static method. When we try to stub the static `callMe()`
    method, it still calls the original method and fails for the testing impediment.
    You cannot stub a `static` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not hide testing impediments in static methods. You cannot stub static methods.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to overcome this issue is to create a `protected` method and wrap
    the `static` call. From the code, call the wrapped method and from the test, override
    the `protected` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `static` wrapper method in the dependency class and call the `static`
    method from it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code, call the `wrapper` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Stub the `wrapper` method in the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Working with final classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You cannot override a `final` class, so you can hide testing unfavorable features
    in a `final` class. The following example explains the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final class hides a testing impediment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The code under test has a dependency on the final class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In test, we''ll try to stub the `poison` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The test fails with a **MockitoException** as Mockito cannot mock a final class.
    The following is the JUnit output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with final classes](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not hide testing impediments in final classes. You cannot mock a final class.
  prefs: []
  type: TYPE_NORMAL
- en: Final classes are important for framework or architecture design so that no
    one can hack the behavior, but it can create a serious problem for unit testing.
    Consider it before you choose to make a class final.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the new attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java instantiates classes using the `new` operator, but a `new` operator can
    create problems for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example explains the issue. The `PoisonIvy` constructor has a
    testing impediment such as calls fetch data from a database table or reads from
    a filesystem; we represented the testing impediment with the `TestingImpedimentException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code that calls the `PoisonIvy` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When we unit test the `testMe()` code, it fails. The `testMe()` method directly
    creates an instance of dependency and calls the `poison()` method. You cannot
    override this `new` expression. If we want to unit test the `testMe()` method,
    first we need to move the `new` operator outside of `testMe()` as we cannot instantiate
    the `PoisonIvy` class. The constructor of `PoisonIvy` throws an exception. Hence,
    we cannot unit test the `testMe` behavior unless we move the object creation out
    of `testMe`. Instead of creating a new instance of `PoisonIvy` inside `testMe()`,
    we can pass an instance of `PoisonIvy` as a method argument, or create a class-level
    dependency and pass `PoisonIvy` as the constructor or setter dependency argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Program to an interface, not to an implementation. Rather than hardcoding the
    instantiation of the subtype into the code, assign the concrete implementation
    object at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: What is "program to an interface, not to an implementation"?
  prefs: []
  type: TYPE_NORMAL
- en: This means program to a supertype rather than a subtype. You can interchange
    the implementation at runtime. In the collection framework, we have the `List`
    interface and its many implantations. In your class, always define a variable
    of the `List` type and not `ArrayList`; at runtime, you can assign any implementation
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you can pass `PoisonIvy` as a constructor or setter dependency,
    and at runtime (during testing), you can pass a mock or a fake implementation
    to suppress the testing impediments.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring static variables and blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static initializations and `static` blocks are executed during class loading.
    You cannot override them. If you initialize a testing impediment in a `static`
    block, then you cannot unit test the class. The following example explains the
    issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StaticBlockOwner` class has a static variable named `StaticBlockDependency`,
    and it initializes the variable in a `static` block. The following is the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we unit test the class, it fails. The following is the unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The test fails with a `java.lang.ExceptionInInitializationError`, as it tries
    to instantiate the dependency in a `static` block and the dependency throws an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not instantiate dependencies in the static block. You cannot override the
    testing impediments.
  prefs: []
  type: TYPE_NORMAL
- en: The book *Working Effectively with Legacy Code*, *Pearson Education*, by Michael
    Feathers explains the legacy code and how effectively you can refactor the legacy
    code. You can read the e-book at [http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052).
  prefs: []
  type: TYPE_NORMAL
- en: Working with greenfield code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section illustrates the three-step rhythm of writing a failing test, coding
    enough to make it work, and then refactoring it. This is implied greenfield coding
    as opposed to working with an existing legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is an evolutionary development approach. It offers test-first development
    where the production code is written only to satisfy a test, and the code is refactored
    to improve the code quality. In TDD, unit tests drive the design. You write the
    code to satisfy a failing test, so it limits the code you write to only what is
    needed. The tests provide fast automated regression for refactoring and new enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Kent Beck is the originator of Extreme Programming and TDD. He has authored
    many books and papers. Visit [http://en.wikipedia.org/wiki/Kent_Beck](http://en.wikipedia.org/wiki/Kent_Beck)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the TDD life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with greenfield code](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: First, we write a failing test, then add code to satisfy the failing test, and
    then refactor the code and again start with another test.
  prefs: []
  type: TYPE_NORMAL
- en: The following section provides an example of TDD. We'll build a program to conduct
    an election survey and forecast the result. The program will compile the survey
    result and display the opinion poll.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should present the zone-wise (geographically) poll opinion and overall
    opinion, such as if there are two zones, east and west, then the result will be
    presented in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with greenfield code](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a test class named `SurveyResultCompilerTest` and add a `when_one_opinion_then_result_forecasts_the_opinion()`test
    to compile the overall survey result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll follow this convention for the test method names, for example, `when_some_condition_then_this_happens`.
    We will use the underscore symbol as a separator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this new test method, type in `SurveyResultCompiler()`. The compiler will
    complain that the `SurveyResultCompiler` class doesn't exist. Hover the mouse
    over `SurveyResultCompiler`; Eclipse will suggest a quick fix for you. Choose
    **Create class 'SurveyResultCompiler'**, and create the class in the `com.packt.tdd.survey`
    package under the `src` source folder, as shown in the following screenshot:![Working
    with greenfield code](img/00124.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SurveyResultCompiler` is ready. We need to pass an opinion to `SurveyResultCompiler`
    so that it can compile a result. Modify the test to call `willVoteFor` and pass
    an opinion. The compiler will complain that the method doesn''t exist. Add the
    method to `SurveyResultCompiler` by following the quick fix options. The following
    is the test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a compiled result after the survey. The result should give us the party
    name and winning percentage. We can think of a `Map` data type. Modify the test
    again to obtain the result. The following is the modified test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `forecastResult` method to the `SurveyResultCompiler` class. The following
    is the `SurveyResultCompiler` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that when only one person participates in a survey, then the survey
    result should return a 100 percent winning chance for the political party that
    the person votes for. The following assertion verifies our assumption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run the test, it fails with a `NullPointerException`. We need to modify
    the code as follows to return a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the test. It fails for an `AssertionError`. The following is the output:![Working
    with greenfield code](img/00125.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to modify the code to return 100 percent for `Party A`. The following
    is the modified code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the test. It will show you a green bar. The following is the output:![Working
    with greenfield code](img/00126.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add another test to verify that when two persons participate
    in a poll, and they vote for two different political parties, then the result
    should portray 50 percent chance for each party. Add a `when_different_opinions_then_forecasts_50_percent_chance_for_each_party`
    test, and add the following lines to verify the assumption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the test, it fails. It expects 50 percent but gets 100 percent,
    as shown in the following screenshot:![Working with greenfield code](img/00127.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to modify the code to return 50 percent for `Party A` and 50 percent
    for `Party B`. The following is the modified code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the test. The second test passes but the first test fails, as shown in
    the following screenshot:![Working with greenfield code](img/00128.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We broke the first test. Now we need to revert the changes, but then the second
    test will fail. We need an algorithm to calculate the percentage. First, we need
    to store the opinions. Add a `List` to the `SurveyResultCompiler` class and store
    each opinion. The following is the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to modify the `forecastResult` method to calculate the percentage.
    First, loop through the opinions to get the party-wise vote count, such as 10
    voters for `Party A` and 20 voters for `Party B`. Then, we can compute the percentage
    as *vote count * 100 / total votes*. The following is the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the test. You will get a green bar, as shown in the following screenshot:![Working
    with greenfield code](img/00129.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add a test for three participants. The following is the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look at the test class, and you will find the duplicate code in each test method;
    clean them. Move the `SurveyResultCompiler` object instantiation to a `setUp`
    method instead of instantiating the class in each test method. Inline are the
    `opinion` variables, such as `opinionA`. The following is the refactored test
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The test class looks clean now. Rerun the test to make sure nothing is broken.
    The following is the test output:![Working with greenfield code](img/00130.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Revisit the `SurveyResultCompiler` class. It works with a `List` and two `Map`
    attributes. Do we really need to keep the `List` attribute? Instead of calculating
    the votes from `List`, we can directly store the opinions in `Map` and keep the
    opinion count up to date. The following is the refactored code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the test to make sure nothing is broken. If anything breaks, then immediately
    revert the changes. The tests should run fine, so we are good to go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One feature is complete. Now we need to develop a new feature—zone-wise calculation.
    The existing test cases will safeguard our code. If you break any existing test,
    immediately revisit your change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What we just completed is TDD. It has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: TDD gives us clean, testable, and maintainable code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We document and update the code, but we forget to update the documentation;
    this creates confusion. You can document your code and keep it updated, or write
    your code and unit tests in such a way that anybody can understand the intent.
    In TDD, tests are written to provide enough documentation of code. So, the test
    is our documentation, but we need to clean the tests too to keep them readable
    and maintainable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write many tests with boundary value conditions, null, zero, negative
    numbers, and so on, and verify our code. And by passing these boundary values,
    you're trying to break your own code. No need to package the whole application
    and ship it to **Quality Assurance** (**QA**) or the customer to discover issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also avoid over engineering the classes you write. Just write what's needed
    to make all tests green.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another benefit to incrementally build your code is that your API is easier
    to work with because the code is written and used at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the unit testing strategy for the legacy code and new
    development. It covered the legacy code issues, refactored the legacy code, illustrated
    design for testability, described the TDD concepts and TDD life cycle, demonstrated
    TDD examples, and refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Now the reader should be able to write unit tests for legacy code, refactor
    the legacy code to improve the design of the existing code, and start writing
    simple, clean, and maintainable code that follows TDD, and refactor the code to
    improve its quality.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the best practices of unit testing.
  prefs: []
  type: TYPE_NORMAL
