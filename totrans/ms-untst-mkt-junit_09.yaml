- en: Chapter 9. Solving Test Puzzles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 解决测试难题
- en: '"We make a living by what we get, but we make a life by what we give."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我们通过我们所得到的东西谋生，但我们通过我们所给予的东西创造生活。”
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Winston Churchill
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——温斯顿·丘吉尔
- en: You may have worked in greenfield development projects that were written using
    **test-driven development** (**TDD**) and also in brownfield development or maintenance
    projects that were not written with TDD. You must have noticed that the test-first
    code written with TDD is easier to extend than the code with no unit test or unit
    tests written after coding.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能参与过使用**测试驱动开发**（**TDD**）编写的绿地开发项目，也参与过没有使用TDD编写的棕地开发或维护项目。你必须已经注意到，使用TDD编写的测试优先代码比没有单元测试或编码后编写的单元测试的代码更容易扩展。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A greenfield project starts building from scratch and doesn't consider any prior
    work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 绿地项目是从零开始构建的，不考虑任何先前的工作。
- en: A brownfield project is an extension of prior work or rebuilding a project from
    an existing project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 棕地项目是先前工作的扩展或从现有项目重建项目。
- en: 'This chapter covers the importance of unit testing in greenfield and brownfield
    projects. The following topics are covered in depth:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在绿地和棕地项目中单元测试的重要性。以下主题将进行深入探讨：
- en: Working with legacy code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与遗留代码一起工作
- en: Designing for testability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计可测试性
- en: Working with greenfield code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与绿地代码一起工作
- en: The *Working with legacy code* section covers the legacy code and explains how
    to unit test and refactor the legacy code. The *Designing for testability* section
    explains how to design for testability. The *Working with greenfield code* section
    elaborates on TDD, the TDD life cycle, refactoring, and concludes with an example
    of TDD.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “*与遗留代码一起工作*”部分涵盖了遗留代码，并解释了如何进行单元测试和重构遗留代码。“*设计可测试性*”部分解释了如何设计可测试性。“*与绿地代码一起工作*”部分详细阐述了TDD、TDD生命周期、重构，并以TDD的示例结束。
- en: Working with the legacy code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与遗留代码一起工作
- en: The term **legacy** is frequently used, as slang, to describe complex code,
    which is difficult to understand, is rigid and fragile in nature, and is almost
    impossible to enhance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**遗产**经常被用作俚语，用来描述复杂、难以理解、本质上是僵化和脆弱的代码，几乎不可能进行增强。
- en: However, the fact is that any code with no automated unit tests is legacy code.
    A piece of code can be well written. It can also follow coding guidelines, might
    be easy to understand, can be clean, loosely coupled, and very easy to extend.
    However, if it doesn't have automated unit tests, then it is legacy code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事实是，任何没有自动单元测试的代码都是遗留代码。一段代码可以写得很好。它也可以遵循编码指南，可能易于理解，可以干净、松散耦合，并且非常容易扩展。然而，如果没有自动单元测试，那么它就是遗留代码。
- en: Statistically, fixing bugs or adding new features to a legacy project is quite
    difficult than doing the same to a greenfield project. In legacy code, either
    automated unit tests do not exist or very few tests are written; the code is not
    designed for testability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 统计上，修复遗留项目中的错误或添加新功能比在绿地项目中做同样的事情要困难得多。在遗留代码中，要么没有自动单元测试，要么测试很少；代码没有设计为可测试。
- en: We inherit legacy code from some other source, maybe from a very old project,
    from another team that cannot maintain the code, or we acquire it from another
    company, but it is our duty to improve the quality.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从其他来源继承了遗留代码，可能来自一个非常古老的项目，来自无法维护代码的其他团队，或者我们从另一家公司获得它，但我们的责任是提高其质量。
- en: Unit tests give us some level of assurance that our code is doing what the code
    is expected to do, and they allow us to change the code quickly and verify the
    change faster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试为我们提供了一定程度的保证，即我们的代码正在执行预期的操作，并且允许我们快速更改代码并更快地验证更改。
- en: In general, legacy code is not testable and requires changes to the code structure
    (refactoring) to make it testable. However, the dilemma, most of the time, is
    that the legacy system is so crucial to the business that no one dares to touch
    the code. It makes no sense to modify an existing crucial module unless something
    is seriously wrong. Stalemate! You cannot refactor the code unless you have the
    automated test suite, and you cannot write tests as the code needs refactoring.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，遗留代码不可测试，需要修改代码结构（重构）才能使其可测试。然而，大多数情况下，遗留系统对业务至关重要，没有人敢触碰代码。除非出现严重问题，否则修改现有关键模块是没有意义的。僵局！除非你有自动测试套件，否则你不能重构代码，而且你不能在代码需要重构时编写测试。
- en: Sometimes it feels as though the legacy code, even with unit tests, are hard
    to understand, maintain, and enhance; hence, we need to be careful to make our
    tests readable and to avoid close coupling with the actual implementation details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时感觉即使有单元测试，遗留代码也很难理解、维护和增强；因此，我们需要小心地编写可读性强的测试，并避免与实际实现细节紧密耦合。
- en: Working with testing impediments
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与测试障碍一起工作
- en: 'This section explains the nature or quality of code that makes unit testing
    difficult. Automated tests help us develop software quickly even when we have
    a large code base to work on. However, automated tests should be executed very
    fast so that tests can give us quick feedback. We cannot unit test code when it
    exhibits any of the following features:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了使单元测试变得困难的代码的性质或质量。自动测试帮助我们快速开发软件，即使我们有一个庞大的代码库要处理。然而，自动测试应该执行得非常快，以便测试可以给我们提供快速反馈。当代码表现出以下任何特征时，我们无法对代码进行单元测试：
- en: It performs long running operations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行长时间运行的操作
- en: It connects to a database and modifies database records
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它连接到数据库并修改数据库记录
- en: It performs remote computing
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行远程计算
- en: It looks up JNDI resources or web/app server objects
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查找JNDI资源或Web/应用程序服务器对象
- en: It accesses the filesystem
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它访问文件系统
- en: It works with native objects or graphical widgets (UI components, alert, Java
    Swing components, and so on)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与原生对象或图形小部件（UI组件、警告、Java Swing组件等）一起工作
- en: It accesses network resources such as the LAN printer and downloads data from
    the Internet
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它访问网络资源，例如局域网打印机，并从互联网下载数据
- en: Unit tests should not wait for a long running process to complete; it will defeat
    the purpose of quick feedback.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不应该等待长时间运行的过程完成；这将违背快速反馈的目的。
- en: Unit tests should be reliable, and they should fail if and only if the production
    code is broken. However, if your unit test verifies an I/O operation, such as
    connecting to a LAN printer, which is slow, error prone, and unpredictable, then
    your unit test may fail due to some network issue, but it will incorrectly signal
    that the code is broken. So, unit testing a network operation defeats the test
    reliability principle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该是可靠的，并且只有在生产代码出错时才应该失败。然而，如果你的单元测试验证的是一个慢速、易出错且不可预测的I/O操作，例如连接到局域网打印机，那么你的单元测试可能会因为某些网络问题而失败，但它将错误地表明代码已损坏。因此，对网络操作进行单元测试违反了测试可靠性原则。
- en: Unit tests run automatically, so it doesn't make any sense to open a modal dialog
    or show an alert message during test execution because the test will wait, unless
    the UI dialog or the alert is closed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试会自动运行，所以在测试执行期间打开模态对话框或显示警告消息是没有意义的，因为测试将会等待，除非UI对话框或警告被关闭。
- en: 'So, the preceding features in the production code are barriers during unit
    testing. The following example shows how to avoid test impediments:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在生产代码中的前述特性在单元测试期间构成了障碍。以下示例展示了如何避免测试障碍：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `book()` method in the preceding example takes a movie, a show time, and
    the number of tickets to book, and it books the tickets or shows an error message.
    If an invalid movie or show time is passed to the `book` method, it shows an error
    message that states the movie or show time is not available. The following is
    the ticket booking logic:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，`book()`方法接受一个电影、一个放映时间和要预订的票数，并预订票或显示错误消息。如果传递给`book`方法的电影或放映时间无效，它将显示一个错误消息，指出电影或放映时间不可用。以下是为票务预订的逻辑：
- en: First, the book method finds a movie hall for the movie and the movie's show
    time, for example, the movie *The HOBBIT*, with show time *Evening* is being screened
    in *SCREEN 2*. If the movie is not being played, an error message is shown.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，查找方法会找到电影和电影的放映时间，例如，电影*The HOBBIT*，放映时间为*Evening*，正在*SCREEN 2*放映。如果电影没有放映，则会显示错误消息。
- en: It then retrieves the available seats, for example, 40 seats are available in
    *SCREEN 2* in the evening.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它检索可用的座位，例如，晚上在*SCREEN 2*有40个座位可用。
- en: If the requested numbers of seats are greater than the available number of seats,
    an error message is shown, for example, request for 10 tickets but only two seats
    available.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求的座位数超过可用座位数，则会显示错误消息，例如，请求10张票但只有两个座位可用。
- en: If the seats requested are available, then it loops through the seats and books
    them.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求的座位可用，那么它将遍历座位并预订它们。
- en: If any error occurs during seat booking, such as someone concurrently books
    the seat or some runtime error occurs, the relevant error message is displayed.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在座位预订过程中发生任何错误，例如有人同时预订了座位或发生了一些运行时错误，将显示相关的错误信息。
- en: 'The `BookingErrorController` class is responsible for displaying error messages.
    The following is the `BookingErrorController` class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingErrorController`类负责显示错误信息。以下是对`BookingErrorController`类的描述：'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each method calls `JOptionPane` to display messages. `JOptionPane` shows the
    modal dialog box, and the user has to click on the close button or the **Yes**/**No**
    button to close the dialog. If the user doesn't close the dialog box, the program
    keeps waiting for the user action.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都调用`JOptionPane`来显示消息。`JOptionPane`显示模态对话框，用户必须点击关闭按钮或**是**/**否**按钮来关闭对话框。如果用户不关闭对话框，程序将保持等待用户操作。
- en: So, you cannot unit test the movie ticket booking logic unless you separate
    the error message display from the code logic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非将错误信息显示与代码逻辑分离，否则你不能对电影票预订逻辑进行单元测试。
- en: 'The second thing to note is the `MovieDao` creation constructor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的事项是`MovieDao`的创建构造函数：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `book()` method instantiates a database access object and invokes methods
    on it. We should separate the direct database access object creation from code
    so that we can pass a mock data access object and stub out the database calls;
    otherwise, the `book()` method will instantiate the real `MovieDao` object and
    the test will take time to execute. For now, we'll unit test the code with the
    real data access logic and later refactor the code to separate the `MovieDao`
    object instantiation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`book()`方法实例化一个数据库访问对象并在其上调用方法。我们应该将直接创建数据库访问对象与代码分离，以便我们可以传递一个模拟数据访问对象并模拟数据库调用；否则，`book()`方法将实例化真实的`MovieDao`对象，测试将需要花费时间执行。目前，我们将使用真实的数据访问逻辑对代码进行单元测试，稍后对代码进行重构以分离`MovieDao`对象的实例化。'
- en: 'Create a `MovieTicketProTest` test class and add a sanity check method to call
    the `book` method with null objects. The following is the code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`MovieTicketProTest`测试类，并添加一个检查方法以调用带有null对象的`book`方法。以下是对代码片段的描述：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we execute the test in Eclipse, it shows an error message pop up, and
    the test waits for user action. The following is the Eclipse output, and you can
    see that the test is waiting for the pop up:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Eclipse中执行测试时，会弹出一个错误信息对话框，测试将等待用户操作。以下是Eclipse的输出，你可以看到测试正在等待弹出窗口：
- en: '![Working with testing impediments](img/00115.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![与测试障碍一起工作](img/00115.jpeg)'
- en: 'If we include the test on our automation suite, the automation suite will run
    forever and wait for user intervention. We can localize the problem; extract the
    protected methods for each `BookingErrorController` method call. This change will
    allow us to create a `MovieTicketPro` fake object and replace the protected methods
    with empty implementations. However, the problem is how do we verify the error
    conditions? We can extract an error message interface, create a generic error
    message method, and pass and refactor the `BookingErrorController` class to implement
    the interface. The following are the interface details:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将测试包含在我们的自动化测试套件中，自动化测试套件将永远运行并等待用户干预。我们可以定位问题；提取每个`BookingErrorController`方法调用中的受保护方法。这个更改将允许我们创建一个`MovieTicketPro`模拟对象并将受保护的方法替换为空实现。然而，问题是怎样验证错误条件？我们可以提取一个错误信息接口，创建一个通用的错误信息方法，并重构`BookingErrorController`类以实现该接口。以下是对接口的详细说明：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Modify the `BookingErrorController` class to implement the interface. The following
    is the implementation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`BookingErrorController`类以实现接口。以下是对实现的描述：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Modify the `MovieTicketPro` class and, inline, all the `BookingErrorController`
    calls. The following is an example of such a change:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`MovieTicketPro`类，并在行内修改所有对`BookingErrorController`的调用。以下是一个这样的修改示例：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the `BookingErrorController.createAndShowDatabaseSaveError()` and
    `BookingErrorController.createAndShowMovieOrShowTimeNotAvailableError()` methods
    are replaced by the original method content.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`BookingErrorController.createAndShowDatabaseSaveError()`和`BookingErrorController.createAndShowMovieOrShowTimeNotAvailableError()`方法被原始方法内容替换。
- en: Now remove the static error message methods from the `BookingErrorController`
    class. You should not get any compilation errors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从`BookingErrorController`类中删除静态错误信息方法。你不应该得到任何编译错误。
- en: 'Create a getter method in `MovieTicketPro` to return an implementation of `ErrorMessageDisplayer`.
    The following is the method body:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MovieTicketPro`中创建一个getter方法以返回`ErrorMessageDisplayer`的实现。以下是对方法的描述：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Replace all contents of the `JOptionPane.showMessageDialog` code with `getErrorMessageDisplayer()`.
    The following is the modified code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将`JOptionPane.showMessageDialog`代码的所有内容替换为`getErrorMessageDisplayer()`。以下是修改后的代码：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We need to separate the database access, create a getter method to return the
    `MovieDao` object, and call the getter method from the `book` method. From test,
    we can create a fake object and override the `getMovieDao()` method to return
    a mock data access object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分离数据库访问，创建一个返回`MovieDao`对象的getter方法，并从`book`方法中调用getter方法。从测试中，我们可以创建一个假对象并重写`getMovieDao()`方法以返回一个模拟数据访问对象。
- en: 'The following are the changes in the code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码中的更改：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the modified test:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的测试：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this change, the test execution finishes very quickly. The following
    is the test execution output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改后，测试执行完成得非常快。以下为测试执行输出：
- en: '![Working with testing impediments](img/00116.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![与测试障碍一起工作](img/00116.jpeg)'
- en: The next section covers designing for testability.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍为可测试性而设计。
- en: Designing for testability
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为可测试性设计
- en: We learned about testing impediments and how to refactor them. We cannot unit
    test code when testing impediments are present; we refactor the code and move
    the impediments out (to another class or methods), and during testing, the impediments
    are replaced with mock objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了测试障碍及其重构方法。当存在测试障碍时，我们无法对代码进行单元测试；我们重构代码，将障碍移出（到另一个类或方法），并在测试期间用模拟对象替换障碍。
- en: 'However, sometimes we cannot mock out the external dependencies because of
    testing an unfriendly design. This section covers the design for testability,
    or rather matters to avoid in code. The following Java constructs go up against
    mocking the testing impediments:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时由于测试不友好的设计，我们无法模拟外部依赖。本节涵盖了可测试性的设计，或者更确切地说，是代码中需要避免的问题。以下Java结构违反了模拟测试障碍：
- en: Constructors initialize testing impediments
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数初始化测试障碍
- en: Class-level variable declaration and initialization
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类级别变量声明和初始化
- en: The `private` methods
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`方法'
- en: The `final` methods
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`final`方法'
- en: The `static` methods
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`方法'
- en: The `final` classes
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`final`类'
- en: Use of `new`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`的使用'
- en: Static variable declaration and initialization
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量声明和初始化
- en: Static initialization blocks
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态初始化块
- en: You cannot unit test the legacy code because either it is tightly coupled or
    testing unfavorable language constructs hide the testing impediments. The following
    section explains the testing unfavorable constructs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于遗留代码要么耦合紧密，要么测试不利的语言结构隐藏了测试障碍，因此您无法对遗留代码进行单元测试。以下部分解释了测试不利的结构。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To show a testing impediment, we'll throw a special runtime exception `TestingImpedimentException`.
    If your test fails with a `TestingImpedimentException`, then that means you cannot
    automate the test as your code has unfavorable features for testing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示测试障碍，我们将抛出一个特殊的运行时异常`TestingImpedimentException`。如果您的测试因`TestingImpedimentException`而失败，那么这意味着您无法自动化测试，因为您的代码具有对测试不利的特性。
- en: Identifying constructor issues
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别构造函数问题
- en: To build a test, we need to instantiate the class in the test harness, but the
    problem with legacy code is that it is difficult to break dependency and instantiate
    a class in a test harness. One such example is in a constructor, where the class
    instantiates many objects, reads from the properties file, or even creates a database
    connection. There can be many callers of the class, so you cannot change the constructor
    to pass dependencies; otherwise, it will cause a series of compilation errors.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建测试，我们需要在测试框架中实例化类，但遗留代码的问题在于很难打破依赖关系并在测试框架中实例化类。一个这样的例子是在构造函数中，类实例化了多个对象，从属性文件中读取，甚至创建数据库连接。可能有多个类调用者，因此您不能更改构造函数以传递依赖关系；否则，将导致一系列编译错误。
- en: We will take a look at a sample legacy code and try to write a test for the
    class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个示例遗留代码，并尝试为该类编写测试。
- en: 'Suppose we have a `TestingUnfavorableConstructor` class with two external dependencies
    `DatabaseDependency` and `FileReadDependency`. Both the dependencies are slow
    in nature and are testing impediments. `TestingUnfavorableConstructor` creates
    dependencies in the constructor. Ideally, the dependencies represent the database
    access and the file reads from the `TestingUnfavorableConstructor` constructor.
    The following is the `TestingUnfavorableConstructor` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `TestingUnfavorableConstructor` 类，它有两个外部依赖 `DatabaseDependency` 和 `FileReadDependency`。这两个依赖都是缓慢的，并且是测试障碍。`TestingUnfavorableConstructor`
    在构造函数中创建依赖。理想情况下，这些依赖代表从 `TestingUnfavorableConstructor` 构造函数的数据库访问和文件读取。以下是 `TestingUnfavorableConstructor`
    类：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we want to unit test the `testMe()` behavior of the class, then we need
    to create an object of the `TestingUnfavorableConstructor` class. However, when
    we try to create an instance in a unit test, the class fails to indicate that
    the class cannot be instantiated from an automated test suite. The following is
    the output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对类的 `testMe()` 行为进行单元测试，那么我们需要创建一个 `TestingUnfavorableConstructor` 类的实例。然而，当我们尝试在单元测试中创建实例时，类无法从自动化测试套件中实例化，并显示错误。以下是输出：
- en: '![Identifying constructor issues](img/00117.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![识别构造函数问题](img/00117.jpeg)'
- en: To overcome this, you should inject the dependencies through a constructor instead
    of creating them in a constructor.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要克服这个问题，你应该通过构造函数注入依赖，而不是在构造函数中创建它们。
- en: 'We cannot modify the default constructor because the class is invoked from
    many other clients. We cannot break the clients. The other two options are as
    follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能修改默认构造函数，因为类被许多其他客户端调用。我们不能破坏客户端。其他两种选项如下：
- en: Keep the default constructor as it is. Create another constructor and inject
    dependencies through this new constructor; from test, we can call this new constructor.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持默认构造函数不变。创建另一个构造函数并通过这个新构造函数注入依赖；从测试中，我们可以调用这个新构造函数。
- en: Create a protected method, move the dependency instantiation to that method,
    create two setter methods, and initialize the dependencies through the setter
    injection. In the test, create a fake object of the main class and override the
    protected method to do nothing, and pass the dependencies through the setter methods.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个受保护的方法，将依赖实例化移动到那个方法，创建两个设置器方法，并通过设置器注入初始化依赖。在测试中，创建主类的模拟对象并覆盖受保护的方法使其不执行任何操作，并通过设置器方法传递依赖。
- en: The first option is relatively straight forward. We'll apply the second approach.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法相对简单。我们将应用第二种方法。
- en: 'The following is the modified code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是被修改的代码：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following unit test overrides the `TestingUnfavorableConstructor` and provides
    an empty implementation of the `createDependencies()` method, creates mock dependencies,
    and calls setter methods to set the mock dependencies:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下单元测试覆盖了 `TestingUnfavorableConstructor` 并提供了 `createDependencies()` 方法的空实现，创建了模拟依赖，并通过设置器方法设置模拟依赖：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not instantiate dependencies in the constructor; the dependencies may exhibit
    testing impediments and make the class nontestable. Instead of instantiating the
    dependencies in the constructor, you can pass the real implementations (real dependencies)
    to the constructor or the setter method of the code under the test.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在构造函数中实例化依赖；依赖可能表现出测试障碍，使类不可测试。而不是在构造函数中实例化依赖，你可以将真实实现（真实依赖）传递给构造函数或被测试代码的设置器方法。
- en: Realizing initialization issues
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识到初始化问题
- en: 'Class-level variable declaration and object instantiation at the same time
    creates problems. You don''t get the chance to mock out the variable. The following
    example explains the problem:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一时间进行类级别变量声明和对象实例化会引发问题。你将没有机会模拟变量。以下示例解释了这个问题：
- en: 'The `VariableInitialization` class has a database dependency, and the dependency
    is instantiated where it is declared, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`VariableInitialization` 类有一个数据库依赖，并且依赖在其声明的地方实例化，如下所示：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you instantiate the `VariableInitialization` class in test, the test fails.
    The following is the output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在测试中实例化 `VariableInitialization` 类时，测试会失败。以下是输出：
- en: '![Realizing initialization issues](img/00118.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![认识到初始化问题](img/00118.jpeg)'
- en: 'The following is the test class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试类：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To overcome the class-level variable initialization, you can try out the following
    options:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要克服类级别变量初始化，你可以尝试以下选项：
- en: Add a default constructor and move the dependency instantiation to the default
    constructor. Create another constructor and inject the dependencies through this
    new constructor; from test, we can call this the new constructor.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个默认构造函数并将依赖实例化移动到默认构造函数中。创建另一个构造函数并通过这个新构造函数注入依赖；从测试的角度来看，我们可以称这个新构造函数为“新构造函数”。
- en: Add a default constructor, and move the dependency instantiation to a protected
    method and call the method from the default constructor. Create a setter method
    and initialize the dependency through a setter injection. In the test, create
    a fake object of the main class and override the protected method to do nothing,
    and pass the dependencies through the setter methods.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个默认构造函数，并将依赖实例化移动到受保护的方法中，并从默认构造函数中调用该方法。创建一个设置方法并通过设置注入初始化依赖。在测试中，创建主类的一个假对象并覆盖受保护的方法使其不执行任何操作，并通过设置方法传递依赖项。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not instantiate variables at the class level.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要在类级别实例化变量。
- en: Working with private methods
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与私有方法一起工作
- en: 'The `private` methods are useful for hiding the internal state and encapsulation,
    but they can also hide the testing impediments. The following example explains
    the details:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 方法对于隐藏内部状态和封装很有用，但它们也可能隐藏测试障碍。以下示例解释了细节：'
- en: 'The `PrivateMethod` class has a `private` method named `showError()`. This
    `private` method hides a test impediment. When we unit test the `validate()` method
    with a `null` object, the `validate()` method calls the `showError` message, as
    follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrivateMethod` 类有一个名为 `showError()` 的 `private` 方法。此 `private` 方法隐藏了一个测试障碍。当我们使用
    `null` 对象对 `validate()` 方法进行单元测试时，`validate()` 方法会调用 `showError` 消息，如下所示：'
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the test output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试输出：
- en: '![Working with private methods](img/00119.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![与私有方法一起工作](img/00119.jpeg)'
- en: You can extract the testing impediments to a protected method, or you can separate
    the concern. Create a new class, move the testing impediment to that class, and
    inject the new class as a dependency.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将测试障碍提取到受保护的方法中，或者您可以分离关注点。创建一个新的类，将测试障碍移动到该类中，并将新类作为依赖项注入。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not hide testing impediments in private methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在私有方法中隐藏测试障碍。
- en: 'The following code refactors the testing impediments and makes the class unit
    testable:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码重构了测试障碍并使类可进行单元测试：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `showError` method's access specifier is changed to `protected`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`showError` 方法的访问修饰符更改为 `protected`。'
- en: 'The following test code extends the class with an anonymous implementation,
    and it overrides the protected method with an empty implementation. The test code
    invokes the `validate()` method on the new anonymous implementation of the `PrivateMethodRefactored`
    class. In turn, the polymorphic behavior will call the empty implementation. Hence,
    the test will always bypass the testing impediments by calling the overridden
    empty implementation of the testing impediment, but the real production code will
    always invoke the protected method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试代码通过匿名实现扩展了类，并使用空实现覆盖了受保护的方法。测试代码在 `PrivateMethodRefactored` 类的新匿名实现上调用
    `validate()` 方法。反过来，多态行为将调用空实现。因此，测试将通过调用测试障碍的覆盖空实现来绕过测试障碍，但实际的生产代码将始终调用受保护的方法：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This approach of bypassing the testing impediments with overridden versions
    of the testing impediments is known as faking or fake object. If the code under
    test contains many testing impediments, then it is not possible to override all
    of them in an anonymous class. Instead, we can create an inner class, and extend
    the code under test and override all the testing unfriendly methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通过覆盖测试障碍的版本来绕过测试障碍的方法被称为模拟或假对象。如果待测试的代码包含许多测试障碍，那么在匿名类中不可能覆盖所有这些障碍。相反，我们可以创建一个内部类，并扩展待测试的代码并覆盖所有不友好的方法。
- en: Working with final methods
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与最终方法一起工作
- en: 'When a method is final, you cannot override it. If the final method hides any
    testing impediment, you cannot unit test the class. The following example explains
    the issue:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法是最终方法时，您不能覆盖它。如果最终方法隐藏了任何测试障碍，您就不能对类进行单元测试。以下示例解释了这个问题：
- en: 'The `FinalDependency` class has a final method named `doSomething`. This method
    hides a testing unfriendly feature. The following is the class definition:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`FinalDependency` 类有一个名为 `doSomething` 的最终方法。此方法隐藏了一个对测试不友好的特性。以下是该类的定义：'
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `FinalMethodDependency` class has a dependency on `FinalDependency`, and
    in the `testMe` method, it calls the `doSomething` method as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`FinalMethodDependency` 类依赖于 `FinalDependency`，在 `testMe` 方法中，它按照以下方式调用 `doSomething`
    方法：'
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the test, we''ll mock the dependency and unit test the code as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们将模拟依赖项并按照以下方式对代码进行单元测试：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run the test, the test still accesses the testing impediment, as the
    mock object cannot stub a final method. When we try to stub the method, we get
    an error. The following test stubs the final method call:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，测试仍然访问测试障碍，因为模拟对象无法模拟最终方法。当我们尝试模拟方法时，我们会得到错误。以下测试模拟了最终方法调用：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run the test, we get the following error message thrown by the Mockito
    framework:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，Mockito 框架抛出了以下错误信息：
- en: '![Working with final methods](img/00120.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![与最终方法一起工作](img/00120.jpeg)'
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not hide the testing impediments in final methods. You cannot override or
    stub a final method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在最终方法中隐藏测试障碍。你不能重写或模拟最终方法。
- en: The only possible way to overcome this is extracting the content of the final
    method to a protected method; call the protected method from the final method,
    and override the protected method in test. Otherwise, you can use the PowerMock
    or PowerMockito framework if you cannot touch the class at all; for example, when
    you only have a JAR file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的唯一方法是将最终方法的内 容提取到一个 `protected` 方法中；从最终方法中调用 `protected` 方法，并在测试中重写 `protected`
    方法。否则，如果你根本无法接触该类，可以使用 PowerMock 或 PowerMockito 框架；例如，当你只有 JAR 文件时。
- en: Exploring static method issues
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索静态方法问题
- en: 'The `static` methods are good for utility classes, but unnecessary use of `static`
    can hide the testing impediments and create problems in unit testing. The following
    example sheds light on the issue:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 方法对实用类很有用，但过度使用 `static` 可能会隐藏测试障碍，并在单元测试中造成问题。以下示例说明了这个问题：'
- en: 'The `SingletonDependency` class is an implementation of the **Gang of Four**
    (**GoF**) singleton design pattern. It has a `private` constructor and a static
    `getInstance()` method to create only a single instance of the class. The static
    `callMe()` method hides a testing impediment. Note that the GoF singleton pattern
    doesn''t define methods as `static`, but in this example, we are defining the
    `callMe()` method as `static` to display a drawback of the `static` methods. The
    following is the singleton implementation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonDependency` 类是 **Gang of Four** (**GoF**) 单例设计模式的实现。它有一个 `private`
    构造函数和一个静态 `getInstance()` 方法来创建该类的一个唯一实例。静态 `callMe()` 方法隐藏了一个测试障碍。请注意，GoF 单例模式没有将方法定义为
    `static`，但在这个例子中，我们将 `callMe()` 方法定义为 `static` 以显示 `static` 方法的缺点。以下是对单例的实现：'
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `VictimOfAPatternLover` class has a dependency on `SingletonDependency`.
    The following are the class details:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`VictimOfAPatternLover` 类依赖于 `SingletonDependency`。以下是该类的详细信息：'
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Mockito cannot stub a static method. When we try to stub the static `callMe()`
    method, it still calls the original method and fails for the testing impediment.
    You cannot stub a `static` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 无法模拟静态方法。当我们尝试模拟静态 `callMe()` 方法时，它仍然调用原始方法，并因测试障碍而失败。你不能模拟 `static`
    方法。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not hide testing impediments in static methods. You cannot stub static methods.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在静态方法中隐藏测试障碍。你不能模拟静态方法。
- en: The only way to overcome this issue is to create a `protected` method and wrap
    the `static` call. From the code, call the wrapped method and from the test, override
    the `protected` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的唯一方法是在类中创建一个 `protected` 方法并包装 `static` 调用。从代码中调用包装方法，从测试中重写 `protected`
    方法。
- en: 'Add a `static` wrapper method in the dependency class and call the `static`
    method from it, as shown in the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖类中添加一个 `static` 包装方法，并从其中调用 `static` 方法，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the code, call the `wrapper` method as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，按照以下方式调用 `wrapper` 方法：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Stub the `wrapper` method in the test as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式在测试中模拟 `wrapper` 方法：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Working with final classes
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与最终类一起工作
- en: 'You cannot override a `final` class, so you can hide testing unfavorable features
    in a `final` class. The following example explains the problem:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能重写 `final` 类，因此你可以在 `final` 类中隐藏不利的测试特性。以下示例解释了这个问题：
- en: 'The final class hides a testing impediment as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最终类隐藏了一个测试障碍如下：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code under test has a dependency on the final class as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的代码依赖于最终类如下：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In test, we''ll try to stub the `poison` method as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们将尝试按照以下方式模拟 `poison` 方法：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The test fails with a **MockitoException** as Mockito cannot mock a final class.
    The following is the JUnit output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败是因为出现了 **MockitoException**，因为 Mockito 无法模拟一个最终的类。以下是 JUnit 的输出：
- en: '![Working with final classes](img/00121.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![与最终类一起工作](img/00121.jpeg)'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not hide testing impediments in final classes. You cannot mock a final class.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在最终的类中隐藏测试障碍。你不能模拟一个最终的类。
- en: Final classes are important for framework or architecture design so that no
    one can hack the behavior, but it can create a serious problem for unit testing.
    Consider it before you choose to make a class final.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最终类对于框架或架构设计很重要，这样就没有人可以黑客行为，但它可能会为单元测试造成严重问题。在你选择将类设置为最终之前，请考虑这一点。
- en: Learning the new attribute
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习新属性
- en: Java instantiates classes using the `new` operator, but a `new` operator can
    create problems for unit testing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Java 使用 `new` 操作符实例化类，但 `new` 操作符可能会为单元测试带来问题。
- en: 'The following example explains the issue. The `PoisonIvy` constructor has a
    testing impediment such as calls fetch data from a database table or reads from
    a filesystem; we represented the testing impediment with the `TestingImpedimentException`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个解释这个问题的例子。`PoisonIvy` 的构造函数有一个测试障碍，比如从数据库表获取数据或从文件系统中读取；我们用 `TestingImpedimentException`
    来表示测试障碍：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the code that calls the `PoisonIvy` constructor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调用 `PoisonIvy` 构造函数的代码：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When we unit test the `testMe()` code, it fails. The `testMe()` method directly
    creates an instance of dependency and calls the `poison()` method. You cannot
    override this `new` expression. If we want to unit test the `testMe()` method,
    first we need to move the `new` operator outside of `testMe()` as we cannot instantiate
    the `PoisonIvy` class. The constructor of `PoisonIvy` throws an exception. Hence,
    we cannot unit test the `testMe` behavior unless we move the object creation out
    of `testMe`. Instead of creating a new instance of `PoisonIvy` inside `testMe()`,
    we can pass an instance of `PoisonIvy` as a method argument, or create a class-level
    dependency and pass `PoisonIvy` as the constructor or setter dependency argument.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们单元测试 `testMe()` 代码时，它失败了。`testMe()` 方法直接创建了一个依赖项的实例并调用了 `poison()` 方法。你不能覆盖这个
    `new` 表达式。如果我们想对 `testMe()` 方法进行单元测试，首先我们需要将 `new` 操作符移出 `testMe()`，因为我们不能实例化
    `PoisonIvy` 类。`PoisonIvy` 的构造函数会抛出异常。因此，除非我们将对象创建移出 `testMe`，否则我们无法对 `testMe`
    的行为进行单元测试。而不是在 `testMe()` 内部创建 `PoisonIvy` 的新实例，我们可以将 `PoisonIvy` 的实例作为方法参数传递，或者创建一个类级别的依赖并将
    `PoisonIvy` 作为构造函数或设置器依赖参数传递。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Program to an interface, not to an implementation. Rather than hardcoding the
    instantiation of the subtype into the code, assign the concrete implementation
    object at runtime.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 面向接口编程，而不是面向实现。而不是将子类型的实例化硬编码到代码中，在运行时分配具体的实现对象。
- en: What is "program to an interface, not to an implementation"?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: “面向接口编程，而不是面向实现”是什么意思？
- en: This means program to a supertype rather than a subtype. You can interchange
    the implementation at runtime. In the collection framework, we have the `List`
    interface and its many implantations. In your class, always define a variable
    of the `List` type and not `ArrayList`; at runtime, you can assign any implementation
    you want.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着编写面向超类型而不是子类型的程序。你可以在运行时交换实现。在集合框架中，我们有 `List` 接口及其许多实现。在你的类中，始终定义一个 `List`
    类型的变量，而不是 `ArrayList`；在运行时，你可以分配任何你想要的实现。
- en: In this example, you can pass `PoisonIvy` as a constructor or setter dependency,
    and at runtime (during testing), you can pass a mock or a fake implementation
    to suppress the testing impediments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以将 `PoisonIvy` 作为构造函数或设置器依赖项传递，在运行时（测试期间），你可以传递一个模拟或伪造的实现来抑制测试障碍。
- en: Exploring static variables and blocks
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索静态变量和块
- en: 'Static initializations and `static` blocks are executed during class loading.
    You cannot override them. If you initialize a testing impediment in a `static`
    block, then you cannot unit test the class. The following example explains the
    issue:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 静态初始化和 `static` 块在类加载期间执行。你不能覆盖它们。如果你在一个 `static` 块中初始化一个测试障碍，那么你将无法对这个类进行单元测试。以下是一个解释这个问题的例子：
- en: 'The `StaticBlockOwner` class has a static variable named `StaticBlockDependency`,
    and it initializes the variable in a `static` block. The following is the class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticBlockOwner` 类有一个名为 `StaticBlockDependency` 的静态变量，并在一个 `static` 块中初始化这个变量。以下是这个类的代码：'
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we unit test the class, it fails. The following is the unit test:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对类进行单元测试时，它失败了。以下是一个单元测试：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The test fails with a `java.lang.ExceptionInInitializationError`, as it tries
    to instantiate the dependency in a `static` block and the dependency throws an
    exception.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败，出现`java.lang.ExceptionInInitializationError`异常，因为它尝试在`static`块中实例化依赖项，而依赖项抛出了异常。
- en: Tip
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not instantiate dependencies in the static block. You cannot override the
    testing impediments.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在静态块中实例化依赖项。你不能覆盖测试障碍。
- en: The book *Working Effectively with Legacy Code*, *Pearson Education*, by Michael
    Feathers explains the legacy code and how effectively you can refactor the legacy
    code. You can read the e-book at [http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Feathers所著的《*与遗留代码有效工作*》，由Pearson Education出版，解释了遗留代码以及你如何有效地重构遗留代码。你可以在[http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)上阅读电子书。
- en: Working with greenfield code
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与绿色代码一起工作
- en: This section illustrates the three-step rhythm of writing a failing test, coding
    enough to make it work, and then refactoring it. This is implied greenfield coding
    as opposed to working with an existing legacy code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本节说明了编写一个失败的测试、编写足够的代码使其工作，然后重构它的三步节奏。这是隐含的绿色代码开发，而不是与现有遗留代码一起工作。
- en: TDD is an evolutionary development approach. It offers test-first development
    where the production code is written only to satisfy a test, and the code is refactored
    to improve the code quality. In TDD, unit tests drive the design. You write the
    code to satisfy a failing test, so it limits the code you write to only what is
    needed. The tests provide fast automated regression for refactoring and new enhancements.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种进化式开发方法。它提供了测试优先的开发，生产代码仅编写以满足测试，代码被重构以提高代码质量。在TDD中，单元测试驱动设计。你编写代码以满足失败的测试，因此它限制了你要编写的代码仅限于所需的内容。测试提供了快速自动化的回归，用于重构和新增强。
- en: Kent Beck is the originator of Extreme Programming and TDD. He has authored
    many books and papers. Visit [http://en.wikipedia.org/wiki/Kent_Beck](http://en.wikipedia.org/wiki/Kent_Beck)
    for details.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Kent Beck是极限编程和TDD的创始人。他撰写了许多书籍和论文。访问[http://en.wikipedia.org/wiki/Kent_Beck](http://en.wikipedia.org/wiki/Kent_Beck)获取详细信息。
- en: 'The following diagram represents the TDD life cycle:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示了TDD的生命周期：
- en: '![Working with greenfield code](img/00122.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![与绿色代码一起工作](img/00122.jpeg)'
- en: First, we write a failing test, then add code to satisfy the failing test, and
    then refactor the code and again start with another test.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写一个失败的测试，然后添加代码以满足失败的测试，然后重构代码并再次从另一个测试开始。
- en: The following section provides an example of TDD. We'll build a program to conduct
    an election survey and forecast the result. The program will compile the survey
    result and display the opinion poll.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提供了一个TDD的示例。我们将构建一个进行选举调查并预测结果的程序。该程序将编译调查结果并显示意见调查。
- en: 'The result should present the zone-wise (geographically) poll opinion and overall
    opinion, such as if there are two zones, east and west, then the result will be
    presented in the following format:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应展示区域（地理上）的民意调查意见和总体意见，例如，如果有两个区域，东部和西部，则结果将以以下格式展示：
- en: '![Working with greenfield code](img/00123.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![与绿色代码一起工作](img/00123.jpeg)'
- en: 'Let''s look at the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: Create a test class named `SurveyResultCompilerTest` and add a `when_one_opinion_then_result_forecasts_the_opinion()`test
    to compile the overall survey result.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SurveyResultCompilerTest`的测试类，并添加一个`when_one_opinion_then_result_forecasts_the_opinion()`测试来编译总体调查结果。
- en: Note
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll follow this convention for the test method names, for example, `when_some_condition_then_this_happens`.
    We will use the underscore symbol as a separator.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将遵循这种约定来命名测试方法，例如，`when_some_condition_then_this_happens`。我们将使用下划线符号作为分隔符。
- en: In this new test method, type in `SurveyResultCompiler()`. The compiler will
    complain that the `SurveyResultCompiler` class doesn't exist. Hover the mouse
    over `SurveyResultCompiler`; Eclipse will suggest a quick fix for you. Choose
    **Create class 'SurveyResultCompiler'**, and create the class in the `com.packt.tdd.survey`
    package under the `src` source folder, as shown in the following screenshot:![Working
    with greenfield code](img/00124.jpeg)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新的测试方法中，输入`SurveyResultCompiler()`。编译器会抱怨`SurveyResultCompiler`类不存在。将鼠标悬停在`SurveyResultCompiler`上；Eclipse会为你提供一个快速修复建议。选择**创建类
    'SurveyResultCompiler'**，并在`src`源文件夹下的`com.packt.tdd.survey`包中创建该类，如图所示：![与绿色代码一起工作](img/00124.jpeg)
- en: '`SurveyResultCompiler` is ready. We need to pass an opinion to `SurveyResultCompiler`
    so that it can compile a result. Modify the test to call `willVoteFor` and pass
    an opinion. The compiler will complain that the method doesn''t exist. Add the
    method to `SurveyResultCompiler` by following the quick fix options. The following
    is the test method:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SurveyResultCompiler` 已经准备好了。我们需要传递一个意见给 `SurveyResultCompiler` 以便它可以编译一个结果。修改测试以调用
    `willVoteFor` 并传递一个意见。编译器会抱怨该方法不存在。通过快速修复选项将方法添加到 `SurveyResultCompiler` 中。以下是测试方法：'
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need a compiled result after the survey. The result should give us the party
    name and winning percentage. We can think of a `Map` data type. Modify the test
    again to obtain the result. The following is the modified test:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查后我们需要一个编译好的结果。结果应该给出政党名称和获胜百分比。我们可以考虑使用 `Map` 数据类型。再次修改测试以获取结果。以下是修改后的测试：
- en: '[PRE38]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the `forecastResult` method to the `SurveyResultCompiler` class. The following
    is the `SurveyResultCompiler` class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `forecastResult` 方法添加到 `SurveyResultCompiler` 类中。以下是 `SurveyResultCompiler`
    类：
- en: '[PRE39]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Verify that when only one person participates in a survey, then the survey
    result should return a 100 percent winning chance for the political party that
    the person votes for. The following assertion verifies our assumption:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证当只有一个人参与调查时，调查结果应该返回该人投票的政党100%的获胜机会。以下断言验证了我们的假设：
- en: '[PRE40]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we run the test, it fails with a `NullPointerException`. We need to modify
    the code as follows to return a result:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行测试时，它因为 `NullPointerException` 而失败。我们需要修改代码如下以返回一个结果：
- en: '[PRE41]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Rerun the test. It fails for an `AssertionError`. The following is the output:![Working
    with greenfield code](img/00125.jpeg)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试。它因为 `AssertionError` 而失败。以下是输出：![与绿色代码一起工作](img/00125.jpeg)
- en: 'We need to modify the code to return 100 percent for `Party A`. The following
    is the modified code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改代码以返回 `Party A` 100%。以下是修改后的代码：
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Rerun the test. It will show you a green bar. The following is the output:![Working
    with greenfield code](img/00126.jpeg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试。它将显示一个绿色条形图。以下是输出：![与绿色代码一起工作](img/00126.jpeg)
- en: 'Now we need to add another test to verify that when two persons participate
    in a poll, and they vote for two different political parties, then the result
    should portray 50 percent chance for each party. Add a `when_different_opinions_then_forecasts_50_percent_chance_for_each_party`
    test, and add the following lines to verify the assumption:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加另一个测试来验证当两个人参与投票，并且他们为两个不同的政党投票时，结果应该显示每个政党有50%的机会。添加一个 `when_different_opinions_then_forecasts_50_percent_chance_for_each_party`
    测试，并添加以下行来验证假设：
- en: '[PRE43]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we run the test, it fails. It expects 50 percent but gets 100 percent,
    as shown in the following screenshot:![Working with greenfield code](img/00127.jpeg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行测试时，它失败了。它期望得到50%，但得到了100%，如下截图所示：![与绿色代码一起工作](img/00127.jpeg)
- en: 'We need to modify the code to return 50 percent for `Party A` and 50 percent
    for `Party B`. The following is the modified code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改代码以返回 `Party A` 50% 和 `Party B` 50%。以下是修改后的代码：
- en: '[PRE44]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Rerun the test. The second test passes but the first test fails, as shown in
    the following screenshot:![Working with greenfield code](img/00128.jpeg)
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试。第二个测试通过，但第一个测试失败，如下截图所示：![与绿色代码一起工作](img/00128.jpeg)
- en: 'We broke the first test. Now we need to revert the changes, but then the second
    test will fail. We need an algorithm to calculate the percentage. First, we need
    to store the opinions. Add a `List` to the `SurveyResultCompiler` class and store
    each opinion. The following is the code:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们破坏了第一个测试。现在我们需要撤销更改，但第二个测试将失败。我们需要一个算法来计算百分比。首先，我们需要存储意见。向 `SurveyResultCompiler`
    类中添加一个 `List` 并存储每个意见。以下是代码：
- en: '[PRE45]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we need to modify the `forecastResult` method to calculate the percentage.
    First, loop through the opinions to get the party-wise vote count, such as 10
    voters for `Party A` and 20 voters for `Party B`. Then, we can compute the percentage
    as *vote count * 100 / total votes*. The following is the code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要修改 `forecastResult` 方法来计算百分比。首先，遍历意见以获取每个政党的投票计数，例如10个选民为 `Party A` 投票，20个选民为
    `Party B` 投票。然后，我们可以计算百分比作为 *投票计数 * 100 / 总投票数*。以下是代码：
- en: '[PRE46]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Rerun the test. You will get a green bar, as shown in the following screenshot:![Working
    with greenfield code](img/00129.jpeg)
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试。你将得到一个绿色条形图，如下截图所示：![与绿色代码一起工作](img/00129.jpeg)
- en: 'Now add a test for three participants. The following is the test:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个针对三个参与者的测试。以下是这个测试：
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Look at the test class, and you will find the duplicate code in each test method;
    clean them. Move the `SurveyResultCompiler` object instantiation to a `setUp`
    method instead of instantiating the class in each test method. Inline are the
    `opinion` variables, such as `opinionA`. The following is the refactored test
    class:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下测试类，你会在每个测试方法中找到重复的代码；清理它们。将`SurveyResultCompiler`对象的实例化移到`setUp`方法中，而不是在每个测试方法中实例化类。内联的是`opinion`变量，例如`opinionA`。以下是被重构的测试类：
- en: '[PRE48]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The test class looks clean now. Rerun the test to make sure nothing is broken.
    The following is the test output:![Working with greenfield code](img/00130.jpeg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试类现在看起来很干净。重新运行测试以确保没有出错。以下是测试输出：![处理绿色代码](img/00130.jpeg)
- en: 'Revisit the `SurveyResultCompiler` class. It works with a `List` and two `Map`
    attributes. Do we really need to keep the `List` attribute? Instead of calculating
    the votes from `List`, we can directly store the opinions in `Map` and keep the
    opinion count up to date. The following is the refactored code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾`SurveyResultCompiler`类。它与`List`和两个`Map`属性一起工作。我们真的需要保留`List`属性吗？我们可以在`Map`中直接存储意见而不是从`List`中计算投票，并保持意见计数最新。以下是被重构的代码：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Rerun the test to make sure nothing is broken. If anything breaks, then immediately
    revert the changes. The tests should run fine, so we are good to go.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试以确保没有出错。如果有任何错误，则立即撤销更改。测试应该运行良好，所以我们一切顺利。
- en: One feature is complete. Now we need to develop a new feature—zone-wise calculation.
    The existing test cases will safeguard our code. If you break any existing test,
    immediately revisit your change.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个特性已经完成。现在我们需要开发一个新特性——区域计算。现有的测试用例将保护我们的代码。如果你破坏了任何现有测试，立即回顾你的更改。
- en: 'What we just completed is TDD. It has the following benefits:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成的是TDD。它有以下好处：
- en: TDD gives us clean, testable, and maintainable code.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD为我们提供了干净、可测试和可维护的代码。
- en: We document and update the code, but we forget to update the documentation;
    this creates confusion. You can document your code and keep it updated, or write
    your code and unit tests in such a way that anybody can understand the intent.
    In TDD, tests are written to provide enough documentation of code. So, the test
    is our documentation, but we need to clean the tests too to keep them readable
    and maintainable.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们记录并更新代码，但忘记更新文档；这造成了混淆。你可以记录代码并保持其更新，或者以任何人都可理解的方式编写代码和单元测试。在TDD中，测试是为了提供足够的代码文档。因此，测试是我们的文档，但我们需要清理测试以保持其可读性和可维护性。
- en: We can write many tests with boundary value conditions, null, zero, negative
    numbers, and so on, and verify our code. And by passing these boundary values,
    you're trying to break your own code. No need to package the whole application
    and ship it to **Quality Assurance** (**QA**) or the customer to discover issues.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写许多带有边界值条件的测试，如null、零、负数等，并验证我们的代码。通过传递这些边界值，你试图破坏你自己的代码。无需打包整个应用程序并交付给**质量保证**（**QA**）或客户以发现问题。
- en: You also avoid over engineering the classes you write. Just write what's needed
    to make all tests green.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还避免了过度设计你编写的类。只需编写使所有测试变绿所需的内容。
- en: Another benefit to incrementally build your code is that your API is easier
    to work with because the code is written and used at the same time.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步构建代码的另一个好处是API更容易使用，因为代码是在编写和使用的同时编写的。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained the unit testing strategy for the legacy code and new
    development. It covered the legacy code issues, refactored the legacy code, illustrated
    design for testability, described the TDD concepts and TDD life cycle, demonstrated
    TDD examples, and refactoring.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了遗留代码和新开发的单元测试策略。它涵盖了遗留代码问题，重构了遗留代码，说明了可测试性设计，描述了TDD概念和TDD生命周期，演示了TDD示例和重构。
- en: Now the reader should be able to write unit tests for legacy code, refactor
    the legacy code to improve the design of the existing code, and start writing
    simple, clean, and maintainable code that follows TDD, and refactor the code to
    improve its quality.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在读者应该能够为遗留代码编写单元测试，重构遗留代码以改进现有代码的设计，并开始编写简单、干净、可维护的代码，遵循TDD，并重构代码以提高其质量。
- en: The next chapter covers the best practices of unit testing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍单元测试的最佳实践。
