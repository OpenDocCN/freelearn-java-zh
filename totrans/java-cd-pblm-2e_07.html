<html><head></head><body>
  <div id="_idContainer221" class="Basic-Text-Frame">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-313" class="chapterTitle">Foreign (Function) Memory API</h1>
    <p class="normal">This chapter includes 28 problems covering the Foreign Memory API and Foreign Linker API. We’ll start with the classical approaches for calling foreign functions relying on the JNI API and the open-source JNA/JNR libraries. Next, we’ll introduce the new approach delivered under the code name Project Panama (third review in JDK 21 and final release in JDK 22 as JEP 454). We’ll dissect the most relevant APIs, such as <code class="inlineCode">Arena</code>, <code class="inlineCode">MemorySegment</code>, <code class="inlineCode">MemoryLayout</code>, and so on. Finally, we’ll focus on the Foreign Linker API and the Jextract tool for calling foreign functions with different types of signatures, including callback functions.</p>
    <p class="normal">By the end of this chapter, you’ll be skilled in putting JNI, JNA, JNR, and, of course, Project Panama to work and you’ll be able to confidently answer any interview questions with this topic on the menu. </p>
    <h1 id="_idParaDest-314" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess in manipulating off-heap memory and calling native foreign functions from Java. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="144"><strong class="keyWord">Introducing Java Native Interface (JNI)</strong>: Write a Java application that calls a C/C++ native foreign function via the JNI API (for instance, implement in C a function with the following signature: <code class="inlineCode">long sumTwoInt(int x, int y)</code>).</li>
      <li class="numberedList"><strong class="keyWord">Introducing Java Native Access (JNA)</strong>: Write a Java application that calls a C/C++ native foreign function via the JNA API.</li>
      <li class="numberedList"><strong class="keyWord">Introducing Java Native Runtime (JNR)</strong>: Write a Java application that calls a C/C++ native foreign function via the JNR API.</li>
      <li class="numberedList"><strong class="keyWord">Motivating and introducing Project Panama</strong>: Provide a theoretical and meaningful transition from classical approaches of manipulating off-heap memory and foreign functions to the new Project Panama.</li>
      <li class="numberedList"><strong class="keyWord">Introducing Panama’s architecture and terminology</strong>: Provide a brief description of Project Panama, including architecture, terminology, and the main API components.</li>
      <li class="numberedList"><strong class="keyWord">Introducing Arena and MemorySegment</strong>: Explain and exemplify via snippets of code the <code class="inlineCode">Arena</code> and <code class="inlineCode">MemorySegment</code> APIs.</li>
      <li class="numberedList"><strong class="keyWord">Allocating arrays into memory segments</strong>: Write several approaches for allocating arrays into memory segments (via <code class="inlineCode">Arena</code> and <code class="inlineCode">MemorySegment</code>).</li>
      <li class="numberedList"><strong class="keyWord">Understanding addresses (pointers)</strong>: Exemplify the usage of memory addresses (pointers) in Java (<code class="inlineCode">ValueLayout.ADDRESS</code>).</li>
      <li class="numberedList"><strong class="keyWord">Introducing the sequence layout</strong>: Explain and exemplify the usage of the sequence layout. Moreover, introduce the <code class="inlineCode">PathElement</code> and <code class="inlineCode">VarHandle</code> APIs.</li>
      <li class="numberedList"><strong class="keyWord">Shaping C-like structs into memory segments</strong>: Exemplify the approach of shaping C-like structs via Java memory layouts (<code class="inlineCode">StructLayout</code>).</li>
      <li class="numberedList"><strong class="keyWord">Shaping C-like unions into memory segments</strong>: Exemplify the approach of shaping C-like unions via Java memory layouts (<code class="inlineCode">UnionLayout</code>).</li>
      <li class="numberedList"><strong class="keyWord">Introducing PaddingLayout</strong>: Provide a detailed explanation and meaningful examples for explaining padding layout (introduce <em class="italic">size</em>, <em class="italic">alignment</em>, <em class="italic">stride</em>, <em class="italic">padding</em>, and <em class="italic">order</em> of bytes).</li>
      <li class="numberedList"><strong class="keyWord">Copying and slicing memory segments</strong>: Exemplify different approaches for copying and slicing parts of a memory segment, including <code class="inlineCode">asOverlappingSlice()</code> and <code class="inlineCode">segmentOffset()</code>.</li>
      <li class="numberedList"><strong class="keyWord">Tackling the slicing allocator</strong>: Exemplify the usage of the slicing allocator (<code class="inlineCode">SegmentAllocator</code>).</li>
      <li class="numberedList"><strong class="keyWord">Introducing the slice handle</strong>: Explain and exemplify the usage of <code class="inlineCode">sliceHandle()</code>.</li>
      <li class="numberedList"><strong class="keyWord">Introducing layout flattening</strong>: Consider a hierarchical memory layout (for instance, two nested sequence layouts). Explain and exemplify how to flatten this model.</li>
      <li class="numberedList"><strong class="keyWord">Introducing layout reshaping</strong>: Provide an example that reshapes a hierarchical sequence layout.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the layout spreader</strong>: Provide a brief explanation and a simple example of using the layout spreader (<code class="inlineCode">asSpreader()</code>).</li>
      <li class="numberedList"><strong class="keyWord">Introducing the memory segment view VarHandle</strong>: Exemplify the usage of <code class="inlineCode">MethodHandles.memorySegmentViewVarHandle(ValueLayout layout)</code> for creating a <code class="inlineCode">VarHandle</code> that can be used to access a memory segment.</li>
      <li class="numberedList"><strong class="keyWord">Streaming memory segments</strong>: Write several snippets of code for combining memory segments with the Java Stream API.</li>
      <li class="numberedList"><strong class="keyWord">Tackling mapped memory segments</strong>: Provide a brief introduction of mapped memory segments and exemplify them in Java code.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Foreign Linker API</strong>: Provide a brief description of the Foreign Linker API, including <code class="inlineCode">Linker</code>, <code class="inlineCode">SymbolLookup</code>, <em class="italic">downcall</em>, and <em class="italic">upcall</em>.</li>
      <li class="numberedList"><strong class="keyWord">Calling the sumTwoInt() foreign function</strong>: Write a Java application that calls the <code class="inlineCode">sumTwoInt()</code> method (the <code class="inlineCode">long sumTwoInt(int x, int y)</code> implemented in <em class="italic">Problem 144</em>) via the Foreign Linker API.</li>
      <li class="numberedList"><strong class="keyWord">Calling the modf() foreign function</strong>: Use the Foreign Linker API to call the <code class="inlineCode">modf()</code> foreign function – this function is part of the C standard library.</li>
      <li class="numberedList"><strong class="keyWord">Calling the strcat() foreign function</strong>: Use the Foreign Linker API to call the <code class="inlineCode">strcat()</code> foreign function – this function is part of the C standard library.</li>
      <li class="numberedList"><strong class="keyWord">Calling the bsearch() foreign function</strong>: Use the Foreign Linker API to call the <code class="inlineCode">bsearch()</code> foreign function – this function is part of the C standard library.</li>
      <li class="numberedList"><strong class="keyWord">Introducing Jextract</strong>: Provide a brief description of the Jextract tool, including the main options.</li>
      <li class="numberedList"><strong class="keyWord">Generating native binding for modf()</strong>: Exemplify the combination of Jextract and the Foreign Linker API to call the <code class="inlineCode">modf()</code> foreign function.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07</span></a>.</p>
    <h1 id="_idParaDest-315" class="heading-1">144. Introducing Java Native Interface (JNI)</h1>
    <p class="normal"><strong class="keyWord">Java Native Interface</strong> (<strong class="keyWord">JNI</strong>) was <a id="_idIndexMarker767"/>the first Java API meant to act as a bridge between JVM bytecode and native code written in another programming language (typically C/C++).</p>
    <p class="normal">Let’s suppose that we plan to call via JNI a C function on a Windows 10, 64-bit machine. </p>
    <p class="normal">For instance, let’s consider that we have a C function for summing two integers called <code class="inlineCode">sumTwoInt(int x, int y)</code>. This function is defined in a C shared library named <code class="inlineCode">math.dll</code>. Calling such functions from Java (generally speaking, functions implemented by native shared libraries) starts with loading the proper shared native library via <code class="inlineCode">System.loadLibrary(String library)</code>. Next, we declare the C function in Java via the <code class="inlineCode">native</code> keyword. Finally, we call it with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> modern.challenge;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">static</span> { 
    System.loadLibrary(<span class="hljs-string">"math"</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title">sumTwoInt</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x, </span><span class="hljs-type">int</span><span class="hljs-params"> y)</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Main</span>().sumTwoInt(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
    System.out.println(<span class="hljs-string">"Result: "</span> + result);
  } 
}
</code></pre>
    <p class="normal">Next, we focus on C implementation. We need the header file (the <code class="inlineCode">.h</code> file) and the source file that implements this method (the <code class="inlineCode">.cpp</code> file). </p>
    <h2 id="_idParaDest-316" class="heading-2">Generating the header (.h) file</h2>
    <p class="normal">The <a id="_idIndexMarker768"/>header file (definition of the method) can be obtained by running <code class="inlineCode">javac</code> with the <code class="inlineCode">–h</code> option against our <code class="inlineCode">Main.java</code> source, as in the following figure (before JDK 9, use <code class="inlineCode">javah</code>):</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_01.png" alt="Figure 7.1.png"/></figure>
    <p class="packt_figref">Figure 7.1: Running javac –h to compile source code and generate the .h file</p>
    <p class="normal">Or, as <a id="_idIndexMarker769"/>plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P144_EngagingJNI&gt;
  javac –h src/main/java/modern/challenge/cpp –d target/classes src/main/java/modern/challenge/Main.java
</code></pre>
    <p class="normal">This command compiles our code (<code class="inlineCode">Main.java</code>) and places the resulting class in the <code class="inlineCode">target/classes</code> folder. In addition, this command generates the C header <code class="inlineCode">modern_challenge_Main.h</code> in <code class="inlineCode">jni/cpp</code>. The important code of this file is listed here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Class:     modern_challenge_Main</span>
<span class="hljs-comment"> * Method:    sumTwoInt</span>
<span class="hljs-comment"> * Signature: (II)J</span>
<span class="hljs-comment"> */</span>
JNIEXPORT jlong JNICALL <span class="hljs-title">Java_modern_challenge_Main_sumTwoInt</span>
  <span class="hljs-params">(JNIEnv *, jobject, jint, jint)</span>;
</code></pre>
    <p class="normal">The function name was generated as <code class="inlineCode">Java_modern_challenge_Main_sumTwoInt</code>. Moreover, we have here the following artifacts:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">JNIEXPORT</code> – the function is marked as exportable</li>
      <li class="bulletList"><code class="inlineCode">JNICALL</code> – sustains <code class="inlineCode">JNIEXPORT</code> to guarantee that the function can be found by JNI</li>
      <li class="bulletList"><code class="inlineCode">JNIEnv</code> – represents a pointer to the JNI environment for accessing JNI functions</li>
      <li class="bulletList"><code class="inlineCode">jobject</code> – represents <a id="_idIndexMarker770"/>a reference to this Java object</li>
    </ul>
    <h2 id="_idParaDest-317" class="heading-2">Implementing the modern_challenge_Main.cpp</h2>
    <p class="normal">Next, we provide the <a id="_idIndexMarker771"/>C implementation in <code class="inlineCode">src/main/java/modern/challenge/cpp</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;iostream&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">"modern_challenge_Main.h"</span>
<span class="hljs-function">JNIEXPORT jlong JNICALL </span><span class="hljs-title">Java_modern_challenge_Main_sumTwoInt</span>
<span class="hljs-function">  </span><span class="hljs-params">(JNIEnv* env, jobject thisObject, jint x, jint y)</span><span class="hljs-function"> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"C++: The received arguments are : "</span> 
      &lt;&lt; x &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; y &lt;&lt; std::endl;
  <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)x + (<span class="hljs-type">long</span>)y;
}
</code></pre>
    <p class="normal">This is a <a id="_idIndexMarker772"/>simple snippet of C code that prints a message and returns <code class="inlineCode">x</code> + <code class="inlineCode">y</code> as a <code class="inlineCode">long</code> result.</p>
    <h2 id="_idParaDest-318" class="heading-2">Compiling the C source code</h2>
    <p class="normal">So far, we have the <a id="_idIndexMarker773"/>C source code (the <code class="inlineCode">.cpp</code> file) and the generated header (<code class="inlineCode">.h</code>). Next, we have to compile the C source code, and for this, we need a C compiler. There are many options, like Cygwin, MinGW, and so on. </p>
    <p class="normal">We decided to install <a id="_idIndexMarker774"/>MinGW (<a href="https://sourceforge.net/projects/mingw-w64/"><span class="url">https://sourceforge.net/projects/mingw-w64/</span></a>) for 64-bit platforms and use the G++ compiler. </p>
    <p class="normal">Having G++ in our hands, we have to trigger a specific command for compiling the C code, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_02.png" alt="Figure 7.2.png"/></figure>
    <p class="packt_figref">Figure 7.2: Compiling the C source code</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P144_EngagingJNI&gt;
  g++ -c "-I%JAVA_HOME%\include" "-I%JAVA_HOME%\include\win32" 
  src/main/java/modern/challenge/cpp/modern_challenge_Main.cpp  
  –o jni/cpp/modern_challenge_Main.o
</code></pre>
    <p class="normal">Next, we have to pack everything in <code class="inlineCode">math.dll</code>.</p>
    <h2 id="_idParaDest-319" class="heading-2">Generating the native shared library</h2>
    <p class="normal">It is time to create the native<a id="_idIndexMarker775"/> shared library, <code class="inlineCode">math.dll</code>. For this, we use G++ again, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_03.png" alt="Figure 7.3.png"/></figure>
    <p class="packt_figref">Figure 7.3: Creating the math.dll</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P144_EngagingJNI&gt;
  g++ -shared –o jni/cpp/math.dll jni/cpp/modern_challenge_Main.o 
  –static –m64 –Wl,--add-stdcall-alias
</code></pre>
    <p class="normal">Notice that we have used the <code class="inlineCode">–static</code> option. This option instructs G++ to add in <code class="inlineCode">math.dll</code> all dependencies. If you dislike this approach, then you may need to manually add the dependencies in order to avoid <code class="inlineCode">java.lang.UnsatisfiedLinkError</code> errors. To find out the missing dependencies, you can use a DLL dependency walker<a id="_idIndexMarker776"/> such as this one: <a href="https://github.com/lucasg/Dependencies"><span class="url">https://github.com/lucasg/Dependencies</span></a>.</p>
    <h2 id="_idParaDest-320" class="heading-2">Finally, run the code</h2>
    <p class="normal">Finally, we can run the code. Keep your fingers crossed and execute the command in the following figure:</p>
    <p class="normal"><img src="../Images/B19665_07_04.png" alt="Figure 7.4.png"/></p>
    <p class="packt_figref">Figure 7.4: Executing the Java code</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P144_EngagingJNI&gt;  java –Djava.library.path=jni/cpp 
  –classpath target/classes modern.challenge.Main
</code></pre>
    <p class="normal">Notice that we <a id="_idIndexMarker777"/>should set the library path; otherwise, Java will not be able to load <code class="inlineCode">math.dll</code>. If everything worked fine, then you should see the output from this figure. </p>
    <p class="normal">Well, as you can easily conclude, JNI is not easy to use. Imagine doing all this work for an entire C library like TensorFlow, which has 200+ functions. Besides being hard to use, JNI also faces a lot of shortcomings, for example, it is error-prone, hard to maintain, and brittle, it has poor exception support, JNI errors can crash the JVM, it has a maximum off-heap of 2 GB allocated via <code class="inlineCode">ByteBuffer</code> that cannot be directly free (we have to wait for the garbage collector to do it), and many more. Despite all this, it is still worth learning this technique because, as you’ll surely know, management is often not quick to adopt new ways of doing things.</p>
    <p class="normal">With this in mind, the community came up with other approaches that we will discuss in the next problems.</p>
    <h1 id="_idParaDest-321" class="heading-1">145. Introducing Java Native Access (JNA)</h1>
    <p class="normal"><strong class="keyWord">Java Native Access</strong> (<strong class="keyWord">JNA</strong>) is a<a id="_idIndexMarker778"/> brave open-source attempt to address JNI complexity via a more intuitive and easy-to-use API. Being a third-party library, JNA must be added as a dependency in our project:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;dependency&gt;
  &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;
  &lt;artifactId&gt;jna-platform&lt;/artifactId&gt;
  &lt;version&gt;<span class="hljs-number">5.8.0</span>&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    <p class="normal">Next, let’s try to call the same <code class="inlineCode">sumTwoInt()</code> method from <em class="italic">Problem 144</em>. This function is defined in a C native shared library named <code class="inlineCode">math.dll</code> and stored in our project in the <code class="inlineCode">jna/cpp</code> folder.</p>
    <p class="normal">We start by writing a Java interface that extends JNA’s <code class="inlineCode">Library</code> interface. This interface contains declarations of methods and types that we plan to call from Java and are defined in native code. We write the <code class="inlineCode">SimpleMath</code> interface containing the <code class="inlineCode">sumTwoInt()</code> declaration as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">SimpleMath</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Library</span> { 
  <span class="hljs-type">long</span> <span class="hljs-title">sumTwoInt</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x, </span><span class="hljs-type">int</span><span class="hljs-params"> y)</span>;
}
</code></pre>
    <p class="normal">Next, we have to<a id="_idIndexMarker779"/> instruct JNA to load the <code class="inlineCode">math.dll</code> library and generate a concrete implementation of this interface so we can call its methods. For this, we need the <code class="inlineCode">jna.library.path</code> system property and JNA’s <code class="inlineCode">Native</code> class, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"> package</span> modern.challenge;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    System.setProperty(<span class="hljs-string">"jna.library.path"</span>, <span class="hljs-string">"</span><span class="hljs-string">./jna/cpp"</span>);
    <span class="hljs-type">SimpleMath</span> <span class="hljs-variable">math</span> <span class="hljs-operator">=</span> Native.load(Platform.isWindows() 
      ? <span class="hljs-string">"math"</span> : <span class="hljs-string">"NOT_WINDOWS"</span>, SimpleMath.class);
    <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> math.sumTwoInt(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
    System.out.println(<span class="hljs-string">"Result: "</span> + result);
  }
}
</code></pre>
    <p class="normal">Here, we instruct JNA to load <code class="inlineCode">math.dll</code> from <code class="inlineCode">jna/cpp</code> via <code class="inlineCode">System.setProperty()</code>, but you can also do it from a terminal via <code class="inlineCode">–Djna.library.path=jna/cpp</code>.</p>
    <p class="normal">Next, we call <code class="inlineCode">Native.load()</code>, which takes two arguments. First, it takes the native library name, which in our case is <code class="inlineCode">math</code> (without the <code class="inlineCode">.dll</code> extension). Second, it takes the Java interface containing the declaration of the methods, which in our case is <code class="inlineCode">SimpleMath.class</code>. The <code class="inlineCode">load()</code> method returns a concrete implementation of <code class="inlineCode">SimpleMath</code> that we use to call the <code class="inlineCode">sumTwoInt()</code> method. </p>
    <p class="normal">The JNA <code class="inlineCode">Platform</code> helper <a id="_idIndexMarker780"/>allows us to provide the name of the native library specific to the current operating system. We have only <code class="inlineCode">math.dll</code> for Windows.</p>
    <h2 id="_idParaDest-322" class="heading-2">Implementing the .cpp and .h files</h2>
    <p class="normal">This time, there is no <a id="_idIndexMarker781"/>naming convention <a id="_idIndexMarker782"/>from the <code class="inlineCode">.cpp</code> and <code class="inlineCode">.h</code> files, so let’s name them <code class="inlineCode">Arithmetic.cpp</code> and <code class="inlineCode">Arithmetic.h</code> (the header file is optional). The source code of <code class="inlineCode">Artihmetic.cpp</code> is basically plain C code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;iostream&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">"Arithmetic.h"</span>
<span class="hljs-type">long</span><span class="hljs-function"> </span><span class="hljs-title">sumTwoInt</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x, </span><span class="hljs-type">int</span><span class="hljs-params"> y)</span><span class="hljs-function"> </span>{
  std::cout &lt;&lt; <span class="hljs-string">"C++: The received arguments are : "</span> &lt;&lt; x &lt;&lt;
     <span class="hljs-string">" and "</span> &lt;&lt; y &lt;&lt; std::endl;
  <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)x + (<span class="hljs-type">long</span>)y;
}
</code></pre>
    <p class="normal">As you can see, with JNA, there is no need to patch our code with the JNI-specific bridge code. It is only plain C code. The <code class="inlineCode">Arithmetic.h</code> is optional and we can write it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">ifndef</span><span class="hljs-meta"> FUNCTIONS_H_INCLUDED</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> FUNCTIONS_H_INCLUDED</span>
  <span class="hljs-type">long</span><span class="hljs-function"> </span><span class="hljs-title">sumTwoInt</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x, </span><span class="hljs-type">int</span><span class="hljs-params"> y)</span>;  
<span class="hljs-meta">#</span><span class="hljs-keyword">endif</span>
</code></pre>
    <p class="normal">Next, we can compile our code.</p>
    <h2 id="_idParaDest-323" class="heading-2">Compiling the C source code</h2>
    <p class="normal">Compiling the<a id="_idIndexMarker783"/> C source code is done via the G++ compiler with the command from the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_05.png" alt="Figure 7.5.png"/></figure>
    <p class="packt_figref">Figure 7.5: Compiling the C++ code</p>
    <p class="normal">Or, as<a id="_idIndexMarker784"/> plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P145_EngagingJNA&gt;
  g++ -c "-I%JAVA_HOME%\include" "-I%JAVA_HOME%\include\win32" 
  src/main/java/modern/challenge/cpp/Arithmetic.cpp 
  –o jna/cpp/Arithmetic.o
</code></pre>
    <p class="normal">Next, we can generate the proper native library.</p>
    <h2 id="_idParaDest-324" class="heading-2">Generating the native shared library</h2>
    <p class="normal">It is time to<a id="_idIndexMarker785"/> create the native shared library, <code class="inlineCode">math.dll</code>. For this, we use G++ again as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_06.png" alt="Figure 7.6.png"/></figure>
    <p class="packt_figref">Figure 7.6: Generating math.dll</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P145_EngagingJNA&gt;g++ -shared –o jna/cpp/math.dll jna/cpp/Arithmetic.o –static –m64             –Wl,--add-stdcall-alias
</code></pre>
    <p class="normal">At this point, you should have <code class="inlineCode">math.dll</code> in the <code class="inlineCode">jna/cpp</code> folder.</p>
    <h2 id="_idParaDest-325" class="heading-2">Finally, run the code</h2>
    <p class="normal">Finally, we can <a id="_idIndexMarker786"/>run the code. If everything worked fine, then you’re done. Otherwise, if you get an exception such as <code class="inlineCode">java.lang.UnsatisfiedLinkError:</code> <em class="italic">Error looking up function 'sumTwoInt': The specified procedure could not be found</em>, then you have to fix it.</p>
    <p class="normal">But what<a id="_idIndexMarker787"/> happened? Most probably, the G++ compiler has applied a technique referred to as <em class="italic">name mangling</em> (or, <em class="italic">name decoration</em>) – <a href="https://en.wikipedia.org/wiki/Name_mangling"><span class="url">https://en.wikipedia.org/wiki/Name_mangling</span></a>. In other words, the G++ compiler has renamed the <code class="inlineCode">sumTwoInt()</code> method to something else that is not known to JNA.</p>
    <p class="normal">Solving this <a id="_idIndexMarker788"/>issue can be done in two steps. First, we need to inspect <code class="inlineCode">math.dll</code> with a DLL dependency walker such as this one, <a href="https://github.com/lucasg/Dependencies"><span class="url">https://github.com/lucasg/Dependencies</span></a>. As you can see in the following figure, G++ has renamed <code class="inlineCode">sumTwoInt</code> to <code class="inlineCode">_Z9sumTwoIntii</code> (of course, on your computer, it could be another name):</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_07.png" alt="Figure 7.7.png"/></figure>
    <p class="packt_figref">Figure 7.7: G++ has renamed sumToInt to _Z9sumTwoIntii</p>
    <p class="normal">Second, we have to tell JNA about this name (<code class="inlineCode">_Z9sumTwoIntii</code>). Basically, we need to define a <code class="inlineCode">Map</code> containing the corresponding mapping of names and pass this map to a flavor of <code class="inlineCode">Native.load()</code> that takes this map as the last argument. The code is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> Map MAPPINGS;
  <span class="hljs-type">static</span> {
    MAPPINGS = Map.<span class="hljs-built_in">of</span>(
      Library.OPTION_FUNCTION_MAPPER,
      <span class="hljs-keyword">new</span> <span class="hljs-built_in">StdCallFunctionMapper</span>() {
      Map&lt;String, String&gt; methodNames
        = Map.<span class="hljs-built_in">of</span>(<span class="hljs-string">"sumTwoInt"</span>, <span class="hljs-string">"_Z9sumTwoIntii"</span>);
      @Override
      <span class="hljs-keyword">public</span> String <span class="hljs-built_in">getFunctionName</span>(
             NativeLibrary library, Method method) {
        String methodName = method.<span class="hljs-built_in">getName</span>();
        <span class="hljs-keyword">return</span> methodNames.<span class="hljs-built_in">get</span>(methodName);
      }
    });
  }
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-type">static</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-function"> </span>{ 
    System.<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">"</span><span class="hljs-string">jna.library.path"</span>, <span class="hljs-string">"./jna/cpp"</span>);
    SimpleMath math = Native.<span class="hljs-built_in">load</span>(Platform.<span class="hljs-built_in">isWindows</span>() 
      ? <span class="hljs-string">"math"</span> : <span class="hljs-string">"NOT_WINDOWS"</span>, SimpleMath.<span class="hljs-keyword">class</span>, MAPPINGS);
    <span class="hljs-type">long</span> result = math.<span class="hljs-built_in">sumTwoInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Result: "</span> + result);
  }
}
</code></pre>
    <p class="normal">Done! Now, you should obtain the result of 3+9. Feel free to explore JNA further, and attempt to use C/C++ structures, unions, and pointers.</p>
    <h1 id="_idParaDest-326" class="heading-1">146. Introducing Java Native Runtime (JNR)</h1>
    <p class="normal"><strong class="keyWord">Java Native Runtime</strong> (<strong class="keyWord">JNR</strong>) is another <a id="_idIndexMarker789"/>open-source attempt to address JNI’s complexity. It is a serious competitor for JNA, having a more intuitive and powerful API than JNI. </p>
    <p class="normal">We can add it as a dependency as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;dependency&gt;
    &lt;groupId&gt;com.github.jnr&lt;/groupId&gt;
    &lt;artifactId&gt;jnr-ffi&lt;/artifactId&gt;
    &lt;version&gt;<span class="hljs-number">2.2.13</span>&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    <p class="normal">Let’s assume that we have the exact same C method (<code class="inlineCode">sumTwoInt()</code>) and the native shared library (<code class="inlineCode">math.dll</code>) from <em class="italic">Problem 145</em>.</p>
    <p class="normal">We start by writing a Java interface containing the declarations of methods and types that we plan to call from Java and are defined in native code. We write the <code class="inlineCode">SimpleMath</code> interface containing the <code class="inlineCode">sumTwoInt()</code> declaration as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">SimpleMath</span> { 
  <span class="hljs-meta">@IgnoreError</span>
  <span class="hljs-type">long</span> <span class="hljs-title">sumTwoInt</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x, </span><span class="hljs-type">int</span><span class="hljs-params"> y)</span>;
}
</code></pre>
    <p class="normal">The <code class="inlineCode">@IgnoreError</code> annotation instructs JNR to not save the <em class="italic">errno value </em>(<a href="https://www.geeksforgeeks.org/errno-constant-in-c/"><span class="url">https://www.geeksforgeeks.org/errno-constant-in-c/</span></a>).</p>
    <p class="normal">Next, we have to instruct JNR to load the <code class="inlineCode">math.dll</code> library and generate a concrete implementation of this interface so we can call its methods. For this, we need the <code class="inlineCode">LibraryLoader</code> and the following intuitive code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
  LibraryLoader&lt;SimpleMath&gt; loader = 
            FFIProvider.getSystemProvider()
  .createLibraryLoader(SimpleMath.class)
  .search(<span class="hljs-string">"./jnr/cpp"</span>)
  .map(<span class="hljs-string">"sumTwoInt"</span>, <span class="hljs-string">"_Z9sumTwoIntii"</span>);
  loader = loader.map(<span class="hljs-string">"sumTwoInt"</span>, <span class="hljs-string">"_Z9sumTwoIntii"</span>);
  <span class="hljs-keyword">if</span> (Platform.getNativePlatform().getOS() 
   == Platform.OS.WINDOWS) {
   <span class="hljs-variable">SimpleMath</span> <span class="hljs-type">simpleMath</span> = loader.load(<span class="hljs-string">"math"</span>); 
   <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> simpleMath.sumTwoInt(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
   System.out.println(<span class="hljs-string">"Result: "</span> + result);
  }
 }
}
</code></pre>
    <p class="normal">Via the <code class="inlineCode">LibraryLoader</code> API, we prepare the playground. We instruct JNR that our library is located in <code class="inlineCode">jnr/cpp</code> via the <code class="inlineCode">search()</code> method. Moreover, we provide the proper mapping of the method’s names via the <code class="inlineCode">map()</code> method (remember from <em class="italic">Problem 145</em> that G++ renames the method via <em class="italic">name mangling</em> (or, <em class="italic">name decoration</em>) from <code class="inlineCode">sumTwoInt</code> to <code class="inlineCode">_Z9sumTwoIntii</code>).</p>
    <p class="normal">Finally, we load the library via the <code class="inlineCode">load()</code> method and call the <code class="inlineCode">sumTwoInt()</code> method. </p>
    <p class="normal">JNR provides many <a id="_idIndexMarker790"/>other features that you can exploit starting from <a href="https://github.com/jnr"><span class="url">https://github.com/jnr</span></a>. You may also be interested in JavaCPP, which is another alternative to JNI (<a href="https://github.com/bytedeco/javacpp"><span class="url">https://github.com/bytedeco/javacpp</span></a>).</p>
    <h1 id="_idParaDest-327" class="heading-1">147. Motivating and introducing Project Panama</h1>
    <p class="normal">Project Panama, or <a id="_idIndexMarker791"/>the Foreign Function &amp; Memory (FFM) API, is an elegant way of saying goodbye to JNI. This project started in JDK 17 as JEP 412 (first incubator). It continued in JDK 18 as JEP 419 (second incubator), JDK 19 as JEP 424 (first preview), JDK 20 as JEP 434 (second preview), and JDK 21 as JEP 442 (third preview). This is where things are at the time of writing. </p>
    <p class="normal">To understand the goals of this project, we have to talk about accessing <strong class="keyWord">off-heap</strong> memory<a id="_idIndexMarker792"/> from Java applications. By off-heap memory, we mean the memory that is outside the JVM heap and is not managed by the garbage collector.</p>
    <p class="normal">Surfing off-heap is the job of JNI, JNA, and JNR. In one way or another, these APIs can work in off-heap land to handle different tasks. Among these tasks, we can enumerate the following:</p>
    <ul>
      <li class="bulletList">Use native libraries (for instance, some common libraries are Open CL/GL, CUDA, TensorFlow, Vulkan, OpenSSL, V8, BLAS, cuDNN, and so on)</li>
      <li class="bulletList">Share memory across different processes</li>
      <li class="bulletList">Serialize/deserialize memory content to the so-called <em class="italic">mmaps</em></li>
    </ul>
    <p class="normal">The Java <em class="italic">de facto</em> API for accomplishing <a id="_idIndexMarker793"/>these kinds of tasks is <code class="inlineCode">ByteBuffer</code>, or better, the so-called <em class="italic">allocated direct buffers</em>, which are more efficient in accessing off-heap <a id="_idIndexMarker794"/>memory. Alternatively, we can use JNI, or as you saw, third-party libraries such as JNA and JNR.</p>
    <p class="normal">However, <code class="inlineCode">ByteBuffer</code> and JNI have a lot of shortcomings that make them useful only in a limited number of scenarios. A few of their drawbacks are listed below:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ByteBuffer</code>:<ul>
          <li class="bulletList">Brittle <a id="_idIndexMarker795"/>and error-prone </li>
          <li class="bulletList">Unstable memory addresses</li>
          <li class="bulletList">Backed by an array that can be manipulated by the garbage collector</li>
          <li class="bulletList">Allocated direct buffers</li>
          <li class="bulletList">Cannot scale when used as a general off-heap API</li>
          <li class="bulletList">Works well only if used by power users who deeply understand its use</li>
          <li class="bulletList">No solution for deallocation/free memory</li>
        </ul>
      </li>
      <li class="bulletList">JNI:<ul>
          <li class="bulletList">As you <a id="_idIndexMarker796"/>saw in <em class="italic">Problem 144</em>, JNI is hard to use (even for simple cases)</li>
          <li class="bulletList">It is brittle and error-prone</li>
          <li class="bulletList">It is difficult/expensive to maintain</li>
          <li class="bulletList">There is poor error checking</li>
          <li class="bulletList">It can crash the JVM</li>
        </ul>
      </li>
    </ul>
    <p class="normal">These shortcomings and much more are behind the reason for the creation of Project Panama. The goal of this project is to become the new <em class="italic">de facto</em> API for interoperating with foreign data, functions, and memory in Java. To accomplish this goal, Project Panama <a id="_idIndexMarker797"/>has two main features:</p>
    <ul>
      <li class="bulletList">A future-proof API (low-level, efficient, robust, and safe) to replace the old-school API based <a id="_idIndexMarker798"/>on byte buffers – this is referred to as the memory access API and is capable of accessing on-heap and off-heap memory.</li>
      <li class="bulletList">A brand-new paradigm replaces the JNI concepts and mechanisms, so now we have an intuitive, easy-to-use, and robust solution for creating Java bindings for native libraries. This is <a id="_idIndexMarker799"/>referred to as the<a id="_idIndexMarker800"/> Foreign Linker API.</li>
    </ul>
    <p class="normal">In the next problems, we will dive deeper into this project.</p>
    <h1 id="_idParaDest-328" class="heading-1">148. Introducing Panama’s architecture and terminology</h1>
    <p class="normal">When we talk about<a id="_idIndexMarker801"/> architecture, it helps to present a meaningful diagram, so here it is:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_08.png" alt="Figure 7.8.png"/></figure>
    <p class="packt_figref">Figure 7.8: Project Panama architecture</p>
    <p class="normal">This diagram reveals<a id="_idIndexMarker802"/> the interoperability of Panama’s components. The climax of this diagram is the<a id="_idIndexMarker803"/> Jextract tool. As you’ll see in this chapter, Jextract is a very handy tool capable of consuming the headers of native libraries and producing low-level Java native bindings. These bindings are the unit of work for two major APIs of Project Panama:</p>
    <ul>
      <li class="bulletList">Foreign Memory API – used to <a id="_idIndexMarker804"/>allocate/deallocate off-heap/on-heap memory</li>
      <li class="bulletList">Foreign Linker API – used to<a id="_idIndexMarker805"/> call foreign functions directly from Java and vice versa</li>
    </ul>
    <p class="normal">The process described so far is entirely mechanical. When these APIs and the low-level Java native bindings are not enough for our tasks, then we can take things a step further and create a set of higher-level Java bindings. Of course, this is not a task for novices, but it is very powerful. For instance, you may have an existing automation tool for generating JNI bindings and now you want to modernize your tool to generate a higher level of pure Java bindings in Panama’s style.</p>
    <p class="normal">Among the abstractions used by Project Panama, we have the following:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">java.lang.foreign.MemorySegment</code>: This API shapes a heap or native memory segment. A <a id="_idIndexMarker806"/>heap segment accesses on-heap memory, while a native segment accesses off-heap memory. In both cases, we’re talking about a contiguous region of memory that has a lifespan bounded by space and time.</li>
      <li class="bulletList"><code class="inlineCode">java.lang.foreign.Arena</code> (or <code class="inlineCode">MemorySession</code> in JDK versions earlier than 20): This API can control the memory segment’s lifespan.</li>
      <li class="bulletList"><code class="inlineCode">java.lang.foreign.MemorySegment.Scope</code>: This API represents the scope of a memory segment.</li>
      <li class="bulletList"><code class="inlineCode">java.lang.foreign.MemoryLayout</code>: This API describes the content of memory segments as <em class="italic">memory layouts</em>. For instance, among the available memory layouts, in the context of basic Java data types (<code class="inlineCode">int</code>, <code class="inlineCode">double</code>, <code class="inlineCode">long</code>, and so on), we have <em class="italic">memory value layouts</em> (<code class="inlineCode">java.lang.foreign.ValueLayout</code>). </li>
    </ul>
    <p class="normal">Of course, next to these three pillars, we have many other classes and helpers. In the next problems, we will cover several scenarios meant to get us familiar with the major aspects of using Project Panama’s APIs.</p>
    <h1 id="_idParaDest-329" class="heading-1">149. Introducing Arena and MemorySegment</h1>
    <p class="normal">A <code class="inlineCode">MemorySegment</code> shapes <a id="_idIndexMarker807"/>a heap or native memory segment. A heap segment accesses on-heap memory, while a native segment accesses off-heap memory. In both cases, we talk about a contiguous region of memory that has a lifespan bounded by space and time.</p>
    <p class="normal">Among its characteristics, a memory<a id="_idIndexMarker808"/> segment has a <em class="italic">size</em> in bytes, an <em class="italic">alignment</em> of bytes, and a <em class="italic">scope</em>. The scope is shaped via the <code class="inlineCode">java.lang.foreign.MemorySegment.Scope</code> sealed interface and represents the lifespan of the memory segment. A native memory segment lifespan is controlled by a <code class="inlineCode">java.lang.foreign.Arena</code> instance. An <code class="inlineCode">Arena</code> has a scope that can be:</p>
    <p class="normal">The <em class="italic">arena global scope </em>(or <em class="italic">global arena</em>): The memory segments with the arena global scope are always accessible. In other words, the regions of memory allocated to these segments are never deallocated and their global scope remains alive forever. </p>
    <p class="normal">Attempting to close (<code class="inlineCode">close()</code>) this scope will result in <code class="inlineCode">UnsupportedOperationException</code>. Here is an example of creating a native memory segment of 8 bytes in the arena global scope:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">globalSegment</span> = Arena.global().allocate(<span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">The <em class="italic">arena auto scope</em>: The <a id="_idIndexMarker809"/>memory segments with the arena automatic scope are managed by the garbage collector. In other words, the garbage collector determines when the regions of memory backing these segments can be safely deallocated. </p>
    <p class="normal">Attempting to close (<code class="inlineCode">close()</code>) this scope will result in an <code class="inlineCode">UnsupportedOperationException</code>. Here is an example of creating a native memory segment of 8 bytes in the auto scope:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">autoSegment</span> = Arena.ofAuto().allocate(<span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">The <em class="italic">arena confined scope </em>(or, <em class="italic">confined arena</em>): Strict control of the memory segment’s lifespan (allocation/deallocation and lifetime) can be obtained via a confined arena. Typically, this<a id="_idIndexMarker810"/> scope lives in a <code class="inlineCode">try-with-resources</code> block. When the <code class="inlineCode">Arena</code> is closed (by explicitly calling <code class="inlineCode">close()</code>, or by simply leaving the arena’s <code class="inlineCode">try-with-resources</code> block), its scope is closed, all memory segments associated with this scope are destroyed, and memory is deallocated automatically. A confined arena is opened via <code class="inlineCode">ofConfined()</code> and is owned by the current thread – the memory segments associated with the scope of a confined arena can only be accessed by the thread that created the arena.</p>
    <p class="normal">In code lines, a confined arena can be created as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
<span class="hljs-comment">  // current thread work with memory segments (MS1, MS2, …)</span>
}
<span class="hljs-comment">// here, memory segments MS1, MS2, …, have been deallocated</span>
</code></pre>
    <p class="normal">The <em class="italic">arena shared scope</em> (or, <em class="italic">shared arena</em>): A shared arena is typically opened in a <code class="inlineCode">try-with-resources</code> block<a id="_idIndexMarker811"/> via <code class="inlineCode">ofShared()</code> and can be shared by multiple threads – the memory segments associated with the scope of the shared arena can be accessed by any thread (for instance, this can be useful for performing parallel computations on memory segments). When the <code class="inlineCode">Arena</code> is closed (by explicitly calling <code class="inlineCode">close()</code>, or by simply leaving the arena’s <code class="inlineCode">try-with-resources</code> block), its scope is closed, all memory segments associated with this scope are destroyed, and memory is deallocated automatically.</p>
    <p class="normal">In code lines, a<a id="_idIndexMarker812"/> confined arena can be created as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofShared()) {
<span class="hljs-comment">  // any thread work with memory segments (MS1, MS2, …)</span>
}
<span class="hljs-comment">// here, memory segments MS1, MS2, …, have been deallocated</span>
</code></pre>
    <p class="normal">By calling <code class="inlineCode">arena.scope()</code>, we<a id="_idIndexMarker813"/> obtain the <code class="inlineCode">MemorySegment.Scope</code> of the arena, and by calling <code class="inlineCode">arena.scope().isAlive()</code>, we can find out if the current scope is alive or not. A memory segment is accessible only if its scope is alive, so as long as the arena’s scope is alive. </p>
    <p class="normal">Here, we have a memory segment of 8 bytes in the arena scope:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-variable">MemorySegment</span> <span class="hljs-variable">arenaSegment</span> = arena.allocate(<span class="hljs-number">8</span>);
}
</code></pre>
    <p class="normal">Summarizing the main characteristics of arena scopes in a table can be done as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_09.png" alt="Figure a0.png"/></figure>
    <p class="packt_figref">Figure 7.9: Summarizing the main characteristics of arena scopes</p>
    <p class="normal">If you want to monitor the allocated native memory, then this article will help you to do so: <a href="https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/"><span class="url">https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/</span></a>. Before going further, let’s briefly introduce <em class="italic">memory layouts</em>.</p>
    <h2 id="_idParaDest-330" class="heading-2">Introducing memory layouts (ValueLayout)</h2>
    <p class="normal"><em class="italic">Memory layouts</em> are <a id="_idIndexMarker814"/>shaped by the <code class="inlineCode">java.lang.foreign.MemoryLayout</code> interface and their goal is to describe the content of memory segments. </p>
    <p class="normal">We have <em class="italic">simple memory layouts</em>, including <code class="inlineCode">ValueLayout</code> and <code class="inlineCode">PaddingLayout</code>, but we also have <em class="italic">complex memory layouts</em> for describing complex memory segments such as <code class="inlineCode">SequenceLayout</code>, <code class="inlineCode">StructLayout</code>, <code class="inlineCode">UnionLayout</code>, and <code class="inlineCode">GroupLayout</code>. The complex layouts are useful to model hierarchical user-defined data types such as C-like sequences, structures, unions, and so on. </p>
    <h3 id="_idParaDest-331" class="heading-3">Allocating memory segments of value layouts</h3>
    <p class="normal">For now, we are<a id="_idIndexMarker815"/> interested in <code class="inlineCode">ValueLayout</code>. This is a<a id="_idIndexMarker816"/> simple memory layout that is useful to represent basic Java data types such as <code class="inlineCode">int</code>, <code class="inlineCode">float</code>, <code class="inlineCode">double</code>, <code class="inlineCode">char</code>, <code class="inlineCode">byte</code>, and so on. In an API-specific example, a <code class="inlineCode">ValueLayout.JAVA_LONG</code> is a layout whose <em class="italic">carrier</em> is <code class="inlineCode">long.class</code>, a <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code> is a layout whose <em class="italic">carrier</em> is <code class="inlineCode">double.class</code>, and so on. The <em class="italic">carrier</em> of a value layout can be obtained via the <code class="inlineCode">carrier()</code> method.</p>
    <p class="normal">For instance, let’s assume that we have a confined <code class="inlineCode">arena</code> and need a memory segment for storing a single <code class="inlineCode">int</code> value. We know that a Java <code class="inlineCode">int</code> needs 4 bytes, so our segment can be allocated as follows (the first argument of <code class="inlineCode">allocate()</code> is the <code class="inlineCode">int</code> <em class="italic">byte size</em>, and the second argument is the <code class="inlineCode">int</code> <em class="italic">byte alignment</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);
</code></pre>
    <p class="normal">But we can achieve the same thing via <code class="inlineCode">ValueLayout</code> as follows (here, we use <code class="inlineCode">allocate(MemoryLayout layout)</code> and <code class="inlineCode">allocate(long byteSize, long byteAlignment)</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(ValueLayout.JAVA_INT);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena
  .allocate(ValueLayout.JAVA_INT.byteSize(),
            ValueLayout.JAVA_INT.byteAlignment());
</code></pre>
    <p class="normal">Or, without specifying the <em class="italic">byte alignment</em>, via <code class="inlineCode">allocate(long byteSize)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-number">4</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena
  .allocate(ValueLayout.JAVA_INT.byteSize());
</code></pre>
    <p class="normal">Here is another example of allocating a memory segment for storing a Java <code class="inlineCode">double</code> using the <em class="italic">byte alignment</em> specific to <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span>
  <span class="hljs-operator">=</span> arena.allocate(ValueLayout.JAVA_DOUBLE);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(
  ValueLayout.JAVA_DOUBLE.byteSize(),
  ValueLayout.JAVA_DOUBLE.byteAlignment());
</code></pre>
    <p class="normal">Or, allocating a<a id="_idIndexMarker817"/> memory segment for storing a <a id="_idIndexMarker818"/>Java <code class="inlineCode">char</code> can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(ValueLayout.JAVA_CHAR);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> MemorySegment.allocate(
  ValueLayout.JAVA_CHAR.byteSize(),
  ValueLayout.JAVA_CHAR.byteAlignment());
</code></pre>
    <p class="normal">Now that we know how to allocate a memory segment to different data types, let’s see how we can set/get some values.</p>
    <h3 id="_idParaDest-332" class="heading-3">Setting/getting the content of a memory segment</h3>
    <p class="normal">The <code class="inlineCode">Arena</code> API <a id="_idIndexMarker819"/>provides a set of <code class="inlineCode">allocate()</code> methods inherited from <code class="inlineCode">SegmentAllocator</code> that can be used to allocate a memory segment and set its content in the same line of code (in the previous section, we used only the <code class="inlineCode">allocate()</code> flavors that allocate memory segments but don’t set their content). For instance, calling <code class="inlineCode">allocate(OfInt layout, int value)</code> allocates a memory segment for storing an <code class="inlineCode">int</code> and sets that <code class="inlineCode">int</code> to the given <code class="inlineCode">value</code> (<code class="inlineCode">OfInt</code> is an interface that extends <code class="inlineCode">ValueLayout</code>). Here, we consider the <code class="inlineCode">int</code> as being <code class="inlineCode">Integer.MAX_VALUE</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(
  ValueLayout.JAVA_INT, Integer.MAX_VALUE);
</code></pre>
    <p class="normal">Or, here we allocate a memory segment for a <code class="inlineCode">char</code> and set that <code class="inlineCode">char</code> to <code class="inlineCode">a</code> (<code class="inlineCode">allocate(OfChar layout, char value)</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(
  ValueLayout.JAVA_CHAR, <span class="hljs-string">'a'</span>);
</code></pre>
    <p class="normal">But if we want to set the content of a memory segment later (not at the same time as the allocation), then we can use the <code class="inlineCode">MemorySegment.set()</code> or <code class="inlineCode">setAtIndex()</code> method.</p>
    <p class="normal">For instance, we can set the <code class="inlineCode">Integer.MAX_VALUE</code> via <code class="inlineCode">set(OfInt layout, long offset, int value)</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> ...;
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, Integer.MAX_VALUE);
</code></pre>
    <p class="normal">The second argument is the <code class="inlineCode">offset</code> (0, 4, 8, 12, …), which in this case must be 0. Alternatively, we can use <code class="inlineCode">setAtIndex(OfInt layout, long index, int value)</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.setAtIndex(
  ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, Integer.MAX_VALUE);
</code></pre>
    <p class="normal">Here, the second argument represents an index exactly as in an array (0, 1, 2, 3…). In this case, it must be 0 since we have a single integer stored in the memory segment.</p>
    <p class="normal">Getting content from a certain offset can be done via <code class="inlineCode">get()</code> and from a certain index via <code class="inlineCode">getAtIndex()</code> methods. For instance, getting the <code class="inlineCode">int</code> stored at a certain offset can be done via <code class="inlineCode">get(OfInt layout, long offset)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">val</span> = segment.get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">And, the <code class="inlineCode">int</code> stored <a id="_idIndexMarker820"/>at a certain index via <code class="inlineCode">getAtIndex(OfInt layout, long index)</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> segment.getAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">In the next problems, you’ll see more examples of using these methods.</p>
    <h3 id="_idParaDest-333" class="heading-3">Working with Java strings</h3>
    <p class="normal">Allocating a memory<a id="_idIndexMarker821"/> segment for storing a Java <code class="inlineCode">String</code> is a special case. If we have an <code class="inlineCode">Arena</code> instance, then we can allocate a memory segment and set its content as a Java <code class="inlineCode">String</code> via <code class="inlineCode">allocateUtf8String(String str)</code> as follows (here, the Java string is <code class="inlineCode">abcd</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocateUtf8String(<span class="hljs-string">"abcd"</span>);
</code></pre>
    <p class="normal">The <code class="inlineCode">allocateUtf8String(String str)</code> converts a Java <code class="inlineCode">String</code> into a C-like string that is UTF-8-encoded and <code class="inlineCode">null</code>-terminated. The size of the memory segment is obtained as <code class="inlineCode">str.length</code> + 1.This means that we can allocate a segment for the <code class="inlineCode">abcd</code> string as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-number">5</span>);
</code></pre>
    <p class="normal">Or, more expressive:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-string">"abcd"</span>.length() + <span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">Having the allocated memory segment, we can set the string via <code class="inlineCode">setUtf8String(long offset, String str)</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.setUtf8String(<span class="hljs-number">0</span>, <span class="hljs-string">"abcd"</span>);
</code></pre>
    <p class="normal">Offset 0 means exactly at the start of the memory segment. Since this memory segment has the size computed to fit exactly the string <code class="inlineCode">abcd</code>, we cannot have an offset other than 0. For instance, the following snippet results in an <code class="inlineCode">IndexOutOfBoundsException</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.setUtf8String(<span class="hljs-number">1</span>, <span class="hljs-string">"abcd"</span>);
</code></pre>
    <p class="normal">Getting the string stored in a memory segment can be done via <code class="inlineCode">MemorySegment.getUtf8String(long offset)</code>, so we can do it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> segment.getUtf8String(<span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">You can <a id="_idIndexMarker822"/>practice all these examples in the bundled code.</p>
    <h1 id="_idParaDest-334" class="heading-1">150. Allocating arrays into memory segments</h1>
    <p class="normal">Now that we know <a id="_idIndexMarker823"/>how to create memory segments for <a id="_idIndexMarker824"/>storing single values, let’s take it a step further and try to store an array of integers. For instance, let’s define a memory segment for storing the following array: [11, 21, 12, 7, 33, 1, 3, 6].</p>
    <p class="normal">A Java <code class="inlineCode">int</code> needs 4 bytes (32 bits) and we have 8 integers, so we need a memory segment of 4 bytes x 8 = 32 bytes = 256 bits. If we try to represent this memory segment, then we can do it as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_10.png" alt="Figure 7.9.png"/></figure>
    <p class="packt_figref">Figure 7.10: A memory segment of 8 integers</p>
    <p class="normal">In code lines, we can allocate this memory segment via any of the following approaches (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-number">32</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-number">4</span> * <span class="hljs-number">8</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(
  ValueLayout.JAVA_INT.byteSize() * <span class="hljs-number">8</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(Integer.SIZE/<span class="hljs-number">8</span> * <span class="hljs-number">8</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(Integer.BYTES * <span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">Next, we can use the <code class="inlineCode">set(OfInt layout, long offset, int value)</code> method to populate the memory segment as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">4</span>, <span class="hljs-number">21</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">16</span>, <span class="hljs-number">33</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">24</span>, <span class="hljs-number">3</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">28</span>, <span class="hljs-number">6</span>);
</code></pre>
    <p class="normal">Or, we can use the <code class="inlineCode">setAtIndex(OfInt layout, long index, int value)</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">4</span>, <span class="hljs-number">33</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>);
</code></pre>
    <p class="normal">We already know that we can access any of these integers via <code class="inlineCode">get()</code> using the offset or via <code class="inlineCode">getAtIndex()</code> using the index. This time, let’s try to use this memory segment to populate an <code class="inlineCode">IntVector</code> (introduced in <em class="italic">Chapter 5</em>). The code should look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.fromMemorySegment(
  VS256, segment, <span class="hljs-number">0</span>, ByteOrder.nativeOrder());
</code></pre>
    <p class="normal">So, the Vector API<a id="_idIndexMarker825"/> exposes the <code class="inlineCode">fromMemorySegment()</code> method, especially<a id="_idIndexMarker826"/> to populate a vector from a memory segment. The <code class="inlineCode">ByteOrder</code> can be <code class="inlineCode">nativeOrder()</code>, which means the platform’s native order of bytes, <code class="inlineCode">BIG_ENDIAN</code> (big-endian byte order), or <code class="inlineCode">LITTLE_ORDER</code> (little-endian byte order).</p>
    <p class="normal">A more convenient approach for populating the memory segment relies on a suite of <code class="inlineCode">Arena.allocateArray()</code> methods inherited from <code class="inlineCode">SegmentAllocator</code>. These methods create and populate the memory segment in a single line of code, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocateArray(
  ValueLayout.JAVA_INT, <span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>, <span class="hljs-number">33</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>);
<span class="hljs-comment">// or, like this</span>
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocateArray(
  ValueLayout.JAVA_INT, 
  <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>,  <span class="hljs-number">33</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>});
</code></pre>
    <p class="normal">Or, here it is a <code class="inlineCode">char[]</code> array:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocateArray(
  ValueLayout.JAVA_CHAR,<span class="hljs-string">"abcd"</span>.toCharArray());
</code></pre>
    <p class="normal">All these examples allocate an off-heap memory segment. If we need an on-heap memory segment, then<a id="_idIndexMarker827"/> we can rely on <code class="inlineCode">MemorySegment.ofArray()</code>, as<a id="_idIndexMarker828"/> follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> MemorySegment
  .ofArray(<span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>, <span class="hljs-number">33</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>});
</code></pre>
    <p class="normal">For complete examples, please consider the bundled code.</p>
    <h1 id="_idParaDest-335" class="heading-1">151. Understanding addresses (pointers)</h1>
    <p class="normal">A memory segment has a memory address<a id="_idIndexMarker829"/> (<em class="italic">pointer</em>) expressed as a <code class="inlineCode">long</code> number. An off-heap memory segment has a <em class="italic">physical address</em> that points out the memory region that backs the <a id="_idIndexMarker830"/>segment (<em class="italic">base address</em>). Each memory layout stored in this segment has its own memory address as well. For instance, here is an example of querying the <em class="italic">base address</em> of a memory segment via the <code class="inlineCode">address()</code> method (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena
  .allocate(ValueLayout.JAVA_INT, <span class="hljs-number">1000</span>);
<span class="hljs-type">long</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> segment.address(); <span class="hljs-comment">// 2620870760384</span>
</code></pre>
    <p class="normal">On the other hand, an on-heap memory segment has a <em class="italic">non-physical stable virtualized</em> address typically representing an offset within the memory region of that segment (the client sees a stable address while the garbage collector can reallocate the region of memory inside the heap). For instance, an on-heap segment created via one of the <code class="inlineCode">ofArray()</code> factory methods has an address of 0.</p>
    <p class="normal">Next, let’s focus only on off-heap memory segments. Let’s consider the following three memory segments containing integer values (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> arena.allocate(ValueLayout.JAVA_INT, <span class="hljs-number">1</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> arena.allocate(ValueLayout.JAVA_INT, <span class="hljs-number">3</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> arena.allocate(ValueLayout.JAVA_INT, <span class="hljs-number">2</span>);
</code></pre>
    <p class="normal">Each of these segments has a <a id="_idIndexMarker831"/>memory address. Next, let’s create a segment containing their addresses (like a segment of pointers). First, we allocate such a segment via <code class="inlineCode">ValueLayout.ADDRESS</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">addrs</span> = arena
  .allocateArray(ValueLayout.ADDRESS, <span class="hljs-number">3</span>);
</code></pre>
    <p class="normal">Since each address is a <code class="inlineCode">long</code> value, the size of <code class="inlineCode">addrs</code> is 24 bytes. We can use the <code class="inlineCode">set()</code> method and the offsets 0, 8, and 16 to set the addresses of <code class="inlineCode">i1</code>, <code class="inlineCode">i2</code>, and <code class="inlineCode">i3</code>, or we can use the <code class="inlineCode">setAtIndex()</code> and refer to offsets as indexes 0, 1, and 2:</p>
    <pre class="programlisting code"><code class="hljs-code">addrs.setAtIndex(ValueLayout.ADDRESS, <span class="hljs-number">0</span>, i1);
addrs.setAtIndex(ValueLayout.ADDRESS, <span class="hljs-number">1</span>, i2);
addrs.setAtIndex(ValueLayout.ADDRESS, <span class="hljs-number">2</span>, i3);
</code></pre>
    <p class="normal">We can represent this in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_11.png" alt="Figure 7.11.png"/></figure>
    <p class="packt_figref">Figure 7.11: Storing i1, i2, and i3 addresses in an array of addresses</p>
    <p class="normal">In other words, we set <a id="_idIndexMarker832"/>the address of <code class="inlineCode">i1</code> at offset 0 in <code class="inlineCode">addrs</code>, the address of <code class="inlineCode">i2</code> at offset 8, and the address of <code class="inlineCode">i3</code> at offset 16. The <code class="inlineCode">addrs</code> segment doesn’t hold the data of <code class="inlineCode">i1</code>, <code class="inlineCode">i2</code>, and <code class="inlineCode">i3</code>. It is just a segment of pointers that points to the memory addresses of <code class="inlineCode">i1</code>, <code class="inlineCode">i2</code>, and <code class="inlineCode">i3</code>.</p>
    <p class="normal">If we call <code class="inlineCode">get()</code>/<code class="inlineCode">getAtIndex()</code>, we will get an address:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">addr1</span> <span class="hljs-operator">=</span> addrs.getAtIndex(ValueLayout.ADDRESS, <span class="hljs-number">0</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">addr2</span> <span class="hljs-operator">=</span> addrs.getAtIndex(ValueLayout.ADDRESS, <span class="hljs-number">1</span>);
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">addr3</span> <span class="hljs-operator">=</span> addrs.getAtIndex(ValueLayout.ADDRESS, <span class="hljs-number">2</span>);
</code></pre>
    <p class="normal">We can represent this in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_12.png" alt="Figure 7.11 - Copy.png"/></figure>
    <p class="packt_figref">Figure 7.12: Getting addresses from the array of addresses</p>
    <p class="normal">But check out the return type. It is not a <code class="inlineCode">long</code> value! It is a <code class="inlineCode">MemorySegment</code>. The returned native memory segments (<code class="inlineCode">addr1</code>, <code class="inlineCode">addr2</code>, and <code class="inlineCode">addr3</code>) are automatically associated with the <em class="italic">global scope</em>. They have the size 0 (<em class="italic">limit: 0</em>) and each of them wraps the returned address of the given offset/index (the <code class="inlineCode">long</code> value is available via <code class="inlineCode">addr1</code>/<code class="inlineCode">2</code>/<code class="inlineCode">3.address()</code>). However, in the case of an <em class="italic">unbounded</em> address layout, the size is expected to be <code class="inlineCode">Long.MAX_VALUE</code> (9223372036854775807). </p>
    <p class="normal">This means that we shouldn’t do this:</p>
    <pre class="programlisting code"><code class="hljs-code">addr1.get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>); DON'T DO THIS!
</code></pre>
    <p class="normal">This causes <a id="_idIndexMarker833"/>an <code class="inlineCode">IndexOutOfBoundsException</code> since <code class="inlineCode">addr1</code> has a size of 0 bytes – this is known <a id="_idIndexMarker834"/>as a <em class="italic">zero-length memory segment</em>. Getting the integer value associated with an address can be done via the <code class="inlineCode">ofAddress()</code> and a flavor of the <code class="inlineCode">reinterpret()</code> methods, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> MemorySegment.ofAddress(addr1.address())
  .reinterpret(ValueLayout.JAVA_INT.byteSize())
  .get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">First, we call <code class="inlineCode">ofAddress()</code> and pass the <code class="inlineCode">addr1</code> address. This will create a native memory segment with the size 0. Next, we call the <code class="inlineCode">reinterpret()</code> method and pass the size of the <code class="inlineCode">int</code> type. This will return a new memory segment (a reinterpreted memory segment) with the same address and scope as this segment, but with the given size (4 bytes). Finally, we read the integer value stored at this address at offset 0. The same thing can be done for <code class="inlineCode">addr2</code> and <code class="inlineCode">addr3</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> MemorySegment.ofAddress(addr2.address())
  .reinterpret(ValueLayout.JAVA_INT.byteSize())
  .get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>);
<span class="hljs-type">int</span> <span class="hljs-variable">v3</span> <span class="hljs-operator">=</span> MemorySegment.ofAddress(addr3.address())
  .reinterpret(ValueLayout.JAVA_INT.byteSize())
  .get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">Before using <a id="_idIndexMarker835"/>the <code class="inlineCode">reinterpret()</code> or <code class="inlineCode">withTargetLayout()</code> methods, please consider the following note:</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The <code class="inlineCode">reinterpret()</code> method (and all other methods for working with zero-length memory segments) is considered a <em class="italic">restricted</em> method. It should be used with caution since any mistake can lead to a VM crash when trying to access the memory segment.</p>
    </div>
    <p class="normal">We can check whether two long addresses are equal via the <code class="inlineCode">==</code> operator:</p>
    <pre class="programlisting code"><code class="hljs-code">addr1.address() == i1.address() <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal">Or, via <code class="inlineCode">equals()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">addr1.equals(i1) <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal">At this point, we have that <code class="inlineCode">i1</code>=1, <code class="inlineCode">i2</code>=3, and <code class="inlineCode">i3</code>=2. Let’s manipulate only the addresses to obtain <code class="inlineCode">i1</code>=1, <code class="inlineCode">i2</code>=2, and <code class="inlineCode">i3</code>=3. So, we want to switch the integer values of <code class="inlineCode">i2</code> and <code class="inlineCode">i3</code> by switching the addresses, not the values. First, we store the <code class="inlineCode">i2</code> address as a <code class="inlineCode">long</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">i2Addr</span> <span class="hljs-operator">=</span> i2.address();
</code></pre>
    <p class="normal">Next, we set the <code class="inlineCode">i2</code> address as the <code class="inlineCode">i3</code> address:</p>
    <pre class="programlisting code"><code class="hljs-code">i2 = MemorySegment.ofAddress(i3.address())
  .reinterpret(ValueLayout.JAVA_INT.byteSize());
</code></pre>
    <p class="normal">Finally, we set the address of <code class="inlineCode">i3</code> as the address of <code class="inlineCode">i2</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">i3 = MemorySegment.ofAddress(i2Addr)
  .reinterpret(ValueLayout.JAVA_INT.byteSize());
</code></pre>
    <p class="normal">Done! Now, <code class="inlineCode">i1</code>=1, <code class="inlineCode">i2</code>=2, and <code class="inlineCode">i3</code>=3. I hope you found this exercise useful for understanding how to<a id="_idIndexMarker836"/> manipulate values, offsets, and memory addresses.</p>
    <h1 id="_idParaDest-336" class="heading-1">152. Introducing the sequence layout</h1>
    <p class="normal">In <em class="italic">Problem 149</em>, we already<a id="_idIndexMarker837"/> covered the <code class="inlineCode">ValueLayout</code> for basic data types. Next, let’s talk about the <em class="italic">sequence layout</em> (<code class="inlineCode">java.lang.foreign.SequenceLayout</code>). </p>
    <p class="normal">But before introducing the sequence layout, let’s take a moment to analyze the following snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(
    ValueLayout.JAVA_DOUBLE.byteSize() * <span class="hljs-number">10</span>,
    ValueLayout.JAVA_DOUBLE.byteAlignment());
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    segment.setAtIndex(ValueLayout.JAVA_DOUBLE,
      i, Math.random());
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    System.out.printf(<span class="hljs-string">"</span><span class="hljs-string">\nx = %.2f"</span>,
      segment.getAtIndex(ValueLayout.JAVA_DOUBLE, i));
  }
}
</code></pre>
    <p class="normal">We start by creating a native memory segment for storing 10 <code class="inlineCode">double</code> values. Next, we rely on <code class="inlineCode">setAtIndex()</code> to set these <code class="inlineCode">double</code> values. Finally, we print them.</p>
    <p class="normal">So, basically, we repeat the <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code> 10 times. When an <em class="italic">element layout</em> is repeated <em class="italic">n</em> times (a finite number of times), we can express the code via a sequence layout (<code class="inlineCode">java.lang.foreign.SequenceLayout</code>). In other words, a sequence layout represents a repetition/sequence of a given <em class="italic">element layout</em> for a finite number of times.</p>
    <p class="normal">The following code uses <code class="inlineCode">SequenceLayout</code> to shape the previous snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-variable">seq</span> = MemoryLayout.sequenceLayout(
  <span class="hljs-number">10</span>, ValueLayout.JAVA_DOUBLE);
</code></pre>
    <p class="normal">The number of repetitions (<em class="italic">element count</em>) is 10, and the repeated <em class="italic">element layout</em> is <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code>.</p>
    <p class="normal">But how do we set<a id="_idIndexMarker838"/> the values of a sequence layout? There are at least two approaches, and one of them relies on a combination of the <code class="inlineCode">java.lang.invoke.VarHandle</code> API and the <code class="inlineCode">java.lang.foreign.MemoryLayout.PathElement</code> API.</p>
    <h2 id="_idParaDest-337" class="heading-2">Introducing PathElement</h2>
    <p class="normal">In a nutshell, the <code class="inlineCode">PathElement</code> API<a id="_idIndexMarker839"/> exposes a friendly approach for navigating a hierarchal memory layout via the so-called <em class="italic">layout path</em>. By chaining path elements in a layout path, we can locate<a id="_idIndexMarker840"/> an element layout, which can be a sequence layout (located via sequence path elements) or, as you’ll see in other problems, a group layout (which can be a struct layout or a union layout located via group path elements). Sequence layouts are traversed via <code class="inlineCode">PathElement.sequenceElement()</code>, while group layouts via <code class="inlineCode">PathElement.groupElement()</code>. Each element layout has a number of elements referred to as the <em class="italic">element count</em> (obtained via a method named <code class="inlineCode">elementCount()</code>).</p>
    <h2 id="_idParaDest-338" class="heading-2">Introducing VarHandle</h2>
    <p class="normal"><code class="inlineCode">VarHandle</code> is not <a id="_idIndexMarker841"/>new to town. It was introduced in JDK 9. A <code class="inlineCode">VarHandle</code> is a dynamic, immutable, non-visible-state, strongly typed reference to a variable that cannot be subclassed. Its <a id="_idIndexMarker842"/>goal is to provide read/write access to the handled variables under certain circumstances.</p>
    <p class="normal">A <code class="inlineCode">VarHandle</code> is characterized by two aspects:</p>
    <ul>
      <li class="bulletList">The type of variables represented by this <code class="inlineCode">VarHandle</code> as a generic type (<code class="inlineCode">T</code>)</li>
      <li class="bulletList">A list of Coordinate Types (denoted CT) used to locate variables referenced by this <code class="inlineCode">VarHandle</code></li>
    </ul>
    <p class="normal">The CT list may be empty.</p>
    <p class="normal">Typically, a <code class="inlineCode">VarHandle</code> method gets a variable number of <code class="inlineCode">Object</code> arguments. Argument(s) checking is accomplished at runtime (static argument(s) checking is disabled). Different<a id="_idIndexMarker843"/> methods of <code class="inlineCode">VarHandle</code> expect to have a variable number of arguments <a id="_idIndexMarker844"/>of different types.</p>
    <h2 id="_idParaDest-339" class="heading-2">Putting PathElement and VarHandle together</h2>
    <p class="normal">The <a id="_idIndexMarker845"/>path elements (layout path) are arguments of the <code class="inlineCode">MemoryLayout.varHandle()</code> method, which is capable of returning a <code class="inlineCode">VarHandle</code> that can be used to access a <a id="_idIndexMarker846"/>memory segment at the layout located via this layout path. The path is considered rooted in this layout.</p>
    <p class="normal">So, in our simple case, we can obtain a <code class="inlineCode">VarHandle</code> for <code class="inlineCode">seq</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// VarHandle[varType=double, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment, long]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-variable">sphandle</span> = seq.varHandle(
  PathElement.sequenceElement());
</code></pre>
    <p class="normal">Our path layout is just a simple navigation via <code class="inlineCode">PathElement.sequenceElement()</code>. The returned <code class="inlineCode">VarHandle</code> represents variables of the type <code class="inlineCode">double</code> and contains a CT of (<code class="inlineCode">MemorySegment</code> and <code class="inlineCode">long</code>).</p>
    <p class="normal">The <code class="inlineCode">MemorySegment</code> represents the memory segment from this sequence layout and the <code class="inlineCode">long</code> value represents the index in this memory segment. This means that we can set 10 <code class="inlineCode">double</code> values, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(seq);
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; seq.elementCount(); i++) {
    sphandle.set(segment, i, Math.random());
  }
  ...
</code></pre>
    <p class="normal">Getting these 10 <code class="inlineCode">double</code> values can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; seq.elementCount(); i++) {
    System.out.printf(<span class="hljs-string">"\nx = %.2f"</span>, sphandle.get(segment, i));
  }
}
</code></pre>
    <p class="normal">A <code class="inlineCode">VarHandle</code> can <a id="_idIndexMarker847"/>be created via <code class="inlineCode">arrayElementVarHandle(int... shape)</code> as well. This method creates a <code class="inlineCode">VarHandle</code> for accessing a memory <a id="_idIndexMarker848"/>segment as a multi-dimensional array (this is known as a <em class="italic">strided var handler)</em>. The <code class="inlineCode">varargs</code> argument, <code class="inlineCode">shape</code>, represents the size of each nested array dimension. You can find this example in the bundle code.</p>
    <p class="normal">Next, let’s complicate things a little bit.</p>
    <h2 id="_idParaDest-340" class="heading-2">Working with nested sequence layouts</h2>
    <p class="normal">Let’s<a id="_idIndexMarker849"/> consider<a id="_idIndexMarker850"/> the following sequence layout of 400 bytes (5 * 10 * 8 bytes):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">nestedseq</span> = MemoryLayout.sequenceLayout(<span class="hljs-number">5</span>,
  MemoryLayout.sequenceLayout(<span class="hljs-number">10</span>, ValueLayout.JAVA_DOUBLE));
</code></pre>
    <p class="normal">So, here we have 5 sequence layouts of 10 <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code> each. Navigating to the <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code> requires a layout path obtained by chaining two calls of <code class="inlineCode">sequenceLayout()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// VarHandle[varType=double, coord=[interface </span>
<span class="hljs-comment">// java.lang.foreign.MemorySegment, long, long]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">nphandle</span> = nestedseq.varHandle(
  PathElement.sequenceElement(),
  PathElement.sequenceElement());
</code></pre>
    <p class="normal">Besides the memory segment, the <code class="inlineCode">VarHandle</code> accepts two <code class="inlineCode">long</code> values. The first <code class="inlineCode">long</code> corresponds to the outer sequence layout, and the second <code class="inlineCode">long</code> corresponds to the inner sequence layout. The number of elements (element count) for the outer sequence is 5, and it can be obtained as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> nestedseq.elementCount();
</code></pre>
    <p class="normal">The element count of the inner sequence is 10, and it can be obtained via the <code class="inlineCode">select()</code> method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> ((SequenceLayout) nestedseq.select(
  PathElement.sequenceElement())).elementCount();
</code></pre>
    <p class="normal">Now, <code class="inlineCode">outer</code> fits the first <code class="inlineCode">long</code> argument in the coordinate’s types of <code class="inlineCode">nphandle</code>, while <code class="inlineCode">inner</code> fits the second <code class="inlineCode">long</code> argument. So, we can get/set the <code class="inlineCode">double</code> values of our sequence as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(nestedseq);
  <span class="hljs-type">long</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> nestedseq.elementCount();
  <span class="hljs-type">long</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> ((SequenceLayout) nestedseq.select(
    PathElement.sequenceElement())).elementCount();
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; outer; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; inner; j++) {
      nphandle.set(segment, i, j, Math.random());
    }
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; outer; i++) {
    System.out.print(<span class="hljs-string">"\n-----"</span> + i + <span class="hljs-string">"-----"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; inner; j++) {
      System.out.printf(<span class="hljs-string">"\nx = %.2f"</span>,
        nphandle.get(segment, i, j));
    }
  }
}
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker851"/>bundled <a id="_idIndexMarker852"/>code, you can see an example relying on <code class="inlineCode">ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(5, 10)</code> as well.</p>
    <h1 id="_idParaDest-341" class="heading-1">153. Shaping C-like structs into memory segments</h1>
    <p class="normal">Let’s<a id="_idIndexMarker853"/> consider <a id="_idIndexMarker854"/>the C-like struct from the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_13.png" alt="Figure 7.16.png"/></figure>
    <p class="packt_figref">Figure 7.13: A C-like structure</p>
    <p class="normal">So, in <em class="italic">Figure 7.13</em>, we have a C-like struct named <code class="inlineCode">point</code> to shape an (<em class="italic">x</em>, <em class="italic">y</em>) pair of <code class="inlineCode">double</code> values. Moreover, we have 5 such pairs declared under the name <code class="inlineCode">pointarr</code>. We can try to shape a <a id="_idIndexMarker855"/>memory segment to fit this model as <a id="_idIndexMarker856"/>follows (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(
  <span class="hljs-number">2</span> * ValueLayout.JAVA_DOUBLE.byteSize() * <span class="hljs-number">5</span>,
  ValueLayout.JAVA_DOUBLE.byteAlignment());
</code></pre>
    <p class="normal">Next, we should set (<em class="italic">x</em>, <em class="italic">y</em>) pairs into this segment. For this, we can visualize it as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_14.png" alt="Figure 7.17.png"/></figure>
    <p class="packt_figref">Figure 7.14: Memory segment to store (x, y) pairs</p>
    <p class="normal">Based on this diagram, we can easily come up with the following snippet of code for setting the (<em class="italic">x</em>, <em class="italic">y</em>) pairs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
  segment.setAtIndex(
    ValueLayout.JAVA_DOUBLE, i * <span class="hljs-number">2</span>, Math.random());
  segment.setAtIndex(
    ValueLayout.JAVA_DOUBLE, i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, Math.random());
}
</code></pre>
    <p class="normal">But another<a id="_idIndexMarker857"/> approach consists of using the <code class="inlineCode">StructLayout</code>, which is<a id="_idIndexMarker858"/> more suitable for this scenario since it provides a wrapping structure around the data.</p>
    <h2 id="_idParaDest-342" class="heading-2">Introducing StructLayout</h2>
    <p class="normal">A <code class="inlineCode">StructLayout</code> is a <a id="_idIndexMarker859"/>group layout. In this layout, the members (other memory layouts) are laid out one after the other exactly as in a C struct. This means that we can shape our C-like struct by laying out two <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StructLayout</span> <span class="hljs-variable">struct</span> <span class="hljs-operator">=</span> MemoryLayout.structLayout(
  ValueLayout.JAVA_DOUBLE.withName(<span class="hljs-string">"x"</span>), 
  ValueLayout.JAVA_DOUBLE.withName(<span class="hljs-string">"y"</span>));
</code></pre>
    <p class="normal">But we have 5 pairs of (<em class="italic">x</em>, <em class="italic">y</em>), so we need to nest this <code class="inlineCode">StructLayout</code> in a <code class="inlineCode">SequenceLayout</code> containing 5 <code class="inlineCode">StructLayout</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">struct</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">5</span>,
      MemoryLayout.structLayout(
        ValueLayout.JAVA_DOUBLE.withName(<span class="hljs-string">"x"</span>),
        ValueLayout.JAVA_DOUBLE.withName(<span class="hljs-string">"y"</span>)));
</code></pre>
    <p class="normal">Next, as we already know from <em class="italic">Problem 152</em>, we need to define the proper layout paths via <code class="inlineCode">PathElement</code> and get back the <code class="inlineCode">VarHandle</code>. We need a <code class="inlineCode">VarHandle</code> for <em class="italic">x</em> and one for <em class="italic">y</em>. Notice in the following code how we point them out via their names:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// VarHandle[varType=double, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment, long]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">xHandle</span> = struct.varHandle(
  PathElement.sequenceElement(),
  PathElement.groupElement(<span class="hljs-string">"x"</span>));
<span class="hljs-comment">// VarHandle[varType=double, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment, long]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">yHandle</span> = struct.varHandle(
  PathElement.sequenceElement(),
  PathElement.groupElement(<span class="hljs-string">"y"</span>));
</code></pre>
    <p class="normal">Finally, we can use <code class="inlineCode">VarHandle</code> and the element count for setting the data, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(struct);
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; struct.elementCount(); i++) {
    xHandle.set(segment, i, Math.random());
    yHandle.set(segment, i, Math.random());
  }
  ...
</code></pre>
    <p class="normal">Getting the data is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; struct.elementCount(); i++) {
    System.out.printf(<span class="hljs-string">"\nx = %.2f"</span>, xHandle.get(segment, i));
    System.out.printf(<span class="hljs-string">"\ny = %.2f"</span>, yHandle.get(segment, i));
  }
}
</code></pre>
    <p class="normal">Challenge yourself to<a id="_idIndexMarker860"/> implement this example via <code class="inlineCode">ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(int... shape)</code>.</p>
    <h1 id="_idParaDest-343" class="heading-1">154. Shaping C-like unions into memory segments</h1>
    <p class="normal">Let’s consider the C-like union<a id="_idIndexMarker861"/> from the following <a id="_idIndexMarker862"/>figure (the members of a C union share the same memory location (the member’s largest data type dictates the size of the memory location), so only one of the members has a value at any moment in time):</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_15.png" alt="Figure 7.18.png"/></figure>
    <p class="packt_figref">Figure 7.15: A C-like union</p>
    <p class="normal">In <em class="italic">Figure 7.15</em>, we have a C-like union named <code class="inlineCode">product</code> to shape two members, <code class="inlineCode">price</code> (<code class="inlineCode">double</code>) and <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>), while only one can have a value at any moment in time. We can shape a memory segment to fit this model as follows (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(
  ValueLayout.JAVA_DOUBLE.byteSize(),
  ValueLayout.JAVA_DOUBLE.byteAlignment());
</code></pre>
    <p class="normal">Because <code class="inlineCode">double</code> needs 8 bytes and <code class="inlineCode">int</code> needs only 4 bytes, we choose <code class="inlineCode">ValueLayout.JAVA_DOUBLE</code> to shape the size of the memory segment. This way, the segment can accommodate a <code class="inlineCode">double</code> and an <code class="inlineCode">int</code> at the same offset.</p>
    <p class="normal">Next, we can set the <code class="inlineCode">price</code> or the <code class="inlineCode">sku</code> and use it accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.setAtIndex(ValueLayout.JAVA_DOUBLE, <span class="hljs-number">0</span>, <span class="hljs-number">500.99</span>);
segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, <span class="hljs-number">101000</span>);
</code></pre>
    <p class="normal">When we <a id="_idIndexMarker863"/>set the <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>), the value of <code class="inlineCode">price</code> (<code class="inlineCode">double</code>) became<a id="_idIndexMarker864"/> a <em class="italic">garbage value</em> and vice versa. For more details, check out the bundled code. Next, let’s see an alternative to this implementation based on <code class="inlineCode">UnionLayout</code>.</p>
    <h2 id="_idParaDest-344" class="heading-2">Introducing UnionLayout</h2>
    <p class="normal">A <code class="inlineCode">UnionLayout</code> is a<a id="_idIndexMarker865"/> group layout. In this layout, the members (other memory layouts) are laid out at the same starting offset exactly as in a C union. This means that we can shape our C-like union by laying out the <code class="inlineCode">price</code> (<code class="inlineCode">double</code>) and the <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>) members as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">UnionLayout</span> <span class="hljs-variable">union</span> <span class="hljs-operator">=</span> MemoryLayout.unionLayout(
  ValueLayout.JAVA_DOUBLE.withName(<span class="hljs-string">"price"</span>),
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"sku"</span>));
</code></pre>
    <p class="normal">Next, as we already <a id="_idIndexMarker866"/>know from <em class="italic">Problem 152</em>, we need to define the proper layout paths via <code class="inlineCode">PathElement</code> and get back the <code class="inlineCode">VarHandle</code>. We need a <code class="inlineCode">VarHandle</code> for <code class="inlineCode">price</code> and one for <code class="inlineCode">sku</code>. Notice in the following code how we point them out via their names:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// VarHandle[varType=double, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">pHandle</span> = union.varHandle(
  PathElement.groupElement(<span class="hljs-string">"price"</span>));
<span class="hljs-comment">// VarHandle[varType=double, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">sHandle</span> = union.varHandle(
  PathElement.groupElement(<span class="hljs-string">"sku"</span>));
</code></pre>
    <p class="normal">Finally, we can use <code class="inlineCode">VarHandle</code> to set <code class="inlineCode">price</code> or <code class="inlineCode">sku</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(union);
  pHandle.set(segment, <span class="hljs-number">500.99</span>);
  sHandle.set(segment, <span class="hljs-number">101000</span>);
}
</code></pre>
    <p class="normal">When we set <a id="_idIndexMarker867"/>the <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>), the value of <code class="inlineCode">price</code> (<code class="inlineCode">double</code>) became a <em class="italic">garbage value</em> and vice versa.</p>
    <h1 id="_idParaDest-345" class="heading-1">155. Introducing PaddingLayout</h1>
    <p class="normal">Data types are typically<a id="_idIndexMarker868"/> characterized by several properties: <em class="italic">size</em>, <em class="italic">alignment</em>, <em class="italic">stride</em>, <em class="italic">padding</em>, and <em class="italic">order</em> of bytes.</p>
    <p class="normal"><em class="italic">The padding layout</em> (<code class="inlineCode">java.lang.foreign.PaddingLayout</code>) allows us to specify the <em class="italic">padding</em>. In other words, <code class="inlineCode">PaddingLayout</code> allows us to add at certain offsets some extra space that is usually ignored by the applications but is needed to align the member layouts of a memory segment.</p>
    <p class="normal">For instance, let’s<a id="_idIndexMarker869"/> consider the following two memory segments (the left-hand side is a memory segment without padding, while the right-hand side is a memory segment with two paddings of 4 bytes each).</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_16.png" alt="Figure 7.19.png"/></figure>
    <p class="packt_figref">Figure 7.16: Memory segments with (right-hand side)/without (left-hand side) padding</p>
    <p class="normal">In code lines, the padding-free memory segment can be shaped as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StructLayout</span> <span class="hljs-type">npStruct</span> = MemoryLayout.structLayout( 
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"x"</span>), 
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"</span><span class="hljs-string">y"</span>)
);
</code></pre>
    <p class="normal">Since the size of <code class="inlineCode">JAVA_INT</code> is 4 bytes, we can set <em class="italic">x</em> and <em class="italic">y</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">VarHandle</span> <span class="hljs-type">xpHandle</span> = npStruct.varHandle(
  PathElement.groupElement(<span class="hljs-string">"x"</span>));
<span class="hljs-type">VarHandle</span> <span class="hljs-type">ypHandle</span> = npStruct.varHandle(
  PathElement.groupElement(<span class="hljs-string">"y"</span>));
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(npStruct);
  xnHandle.set(segment, <span class="hljs-number">23</span>); <span class="hljs-comment">// offset 0</span>
  ynHandle.set(segment, <span class="hljs-number">54</span>); <span class="hljs-comment">// offset 4</span>
}
</code></pre>
    <p class="normal">This code writes the value 23 at offset 0, and 54 at offset 4. No surprises, right?</p>
    <p class="normal">Next, let’s code a memory segment with padding. For this, we call <code class="inlineCode">MemoryLayout.paddingLayout(long byteSize)</code> as in the following snippet (since we have two interleaved paddings of 4 bytes, we have to interleave two calls of <code class="inlineCode">paddingLayout()</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StructLayout</span> <span class="hljs-type">wpStruct</span> = MemoryLayout.structLayout(
  MemoryLayout.paddingLayout(<span class="hljs-number">4</span>), <span class="hljs-comment">// 4 bytes</span>
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"x"</span>),
  MemoryLayout.paddingLayout(<span class="hljs-number">4</span>), <span class="hljs-comment">// 4 bytes</span>
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"y"</span>)
);
</code></pre>
    <p class="normal">Next, we write the two <code class="inlineCode">int</code> values (23 and 54) again:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">VarHandle</span> <span class="hljs-type">xpHandle</span> = wpStruct.varHandle(
  PathElement.groupElement(<span class="hljs-string">"x"</span>));
<span class="hljs-type">VarHandle</span> <span class="hljs-type">ypHandle</span> = wpStruct.varHandle(
  PathElement.groupElement(<span class="hljs-string">"</span><span class="hljs-string">y"</span>));
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(wpStruct);
  xpHandle.set(segment, <span class="hljs-number">23</span>); <span class="hljs-comment">// offset 4</span>
  ypHandle.set(segment, <span class="hljs-number">54</span>); <span class="hljs-comment">// offset 12</span>
}
</code></pre>
    <p class="normal">This time, the padding zones are skipped, and 23 is written to offset 4, while 54 is written to offset 12. Reading <em class="italic">x</em> and <em class="italic">y</em> should be done from offset 4 and offset 12, respectively. From 0 to 3, and from 8 to 11, we have extra space added via <code class="inlineCode">paddingLayout()</code> that is ignored by the application. Attempting to read an <code class="inlineCode">int</code> from these zones results in values of 0 (default values).</p>
    <p class="normal">These <a id="_idIndexMarker870"/>examples have nicely and smoothly introduced the <em class="italic">padding </em>notion but they are not that useful in real scenarios. Remember that we said earlier that padding is useful for aligning the members of a memory segment. In order to understand this, let’s briefly hook a few more players.</p>
    <h2 id="_idParaDest-346" class="heading-2">Hooking size, alignment, stride, and padding</h2>
    <p class="normal">Before continuing to work with padding, we need to cover some notions that are closely related to each other and work hand in hand with padding.</p>
    <h3 id="_idParaDest-347" class="heading-3">Hooking size</h3>
    <p class="normal">By <em class="italic">size</em>, we mean the amount <a id="_idIndexMarker871"/>of memory (in bytes/bits) occupied by a memory layout (data type, C-like struct, C-like union, sequence layout, and so on). We know that a Java <code class="inlineCode">int</code> consumes 4 bytes, a Java <code class="inlineCode">byte</code> consumes 1 byte, a C-like struct consumes a number of bytes calculated as the sum of each property’s size, a C-like union consumes a number of bytes equal to the bigger property’s size, and so on.</p>
    <p class="normal">We can easily query the size via <code class="inlineCode">byteSize()</code>/<code class="inlineCode">bitSize()</code>. Here are some examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> ValueLayout.JAVA_INT.byteSize();   <span class="hljs-comment">// 4</span>
<span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> ValueLayout.JAVA_BYTE.byteSize();  <span class="hljs-comment">// 1</span>
<span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> npStruct.byteSize();               <span class="hljs-comment">// 8</span>
<span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> wpStruct.byteSize();               <span class="hljs-comment">// 16</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">npStruct</code> and <code class="inlineCode">wpStruct</code> were <a id="_idIndexMarker872"/>introduced earlier in this problem.</p>
    <h3 id="_idParaDest-348" class="heading-3">Hooking alignment</h3>
    <p class="normal">We know that each member<a id="_idIndexMarker873"/> layout starts in a memory segment at a specific address. We say that this address is <em class="italic">k</em>-byte-aligned if this address is a multiple of <em class="italic">k</em> (where <em class="italic">k</em> is any power of 2) or if this address is evenly divisible by <em class="italic">k</em>. Commonly, <em class="italic">k</em> is 1, 2, 4, or 8. Alignment is useful for sustaining CPU performance, which reads data in chunks of <em class="italic">k</em> bytes instead of reading byte by byte. If the CPU attempts to access a member layout that is not correctly aligned, then we’ll get an <code class="inlineCode">IllegalArgumentException: </code><em class="italic">Misaligned access at address …</em>.</p>
    <p class="normal">In the case of basic data types (<code class="inlineCode">int</code>, <code class="inlineCode">double</code>, <code class="inlineCode">float</code>, <code class="inlineCode">byte</code>, <code class="inlineCode">char</code>, and so on), the alignment value is equal to their size. For instance, an 8-bit (1-byte) Java <code class="inlineCode">byte</code> has a size of 1 byte and needs to be aligned to 1 byte. A 32-bit (4 bytes) Java <code class="inlineCode">int</code> has a size of 4 bytes and needs to be aligned to 4 bytes. In the case of a C-like struct/union, the alignment is the maximum alignment of all its member layouts.</p>
    <p class="normal">We can easily query the alignment via <code class="inlineCode">byteAlignment()</code>/<code class="inlineCode">bitAlignment()</code>. Here are some examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">align</span> <span class="hljs-operator">=</span> ValueLayout.JAVA_INT.byteAlignment();   <span class="hljs-comment">// 4</span>
<span class="hljs-type">long</span> <span class="hljs-variable">align</span> <span class="hljs-operator">=</span> ValueLayout.JAVA_BYTE.byteAlignment();  <span class="hljs-comment">// 1</span>
<span class="hljs-type">long</span> <span class="hljs-variable">align</span> <span class="hljs-operator">=</span> npStruct.byteAlignment();               <span class="hljs-comment">// 4</span>
<span class="hljs-type">long</span> <span class="hljs-variable">align</span> <span class="hljs-operator">=</span> wpStruct.byteAlignment();               <span class="hljs-comment">// 4</span>
</code></pre>
    <p class="normal">So, in a nutshell, a member layout should start with an address that must be at a multiple of its alignment. This applies to any kind of member layout (basic data type, C-like struct, C-like union, and so on).</p>
    <h3 id="_idParaDest-349" class="heading-3">Hooking stride</h3>
    <p class="normal">The minimum byte distance<a id="_idIndexMarker874"/> between two member layouts is called a <em class="italic">stride</em>. The stride can be greater than or equal to the size. When we don’t face any alignment issues, the stride is equal to the size. Otherwise, the stride is computed by rounding up the size to the next multiple of the alignment. When the stride is greater than the size, it means that we also have some padding. If we have a C-like struct/union named <code class="inlineCode">foo</code>, then the stride is the minimum byte distance between two <code class="inlineCode">foo</code> objects.</p>
    <h3 id="_idParaDest-350" class="heading-3">Hooking padding</h3>
    <p class="normal">So, padding is the amount of<a id="_idIndexMarker875"/> extra space that we need to add in order to preserve a valid alignment of the member layouts.</p>
    <p class="normal">Don’t worry if you are a little bit confused about all these statements. We will clarify everything via a bunch of examples.</p>
    <h2 id="_idParaDest-351" class="heading-2">Adding implicit extra space (implicit padding) to validate alignment</h2>
    <p class="normal">Let’s <a id="_idIndexMarker876"/>consider the following simple example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> Arena.ofAuto().allocate(<span class="hljs-number">12</span>);
segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);
segment.set(ValueLayout.JAVA_CHAR, <span class="hljs-number">4</span>, <span class="hljs-string">'a'</span>); 
</code></pre>
    <p class="normal">We have a memory segment of 12 bytes and we have set an <code class="inlineCode">int</code> of 4 bytes at offset 0 and a <code class="inlineCode">char</code> of 2 bytes at offset 4 (immediately after the <code class="inlineCode">int</code>). So, we still have 6 free bytes. Let’s assume that we want to set one more <code class="inlineCode">int</code> of 4 bytes after the <code class="inlineCode">char</code>, <code class="inlineCode">a</code>. What should the offset be? Our first thought may be that the proper offset is 6 since the <code class="inlineCode">char</code> consumed 2 bytes:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">6</span>, <span class="hljs-number">2000</span>);
</code></pre>
    <p class="normal">But if we do this, then the result is <code class="inlineCode">java.lang.IllegalArgumentException: </code><em class="italic">Misaligned access at the address: …</em>. We have a misaligned member layout (the 2000 <code class="inlineCode">int</code> value) because 6 is not evenly divisible by 4, which is the byte alignment of <code class="inlineCode">int</code>. Check out the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_17.png" alt="Figure 7.20.png"/></figure>
    <p class="packt_figref">Figure 7.17: Fixing the misaligned issue</p>
    <p class="normal">But what should we do? We know that the current offset is 6 and 6 is not evenly divisible by 4 (the <code class="inlineCode">int</code> alignment). So, we are looking for the next offset that is evenly divisible by 4 and is the closest and greater than 6. Obviously, this is 8. So, before we set the 2000 <code class="inlineCode">int</code> value, we need a padding of 2 bytes (16 bits). This padding will be automatically added if we simply specify the offset 8 instead of 6:</p>
    <pre class="programlisting code"><code class="hljs-code">segment.set(ValueLayout.JAVA_INT, <span class="hljs-number">8</span>, <span class="hljs-number">2000</span>);
</code></pre>
    <p class="normal">Since our <a id="_idIndexMarker877"/>memory segment has a size of 12 bytes, we fit this <code class="inlineCode">int</code> exactly on bytes 8, 9, 10, and 11. A smaller size of the segment leads to an <code class="inlineCode">IndexOutOfBoundsException:</code> <em class="italic">Out of bound access on segment MemorySegment</em>.</p>
    <h2 id="_idParaDest-352" class="heading-2">Adding explicit extra space (explicit padding) to validate alignment</h2>
    <p class="normal">Let’s consider<a id="_idIndexMarker878"/> the following C-like struct (let’s denote this as <em class="italic">Case 1</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StructLayout</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> MemoryLayout.structLayout(
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"sku"</span>),
  ValueLayout.JAVA_CHAR.withName(<span class="hljs-string">"energy"</span>),
  ValueLayout.JAVA_BYTE.withName(<span class="hljs-string">"weight"</span>));
</code></pre>
    <p class="normal">The <code class="inlineCode">product</code> size returned via <code class="inlineCode">byteSize()</code> is 7 bytes (4 + 2 + 1). The <code class="inlineCode">product</code> alignment returned via <code class="inlineCode">byteAlignment()</code> is 4 (the greater alignment of 4, 2, and 1). The byte offset of each member layout returned by <code class="inlineCode">byteOffset()</code> is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">boSku</span> <span class="hljs-operator">=</span>product.byteOffset(        <span class="hljs-comment">// 0</span>
  PathElement.groupElement(<span class="hljs-string">"sku"</span>));
<span class="hljs-type">long</span> <span class="hljs-variable">boEnergy</span> <span class="hljs-operator">=</span>product.byteOffset(     <span class="hljs-comment">// 4</span>
  PathElement.groupElement(<span class="hljs-string">"energy"</span>));
<span class="hljs-type">long</span> <span class="hljs-variable">boWeight</span> <span class="hljs-operator">=</span>product.byteOffset(     <span class="hljs-comment">// 6</span>
  PathElement.groupElement(<span class="hljs-string">"weight"</span>));
</code></pre>
    <p class="normal">If we represent this via a diagram, we obtain the following:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_18.png" alt="Figure 7.21.png"/></figure>
    <p class="packt_figref">Figure 7.18: The representation of the struct</p>
    <p class="normal">Everything<a id="_idIndexMarker879"/> looks fine, so we can go further. Now, let’s use the same struct, but we arrange the member layouts as follows (let’s denote this as <em class="italic">Case 2</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StructLayout</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> MemoryLayout.structLayout( 
  ValueLayout.JAVA_CHAR.withName(<span class="hljs-string">"energy"</span>),
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"</span><span class="hljs-string">sku"</span>),
  ValueLayout.JAVA_BYTE.withName(<span class="hljs-string">"weight"</span>));
</code></pre>
    <p class="normal">First, we place the <code class="inlineCode">energy</code> (<code class="inlineCode">char</code>) at offset 0. Since <code class="inlineCode">energy</code> (<code class="inlineCode">char</code>) consumes 2 bytes, it is followed by <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>) at offset 2. Since <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>) consumes 4 bytes, it is followed by <code class="inlineCode">weight</code> (<code class="inlineCode">byte</code>). But is this the correct logic? As you can see in the following figure (left-hand side), this logic is incorrect, because we have an invalid alignment error at offset 2 for the <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>).</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_19.png" alt="Figure 7.22.png"/></figure>
    <p class="packt_figref">Figure 7.19: Incorrect/correct padding</p>
    <p class="normal">The<a id="_idIndexMarker880"/> alignment of <code class="inlineCode">energy</code> (<code class="inlineCode">char</code>) is 2, so it can start only on 0, 2, 4, …. Since <code class="inlineCode">energy</code> (<code class="inlineCode">char</code>) is the first, we start with it on offset 0. Next, the alignment of <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>) is 4, so it can start only on 0, 4, 8, …. That is why the start address of <code class="inlineCode">sku</code> is at 4 and not at 2. Finally, the alignment of <code class="inlineCode">weight</code> (<code class="inlineCode">byte</code>) is 1, so it can go after <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>) at offset 8.</p>
    <p class="normal">So, by following the alignment rules, we conclude that the size of <code class="inlineCode">product</code> is 9, not 7. At this point, we know that to align <code class="inlineCode">sku</code> (<code class="inlineCode">int</code>), we should add a padding of 2 bytes (16 bits) at offset 2, so let’s do it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StructLayout</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> MemoryLayout.structLayout(
  ValueLayout.JAVA_CHAR.withName(<span class="hljs-string">"energy"</span>),
  <span class="code-highlight"><strong class="hljs-slc">MemoryLayout.paddingLayout(</strong><strong class="hljs-number-slc">2</strong><strong class="hljs-slc">),</strong></span>
  ValueLayout.JAVA_INT.withName(<span class="hljs-string">"sku"</span>),
  ValueLayout.JAVA_BYTE.withName(<span class="hljs-string">"weight"</span>));
</code></pre>
    <p class="normal">Next, let’s assume that we want to repeat this C-like struct 2 times (or <em class="italic">n</em> times). For this, we nest the struct in a sequence layout as follows (let’s denote this as <em class="italic">Case 3</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> MemoryLayout.sequenceLayout(
  <span class="hljs-number">2</span>, MemoryLayout.structLayout(
    ValueLayout.JAVA_CHAR.withName(<span class="hljs-string">"energy"</span>),
    MemoryLayout.paddingLayout(<span class="hljs-number">2</span>),
    ValueLayout.JAVA_INT.withName(<span class="hljs-string">"sku"</span>),
    ValueLayout.JAVA_BYTE.withName(<span class="hljs-string">"weight"</span>)));
</code></pre>
    <p class="normal">This time, the code fails with an exception as <code class="inlineCode">IllegalArgumentException:</code> <em class="italic">Element layout size is not multiple of alignment</em>. What’s happening now? Well, the first struct instance lies out from offset 0 to offset 8, and, conforming to our code, the second struct lies out from offset 9 to offset 18, as in the following figure (top diagram):</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_20.png" alt="Figure 7.23.png"/></figure>
    <p class="packt_figref">Figure 7.20: Calculating stride</p>
    <p class="normal">But this is <a id="_idIndexMarker881"/>not correct, because the second instance of the struct (and the third, fourth, and so on) doesn’t follow the alignment rules. The alignment of the struct is 4, so an instance of the struct should be at 0, 4, 8, 12, 16, …, but not at 9. This means that we need to calculate the <em class="italic">stride</em>, which gives us the minimum byte distance between two member layouts – here, two instances of our struct.</p>
    <p class="normal">We have that the size of the struct instance is 9 and its alignment is 4. So, we need to find the offset evenly divisible by 4 that is greater and closest to 9. This is 12. Since the <em class="italic">stride</em> is 12, it means that the second instance of the struct starts at offset 12. We need to add a padding of 3 (12-9) bytes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> MemoryLayout.sequenceLayout(
  <span class="hljs-number">2</span>, MemoryLayout.structLayout(
    ValueLayout.JAVA_CHAR.withName(<span class="hljs-string">"energy"</span>),
    MemoryLayout.paddingLayout(<span class="hljs-number">2</span>),
    ValueLayout.JAVA_INT.withName(<span class="hljs-string">"sku"</span>),
    ValueLayout.JAVA_BYTE.withName(<span class="hljs-string">"weight"</span>),
    <span class="code-highlight"><strong class="hljs-slc">MemoryLayout.paddingLayout(</strong><strong class="hljs-number-slc">3</strong><strong class="hljs-slc">)</strong></span>));
</code></pre>
    <p class="normal">Done! As you can see, the order of member layouts counts a lot. By being aware of the size, alignment, stride, and padding, we can optimize the memory allocation by simply arranging the member layouts in a proper order that requires 0 or minimum padding.</p>
    <p class="normal">In the bundled<a id="_idIndexMarker882"/> code, you can find more examples of permutating the member layout of our struct.</p>
    <h1 id="_idParaDest-353" class="heading-1">156. Copying and slicing memory segments</h1>
    <p class="normal">Let’s consider the <a id="_idIndexMarker883"/>following memory segment (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">srcSegment</span> = arena.allocateArray(
  ValueLayout.JAVA_INT, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, 
                        <span class="hljs-number">52</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);
</code></pre>
    <p class="normal">Next, let’s see how we can copy the content of this segment.</p>
    <h2 id="_idParaDest-354" class="heading-2">Copying a segment</h2>
    <p class="normal">We can make <a id="_idIndexMarker884"/>a copy of this memory segment via <code class="inlineCode">copyFrom(MemorySegment src)</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">copySegment</span> = srcSegment.copyFrom(srcSegment);
</code></pre>
    <p class="normal">We can easily see if the data was copied as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Data: "</span> + Arrays.toString(
  copySegment.toArray(ValueLayout.JAVA_INT)));
</code></pre>
    <p class="normal">This is a bulk operation that creates a full copy of the given memory segment. </p>
    <h2 id="_idParaDest-355" class="heading-2">Copying a part of the segment into another segment (1)</h2>
    <p class="normal">Let’s suppose that we <a id="_idIndexMarker885"/>want to copy only a part of <code class="inlineCode">srcSegment</code> into another segment (<code class="inlineCode">dstSegment</code>). For instance, if we wanted to copy the last 8 elements ([22, 33, -1, -1, -1, -1, -1, 4]) from <code class="inlineCode">srcSegment</code> to <code class="inlineCode">dstSegment</code>, we’d start by allocating the <code class="inlineCode">dstSegment</code> accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">dstSegment</span>
  = arena.allocateArray(ValueLayout.JAVA_INT, <span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">Next, we call the <code class="inlineCode">copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)</code> method as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_21.png" alt="Figure 7.24 - Copy.png"/></figure>
    <p class="packt_figref">Figure 7.21: Copying a part of a segment into another segment (1)</p>
    <p class="normal">So, we specify the source segment as <code class="inlineCode">srcSsegment</code>, the source offset as 32 (skip the first 8 elements), the destination segment as <code class="inlineCode">dstSegment</code>, the destination offset as 0, and the number of bytes to be copied as 32 (the last 8 elements are copied):</p>
    <pre class="programlisting code"><code class="hljs-code">MemorySegment.copy(srcSegment, <span class="hljs-number">32</span>, dstSegment, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>);
</code></pre>
    <p class="normal">Practically, we <a id="_idIndexMarker886"/>copied half of the <code class="inlineCode">srcSegment</code> to <code class="inlineCode">dstSegment</code>.</p>
    <h2 id="_idParaDest-356" class="heading-2">Copying a segment into an on-heap array</h2>
    <p class="normal">Let’s suppose<a id="_idIndexMarker887"/> that we want to copy only a part<a id="_idIndexMarker888"/> of <code class="inlineCode">srcSegment</code> into an on-heap Java regular array (<code class="inlineCode">dstArray</code>). For instance, if we wanted to copy the last 8 elements ([22, 33, -1, -1, -1, -1, -1, 4]) from <code class="inlineCode">srcSegment</code> to <code class="inlineCode">dstArray</code>, we’d start by creating the <code class="inlineCode">dstArray</code> accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] dstArray = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[<span class="hljs-number">8</span>];
</code></pre>
    <p class="normal">Next, we’d call <code class="inlineCode">copy(MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset, Object dstArray, int dstIndex, int elementCount)</code>, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_22.png" alt="Figure 7.24 - Copy - Copy.png"/></figure>
    <p class="packt_figref">Figure 7.22: Copying a segment into an on-heap array</p>
    <p class="normal">So, we <a id="_idIndexMarker889"/>specify the source segment <a id="_idIndexMarker890"/>as <code class="inlineCode">srcSegment</code>, the source layout as <code class="inlineCode">JAVA_INT</code>, the source offset as 32 (skip the first 8 elements), the destination array as <code class="inlineCode">dstArray</code>, the destination array index as 0, and the number of elements to be copied as 8:</p>
    <pre class="programlisting code"><code class="hljs-code">MemorySegment.copy(
  srcSegment, ValueLayout.JAVA_INT, <span class="hljs-number">32</span>, dstArray, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">Practically, we copied half of the off-heap <code class="inlineCode">srcSegment</code> to the on-heap <code class="inlineCode">dstArray</code>.</p>
    <h2 id="_idParaDest-357" class="heading-2">Copying an on-heap array into a segment</h2>
    <p class="normal">Let’s<a id="_idIndexMarker891"/> suppose that we want to copy an on-heap<a id="_idIndexMarker892"/> array (or a part of it) into a segment. The given on-heap array is <code class="inlineCode">srcArray</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] srcArray = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">10</span>, <span class="hljs-number">44</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">55</span>, <span class="hljs-number">65</span>, <span class="hljs-number">7</span>, <span class="hljs-number">89</span>};
</code></pre>
    <p class="normal">The destination segment can hold 16 integer values:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">dstSegment</span>
  = arena.allocateArray(ValueLayout.JAVA_INT, <span class="hljs-number">16</span>);
</code></pre>
    <p class="normal">Next, we want to overwrite the last 8 elements from <code class="inlineCode">dstSegment</code> with the elements from <code class="inlineCode">srcArray</code>, while the first elements remain 0. For this, we call <code class="inlineCode">copy(Object srcArray, int srcIndex, MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset, int elementCount)</code>, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_23.png" alt="Figure 7.24 - Copy - Copy - Copy.png"/></figure>
    <p class="packt_figref">Figure 7.23: Copying an on-heap array into a segment</p>
    <p class="normal">So, we specify the source array as <code class="inlineCode">srcArray</code>, the source index as 0, the destination segment as <code class="inlineCode">dstSegment</code>, the destination layout as <code class="inlineCode">JAVA_INT</code>, the destination offset as 32 (skip the first 8 elements), and the number of elements to be copied as 8:</p>
    <pre class="programlisting code"><code class="hljs-code">MemorySegment.copy(
  srcArray, <span class="hljs-number">0</span>, dstSegment, ValueLayout.JAVA_INT, <span class="hljs-number">32</span>, <span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">Practically, we <a id="_idIndexMarker893"/>copied the on-heap <code class="inlineCode">srcArray</code> as the<a id="_idIndexMarker894"/> second half of the off-heap <code class="inlineCode">destSegment</code>.</p>
    <h2 id="_idParaDest-358" class="heading-2">Copying a part of the segment into another segment (2)</h2>
    <p class="normal">Let’s consider <a id="_idIndexMarker895"/>the <code class="inlineCode">srcSegment</code> (1, 2, 3, 4, -1, -1, -1, 52, 22, 33, -1, -1, -1, -1, -1, 4) and the <code class="inlineCode">dstSegment</code> (0, 0, 0, 0, 0, 0, 0, 0, 10, 44, 2, 6, 55, 65, 7, 89) from the previous sections. We want to copy the last 8 elements from <code class="inlineCode">srcSegment</code> as the first 8 elements from <code class="inlineCode">dstSegment</code> (22, 33, -1, -1, -1, -1, -1, 4, 10, 44, 2, 6, 55, 65, 7, 89). We know that this can be done via <code class="inlineCode">copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">MemorySegment.copy(srcSegment, <span class="hljs-number">32</span>, dstSegment, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>);
</code></pre>
    <p class="normal">Alternatively, we can use <code class="inlineCode">copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, long elementCount)</code>, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_24.png" alt="Figure 7.24 - Copy - Copy (2).png"/></figure>
    <p class="packt_figref">Figure 7.24: Copying a part of a segment into another segment (2)</p>
    <p class="normal">So, we specify the source segment as <code class="inlineCode">srcSegment</code>, the source layout as <code class="inlineCode">JAVA_INT</code>, the source offset as 32 (skip the first 8 elements), the destination segment as <code class="inlineCode">dstSegment</code>, the destination layout as <code class="inlineCode">JAVA_INT</code>, the destination offset as 0, and the number of elements to be copied as 8:</p>
    <pre class="programlisting code"><code class="hljs-code">MemorySegment.copy(srcSegment, ValueLayout.JAVA_INT, 
  <span class="hljs-number">32</span>, dstSegment, ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">Feel free to <a id="_idIndexMarker896"/>test this method with different value layouts. Next, let’s talk about slicing.</p>
    <h2 id="_idParaDest-359" class="heading-2">Slicing a segment</h2>
    <p class="normal">Next, let’s suppose that we want to slice<a id="_idIndexMarker897"/> the segment containing (1, 2, 3, 4, -1, -1, -1, 52, 22, 33, -1, -1, -1, -1, -1, 4) into three separate <code class="inlineCode">IntVector</code> instances the values that are not -1 without using the <code class="inlineCode">copy()</code> methods. So, <code class="inlineCode">v1</code> should contain [1, 2, 3, 4], <code class="inlineCode">v2</code> should contain [52, 22, 33, 0], and <code class="inlineCode">v3</code> should contain [4, 0, 0, 0]. Since an <code class="inlineCode">int</code> needs 4 bytes, and we have a maximum of 4 <code class="inlineCode">int</code> values, we go for <code class="inlineCode">SPECIES_128</code> (4 <code class="inlineCode">int</code> values x 4 bytes = 16 bytes x 8 bits = 128 bits):</p>
    <pre class="programlisting code"><code class="hljs-code">VectorSpecies&lt;Integer&gt; VS128 = IntVector.SPECIES_128;
</code></pre>
    <p class="normal">Next, we need to slice the memory segment in order to eliminate the values of -1. This can be accomplished via the <code class="inlineCode">asSlice(long offset)</code> and <code class="inlineCode">asSlice(long offset, long newSize)</code> methods. The first argument represents the starting offset. The second argument represents the size of the new memory segment. The following figure helps us to clear this up:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_25.png" alt="Figure 7.24.png"/></figure>
    <p class="packt_figref">Figure 7.25: Slicing a memory segment</p>
    <p class="normal">The first <a id="_idIndexMarker898"/>memory segment starts at offset 0 and ends at offset 16, so it contains 4 <code class="inlineCode">int</code> values of 4 bytes (<code class="inlineCode">asSlice(0, 16)</code>). The second memory segment starts at offset 28 and ends at offset 40, so it contains 3 <code class="inlineCode">int</code> values of 4 bytes (<code class="inlineCode">asSlice(28, 12)</code>). Finally, the third memory segment starts at offset 60 and ends at the end of the segment, so it contains a single <code class="inlineCode">int</code> value of 4 bytes (<code class="inlineCode">asSlice(60)</code> or <code class="inlineCode">asSlice(60, 4)</code>). The resulting code is listed here:</p>
    <pre class="programlisting code"><code class="hljs-code">IntVector v1, v2, v3;
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">srcSegment</span> = arena.allocateArray(
    ValueLayout.JAVA_INT, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">52</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>,
                         -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);
v1 = IntVector.fromMemorySegment(VS128,
  srcSegment.asSlice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>), <span class="hljs-number">0</span>, ByteOrder.nativeOrder());
v2 = IntVector.fromMemorySegment(VS128,
  srcSegment.asSlice(<span class="hljs-number">28</span>, <span class="hljs-number">12</span>), <span class="hljs-number">0</span>, ByteOrder.nativeOrder(),
  VS128.indexInRange(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>));
v3 = IntVector.fromMemorySegment(VS128,
  srcSegment.asSlice(<span class="hljs-number">60</span>), <span class="hljs-number">0</span>, ByteOrder.nativeOrder(),
  VS128.indexInRange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
}
</code></pre>
    <p class="normal">Done! Of course, we can slice a memory segment in regular Java arrays as well. Here you go:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] jv1, jv2, jv3;
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">srcSegment</span> = arena.allocateArray(
    ValueLayout.JAVA_INT, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">52</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>,
                         -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);
  jv1 = srcSegment
    .asSlice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>).toArray(ValueLayout.JAVA_INT);
  jv2 = srcSegment
    .asSlice(<span class="hljs-number">28</span>, <span class="hljs-number">12</span>).toArray(ValueLayout.JAVA_INT);
  jv3 = srcSegment
    .asSlice(<span class="hljs-number">60</span>).toArray(ValueLayout.JAVA_INT);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">toArray()</code> method<a id="_idIndexMarker899"/> returns a Java regular array (here, <code class="inlineCode">int[]</code>) from the sliced memory segment.</p>
    <h3 id="_idParaDest-360" class="heading-3">Using asOverlappingSlice()</h3>
    <p class="normal">The <code class="inlineCode">asOverlappingSlice(MemorySegment other)</code> method returns a slice of this segment that <a id="_idIndexMarker900"/>overlaps the given segment as <a id="_idIndexMarker901"/>an <code class="inlineCode">Optional&lt;MemorySegment&gt;</code>. Consider the following segment (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocateArray(
  ValueLayout.JAVA_INT, <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>});
</code></pre>
    <p class="normal">And, we slice it at offset 12, so at value 4:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">subsegment</span> <span class="hljs-operator">=</span> segment.asSlice(<span class="hljs-number">12</span>);
</code></pre>
    <p class="normal">Finally, we call <code class="inlineCode">asOverlappingSlice()</code> to see where the overlapping occurs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] subarray = segment.asOverlappingSlice(subsegment)
  .orElse(MemorySegment.NULL).toArray(ValueLayout.JAVA_INT);
</code></pre>
    <p class="normal">The resulting array is [4, 6, 8, 4, 5, 3].</p>
    <h3 id="_idParaDest-361" class="heading-3">Using segmentOffset()</h3>
    <p class="normal">The <code class="inlineCode">segmentOffset(MemorySegment other)</code> returns <a id="_idIndexMarker902"/>the offset <a id="_idIndexMarker903"/>of the given segment (<code class="inlineCode">other</code>) relative to this segment. Consider the following segment (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocateArray(
  ValueLayout.JAVA_INT, <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>});
</code></pre>
    <p class="normal">And, we slice it at offset 16, so at value 6:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">subsegment</span> <span class="hljs-operator">=</span> segment.asSlice(<span class="hljs-number">16</span>);
</code></pre>
    <p class="normal">Next, we call <code class="inlineCode">segmentOffset()</code> to find out at what offset in <code class="inlineCode">segment</code> we have <code class="inlineCode">subsegment</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 16</span>
<span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> segment.segmentOffset(subsegment);
<span class="hljs-comment">// 6</span>
segment.get(ValueLayout.JAVA_INT, offset)
</code></pre>
    <p class="normal">You can <a id="_idIndexMarker904"/>practice all these examples in the bundled<a id="_idIndexMarker905"/> code. Challenge yourself to explore <code class="inlineCode">MemorySegment.mismatch()</code> further.</p>
    <h1 id="_idParaDest-362" class="heading-1">157. Tackling the slicing allocator</h1>
    <p class="normal">Let’s <a id="_idIndexMarker906"/>consider the following three Java regular <code class="inlineCode">int</code> arrays:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};
<span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>};
<span class="hljs-type">int</span>[] arr3 = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>};
</code></pre>
    <p class="normal">Next, we want to allocate a memory segment to each of these arrays. A straightforward approach relies on <code class="inlineCode">Arena.allocateArray()</code> introduced in <em class="italic">Problem 150</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
<span class="hljs-type">  MemorySegment</span> <span class="hljs-variable">segment1</span> 
    <span class="hljs-operator">=</span> arena.allocateArray(ValueLayout.JAVA_INT, arr1);
<span class="hljs-type">  MemorySegment</span> <span class="hljs-variable">segment2</span> 
    <span class="hljs-operator">=</span> arena.allocateArray(ValueLayout.JAVA_INT, arr2);
<span class="hljs-type">  MemorySegment</span> <span class="hljs-variable">segment3</span> 
    <span class="hljs-operator">=</span> arena.allocateArray(ValueLayout.JAVA_INT, arr3);
}
</code></pre>
    <p class="normal">This approach allocates enough memory to accommodate each of the given arrays. But, sometimes, we want to allocate only a certain amount of memory. If this fixed amount is not enough, then we want to tackle the problem differently. For this, we can rely on a <code class="inlineCode">java.lang.foreign.SegmentAllocator</code>. Of course, there are many other scenarios when <code class="inlineCode">SegmentAllocator</code> is useful, but for now, let’s tackle the following one. </p>
    <p class="normal">Let’s assume<a id="_idIndexMarker907"/> that we allow allocating a fixed size of 10 * 4 = 40 bytes. This is a bulk amount of memory that should be sliced between our three arrays. First, we allocate these 40 bytes as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">SegmentAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> 
    SegmentAllocator.slicingAllocator(arena.allocate(<span class="hljs-number">10</span> * <span class="hljs-number">4</span>)); 
  ...
</code></pre>
    <p class="normal">Next, we use the <code class="inlineCode">allocator</code> to allocate a slice from these 40 bytes to each array. The first array (<code class="inlineCode">arr1</code>) has 6 values, so the memory segment gets 6 * 4 = 24 bytes:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment1</span> <span class="hljs-operator">=</span> allocator.allocateArray(
    ValueLayout.JAVA_INT, arr1);
  ...
</code></pre>
    <p class="normal">The segment allocator has available 40 – 24 = 16 more bytes. The second array (<code class="inlineCode">arr2</code>) has 3 values, so the memory segment gets 3 * 4 = 12 bytes:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment2</span> <span class="hljs-operator">=</span> allocator.allocateArray(
    ValueLayout.JAVA_INT, arr2);
  ...
</code></pre>
    <p class="normal">The segment allocator has available 16 – 12 = 4 more bytes. The third array (<code class="inlineCode">arr3</code>) has 5 values, so it needs a memory segment of 5 * 4 = 20 bytes, but only 4 are available. This causes an <code class="inlineCode">IndexOutOfBoundsException</code> and gives us the control to handle this corner case:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment3</span> <span class="hljs-operator">=</span> allocator.allocateArray(
    ValueLayout.JAVA_INT, arr3);
} <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e) {
  System.out.println(
    <span class="hljs-string">"</span><span class="hljs-string">There is not enough memory to fit all data"</span>);
    <span class="hljs-comment">// handle exception</span>
}
</code></pre>
    <p class="normal">A possible approach to avoid this <code class="inlineCode">IndexOutOfBoundsException</code> may consist of giving more memory to the segment allocator. In this case, we need to give it 16 more bytes, so we can express it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SegmentAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> SegmentAllocator
  .slicingAllocator(arena.allocate(<span class="hljs-number">10</span> * <span class="hljs-number">4</span> + <span class="hljs-number">4</span> * <span class="hljs-number">4</span>));
</code></pre>
    <p class="normal">Of course, you<a id="_idIndexMarker908"/> don’t have to write 10 * 4 + 4 * 4. You can say 14 * 4, or just 56. Basically, our three arrays have 14 elements of 4 bytes each, and initially, we covered only 10 of them. Next, we increased the memory to cover the remaining 4 as well.</p>
    <h1 id="_idParaDest-363" class="heading-1">158. Introducing the slice handle</h1>
    <p class="normal">Let’s suppose that we have the<a id="_idIndexMarker909"/> following nested model (10 sequences of 5 <code class="inlineCode">double</code> values each):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">innerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">5</span>, ValueLayout.JAVA_DOUBLE);
<span class="hljs-type">SequenceLayout</span> <span class="hljs-type">outerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">10</span>, innerSeq);
</code></pre>
    <p class="normal">Next, we define a <code class="inlineCode">VarHandle</code> via <code class="inlineCode">PathElement</code> and we populate this model accordingly with some random data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">VarHandle</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> outerSeq.varHandle(
  PathElement.sequenceElement(),
  PathElement.sequenceElement());
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(outerSeq);
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; outerSeq.elementCount(); i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; innerSeq.elementCount(); j++) {
      handle.set(segment, i, j, Math.random());
    }
  }
}
</code></pre>
    <p class="normal">OK, you should be familiar with this code, so nothing new so far. Next, we plan to extract from this model the third sequence from 10 containing 5 sequences of <code class="inlineCode">double</code> values. We can accomplish this via the <code class="inlineCode">sliceHandle(PathElement... elements)</code> method, which returns a <code class="inlineCode">java.lang.invoke.MethodHandle</code>. This <code class="inlineCode">MethodHandle</code> takes a memory segment and returns a slice of it corresponding to the selected memory layout. Here is the code for our scenario:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MethodHandle</span> <span class="hljs-type">mHandle</span> = outerSeq.sliceHandle(
  PathElement.sequenceElement());
System.out.println(<span class="hljs-string">"\n The third sequence of 10: "</span> 
  + Arrays.toString(
    ((MemorySegment) mHandle.invoke(segment, <span class="hljs-number">3</span>))
      .toArray(ValueLayout.JAVA_DOUBLE)));
</code></pre>
    <p class="normal">Done! Now, you know<a id="_idIndexMarker910"/> how to slice out a certain memory layout from the given memory segment.</p>
    <h1 id="_idParaDest-364" class="heading-1">159. Introducing layout flattening</h1>
    <p class="normal">Let’s suppose that we have the <a id="_idIndexMarker911"/>following nested model (the exact same model as in <em class="italic">Problem 158</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">innerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">5</span>, ValueLayout.JAVA_DOUBLE);
<span class="hljs-type">SequenceLayout</span> <span class="hljs-type">outerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">10</span>, innerSeq);
</code></pre>
    <p class="normal">Next, we define a <code class="inlineCode">VarHandle</code> via <code class="inlineCode">PathElement</code> and we populate this model accordingly with some random data in a memory segment named <code class="inlineCode">segment</code> (you can see the code listed in <em class="italic">Problem 158</em>).</p>
    <p class="normal">Our goal is to take this<a id="_idIndexMarker912"/> nested model and obtain a flat model. So, instead of having 10 sequences of 5 <code class="inlineCode">double</code> values each, we want one sequence of 50 <code class="inlineCode">double</code> values. This can be achieved via the <code class="inlineCode">flatten()</code> method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-variable">flatten</span> <span class="hljs-operator">=</span> outerSeq.flatten();
<span class="hljs-type">VarHandle</span> <span class="hljs-type">fhandle</span> = flatten.varHandle(
  PathElement.sequenceElement());
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; flatten.elementCount(); i++) {
  System.out.printf(<span class="hljs-string">"\nx = %.2f"</span>, fhandle.get(segment, i));
}
</code></pre>
    <p class="normal">Notice the <code class="inlineCode">PathElement</code>, which traverses a single sequence. This is the sequence that resulted after the flatten operation. We can go further and allocate another memory segment for this<a id="_idIndexMarker913"/> sequence and set new data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(flatten);
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; flatten.elementCount(); i++) {
    fhandle.set(segment, i, Math.random());
  }
}
</code></pre>
    <p class="normal">Next, let’s see how we can reshape a memory layout.</p>
    <h1 id="_idParaDest-365" class="heading-1">160. Introducing layout reshaping</h1>
    <p class="normal">Let’s suppose that we have the<a id="_idIndexMarker914"/> following nested model (the exact same model as in <em class="italic">Problem 158</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">innerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">5</span>, ValueLayout.JAVA_DOUBLE);
<span class="hljs-type">SequenceLayout</span> <span class="hljs-type">outerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">10</span>, innerSeq);
</code></pre>
    <p class="normal">Next, we define a <code class="inlineCode">VarHandle</code> via <code class="inlineCode">PathElement</code> and we populate this model accordingly with some random data (you can see the code listed in <em class="italic">Problem 158</em>).</p>
    <p class="normal">Our goal is to reshape this model to look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">innerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">25</span>, ValueLayout.JAVA_DOUBLE);
<span class="hljs-type">SequenceLayout</span> <span class="hljs-type">outerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">2</span>, innerSeq);
</code></pre>
    <p class="normal">So, instead of <a id="_idIndexMarker915"/>having 10 sequences of 5 <code class="inlineCode">double</code> values each, we want 25 sequences of 2 <code class="inlineCode">double</code> values each. In order to accomplish this reshaping goal, we can rely on the <code class="inlineCode">reshape(long... elementCounts)</code> method. This method takes the elements of this sequence layout and re-arranges them into a multi-dimensional sequence layout conforming to the given list of element counts per sequence. So, in our case, we do it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-variable">reshaped</span> <span class="hljs-operator">=</span> outerSeq.reshape(<span class="hljs-number">25</span>, <span class="hljs-number">2</span>);
</code></pre>
    <p class="normal">You can see the complete <a id="_idIndexMarker916"/>example in the bundled code.</p>
    <h1 id="_idParaDest-366" class="heading-1">161. Introducing the layout spreader</h1>
    <p class="normal">Let’s suppose that we <a id="_idIndexMarker917"/>have the following nested model (the exact same model as in <em class="italic">Problem 158</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">innerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">5</span>, ValueLayout.JAVA_DOUBLE);
<span class="hljs-type">SequenceLayout</span> <span class="hljs-type">outerSeq</span>
  = MemoryLayout.sequenceLayout(<span class="hljs-number">10</span>, innerSeq);
</code></pre>
    <p class="normal">Next, we define a <code class="inlineCode">VarHandle</code> via <code class="inlineCode">PathElement</code> and we populate this model accordingly with some random data in a memory segment named <code class="inlineCode">segment</code> (you can see the code listed in <em class="italic">Problem 158</em>).</p>
    <p class="normal">Next, let’s assume that we want to extract the third <code class="inlineCode">double</code> value from the seventh sequence (count starts from 0). Among the approaches, we can rely on <code class="inlineCode">sliceHandle()</code> introduced in <em class="italic">Problem 158,</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MethodHandle</span> <span class="hljs-type">mHandle</span> = outerSeq.sliceHandle(
  PathElement.sequenceElement(),
  PathElement.sequenceElement());
<span class="hljs-type">MemorySegment</span> <span class="hljs-type">ms</span> = (MemorySegment)     
  mHandle.invokeExact(segment, <span class="hljs-number">7L</span>, <span class="hljs-number">3L</span>);
System.out.println(ms.get(ValueLayout.JAVA_DOUBLE, <span class="hljs-number">0</span>));
</code></pre>
    <p class="normal">Another approach consists of using an <em class="italic">array-spreading</em> method handle. In other words, by calling the <code class="inlineCode">asSpreader(Class&lt;?&gt; arrayType, int arrayLength)</code> method, we can obtain a <em class="italic">spreader-array</em> that contains the positional arguments that we want to pass over and has a length equal to the given <code class="inlineCode">arrayLength</code>. Since we have two pass-over <code class="inlineCode">long</code> arguments (7L and 3L), we need a <code class="inlineCode">long[]</code> array of length 2:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">ms</span> = (MemorySegment) mHandle
  .asSpreader(Long[].class, <span class="hljs-number">2</span>)
  .invokeExact(segment, <span class="hljs-keyword">new</span> <span class="hljs-title">Long</span>[]{<span class="hljs-number">7L</span>, <span class="hljs-number">3L</span>});
</code></pre>
    <p class="normal">You may also <a id="_idIndexMarker918"/>be interested in <code class="inlineCode">asCollector(Class&lt;?&gt; arrayType, int arrayLength)</code>, which is basically the opposite of <code class="inlineCode">asSpreader()</code>. You give a list of arguments and this method collects them in an <em class="italic">array-collecting</em>.</p>
    <h1 id="_idParaDest-367" class="heading-1">162. Introducing the memory segment view VarHandle</h1>
    <p class="normal">Let’s consider the following simple <a id="_idIndexMarker919"/>memory segment for storing an int (<code class="inlineCode">arena</code> is an instance of <code class="inlineCode">Arena</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(ValueLayout.JAVA_INT);
</code></pre>
    <p class="normal">We know that we can create a <code class="inlineCode">VarHandle</code> via <code class="inlineCode">PathElement</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// VarHandle[varType=int, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">handle</span> = ValueLayout.JAVA_INT.varHandle();
</code></pre>
    <p class="normal">Or, via <code class="inlineCode">arrayElementVarHandle()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// VarHandle[varType=int, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment, long]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">arrhandle</span>
  = ValueLayout.JAVA_INT.arrayElementVarHandle();
</code></pre>
    <p class="normal">The <code class="inlineCode">MethodHandles.memorySegmentViewVarHandle(ValueLayout layout)</code> is another approach for creating a <code class="inlineCode">VarHandle</code> that can be used to access a memory segment. The returned <code class="inlineCode">VarHandle</code> perceives/views the content of the memory segment as a sequence of the given <code class="inlineCode">ValueLayout</code>. In our case, the code looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// VarHandle[varType=int, </span>
<span class="hljs-comment">// coord=[interface java.lang.foreign.MemorySegment, long]]</span>
<span class="hljs-type">VarHandle</span> <span class="hljs-type">viewhandle</span> = MethodHandles
  .memorySegmentViewVarHandle(ValueLayout.JAVA_INT);
</code></pre>
    <p class="normal">Next, we can rely on <code class="inlineCode">insertCoordinates(VarHandle target, int pos, Object... values)</code> to specify the set of <em class="italic">bound coordinates</em> before the <code class="inlineCode">VarHandle</code> is actually invoked. In other words, the returned <code class="inlineCode">VarHandle</code> will expose fewer Coordinate Types (CTs) than the given <code class="inlineCode">target</code>.</p>
    <p class="normal">In our example, the <code class="inlineCode">target</code> argument (invoked after inserting the set of <em class="italic">bound coordinates</em>) is <code class="inlineCode">viewhandle</code>. The position of the first coordinate is 1, and we have a single <em class="italic">bound coordinate</em> representing the offset 0 of type <code class="inlineCode">long</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">viewhandle = MethodHandles
  .insertCoordinates(viewhandle, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); 
</code></pre>
    <p class="normal">Now, when we call the popular <code class="inlineCode">VarHandle.set/get(Object...)</code> on the returned <code class="inlineCode">VarHandler</code>, the incoming coordinate values are automatically joined with the given <em class="italic">bound coordinate</em> values. The result is passed to the target <code class="inlineCode">VarHandle</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">viewhandle.set(segment, <span class="hljs-number">75</span>); 
System.out.println(<span class="hljs-string">"Value: "</span> + viewhandle.get(segment));
</code></pre>
    <p class="normal">Done! Now, you know <a id="_idIndexMarker920"/>three ways to create a <code class="inlineCode">VarHandle</code> for dereferencing a memory segment.</p>
    <h1 id="_idParaDest-368" class="heading-1">163. Streaming memory segments</h1>
    <p class="normal">Combining the<a id="_idIndexMarker921"/> Java Stream API with memory segments can be achieved via the <code class="inlineCode">elements(MemoryLayout elementLayout)</code> method. This method gets an element layout and returns a <code class="inlineCode">Stream&lt;MemorySegment&gt;</code>, which is a sequential stream over disjointed slices in this segment. The stream size matches the size of the specified layout.</p>
    <p class="normal">Let’s consider the following memory layout:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SequenceLayout</span> <span class="hljs-type">xy</span> = MemoryLayout
  .sequenceLayout(<span class="hljs-number">2</span>, MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName(<span class="hljs-string">"x"</span>),
    ValueLayout.JAVA_INT.withName(<span class="hljs-string">"y"</span>)));
</code></pre>
    <p class="normal">Next, we declare two <code class="inlineCode">VarHandle</code> and set some data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">VarHandle</span> <span class="hljs-type">xHandle</span> = xy.varHandle(
  PathElement.sequenceElement(),
  PathElement.groupElement(<span class="hljs-string">"x"</span>));
<span class="hljs-type">VarHandle</span> <span class="hljs-type">yHandle</span> = xy.varHandle(
  PathElement.sequenceElement(), 
  PathElement.groupElement(<span class="hljs-string">"y"</span>));
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofShared()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span> <span class="hljs-operator">=</span> arena.allocate(xy);
  xHandle.set(segment, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
  yHandle.set(segment, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);
  xHandle.set(segment, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>);
  yHandle.set(segment, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>);
  <span class="hljs-comment">// stream operations</span>
}
</code></pre>
    <p class="normal">Let’s assume that we <a id="_idIndexMarker922"/>want to sum up all data. For this, we can do the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> segment.elements(xy)
  .map(t -&gt; t.toArray(ValueLayout.JAVA_INT))
  .flatMapToInt(t -&gt; Arrays.stream(t))
  .sum();
</code></pre>
    <p class="normal">Or, we can simply pass the proper layout and even empower parallel processing:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> segment.elements(ValueLayout.JAVA_INT)
  .parallel()
  .mapToInt(s -&gt; s.get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>))
  .sum();
</code></pre>
    <p class="normal">Both approaches return 28 = 5 + 9 + 6 + 8.</p>
    <p class="normal">How about summing only the values from the first (<em class="italic">x</em>, <em class="italic">y</em>) pair? For this, we have to slice the layout corresponding to the first (<em class="italic">x</em>, <em class="italic">y</em>) pair via <code class="inlineCode">sliceHandle()</code> – we introduced this method in <em class="italic">Problem 151</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MethodHandle</span> <span class="hljs-variable">xyHandle</span>
  = xy.sliceHandle(PathElement.sequenceElement());
</code></pre>
    <p class="normal">Next, we slice the segment of the first (<em class="italic">x</em>, <em class="italic">y</em>) pair (if we replace 0 with 1, then we obtain the segment of the second (<em class="italic">x</em>, <em class="italic">y</em>) pair):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-variable">subsegment</span> 
<span class="hljs-operator">  =</span> (MemorySegment) xyHandle.invoke(segment, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">And, we use it to calculate the needed sum:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> subsegment.elements(ValueLayout.JAVA_INT)
  .parallel()
  .mapToInt(s -&gt; s.get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>))
  .sum();
</code></pre>
    <p class="normal">The result is clear, 14 = 5 + 9.</p>
    <p class="normal">How about summing <em class="italic">y</em> from the first pair with the second pair (<em class="italic">x</em>, <em class="italic">y</em>)? For this, we can slice the proper segment via <code class="inlineCode">asSlice()</code> – we introduced this method in <em class="italic">Problem 156</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">var</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> segment.elements(xy)
  .parallel()
  .map(t -&gt; t.asSlice(<span class="hljs-number">4</span>).toArray(ValueLayout.JAVA_INT)) 
  .flatMapToInt(t -&gt; Arrays.stream(t))
  .sum();
</code></pre>
    <p class="normal">The <code class="inlineCode">asSlice(4)</code> simply skips the first <em class="italic">x</em> since this is stored at offset 0 and consumes 4 bytes. From offset 4 to the end, we have the first <em class="italic">y</em>, and the second pair (<em class="italic">x</em>, <em class="italic">y</em>). So, the result is 23 = 9 + 6 + 8.</p>
    <p class="normal">Notice that, this time, we have used a shared arena (<code class="inlineCode">Arena.ofShared()</code>). This is needed for parallel computations <a id="_idIndexMarker923"/>since the segment should be shared between multiple threads.</p>
    <p class="normal">Done! Feel free to challenge yourself to solve more such scenarios.</p>
    <h1 id="_idParaDest-369" class="heading-1">164. Tackling mapped memory segments</h1>
    <p class="normal">We know<a id="_idIndexMarker924"/> that a computer has limited physical memory, referred to as RAM. Common sense, though, tells us that we cannot allocate a memory segment larger than the available RAM (this should lead to an out-of-memory error). But this is not quite true! Here is where <em class="italic">mapped memory segments</em> come into the discussion.</p>
    <p class="normal">The mapped memory segment represents virtual memory and can be huge (gigabytes, terabytes, or whatever you may think of). This virtual memory is actually memory mapped by files or shortly <em class="italic">memory-mapped files</em> (a file can be from a regular file to any other kind of file descriptor).</p>
    <p class="normal">Obviously, at any time, only a part of the virtual memory lives in the real memory. This is why we can allocate terabytes of virtual memory on a laptop with much less real RAM. Practically, a portion of missing mapped memory is loaded on demand in the real RAM. While loading, the process operating on this memory is temporarily suspended.</p>
    <p class="normal">The goal of mapped memory files is to drastically reduce the I/O operations. The standard read/write operations rely on copying data into buffers, while mapped files put the file data directly into the process address space. This is much faster and sharable across processes.</p>
    <p class="normal">In Java, we can set a mapped memory file via the <code class="inlineCode">java.nio.channels.FileChannel</code> API, more precisely, via the <code class="inlineCode">map(MapMode mode, long offset, long size, Arena arena)</code> method. Here is an example of setting a mapped memory file of 1 MB and writing/reading some text into it (feel free to try it on your machine for a file that is 1 GB (1,073,741,824 bytes) or larger:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> FileChannel.open(
  Path.of(<span class="hljs-string">"readme.txt"</span>), CREATE, READ, WRITE);   
  <span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
    <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span>
      <span class="hljs-operator">=</span> file.map(READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">1048576</span>, arena);  
    <span class="hljs-comment">// write the data</span>
    segment.setUtf8String(<span class="hljs-number">0</span>, <span class="hljs-string">"This is a readme file ..."</span>);
    segment.setUtf8String(<span class="hljs-number">1048576</span>/<span class="hljs-number">2</span>, 
      <span class="hljs-string">"Here is the middle of the file ..."</span>);
    segment.setUtf8String(<span class="hljs-number">1048576</span>-<span class="hljs-number">32</span>, 
      <span class="hljs-string">"Here is the end of the file ..."</span>);
    <span class="hljs-comment">// read some data</span>
    System.out.println(segment.getUtf8String(<span class="hljs-number">1048576</span>/<span class="hljs-number">2</span>));
}
</code></pre>
    <p class="normal">When a file<a id="_idIndexMarker925"/> contains a significant number of empty bytes (so-called holes, <code class="inlineCode">\x00</code>) it becomes a good candidate to become a <em class="italic">sparse</em> file. In a sparse file, these holes are no longer kept on the storage device, so they no longer consume physical memory. This is an attempt at using memory more efficiently and stops consuming physical memory with zero-byte blocks. Each operating system has its own way of handling sparse files, but generally speaking, the zero-byte blocks are simply reduced to some meaningful metadata useful for dynamically generating them. For more details and a useful diagram, consider this <a id="_idIndexMarker926"/>Wikipedia article (<a href="https://en.wikipedia.org/wiki/Sparse_file"><span class="url">https://en.wikipedia.org/wiki/Sparse_file</span></a>).</p>
    <p class="normal">In Java, we can create a sparse file by adding the <code class="inlineCode">java.nio.file.StandardOpenOption.SPARSE</code> option to the list of options next to <code class="inlineCode">CREATE_NEW</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> FileChannel.open(
  Path.of(<span class="hljs-string">"sparse_readme.txt"</span>), 
    CREATE_NEW, SPARSE, READ, WRITE);
  <span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
   <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span>
      <span class="hljs-operator">=</span> file.map(READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">1048576</span>, arena);
    <span class="hljs-comment">// write the data </span>
    segment.setUtf8String(<span class="hljs-number">0</span>, <span class="hljs-string">"This is a readme file ..."</span>);
    segment.setUtf8String(<span class="hljs-number">1048576</span>/<span class="hljs-number">2</span>, 
      <span class="hljs-string">"Here is the middle of the file ..."</span>);
    segment.setUtf8String(<span class="hljs-number">1048576</span>-<span class="hljs-number">32</span>, 
      <span class="hljs-string">"Here is the end of the file ..."</span>);
    <span class="hljs-comment">// read some data</span>
    System.out.println(segment.getUtf8String(<span class="hljs-number">0</span>));
}
</code></pre>
    <p class="normal">Depending on your <a id="_idIndexMarker927"/>operating system (machine), you should use dedicated tools to inspect these files in detail and get a deeper insight into how they work.</p>
    <p class="normal">If you find yourself using mapped memory files quite often, then you may prefer to extend the <code class="inlineCode">Arena</code> interface and provide your own implementation starting from a simple skeleton, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MappedArena</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Arena</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String fileName;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Arena shared;
  <span class="hljs-keyword">public</span> <span class="hljs-title">MappedArena</span><span class="hljs-params">(String fileName)</span> {
    <span class="hljs-built_in">this</span>.fileName = fileName;
    <span class="hljs-built_in">this</span>.shared = Arena.ofShared();
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> MemorySegment<span class="hljs-title"> allocate</span><span class="hljs-params">(</span>
<span class="hljs-params">    </span><span class="hljs-type">long</span><span class="hljs-params"> byteSize, </span><span class="hljs-type">long</span><span class="hljs-params"> byteAlignment)</span> {
    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> FileChannel.open(
      Path.of(fileName + System.currentTimeMillis() + <span class="hljs-string">".txt"</span>),
        CREATE_NEW, SPARSE, READ, WRITE)) {
      <span class="hljs-keyword">return</span> file.map(
        READ_WRITE, <span class="hljs-number">0</span>, byteSize, shared);
    } <span class="hljs-keyword">catch</span> (IOException e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(e);
    }
  }
  <span class="hljs-comment">// more overridden methods</span>
}
</code></pre>
    <p class="normal">Using the <code class="inlineCode">MappedArena</code> is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MappedArena</span>(<span class="hljs-string">"readme"</span>)) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment1</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-number">100</span>);
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment2</span> <span class="hljs-operator">=</span> arena.allocate(<span class="hljs-number">50</span>);
  segment1.setUtf8String(<span class="hljs-number">0</span>, <span class="hljs-string">"Hello"</span>);
  segment2.setUtf8String(<span class="hljs-number">0</span>, <span class="hljs-string">"World"</span>);
  System.out.println(segment1.getUtf8String(<span class="hljs-number">0</span>) 
    + <span class="hljs-string">" "</span> + segment2.getUtf8String(<span class="hljs-number">0</span>));
}
</code></pre>
    <p class="normal">Of course, you <a id="_idIndexMarker928"/>can improve/modify this code to obtain other configurations. Maybe you want a confined arena (here, we have a shared arena), maybe you want to delete the files after the arena is closed (here, the files remain on disk, so you can inspect them), maybe you don’t need sparse files (here, we use sparse files), maybe you prefer another file name (here, we concatenate the given name with <code class="inlineCode">System.currentTimeMillis()</code> and the <code class="inlineCode">.txt</code> extension), or maybe you need to take into account byte alignment.</p>
    <h1 id="_idParaDest-370" class="heading-1">165. Introducing the Foreign Linker API</h1>
    <p class="normal">The main goal of the <a id="_idIndexMarker929"/>Foreign Linker API is to provide a robust and easy-to-use API (no need to write C/C++ code) for sustaining interoperability between the Java code and C/C++ foreign functions of native shared libraries (in the future, other programming languages will be supported via this API).</p>
    <p class="normal">The journey of calling foreign code starts with the <code class="inlineCode">java.lang.foreign.SymbolLookup</code> functional interface. This interface represents the entry point and consists of looking up the address of a given symbol in a loaded native shared library. There are three ways of doing this, as follows:</p>
    <p class="normal"><code class="inlineCode">Linker.defaultLookup()</code> – as its name suggests, <code class="inlineCode">defaultLookup()</code> represents a <em class="italic">default lookup</em> that scans and locates all the symbols of the commonly used native shared libraries depending on the current operating system:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Linker</span> <span class="hljs-variable">linker</span> <span class="hljs-operator">=</span> Linker.nativeLinker();
<span class="hljs-type">SymbolLookup</span> <span class="hljs-type">lookup</span> = linker.defaultLookup();
</code></pre>
    <p class="normal"><code class="inlineCode">SymbolLookup.loaderLookup()</code> – represents a <em class="italic">loader lookup</em> that scans and locates all the symbols in all the native shared libraries loaded in the current class loader (via <code class="inlineCode">System.loadLibrary()</code> and <code class="inlineCode">System.load()</code> based on <code class="inlineCode">java.library.path</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">System.loadLibrary(<span class="hljs-string">"fooLib"</span>); <span class="hljs-comment">// fooLib.dll is loaded here</span>
<span class="hljs-type">SymbolLookup</span> <span class="hljs-variable">lookup</span> <span class="hljs-operator">=</span> SymbolLookup.loaderLookup();
</code></pre>
    <p class="normal"><code class="inlineCode">SymbolLookup.libraryLookup(String name, Arena arena)</code> – represents a <em class="italic">library lookup</em> capable of scanning and loading in the arena scope a native shared library with the given name. It also creates a symbol lookup for all symbols in that native shared library. Alternatively, we can specify a <code class="inlineCode">Path</code> via <code class="inlineCode">SymbolLookup.libraryLookup(Path path, Arena arena)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) { 
  <span class="hljs-type">SymbolLookup</span> <span class="hljs-variable">lookup</span> <span class="hljs-operator">=</span> SymbolLookup.libraryLookup(
    libName/libPath, arena);
}
</code></pre>
    <p class="normal">If this step is successfully accomplished, then we can choose the symbol(s) corresponding to the foreign function(s) that we want to call. Finding a foreign function can be done by its name via the <code class="inlineCode">SymbolLookup.find(String name)</code> method. </p>
    <p class="normal">If the pointed method exists among the located symbols, then <code class="inlineCode">find()</code> returns a zero-length memory segment wrapped in an <code class="inlineCode">Optional (Optional&lt;MemorySegment&gt;)</code>. The <em class="italic">base address</em> of this segment points to the foreign function’s entry point:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MemorySegment</span> <span class="hljs-type">fooFunc</span> = mathLookup.find(<span class="hljs-string">"</span><span class="hljs-string">fooFunc"</span>).get();
</code></pre>
    <p class="normal">So far, we have located the native shared library and found one of its methods (<code class="inlineCode">fooFunc</code>). Next, we have to link Java code to this foreign function. This is accomplished via the <code class="inlineCode">Linker</code> API, which is based on two concepts:</p>
    <ul>
      <li class="bulletList"><em class="italic">downcall</em> – call the native code from Java code</li>
      <li class="bulletList"><em class="italic">upcall – </em>call the Java code from the native code</li>
    </ul>
    <p class="normal">These two concepts are materialized by the <code class="inlineCode">Linker</code> interface. <em class="italic">downcall</em> is mapped in two methods with the following signatures:</p>
    <pre class="programlisting code"><code class="hljs-code">MethodHandle <span class="hljs-title">downcallHandle</span>(
  FunctionDescriptor function, Linker.Option... options)
<span class="hljs-keyword">default</span> MethodHandle<span class="hljs-title"> downcallHandle</span><span class="hljs-params">(MemorySegment symbol, </span>
<span class="hljs-params">  FunctionDescriptor function, Linker.Option... options)</span>
</code></pre>
    <p class="normal">Typically, the <code class="inlineCode">default</code> method is used via the <code class="inlineCode">MemorySegment</code> obtained earlier via the <code class="inlineCode">find()</code> method, a function descriptor that describes the signature of the foreign function, and an optional set of linker options. The returned <code class="inlineCode">MethodHandle</code> is used later to invoke the foreign function via <code class="inlineCode">invoke()</code>, <code class="inlineCode">invokeExact()</code>, and so on. Via <code class="inlineCode">invoke()</code> or <code class="inlineCode">invokeExact()</code>, we pass arguments to the foreign function and access the returned result of running the foreign function (if any).</p>
    <p class="normal"><em class="italic">upcall</em> is mapped by the following method:</p>
    <pre class="programlisting code"><code class="hljs-code">MemorySegment <span class="hljs-title">upcallStub</span>(MethodHandle target, 
  FunctionDescriptor function, Arena arena)
</code></pre>
    <p class="normal">Typically, the <code class="inlineCode">target</code> argument refers to a Java method, the <code class="inlineCode">function</code> argument describes the<a id="_idIndexMarker930"/> Java method signature, and the <code class="inlineCode">arena</code> argument represents the arena associated with the returned <code class="inlineCode">MemorySegment</code>. This <code class="inlineCode">MemorySegment</code> is passed later as an argument of the Java code that invokes (<code class="inlineCode">invoke()</code>/<code class="inlineCode">invokeExact()</code>) a <em class="italic">downcall</em> method handle. As a consequence, this <code class="inlineCode">MemorySegment</code> acts as a function pointer.</p>
    <p class="normal">If we glue this knowledge together, then we can write a classical example of calling the <code class="inlineCode">getpid()</code> method (on Windows 10, <code class="inlineCode">_getpid()</code> – <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid"><span class="url">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid</span></a>) as follows (consider reading the meaningful comments to get insight on each step):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// get the Linker of the underlying native platform </span>
<span class="hljs-comment">// (operating system + processor that runs the JVM)</span>
<span class="hljs-type">Linker</span> <span class="hljs-variable">linker</span> <span class="hljs-operator">=</span> Linker.nativeLinker();
<span class="hljs-comment">// "_getpid" is part of the Universal C Runtime (UCRT) Library</span>
<span class="hljs-type">SymbolLookup</span> <span class="hljs-type">libLookup</span> = linker.defaultLookup();
<span class="hljs-comment">// find the "_getpid" foreign function</span>
<span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentGetpid</span> = libLookup.find(<span class="hljs-string">"_getpid"</span>).get();
<span class="hljs-comment">// create a method handle for "_getpid"</span>
<span class="hljs-type">MethodHandle</span> <span class="hljs-type">func</span> = linker.downcallHandle(segmentGetpid,
  FunctionDescriptor.of(ValueLayout.JAVA_INT));
<span class="hljs-comment">// invoke the foreign function, "_getpid" and get the result</span>
<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) func.invokeExact(); 
System.out.println(result);
</code></pre>
    <p class="normal">This code was<a id="_idIndexMarker931"/> tested on Windows 10. If you run a different operating system, then consider informing yourself about this foreign function to adjust the code accordingly.</p>
    <h1 id="_idParaDest-371" class="heading-1">166. Calling the sumTwoInt() foreign function</h1>
    <p class="normal">Do you<a id="_idIndexMarker932"/> remember the <code class="inlineCode">sumTwoInt()</code> function? We have defined this C function in a native shared library named <code class="inlineCode">math.dll</code> (check <em class="italic">Problems 144</em>, <em class="italic">145</em>, and <em class="italic">146</em>). Let’s assume that we have placed the <code class="inlineCode">math.dll</code> library in the project folder under the <code class="inlineCode">lib/cpp</code> path.</p>
    <p class="normal">We can call this foreign function in almost the same manner as we’ve called <code class="inlineCode">_getpid()</code>. Since <code class="inlineCode">math.dll</code> is a user-defined library that is not commonly used, it cannot be loaded via <code class="inlineCode">defaultLookup()</code>. The solution is to explicitly load the library from the <code class="inlineCode">lib/cpp</code> path, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Linker</span> <span class="hljs-variable">linker</span> <span class="hljs-operator">=</span> Linker.nativeLinker();
<span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"lib/cpp/math.dll"</span>);
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) { 
  <span class="hljs-type">SymbolLookup</span> <span class="hljs-type">libLookup</span> = SymbolLookup.libraryLookup(
    path, arena);
  ...
</code></pre>
    <p class="normal">Next, we have to find in <code class="inlineCode">math.dll</code> the foreign function by name. If your C compiler (for instance, G++) has applied the <em class="italic">mangling</em> (or <em class="italic">name decoration</em>) technique, then <code class="inlineCode">sumTwoInt</code> will have been renamed in the library to something else (here, <code class="inlineCode">_Z9sumTwoIntii</code>) and that name should be used:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentSumTwoInt</span>
    = libLookup.find(<span class="hljs-string">"_Z9sumTwoIntii"</span>).get();
  ...
</code></pre>
    <p class="normal">Next, we define the <code class="inlineCode">MethodHandle</code> for this <em class="italic">downcall</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">  MethodHandle</span> <span class="hljs-type">func</span> = linker.downcallHandle(segmentSumTwoInt,
  FunctionDescriptor.of(ValueLayout.JAVA_LONG, 
    ValueLayout.JAVA_INT, ValueLayout.JAVA_INT));
  ...
</code></pre>
    <p class="normal">Finally, we can invoke the foreign function and get the result:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">  long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) func.invokeExact(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
  System.out.println(result);
}
</code></pre>
    <p class="normal">The result <a id="_idIndexMarker933"/>should be 12. Check out the complete code in the bundled code.</p>
    <h1 id="_idParaDest-372" class="heading-1">167. Calling the modf() foreign function</h1>
    <p class="normal">Let’s consider that we<a id="_idIndexMarker934"/> want to call the <code class="inlineCode">modf()</code> foreign function. This function is part of the C standard library with the following syntax (<a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl"><span class="url">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl</span></a>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">double</span><span class="hljs-function"> </span><span class="hljs-title">modf</span><span class="hljs-function">(</span><span class="hljs-built_in">double</span><span class="hljs-params"> x, </span><span class="hljs-built_in">double</span><span class="hljs-params"> *intptr</span><span class="hljs-function">)</span>;
</code></pre>
    <p class="normal">This method gets a <code class="inlineCode">double x</code> and returns the signed fractional part of <code class="inlineCode">x</code>. The <code class="inlineCode">intptr</code> is a pointer argument used to point to the memory address where the integer part should be stored as a <code class="inlineCode">double</code> value.</p>
    <p class="normal">Since this method is part of UCRT, it can be found via <code class="inlineCode">defaultLookup()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Linker</span> <span class="hljs-variable">linker</span> <span class="hljs-operator">=</span> Linker.nativeLinker();
<span class="hljs-type">SymbolLookup</span> <span class="hljs-type">libLookup</span> = linker.defaultLookup();
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentModf</span> = libLookup.find(<span class="hljs-string">"modf"</span>).get();
  ...
</code></pre>
    <p class="normal">Nothing new so far! Next, we need to define the proper <code class="inlineCode">MethodHandle</code>. Because the second argument of <code class="inlineCode">modf()</code> is a pointer, we need to specify a value layout of type <code class="inlineCode">ADDRESS</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">MethodHandle</span> <span class="hljs-type">func</span> = linker.downcallHandle(segmentModf,   
    FunctionDescriptor.of(ValueLayout.JAVA_DOUBLE, 
      ValueLayout.JAVA_DOUBLE, ValueLayout.ADDRESS));
  ...
</code></pre>
    <p class="normal">If we could invoke the foreign function at this point, we could collect the fractional part of the given <code class="inlineCode">x</code>, but we cannot obtain the integer part. We have to create a memory segment and pass this memory segment to the foreign function at invocation time. The foreign function will write the integer part in this memory segment, which should be capable of <a id="_idIndexMarker935"/>storing a <code class="inlineCode">double</code> value:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentIntptr</span>
    = arena.allocate(ValueLayout.JAVA_DOUBLE);
  <span class="hljs-type">double</span> <span class="hljs-variable">fractional</span>
    <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>) func.invokeExact(x, segmentIntptr);
  ...
</code></pre>
    <p class="normal">The fractional part is returned by the foreign key. The integer part is read from the memory segment at offset 0:</p>
    <pre class="programlisting code"><code class="hljs-code">  System.out.println(<span class="hljs-string">"Fractional part: "</span> + fractional 
    + <span class="hljs-string">" Integer part: "</span> + segmentIntptr.get(
     ValueLayout.JAVA_DOUBLE, <span class="hljs-number">0</span>));
}
</code></pre>
    <p class="normal">If <code class="inlineCode">x</code> = 89.76655, then the output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">Fractional part: 0.7665499999999952 Integer part: 89.0
</code></pre>
    <p class="normal">Challenge <a id="_idIndexMarker936"/>yourself to adapt this code to call <code class="inlineCode">modff()</code> and <code class="inlineCode">modfl()</code> foreign functions.</p>
    <h1 id="_idParaDest-373" class="heading-1">168. Calling the strcat() foreign function</h1>
    <p class="normal">The <code class="inlineCode">strcat()</code> foreign function <a id="_idIndexMarker937"/>is part of the C standard library and has the following signature (<a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat"><span class="url">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat</span></a>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">char</span> *strcat(<span class="hljs-type">char</span> *strDestination, const <span class="hljs-type">char</span> *strSource);
</code></pre>
    <p class="normal">This function appends the <code class="inlineCode">strSource</code> at the end of the <code class="inlineCode">strDestination</code>. The function doesn’t get these strings. It gets two pointers to these strings (so, two <code class="inlineCode">ADDRESS</code>) and doesn’t return a value, so we rely on <code class="inlineCode">FunctionDescriptor.ofVoid()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Linker</span> <span class="hljs-variable">linker</span> <span class="hljs-operator">=</span> Linker.nativeLinker();
<span class="hljs-type">SymbolLookup</span> <span class="hljs-type">libLookup</span> = linker.defaultLookup();
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentStrcat</span>
    = libLookup.find(<span class="hljs-string">"strcat"</span>).get();
  <span class="hljs-type">MethodHandle</span> <span class="hljs-type">func</span> = linker.downcallHandle(
    segmentStrcat, FunctionDescriptor.ofVoid(
      ValueLayout.ADDRESS, ValueLayout.ADDRESS));
  ...
</code></pre>
    <p class="normal">Since the arguments of <code class="inlineCode">strcat()</code> are two pointers (<code class="inlineCode">ADDRESS</code>), we have to create two memory segments and set the strings accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">String</span> <span class="hljs-variable">strDestination</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello "</span>;
  <span class="hljs-type">String</span> <span class="hljs-variable">strSource</span> <span class="hljs-operator">=</span> <span class="hljs-string">"World"</span>;
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentStrSource</span>
    = arena.allocate(strSource.length() + <span class="hljs-number">1</span>);
  segmentStrSource.setUtf8String(<span class="hljs-number">0</span>, strSource);
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentStrDestination</span> = arena.allocate(
    strSource.length() + <span class="hljs-number">1</span> + strDestination.length() + <span class="hljs-number">1</span>);
  segmentStrDestination.setUtf8String(<span class="hljs-number">0</span>, strDestination);
  ...
</code></pre>
    <p class="normal">Notice the size of <code class="inlineCode">segmentStrDestination</code>. Since <code class="inlineCode">strcat()</code> appends the source string (<code class="inlineCode">strSource</code>) at the end of the destination string (<code class="inlineCode">strDestination</code>), we have to prepare the size of <code class="inlineCode">segmentStrDestination</code> to fit the source string as well, so its size is <code class="inlineCode">strSource.length() + 1 + strDestination.length() + 1</code>. Next, we can invoke the foreign function as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">func.invokeExact(segmentStrDestination, segmentStrSource);
</code></pre>
    <p class="normal">Finally, we read the result from <code class="inlineCode">segmentStrDestination</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Hello World</span>
System.out.println(segmentStrDestination.getUtf8String(<span class="hljs-number">0</span>));
</code></pre>
    <p class="normal">So, the <code class="inlineCode">World</code> string <a id="_idIndexMarker938"/>was appended at the end of <code class="inlineCode">Hello</code>.</p>
    <h1 id="_idParaDest-374" class="heading-1">169. Calling the bsearch() foreign function</h1>
    <p class="normal">The <code class="inlineCode">bsearch()</code> foreign<a id="_idIndexMarker939"/> function is part of the C standard library and has the following signature (<a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch"><span class="url">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch</span></a>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span> *bsearch(
  const <span class="hljs-keyword">void</span> *key,
  const <span class="hljs-keyword">void</span> *base,
  size_t num,
  size_t width,
  <span class="hljs-type">int</span> ( __cdecl *compare ) (
    const <span class="hljs-keyword">void</span> *key, const <span class="hljs-keyword">void</span> *datum)
);
</code></pre>
    <p class="normal">In a nutshell, this method gets pointers to a key, a sorted array (<code class="inlineCode">base</code>), and a comparator. Its goal is to use the given comparator to perform a binary search of the given <code class="inlineCode">key</code> in the given array. More precisely, <code class="inlineCode">bsearch()</code> gets a pointer to the <code class="inlineCode">key</code>, a pointer to the array, the number of elements in the array (<code class="inlineCode">num</code>), the size of an element in bytes (<code class="inlineCode">width</code>), and the comparator as a callback function. </p>
    <p class="normal">The callback function gets a pointer to <code class="inlineCode">key</code> and a pointer to the current element of the array to be compared with <code class="inlineCode">key</code>. It returns the result of comparing these two elements.</p>
    <p class="normal">The <code class="inlineCode">bsearch()</code> function returns a pointer in the array pointing to the occurrence of the key. If the given key is not found, then <code class="inlineCode">bsearch()</code> returns <code class="inlineCode">NULL</code>.</p>
    <p class="normal">We can start by coding the comparator callback function as a Java method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">comparator</span><span class="hljs-params">(MemorySegment i1, MemorySegment i2)</span> {
  <span class="hljs-keyword">return</span> Integer.compare(i1.get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>),
    i2.get(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>));
}
</code></pre>
    <p class="normal">The <code class="inlineCode">i1</code> memory <a id="_idIndexMarker940"/>segment is the pointer to <code class="inlineCode">key</code>, and the <code class="inlineCode">i2</code> memory segment is the pointer to the current element of the array to be compared with <code class="inlineCode">key</code>. This method will be called by the foreign function (native code calls Java code), so an <em class="italic">upcall stub</em> should be prepared. First, we need a method handle pointing to this comparator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MethodHandle</span> <span class="hljs-type">comparatorHandle</span> = MethodHandles.lookup()
  .findStatic(Main.class, <span class="hljs-string">"comparator"</span>, MethodType.methodType(
    <span class="hljs-type">int</span>.class, MemorySegment.class, MemorySegment.class));
</code></pre>
    <p class="normal">Second, we create the <em class="italic">upcall stub</em>. For this, we need the <code class="inlineCode">Linker</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Linker</span> <span class="hljs-variable">linker</span> <span class="hljs-operator">=</span> Linker.nativeLinker();
<span class="hljs-type">SymbolLookup</span> <span class="hljs-type">libLookup</span> = linker.defaultLookup();
</code></pre>
    <p class="normal">And we are ready to use the confined arena:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">comparatorFunc</span> =   
    linker.upcallStub(comparatorHandle,
      FunctionDescriptor.of(ValueLayout.JAVA_INT,
        ValueLayout.ADDRESS.withTargetLayout(
          MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)),
        ValueLayout.ADDRESS.withTargetLayout(
          MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT))), 
      arena);
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentBsearch</span>
    = libLookup.find(<span class="hljs-string">"bsearch"</span>).get();
  <span class="hljs-type">MethodHandle</span> <span class="hljs-type">func</span> = linker.downcallHandle(
    segmentBsearch, FunctionDescriptor.of(
      ValueLayout.ADDRESS, ValueLayout.ADDRESS, 
      ValueLayout.ADDRESS, ValueLayout.JAVA_INT,
      ValueLayout.JAVA_LONG, ValueLayout.ADDRESS));
  ...
</code></pre>
    <p class="normal">Here, we have used the <code class="inlineCode">withTargetLayout()</code> method to create an <em class="italic">unbounded</em> address. The <em class="italic">unbounded </em><code class="inlineCode">ADDRESS</code> means addresses for which we don’t know the size, so it is better to ensure that enough space will be available by setting them as <em class="italic">unbounded</em>. Practically, by <a id="_idIndexMarker941"/>creating a target sequence layout without an explicit size, we obtain a native memory segment with maximal size. Next, we find the <code class="inlineCode">bsearch()</code> method and define its method handle.</p>
    <p class="normal">Next, we prepare the <code class="inlineCode">key</code> and the <code class="inlineCode">array</code> arguments as <code class="inlineCode">MemorySegment</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;
  <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>};
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> arena.allocate(
    ValueLayout.JAVA_INT, elem);
  <span class="hljs-type">MemorySegment</span> <span class="hljs-variable">array</span> 
    <span class="hljs-operator">=</span> arena.allocateArray(ValueLayout.JAVA_INT, arr);
  ...
</code></pre>
    <p class="normal">We have all the needed arguments, so we can invoke <code class="inlineCode">bsearch()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">  MemorySegment</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (MemorySegment) func.invokeExact(
    key, array, <span class="hljs-number">10</span>, ValueLayout.JAVA_INT.byteSize(), 
      comparatorFunc);
  ...
</code></pre>
    <p class="normal">Keep in mind that <code class="inlineCode">bsearch()</code> returns a pointer in the <code class="inlineCode">array</code> pointing to the first occurrence of the <code class="inlineCode">key</code>, or it returns <code class="inlineCode">NULL</code> if the given <code class="inlineCode">key</code> is not found in the given <code class="inlineCode">array</code>. If <code class="inlineCode">bsearch()</code> returned <code class="inlineCode">NULL</code>, then the result should match <code class="inlineCode">MemorySegment.NULL</code>, which is a zero-length native segment representing a <code class="inlineCode">NULL</code> address:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (result.equals(MemorySegment.NULL)) {
    System.out.println(<span class="hljs-string">"Element "</span> + elem
      + <span class="hljs-string">" not found in the given array "</span>
      + Arrays.toString(arr));
  } <span class="hljs-keyword">else</span> {
    ...
</code></pre>
    <p class="normal">Otherwise, we know that the result represents a pointer in the given <code class="inlineCode">array</code>. So, we can rely on the <code class="inlineCode">segmentOffset()</code> method (introduced in <em class="italic">Problem 149</em>) to find the offset of the result relative to <code class="inlineCode">array</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> array.segmentOffset(result);
    System.out.println(<span class="hljs-string">"Element found in the given array at </span>
<span class="hljs-string">      offset: "</span> + offset);
    System.out.println(<span class="hljs-string">"Element value: "</span>
      + array.get(ValueLayout.JAVA_INT, offset));
  }
}
</code></pre>
    <p class="normal">For <a id="_idIndexMarker942"/>our <code class="inlineCode">key</code> (14) and <code class="inlineCode">array</code>, the returned offset is 24.</p>
    <h1 id="_idParaDest-375" class="heading-1">170. Introducing Jextract</h1>
    <p class="normal">Jextract (<a href="https://github.com/openjdk/jextract"><span class="url">https://github.com/openjdk/jextract</span></a>) is a very handy tool capable of consuming<a id="_idIndexMarker943"/> the headers of <a id="_idIndexMarker944"/>native libraries (<code class="inlineCode">*.h</code> files) and producing low-level Java native bindings. Via this tool, we can save a lot of time since we can focus only on calling native code without caring about the mechanical steps of loading libraries, writing method handles, or <em class="italic">downcall</em> and <em class="italic">upcall stubs</em>.</p>
    <p class="normal">Jextract is a command-line tool that can be downloaded from <a href="https://jdk.java.net/jextract"><span class="url">https://jdk.java.net/jextract</span></a>. The main options of this tool are listed here:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">--source</code>: When we write <code class="inlineCode">jextract --source</code>, we instruct Jextract to generate from the given header file the corresponding source files without classes. When this option is omitted, Jextract will generate classes.</li>
      <li class="bulletList"><code class="inlineCode">-- output path</code>: By default, the generated files are placed in the current folder. Via this option, we can point out the path where these files should be placed.</li>
      <li class="bulletList"><code class="inlineCode">-t &lt;package&gt;</code>: By default, Jextract uses the unnamed package name. Via this option, we can specify the package name for the generated classes.</li>
      <li class="bulletList"><code class="inlineCode">-I &lt;dir&gt;</code>: Specify one or more paths that should be appended to the existing search paths. The given order is respected during the search. </li>
      <li class="bulletList"><code class="inlineCode">--dump-includes &lt;String&gt;</code>: This option allows you to filter the symbols. First, use this option to extract all symbols in a file. Next, edit the file to keep only the needed symbols. Finally, pass this file to Jextract.</li>
    </ul>
    <p class="normal">The complete list of options is available at <a href="https://github.com/openjdk/jextract"><span class="url">https://github.com/openjdk/jextract</span></a>.</p>
    <h1 id="_idParaDest-376" class="heading-1">171. Generating native binding for modf()</h1>
    <p class="normal">In <em class="italic">Problem 160</em>, we <a id="_idIndexMarker945"/>located, prepared, and called the <code class="inlineCode">modf()</code> foreign <a id="_idIndexMarker946"/>function via the Foreign Linker API. Now, let’s use Jextract to generate the native binding needed to call <code class="inlineCode">modf()</code>.</p>
    <p class="normal">For Windows, the <code class="inlineCode">modf()</code> foreign function is described in the <code class="inlineCode">math.h</code> header file. If you have installed MinGW (<a href="https://sourceforge.net/projects/mingw-w64/"><span class="url">https://sourceforge.net/projects/mingw-w64/</span></a>) for 64-bit, then this header file is available in the <code class="inlineCode">mingw64\x86_64-w64-mingw32\include</code> folder. If we want to generate the native bindings for <code class="inlineCode">math.h</code>, we can do it as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_26.png" alt="Figure 7.25.png"/></figure>
    <p class="packt_figref">Figure 7.26: Generating the native bindings from math.h</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P171_JextractAndModf&gt;
  jextract --source --output src\main\java -t c.lib.math
  -I C:\MinGW64\mingw64\x86_64-w64-mingw32\include 
  C:\MinGW64\mingw64\x86_64-w64-mingw32\include\math.h
</code></pre>
    <p class="normal">So, we generated the source files (<code class="inlineCode">--sources</code>) in the <code class="inlineCode">src\main\java</code> subfolder of the current project (<code class="inlineCode">--output</code>), in the package <code class="inlineCode">c.lib.math</code> (<code class="inlineCode">-t</code>). The <code class="inlineCode">math.h</code> is loaded from <code class="inlineCode">mingw64\x86_64-w64-mingw32\include</code>.</p>
    <p class="normal">After running this command, you’ll find in <code class="inlineCode">c.lib.math</code> the native bindings for all the symbols found in <code class="inlineCode">math.h</code>. Most probably, this is not what we want, since we’re calling only the <code class="inlineCode">modf()</code> foreign function. Filtering symbols is a two-step process. First, we generate a <em class="italic">dump</em> of all symbols, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_27.png" alt="Figure 7.26.png"/></figure>
    <p class="packt_figref">Figure 7.27: Creating a dump file containing all symbols from math.h</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P171_JextractAndModf&gt;
  jextract --dump-includes includes.txt 
  -I C:\MinGW64\mingw64\x86_64-w64-mingw32\include 
  C:\MinGW64\mingw64\x86_64-w64-mingw32\include\math.h
</code></pre>
    <p class="normal">This <a id="_idIndexMarker947"/>command will write in the project root a file <a id="_idIndexMarker948"/>named <code class="inlineCode">includes.txt</code> containing all symbols found in <code class="inlineCode">math.h</code>. The second step consists of editing this file. For instance, we have kept only the symbol for <code class="inlineCode">modf()</code>, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_28.png" alt="Figure 7.27.png"/></figure>
    <p class="packt_figref">Figure 7.28: Editing the includes.txt to keep only the needed symbols</p>
    <p class="normal">Next, we pass the edited <code class="inlineCode">includes.txt</code> to Jextract, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_29.png" alt="Figure 7.28.png"/></figure>
    <p class="packt_figref">Figure 7.29: Run Jextract with the filtered includes.txt</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P171_JextractAndModf&gt;
  jextract --source @includes.txt --output src\main\java -t c.lib.math
  -I C:\MinGW64\mingw64\x86_64-w64-mingw32\include 
  C:\MinGW64\mingw64\x86_64-w64-mingw32\include\math.h
</code></pre>
    <p class="normal">This time, in <code class="inlineCode">c.lib.math</code>, you’ll find the native bindings only for the <code class="inlineCode">modf()</code> foreign function. Take your time to inspect each of these files and see how they interact at the code level. Since we generate only the sources, we have to compile the project to obtain the classes. If you prefer to generate the classes directly via Jextract, then you can use the following command (now, the sources will not be generated, only the classes):</p>
    <figure class="mediaobject"><img src="../Images/B19665_07_30.png" alt="Figure 7.29.png"/></figure>
    <p class="packt_figref">Figure 7.30: Generating the classes of native bindings</p>
    <p class="normal">Or, as plain text:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\SBPBP\GitHub\Java-Coding-Problems-Second-Edition\Chapter07\P171_JextractAndModf&gt;
  jextract @includes.txt --output target\classes -t c.lib.math
  -I C:\MinGW64\mingw64\x86_64-w64-mingw32\include 
  C:\MinGW64\mingw64\x86_64-w64-mingw32\include\math.h
</code></pre>
    <p class="normal">Next, we can use<a id="_idIndexMarker949"/> the generated bindings in a Java application to<a id="_idIndexMarker950"/> call the <code class="inlineCode">modf()</code> function. The code is straightforward (we don’t need to write the method handle and there is no need to explicitly use <code class="inlineCode">invoke()</code>/<code class="inlineCode">invokeExact()</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">89.76655</span>;
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
  <span class="hljs-type">MemorySegment</span> <span class="hljs-type">segmentIntptr</span>
    = arena.allocate(ValueLayout.JAVA_DOUBLE);
  <span class="hljs-type">double</span> <span class="hljs-variable">fractional</span> <span class="hljs-operator">=</span> modf(x, segmentIntptr);
  System.out.println(<span class="hljs-string">"Fractional part: "</span> + fractional
    + <span class="hljs-string">" Integer part: "</span> + segmentIntptr.get(
      ValueLayout.JAVA_DOUBLE, <span class="hljs-number">0</span>));
}
</code></pre>
    <p class="normal">The <code class="inlineCode">modf()</code> function is imported from the <code class="inlineCode">c.lib.math.math_h</code> package.</p>
    <h1 id="_idParaDest-377" class="heading-1">Summary</h1>
    <p class="normal">This chapter covered 28 problems. Most of them were focused on the new Foreign (Function) Memory APIs, or Project Panama. As you saw, this API is much more intuitive and powerful than the classical approaches of using JNI, JNA, and JNR. Moreover, the Jextract tool is very handy for generating native bindings from the headers of native shared libraries and saves us a lot of mechanical work.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>