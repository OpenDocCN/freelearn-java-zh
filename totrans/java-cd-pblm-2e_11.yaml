- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: 'Concurrency ‒ Virtual Threads and Structured Concurrency: Diving Deeper'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发 - 虚拟线程和结构化并发：深入探讨
- en: This chapter includes 18 problems meant to dive deep into how *virtual threads*
    and *structured concurrency* work and how they should be used in your applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括18个问题，旨在深入探讨*虚拟线程*和*结构化并发*的工作方式以及它们应该如何在你的应用程序中使用。
- en: If you don’t have a background in concurrency in Java then I strongly recommend
    postponing this chapter until you read some good introductory coverage on this
    topic. For instance, you could try out *Chapter 10* and *Chapter 11* from *Java
    Coding Problems*, *First Edition*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有Java并发方面的背景，我强烈建议你推迟阅读本章，直到你阅读了一些关于这个主题的良好入门内容。例如，你可以尝试《Java编码问题》第一版的第10章和第11章。
- en: We start this chapter by explaining how virtual threads work internally. This
    will be helpful to help you better understand the subsequent problems about extending
    and assembling `StructuredTaskScope`, hooking `ThreadLocal` and virtual threads,
    avoiding *pinning*, solving *producer-consumer* problems, implementing an HTTP
    web server, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从解释虚拟线程的内部工作方式开始本章。这将有助于你更好地理解后续关于扩展和组装`StructuredTaskScope`、挂钩`ThreadLocal`和虚拟线程、避免*固定*、解决*生产者-消费者*问题、实现HTTP网络服务器等问题。
- en: By the end of this chapter, you’ll have comprehensive and crystal-clear knowledge
    about working with *virtual threads* and *structured concurrency*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面且清晰地了解如何使用*虚拟线程*和*结构化并发*。
- en: Problems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your advanced programming prowess in virtual
    threads and structured concurrency in Java. I strongly encourage you to give each
    problem a try before you turn to the solutions and download the example programs:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在Java虚拟线程和结构化并发方面的高级编程能力。我强烈鼓励你在查看解决方案和下载示例程序之前尝试每个问题：
- en: '**Tackling continuations**: Provide a detailed explanation of what *continuations*
    are and how they work in the context of virtual threads.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理延续（Tackling continuations）**：详细解释什么是*延续*以及它们在虚拟线程上下文中的工作方式。'
- en: '**Tracing virtual thread states and transitions**: Build a meaningful diagram
    of virtual thread states and transitions and explain it.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**追踪虚拟线程的状态和转换（Tracing virtual thread states and transitions）**：构建一个有意义的虚拟线程状态和转换图，并对其进行解释。'
- en: '**Extending StructuredTaskScope**: Explain and demonstrate the steps for extending
    the `StructuredTaskScope`. Explain why we cannot extend `ShutdownOnSuccess` and
    `ShutdownOnFailure`.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扩展StructuredTaskScope**：解释并演示扩展`StructuredTaskScope`的步骤。解释为什么我们不能扩展`ShutdownOnSuccess`和`ShutdownOnFailure`。'
- en: '**Assembling StructuredTaskScope**: Write a Java application that assembles
    (nests) multiple `StructuredTaskScope` instances.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组装StructuredTaskScope**：编写一个Java应用程序，组装（嵌套）多个`StructuredTaskScope`实例。'
- en: '**Assembling StructuredTaskScope with timeout**: Modify the application developed
    in *Problem 228* to add a timeout/deadline to the forked tasks.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用超时修改StructuredTaskScope**：修改在*问题228*中开发的应用程序，为分叉的任务添加超时/截止日期。'
- en: '**Hooking ThreadLocal and virtual threads**: Demonstrate the use of `ThreadLocal`
    and virtual threads.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂钩ThreadLocal和虚拟线程**：演示`ThreadLocal`和虚拟线程的使用。'
- en: '**Hooking ScopedValue and virtual threads**: Provide a comprehensive introduction
    with examples of the `ScopedValue` API.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂钩ScopedValue和虚拟线程**：提供一个全面的介绍，并带有`ScopedValue` API的示例。'
- en: '**Using ScopedValue and executor services**: Write a snippet of code that emphasizes
    the usage of the `ScopedValue` API in the context of executor services.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用ScopedValue和执行器服务**：编写一段代码，强调在执行器服务上下文中使用`ScopedValue` API。'
- en: '**Chaining and rebinding scoped values**: Provide a few snippets of code that
    show how scoped values can be chained and rebound.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链式和重新绑定作用域值**：提供一些代码片段，展示作用域值如何进行链式和重新绑定。'
- en: '**Using ScopedValue and StructuredTaskScope**: Write a Java application that
    highlights the usage of `ScopedValue` and `StructuredTaskScope`. Explain in your
    code where every `ScopedValue` is bound and not bound.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用ScopedValue和StructuredTaskScope**：编写一个Java应用程序，突出`ScopedValue`和`StructuredTaskScope`的使用。在代码中解释每个`ScopedValue`是如何绑定和未绑定的。'
- en: '**Using Semaphore instead of Executor**: In the context of virtual threads,
    explain the benefits and exemplify the usage of `Semaphore` instead of an executor
    (for instance, instead of `newFixedThreadPool()`).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Semaphore代替Executor**：在虚拟线程的上下文中，解释使用`Semaphore`而不是执行器（例如，而不是`newFixedThreadPool()`）的好处，并举例说明。'
- en: '**Avoiding pinning via locking**: Explain and exemplify how we can avoid pinned
    virtual threads by refactoring `synchronized` code via `ReentrantLock`.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过锁定避免固定**：解释并举例说明我们如何通过重构`synchronized`代码通过`ReentrantLock`来避免固定的虚拟线程。'
- en: '**Solving the producer-consumer problem via virtual threads**: Write a program
    that simulates, via the producer-consumer pattern, an assembly line for checking
    and packing up bulbs using multiple workers (virtual threads).'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过虚拟线程解决生产者-消费者问题**：编写一个程序，通过生产者-消费者模式模拟一个由多个工人（虚拟线程）组成的检查和包装灯泡的装配线。'
- en: '**Solving the producer-consumer problem via virtual threads (fixed via Semaphore)**:
    Adapt the application developed in *Problem 237* to use `Semaphore` instead of
    executor services.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过虚拟线程解决生产者-消费者问题（通过信号量解决）**：将*问题237*中开发的应用程序修改为使用`Semaphore`而不是执行器服务。'
- en: '**Solving the producer-consumer problem via virtual threads (increase/decrease
    consumers)**: Write a program that simulates an assembly line for checking and
    packing up bulbs using workers as needed (e.g., adapt the number of packers (increase
    or decrease them) to ingest the incoming flux produced by the checker). Use virtual
    threads and `Semaphore`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过虚拟线程解决生产者-消费者问题（增加/减少消费者）**：编写一个程序，模拟一个检查和包装灯泡的装配线，根据需要使用工人（例如，调整包装工的数量（增加或减少）以适应检查器产生的输入流）。使用虚拟线程和`Semaphore`。'
- en: '**Implementing an HTTP web server on top of virtual threads**: Rely on Java
    `HttpServer` to write a simple HTTP web server implementation capable of supporting
    platform threads, virtual threads, and locking (for simulating a database connection
    pool).'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在虚拟线程之上实现HTTP网络服务器**：依靠Java `HttpServer`编写一个简单的HTTP网络服务器实现，能够支持平台线程、虚拟线程和锁定（用于模拟数据库连接池）。'
- en: '**Hooking CompletableFuture and virtual threads**: Demonstrate the usage of
    `CompletableFuture` and virtual threads to solve asynchronous tasks.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂钩CompletableFuture和虚拟线程**：演示如何使用`CompletableFuture`和虚拟线程来解决异步任务。'
- en: '**Signaling virtual threads via wait() and notify()**: Write several examples
    that use `wait()` and `notify()` to coordinate access to resources (objects) via
    virtual threads. Demonstrate the good signal and missed signal scenarios.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过wait()和notify()信号虚拟线程**：编写几个示例，使用`wait()`和`notify()`通过虚拟线程协调对资源（对象）的访问。演示良好的信号和错过信号的情景。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter11).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述了前面问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节并实验程序，请访问[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter11)。
- en: 225\. Tackling continuations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 225. 处理连续
- en: 'The concept that sits behind virtual threads is known as *delimited continuations*
    or simply *continuations*. This concept is used internally by the JVM in the following
    piece of code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程背后的概念被称为*分界连续**或简单地称为*连续**。这个概念在以下代码片段中被JVM内部使用：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code, we create and start five virtual threads but we only log information
    about one thread (thread #22 – of course, the id value may vary among executions).
    So, the output will be as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了五个虚拟线程并启动了它们，但我们只记录了一个线程的信息（线程#22 – 当然，ID值可能在不同的执行中有所不同）。因此，输出将如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Thread #22 has started running on *worker-1*, but after the blocking operation
    (`sleep(1000)`), it continues to run on *worker-4*. Behind this *thread context
    switching*, we have the so-called *continuations*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 线程#22已经开始在*worker-1*上运行，但在阻塞操作（`sleep(1000)`）之后，它继续在*worker-4*上运行。在这所谓的*线程上下文切换*背后，我们有所谓的*连续**。
- en: Basically, the behavior of *continuations* can easily be explained via a popular
    debugger use case. When we debug the code, we set a breakpoint and run the code.
    When the flow hits this breakpoint, the execution freezes and we can inspect the
    current status of the application. Later on, when we’ve done the inspection, we
    continue running the code from this breakpoint forward. The debugger knows how
    to resume the execution from where it was left off (frozen). So, the execution
    continues until it hits the end of the application or until another breakpoint
    is encountered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，*延续*的行为可以通过一个流行的调试器用例轻松解释。当我们调试代码时，我们会设置一个断点并运行代码。当执行流程遇到这个断点时，执行会冻结，我们可以检查应用程序的当前状态。稍后，当我们完成检查后，我们可以从这个断点继续运行代码。调试器知道如何从暂停的地方（冻结状态）恢复执行。因此，执行会继续，直到遇到应用程序的末尾或遇到另一个断点。
- en: Briefly, virtual threads follow the same behavior. A virtual thread is mounted
    on a platform thread (*worker-x*) and starts running. When the execution hits
    a blocking operation (for instance, a `sleep()` call), then the virtual thread
    is unmounted from its worker. Later on, after the blocking operation ends, the
    thread execution is resumed by scheduling and mounting it on a platform thread
    (same worker, *worker-x*, or another *worker-y*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，虚拟线程遵循相同的行为。虚拟线程被挂载在平台线程（*worker-x*）上并开始运行。当执行遇到一个阻塞操作（例如，一个`sleep()`调用）时，虚拟线程就会从其工作线程上卸载。稍后，在阻塞操作结束后，通过调度和将其挂载在平台线程（相同的worker，*worker-x*，或另一个*worker-y*）上，线程执行得以恢复。
- en: Introducing continuations
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍延续
- en: Going deeper, we have to introduce *subroutines* and *coroutines*. Subroutines
    are functions that can be called and get back a response, while coroutines are
    *cooperating subroutines* that run at the same time and talk to each other like
    in a human conversation. Exactly like how two people talk to each other, coroutines
    set up a conversational state via two subroutines that are talking to each other.
    Via this paradigm, an application can perform some tasks, do nothing for a while,
    and then perform more tasks later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨，我们必须介绍*子程序*和*协程*。子程序是可以被调用并返回响应的函数，而协程是*协作子程序*，它们同时运行并像人类对话一样相互交谈。就像两个人交谈一样，协程通过两个相互交谈的子程序设置对话状态。通过这种范式，应用程序可以执行一些任务，然后一段时间什么也不做，稍后再执行更多任务。
- en: But, how can coroutines remember the data involved in the conversations? The
    short answer is *continuations*. Continuations are data structures capable of
    carrying data (the conversational state) between coroutines. They can resume processing
    from where it was left off.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，协程如何记住对话中涉及的数据呢？简短的答案是*延续*。延续是能够携带数据（对话状态）在协程之间传递的数据结构。它们可以从离开的地方恢复处理。
- en: Virtual threads take advantage of continuations by being capable of doing some
    work, then unmounting, and, later on, resuming from where they left off.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程通过能够做一些工作，然后卸载，稍后再从离开的地方恢复，利用了延续。
- en: 'Project Loom provides the API for working with continuations as an internal
    API, so it is not meant to be used directly in applications (we shouldn’t try
    to use this low-level API unless our goal is to write some higher-level API (libraries)
    on top of it). However, this API relies on two main classes and three methods.
    As classes, we have the `ContinuationScope`, which is the scope for handling nested
    `Continuation` instances. As methods, we have:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Project Loom提供了一个API来作为内部API处理延续，因此它不打算直接在应用程序中使用（除非我们的目标是编写一些更高层次的API（库）），我们不应该尝试使用这个低级API，除非我们的目标是编写一些更高层次的API（库）。然而，这个API依赖于两个主要类和三个方法。作为类，我们有`ContinuationScope`，它是处理嵌套`Continuation`实例的作用域。作为方法，我们有：
- en: '`run()` – run a continuation from where it was left off'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()` – 从离开的地方运行延续'
- en: '`yield()` – freeze (suspend) the continuation at this point and give control
    to the continuation’s caller (`run()` will be able to resume the execution from
    here)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield()` – 在此点冻结（挂起）延续并交出控制权给延续的调用者（`run()`将能够从这里恢复执行）'
- en: '`isDone()` – test if the current continuation is complete'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDone()` – 测试当前延续是否完成'
- en: So, under a `ContinuationScope` umbrella, we can have multiple nested continuations
    that set up a conversational state via `run()`, `yield()`, and `isDone()`. For
    virtual threads, there is a single `ContinuationScope` named `VTHREAD_SCOPE`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`ContinuationScope`的伞下，我们可以有多个嵌套的延续，通过`run()`、`yield()`和`isDone()`设置对话状态。对于虚拟线程，有一个名为`VTHREAD_SCOPE`的单个`ContinuationScope`。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since we call `continuation.run()`, this code will output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们调用了`continuation.run()`，这段代码将输出：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is quite straightforward. Next, let’s suspend the continuation via `yield()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。接下来，让我们通过 `yield()` 暂停延续：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At the moment, the output is the same:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，输出结果相同：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Practically, when we call the `yield()` method, the continuation is suspended
    and control is given to the caller. We can easily see this by adding some logs
    after calling the `run()` method as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当我们调用 `yield()` 方法时，延续被挂起，并将控制权交给调用者。我们可以通过在调用 `run()` 方法后添加一些日志来轻松地看到这一点，如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the output will be:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出将变为：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, the `logger.info("Continuation keeps running ...");` code line
    was not executed. The `yield()` method has frozen the execution before this line
    and returned the control to the caller. In order to resume the continuation from
    where it was left off, we have to call `run()` again:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`logger.info("Continuation keeps running ...");` 这行代码没有执行。`yield()` 方法在这一点上冻结了执行并将控制权返回给调用者。为了从上次停止的地方恢复延续，我们必须再次调用
    `run()`：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time, the output will be as follows (you can check if the continuation
    is done via `isDone()`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出将如下（您可以通过 `isDone()` 检查延续是否完成）：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, when we call `run()` again, the execution is resumed from where
    it was left off, not from the beginning. This is how continuations work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们再次调用 `run()` 时，执行从上次停止的地方恢复，而不是从头开始。这就是延续的工作方式。
- en: Continuations and virtual threads
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延续和虚拟线程
- en: 'Now, let’s see how virtual threads and `sleep()` work via continuations in
    our example. Our virtual thread (#22) starts its journey by logging a simple message.
    Afterward, it hits the `Thread.sleep(1000);` code line, as in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过示例中的延续来了解虚拟线程和 `sleep()` 的工作方式。我们的虚拟线程 (#22) 通过记录一条简单消息开始其旅程。之后，它触发了
    `Thread.sleep(1000);` 代码行，如下面的图所示：
- en: '![Figure 11.1.png](img/B19665_11_01.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1.png](img/B19665_11_01.png)'
- en: 'Figure 11.1: The virtual thread #22 running on worker-1'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11.1：虚拟线程 #22 在 *worker-1* 上运行'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, if the thread that has called `sleep()` is a virtual thread, then the code
    simply calls the internal `sleepNanos()` method from the `VirtualThread` class.
    The relevant code that we are interested in is the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果调用 `sleep()` 的线程是虚拟线程，那么代码将简单地从 `VirtualThread` 类调用内部的 `sleepNanos()` 方法。我们感兴趣的代码如下：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, here the code can call the `tryYield()` method (if `nanos` is 0) or the
    `parkNanos()` method. If `tryYield()` is called, then the thread state is set
    as `YIELDING`. On the other hand, if `parkNanos()` is called, then the thread
    state is set as `PARKING`. In both cases (via `tryYield()` or `parkNanos()`),
    the execution hits the `yieldContinuation()`, which is the climax of our journey:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，代码可以调用 `tryYield()` 方法（如果 `nanos` 为 0）或 `parkNanos()` 方法。如果调用 `tryYield()`，则线程状态设置为
    `YIELDING`。另一方面，如果调用 `parkNanos()`，则线程状态设置为 `PARKING`。在这两种情况下（通过 `tryYield()`
    或 `parkNanos()`），执行将遇到 `yieldContinuation()`，这是我们旅程的顶点：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, here the virtual thread is unmounted, and `yield()` is called.
    So, the virtual thread stack is copied into the heap and the thread is unmounted
    from the carrier thread (it becomes `PARKED`). We can see this via the following
    diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里虚拟线程被卸载，并调用了 `yield()`。因此，虚拟线程栈被复制到堆中，线程从承载线程（变为 `PARKED`）卸载。我们可以通过以下图来查看这一点：
- en: '![Figure 11.2.png](img/B19665_11_02.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2.png](img/B19665_11_02.png)'
- en: 'Figure 11.2: The virtual thread #22 is unmounted and moved to the heap'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11.2：虚拟线程 #22 被卸载并移动到堆中'
- en: 'This scenario takes place for any blocking operation, not just for `sleep()`.
    Once virtual thread #22 is uncounted, *worker-1* is ready to serve another virtual
    thread or do some other processing.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '这种场景适用于任何阻塞操作，而不仅仅是`sleep()`。一旦虚拟线程 #22 被释放，*worker-1* 就可以准备为另一个虚拟线程提供服务或执行其他处理。'
- en: 'After the blocking operation finishes (here, `sleep(1000)`), the `private`
    method `runContinuation()` from the `VirtualThread` class is called and the execution
    of #22 is resumed. As you can see in the following diagram, #22 is mounted now
    on *worker-4* since *worker-1* is not available (it has to execute some hypothetical
    virtual thread, #41).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '在阻塞操作完成（这里，`sleep(1000)`）后，`VirtualThread` 类的 `private` 方法 `runContinuation()`
    被调用，并且 #22 的执行被恢复。如您在以下图中所见，#22 现在在 *worker-4* 上运行，因为 *worker-1* 不可用（它必须执行一些假设的虚拟线程，#41）。'
- en: '![Figure 11.3.png](img/B19665_11_03.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3.png](img/B19665_11_03.png)'
- en: 'Figure 11.3: The execution of virtual thread #22 is resumed on worker-4'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11.3：虚拟线程 #22 在 *worker-4* 上恢复执行'
- en: The execution continues with the second logging instruction and terminates.
    This is how continuations and virtual threads work internally to sustain a massive
    throughput.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行继续到第二个日志指令并终止。这就是连续性和虚拟线程如何在内部维持大量吞吐量的工作方式。
- en: 226\. Tracing virtual thread states and transitions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 226. 追踪虚拟线程的状态和转换
- en: 'As you know, a thread can be in one of the following states: `NEW`, `RUNNABLE`,
    `BLOCKED`, `WAITING`, `TIMED_WAITING`, or `TERMINATED`. These states are elements
    of the `State` enum and are exposed via the `Thread.currentThread().getState()`
    call. These states are valid for platform threads and for virtual threads as well
    and we can use them in our applications. (If you’re unfamiliar with this, you
    can find more details about it in *Java Coding Problems*, *First Edition*, *Chapter
    10*, *Problem 199.*)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，一个线程可以处于以下状态之一：`NEW`、`RUNNABLE`、`BLOCKED`、`WAITING`、`TIMED_WAITING`或`TERMINATED`。这些状态是`State`枚举的元素，并且可以通过`Thread.currentThread().getState()`调用公开。这些状态对平台线程和虚拟线程都有效，我们可以在我们的应用程序中使用它们。（如果你不熟悉这一点，你可以在*Java编码问题*，第一版，第10章，问题199中找到更多详细信息。）
- en: 'However, internally speaking, a virtual thread works on a state transition
    model, as shown in the following figure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从内部来说，虚拟线程是在状态转换模型上工作的，如下面的图所示：
- en: '![](img/B19665_11_04.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19665_11_04.png)'
- en: 'Figure 11.4: Virtual thread state transitions'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：虚拟线程状态转换
- en: These states are declared in the `VirtualThread` class as `private static final
    int`. So, they are not public. However, they are essential for understanding the
    lifecycle of a virtual thread, so let’s briefly attempt to trace a virtual thread’s
    states during its lifetime.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态在`VirtualThread`类中以`private static final int`的形式声明。因此，它们不是公开的。然而，它们对于理解虚拟线程的生命周期至关重要，所以让我们简要地尝试追踪虚拟线程在其生命周期中的状态。
- en: NEW
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NEW
- en: 'When a virtual thread is created (for instance, via the `unstarted()` method),
    it is in the `NEW` state. In this state, the thread is not mounted and not even
    started. However, at that moment, JVM calls the constructor of the `VirtualThread`
    listed here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当虚拟线程被创建（例如，通过`unstarted()`方法）时，它处于`NEW`状态。在这个状态下，线程尚未挂载，甚至尚未启动。然而，在那个时刻，JVM调用这里列出的`VirtualThread`的构造函数：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, this constructor is responsible for choosing the scheduler to create a `Continuation`
    (which is a `VThreadContinuation` object that stores the information of what has
    to be run as a `task`) and prepare the `runContinuation private` field, which
    is a `Runnable` used to run the `Continuation` when the virtual thread is started.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个构造函数负责选择调度器来创建一个`Continuation`（这是一个存储要作为`task`运行的`VThreadContinuation`对象）并准备`runContinuation
    private`字段，这是一个`Runnable`，用于在虚拟线程启动时运行`Continuation`。
- en: STARTED
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STARTED
- en: 'A virtual thread passes from `NEW` to `STARTED` when we call the `start()`
    method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`start()`方法时，虚拟线程从`NEW`状态转换为`STARTED`：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Moreover, at the moment, the `runContinuation` runnable is scheduled on the
    virtual thread scheduler via `submitRunContinuation()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在那个时刻，`runContinuation`可运行对象通过`submitRunContinuation()`在虚拟线程调度器上安排。
- en: RUNNING
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行中
- en: 'The `runContinuation` runnable moves the virtual thread state from `STARTED`
    to `RUNNING` and calls `cont.run()`. The virtual thread is mounted (it could be
    for the first time or just a subsequent mounting that resumes the execution from
    where it was left off) on a platform thread and starts running:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`runContinuation`可运行对象将虚拟线程的状态从`STARTED`移动到`RUNNING`并调用`cont.run()`。虚拟线程被挂载（可能是第一次挂载，或者只是后续挂载以从上次停止的地方恢复执行）在一个平台线程上并开始运行：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From this point forward, the virtual thread state can be moved to `TERMINATED`
    (the execution is done), `PARKING` (a blocking operation has been encountered),
    or `YIELDING` (the effect of calling `Thread.yield()`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，虚拟线程的状态可以被移动到`TERMINATED`（执行完成）、`PARKING`（遇到阻塞操作）或`YIELDING`（调用`Thread.yield()`的效果）。
- en: PARKING
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PARKING
- en: The virtual thread is running until its job is done or it reaches a blocking
    operation. At this moment, the virtual thread should be unmounted from the platform
    thread (should be parked). In order to accomplish this, the JVM moves the virtual
    thread state from `RUNNING` to `PARKING` via the `park()` method. This is a transitional
    state to `PARKED` (park on the heap) or `PINNED` (park on its carrier thread).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程会一直运行，直到其任务完成或遇到阻塞操作。在这个时候，虚拟线程应该从平台线程（应该是挂起状态）卸载。为了完成这个任务，JVM通过`park()`方法将虚拟线程的状态从`RUNNING`转换为`PARKING`。这是一个过渡状态，可以转换为`PARKED`（在堆上挂起）或`PINNED`（在其承载线程上挂起）。
- en: PARKED/PINNED
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PARKED/PINNED
- en: Further, the `yieldContinuation()` is called from `park()` and the result of
    unmounting the virtual thread is signaled via the flag returned by `Continuation.yield(VTHREAD_SCOPE)`.
    In other words, if the unmounting operation is a success, then the virtual thread
    state is moved from `PARKING` to `PARKED` (the virtual thread was successfully
    parked on the heap). Otherwise, if the unmounting operation fails, then the `parkOnCarrierThread()`
    method is called and the virtual thread state is moved to `PINNED` (the virtual
    thread is parked on the carrier thread). A `PINNED` virtual thread is moved to
    the `RUNNING` state when the execution can be resumed (since it was parked on
    its carrier thread). On the other hand, a `PARKED` virtual thread is moved to
    the `RUNNABLE` state when it is unparked (or interrupted). In this case, the virtual
    thread (which is not mounted) is mounted and the execution continues from where
    it was left by moving the state from `RUNNABLE` to `RUNNING`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`yieldContinuation()` 从 `park()` 被调用，虚拟线程卸载的结果通过 `Continuation.yield(VTHREAD_SCOPE)`
    返回的标志来表示。换句话说，如果卸载操作成功，则虚拟线程的状态从 `PARKING` 移动到 `PARKED`（虚拟线程已成功停放在堆上）。否则，如果卸载操作失败，则调用
    `parkOnCarrierThread()` 方法，并将虚拟线程的状态移动到 `PINNED`（虚拟线程已停放在承载线程上）。当一个 `PINNED` 虚拟线程可以恢复执行时，它会被移动到
    `RUNNING` 状态（因为它已停放在其承载线程上）。另一方面，当一个 `PARKED` 虚拟线程被停泊（或中断）时，它会被移动到 `RUNNABLE`
    状态。在这种情况下，虚拟线程（未挂载）被挂载，并从上次停止的地方继续执行，通过将状态从 `RUNNABLE` 移动到 `RUNNING`。
- en: YIELDING
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YIELDING
- en: A virtual thread state is moved from `RUNNING` to `YIELDING` when a `Thread.yield()`
    call is encountered (for instance, this happens when we call `Thread.yield()`
    or `Thread.sleep(0)`). If the yield fails, then the virtual thread state is moved
    back to `RUNNING`. Otherwise, it is moved to `RUNNABLE`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到 `Thread.yield()` 调用时，虚拟线程的状态从 `RUNNING` 移动到 `YIELDING`（例如，当我们调用 `Thread.yield()`
    或 `Thread.sleep(0)` 时）。如果让步失败，则虚拟线程的状态会回到 `RUNNING`。否则，它会被移动到 `RUNNABLE`。
- en: RUNNABLE
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RUNNABLE
- en: A virtual thread is in the `RUNNABLE` state when it is not mounted but it wants
    to resume its execution. It comes into this state from the `PARKED` or `YIELDING`
    states. At this moment, the virtual thread state is moved from `RUNNABLE` to `RUNNING`
    and the execution continues from where it was left off (this happens in `runContinuation()`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个虚拟线程未挂载但想要恢复其执行时，它处于 `RUNNABLE` 状态。它从 `PARKED` 或 `YIELDING` 状态进入此状态。此时，虚拟线程的状态从
    `RUNNABLE` 移动到 `RUNNING`，并从上次停止的地方继续执行（这发生在 `runContinuation()` 中）。
- en: TERMINATED
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TERMINATED
- en: Now, the circle is closed. The virtual thread finishes its execution and gets
    into the `TERMINATED` state. Moreover, a virtual thread that couldn’t be started
    is also moved to this state.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，闭环完成。虚拟线程完成其执行并进入 `TERMINATED` 状态。此外，无法启动的虚拟线程也会被移动到这个状态。
- en: 227\. Extending StructuredTaskScope
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 227. 扩展 StructuredTaskScope
- en: We cannot extend `StructuredTaskScope.ShutdownOnSuccess` (*Chapter 10*, *Problem
    221*) or `ShutdownOnFailure` (*Chapter 10*, *Problem 222*) since these are `final`
    classes. But, we can extend `StructuredTaskScope` and provide a custom behavior
    via its `handleComplete()` method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能扩展 `StructuredTaskScope.ShutdownOnSuccess`（*第 10 章，问题 221*）或 `ShutdownOnFailure`（*第
    10 章，问题 222*），因为这些是 `final` 类。但是，我们可以扩展 `StructuredTaskScope` 并通过其 `handleComplete()`
    方法提供自定义行为。
- en: 'Let’s assume that we want to travel from our current location to a certain
    destination in our town:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从我们当前的位置到我们镇上的一个特定目的地旅行：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On our phone, we have an application that can query a ridesharing service and
    the public transport service. The ridesharing service can simultaneously query
    multiple ridesharing servers to find the cheapest offer. On the other hand, the
    public transport service can simultaneously query the public transport servers
    to find the offer that leaves the earliest, no matter whether it is by bus, train,
    tram, or subway. In a diagram, we can represent these statements as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的手机上，我们有一个可以查询拼车服务和公共交通服务应用程序。拼车服务可以同时查询多个拼车服务器以找到最便宜的报价。另一方面，公共交通服务可以同时查询公共交通服务器以找到最早出发的报价，无论它是通过公共汽车、火车、电车还是地铁。在图中，我们可以将这些陈述表示如下：
- en: '![Figure 11.5.png](img/B19665_11_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5.png](img/B19665_11_05.png)'
- en: 'Figure 11.5: Querying ridesharing and public transport services'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：查询拼车和公共交通服务
- en: Both services are implemented via a `StructuredTaskScope`, but the one that
    queries the public transport servers uses a custom `StructuredTaskScope`, while
    the one that queries the ridesharing servers uses a classical `StructuredTaskScope`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 两个服务都是通过`StructuredTaskScope`实现的，但查询公共交通服务器的那个使用自定义的`StructuredTaskScope`，而查询拼车服务器的那个使用经典的`StructuredTaskScope`。
- en: 'Since we are already familiar with the classical `StructuredTaskScope`, let’s
    quickly cover the ridesharing service. An offer received from this service is
    shaped as a record:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经熟悉经典的`StructuredTaskScope`，让我们快速了解一下拼车服务。从这个服务收到的报价形状如下：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The core of our code starts by forking a task for each of the three ridesharing
    servers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的核心是开始为三个拼车服务器中的每一个分叉一个任务：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After `scope.join()` finishes, we know that all subtasks have been finished
    successfully or exceptionally. We filter the results to extract the cheapest offer.
    If no offer is available, then we collect all exceptions and wrap them in a custom
    `RidesharingException`. Writing this as a functional programming snippet of code
    can be done as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scope.join()`完成后，我们知道所有子任务都已成功完成或异常完成。我们过滤结果以提取最便宜的报价。如果没有报价可用，那么我们将收集所有异常并将它们封装在一个自定义的`RidesharingException`中。将此作为代码片段的函数式编程可以这样做：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we return the offer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回报价：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A possible output will be:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let’s focus on the public transport service. This service queries the
    public transport servers via a custom `StructuredTaskScope`. A public transport
    offer is wrapped in the following record:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于公共交通服务。该服务通过自定义的`StructuredTaskScope`查询公共交通服务器。一个公共交通报价被封装在以下记录中：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The custom `StructuredTaskScope` is named `PublicTransportScope` and its goal
    is to analyze each subtask (`Subtask`) and to fetch the best offer. Extending
    the `StructuredTaskScope` is straightforward:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的`StructuredTaskScope`命名为`PublicTransportScope`，其目标是分析每个子任务（`Subtask`）并获取最佳报价。扩展`StructuredTaskScope`很简单：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A public transport server returns a `List<PublicTransportOffer>`. For instance,
    there can be three trains, or five buses in a day that cover our route. We will
    get them all on a separate list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 公共交通服务器返回一个`List<PublicTransportOffer>`。例如，一天中可能有三趟火车或五辆公交车覆盖我们的路线。我们将它们全部放在一个单独的列表中。
- en: 'When we extend `StructuredTaskScope`, we have to override a single method named
    `handleComplete()`. This method is automatically invoked for each `Subtask` that
    completes successfully or exceptionally. It is our job to collect and store the
    results for analysis later. To collect the results, we need a collection for valid
    results and a collection for exceptional results. These should be thread-safe
    collections since multiple `Subtask` instances may complete (almost) at the same
    time, which leads to race conditions. For instance, we can use `CopyOnWriteArrayList`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展`StructuredTaskScope`时，我们必须重写一个名为`handleComplete()`的方法。这个方法会自动为每个成功完成或异常完成的`Subtask`调用。我们的任务是收集和存储结果以供后续分析。为了收集结果，我们需要一个用于有效结果的集合和一个用于异常结果的集合。这些应该是线程安全的集合，因为多个`Subtask`实例可能几乎同时完成，这会导致竞争条件。例如，我们可以使用`CopyOnWriteArrayList`：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we override `handleComplete()`, and based on the `Subtask` state, we
    collect the results accordingly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重写`handleComplete()`，并根据`Subtask`的状态相应地收集结果：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we reach this point, we have collected all successful and exceptional
    results. It is time to analyze this data and recommend the best offer. We consider
    that the best offer is the offer that leaves the earliest no matter whether it
    is by bus, train, tram, or subway. So, we just have to find the best `goTime`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达这个点时，我们已经收集了所有成功和异常的结果。现在是时候分析这些数据并推荐最佳报价了。我们认为最佳报价是不论是通过公交车、火车、电车还是地铁，都能最早出发的报价。所以，我们只需要找到最佳的`goTime`：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we cannot find any valid offer, then we collect the exceptions and wrap
    them in a custom `PublicTransportException` via the following helper:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找不到任何有效的报价，那么我们将收集异常并将它们封装在一个自定义的`PublicTransportException`中，如下面的辅助函数所示：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that both of these methods are calling the `ensureOwnerAndJoined()` method.
    This built-in method guarantees that the current thread is the owner of this task
    scope (otherwise, it throws `WrongThreadException`) and that it joined after forking
    subtasks via `join()`/`joinUntil()` (otherwise, it throws an `IllegalStateException`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个方法都在调用`ensureOwnerAndJoined()`方法。这个内置方法保证当前线程是该任务范围的拥有者（否则，它抛出`WrongThreadException`），并且在通过`join()`/`joinUntil()`分叉子任务后已经加入（否则，它抛出`IllegalStateException`）。
- en: '**Important note**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: As a rule of thumb it is good practice to rely on the `ensureOwnerAndJoined()`
    check on every `StructuredTaskScope` that needs to be called by the main task.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，对于需要由主任务调用的每个`StructuredTaskScope`，依赖`ensureOwnerAndJoined()`检查是一个好的实践。
- en: 'Done! Our custom `StructuredTaskScope` is ready. Next, we can use it by forking
    our tasks and calling the `recommendedPublicTransport()` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们的自定义`StructuredTaskScope`已经准备好了。接下来，我们可以通过分叉任务并调用`recommendedPublicTransport()`方法来使用它：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A possible output looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下所示：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we can call both services (ridesharing and public transport) as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以如下调用这两个服务（共享出行和公共交通）：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So far, these two services run sequentially. In the next problem, we will run
    these two services concurrently by introducing another custom `StructuredTaskScope`.
    Until then, you can challenge yourself to write a custom `StructuredTaskScope`
    for the ridesharing service as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这两个服务是顺序运行的。在下一个问题中，我们将通过引入另一个自定义的`StructuredTaskScope`来同时运行这两个服务。在此之前，你可以挑战自己为共享出行服务也编写一个自定义的`StructuredTaskScope`。
- en: 228\. Assembling StructuredTaskScope
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 228. 组装StructuredTaskScope
- en: In the previous problem (*Problem 227*), we developed an application containing
    a ridesharing service and a public transport service. In both services, we used
    `StructuredTaskScope` to concurrently query the proper servers. However, only
    the servers were called concurrently while these two services were executed sequentially
    – first, we run the ridesharing service (which queries concurrently three servers),
    and after we have a result from this service, we run the public transport service
    (which queries concurrently four servers).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题（*问题227*）中，我们开发了一个包含共享出行服务和公共交通服务的应用程序。在这两个服务中，我们使用了`StructuredTaskScope`来并发查询适当的服务器。然而，尽管这两个服务是顺序执行的，但服务器是并发调用的——首先运行共享出行服务（通过并发查询三个服务器），然后从这个服务得到结果后，再运行公共交通服务（通过并发查询四个服务器）。
- en: 'Going further, we want to assemble these two services into a third service
    capable of running them concurrently as in the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，我们希望将这些两个服务组装成一个第三服务，使其能够同时运行，如下面的图所示：
- en: '![Figure 11.6.png](img/B19665_11_06.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 11.6.png](img/B19665_11_06.png)'
- en: 'Figure 11.6: Running the ridesharing and public transport services concurrently'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：同时运行共享出行和公共交通服务
- en: 'We start by assembling the `RidesharingOffer` and `PublicTransportOffer` into
    a record named `TravelOffer`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`RidesharingOffer`和`PublicTransportOffer`组装成一个名为`TravelOffer`的记录：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we write a custom `StructuredTaskScope` that forks the two `Callable`
    objects created in *Problem 227*. One `Callable` represents the ridesharing services
    (already implemented in *Problem 227* via a classic `StructuredTaskScope`), and
    the second `Callable` represents the public transport services (already implemented
    in *Problem 227* via the custom `PublicTransportScope`). We can name this `StructuredTaskScope`
    as `TravelScope`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写一个自定义的`StructuredTaskScope`，它分叉了在*问题227*中创建的两个`Callable`对象。一个`Callable`代表共享出行服务（已在*问题227*中通过经典的`StructuredTaskScope`实现），第二个`Callable`代表公共交通服务（已在*问题227*中通过自定义的`PublicTransportScope`实现）。我们可以将这个`StructuredTaskScope`命名为`TravelScope`：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `StructuredTaskScope` is parametrized – notice the `StructuredTaskScope<Travel>`.
    Since we have to fork different types of `Callable` instances, it would be handy
    to rely on `Object` and write `StructuredTaskScope<Object>`. But this will not
    be very expressive and neat. We better define an interface that narrows down the
    `Object` domain and that is implemented by our `Callable` instance’s results as
    follows (*sealed interfaces* were covered in detail in *Chapter 8*):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`StructuredTaskScope`是参数化的——注意`StructuredTaskScope<Travel>`。由于我们必须分叉不同类型的`Callable`实例，依赖`Object`并编写`StructuredTaskScope<Object>`会很有用。但这样不会非常清晰和整洁。我们最好定义一个接口来缩小`Object`域，并由我们的`Callable`实例的结果实现，如下所示（*密封接口*在*第8章*中详细讨论过）：'
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Getting back to `TravelScope`, we have to override the `handleComplete()` method
    to handle each completed `Subtask`. We know that the ridesharing service can return
    a valid result as a `RidesharingOffer` or an exceptional result as a `RidesharingException`.
    Moreover, the public transport service can return a valid result as `PublicTransportOffer`
    or an exceptional result as a `PublicTransportException`. We have to store these
    results in order to analyze them later when we create the `TravelOffer` answer.
    So, we define the following variables to cover all possible cases:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`TravelScope`，我们必须重写`handleComplete()`方法来处理每个完成的`Subtask`。我们知道共享出行服务可以返回一个有效的结果作为`RidesharingOffer`，或者一个异常的结果作为`RidesharingException`。此外，公共交通服务可以返回一个有效的结果作为`PublicTransportOffer`，或者一个异常的结果作为`PublicTransportException`。我们必须存储这些结果，以便在创建`TravelOffer`答案时稍后分析它们。因此，我们定义以下变量来覆盖所有可能的案例：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we override the `handleComplete()` and, exactly as in the case of `PublicTransportScope`,
    we rely on a simple `switch` to collect the results (for the `SUCCESS` and `FAILED`
    states, we need a nested `switch` to distinguish between the offer/exception received
    from the ridesharing service and the offer/exception received from the public
    transport service):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重写`handleComplete()`方法，正如在`PublicTransportScope`的情况中，我们依赖于一个简单的`switch`来收集结果（对于`SUCCESS`和`FAILED`状态，我们需要一个嵌套的`switch`来区分从共享出行服务收到的报价/异常和从公共交通服务收到的报价/异常）：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we analyze these results and create the proper `TravelOffer`. One
    way to accomplish this is as follows (feel free to think of a cooler/smarter implementation):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析这些结果并创建适当的`TravelOffer`。实现这一目标的一种方法如下（请随意思考更酷/更聪明的实现方式）：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our `TravelScope` is ready to be used. All we need to do is to fork our two
    services to be executed concurrently and call the `recommendedTravelOffer()` method
    to get the best offer:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TravelScope`已经准备好使用。我们所需做的只是将我们的两个服务并行执行，并调用`recommendedTravelOffer()`方法以获取最佳报价：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, instead of sequentially calling `fetchRidesharingOffers()` and `fetchPublicTransportOffers()`,
    we simply call `fetchTravelOffers()`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再依次调用`fetchRidesharingOffers()`和`fetchPublicTransportOffers()`，而是简单地调用`fetchTravelOffers()`：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A possible output would be:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Mission accomplished! Now you know how to write custom `StructuredTaskScope`
    instances and how to assemble/nest them to shape complex concurrent models.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！现在你了解了如何编写自定义的`StructuredTaskScope`实例，以及如何组装/嵌套它们来构建复杂的并发模型。
- en: 229\. Assembling StructuredTaskScope instances with timeout
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 229. 组装带超时的StructuredTaskScope实例
- en: Let’s continue our journey from *Problem 228* by assuming that the ridesharing
    service should be implemented with a timeout/deadline. In other words, if any
    of the ridesharing servers don’t answer in 10 milliseconds, then we abort the
    request and report the thrown `TimeoutException` via a meaningful message to the
    user.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续从*问题228*开始，假设共享出行服务应该实现超时/截止日期。换句话说，如果任何一个共享出行服务器在10毫秒内没有回答，那么我们终止请求并通过一个有意义的消息向用户报告抛出的`TimeoutException`。
- en: 'This means that instead of `scope.join()`, which waits indefinitely, we should
    use `joinUntil(Instant deadline)`, which waits only for the given `deadline` before
    throwing a `TimeoutException`. So, the `fetchRidesharingOffers()` method should
    be modified as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该使用`joinUntil(Instant deadline)`而不是`scope.join()`，后者会无限期等待，它只等待给定的`deadline`，在抛出`TimeoutException`之前。因此，`fetchRidesharingOffers()`方法应该修改如下：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By simply simulating a delay bigger than 10 milliseconds in any of the ridesharing
    servers, we help this `joinUntil()` to fail with a `TimeoutException`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在任何一个共享出行服务器中简单地模拟大于10毫秒的延迟，我们帮助`joinUntil()`失败并抛出`TimeoutException`：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In order to capture this `TimeoutException` and replace it with a friendly
    message for the end user, we have to adapt the `TravelScope` class. First, we
    define a variable to store the potential `TimeoutException`. Second, we adapt
    the `case FAILED` to populate this variable accordingly:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获这个`TimeoutException`并将其替换为对最终用户友好的消息，我们必须调整`TravelScope`类。首先，我们定义一个变量来存储潜在的`TimeoutException`。其次，我们调整`case
    FAILED`来相应地填充这个变量：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Third, we modify the `recommendedTravelOffer()` method to return a friendly
    message if `timeoutException` is not `null`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们修改`recommendedTravelOffer()`方法，如果`timeoutException`不为`null`，则返回一个友好的消息：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If the ridesharing service timeouts and the public transport service provides
    an offer, then the output should be something like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果共享出行服务超时，而公共交通服务提供了一个报价，那么输出应该是这样的：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Done! Check out the bundled code to practice this example. Challenge yourself
    to add a timeout/deadline for the public transport service as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！查看捆绑的代码以练习此示例。挑战自己为公共交通服务添加超时/截止日期。
- en: 230\. Hooking ThreadLocal and virtual threads
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 230. 钩子ThreadLocal和虚拟线程
- en: In a nutshell, `ThreadLocal` was introduced in JDK 1.2 (in 1998) as a solution
    to provide dedicated memory for each thread in order to share information with
    untrusted code (maybe some of your code has been written externally as third-party
    components) or between different components (that may run in multiple threads)
    of your application. Basically, if you are in such a scenario, then you don’t
    want to (or you cannot) share information via method arguments. If you need a
    more in-depth introduction to the `ThreadLocal` API, then consider *Java Coding
    Problems*, *First Edition*, *Chapter 11*, *Problem 220*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`ThreadLocal`是在JDK 1.2（1998年）中引入的，作为一种为每个线程提供专用内存的解决方案，以便与不受信任的代码（可能是一些外部编写的第三方组件）或应用程序的不同组件（可能在多个线程中运行）之间共享信息。基本上，如果你处于这种场景，那么你不想（或不能）通过方法参数来共享信息。如果你需要更深入地了解`ThreadLocal`
    API，请考虑《Java编码问题》*第一版*，第11章，问题220。
- en: 'A thread-local variable is of type `ThreadLocal` and relies on `set()` to set
    a value and on `get()` to get a value. In *Java Coding Problems*, *First Edition,*
    it was said that: “*If thread* `A` *stores the* `x` *value and thread* `B` *stores
    the* `y` *value in the same instance of* `ThreadLocal`*, then later on, thread*
    `A` *retrieves the* `x` *value and thread* `B` *retrieves the* `y` *value. So,
    we can say that the* `x` *value is local to thread* `A`*, while the* `y` *value
    is local to thread* `B`*.”* Each thread that calls `get()` or `set()` has its
    own copy of the `ThreadLocal` variable.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部变量是`ThreadLocal`类型，依赖于`set()`来设置值和`get()`来获取值。在《Java编码问题》*第一版*中提到：“*如果线程*
    `A` *存储了* `x` *值，而线程* `B` *在同一个* `ThreadLocal` *实例中存储了* `y` *值，那么稍后，线程* `A` *检索到*
    `x` *值，线程* `B` *检索到* `y` *值。因此，我们可以这样说，*x* *值是线程* `A` *的局部值，而*y* *值是线程* `B` *的局部值。”*
    调用`get()`或`set()`的每个线程都有自己的`ThreadLocal`变量副本。
- en: '**Important note**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Internally, `ThreadLocal` manages a map (`ThreadLocalMap`). The keys of the
    map are the threads, and the values are those values given via the `set()` method.
    `ThreadLocal` variables fit well for implementing the *one thread per request*
    model (for instance, one thread per HTTP request) since they allow us to easily
    manage the lifecycle of a request.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`ThreadLocal`管理一个映射（`ThreadLocalMap`）。映射的键是线程，值是通过`set()`方法给出的值。`ThreadLocal`变量非常适合实现*每个请求一个线程*模型（例如，每个HTTP请求一个线程），因为它们允许我们轻松管理请求的生命周期。
- en: 'Typically, a thread-local variable is global and static and it can be declared
    and initialized as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，线程局部变量是全局和静态的，它可以如下声明和初始化：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A thread-local variable should be reachable in the code from where it is needed
    (sometimes from everywhere in the code). Basically, the current thread and all
    the threads spawned by this thread should have access to the thread-local variables.
    In our case, it is reachable from everywhere in the current class. Next, let’s
    consider the following `Runnable`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部变量应该可以从需要它的代码中访问到（有时是从代码的任何地方）。基本上，当前线程以及由该线程派生的所有线程都应该能够访问线程局部变量。在我们的情况下，它可以从当前类的任何地方访问。接下来，让我们考虑以下`Runnable`：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we set a thread-local value representing information about the current
    thread, we get and log that value, we sleep for a random number of seconds (between
    0 and 5), and we log that value again.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个表示当前线程信息的线程局部值，我们获取并记录该值，然后随机睡眠几秒钟（0到5秒之间），然后再次记录该值。
- en: 'Next, let’s execute 10 tasks via a classical fixed thread pool (platform threads):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过经典固定线程池（平台线程）执行10个任务：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can easily see that each of threads #24, #31, and #22 sets information about
    themselves, and this information is available after sleeping. For instance, thread
    #22 sets the value `[Thread[#22,pool-1-thread-1,5,main]]`, and this value is exactly
    what it gets after sleeping for 4 seconds.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看到线程#24、#31和#22各自设置了关于它们自己的信息，并且这些信息在睡眠后可用。例如，线程#22设置了值`[Thread[#22,pool-1-thread-1,5,main]]`，而这个值正是它在睡眠4秒后得到的结果。
- en: 'Now, let’s switch to virtual threads:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换到虚拟线程：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output will be:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can easily see that each of threads #25, #27, and #28 sets information about
    themselves and this information is available after the sleeping period. For instance,
    thread #25 sets the value `[VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3]`,
    and this value is exactly what it gets after sleeping for 3 seconds.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以很容易地看到，线程 #25、#27 和 #28 每个都设置了关于它们自己的信息，并且这个信息在睡眠期之后是可用的。例如，线程 #25 设置了值
    `[VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3]`，这正是它在睡眠 3 秒后获取的值。'
- en: 'However, when we get this information, thread #25 is executed on *worker-4*,
    not on *worker-3*, as the information reveals. Practically, thread #25 has been
    executed on *worker-3* when the information was set, and it has been executed
    on *worker-4* when the information (which remains unchanged) was get.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，当我们获取这个信息时，线程 #25 在 *worker-4* 上执行，而不是在 *worker-3* 上，正如信息所揭示的那样。实际上，当信息被设置时，线程
    #25 在 *worker-3* 上执行，而当信息（保持不变）被获取时，它在 *worker-4* 上执行。'
- en: This is perfectly normal since the thread was unmounted from *worker-3* when
    the execution hit the `Thread.sleep()` blocking operation. After sleeping, it
    was mounted on *worker-4*. However, the information was not altered, so virtual
    threads and `ThreadLocal` work together as expected. In other words, the mounting-unmounting
    cycles of a virtual thread don’t affect how `ThreadLocal` works. `ThreadLocal`
    variables are fully supported by virtual threads.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全正常的，因为当执行遇到 `Thread.sleep()` 阻塞操作时，线程从 *worker-3* 上卸载。睡眠后，它被安装到 *worker-4*
    上。然而，信息没有被更改，所以虚拟线程和 `ThreadLocal` 正如预期的那样一起工作。换句话说，虚拟线程的安装-卸载周期不会影响 `ThreadLocal`
    的工作方式。虚拟线程完全支持 `ThreadLocal` 变量。
- en: 231\. Hooking ScopedValue and virtual threads
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 231. 将 ScopedValue 和虚拟线程挂钩
- en: The `ScopedValue` API was added to handle the shortcomings of `ThreadLocal`.
    But what are the shortcomings of `ThreadLocal`?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScopedValue` API 被添加来处理 `ThreadLocal` 的不足之处。但 `ThreadLocal` 的不足之处是什么？'
- en: Thread-local variables’ shortcomings
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程局部变量的不足之处
- en: First of all, it is hard to say and track who’s mutating a thread-local variable.
    This is a shortcoming of the API design. Basically, a `ThreadLocal` variable is
    globally available (at the application level or at a lower level), so it is hard
    to say from where it is mutated. Imagine that it is your responsibility to read,
    understand, and debug an application that uses several thread-local variables.
    How will you manage to follow the code logic and how will you know, at any given
    time, what values are stored by these thread-local variables? It would be a nightmare
    to track these variables from class to class and to signal when they mutated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，很难说和追踪谁在修改线程局部变量。这是 API 设计的不足之处。基本上，`ThreadLocal` 变量在全局范围内可用（在应用级别或更低级别），因此很难说它从哪里被修改。想象一下，你有责任阅读、理解和调试一个使用多个线程局部变量的应用程序。你将如何管理代码逻辑，你将如何知道在任何给定时间，这些线程局部变量存储了什么值？从类到类跟踪这些变量并将它们修改的信号将会是一场噩梦。
- en: Second, thread-local variables may live forever or longer than they should.
    How is this possible? Thread-local variables will live as long as the platform
    threads that use them will live, or even longer. It is true that we can remove
    a thread-local variable from the internal map by explicitly calling `remove()`.
    But, if we forget to call `remove()`, then we just open the gate for memory leaks
    (we just hope that the garbage collector will collect this data at some point).
    Never forget to call `remove()` when you are done with a thread-local variable
    used by a platform thread! On the other hand, if you are using thread-local variables
    with virtual threads, then there is no need to call `remove()` because the thread-local
    variable is removed once the virtual thread dies.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，线程局部变量可能永远存在，或者比它们应该存在的时间更长。这是如何可能的？线程局部变量将一直存在，直到使用它们的平台线程存在，甚至更长。确实，我们可以通过显式调用
    `remove()` 来从内部映射中删除线程局部变量。但是，如果我们忘记调用 `remove()`，那么我们就打开了内存泄漏的大门（我们只是希望垃圾收集器在某个时候收集这些数据）。永远不要忘记在完成使用平台线程的线程局部变量后调用
    `remove()`！另一方面，如果你在使用虚拟线程的线程局部变量，那么就没有必要调用 `remove()`，因为一旦虚拟线程死亡，线程局部变量就会被删除。
- en: Third, thread-local variables are prone to being duplicated. When we create
    a new thread (child thread) from the current thread (parent thread), the child
    thread copies all thread-local variables of the parent thread. So, if we spawn
    multiple threads from the current thread that has a significant number of thread-local
    variables, then we will duplicate a significant number of these variables. This
    is true for platform threads and for virtual threads. Since thread-local variables
    are not immutable, we cannot simply share the reference between threads. We have
    to copy them. Of course, this cannot be good for the application since it will
    negatively impact the memory footprint of these variables (imagine a million virtual
    threads having copies of thread-local variables).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，线程局部变量容易重复。当我们从当前线程（父线程）创建一个新的线程（子线程）时，子线程会复制父线程的所有线程局部变量。因此，如果我们从具有大量线程局部变量的当前线程中产生多个线程，那么我们将复制大量这些变量。这对于平台线程和虚拟线程都是如此。由于线程局部变量不是不可变的，我们无法简单地在线程之间共享引用。我们必须复制它们。当然，这对应用程序来说可能不是好事，因为它将负面地影响这些变量的内存占用（想象一下有百万个虚拟线程都有线程局部变量的副本）。
- en: Introducing scoped values
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍范围值
- en: Starting with JDK 20 (JEP 429) we have an alternative to thread-local variables
    called *scoped values*. This is meant to work with virtual threads and to overcome
    the shortcomings of thread-local variables. In JDK 20, this feature is in the
    incubator phase, and in JDK 21 (JEP 446) it is in the preview phase, so don’t
    forget to run the code using the `–code-preview` VM option.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 20（JEP 429）开始，我们有一个名为“范围值”的线程局部变量的替代方案。这是为了与虚拟线程一起工作，并克服线程局部变量的不足。在 JDK
    20 中，这个特性处于孵化阶段，在 JDK 21（JEP 446）中处于预览阶段，所以不要忘记使用`–code-preview` VM选项运行代码。
- en: Scoped values allow us to share immutable information (no need to copy) across
    the application’s components and have a limited lifetime (no risk of memory leaks).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 范围值允许我们在应用程序的组件之间共享不可变信息（无需复制），并且具有有限的生存期（没有内存泄漏的风险）。
- en: 'As you’ll see, the `ScopedValue` API is very neat and easy to use. To create
    a `ScopedValue`, we just call a factory method named `newInstance()` as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，`ScopedValue` API 非常整洁且易于使用。要创建一个`ScopedValue`，我们只需调用一个名为`newInstance()`的工厂方法，如下所示：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we’ve created a `ScopedValue` (not bound) that is capable of carrying
    a value of type `String` (of course, it could be anything else). You can declare
    it locally, globally, or however you need it to be declared depending on the place(s)
    that it should be accessible from. However, the value mapped to a `ScopedValue`
    is available for the current thread and all threads spawned by the current thread
    (so far, this is like `ThreadLocal`) but it is restricted to a method call. We
    will clarify this shortly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`ScopedValue`（未绑定），它能够携带类型为`String`的值（当然，它可以是任何其他类型）。您可以根据它应该从哪些位置访问来本地声明、全局声明或按需声明。然而，映射到`ScopedValue`的值仅对当前线程及其由当前线程产生的所有线程（到目前为止，这类似于`ThreadLocal`）可用，但它仅限于方法调用。我们将在稍后澄清这一点。
- en: '**Important note**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: A `ScopedValue` is considered bound if a value is mapped to it. Otherwise, the
    `ScopedValue` is considered not bound. We can check if a `ScopedValue` is bound
    via the `isBound()` flag method. This is an important check because if we attempt
    to get a value of a `ScopedValue` that is not bound, then we will get back `NoSuchElementException`.
    Besides `isBound()`, we also have `orElse()` and `orElseThrow()`. Using `orElse()`,
    we can set a default value for a `ScopedValue` that is not bound, while via `orElseThrow()`,
    we can throw a default exception.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个值映射到`ScopedValue`，则认为`ScopedValue`已绑定。否则，认为`ScopedValue`未绑定。我们可以通过`isBound()`标志方法检查`ScopedValue`是否已绑定。这是一个重要的检查，因为如果我们尝试获取未绑定的`ScopedValue`的值，那么我们将得到`NoSuchElementException`。除了`isBound()`之外，我们还有`orElse()`和`orElseThrow()`。使用`orElse()`，我们可以为未绑定的`ScopedValue`设置一个默认值，而通过`orElseThrow()`，我们可以抛出一个默认异常。
- en: 'A value can be mapped to a `ScopedValue` (so, the `ScopedValue` becomes bound
    to a value) via the `where()` method. The syntax of this method is listed here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值可以通过`where()`方法映射到一个`ScopedValue`（因此，`ScopedValue`与一个值绑定）。这个方法的语法如下：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Or, via the `runWhere()` and `callWhere()` methods:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过`runWhere()`和`callWhere()`方法：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'These three methods have in common the `key` and `value` parameters. The `key`
    represents the `ScopedValue` key (for instance, `SCOPED_VALUE`), while the `value`
    is the value mapped to this key. Whereas the `where()` method just creates a `ScopedValue`
    bound to a value, the `runWhere()` method can create a `ScopedValue` bound to
    a value and calls a `Runnable` operation (`op`) in the current thread, while `callWhere()`
    calls a `Callable` operation (`op`) in the current thread. If you prefer to rely
    only on the `where()` method, then simply rely on the following syntaxes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方法有共同点，即`key`和`value`参数。`key`代表`ScopedValue`的键（例如，`SCOPED_VALUE`），而`value`是映射到这个键的值。而`where()`方法只是创建一个绑定到值的`ScopedValue`，而`runWhere()`方法可以创建一个绑定到值的`ScopedValue`并在当前线程中调用`Runnable`操作（`op`），而`callWhere()`在当前线程中调用`Callable`操作（`op`）。如果您只想依赖`where()`方法，那么只需依赖以下语法：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, chaining `where().run()` acts as `runWhere()`, while `where().call()` acts
    as `callWhere()`. The advantage of using `where()` suffixed with `run()`/`call()`
    consists of the fact that we can write `ScopedValue.where(key1, value1).where(key2,
    value2),` …`.run()/call()` to obtain multiple `ScopedValue` instances bound to
    their values.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，链式调用`where().run()`相当于`runWhere()`，而`where().call()`相当于`callWhere()`。使用带有`run()`/`call()`后缀的`where()`的优点在于我们可以编写`ScopedValue.where(key1,
    value1).where(key2, value2),` …`.run()/call()`来获取多个绑定到其值的`ScopedValue`实例。
- en: '**Important note**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: A `ScopedValue` has no `set()` method. Once we map a value to a `ScopedValue`,
    we cannot change it (it is immutable). This means that the JVM doesn’t need to
    copy values around (remember that this is a shortcoming specific to `ThreadLocal`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScopedValue`没有`set()`方法。一旦我们将值映射到`ScopedValue`，我们就不能更改它（它是不可变的）。这意味着JVM不需要在值之间复制（记住，这是一个特定于`ThreadLocal`的缺点）。'
- en: 'The value is mapped to this key only for a method (`Runnable` or `Callable`)
    call. For instance, let’s assume the following `Runnable`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 值仅在该方法（`Runnable`或`Callable`）调用期间映射到该键。例如，让我们假设以下`Runnable`：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Via the `isBound()` method, we can check if a `ScopedValue` is bound (if it
    has a value). If a value is present, then we can successfully access it via the
    `get()` method. Calling `get()` for a `ScopedValue` that is not bound will result
    in a `NoSuchElementException` exception. For instance, if we run this task now:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`isBound()`方法，我们可以检查一个`ScopedValue`是否已绑定（如果它有一个值）。如果存在值，那么我们可以通过`get()`方法成功访问它。对一个未绑定的`ScopedValue`调用`get()`将导致`NoSuchElementException`异常。例如，如果我们现在运行这个任务：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, the output will be:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出将是：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is normal since we didn’t map any values to `SCOPED_VALUE`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的，因为我们没有将任何值映射到`SCOPED_VALUE`。
- en: 'Next, we can use the `where()` method to map a value to `SCOPED_VALUE` and
    share this value with the previous `Runnable`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`where()`方法将一个值映射到`SCOPED_VALUE`并与之前的`Runnable`共享这个值：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `Carrier` object is an immutable and thread-safe accumulator of key-value
    mappings that can be shared with a `Runnable`/`Callable`. By calling `cr.run(taskr)`,
    we share the value `Kaboooom!` with the `Runnable`, so the output will be:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Carrier`对象是一个不可变且线程安全的键值映射累加器，可以与`Runnable`/`Callable`共享。通过调用`cr.run(taskr)`，我们将值`Kaboooom!`与`Runnable`共享，因此输出将是：'
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'But we can write this example more compactly as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以将这个例子写得更紧凑一些，如下所示：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Or, by using `runWhere()`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`runWhere()`：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Calling `taskr.run()` will output `Not bound` again. This is happening because
    the `ScopedValue` is bound only for a method call. *Figure 11.7* highlights this
    via a more expressive example.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`taskr.run()`将再次输出`Not bound`。这是因为在方法调用期间`ScopedValue`才被绑定。*图11.7*通过一个更具有表达性的例子突出了这一点。
- en: '![Figure 11.7.png](img/B19665_11_07.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7.png](img/B19665_11_07.png)'
- en: 'Figure 11.7: ThreadLocal vs. ScopedValue'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：ThreadLocal与ScopedValue
- en: 'As you can see from this figure (left-hand side), once the thread local sets
    the value, `Mike`, this value is available in `sayHelloTL()` and in `sayGoodByeTL()`.
    The value is bound to this thread. On the other hand (right-hand side), the value
    `Mike` is mapped to a `ScopedValue`, but this value is available only in `sayHelloSV()`.
    This is happening because we bound the `SCOPED_VALUE` only to the `sayHelloSV()`
    method call. When the execution leaves the `sayHelloSV()`, the `SCOPED_VALUE`
    is not bound, and the value `Mike` is not available anymore. If `sayGoodByeSV()`
    was called from `sayHelloSV()`, then the value `Mike` would have been available.
    Or, if we call `sayGoodByeSV()` as follows, then the value `Mike` is available:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图（左侧所示）所示，一旦线程局部变量设置了值`Mike`，这个值在`sayHelloTL()`和`sayGoodByeTL()`中都是可用的。这个值绑定到这个线程上。另一方面（右侧），值`Mike`被映射到一个`ScopedValue`，但这个值只在`sayHelloSV()`中可用。这是因为我们只将`SCOPED_VALUE`绑定到`sayHelloSV()`方法调用。当执行离开`sayHelloSV()`时，`SCOPED_VALUE`未绑定，值`Mike`不再可用。如果从`sayHelloSV()`调用`sayGoodByeSV()`，那么值`Mike`将是可用的。或者，如果我们如下调用`sayGoodByeSV()`，那么值`Mike`也是可用的：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`ScopedValue` works with `Callable` as well, but we have to replace `run()`
    with `call()`. For instance, let’s assume the following pretty dummy `Callable`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScopedValue`也与`Callable`一起工作，但我们必须将`run()`替换为`call()`。例如，让我们假设以下相当简单的`Callable`：'
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And the following sequence of calls:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下调用序列：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Can you intuit the output? It should be `Not bound`, `Kaboooom-1!`, `Kaboooom-2!`,
    `Kaboooom-3!`, and `Not bound` again:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你能直观地推断出输出结果吗？应该是`未绑定`，`Kaboooom-1!`，`Kaboooom-2!`，`Kaboooom-3!`，然后再一次`未绑定`：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: So, let me emphasize this once again. A `ScopedValue` is bound (it has a value)
    during a method call’s lifetime. The `isBound()` will return `false` outside this
    method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我再次强调这一点。`ScopedValue`在方法调用生命周期内绑定（它有一个值）。`isBound()`将在该方法外部返回`false`。
- en: '**Important note**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: As you can see in this example, a `ScopedValue` can have different values in
    the same thread. Here, the same `Callable` was executed five times in the same
    thread.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，一个`ScopedValue`在同一个线程中可以有不同的值。在这里，同一个`Callable`在同一线程中执行了五次。
- en: 'Setting a `ScopedValue` from a certain thread (other than the main thread)
    can be done quite easily. For instance, we can set a `ScopedValue` from a platform
    thread as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个线程（除了主线程）设置`ScopedValue`可以非常容易地完成。例如，我们可以如下从平台线程设置`ScopedValue`：
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Or, via the `ofPlatform()` method as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过`ofPlatform()`方法如下：
- en: '[PRE69]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Mapping a `ScopedValue` from a certain virtual thread can be done as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个虚拟线程映射一个`ScopedValue`可以按照以下方式完成：
- en: '[PRE70]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we have two threads, and each of them maps a different value to `SCOPED_VALUE`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有两个线程，每个线程都将不同的值映射到`SCOPED_VALUE`：
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: So, the first thread (`tpcx`) maps the value `Kaboooom-tpcx!`, while the second
    thread (`tpcy`) maps the value `Kaboooom-tpcy!`. When `taskr` is executed by `tpcx`,
    the mapped value will be `Kaboooom-tpcx!`, while when `taskr` is executed by `tpcy`,
    the mapped value will be `Kaboooom-tpcy!`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个线程（`tpcx`）映射的值是`Kaboooom-tpcx!`，而第二个线程（`tpcy`）映射的值是`Kaboooom-tpcy!`。当`taskr`由`tpcx`执行时，映射的值将是`Kaboooom-tpcx!`，而当`taskr`由`tpcy`执行时，映射的值将是`Kaboooom-tpcy!`。
- en: 'Here is an example where `tpca` maps the value `Kaboooom-tpca!`, and `tpcb`
    doesn’t map any value:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子，`tpca`映射的值是`Kaboooom-tpca!`，而`tpcb`没有映射任何值：
- en: '[PRE72]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Make sure to not conclude from this that a `ScopedValue` is bound to a particular
    thread. The following note should clarify this aspect.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保不要从这个结论中得出`ScopedValue`绑定到特定线程的结论。以下说明应该可以澄清这一点。
- en: '**Important note**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'A `ScopedValue` is bound to a particular method call not to a particular thread
    (as in the case of `ThreadLocal`). In other words, a method can get a value of
    a `ScopedValue` if the code that calls it has mapped it. Data/values are passed
    in one way only: from *caller* to *callee*. Otherwise, `ScopedValue` is not bound
    and cannot be bounded and used in the current context of the method. As in the
    case of `ThreadLocal`, a `ScopedValue` is passed (and available) to all threads
    spawned by the task executed in the context of the current `ScopedValue`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScopedValue`绑定到特定的方法调用，而不是特定的线程（如`ThreadLocal`的情况）。换句话说，如果一个方法调用的代码将其映射，那么该方法可以获取`ScopedValue`的值。数据/值只能以这种方式传递：从*调用者*到*被调用者*。否则，`ScopedValue`未绑定，不能在当前方法上下文中绑定和使用。与`ThreadLocal`的情况类似，`ScopedValue`会被传递（并且可用）给在当前`ScopedValue`上下文中执行的任务所创建的所有线程。'
- en: 'Besides the `isBound()` method, a `ScopedValue` also has `orElse()` and `orElseThrow()`.
    Via `orElse()`, we can specify an alternative/default value when the `ScopedValue`
    is not bound, while via `orElseThrow()`, we can throw a default exception. Here
    is an example of two `Runnable` objects that use these methods:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Of course, we can use these methods outside of `Runnable`/`Callable` as well.
    Here is an example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the first virtual thread, we rely on `orElse()` to map the value of `SCOPED_VALUE`,
    so the `SCOPED_VALUE.get()` from `taskr` will return the `Kaboooom` value. In
    the second virtual thread, we rely on `orElseThrow()`, so `taskr` will not be
    executed since the `RuntimeException` will be thrown.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In the next problems, we will tackle more aspects of scoped values.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 232\. Using ScopedValue and executor services
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Problem 230*, we wrote an application that combines `ThreadLocal` and executor
    services (we have used `newVirtualThreadPerTaskExecutor()` and `newFixedThreadPool()`).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'In this problem, we re-write the code from *Problem 230* in order to use `ScopedValue`.
    First, we have the following `Runnable`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This code is straightforward. We retrieve the value mapped to `SCOPED_VALUE`,
    we sleep from a random number of seconds (between 0 and 5), and we retrieve the
    value mapped to `SCOPED_VALUE` again. Next, let’s run this code via `newFixedThreadPool()`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'So, we have 10 platform threads and 10 tasks. Each thread maps the value `Kaboooom-I`
    to `SCOPED_VALUE` and calls the `Runnable`. A possible output would be:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let’s arbitrarily check out thread #27\. Before sleeping, this thread sees
    the scoped value, `Kabooom-2`. After sleeping, thread #27 sees the same value,
    `Kabooom-2`. Each platform thread sees the scoped value that was mapped when the
    thread was created and the task was submitted. So, we have the same behavior as
    in the case of using `ThreadLocal`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s switch to `newVirtualThreadPerTaskExecutor()`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, a possible output would be:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Again, we can conclude that each virtual thread sees the scoped value that was
    mapped when the thread was created and the task was submitted. The only difference
    is that virtual threads are running on different workers before and after sleeping.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: So, we can rely on `ScopedValue` instead of `ThreadLocal` and take advantage
    of all the goodies (see *Problem 231*) brought by this API in comparison to `ThreadLocal`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 233\. Chaining and rebinding scoped values
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this problem, you’ll see how to *chain* and *rebind* scoped values. These
    are very handy operations that you’ll love to use.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Changing scoped values
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume that we have three `ScopedValue` instances, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We also have a `Runnable` that uses all three `ScopedValue` instances:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can map the values to these three `ScopedValue` instances by simply chaining
    the `where()` calls. This is a very convenient way to set up multiple scoped values:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: That’s all! Quite simple!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Rebinding scoped values
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s imagine that we have two `Runnable` objects, `taskA`, and `taskB`. We
    start with `taskB`, which is straightforward:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'So, `taskB` simply logs three `ScopedValue` instances. Next, `taskA` needs
    only `SCOPED_VALUE_1`, but it also has to call `taskB`. So, `taskA` should map
    the proper values for `SCOPED_VALUE_2` and `SCOPED_VALUE_3`. How about `SCOPED_VALUE_1`?
    Well, `taskA` doesn’t want to pass the current value of `SCOPED_VALUE_1` to `taskB`,
    so it must rebind this scoped value as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Calling `taskA` maps a value only to `SCOPED_VALUE_1`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output will be as follows (the comments have been manually added; they
    are not part of the output):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: So, `taskA` sees the value `Kabooom-1` for `SCOPED_VALUE_1`, but it doesn’t
    pass this value to `taskB`. It rebinds this scoped value to `No kaboooom`. This
    is the value that lands in `taskB` next to `Kaboooom -2` and `Kaboooom -3`, which
    has been mapped for `SCOPED_VALUE_2` and `SCOPED_VALUE_3`. This technique is useful
    if you don’t want to allow a certain scoped value to go beyond your goals or if
    you just need another value. Once the execution gets back in `taskA`, the `SCOPED_VALUE_1`
    is restored to `Kaboooom - 1`, so the initial value is not lost and is available
    in `taskA`. On the other hand, `SCOPED_VALUE_2` and `SCOPED_VALUE_3` are not bound.
    They have been bound only for the execution of `taskB`. How cool is that?!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 234\. Using ScopedValue and StructuredTaskScope
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this problem, we will reiterate the application developed in *Problems 227*
    and *228*, and we will enrich it with a few `ScopedValue` variables for implementing
    new features. I’ll consider that you are already familiar with that application.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ScopedValue` that we plan to add are listed here (these are added in the
    main class because we want them to be accessible at the application level):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'First, let’s focus on the `fetchTravelOffers()` method, which is the point
    from where we fork our two tasks, `fetchRidesharingOffers()` and `fetchPublicTransportOffers()`.
    The code that calls `fetchTravelOffers()` gets modified as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'So, our travel page needs the user credentials (for simplicity, only the username).
    If the user is logged in, then we should have a valid username and we can share
    it with `fetchTravelOffers()` via the `USER` scoped value. If the user is not
    logged in, then `USER` remains unbound. The `fetchTravelOffers()` gets modified
    as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There are a lot of things happening in this code, so let’s take it one by one.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'The ridesharing service is accessible only for logged-in users, so we call
    it only if `USER` is bound. Otherwise, we log a message for the user:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'On the other hand, the public transport service doesn’t require the user to
    be logged in. However, in order to use public transport we need a special ticket.
    We have such a ticket and we share it with the public transport service via the
    `PUBLIC_TRANSPORT_TICKET` scoped value:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `PUBLIC_TRANSPORT_TICKET` scoped value will be accessible only from the
    public transport service (only from `fetchPublicTransportOffers()` and other methods
    called from this one).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUBLIC_TRANSPORT_TICKET`作用域值仅可以从公共交通服务（仅从`fetchPublicTransportOffers()`和其他从该函数调用的方法）访问。'
- en: 'Next, the ridesharing and public transport services need our location and destination.
    This information is collected from the user/client and passed as arguments in
    `fetchTravelOffers()`. Thereafter, we map this information to `LOC` and `DEST`
    scoped values:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，拼车和公共交通服务需要我们的位置和目的地信息。这些信息从用户/客户端收集，并通过`fetchTravelOffers()`作为参数传递。然后，我们将这些信息映射到`LOC`和`DEST`作用域值：
- en: '[PRE92]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, `LOC` and `DEST` are bound and are accessible only from ridesharing and
    public transport services. They will be shared with all threads forked from these
    services.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`LOC`和`DEST`已经绑定，并且只能从拼车和公共交通服务中访问。它们将与从这些服务分叉的所有线程共享。
- en: 'Next, let’s check out the ridesharing service, `fetchRidesharingOffers()`.
    This service checks if the user is logged in and logs a meaningful message:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查拼车服务，`fetchRidesharingOffers()`。这项服务检查用户是否已登录，并记录一条有意义的消息：
- en: '[PRE93]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'One of the ridesharing companies (`CarOne`) provides a random discount to its
    clients. We have a discount of 0.5 that we can map to `CAR_ONE_DISCOUNT` scoped
    value:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 拼车公司之一（`CarOne`）向其客户提供随机折扣。我们有一个0.5的折扣可以映射到`CAR_ONE_DISCOUNT`作用域值：
- en: '[PRE94]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If we visit the scoped values status in the context of `fetchRidesharingOffers()`,
    then we can say that the `USER` scoped value was bound at the application level,
    so it should be available everywhere in the application. The `LOC` and `DEST`
    scoped values have been bound in `fetchTravelOffers()`, so they are also available
    in `fetchRidesharingOffers()`. On the other hand, `PUBLIC_TRANSPORT_TICKET` is
    not available (not bound) in `fetchRidesharingOffers()`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`fetchRidesharingOffers()`的上下文中查看作用域值状态，那么我们可以这样说，`USER`作用域值是在应用级别绑定的，因此它应该在应用中的任何地方都是可用的。`LOC`和`DEST`作用域值已经在`fetchTravelOffers()`中绑定，所以它们在`fetchRidesharingOffers()`中也是可用的。另一方面，`PUBLIC_TRANSPORT_TICKET`在`fetchRidesharingOffers()`中不可用（未绑定）。
- en: 'Next, let’s focus on the public transport service, `fetchPublicTransportOffers()`.
    This service doesn’t require the user to be logged in, but it can use this information
    to log a friendly message as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于公共交通服务，`fetchPublicTransportOffers()`。这项服务不需要用户登录，但它可以使用这些信息记录一条友好的消息，如下所示：
- en: '[PRE95]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If we briefly review the current status of the scoped values in the context
    of `fetchPublicTransportOffers()`, then we can say that the `USER` scoped value
    was bound at the application level, so it should be available everywhere in the
    application. The `LOC` and `DEST` scoped values have been bound in `fetchTravelOffers()`,
    so they are also available in `fetchPublicTransportOffers()`. On the other hand,
    `PUBLIC_TRANSPORT_TICKET` and `CAR_ONE_DISCOUNT` are not available (not bound)
    in `fetchPublicTransportOffers()`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简要回顾一下在`fetchPublicTransportOffers()`上下文中作用域值的当前状态，那么我们可以这样说，`USER`作用域值是在应用级别绑定的，因此它应该在应用中的任何地方都是可用的。`LOC`和`DEST`作用域值已经在`fetchTravelOffers()`中绑定，所以它们在`fetchPublicTransportOffers()`中也是可用的。另一方面，`PUBLIC_TRANSPORT_TICKET`和`CAR_ONE_DISCOUNT`在`fetchPublicTransportOffers()`中不可用（未绑定）。
- en: 'At this point, we have used all five scoped values. We continue to track them
    in the `Ridesharing` class, which simulates the ridesharing servers. In this class,
    we have access to `USER`, `DEST`, and `LOC` scoped values. Moreover, only in `carOneServer()`
    do we have access to `CAR_ONE_DISCOUNT`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了所有五个作用域值。我们继续在模拟拼车服务器的`Ridesharing`类中跟踪它们。在这个类中，我们可以访问`USER`、`DEST`和`LOC`作用域值。此外，只有在`carOneServer()`中我们才能访问`CAR_ONE_DISCOUNT`：
- en: '[PRE96]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: So, if we have a discount (and we have one), the server of `CarOne` will apply
    it. If no drivers are available for our route, then the server will throw a meaningful
    exception. This exception is thrown from `topCarServer()` and `starCarServer()`
    as well. These are the servers of `TopCar` company and the `StarCar` company respectively.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有折扣（我们确实有一个），`CarOne`的服务器将应用它。如果没有司机可用，那么服务器将抛出一个有意义的异常。这个异常也是从`topCarServer()`和`starCarServer()`抛出的。这些分别是`TopCar`公司和`StarCar`公司的服务器。
- en: 'Ok, so far so good! Next, let’s check out the `PublicTransport` class, which
    simulates the public transport servers. In this class, we have access to `USER`,
    `DEST`, `LOC`, and `PUBLIC_TRANSPORT_TICKET` scoped values. We arbitrarily choose
    one of the servers (all of them use the same core code) and list here the code
    that we are interested in:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止一切顺利！接下来，让我们检查 `PublicTransport` 类，该类模拟公共交通服务器。在这个类中，我们可以访问 `USER`、`DEST`、`LOC`
    和 `PUBLIC_TRANSPORT_TICKET` 范围值。我们随意选择一个服务器（它们都使用相同的核心代码）并在这里列出我们感兴趣的代码：
- en: '[PRE97]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you can see, the public transport services can make an offer only if we have
    a special ticket that is verified via the `PUBLIC_TRANSPORT_TICKET` scoped value.
    If no public tram transport is available for our route, then the server throws
    an exception that uses the `LOC` and `DEST` scoped values to build a meaningful
    message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，公共交通服务只能在我们有通过 `PUBLIC_TRANSPORT_TICKET` 范围值验证的特殊票时才能提供报价。如果我们路线没有可用的公共电车交通，则服务器会抛出一个异常，该异常使用
    `LOC` 和 `DEST` 范围值构建一个有意义的消息。
- en: Done! Using `ScopedValue` with `StructuredTaskScope` allows us to design complex
    concurrent models.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！使用 `ScopedValue` 和 `StructuredTaskScope` 允许我们设计复杂的并发模型。
- en: 235\. Using Semaphore instead of Executor
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 235. 使用信号量代替执行器
- en: 'Let’s say that we have the following task (`Runnable`):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下任务（`Runnable`）：
- en: '[PRE98]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And we plan to execute this task 15 times by 3 threads:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划通过 3 个线程执行这个任务 15 次：
- en: '[PRE99]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can easily solve this problem via `Executors.newFixedThreadPool()` and platform
    threads:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `Executors.newFixedThreadPool()` 和平台线程轻松解决这个问题：
- en: '[PRE100]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A snippet of the possible output:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出片段：
- en: '[PRE101]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'As you can see, the application has only three platform threads (#22, #23,
    and #24).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，应用程序只有三个平台线程（#22、#23 和 #24）。'
- en: But, we already know that platform threads are expensive and it will be better
    to rely on virtual threads. The problem is that we cannot simply replace this
    fixed thread pool with `newVirtualThreadPerTaskExecutor()` because we can’t control
    the number of threads. While we want to use only 3 threads, the virtual thread
    executor will allocate a virtual thread per task, so we will end up with 15 threads.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们已经知道平台线程很昂贵，因此最好依赖于虚拟线程。问题是，我们不能简单地用 `newVirtualThreadPerTaskExecutor()`
    替换这个固定线程池，因为我们无法控制线程的数量。虽然我们只想使用 3 个线程，但虚拟线程执行器将为每个任务分配一个虚拟线程，所以我们最终会有 15 个线程。
- en: 'In order to control the number of virtual threads, we can rely on `Semaphore`
    (if you want more details about this topic you can check out *Java Coding Problems*,
    *First Edition*, *Chapter 10*, *Problem 211*). First, we declare a `Semaphore`
    with `NUMBER_OF_THREADS` permits:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制虚拟线程的数量，我们可以依赖 `Semaphore`（如果您想了解更多关于这个主题的细节，您可以查看 *Java 编程问题*，*第一版*，*第
    10 章*，*问题 211*）。首先，我们声明一个具有 `NUMBER_OF_THREADS` 许可证的 `Semaphore`：
- en: '[PRE102]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, we rely on `semaphore.acquire()` and `semaphore.release()` to control
    the access to these permits and execute `NUMBER_OF_TASKS` tasks as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们依靠 `semaphore.acquire()` 和 `semaphore.release()` 来控制对这些许可的访问，并按照以下方式执行
    `NUMBER_OF_TASKS` 个任务：
- en: '[PRE103]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Here, we have six virtual threads (#27, #33, #28, #30, #25, and #31), not three.
    The idea is that the `Semaphore` allows only three virtual threads to be created
    and to run concurrently at a time. You can probe this statement by running the
    code by yourself. After the first three virtual threads are created, they will
    sleep for 5 seconds. But because virtual threads are cheap, they do not go back
    into a thread pool, so they are not reused. It is much cheaper to create another
    three to use and throw. The idea is that there will not be more than three at
    a time.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们有六个虚拟线程（#27、#33、#28、#30、#25 和 #31），而不是三个。想法是，`Semaphore` 只允许同时创建和运行三个虚拟线程。你可以通过亲自运行代码来验证这个说法。在前三个虚拟线程创建后，它们将睡眠
    5 秒。但是，因为虚拟线程便宜，它们不会回到线程池中，所以不会被重用。创建另外三个来使用和丢弃更便宜。想法是，一次不会超过三个。'
- en: 236\. Avoiding pinning via locking
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 236. 通过锁定避免固定
- en: 'Remember from *Chapter 10*, *Problem 213*, that a virtual thread is pinned
    (not unmounted from its carrier thread) when the execution goes through a `synchronized`
    block of code. For instance, the following `Runnable` will cause virtual threads
    to be pinned:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *第 10 章*，*问题 213* 中记住，当一个虚拟线程在执行过程中通过一个 `synchronized` 代码块时，它会被固定（不会从其承载线程卸载）。例如，以下
    `Runnable` 将导致虚拟线程被固定：
- en: '[PRE105]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `synchronized` block contains a blocking operation (`sleep()`), but the
    virtual thread that hits this point of execution is not unmounted. It is pinned
    on its carrier thread. Let’s try to capture this behavior via the following executor:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'A possible output would look as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Check out the workers! Because the virtual threads are pinned on their carriers,
    the application uses all the available workers (eight on my machine). The workers
    are not accessible during that `sleep(1000)`, so they are not available to execute
    other tasks. In other words, a carrier thread is available only after the virtual
    thread finishes its execution.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we can avoid this situation by re-writing the application via `ReentrantLock`
    instead of `synchronized`. If you want more details about `ReentrantLock`, then
    you can check out *Java Coding Problems*, *First Edition*, *Chapter 11*, *Problems
    222* and *223*. So, considering that you are familiar with `ReentrantLock`, we
    can come up with the following non-pinned solution:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We execute this code via the same `newVirtualThreadPerTaskExecutor()`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Let’s analyze a snippet of a possible output:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This time, we can see that only three workers are used, *worker-1*, *3*, and
    *5*. Because the virtual threads are not pinned, they can free up their carrier
    threads. This way, the platform threads can be reused and we save the rest of
    the resources for other tasks. If pinning is intensive, then it will affect the
    scalability of the application, so it is recommended to revisit your `synchronized`
    code and, whenever achievable, replace it with `ReentrantLock`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 237\. Solving the producer-consumer problem via virtual threads
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that we want to write a program simulating an assembly line (or
    a conveyor) for checking and packing bulbs using two workers. By checking, we
    mean that the worker tests if the bulb lights up or not. By packing, we mean that
    the worker takes the verified build and puts it in a box.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s assume a fixed number of producers (3), and a fixed number of consumers
    (2); let’s represent it via the following diagram:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8.png](img/B19665_11_08.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: The producer-consumer problem with a fixed number of workers'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: We can implement this scenario via the well-known `Executors.newFixedThreadPool(PRODUCERS)`,
    `Executors.newFixedThreadPool(CONSUMERS)`, and `ConcurrentLinkedQueue` as the
    temporary storage for checked bulbs, as you can see at [https://github.com/PacktPublishing/Java-Coding-Problems/tree/master/Chapter10/P203_ThreadPoolFixed_ConcurrentLinkedQueue](https://github.com/PacktPublishing/Java-Coding-Problems/tree/master/Chapter10/P203_ThreadPoolFixed_ConcurrentLinkedQueue).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider this code as legacy and let’s refactor it via virtual threads.
    All we have to do is to replace `Executors.newFixedThreadPool()` (executor used
    for producers and consumers) with `newVirtualThreadPerTaskExecutor()` as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'That’s all! Isn’t it astonishing how easily we refactor this code to move from
    platform threads to virtual threads? The possible output is listed here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Of course, you’ll find the complete code on GitHub. Take your time to get familiar
    with it especially if you didn’t read the first edition of this book. We will
    rely on this code in the following two problems as well.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 238\. Solving the producer-consumer problem via virtual threads (fixed via Semaphore)
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous problem, we implemented the producer-consumer problem via a
    fixed number of producers (three virtual threads) and consumers (two virtual threads).
    Moreover, since our application works as an assembly line, we can say that the
    number of tasks is boundless. Practically, the producers and consumers work without
    breaks until the assembly line is stopped. This means the virtual threads assigned
    by the executor as producers and consumers remain exactly the same between a start-stop
    lifecycle of the assembly line.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s assume that we want to use `Semaphore` objects instead of `newVirtualThreadPerTaskExecutor()`
    to obtain the exact same behavior.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on *Problem 235*, we can implement the fixed number of producers as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'And the fixed number of consumers is shaped as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In the next problem, we will complicate things a little bit.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 239\. Solving the producer-consumer problem via virtual threads (increase/decrease
    consumers)
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s continue our producer-consumer problem with another scenario that starts
    with three producers and two consumers:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Let’s assume that each producer checks a bulb in no more than one second. However,
    a consumer (packer) needs a maximum of 10 seconds to pack a bulb. The producer
    and consumer times can be shaped as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Obviously, in these conditions, the consumers cannot face the incoming flux.
    The queue (here, `LinkedBlockingQueue`) used for storing bulbs until they are
    packed will continuously increase. The producers will push into this queue much
    faster than the consumers can poll.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Since we have only two consumers, we have to increase their number to be able
    to handle and stabilize the queue’s load. But, after a while, the producers will
    get tired and will need more time to check each bulb. If the producers slow down
    the production rate, the number of consumers should be decreased as well since
    many of them will just sit there. Later on, the producers may speed up again,
    and so on.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: This kind of problem can be solved via `newCachedThreadPool()` and platform
    threads. If you are not familiar with this topic then you can find more details
    in *Java Coding Problems*, *First Edition*, *Chapter 10*, *Problem 204*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'How about solving it via virtual threads? We can start the producers and consumers
    via two `Semaphore` objects exactly as we did in *Problem 238*. Next, we need
    to monitor the queue size and act accordingly. Let’s assume that we should take
    action only if the queue size is greater than five bulbs:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Moreover, let’s assume that we can increase the number of consumers up to 50:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We want to monitor the queue every 3 seconds with an initial delay of 5 seconds,
    so we can rely on a `ScheduledExecutorService`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `monitorQueueSize()` method is responsible for initializing the `monitorService`
    and calling `addNewConsumer()`, `removeConsumer()`, and log the status as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'So, if the queue size is above `MAX_QUEUE_SIZE_ALLOWED` and the number of consumers
    is under `MAX_NUMBER_OF_CONSUMERS`, then we should add a new consumer. This can
    be done by releasing a new permit for the `Semaphore` that handles the consumers.
    Releasing a permit when the number of current permits is zero will simply add
    a new permit, so a new virtual thread can acquire this permit and become a new
    consumer:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Most likely, when the producers slow down the production rate, there will be
    too many consumers that just hand on. In such cases, we have to interrupt virtual
    threads until we manage to balance the work between producers and consumers. The
    `removeConsumer()` method is responsible for signaling that a consumer must be
    interrupted, and for this, it sets an `AtomicBoolean` to `true`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `Consumer` checks this flag at each run and when it is `true`, it will
    simply interrupt the currently running virtual thread:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In order to simulate the decrease in the production rate for producers, we
    can rely on `ScheduledExecutorService` as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'So, we start the assembly line and the producers will check bulbs at a very
    high rate. After 2.5 minutes, we decrease this rate by adding an extra time of
    4 seconds for each producer via the `extraProdTime` variable. Initially, this
    is 0, but after 2.5 minutes it becomes 4000\. Since it is part of the production
    time it will slow down the producer by 4 seconds:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Let’s try to trace a run of our assembly line to see how it works. So, we start
    the assembly line and, pretty soon, we notice that the number of bulbs in the
    queue (27) is greater than 5 and the application started to add consumers:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The application continues to add consumers while the number of unprocessed
    bulbs keeps growing (here we have 237 bulbs in the queue and 32 consumers):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'When the application reaches around 37 consumers, the queue size enters a descending
    trend. Here you can see two consecutive logs of queue status (meanwhile, the application
    is still adding more consumers – it does this until the `queue.size()` is less
    than 5):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The queue size continues to decrease and the number of consumers reaches the
    maximum of 50\. At some point, the queue is depleted. The number of customers
    is much higher than needed so they are removed one by one. Here is the moment
    when the last consumer (consumer #50 was removed):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'While the application continues to calibrate itself by removing consumers,
    the producers slow down:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Since the producers have slowed down, the number of consumers continues to
    decrease and the queue load can be processed by two consumers:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: At this point, the assembly line is calibrated. If the producers increase their
    production rate again then the application is ready to respond. As you can see,
    the consumer’s `Semaphore` has 48 permits available, so we shouldn’t create them
    again. If you want to remove the permit corresponding to an interrupted consumer
    then you have to extend the `Semaphore` class and override the `protected` method
    `reducePermits()`. The number of permits is just a counter; so, in this scenario,
    removing permits is not really necessary.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 240\. Implementing an HTTP web server on top of virtual threads
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a simple HTTP web server in Java is quite easy since we already
    have an API ready to guide and serve our goals. We start from the `HttpServer`
    class (this class is present in the `com.sun.net.httpserver` package), which allows
    us to achieve our goal straightforwardly in a few steps.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping into the code, let’s quickly mention that our web server will
    allow us to choose between platform and virtual threads and between non-locking
    or locking (for instance, to simulate access to a database). We will make these
    choices via two boolean parameters of our `startWebServer(boolean virtual, boolean
    withLock)` method, named `virtual` and `withLock`, respectively. So, we will have
    four possible configurations.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create an `HttpServer` via the `create()` method. At this point,
    we also set up the port of our web server:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Next, we create the web server context by specifying the access page and the
    handler that will deal with the HTTP requests (the `WebServerHandler` is implemented
    later):'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Next, we can choose the executor service (override the default one) that will
    orchestrate the threads of our web server. This can be done via the `setExecutor()`
    method. Since we can choose between platform threads (we arbitrarily chose to
    have 200 such threads) and virtual threads, we have to cover both cases as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Finally, we call the `start()` method to start the web server, and we log this
    accordingly:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Next, we focus on the `WebServerHandler` class, which implements the `com.sun.net.httpserver.HttpHandler`
    interface and is responsible for handling the incoming HTTP requests. We simulate
    an HTTP request processing by sleeping 200 milliseconds and create a simple `String`
    response via a `Callable` named `task`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: When the `WebServerHandler` is initiated, we also set up the `withLock` value.
    If this value is `true`, then our implementation will rely on a `Semaphore` with
    20 permits to limit the access of the platform threads (200) or of the unbounded
    number of virtual threads. This `Semaphore` simulates an external resource, such
    as a database that relies on a connection pool of 20 connections.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP requests (we focus only on `GET`) are handled in the overridden `handle(HttpExchange
    exchange)` method as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Once the HTTP `GET` request is processed, we have to prepare the response for
    our client and send it. This job is done via the `HttpExchange` object as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Done! Our HTTP web server is ready to rock and roll.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start the web server via `startWebServer(false, false)`, then we will
    get a web server that has 200 platform threads ready to serve in a non-locking
    context. If we set the first argument to `true`, then we switch to an unbounded
    number of virtual threads. In the following figure, you can see the heap usage
    in these two scenarios for 400 requests ramped up in 2 seconds via a JMeter test:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9.png](img/B19665_11_09.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Memory usage (lock free)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, virtual threads used less heap memory than platform threads
    being more efficient.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add locking into the equation (we set the second argument of `startWebServer()`
    to `true`), then a possible profile of heap memory looks as in the following figure:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10.png](img/B19665_11_10.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Memory usage (using locking)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even with locking, the virtual threads are still using less
    memory than platform threads. In *Chapter 13*, we will dive deeper into creating
    web servers via the JDK API, including the new features brought by JDK 18.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 241\. Hooking CompletableFuture and virtual threads
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CompletableFuture` is one of the main asynchronous programming APIs in Java
    (if you need deep coverage of this topic, then you could consider checking out
    *Java Coding Problems*, *First Edition*, *Chapter 11*).'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use `CompletableFuture` with virtual threads, we just have to use
    the proper executor for virtual threads:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Next, we use this executor to fetch three application testers in asynchronous
    mode via `CompletableFuture`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Next, we are interested in returning a `TestingTeam` only after all three of
    these `CompletableFuture` instances have completed. For this, we rely on `allOf()`
    as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If we run this code, then the output reveals the usage of three virtual threads
    in asynchronous mode:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Done! Employing virtual threads for `CompletableFuture` is quite easy.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 242\. Signaling virtual threads via wait() and notify()
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `wait()`, `notify()`, and `notifyAll()` are three methods defined in the
    `Object` class that allow multiple threads to communicate with each other and
    coordinate their access to resources without issues.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: The `wait()` method must be called only by the thread that owns the object’s
    *monitor* to force this thread to wait indefinitely until another thread calls
    `notify()` or `notifyAll()` on the same object. In other words, the `wait()` method
    must be called in a `synchronized` context (instance, block, or static method).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a virtual thread calling the `wait()` method:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'And here is another virtual thread that wakes up the previous one via the `notify()`
    call:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'At this point, nothing has happened, since `wThread` and `nThread` are not
    started. We start `wThread` and we give it 1 second to do it:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Next, we start `nThread` and give it 1 second to do it:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Finally, we log the state of `wThread`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Running this code reveals the following output:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The virtual thread #22 is our `wThread`. Initially (before calling `wait()`),
    it is in the `RUNNABLE` state, so the thread is in execution on the JVM. After
    `wait()` is called, the state of this thread is set to `WAITING`, so thread #22
    is waiting indefinitely for another thread to wake it up. This is the moment when
    the virtual thread #23 (`nThread`) calls the `notify()` method on the same object.
    After calling the `notify()` method, thread #22 wakes up, and its state is `RUNNABLE`
    again. After finishing its execution, the `wThread` state is `TERMINATED`.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this scenario is the happy path or a *good signal*. Let’s check out the
    following scenario based on the same `wThread` and `nThread`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The output will be (#22 is `wThread` and #23 is `nThread`):'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This time, `nThread` starts first and calls `notify()`. This is just a shot
    in the dark since `wThread` is not in the `WAITING` state. Later on, `wThread`
    calls `wait()` and waits indefinitely to be woken up by `nThread`. But this will
    never happen since `notify()` was already triggered, so `wThread` is blocked forever.
    In short, this is called a *missed signal*.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'When we develop concurrent applications that involve `wait()`, `notify()`,
    and `notifyAll()`, we have to ensure that the application complexity will not
    hide such *missed signals*. We can avoid *missed signals* by simply counting the
    number of `wait()` and `notify()` calls and acting accordingly. For instance,
    let’s move this logic in the object that should be signaled, and let’s call it
    `SignaledObject`. First, we have the `callWait()` method, which uses the `counter`
    as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: If no signal was missed, then the `counter` variable should be 0\. Otherwise,
    we have at least one *missed signal* (`notify()` call) so there is no reason to
    wait. We return immediately, without calling `wait()`, since this may lead to
    a deadly trap.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `callNotify()` increases the `counter` at each call as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'If we run the happy path (*good signal*) scenario, then the output will be
    as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Everything works as expected since `counter` is 0\. If we try out the missed
    signal scenario, then we have the following output:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: As you can see, we avoided the indefinite blocking by not calling `wait()`.
    We managed to elegantly handle the *missed signal*. Cool, right!?
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered 18 advanced problems about virtual threads and structured
    concurrency. You can see this chapter as a masterclass designed to help you speed
    up your learning and get ready for production with strong confidence in your knowledge.
    With that covered, you have now finished the chapter and the book.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
