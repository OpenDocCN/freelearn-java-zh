<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Functional Idioms"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Functional Idioms</h1></div></div></div><p>In the previous chapter, we covered implicit parameters and implicit conversions. We saw how to enable elegant extension methods for your code. We also had a look at how the Scala compiler resolves implicits. Finally, we covered how implicits work, how to use them, and what kind of benefits they provide.</p><p>In this chapter, we'll cover the core
<a class="indexterm" id="id316"/> concepts of functional programming like 
<code class="literal">Pure</code> functions, immutability, and higher-order functions. We'll build upon this understanding and introduce some of the design patterns that are prevalent in large functional programs that you'll no doubt run into once you start to use Scala libraries that focus on functional programming. Finally, we'll cover two popular functional programming libraries called 
<code class="literal">Cats</code> and 
<code class="literal">Doobie</code>, and use them to write some interesting programs.
</p><p>Functional programming languages have been around for a very long time, but they have gotten more traction lately, with functional programming concepts being adopted by most popular programming languages. A reason for this might be that functional programming lends itself easily to solving some problems that are hard in imperative languages, such as writing parallelizable programs. Functional programming can also increase the modularity of your programs and thus make them easier to test, reuse, and reason about, hopefully resulting in code that produces fewer bugs.</p><p>By the end of this chapter, you will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the core concepts of functional programming</li><li class="listitem" style="list-style-type: disc">Recognize and implement the popular functional programming design patterns</li><li class="listitem" style="list-style-type: disc">Implement Cats and Doobie in your own Scala projects</li></ul></div><div class="section" title="Introduction to Functional Programming Concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec31"/>Introduction to Functional Programming Concepts</h1></div></div></div><p>In this section, we will 
<a class="indexterm" id="id317"/>cover the core concepts behind functional programming and give you the necessary knowledge to understand and write simple functional programs. 
</p><p>By the end of this section, you should have a good understanding of the core concepts behind functional programming, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing and using pure functions</li><li class="listitem" style="list-style-type: disc">Using immutable classes instead of mutable classes</li><li class="listitem" style="list-style-type: disc">Writing and using higher-order functions</li></ul></div><div class="section" title="Pure Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Pure Functions</h2></div></div></div><p>At the very core of functional programming is the concept of a 
<code class="literal">pure</code> function. A function is pure if it doesn't have any side effects, that is, the function simply computes a result based on the arguments to the function and does nothing else. 
</p><p>Examples of side effects are modifying variables, setting fields on objects, performing
<a class="indexterm" id="id318"/> input/output operations such as reading or writing a file, printing values to the console, and many more. 
</p><p>Let's look at some examples of both 
<code class="literal">pure</code> and 
<code class="literal">impure</code> functions to better understand the difference. Let's have a look at two functions:
</p><div class="informalexample"><pre class="programlisting">case class Person(var name: String, var age: Int)

def birthday(p: Person) = p.age += 1

def getName(p: Person) = {
  println(s"Getting the name of ${p.name}")
  p.name
}

def rename(p: Person, name: String) = 
  Person(name, p.age)</pre></div><p>Here, we define a simple case class called 
<code class="literal">Person</code> with a 
<code class="literal">name</code> and an 
<code class="literal">age</code>. Then, we define two functions that operate on 
<code class="literal">Person</code>. Can you see why these functions are not pure functions? To test if these functions are pure, we could try to invoke them with the same arguments twice to see if we get different results – remember, a pure function is a function that simply computes a result based on the arguments to the function and does nothing else.
</p><p>Let's start with 
<code class="literal">birthday:</code>
</p><div class="informalexample"><pre class="programlisting">val p = Person("Jack", 41)
birthday(p)
println(p) // prints Person(Jack,42)
birthday(p)
println(p) // prints Person(Jack,43)</pre></div><p>Alright, so 
<code class="literal">birthday</code> isn't a pure function as it's modifying the state of the 
<code class="literal">Person p</code> passed to the function. We also might have been able to guess this as the return
<a class="indexterm" id="id319"/> type of birthday is 
<code class="literal">Unit</code> – as the function doesn't return a value, it must be doing some side effects, otherwise the function would be completely useless.
</p><p>Next up, let's take a look at 
<code class="literal">getName:</code>
</p><div class="informalexample"><pre class="programlisting">val n1 = getName(p) // Getting the name of Jack
val n2 = getName(p) // Getting the name of Jack
println(n1) // Jack
println(n2) // Jack</pre></div><p>The good news is that the function returns the name value and provides the same arguments. However, the function is still not pure as it prints to the console whenever it's invoked.</p><p>Lastly, let's have a look at 
<code class="literal">rename:</code>
</p><div class="informalexample"><pre class="programlisting">val r1 = rename(p, "John")
val r2 = rename(p, "John")
println(r1) // Person(John,43)
println(r2) // Person(John,43)</pre></div><p>Alright, so 
<code class="literal">rename</code> is a pure function. When provided with the same argument, it produces the same value and doesn't perform any observable side effects.
</p><p>We have now covered the concept of a pure function and seen examples of both pure and impure functions. You've seen two ways to define what a pure function is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When provided with the same argument, it produces the same value and doesn't perform any observable side effects.</li><li class="listitem" style="list-style-type: disc">A pure function is a function that only consists of referentially transparent expressions. An expression is referentially transparent if it can be replaced with its value without changing the behavior of the program.</li></ul></div><p>In the next subsection, we'll look
<a class="indexterm" id="id320"/> at immutability, which is another core concept that enables the writing of pure functions.
</p></div><div class="section" title="Immutability"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Immutability</h2></div></div></div><p>With the 
<a class="indexterm" id="id321"/>understanding of what a pure function is, it's time to introduce another core concept that enables the writing of pure functions: immutability. Something is said to be immutable if you can't change it – it's the opposite of mutable.
</p><p>One of the reasons Scala is so well suited for functional programming is that it provides constructs
<a class="indexterm" id="id322"/> where immutability is guaranteed. Let's look at some examples.
</p><p>If we define a variable or field on a class using the 
<code class="literal">val</code> keyword (rather than 
<code class="literal">var</code>), then the Scala compiler will not allow us to change that value.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open Terminal on your computer. </li><li class="listitem">Start the Scala REPL by typing <code class="literal">scala.</code></li><li class="listitem">Now, you can start pasting in the code after <code class="literal">scala&gt;:</code><div class="informalexample"><pre class="programlisting">scala&gt; val x = "test"
x: String = test

scala&gt; x = "test 2"
&lt;console&gt;:12: error: reassignment to val
       x = "test 2"</pre></div></li><li class="listitem">The expected output is shown on the line below <code class="literal">scala&gt;</code>.</li><li class="listitem">However, Scala can't guarantee that you don't modify the state of the<a class="indexterm" id="id323"/> value that was assigned to a variable, for example:<div class="informalexample"><pre class="programlisting">scala&gt; case class Person(var name: String)
defined class Person

scala&gt; val p = Person("Jack")
p: Person = Person(Jack)

scala&gt; p.name
res0: String = Jack
scala&gt; p.name = "John"
p.name: String = John

scala&gt; p
res1: Person = Person(John)</pre></div></li><li class="listitem">However, if we remove the <code class="literal">var</code> keyword, Scala will, by default, declare the field name using <code class="literal">val</code> and thus won't allow us to change it, thereby enforcing immutability.</li></ol></div><div class="section" title="Implementing the standard library"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec10"/>Implementing the standard library</h3></div></div></div><p>The
<a class="indexterm" id="id324"/> standard library in Scala has a whole collection of immutable data structures in the 
<code class="literal">scala.collection.immutable </code>package.
</p><p>The most used of these is perhaps 
<code class="literal">scala.collection.immutable.List</code>, which is imported in 
<code class="literal">Predef</code> and thus accessible in Scala programs simply as 
<code class="literal">List:</code>
</p><div class="informalexample"><pre class="programlisting">scala&gt; val xs = List(1,2,3)
xs: List[Int] = List(1, 2, 3)

scala&gt; xs.reverse
res0: List[Int] = List(3, 2, 1)
scala&gt; xs
res1: List[Int] = List(1, 2, 3)</pre></div><p>Here, you can see that 
<code class="literal">xs.reverse</code> returns a new 
<code class="literal">List</code> that is reversed and leaves 
<code class="literal">x</code>
<code class="literal">s</code> unmodified.
</p><p>Scala provides constructs where immutability is guaranteed and has many defaults where immutability is used, such as when defining case classes or using some of the immutable collection that is provided by the standard library. In the next subsection, we'll look at higher-order functions, which you'll be using extensively when writing programs in Scala using functional programming.</p></div></div><div class="section" title="Higher-Order Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Higher-Order Functions</h2></div></div></div><p>Higher-order functions are functions that take other functions as arguments. This is a technique that is widely used in Scala, and one that you will use all the time when you're writing Scala programs. Higher-order functions have already been covered previously, but we will include a short recap here for completeness.</p><p>Here's an example
<a class="indexterm" id="id325"/> of using the higher-order function map on 
<code class="literal">List</code> to invoke a function on every item of the list to produce a new 
<code class="literal">List:</code>
</p><div class="informalexample"><pre class="programlisting">scala&gt; val xs = List(1,2,3,4,5)
xs: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; xs.map(_ * 2)
res0: List[Int] = List(2, 4, 6, 8, 10)</pre></div><p>Note that this example uses pure functions, immutability, and higher-order functions – the perfect functional program.</p><p>Here's an example of how to define a higher-order function. It takes a function from 
<code class="literal">A =&gt; Boolean</code> and returns a function of 
<code class="literal">A =&gt; Boolean</code> that negates the result of the original function:
</p><div class="informalexample"><pre class="programlisting">def negate[A](f: A =&gt; Boolean): A =&gt; Boolean =
  (a: A) =&gt; !f(a)</pre></div><p>We'll write
<a class="indexterm" id="id326"/> a higher-order function that finds the second element in a list given a predicate:
</p><div class="informalexample"><pre class="programlisting">def sndWhere[A](xs: List[A])(pred: A =&gt; Boolean): Option[A] = ???</pre></div><p>Here are two examples of using the function:</p><div class="informalexample"><pre class="programlisting">println(sndWhere(List(1,3,2,4,4))(_ &gt; 2)) // Some(4)
println(sndWhere(List(1,3,2,4,4))(_ &gt; 10)) // None</pre></div><p>Now, try to write your own higher-order function to get a better feeling for how they work.  </p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new Scala file in your editor named <code class="literal">HOExample.scala.</code></li><li class="listitem">Paste in the following code:<div class="informalexample"><pre class="programlisting">object HOExample extends App {
  def sndWhere[A](xs: List[A])(pred: A =&gt; Boolean): Option[A] = ???
  println(sndWhere(List(1, 3, 2, 4, 4))(_ &gt; 2)) // Some(4)
  println(sndWhere(List(1, 3, 2, 4, 4))(_ &gt; 10)) // None
}</pre></div></li><li class="listitem">This higher-order function should find the second element in a list given a predicate.</li><li class="listitem">When <a class="indexterm" id="id327"/>you run the application in your editor, you should see the following output:<div class="informalexample"><pre class="programlisting">Some(4) 
None</pre></div></li><li class="listitem">One possible solution is:<div class="informalexample"><pre class="programlisting">  def sndWhere[A](xs: List[A])(pred: A =&gt; Boolean): Option[A] =  

    xs.filter(pred) match { 

      case _ :: snd :: _ =&gt; Some(snd) 

      case _             =&gt; None 

    }</pre></div></li></ol></div><p>We've gotten a recap of what higher-order functions are and seen how they can be used to write generic functions where some of the functionality of the function is provided by an argument to the function.</p><p>In the next section, we'll move beyond the basic concepts behind functional programming and look at some of the functional design patterns that you'll encounter when using functional libraries.</p><p>You've seen three of the cornerstones of functional programming: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pure functions</strong></span>: A function simply computes a result based on the arguments to the function and does nothing else.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Immutability</strong></span>: You've seen how Scala has good support for immutability and uses it as the default in many cases.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Higher-order functions</strong></span>: Functions that take others as arguments or return a function are called higher-order functions.</li></ul></div></div></div></div>
<div class="section" title="Functional Design Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec32"/>Functional Design Patterns</h1></div></div></div><p>In this section, we 
<a class="indexterm" id="id328"/>are moving beyond the basic concepts behind functional programming and looking at some of the functional design patterns that you'll encounter when using functional libraries. You will be introduced to 
<code class="literal">Monoids</code>, 
<code class="literal">Functors</code>, 
<code class="literal">Monads</code>, and other functional programming 
<a class="indexterm" id="id329"/>patterns that
<a class="indexterm" id="id330"/> you can use to structure your programs – these patterns are the functional programming equivalent of the object-oriented design patterns that you might be familiar with from when you first learned about OOP.
</p><p>Have you ever heard of category theory? The patterns we'll see in this section come from 
<a class="indexterm" id="id331"/>category theory. Each concept (such as a 
<code class="literal">Monoid</code>) has a clear mathematical definition and set of associated laws.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>In this section, we won't go into detail regarding these laws, but should you want to research this topic further, it's good to know that the field is called category theory.</p></div></div><p>This will set you up for further study of functional design patterns and enable you to use some of the most popular functional programming libraries such as 
<code class="literal">Cats</code> and 
<code class="literal">Scalaz.</code>
</p><p>The
<a class="indexterm" id="id332"/> following subsections will each introduce an abstract structure, show its definition in Scala, and show how to use it when you write your programs – the structures might seem very abstract at first, but please be patient, as the examples will show you how the structures can be very useful.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The following code will heavily use type classes, so please refer back to the previous chapters to make sure you have a good understanding of them.</p></div></div><div class="section" title="Monoids"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Monoids</h2></div></div></div><p>The first
<a class="indexterm" id="id333"/> structure we'll take a look at is called a 
<code class="literal">Monoid</code>. A 
<code class="literal">Monoid</code> is a very simple structure, but it's one that you'll encounter all the time once you've learned to recognize it.
</p><p>A 
<code class="literal">Monoid</code> has 
<a class="indexterm" id="id334"/>two operations, 
<code class="literal">combine</code> and 
<code class="literal">empty</code>. In Scala, the definition of a Monoid could be expressed as a type class like the following:
</p><div class="informalexample"><pre class="programlisting">trait Monoid[A] {
  def combine(x: A, y: A): A
  def empty: A
}</pre></div><p>That is, instances of the 
<code class="literal">Monoid</code> type class support two operations:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">combine</code>: This <a class="indexterm" id="id335"/>operation takes two arguments of type <code class="literal">A</code> and returns an <code class="literal">A</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">empty</code>: This <a class="indexterm" id="id336"/>operation doesn't take any arguments but it returns an <code class="literal">A</code>.</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>In category theory, these operations are called 
<code class="literal">multiplication</code> and 
<code class="literal">unit</code>. This might be useful if you want to learn more about this topic at a later date.
</p></div></div><p>This is very abstract, so let's make it concrete by looking at some examples.</p><p>Let's look at one of 
<a class="indexterm" id="id337"/>the instances of the 
<code class="literal">Monoid</code> type class to get a better feeling for how it works and how you can use it.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a <code class="literal">Monoid</code> type class instance for <code class="literal">String</code>, that is, a <code class="literal">Monoid[String]:</code><div class="informalexample"><pre class="programlisting">implicit val strMonoid = new Monoid[String] {
  def combine(x: String, y: String): String = x + y
 def empty: String = ""
}</pre></div></li><li class="listitem">Define the <code class="literal">stringMonoid</code> as follows:<div class="informalexample"><pre class="programlisting">strMonoid.combine("Monoids are ", "great")
strMonoid.combine("Hello", strMonoid.empty)</pre></div></li></ol></div><p>In most cases, you won't refer to a concrete instance of Monoid as explicitly as we've done here, but rather you'll use the 
<code class="literal">Monoid</code> type class when writing polymorphic functions, as you'll see in the example after the exercises.
</p><p>Let's create implicit def for Monoid creation.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write an instance of <code class="literal">Monoid</code> for <code class="literal">Int:</code><div class="informalexample"><pre class="programlisting">implicit val intMonoid = new Monoid[Int] {
    def combine(x: Int, y: Int): Int = x + y
    def empty: Int = 0
  }</pre></div></li><li class="listitem">Write an <code class="literal">implicit def</code> that can create a <code class="literal">Monoid[List[A]]</code> for any <code class="literal">A:</code><div class="informalexample"><pre class="programlisting">implicit def listMonoid[A]: Monoid[List[A]] = 
  new Monoid[List[A]] {
   def combine(x: List[A], y: List[A]): List[A] = ???
    def empty: List[A] = ???
  }</pre></div></li></ol></div><div class="section" title="Using Monoids to Write Polymorphic Functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec11"/>Using Monoids to Write Polymorphic Functions</h3></div></div></div><p>Even though the 
<code class="literal">Monoid</code> might seem simple, it is immensely useful. The power of 
<code class="literal">Monoid</code>, and the other structures that you'll be introduced to later, come into
<a class="indexterm" id="id338"/> play when we define polymorphic functions that know nothing about their arguments other than the fact that a 
<code class="literal">Monoid</code> instance for their types exists.
</p><p>Let's write a function that takes the sum of a list:</p><div class="informalexample"><pre class="programlisting">def sum[A](xs: List[A])(implicit m: Monoid[A]): A = xs.foldLeft(m.empty)(m.combine)</pre></div><p>The first 
<a class="indexterm" id="id339"/>parameter list is straightforward – it defines that the function takes a 
<code class="literal">List</code> of the different 
<code class="literal">A</code> values. However, the second implicit parameter list asks the compiler to find an instance of 
<code class="literal">Monoid</code> for 
<code class="literal">A</code> and will only allow you to invoke 
<code class="literal">sum[A]</code> if an instance of 
<code class="literal">Monoid[A] exists.</code>
</p><p>With this function, you can take the 
<code class="literal">sum</code> of any 
<code class="literal">List</code> as long as there is an appropriate instance of 
<code class="literal">Monoid</code> in scope:
</p><div class="informalexample"><pre class="programlisting">sum(List("Monoids", " are", " cool")) // "Monoids are cool"
sum(List(1,2,3)) // 6
sum(List(List(1,2),List(3,4)) // List(1,2,3,4)</pre></div><p>We looked at the first structure, the Monoid. We saw that even though the Monoid has a very simple interface, it showed itself to be a useful construct that allowed us to write interesting polymorphic functions. In the next section, we'll look at 
<code class="literal">Functors</code>. Put simply, a Functor is something that you can map over.
</p></div></div><div class="section" title="Functor"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Functor</h2></div></div></div><p>The second
<a class="indexterm" id="id340"/> structure we'll look at is the 
<code class="literal">Functor</code>. Put simply, a 
<code class="literal">Functor</code> is something that you can map over. In Scala, you'll be 
<a class="indexterm" id="id341"/>very familiar with this operation as you've no doubt used it multiple times to manipulate 
<code class="literal">Lists</code>, 
<code class="literal">Options</code>, and so on. In Scala, the type class for 
<code class="literal">Functors</code> could look something like this:
</p><div class="informalexample"><pre class="programlisting">trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>The 
<code class="literal">Functor</code> abstracts over a type constructor, 
<code class="literal">F</code> – types that abstract over type constructors are called higher types.
</p></div></div><p>You might 
<a class="indexterm" id="id342"/>be tempted to think of 
<code class="literal">map</code> as a convenient way to iterate over a collection such as 
<code class="literal">List</code> or 
<code class="literal">Set</code>, but in the context of Functor, there's a more interesting way to look at it. You should think of 
<code class="literal">map</code> as a way of sequencing operations on some type that preserves the structure of the type as defined by the specificities of the type. The details will vary depending on the type:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Option</strong></span>: There might not be a value.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>List</strong></span>: There might be zero or more values.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Either</strong></span>: There might be an error or there might be a value – not both.</li></ul></div><p>Let's look at some c
<a class="indexterm" id="id343"/>oncrete examples to make this more clear.
</p><p>Let's now evaluate the same thing in different contexts.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a polymorphic function that abstracts over different Functors:<div class="informalexample"><pre class="programlisting">def compute[F[_]](fa: F[Int])(implicit f: Functor[F]): F[Int] = {
 val fx = f.map(fa) { _ + 2 }
  f.map(fx) { _ * 2}
}</pre></div><p>It defines a function, 
<code class="literal">compute</code>, that first uses 
<code class="literal">map</code> to add 
<code class="literal">2</code> to the value inside the functor and then uses map to multiply the result by 
<code class="literal">2</code>.
</p></li><li class="listitem">We can now invoke this method with any value that has a <code class="literal">Functor</code> instance defined:<div class="informalexample"><pre class="programlisting">compute(List(1,2,3)) // List(6, 8, 10)compute(Option(2) // Some(8)
compute(Right(2): Either[String, Int]) // Right(8)</pre></div></li></ol></div><p>With this
<a class="indexterm" id="id344"/> exercise in mind, you can see how Functor allows you to write polymorphic functions that know nothing about their arguments other than that there's a map function defined for them. It's up to the specific Functor to define what map means in its specific context.
</p><p>Let's define and use a Functor for 
<code class="literal">List</code> and 
<code class="literal">Option</code>.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a <code class="literal">Functor</code> for <code class="literal">List:</code><div class="informalexample"><pre class="programlisting">implicit val listFunctor = new Functor[List] {
  def map[A, B](fa: List[A])(f: A =&gt; B): List[B] = fa.map(f)
}</pre></div></li><li class="listitem">Using it would then look something like this:<div class="informalexample"><pre class="programlisting">listFunctor.map(List(1,2,3))(_ * 2)</pre></div></li></ol></div><p>
<span class="strong"><strong>Defining Functor for Option</strong></span>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write an <a class="indexterm" id="id345"/>instance of <code class="literal">Functor</code> for <code class="literal">Option:</code><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>The solution can be found in 
<code class="literal">Examples/src/main/scala/Functor.scala</code>, defined as 
<code class="literal">optionFunctor.</code>
</p></div></div><div class="informalexample"><pre class="programlisting"> implicit val optionFunctor = new Functor[Option] {
    def map[A, B](fa: Option[A])(f: A =&gt; B): Option[B] = fa match {
      case None =&gt; None
      case Some(x) =&gt; Some(f(x))
    }</pre></div></li></ol></div><p>We looked 
<a class="indexterm" id="id346"/>at our second structure, the Functor, which represents things that can be mapped over. You saw how to define instances for Functor and how one can think of 
<code class="literal">map</code> as a way of sequencing operations on some type that preserves the structure of the type, as defined by the specificities of the type. In the next section, we'll look at Monads – a structure that you might already be familiar with without knowing it.
</p></div><div class="section" title="Monads"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Monads</h2></div></div></div><p>The last structure 
<a class="indexterm" id="id347"/>we'll look at is the 
<code class="literal">Monad</code>. Most 
<a class="indexterm" id="id348"/>Scala programmers will be familiar with Monads, even if they don't know them by name, as the abstraction is used whenever 
<a class="indexterm" id="id349"/>you write a 
<code class="literal">for-comprehension</code>. A 
<a class="indexterm" id="id350"/>Monad has two operations, 
<code class="literal">pure</code> and 
<code class="literal">flatMap:</code>
</p><div class="informalexample"><pre class="programlisting">trait Monad[F[_]] extends Functor[F] {
  def flatMap[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
  def pure[A](x: A): F[A]
def map[A, B](fa: F[A])(f: A =&gt; B): F[B] =
    flatMap(fa)(f andThen pure)
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>Note that the category theory names for the 
<code class="literal">flatMap</code> operation is 
<code class="literal">bind,</code> and the name for 
<code class="literal">pure</code> is 
<code class="literal">unit.</code>
</p></div></div><p>Recall from the
<a class="indexterm" id="id351"/> previous section that you can think of Functors as a way to sequence operations on some type that preserves the structure of the type, as defined by the specificities of the type. Well, the same is true of a Monad, expect they're a bit more powerful. For Functors, the complications can only occur in the beginning of the sequence whereas with Monads, they can occur in any part of the sequence.
</p><p>Let's look at 
<a class="indexterm" id="id352"/>an example:
</p><div class="informalexample"><pre class="programlisting">Option(10).map(_ + 1).map(_ * 4)
res3: Option[Int] = Some(44)</pre></div><p>What if one of the operations returned an Option?</p><div class="informalexample"><pre class="programlisting">def big(i: Int): Option[Int] = 
  if (i &gt; 5) Some(i) 
  else None

big(10).map(_ - 5).map(big)
res3: Option[Option[Int]] = Some(None)</pre></div><p>Now, we have a value of type 
<code class="literal">Option[Option[Int]],</code> which isn't very convenient. This is where 
<code class="literal">Monad</code> comes in handy. If you have a sequence of operations where you want some specificities of some type to be preserved on every step, you'll want to use a 
<code class="literal">Monad</code>. 
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>As you can see from the preceding definition, a Monad is also a Functor, as map can be implemented in terms of 
<code class="literal">flatMap</code> and 
<code class="literal">pure.</code>
</p></div></div><p>Here's how you 
<a class="indexterm" id="id353"/>can define a Monad for Option:
</p><div class="informalexample"><pre class="programlisting">implicit val optionMonad = new Monad[Option] {
  def pure[A](x: A): Option[A] = Some(x)
  def flatMap[A, B](fa: Option[A])(f: A =&gt; Option[B]): Option[B] = fa match {
    case Some(x) =&gt; f(x)
    case None =&gt; None
  }
}</pre></div><p>
<code class="literal">pure</code> is defined by simply wrapping the value in 
<code class="literal">Some</code>. 
<code class="literal">flatMap</code> is defined by pattern matching on the value and applying the function if it's 
<code class="literal">Some,</code> otherwise returning 
<code class="literal">None.</code>
</p><p>We can avoid the previous inconvenient situation of having an 
<code class="literal">Option[O</code>
<code class="literal">ption[Int]]:</code>
</p><div class="informalexample"><pre class="programlisting">flatMap(map(big(10))(_ - 5))(big)</pre></div><p>We have seen the definition of the Monad and how it can be used to sequence operations in a specific context where each step in the sequence needs to preserve some specificities that depend on the instance of the Monad.</p></div></div>
<div class="section" title="Popular Libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec33"/>Popular Libraries</h1></div></div></div><p>By this point, you 
<a class="indexterm" id="id354"/>should have a good understanding of the main concepts behind functional programming such as pure functions, immutability, and higher-order functions. In addition to that, you should be familiar with some of the most popular abstractions used when writing functional programs. With all of this knowledge, you are well equipped to start looking into some of the popular functional programming libraries in Scala.
</p><p>In this section, we'll look at some of the popular functional programming libraries from the Scala ecosystem. After this section, you should be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the <code class="literal">Cats</code><code class="literal">Validated</code> type class to validate your data</li><li class="listitem" style="list-style-type: disc">Use <code class="literal">Doobie</code> to talk to databases</li></ul></div><div class="section" title="Validating Data Using Cats"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Validating Data Using Cats</h2></div></div></div><p>In this 
<a class="indexterm" id="id355"/>section, we'll get a quick overview of the 
<a class="indexterm" id="id356"/>Cats library and look at one of the data types 
<a class="indexterm" id="id357"/>it provides to 
<code class="literal">Validate</code> data.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>For more
<a class="indexterm" id="id358"/> information on Cats, refer to 
<a class="ulink" href="https://github.com/typelevel/cats">https://github.com/typelevel/cats</a>.
</p></div></div><p>By the 
<a class="indexterm" id="id359"/>end of this section, you should understand how 
<code class="literal">Cats</code> fits into the Scala ecosystem and know how to use it in your own projects, specifically to validate your data.
</p></div><div class="section" title="Prerequisites for Using Cats"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Prerequisites for Using Cats</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You need to <a class="indexterm" id="id360"/>add <code class="literal">Cats</code> as a dependency to your Scala project. Create a new SBT project with the following <code class="literal">build.sbt</code> file:<div class="informalexample"><pre class="programlisting">name := "cats-example"

scalaVersion := "2.12.4"
libraryDependencies += "org.typelevel" %% "cats-core" % "1.0.0"

scalacOptions ++= Seq(
  "-Xfatal-warnings",
  "-Ypartial-unification"
)</pre></div></li><li class="listitem">As <code class="literal">Cats</code> relies heavily on implicits to provide type class instances and extension methods, you always need to have the following imports in your files when you're using <code class="literal">Cats:</code><div class="informalexample"><pre class="programlisting">import cats._
import cats.implicits._</pre></div></li></ol></div></div><div class="section" title="Introduction to Cats"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec102"/>Introduction to Cats</h2></div></div></div><p>Cats is a library 
<a class="indexterm" id="id361"/>which provides abstractions for functional programming in the Scala programming language. Specifically, it provides definitions for all of 
<a class="indexterm" id="id362"/>the patterns you saw in the previous section (Monoid, Monad, and so on) and many more. It also contains type class instances for all of the relevant classes from the Scala standard library.
</p><p>The broader goal of Cats is to provide a foundation for an ecosystem of pure, typeful libraries to support functional programming in Scala applications.</p></div><div class="section" title="Validating Data"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Validating Data</h2></div></div></div><p>There are two 
<a class="indexterm" id="id363"/>different ways to validate data using Cats. The first is 
<code class="literal">Either,</code> as you know it from the standard library, and the 
<a class="indexterm" id="id364"/>other is 
<code class="literal">Validated</code>. You should use 
<code class="literal">Either</code> if you want your validation to fail-fast and you should use 
<code class="literal">Validated</code> if you want to accumulate the errors. Which one you should use depends on your use case. As you might be familiar with 
<code class="literal">Either</code> from the standard library, we'll focus on 
<code class="literal">Validated</code> in this subsection.
</p><p>First, let's have a look at a basic domain model and some constraints we have for the data. Let's assume you have a 
<code class="literal">User</code> that looks like the following:
</p><div class="informalexample"><pre class="programlisting">final case class User(
  username: String,
  age: Int
)</pre></div><p>Let's also assume that you have the following rules for this user:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The username has to contain at least three characters.</li><li class="listitem" style="list-style-type: disc">The username can only contain alphanumeric characters.</li><li class="listitem" style="list-style-type: disc">The age has to be positive.</li></ul></div><p>We can
<a class="indexterm" id="id365"/> represent these three errors in Scala 
<a class="indexterm" id="id366"/>using a sealed trait with case objects like this:
</p><div class="informalexample"><pre class="programlisting">sealed trait Error {
  def message: String
}

case object SpecialCharacters extends Error {
  val message: String = "Value can't contain special characters"
}

case object TooShort extends Error {
  val message: String = "Value is too short"
}

case object ValueTooLow extends Error {
  val message: String = "Value is too low"
}</pre></div><p>Let's look at how we could write the preceding rules in Scala using 
<code class="literal">Validated.</code>
</p></div><div class="section" title="Validating Using Validated"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Validating Using Validated</h2></div></div></div><p>The 
<a class="indexterm" id="id367"/>
<code class="literal">Validated</code> data type
<a class="indexterm" id="id368"/> is defined like this:
</p><div class="informalexample"><pre class="programlisting">sealed abstract class Validated[+E, +A] extends Product with Serializable
final case class Valid[+A](a: A) extends Validated[Nothing, A]
final case class Invalid[+E](e: E) extends Validated[E, Nothing]</pre></div><p>Here, 
<code class="literal">Valid[A]</code> represents a value 
<a class="indexterm" id="id369"/>of type 
<code class="literal">A</code> that passed some kind of validation, and 
<code class="literal">Invalid[A]</code> represents that some validation failed, producing an error of type 
<code class="literal">E</code>. Let's try to
<a class="indexterm" id="id370"/> implement the rules from the previous section:
</p><div class="informalexample"><pre class="programlisting">def validateAge(age: Int): Validated[NonEmptyList[Error], Int] =
    if (age &gt;= 1) age.validNel
    else ValueTooLow.invalidNel</pre></div><p>Here, we define a method, 
<code class="literal">validateAge</code>, which takes an 
<code class="literal">Int</code> and returns 
<code class="literal">Validated[NonEmptyList[Error], Int]</code>, meaning that it will either return 
<code class="literal">Valid(age)</code> if it's valid or 
<code class="literal">Invalid(NonEmptyList(ValueTooLow))</code> if it's not. We use the extension methods 
<code class="literal">validNel</code> and 
<code class="literal">invalidNel</code> that 
<code class="literal">Cats</code> provides for your convenience.
</p><p>Next up, let's define a validator for the username:</p><div class="informalexample"><pre class="programlisting">private def checkLength(str: String): Validated[NonEmptyList[Error], String] =
  if (str.length &gt; 3) str.validNel
  else TooShort.invalidNel

private def checkSpecialCharacters(str: String): Validated[NonEmptyList[Error], String] =
  if (str.matches("^[a-zA-Z]+$")) str.validNel
  else SpecialCharacters.invalidNel

def validateUsername(username: String): Validated[NonEmptyList[Error], String] =
  (checkLength(username), checkSpecialCharacters(username)).mapN { 
    case (a, _) =&gt; a 
  }</pre></div><p>In this case, we're defining two helper functions, 
<code class="literal">checkLength</code> and 
<code class="literal">checkSpecialCharacters</code>, which check that the string is longer than 3 characters and doesn't contain any alphanumeric characters. We combine these two checks using
<a class="indexterm" id="id371"/> the 
<code class="literal">mapN</code> extension method that Cats provides on tuples. If both checks pass, the 
<code class="literal">mapN</code> function will be invoked with a tuple containing both the valid
<a class="indexterm" id="id372"/> values, but we're only interested in the username once we simply return the first valid value.
</p><p>Finally, let's write the method that validates both the username and the age and returns a 
<code class="literal">User</code> if everything is valid:
</p><div class="informalexample"><pre class="programlisting">def validate(username: String, age: Int) =
    (validateUsername(username), validateAge(age)).mapN { User.apply }</pre></div><p>Again, we use the 
<code class="literal">mapN</code> method and pass in a function that should be invoked if all checks pass. In this case, we use the 
<code class="literal">apply</code> method on 
<code class="literal">User</code> to create an instance of 
<code class="literal">User.</code>
</p><p>If you invoke this, you can see that it accumulates the errors if there are any; otherwise, it returns a 
<code class="literal">User</code> that has been validated:
</p><div class="informalexample"><pre class="programlisting">User.validate("!!", -1)
// Invalid(NonEmptyList(TooShort, SpecialCharacters, ValueTooLow))

User.validate("jack", 42)
// Valid(User(jack,42))</pre></div><p>By now, you should know how to add Cats to your Scala projects and know how to use their 
<code class="literal">Validated</code> data type to write validation methods for your domain models in a nice, functional way. In the next section, we'll have a look at how to use the 
<code class="literal">Doobie</code> library to communicate with databases in a functional type-safe manner.
</p></div><div class="section" title="Communicating with Databases Using Doobie"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Communicating with Databases Using Doobie</h2></div></div></div><p>In this subsection, we'll use the 
<a class="indexterm" id="id373"/>
<code class="literal">Doobie</code> library to 
<a class="indexterm" id="id374"/>communicate with databases in a functional and type-safe manner. You will be introduced to the core concepts of 
<code class="literal">Doobie</code> and see 
<a class="indexterm" id="id375"/>how to use it to query, update, and delete rows in your database.
</p><p>After this subsection, you should be able to use 
<code class="literal">Doobie</code> in your own Scala projects for simple queries and insertions, and know where to find documentation for more advanced use cases.
</p><div class="section" title="Prerequisites for Doobie"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec12"/>Prerequisites for Doobie</h3></div></div></div><p>You need to
<a class="indexterm" id="id376"/> add Doobie as a dependency to your Scala project. Create a new SBT project with the following 
<code class="literal">build.sbt</code> file:
</p><div class="informalexample"><pre class="programlisting">scalaVersion := "2.12.4"

lazy val doobieVersion = "0.5.0-M13"

libraryDependencies ++= Seq(
  "org.tpolecat" %% "doobie-core"   % doobieVersion,
  "org.tpolecat" %% "doobie-h2"     % doobieVersion
)</pre></div><p>Doobie can talk to many different databases, such as MySQL, Postgres, H2, and so on. In the following examples, we'll use the in-memory database H2 to simplify the setup. Have a look at the documentation to see how to use the other databases.</p><p>The database
<a class="indexterm" id="id377"/> tables we'll use in these examples are quite simple. There are two tables, 
<code class="literal">user</code> and 
<code class="literal">todo</code>, which have the following SQL definitions:
</p><div class="informalexample"><pre class="programlisting">CREATE TABLE user (
  userId INT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(255) NOT NULL,
  age INT NOT NULL
);

CREATE TABLE todo (
  todoId INT AUTO_INCREMENT PRIMARY KEY,
  userId INT NOT NULL,
  title VARCHAR(255) NOT NULL,
  completed BOOL DEFAULT false,
  FOREIGN KEY (userId) references user(userId)
);</pre></div></div></div><div class="section" title="Doobie"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Doobie</h2></div></div></div><p>In Doobie, to make
<a class="indexterm" id="id378"/> large programs, you need to write small programs. After creating the program, you can directly drop it into your main function and use it as an effectful monad.
</p><p>Doobie has a high-level and a low-level API. In this lecture, we'll focus exclusively on the high-level API. In the high-level API, there are only a handful of important classes. The two most important are 
<code class="literal">ConnectionIO</code> and 
<code class="literal">Transactor.</code>
</p><div class="section" title="ConnectionIO"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec13"/>ConnectionIO</h3></div></div></div><p>The 
<a class="indexterm" id="id379"/>most common types you will deal with have the 
<a class="indexterm" id="id380"/>form 
<code class="literal">ConnectionIO[A]</code>, specifying computations that take place in a context where a 
<code class="literal">java.sql.Connection</code> is available, ultimately producing a value of type 
<code class="literal">A</code>. 
</p><p>
<code class="literal">ConnectionIO[A]</code>
<a class="indexterm" id="id381"/> is the most common types you will come across, and it specifies the calculations that occur where 
<code class="literal">java.sq</code>
<code class="literal">l.Connection</code> is available, which generates a value of type 
<code class="literal">A</code>.
</p></div><div class="section" title="Transactor"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec14"/>Transactor</h3></div></div></div><p>A 
<code class="literal">Transactor</code> is a structure which is used 
<a class="indexterm" id="id382"/>for database connectivity, connection handouts, and cleanup; it can take a 
<code class="literal">ConnectionIO[A]</code> and produce an 
<code class="literal">IO[A]</code>, which provides an executable code. It specifically provides you an 
<code class="literal">IO</code> that, when executed, will connect to the database and run the program in a single transaction.
</p><p>Here's a full example that creates a 
<code class="literal">Transactor</code> that can connect to the H2 database. We then use that 
<code class="literal">transactor</code> to perform the simple query 
<code class="literal">SELECT</code>
<code class="literal">42:</code>
</p><div class="informalexample"><pre class="programlisting">package com.example

import doobie._
import doobie.implicits._
import cats.effect.IO

object ExampleConnection extends App {

  val transactor =
    Transactor.fromDriverManager[IO](
      "org.h2.Driver", "jdbc:h2:mem:test", "", ""
    )
 val program: ConnectionIO[Int] =
    sql"select 42".query[Int].unique

  val task: IO[Int] =
    program.transact(transactor)

  val result: Int =
    task.unsafeRunSync

  println(s"Got result ${result}")

}</pre></div><p>The 
<a class="indexterm" id="id383"/>preceding example creates a 
<code class="literal">Transactor</code> using 
<code class="literal">Transactor.fromDriverManager</code> and then creates a small program that, when provided with a 
<code class="literal">Connection</code>, will run 
<code class="literal">SELECT 42</code>. Finally, the program is 
<a class="indexterm" id="id384"/>turned into an 
<code class="literal">IO</code> monad using the transact method on 
<code class="literal">ConnectionIO,</code> and the 
<code class="literal">IO</code> monad is executed using 
<code class="literal">unsafeRunSync</code> to produce an 
<code class="literal">Int</code> that is the result of executing 
<code class="literal">SELECT 42</code>. It's important to understand that no side effects are occurring until the 
<code class="literal">IO</code> monad is executed using 
<code class="literal">unsfaceRunSync.</code>
</p><p>Next up, let's have a look at how to write queries.</p></div><div class="section" title="Selecting Rows"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec15"/>Selecting Rows</h3></div></div></div><p>Now that we've 
<a class="indexterm" id="id385"/>seen how to use the 
<code class="literal">ConnectionIO</code> and 
<code class="literal">Transactor</code>, let's have a look at some more interesting queries to perform a very simply query.
</p><p>Let's start by examining the following expression from the previous example:</p><div class="informalexample"><pre class="programlisting">val fragment: Fragment = sql"select 42"
val query: Query0[Int] = fragment.query[Int]
val program = query.unique</pre></div><p>We use the
<a class="indexterm" id="id386"/> Doobies string interpolation function 
<code class="literal">sql</code> to turn a normal 
<code class="literal">String</code> into a 
<code class="literal">Fragment</code>. A 
<code class="literal">Fragment</code> is simply Doobie's representation of parts of an SQL query, which may include interpolated values. 
<code class="literal">Fragments</code> can be composed by concatenation, which maintains the correct offset and mappings for interpolated values. In this lecture, we won't go into detail with what you can do with 
<code class="literal">Fragments</code>, but you can find more information in the documentation.
</p><p>Once you have a 
<code class="literal">Fragment</code>, you can turn it into a 
<code class="literal">Query</code> using the 
<code class="literal">query[A]</code> method on 
<code class="literal">Fragment</code>. 
<code class="literal">Query[A, B]</code> is Doobie's representation for a complete SQL query that takes some input of type 
<code class="literal">A</code> and produces some output of type B. In this specific example, our query doesn't take any input, so the specific type 
<code class="literal">Query0</code> is returned, which represents a query that doesn't take any parameters.
</p><p>Finally, a 
<code class="literal">ConnectionIO[Int]</code> is produced by using the 
<code class="literal">unique</code> method on 
<code class="literal">Query</code>. As stated previously, 
<code class="literal">ConnectionIO[A]</code> represents computations that take place in a context where a 
<code class="literal">java.sql.Connection</code> is available, ultimately producing a value of type 
<code class="literal">A</code>. In this case, we use 
<code class="literal">unique</code> as we're only expecting one row to be returned. Other interesting methods are 
<code class="literal">list</code> and 
<code class="literal">opti</code>
<code class="literal">on</code>, which return 
<code class="literal">ConnectionIO[List[A]]</code> and 
<code class="literal">ConnectionIO[Option[A]],</code> respectively.
</p></div><div class="section" title="Querying Using Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec16"/>Querying Using Parameters</h3></div></div></div><p>In Doobie, you 
<a class="indexterm" id="id387"/>pass parameters to queries as you would with any string interpolator. The parameters are turned into 
<code class="literal">?</code> expressions in prepared statements to avoid SQL injections. Let's have a look at how to query using parameters:
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>You can find the following queries in 
<code class="literal">lesson-1/doobie-example/src/main/scala/com/example/User.scala.</code>
</p></div></div><div class="informalexample"><pre class="programlisting">case class User(userId: Int, username: String, age: Int)

def allManual(limit: Int): ConnectionIO[List[User]] = sql"""
    SELECT userId, username, age
    FROM user
    LIMIT $limit
  """
    .query[(Int, String, Int)]
    .map { case (id, username, age) =&gt; User(id, username, age) }
    .list

def withUsername(username: String): ConnectionIO[User] = sql"""
    SELECT userId, username, age
    FROM user
    WHERE username = $username
  """.query[User].unique</pre></div><p>The 
<a class="indexterm" id="id388"/>first query, 
<code class="literal">allManual</code>, takes an 
<code class="literal">Int</code> and uses it as a parameter to define the 
<code class="literal">LIMIT</code> of the SQL query. The second query takes a 
<code class="literal">String</code> and uses it in a 
<code class="literal">WHERE</code> clause to select users with that specific username. The 
<code class="literal">allManual</code> query selects a 
<code class="literal">Tuple</code> of (
<code class="literal">Int</code>, 
<code class="literal">String</code>, 
<code class="literal">Int</code>) and 
<code class="literal">maps</code> over it to produce a 
<code class="literal">User</code>, whereas 
<code class="literal">withUsername</code> uses Doobie's ability to automatically use the 
<code class="literal">apply</code> method of a case class when querying for rows of that type.
</p></div><div class="section" title="Deleting, Inserting, and Updating Rows"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec17"/>Deleting, Inserting, and Updating Rows</h3></div></div></div><p>Deleting, inserting, and updating works in a similar way. First, let's look at how to 
<a class="indexterm" id="id389"/>delete rows:
</p><div class="informalexample"><pre class="programlisting">def delete(username: String): ConnectionIO[Int] = sql"""
    DELETE FROM user
    WHERE username = $username
  """.update.run</pre></div><p>Again, we 
<a class="indexterm" id="id390"/>use the SQL string interpolator to define our query and simply refer to variables in scope to define 
<a class="indexterm" id="id391"/>parameters to the query. However, instead of using the 
<code class="literal">query[A]</code> method on 
<code class="literal">Fragment</code> to produce a 
<code class="literal">Query</code>, we 
<a class="indexterm" id="id392"/>use 
<code class="literal">update[A]</code> to produce an 
<code class="literal">Update[A]</code>. We then use the 
<code class="literal">run</code> method on 
<code class="literal">Update</code> to produce a 
<code class="literal">ConnectionIO[A]:</code>
</p><div class="informalexample"><pre class="programlisting">def setAge(userId: Int, age: Int): ConnectionIO[Int] = sql"""
    UPDATE user
    SET age = $age
    WHERE userId = $userId
  """.update.run

def create(username: String, age: Int): ConnectionIO[Int] = sql"""
    INSERT INTO user (username, age)
    VALUES ($username, $age)
  """.update.withUniqueGeneratedKeys[Int]("userId")</pre></div><p>Both 
<code class="literal">setAge</code> and 
<code class="literal">create</code> are similar, but 
<code class="literal">create</code> uses an interesting method on 
<code class="literal">Update</code> named 
<code class="literal">withUniqueGeneratedKeys</code>, which returns the 
<code class="literal">id</code> of the row that was inserted last.
</p></div><div class="section" title="A Complete Example"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec18"/>A Complete Example</h3></div></div></div><p>Let's have a look at a 
<a class="indexterm" id="id393"/>full example. You can find it in 
<code class="literal">lesson-1/doobie-example/src/main/scala/com/example/Main.scala</code>. We'll look at each section piece by piece:
</p><div class="informalexample"><pre class="programlisting">val program = for {
    _  &lt;- Tables.create
    userId &lt;- User.create("Jack", 41)
    _ &lt;- User.setAge(userId, 42)
    _ &lt;- Todo.create(userId, "Buy Milk", false)
    _ &lt;- Todo.create(userId, "Read the newspaper", false)
    _ &lt;- Todo.create(userId, "Read the full documentation for Doobie", false)
    uncompleted &lt;- Todo.uncompleted(userId)
  } yield uncompleted</pre></div><p>In this section, you can see how to chain 
<code class="literal">ConnectionIO</code> using 
<code class="literal">flatMap</code> through Scala 
<code class="literal">for-comprehensions</code>. This allows us to nicely construct 
<code class="literal">ConnectionIO</code> from the result of executing another 
<code class="literal">ConnectionIO</code>. In this case, we use it to first create a 
<code class="literal">User</code> and then use the 
<code class="literal">userId</code> in subsequent methods to set the user's age and construct three 
<code class="literal">Todo</code> methods for the user:
</p><div class="informalexample"><pre class="programlisting"> val all: IO[Unit] = for {
    todos &lt;- program.transact(xa)
    users &lt;- User.all(10).transact(xa)
  } yield {
    todos.foreach(println)
    users.foreach(println)
  }</pre></div><p>In this section, we will produce 
<code class="literal">IO</code> from two 
<code class="literal">ConnectionIO</code> instances by using the 
<code class="literal">transact</code> method in a 
<code class="literal">for</code>
<code class="literal">-comprehension</code>:
</p><div class="informalexample"><pre class="programlisting"> all.unsafeRunSync</pre></div><p>Finally, the 
<code class="literal">IO</code> is executed to produce side effects.
</p></div></div><div class="section" title="Activity: Adding Priority to the Todo List"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Activity: Adding Priority to the Todo List</h2></div></div></div><p>Imagine a scenario where a client has told 
<a class="indexterm" id="id394"/>you that he needs priority function added to his Todo lists. Design the priority for the application.
</p><p>Extend the 
<a class="indexterm" id="id395"/>example program in 
<code class="literal">lesson-1/doobie-example </code>by adding a priority to each of the Todos and use the priority when querying for uncompleted todos so that the most important is returned first. You'll have to perform the following steps:
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend the <code class="literal">Todo case class</code> with a <code class="literal">priority: Int</code> field.</li><li class="listitem">Update the <code class="literal">Table</code> definition in <code class="literal">Todo.table.</code></li><li class="listitem">Update the <code class="literal">Todo.create</code> method to take an <code class="literal">Int</code> that represents the priority.</li><li class="listitem">Update <code class="literal">Todo.uncompleted</code> so it orders the rows in descending order.</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we covered the core concepts of functional programming like Pure functions, immutability, and higher-order functions. We introduced some of the design patterns that are prevalent in large functional programs. Finally, we covered two popular functional programming libraries called Cats and Doobie, and used them to write some interesting programs.</p><p>In the next chapter, we will cover how Scala makes it possible to write powerful Domain-Specific Languages (DSLs) by providing a few interesting language features. We'll have a brief look at what DSLs are in general terms. We'll also cover a DSL that you'll very likely be using if you're going to work with Scala professionally. Finally, you will implement your own DSL.</p></div></body></html>