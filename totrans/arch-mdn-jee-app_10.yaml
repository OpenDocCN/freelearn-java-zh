- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, most of the topics covered in this book haven't dealt with the topic
    of security. This is an often overlooked topic that in some real-world projects
    only gets interest when it's already too late.
  prefs: []
  type: TYPE_NORMAL
- en: Developers as well as project managers see security as a necessary evil rather
    than as something providing big benefits to the business. Still, it's a topic
    that stakeholders must be made aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite a few requirements have changed in the age of the cloud and distributed
    applications. This chapter will look into the situation of the past, as well as
    today''s requirements. It will cover how security is realized using modern Java
    EE:'
  prefs: []
  type: TYPE_NORMAL
- en: Security lessons learned from the past
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise security principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern security solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to realize security using modern Java EE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lessons learned from the past
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world IT security is quite an important aspect. Most people have
    realized that information technology can cause a lot of harm if misused.
  prefs: []
  type: TYPE_NORMAL
- en: The last half-century of computing contained a lot to learn from, in terms of
    security, and not only for enterprise software.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into a few lessons learned from the past of enterprise application
    development. In previous years, the biggest security issues were encryption and
    approaches on how to manage credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and signing data is an incredibly safe way of keeping secrets, if
    applied correctly. It solely depends on the used algorithms and the key lengths.
  prefs: []
  type: TYPE_NORMAL
- en: There were quite a few encryption and hashing algorithms that turned out to
    not be secure enough. **DES** is an example, as well as the often-used **MD5**
    hashing algorithm. As of writing this book, **AES** with 192- or 256-bit key lengths
    is considered secure. For the hashing algorithm, **SHA-2** or **-3** with at least
    256 bits is advised.
  prefs: []
  type: TYPE_NORMAL
- en: User credentials that are stored as part of the application must not be stored
    in plain text. There have been too many security breaches in the past that especially
    targeted databases where the passwords resided. Also, simply hashing passwords
    without providing proper password salts is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it's highly advisable for enterprise developers not to implement
    security functionality themselves if they can avoid it. The idea of companies
    was to create their own security implementations that weren't used anywhere else
    and, therefore, provide *security by obscurity*. This, however, turns out to have
    had the opposite effect, and, unless security experts are involved, in fact leads
    to, less secure solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The vast majority of enterprise security demands don't require their own, custom
    implementations. Enterprise frameworks and the implementations thereof already
    ship with corresponding functionality that has been well-tested in numerous use
    cases. We will have a look at these APIs for Java Enterprise later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If the application requires the custom use of encryption, then implementations
    provided by runtime or third-party dependencies must be used. The Java platform
    offers the **Java Cryptography Extension** (**JCE**) for this reason. It provides
    implementations for modern encryption and hashing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In general, applications should only process and store secure information when
    it's absolutely required by the business use case. In particular, for authentication
    and authorization, there are ways that avoid storing user credentials in multiple
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Security in a modern world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More distribution of applications leads to higher demand in securing communication.
    The integrity of exchanged information needs to be ensured. Similarly, people
    are aware of the necessity of encryption, especially when it comes to encrypting
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: What possibilities do engineers have in today's enterprise world? What principles
    should they follow when realizing security?
  prefs: []
  type: TYPE_NORMAL
- en: Security principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some basic principles that should be followed when implementing security
    in enterprise applications. The following list aims to give the basic ideas, and
    is not intended to be exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, it's important to mention that external communication that happens
    over the internet must be encrypted. The usual way of doing this is via TLS using
    trusted certificates. This is possible for HTTP as well as for other communication
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The authenticity of the certificates used must be verified at runtime by the
    implementation. They have to be assured by a trusted internal or external certificate
    authority.
  prefs: []
  type: TYPE_NORMAL
- en: Insecurely accepting any certificates in the application should be avoided,
    for production as well as other environments. This implies that properly signed
    certificates are being provided and used for the communication.
  prefs: []
  type: TYPE_NORMAL
- en: Delegate security concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of storing user information, today's approach is to delegate authentication
    and authorization to security providers if possible. This means that an enterprise
    application doesn't store security information, but asks a third-party, a trusted
    security provider.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially interesting in distributed environments, where multiple applications
    offer potential endpoints to the outside world. The secure information moves to
    a single point of responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Security concerns are usually not a part of the core business logic. The application
    will ask the trusted security provider system to validate the security of user
    requests. The security provider acts as a secure single point of responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: There are decentralized security protocols, such as **OAuth** or **OpenID**,
    that implement this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Delegating the responsibility to a trusted security provider eliminates the
    need to share passwords within enterprise systems. Users identify directly against
    security providers. Applications that require security information about a user
    will be provided session tokens that do not directly contain confidential data.
  prefs: []
  type: TYPE_NORMAL
- en: This principle, however, mainly targets communication that includes application
    users as persons.
  prefs: []
  type: TYPE_NORMAL
- en: Treat user credentials properly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If for some reason the application manages user authentication itself, it should
    never permanently store passwords and tokens in plain text. This introduces a
    severe security risk. Even if an application or database has sufficient protection
    from the outside world, it's important to protect the credentials from internal
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Passwords that need to be managed within the application must be stored only
    via appropriate hashing algorithms and approaches such as **salting**. Doing so
    prevents any malicious attack, from both the inside as well the outside of the
    coorporation. It's advisable to consult security information organizations such
    as **Open Web Application Security Project** (**OWASP**). They provide the modern
    advice for security approaches and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid storing credentials in version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the same reason that you should not treat secure credentials poorly, developers
    shouldn't store clear credentials in the version-controlled project repository.
    Even if the repository is hosted company-internally, this introduces a security
    risk.
  prefs: []
  type: TYPE_NORMAL
- en: The credentials will be visible permanently in the repository's history.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Chapter 5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml), *Container
    and Cloud Environments with Java EE*, there are features of cloud environments
    that inject secret configuration values into applications. This functionality
    can be used to provide secret credentials that are configured externally.
  prefs: []
  type: TYPE_NORMAL
- en: Include tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The security mechanisms that are a responsibility of the application need to
    be system-tested properly. Any included authentication and authorization must
    be verified as part of the Continuous Delivery pipeline. This means that you should
    verify the functionality in automated tests, to not only verify it once, but continuously,
    after changes in the software.
  prefs: []
  type: TYPE_NORMAL
- en: It's especially important for security-relevant tests to include negative tests.
    For example, the test must verify that incorrect credentials or insufficient permissions
    do not allow you to perform specific application functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Possibilities and solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a few basic but important security principles, let's have a look at the
    possible security protocols and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypted communication usually means that the communications are encrypted
    using **TLS encryption**, as part of the communication protocol in the transport
    layer. Certificates are used to encrypt and sign the communication. Of course,
    it's crucial to be able to rely on the certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Companies often operate their own certificate authorities and pre-install their **root
    CA** in their computers and software. This certainly makes sense for internal
    networks. It reduces overhead and potential costs compared to requesting certificates
    for all internal services from an official authority.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates that are *publicly trusted* are required to be signed by one of
    the official certificate authorities that come pre-installed with operating systems
    or platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted communication does not authenticate users, unless individual client
    certificates are being used. It lays the foundation for a secure, trusted communication.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some communication protocols come with authentication capabilities, such as
    HTTP with basic or digest authentication. These functionalities are part of the
    communication protocol and are usually well-supported in tools and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: They usually rely on the communication being already securely encrypted, otherwise
    this would make the information accessible for parties that can read it, should
    they intercept the communication. This is important to mention to application
    developers to ensure that protocol-based authentication is provided via encrypted
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: The credentials for protocol-based security are usually provided directly in
    every message. This simplifies client calls as there is no need for several authentication
    steps, such as in exchanging tokens. The first client invocation can already exchange
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other approaches that do not directly include credentials in the client invocations
    will fetch security tokens first and issue the actual communication with the token
    being provided afterwards. This goes in the direction of decentralized security.
  prefs: []
  type: TYPE_NORMAL
- en: In order to decouple security from the application, enterprise systems can include
    identity providers as a central point for authentication or authorization, respectively.
    This delegates the security concerns from the application to a provider.
  prefs: []
  type: TYPE_NORMAL
- en: The identity providers authorize third parties, such as enterprise applications,
    without directly exchanging the credentials with them. The end users are redirected
    to the identity providers and don't hand the secure information to the enterprise
    application. Third-parties only receive the information when the access has been
    permitted, contained in tokens that they can verify.
  prefs: []
  type: TYPE_NORMAL
- en: This three-way authentication avoids concerning the enterprise application with
    security responsibilities. The responsibility to verify whether the information
    that the user provides was correct moves to the identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this method is **single sign on** (**SSO**) mechanisms. They're
    used quite often in bigger companies to require users to authenticate only once
    and reuse the information in all services that are secured by an SSO. The SSO
    system authenticates the user and provides the required user information to the
    corresponding applications. Users just need to log in once.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to use decentralized access delegation protocols, such as
    OAuth, OpenID, and OpenID Connect. They represent three-way security workflows
    to exchange security information between clients, third-party applications, and
    the identity provider. The idea is similar to single sign on mechanisms. However,
    these protocols enable users to decide which individual application will receive
    the user's information. The applications receive user access tokens, for example,
    in the form of **JSON Web Tokens**, that are validated via the identity provider,
    instead of the actual credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The decentralized access delegation protocols and their implementation are beyond
    the scope of this book. The responsibility for enterprise systems is to intercept
    and redirect the user authentication to the identity provider. Depending on the
    system architecture, this is the responsibility of a proxy server or the application
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: There are open source solutions out there that implement decentralized security.
    An interesting technology is **Keycloak** which is an Identity and Access Management
    solution. It ships with various client adapters and supports standard protocols,
    such as OAuth or OpenID Connect, what makes it easy to secure applications and
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxy servers that encapsulate communication with enterprise applications can
    add security aspects, such as encrypting the communication. Web proxy servers,
    for example, support TLS encryption over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: The question is whether engineers want to make a difference between network,
    internal and external communication. Communication in an intranet network is often
    unencrypted. Depending on the nature of the exchanged information, internet communication
    should, in most cases, be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy servers can be used to terminate the encryption at the network boundaries,
    so-called **TLS termination**. The proxy server encrypts all outgoing information
    and decrypts all incoming information, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: It's equally possible to re-encrypt the communication using different certificates
    for different networks.
  prefs: []
  type: TYPE_NORMAL
- en: Integration in modern environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern environments aim to support today's security needs. Container orchestration
    frameworks offer the provisioning of software proxy servers and gateways that
    expose the service; for example, Kubernetes ingress resources, as well as OpenShift routes support
    TLS encryption for cluster-external traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide secret values such as credentials or private keys, orchestration
    frameworks offer the functionality of secrets. As seen previously, this enables
    us to separately provide secret configurations into the environment. [Chapter
    5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml), *Container and Cloud Environments
    with Java EE* examined how this is realized.
  prefs: []
  type: TYPE_NORMAL
- en: This enables applications, as well as the configuration in general, to use secret
    values. The secrets can be injected into the container runtimes, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing security in Java EE applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing the most common security approaches of today's world, let's have
    a look into how security is implemented using Java EE.
  prefs: []
  type: TYPE_NORMAL
- en: Of all the Java versions, Java EE version 8 aimed to address security aspects.
    It contains a security API that simplifies and unifies the integration for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the simplest way, security in web applications can be implemented by proxy
    web servers, such as **Apache** or **nginx**. In that case, the security responsibilities
    are transparent to the application.
  prefs: []
  type: TYPE_NORMAL
- en: This is often the case if the enterprise application doesn't have to deal with
    users as domain entities.
  prefs: []
  type: TYPE_NORMAL
- en: Servlets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to secure web services offered by the Java EE application, usually
    security on the servlet layer is used. This is the case for all technology that
    is built on top of servlets such as JAX-RS. Security features are configured using
    the servlet deployment descriptor, that is, the `web.xml`file.
  prefs: []
  type: TYPE_NORMAL
- en: This can happen in several ways such as form-based authentication, HTTP basic
    access authentication, or client certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, security solutions such as Keycloak ship their own implementations
    of adapters and servlet filters. Developers usually just need to configure these
    components to use the security provider.
  prefs: []
  type: TYPE_NORMAL
- en: Java principals and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java security principals and roles represent identities and authorization roles,
    respectively. Principals and roles are usually configured in the application server
    in vendor-specific ways. Authenticated requests are bound to a principal during
    the execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of using the associated roles within the execution workflow is
    by using common security annotations such as `@RolesAllowed`. This declarative
    approach checks whether the principal is authorized correctly and will otherwise
    result in a security exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Besides vendor-specific solutions, users and roles can be extended to contain
    domain-specific information. The `Principal` security type is enhanced in order
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to inject the principal that is identified by its name and to
    provide a specialization. The container takes care of the user identification,
    for example, by using form-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: This approach was especially advised prior to Java EE version 8\. However, modern
    applications will likely use identity stores to represent domain-specific user
    information.
  prefs: []
  type: TYPE_NORMAL
- en: JASPIC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Authentication Service Provider Interface for Containers** (**JASPIC**)
    is a standard that defines authentication service providers' interfaces. It comprises
    so-called **Server Authentication Modules** (**SAM**), pluggable authentication
    components, which are added to the application server.
  prefs: []
  type: TYPE_NORMAL
- en: This standard offers powerful and flexible ways how to implement authentication.
    Server vendors can ship their own implementation of SAMs. However, implementing
    authentication modules using the JASPIC standard is seen as quite cumbersome by
    a lot of developers. This is why the JASPIC standard is not widely used in enterprise
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Security API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Security API 1.0 is shipped with Java EE 8\. The idea for this standard
    was to provide modern security approaches that are simpler to use for developers.
    These are implemented in vendor-independent ways, without the need to lock in
    to specific solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look into what the Security API includes.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, the Security API includes `HttpAuthenticationMechanism`, which
    provides the features of the JASPIC standard with much less development effort
    needed. It's specified to be used in a servlet context.
  prefs: []
  type: TYPE_NORMAL
- en: Application developers are only required to define a custom `HttpAuthenticationModule` and
    to configure the authentication in the `web.xml` deployment descriptor. We will
    have a look at a custom security implementation later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Java EE container already ships with predefined HTTP authentication mechanisms
    for basic, default, and custom form authentication. The developers can use this
    predefined functionality with minimal effort. Before we see an example, let's
    see how to store the user information.
  prefs: []
  type: TYPE_NORMAL
- en: Identity stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of identity stores was also added with the Security API. Identity
    stores provide the authentication and authorization information of users in lightweight,
    portable ways. They offer a unified way to access this information.
  prefs: []
  type: TYPE_NORMAL
- en: The `IdentityStore` type validates a caller's credentials and accesses its information.
    Similarly to HTTP authentication mechanisms, the application containers are required
    to provide identity stores for LDAP and database access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an example using the container-provided security functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Application developers only need to provide this annotated class. This approach
    provides simple and straightforward security definitions for test purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Usual enterprise projects arguably require more custom approaches. Organizations
    usually have custom ways of authentication and authorization that need to be integrated.
  prefs: []
  type: TYPE_NORMAL
- en: Custom security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following shows a more sophisticated example.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide custom authentication, application developers implement
    a custom `HttpAuthenticationMechanism`, especially the `validateRequest()` method.
    The class only has to be visible to the container as a CDI bean. The rest is done
    by the application container. This simplifies the security integration for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a basic example, with *pseudo code* representing the actual
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `validateRequest()` implementation accesses the user information contained
    in the HTTP request, for example via the HTTP headers. It delegates the validation
    to the identity store using the `IdentityStoreHandler`. The validation result
    contains the result that is provided to the security HTTP message context.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the requirements, a custom identity handler implementation is required
    as well. It can provide custom authentication and authorization methods.
  prefs: []
  type: TYPE_NORMAL
- en: If decentralized security protocols, such as OAuth, are being used, a custom
    identity handler will implement the security access token validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a custom identity store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `web.xml` servlet deployment descriptor is used to specify the secure resources.
    The application container takes care of the integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An HTTP authentication mechanism provides a straightforward, yet flexible, way
    to implement JASPIC security. Its implementation is simpler compared to a plain
    JASPIC approach.
  prefs: []
  type: TYPE_NORMAL
- en: It provides the possibility of intercepting communication flows and can integrate
    the application with third-party security providers.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing security information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise applications sometimes need the functionality to access information
    about the user authorization as part of the business logic. The Security API enables
    us to retrieve this information in a uniform way.
  prefs: []
  type: TYPE_NORMAL
- en: It contains the `SecurityContext` type that provides a programmatic way to retrieve
    information about the caller principal and its roles. The `SecurityContext` is
    injectable into any managed beans. It also integrates with the servlet authentication
    configuration and provides information about whether the caller is allowed to
    access a specific HTTP resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an example usage of the `SecurityContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The idea of the Security API is that it integrates with the existing functionality
    from previous Java EE versions. This implies, for example, that the `@RolesAllowed` annotation
    uses the same role information as the `SecurityContext`. Developers can continue
    to rely on the existing standard functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, IT security is quite an important aspect. In the past, some
    of the biggest security issues were weak encryption and hashing algorithms, how
    passwords are persisted, and home-grown security implementations. A few important
    security principles include encrypting the communication, using external, trusted
    security providers for authentication and authorization, avoiding keeping credentials
    under version control, and including test scenarios that verify protection.
  prefs: []
  type: TYPE_NORMAL
- en: Communication is usually encrypted in the transport layer using TLS. Used certificates
    should be signed correctly, either by a company-internal or official certificate
    authority. Other approaches includes using security features of the protocol layer,
    such as HTTP basic authentication on top of encrypted communication.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized security decouples authentication and authorization responsibilities
    from the applications by including trusted identity providers. Single sign on
    as well as decentralized access delegations protocols are examples for this.
  prefs: []
  type: TYPE_NORMAL
- en: Security in Java EE application boundaries is usually realized on top of Servlets.
    The Security API which was introduced in Java EE 8 aims to provide simpler, uniform
    approaches on how to tackle security in Java EE applications. HTTP authentication
    mechanisms are an example that provide easier usage of the powerful JASPIC functionality.
    Identity stores provide authentication and authorization information of users.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the Security API is to integrate with existing functionality and
    offer uniform access mechanisms. The included features should be sufficient to
    secure enterprise application on the HTTP side.
  prefs: []
  type: TYPE_NORMAL
