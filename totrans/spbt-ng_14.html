<html><head></head><body>
		<div id="_idContainer103">
			<h1 class="chapter-number" id="_idParaDest-265"><a id="_idTextAnchor275"/>14</h1>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor276"/>Adding Authentication in Angular</h1>
			<p>In the previous chapter, we completed the CRUD features of our Angular application using the building blocks of NgRx. We also learned the step-by-step process of writing the actions, reducers, and effects in our application that will be used to modify the value of states. We also learned the difference between using and not using effects in the application. Effects are essential for us to communicate with the external APIs that allow the database changes to be synced in the <span class="No-Break">NgRx store.</span></p>
			<p>In this chapter, we will learn how to add authentication in our Angular application; we will implement a login page that will provide a valid JWT, protect routes, and apply API authentication with the use <span class="No-Break">of NgRx.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Adding <span class="No-Break">user authentication</span></li>
				<li><span class="No-Break">Protecting routes</span></li>
				<li>Calling <span class="No-Break">an API</span></li>
			</ul>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor277"/>Technical requirements</h1>
			<p>The complete code for this chapter can be found <span class="No-Break">at: </span><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor278"/>Adding user authentication</h1>
			<p>Adding <a id="_idIndexMarker1071"/>user authentication is one of the main requirements in developing an application. This feature allows us to restrict pages and features from unauthorized users. We can achieve user authentication in different ways, and one way to implement this is by providing a login page that will ask <span class="No-Break">for credentials.</span></p>
			<p>Let’s have a look at the step-by-step process of implementing the <span class="No-Break">authentication feature.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor279"/>The authentication API</h2>
			<p>Let us first recap <a id="_idIndexMarker1072"/>the authentication API we created in our Spring Boot project. The endpoints for authentication are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">{BASE_URL}/authenticate</strong>: The main endpoint for authentication accepts an object with email and password fields and returns a valid JWT that will be used for calling endpoints. The following is an example response object of <span class="No-Break">the endpoint:</span><pre class="console">
// valid JWT</pre><pre class="console">
{</pre><pre class="console">
   "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0QGdtYWl sLmNvbSIsImlhdCI6MTY1OTQyODk2MSwiZXhwIjoxNjU5NDY0OTYxfQ.WU_aZjmlfw--LCovx4cZ4_hcOTGiAgPnSaM0bjdv018"</pre><pre class="console">
}</pre></li>
				<li><strong class="source-inline">{BASE_URL}/register</strong>: The endpoint for creating new valid credentials for login. JWT, as stated in <a href="B18159_07.xhtml#_idTextAnchor123"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Adding Spring Boot Security with JWT</em>, is used chiefly on RESTful web services that cannot maintain a client state since JWT holds some information connected to the user. This will be used primarily in the headers of endpoints that we <span class="No-Break">will request.</span></li>
			</ul>
			<p>In our project, let’s create a service named <strong class="source-inline">AuthenticateService</strong> under the <strong class="source-inline">core/services</strong> folder by executing the <span class="No-Break">following command:</span></p>
			<pre class="console">
<strong class="bold"> ng g core/services/authenticate</strong></pre>
			<p>After successfully creating the service, we will place the following code in <span class="No-Break">the service:</span></p>
			<pre class="console">
export class AuthenticateService {
  constructor(private http: HttpClient) { }
  // for login endpoint
  login(data: {email: string, password: string}):
    Observable&lt;any&gt; {
    return this.http.post&lt;any&gt;(
     `${environment.authURL}/authenticate`,
      data).pipe(
      tap((data: any) =&gt; data),
      catchError(err =&gt; throwError(() =&gt; err))
   )
  }
  // for register endpoint
  register(data: {email: string, password: string}):
    Observable&lt;any&gt; {
    return this.http.post&lt;any&gt;(
      `${environment.authURL}/register`, data).pipe(
      tap((data: any) =&gt; data),
      catchError(err =&gt; throwError(() =&gt; err))
   )
  }
}</pre>
			<p><strong class="source-inline">AuthenticateService</strong> will<a id="_idIndexMarker1073"/> hold the two endpoints we will use for our login page. Now, let’s create the interceptor for <span class="No-Break">our application.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor280"/>The HTTP interceptor</h2>
			<p><strong class="bold">HTTP interceptors</strong> are<a id="_idIndexMarker1074"/> features of Angular that allow us to intercept HTTP requests to transform their headers, the body, or the response. This provides the <strong class="source-inline">intercept()</strong> function, which will enable us to get the outgoing request and call the next interceptor or <span class="No-Break">the backend.</span></p>
			<p>We will mainly use the interceptor to modify the headers of our endpoint requests, which will be responsible for adding the <strong class="source-inline">Authorization: Bearer {JWT}</strong> header for each <span class="No-Break">invoked request.</span></p>
			<p>To implement <a id="_idIndexMarker1075"/>the interceptor, we will create the <strong class="source-inline">core/interceptors/header.interceptor.ts</strong> file, and we will place the following code <span class="No-Break">within it:</span></p>
			<pre class="source-code">
@Injectable()
export class HeaderInterceptor implements HttpInterceptor {
  intercept(httpRequest: HttpRequest&lt;any&gt;, next:
    HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    const Authorization = localStorage.getItem('token') ?
      `Bearer ${localStorage.getItem('token')}` : '';
    if(httpRequest.url.includes('api/v1'))
    return next.handle(httpRequest.clone({ setHeaders: {
      Authorization } }));
    else
    return next.handle(httpRequest);
  }
}</pre>
			<p>In the preceding code example, we have added a new implementation for the <strong class="source-inline">intercept()</strong> function. The first step is to retrieve the valid JWT in our local storage that will be used in the HTTP headers. We will only use the JWT if the request endpoint has an <strong class="source-inline">api/v1</strong> substring, as these are the endpoints that <span class="No-Break">are protected.</span></p>
			<p>The next step is to clone the request and add the <strong class="source-inline">Authorization: Bearer {JWT}</strong> header in the cloned request and call the <strong class="source-inline">next()</strong> function to call the API with the <span class="No-Break">added header.</span></p>
			<p>We have now<a id="_idIndexMarker1076"/> created our interceptor; the last step is to add the interceptor <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">AppModule</strong></span><span class="No-Break">.</span></p>
			<p>Let’s have a look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass:
               HeaderInterceptor, multi: true }
  ],</pre>
			<p>In the preceding code example, we will now intercept every HTTP call on the anti-heroes endpoint and will add the generated JWT in the <span class="No-Break">request headers.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor281"/>The authentication module</h2>
			<p>The <a id="_idIndexMarker1077"/>next step is to create an authentication module; this module will be responsible for holding the login and registration page that will accept the users and credentials and call the authenticate and <span class="No-Break">register endpoints.</span></p>
			<p>To create the authentication module, we will execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng g m auth</pre>
			<p>After successfully creating the authentication module, we will import several modules we need for our <span class="No-Break">authentication module:</span></p>
			<pre class="source-code">
@NgModule({
  declarations: [
  ],
  imports: [
    CommonModule,
    MaterialModule,
    FormsModule,
    ReactiveFormsModule,
    CoreModule,
  ]
});</pre>
			<p>Now, we will <a id="_idIndexMarker1078"/>create the different parts of <span class="No-Break">our module.</span></p>
			<h3>The authentication form</h3>
			<p>We will <a id="_idIndexMarker1079"/>create the main form for our authentication module; this is considered the dumb component of our module as it will accept and emit the values of the form to the login and <span class="No-Break">registration page.</span></p>
			<p>To create the authentication form component, we will execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng g c auth/components/auth-form</pre>
			<p>After successfully creating the component, we will now implement the form’s code. In the TypeScript file of the <strong class="source-inline">auth-form</strong> component, we will place the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export class AuthFormComponent {
  @Input() error: string = "";
  @Input() title: string = "Login"
  @Output() submitEmitter = new EventEmitter();
  form: FormGroup;
  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      email: [''],
      password: ['']
    })
  }
  submit() {
    this.submitEmitter.emit(this.form.value);
  }
}</pre>
			<p>In the<a id="_idIndexMarker1080"/> preceding code example, we can see that we have created a reactive form with an email and password form control. We have also created an emitter that will pass the values of the form into the parent component, as this component will be used by both the login and the register page. Now, we will implement the HTML code and the CSS of the <span class="No-Break"><strong class="source-inline">auth-form</strong></span><span class="No-Break"> component.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please refer to the link provided for the entire <span class="No-Break">code implementation:</span></p>
			<p class="callout"><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form</span></a></p>
			<p>In the implemented code, we have bound the reactive form with the email and password input. We have also created a condition where the button changes if the page is currently on login <span class="No-Break">or register.</span></p>
			<p>We have successfully created our authentication form; now, we will create our login and <span class="No-Break">registration page.</span></p>
			<h3>The login and registration page</h3>
			<p>The<a id="_idIndexMarker1081"/> login and registration pages are considered to be the smart components of our application, as these are the components that will dispatch the action for calling the <span class="No-Break">authentication API.</span></p>
			<p>To create the login and register page, we will execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng g c auth/page/login auth/page/register</pre>
			<p>After successfully creating<a id="_idIndexMarker1082"/> the two pages, we will run the code for the login and <span class="No-Break">register components:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Login Page</p>
			<pre class="source-code">
//TS File
export class LoginComponent{
  constructor(private authService: AuthenticateService,
    private router: Router) {
  }
  submit(data:{email:string, password:string}) {
    this.authService.login(data).subscribe((data) =&gt; {
      this.router.navigate(['/anti-heroes']);
      localStorage.setItem('token', data.token);
   });
  }
}
// HTML File
&lt;app-auth-form (submitEmitter)="submit($event)"&gt;&lt;/app-auth-form&gt;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Register Page</p>
			<pre class="source-code">
// TS File
export class RegisterComponent {
  error: string = "";
  constructor(private authService: AuthenticateService) {
  }
  submit(data: User) {
    this.authService.register(data).subscribe((data) =&gt; {
      this.router.navigate(['/']);
    });
  }
}
// HTML File
&lt;app-auth-form title="Register" (submitEmitter)="submit($event)"&gt;&lt;/app-auth-form&gt;</pre>
			<p>In the<a id="_idIndexMarker1083"/> preceding code example, we can see that the login page and registration pages are using the same authentication form component. Once the form is submitted, it will pass the form value into the <strong class="source-inline">login()</strong> or <strong class="source-inline">register()</strong> functions to authenticate or create the user, respectively. If the login is successful, we will redirect the user to the anti-heroes list page and place the generated token from the API in the <span class="No-Break">local storage.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor282"/>The routing module</h2>
			<p>The<a id="_idIndexMarker1084"/> next step is to create the <strong class="source-inline">auth-routing</strong> module that will define the routes for the authentication module. To<a id="_idIndexMarker1085"/> create the module, let’s execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng g m auth/auth-routing --flat</pre>
			<p>After creating the routing module, we will run the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const routes: Routes = [
  {
    path: "",
    component: LoginComponent
  },
  {
    path: "register",
    component: RegisterComponent
  }
];
@NgModule({
  declarations: [],
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class AuthRoutingModule {}</pre>
			<p>We also<a id="_idIndexMarker1086"/> need to modify our <strong class="source-inline">app-routing</strong> module, as we need our base path to redirect to the login page; let’s implement the <span class="No-Break">following modification:</span></p>
			<pre class="source-code">
const routes: Routes = [
  {
    path: "",
    redirectTo: "login",
    pathMatch: "full",
  },
  {
    path: "login",
    loadChildren: () =&gt;
    import("./auth/auth.module").then((m) =&gt; m.AuthModule),
  },
  {
    path: "anti-heroes",
    loadChildren: () =&gt;
      import("./anti-hero/anti-hero.module").then((m) =&gt;
             m.AntiHeroModule),
  }
];</pre>
			<p>In the <a id="_idIndexMarker1087"/>preceding implemented code, we can see that once we go to the base path, this will now load the <strong class="source-inline">AuthModule</strong> and redirect us to the login page, as shown in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer100">
					<img alt="Figure 14.1 – The Login page" src="image/B18159_14_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The Login page</p>
			<p>We should now be able to log in with our user in the database. If no user has been created, we can create a new one using the registration page, and once the login is successful, we will be redirected to the anti-hero list page, as shown in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer101">
					<img alt="Figure 14.2 – The anti-hero list page" src="image/B18159_14_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – The anti-hero list page</p>
			<p>We can also<a id="_idIndexMarker1088"/> observe that our valid JWT is already placed in our local storage as the HTTP interceptor is using the JWT. As we open a request made by our application, we can see that the headers have the <span class="No-Break">generated JWT:</span></p>
			<pre class="source-code">
Accept:
application/json, text/plain, */*
Accept-Encoding:
gzip, deflate, br
Accept-Language:
en-AU,en-US;q=0.9,en;q=0.8,bs;q=0.7,fr-CA;q=0.6,fr;q=0.5,tl;q=0.4
<strong class="bold">Authorization:</strong>
<strong class="bold">Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0QGdtYWlsLmNvbSIsImlhdCI6MTY1OTY5ODM2NSwiZXhwIjoxNjU5NzM0MzY1fQ.2SDLmvQcME5Be9Xj-zTeRlc6kGfQVNCMIWUBOBS5afg</strong></pre>
			<p>In the preceding example headers, we can see that the <strong class="source-inline">Authorization</strong> header contains the valid JWT for every API request the application calls. The placement of the JWT in the header is done when our login is successful and we are redirected to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">AntiHeromodule</strong></span><span class="No-Break">.</span></p>
			<h3>Token validation</h3>
			<p>The next step we <a id="_idIndexMarker1089"/>need to do is to add token validation to check whether our token already expired. To implement this feature, we add the <strong class="source-inline">@auth0/angular-jwt</strong> library by executing the <span class="No-Break">following command:</span></p>
			<pre class="console">
npm install @auth0/angular-jwt --save</pre>
			<p>The <strong class="source-inline">@auth0/angular-jwt</strong> library provides useful functions, such as <strong class="source-inline">isTokenExpired()</strong>, which checks whether the JWT is expired, and <strong class="source-inline">decodeToken()</strong>, which retrieves the information from <span class="No-Break">the JWT.</span></p>
			<p>After successfully installing the library, we will add the following code to our <span class="No-Break">authenticate service:</span></p>
			<pre class="source-code">
  isAuthenticated(): boolean {
    const token = localStorage.getItem('token') ?? '';
    // Check whether the token is expired and return
    // true or false
    return !this.jwtHelper.isTokenExpired(token);
  }</pre>
			<p>We also need to import the JWT module into our <span class="No-Break"><strong class="source-inline">app.module.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
 imports: [
    JwtModule.forRoot({})
  ],</pre>
			<p>We will use the <strong class="source-inline">isAuthenticated()</strong> function on our login and register pages to check whether a JWT is present in our local storage. If there is a valid JWT, we will redirect the application to the anti-hero <span class="No-Break">list page.</span></p>
			<p>Let’s have a look at the <span class="No-Break">following implementation:</span></p>
			<pre class="source-code">
//login page (TS File)
constructor(private authService: AuthenticateService, private router: Router,) {
    this.checkJWT();
  }
checkJWT() {
    if(this.authService.isAuthenticated()) {
      this.router.navigate(['/anti-heroes'])
    }
  }</pre>
			<h3>Logout implementation</h3>
			<p>The<a id="_idIndexMarker1090"/> last feature we need to implement is the logout function. To add this feature, the only function we need to add is a function that will remove the token from our storage. Let’s have the code implementation <span class="No-Break">as follows:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">authenticate.service.ts</p>
			<pre class="source-code">
export class AuthenticateService {
… other functions
doLogout() {
    let removeToken = localStorage.removeItem('token');
    if (removeToken == null) {
      this.router.navigate(['login']);
    }
  }</pre>
			<p>In the preceding code example, we have added a <strong class="source-inline">doLogout()</strong> function that removes the token in the storage and redirects the application to the login page. Now, let’s edit our <strong class="source-inline">navbar</strong> component to have a <span class="No-Break">logout button:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">navbar.component.html</p>
			<pre class="source-code">
&lt;p&gt;
    &lt;mat-toolbar color="primary"&gt;
      &lt;span&gt;Angular CRUD&lt;/span&gt;
      &lt;span class="example-spacer"&gt;&lt;/span&gt;
      &lt;button *ngIf="loggedIn" (click)="submit('logout')"
        mat-icon-button&gt;
        &lt;mat-icon&gt;logout&lt;/mat-icon&gt;
      &lt;/button&gt;
    &lt;/mat-toolbar&gt;
  &lt;/p&gt;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">navbar.component.css</p>
			<pre class="source-code">
.example-spacer {
    flex: 1 1 auto;
  }</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">navbar.component.ts</p>
			<pre class="source-code">
export class NavbarComponent implements OnInit{
  @Output() actionEmitter = new EventEmitter();
  @Input() loggedIn = false;
  submit(action: string) {
    this.actionEmitter.emit(action);
  }
}</pre>
			<p>In the preceding code implementation, we created an emitter for our navbar component. This<a id="_idIndexMarker1091"/> will emit the action we have triggered in our navbar, and it will be passed into our <span class="No-Break">app component.</span></p>
			<p>The last step is to call the <strong class="source-inline">doLogout()</strong> function in our app component when the logout button is clicked. Let’s have a look at the code implementation, <span class="No-Break">as follows:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.component.html</p>
			<pre class="source-code">
&lt;app-navbar [loggedIn]="url != '/' &amp;&amp; !url.includes('login')" (actionEmitter)="submit($event)"&gt;&lt;/app-navbar&gt;
&lt;div class="container"&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/div&gt;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.component.ts</p>
			<pre class="source-code">
export class AppComponent {
  title = 'superheroes';
  url: string = "";
  constructor(private authService: AuthenticateService,
              private router: Router){
    this.getRoute();
  }
  submit(action: string) {
    switch (action) {
      case 'logout':
        this.authService.doLogout();
        break;
      default:
        break;
    }
  }
  getRoute() {
    this.router.events.subscribe(data =&gt; {
    if(data instanceof NavigationEnd) {
      this.url = data.url;
    }
   });
  }
}</pre>
			<p>In the <a id="_idIndexMarker1092"/>preceding code implementation, we injected the authenticate service into our app component and called the <strong class="source-inline">doLogout()</strong> function. If the action is <strong class="source-inline">logout</strong>, we have also added a listener to the router change to check if our route is currently on login or register, and if it is, we will remove the logout button on the <span class="No-Break">navbar component.</span></p>
			<p>We have successfully implemented user authentication with our application, but we will still improve this implementation as we go on through this chapter. In the next section, we will discuss how to protect routes in our <span class="No-Break">Angular application.</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor283"/>Protecting routes</h1>
			<p>One <a id="_idIndexMarker1093"/>of the essential features of Angular is router guards. Guards are helpful if we want to protect our routes from being accessed directly without authentication or prevent the user from losing changes when navigating accidentally from <span class="No-Break">the route.</span></p>
			<p>Guards are interfaces provided by Angular that allow us to control the accessibility of a route with a provided condition. These are applied directly to the routes we want <span class="No-Break">to protect.</span></p>
			<p>Let’s have<a id="_idIndexMarker1094"/> a look at some of the guards provided <span class="No-Break">by Angular:</span></p>
			<ul>
				<li><strong class="source-inline">CanActivate</strong>: This<a id="_idIndexMarker1095"/> is implemented on a route <a id="_idIndexMarker1096"/>we <a id="_idIndexMarker1097"/>want to prevent <span class="No-Break">access to.</span><ul><li><span class="No-Break"><strong class="bold">Method signature</strong></span><span class="No-Break">:</span><pre class="console">
canActivate(route:ActivatedRouteSnapshot, state:RouterStateSnapshot):Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree</pre></li></ul></li>
			</ul>
			<p>The preceding code defines the signature of the <strong class="source-inline">CanActivate</strong> guard. The function accepts the <strong class="source-inline">ActivatedRouteSnapshot</strong> and <strong class="source-inline">RouterStateSnapshot</strong> parameters and returns an <strong class="source-inline">Observable</strong> or <strong class="source-inline">Promise</strong> that can be <a id="_idIndexMarker1098"/>of type <strong class="source-inline">Boolean</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">UrlTree</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Creating </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
export class AuthGuard implements CanActivate {,</pre><pre class="console">
constructor(priavte auth: AuthService, private router: Router) {}</pre><pre class="console">
canActivate(route: ActivatedRouteSnapshot, state:RouterStateSnapshot): Observable&lt;boolean&gt; |</pre><pre class="console">
Promise&lt;boolean&gt; | boolean {</pre><pre class="console">
  // return true permitted in the route, else return</pre><pre class="console">
  // false</pre><pre class="console">
 }</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the preceding code example, we have created a new class named <strong class="source-inline">AuthGuard</strong>; we have also<a id="_idIndexMarker1099"/> implemented it with the <strong class="source-inline">CanActivate</strong> guard and added the <strong class="source-inline">canActivate()</strong> function for the <span class="No-Break">required logic.</span></p>
			<ul>
				<li><strong class="bold">Using </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
// route-module file</pre><pre class="console">
{ path: 'hero',</pre><pre class="console">
 component: HeroComponent,</pre><pre class="console">
 canActivate: [AuthGuard]</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the <a id="_idIndexMarker1100"/>preceding code example, we have used the newly created <strong class="source-inline">AuthGuard</strong> class in our hero route to protect it from users without a <span class="No-Break">valid JWT.</span></p>
			<ul>
				<li><strong class="source-inline">CanActivateChild</strong>: This<a id="_idIndexMarker1101"/> is similar to <strong class="source-inline">CanActivateGuard</strong>, but this guard is applied to prevent access to child routes. Once this is added to the parent route, the guard will protect all <span class="No-Break">child routes.</span><ul><li><span class="No-Break"><strong class="bold">Method signature</strong></span><span class="No-Break">:</span><pre class="console">
canActivateChild(route:ActivatedRouteSnapshot, state:RouterStateSnapshot):Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree</pre></li></ul></li>
			</ul>
			<p>The preceding<a id="_idIndexMarker1102"/> code example defines the signature of the <strong class="source-inline">CanActivateChild</strong> guard. The function accepts the <strong class="source-inline">ActivatedRouteSnapshot</strong> and <strong class="source-inline">RouterStateSnapshot</strong> parameters and returns<a id="_idIndexMarker1103"/> an <strong class="source-inline">Observable</strong> or <strong class="source-inline">Promise</strong> that can be of type <strong class="source-inline">Boolean</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">UrlTree</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Creating </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
export class AuthGuard implements CanActivateChild {</pre><pre class="console">
constructor(private auth: AuthService, private router: Router) {}</pre><pre class="console">
canActivateChild(route: ActivatedRouteSnapshot, state:RouterStateSnapshot): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {</pre><pre class="console">
  // return true permitted in the route, else return</pre><pre class="console">
  // false</pre><pre class="console">
 }}</pre></li>
			</ul>
			<p>In the <a id="_idIndexMarker1104"/>preceding code example, we have created a new class named <strong class="source-inline">AuthGuard</strong>. We have also implemented it with the <strong class="source-inline">CanActivateChild</strong> guard and added the <strong class="source-inline">canActivateChild()</strong> function<a id="_idIndexMarker1105"/> for the <span class="No-Break">required logic.</span></p>
			<ul>
				<li><strong class="bold">Using </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
{</pre><pre class="console">
  path: user',</pre><pre class="console">
  canActivateChild: [AuthGuard],</pre><pre class="console">
  component: UserComponent,</pre><pre class="console">
  children: [</pre><pre class="console">
   { path: ':id', component: ProfileComponent},</pre><pre class="console">
   { path: ':id/edit', component: SettingsComponent}]</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the preceding code example, we have used the newly created <strong class="source-inline">AuthGuard</strong> class in our user path to protect its child routes that navigate to the <strong class="source-inline">ProfileComponent</strong> and <strong class="source-inline">SettingsComponent</strong> components from users without a<a id="_idIndexMarker1106"/> <span class="No-Break">valid JWT.</span></p>
			<ul>
				<li><strong class="source-inline">CanLoad</strong>: This<a id="_idIndexMarker1107"/> guard is used for lazy-loaded modules. The <strong class="source-inline">CanActivate</strong> guard can only prevent users from navigating through a <a id="_idIndexMarker1108"/>route; the <strong class="source-inline">CanLoad</strong> guard prevents both navigating to and downloading the <span class="No-Break">lazy-loaded module.</span><ul><li><span class="No-Break"><strong class="bold">Method signature</strong></span><span class="No-Break">:</span><pre class="console">
canLoad(route:Route,segments:UrlSegment[]):Observable&lt;boolean&gt;|Promise&lt;boolean&gt;|boolean</pre></li></ul></li>
			</ul>
			<p>The preceding code example defines the signature of the <strong class="source-inline">CanLoad</strong> guard. The function accepts the <strong class="source-inline">Route</strong> and <strong class="source-inline">UrlSegment[]</strong> parameters and returns an <strong class="source-inline">Observable</strong> or <strong class="source-inline">Promise</strong> that <a id="_idIndexMarker1109"/>can be of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">Boolean</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Creating </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
import { CanLoad, Route, Router } from '@angular/router';</pre><pre class="console">
export class AuthGuard implements CanLoad {</pre><pre class="console">
constructor(private router: Router) {}</pre><pre class="console">
canLoad(route:Route,segments:UrlSegment[]):Observable &lt;boolean&gt;|Promise&lt;boolean&gt;|boolean {</pre><pre class="console">
 // return true or false based on a condition to load</pre><pre class="console">
 // a module or not</pre><pre class="console">
}}</pre></li>
			</ul>
			<p>In the preceding <a id="_idIndexMarker1110"/>code example, we have created a new class named <strong class="source-inline">AuthGuard</strong>. We have also implemented it with the <strong class="source-inline">CanLoad</strong> guard and added the <strong class="source-inline">canLoad()</strong> function for the <span class="No-Break">required logic.</span></p>
			<ul>
				<li><strong class="bold">Using </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
  {</pre><pre class="console">
    path: "hero",</pre><pre class="console">
    loadChildren: () =&gt;</pre><pre class="console">
      import("./hero/hero.module").then((m) =&gt;</pre><pre class="console">
             m.AntiHeroModule),</pre><pre class="console">
      canLoad: [AuthGuard]</pre><pre class="console">
  }</pre></li>
			</ul>
			<p>In the preceding <a id="_idIndexMarker1111"/>code example, we have used the newly created <strong class="source-inline">AuthGuard</strong> class in our hero route to protect it from users accessing and downloading the resources without a <span class="No-Break">valid JWT.</span></p>
			<ul>
				<li><strong class="source-inline">CanDeactivate</strong>: This<a id="_idIndexMarker1112"/> is a guard used to prevent the user from navigating away from the current route. This is useful in scenarios such as filling out forms in the application, to avoid losing some changes on navigating<a id="_idIndexMarker1113"/> <span class="No-Break">out accidentally.</span><ul><li><span class="No-Break"><strong class="bold">Method signature</strong></span><span class="No-Break">:</span><pre class="console">
canDeactivate(component: T, currentRoute: ActivatedRoute Snapshot, currentState: RouterStateSnapshot,nextState?: RouterStateSnapshot): Observable&lt;boolean|UrlTree&gt;|Promise&lt;boolean|UrlTree&gt;|boolean |UrlTree;</pre></li></ul></li>
			</ul>
			<p>The preceding code example defines the signature of the <strong class="source-inline">CanDeactivate</strong> guard. The function accepts a generic component, the <strong class="source-inline">ActivatedRouteSnapshot</strong> and <strong class="source-inline">RouterStateSnapshot</strong> parameters, and returns <a id="_idIndexMarker1114"/>an <strong class="source-inline">Observable</strong> or <strong class="source-inline">Promise</strong> that can be of type <strong class="source-inline">Boolean</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">UrlTree</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Creating </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
// CanDeactivateGuard service</pre><pre class="console">
import { Observable } from 'rxjs/Observable';</pre><pre class="console">
import { CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';</pre><pre class="console">
export interface CanComponentDeactivate {</pre><pre class="console">
<strong class="bold">canDeactivate: () =&gt; Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;</strong></pre><pre class="console">
<strong class="bold">}</strong></pre><pre class="console">
export class CanDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt; {</pre><pre class="console">
  canDeactivate(component:CanComponentDeactivate,current Route:ActivatedRouteSnapshot, currentState:RouterState Snapshot, nextState?: RouterStateSnapshot): Observable &lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {</pre><pre class="console">
  return <strong class="bold">component.canDeactivate();</strong></pre><pre class="console">
}</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the preceding implementation, we have created an<a id="_idIndexMarker1115"/> interface that will be used in the component of the <span class="No-Break"><strong class="source-inline">CanDeactivateGuard</strong></span><span class="No-Break"> service:</span></p>
			<pre class="console">
export class FormComponent implements OnInit, CanComponentDeactivate {
canDeactivate(): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
/* return true or false depends on a specific condition if you want to navigate away from this route or not.*/
}
}</pre>
			<p>In the preceding code example, we have implemented the interface we have created for <span class="No-Break">the component.</span></p>
			<ul>
				<li><strong class="bold">Using </strong><span class="No-Break"><strong class="bold">the guard</strong></span><span class="No-Break">:</span><pre class="console">
{ path: ':id/edit', component: FormComponent, canDeactivate: [CanDeactivateGuard] }</pre></li>
			</ul>
			<p>In the <a id="_idIndexMarker1116"/>preceding code example, we have used the newly created <strong class="source-inline">CanDeactivateGuard</strong> to prevent the user from navigating out of the <strong class="source-inline">FormComponent</strong> based on the applied condition on the <span class="No-Break"><strong class="source-inline">canDeactivate()</strong></span><span class="No-Break"> function.</span></p>
			<p>We have learned about the different guards we can use in our application. Now, let’s implement this in our <span class="No-Break">Angular project.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor284"/>Project implementation</h2>
			<p>The<a id="_idIndexMarker1117"/> first guard we need to apply in our application is the <strong class="source-inline">CanLoad</strong> guard. This is necessary as we want to protect our anti-heroes routes<a id="_idIndexMarker1118"/> from being accessed if there is no valid JWT. To create the <strong class="source-inline">CanLoad</strong> guard, execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng g g core/guards/auth</pre>
			<p>After executing the command, select the <strong class="source-inline">CanLoad</strong> option to generate a new <strong class="source-inline">AuthGuard</strong> class. The only thing we need to change here is the implementation of the <strong class="source-inline">canLoad()</strong> function. The condition we want to apply is to allow the route and modules to be loaded if the JWT <span class="No-Break">is valid.</span></p>
			<p>Let’s have a look at the <span class="No-Break">following implementation:</span></p>
			<pre class="source-code">
@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanLoad {
  constructor(private router: Router, private auth:
    AuthenticateService) {}
  canLoad(route: Route, segments:UrlSegment[]):
    Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean |
      UrlTree&gt; | boolean | UrlTree {
      if (!this.auth.isAuthenticated()) {
        this. router.navigate(['login']);
        return false;
      }
      return true;
}
}</pre>
			<p>In the <a id="_idIndexMarker1119"/>preceding code example, we have used the <strong class="source-inline">isAuthenticated()</strong> function to check that the JWT is valid and not expired. If it<a id="_idIndexMarker1120"/> is valid, this will return <strong class="source-inline">true</strong> and allow us to navigate the route. Otherwise, it will redirect us to the <span class="No-Break">login page.</span></p>
			<p>The last step is to apply the <strong class="source-inline">AuthGuard</strong> class in the anti-heroes route; in the <strong class="source-inline">app-routing.module.ts</strong> file, we will use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const routes: Routes = [
… other routes here
  {
    path: "anti-heroes",
    loadChildren: () =&gt;
      import("./anti-hero/anti-hero.module").then((m) =&gt;
        m.AntiHeroModule),
      canLoad: [AuthGuard]
  }
];</pre>
			<p>We have now successfully applied the <strong class="source-inline">CanLoad</strong> guard in our anti-heroes route. To test whether<a id="_idIndexMarker1121"/> this works, we can try deleting the token in our local storage, and this should redirect us to the login page having no <span class="No-Break">valid JWT.</span></p>
			<p>The<a id="_idIndexMarker1122"/> last route guard we need is the <strong class="source-inline">CanDeactivate</strong> guard; we will apply this guard on our anti-hero form to prevent the user from losing changes when navigating away from the form. To create our <strong class="source-inline">CanDeactivate</strong> guard, we will execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng g g core/guards/form</pre>
			<p>After executing the command, select the <strong class="source-inline">CanDeactivate</strong> option, and this will generate a new <strong class="source-inline">FormGuard</strong> class. We will add an interface to this class that we will use in our <span class="No-Break"><strong class="source-inline">form</strong></span><span class="No-Break"> component.</span></p>
			<p>Let’s have a look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">export interface CanComponentDeactivate {</strong>
<strong class="bold">  canDeactivate: () =&gt; Observable&lt;boolean&gt; |</strong>
<strong class="bold">    Promise&lt;boolean&gt; | boolean;</strong>
<strong class="bold">}</strong>
@Injectable({
  providedIn: 'root'
})
export class FormGuard implements CanDeactivate&lt;unknown&gt; {
  canDeactivate(
    component: CanComponentDeactivate,
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextState?: RouterStateSnapshot): Observable&lt;boolean |
      UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean |
      UrlTree {
<strong class="bold">      return component.canDeactivate ?</strong>
<strong class="bold">        component.canDeactivate() : true;</strong>
  }
}</pre>
			<p>In the <a id="_idIndexMarker1123"/>preceding code example, we have created the <strong class="source-inline">CanComponentDeactivate</strong> interface that the form component will implement. This <a id="_idIndexMarker1124"/>means that the condition will be placed in the component instead of the guard. In <strong class="source-inline">FormComponent</strong>, we will add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export class FormComponent implements OnInit, <strong class="bold">CanComponentDeactivate</strong> {
   … other code implementation
  canDeactivate(): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; |
    boolean {
    const confirmation = window.confirm('Are you sure?');
    return confirmation;
  }
   … other code implementation
}</pre>
			<p>In the preceding code example, we have implemented the <strong class="source-inline">FormComponent</strong> with the <strong class="source-inline">CanComponentDeactivate</strong> interface that we have created; we have added a <strong class="source-inline">window. confirm()</strong>, which will pop up a dialog box that will ask if the user wants to leave the current route. This is a simple implementation of the guard, as we can also add other conditions, such as if we only want to ask this question if there are changes in <span class="No-Break">the form.</span></p>
			<p>The last step is to apply the guard in <a id="_idIndexMarker1125"/>the <span class="No-Break"><strong class="source-inline">FormComponent</strong></span><span class="No-Break"> route.</span></p>
			<p>Let’s have a look at<a id="_idIndexMarker1126"/> the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const routes: Routes = [
 … other routes
  {
    path: "form",
    children: [
      {
        path: "",
<strong class="bold">        canDeactivate: [FormGuard],</strong>
        component: FormComponent
      },
      {
        path: ":id",
<strong class="bold">        canDeactivate: [FormGuard],</strong>
        component: FormComponent
      }
    ]
  },
];</pre>
			<p>Once we have<a id="_idIndexMarker1127"/> applied the <strong class="source-inline">CanDeactivate</strong> guard, navigating out from the anti-hero form will pop up a dialog box for the user, as shown in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer102">
					<img alt="" src="image/B18159_14_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Figure">14.3 – Dialog box on navigating away from the form</p>
			<p>We have <a id="_idIndexMarker1128"/>now successfully applied <a id="_idIndexMarker1129"/>guards in our Angular application; in the next section, we will directly improve our calling of API authentication with the use of NgRx <span class="No-Break">state management.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor285"/>Calling an API</h1>
			<p>We have already<a id="_idIndexMarker1130"/> created user authentication in the previous section by calling the authentication service directly in our component. We have also stored the generated JWT in our local storage using the <strong class="source-inline">setItem</strong> function, which is also happening in our <span class="No-Break">login component.</span></p>
			<p>What we want to achieve is to reduce the responsibility of our components, and as we remember, we are using NgRx state management to call the APIs, and the only responsibility of our components is to dispatch the action, and NgRx will do <span class="No-Break">the rest.</span></p>
			<p>In this section, we will improve our API calls by using the building blocks of the NgRx <span class="No-Break">state management.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor286"/>Creating the actions</h2>
			<p>The first <a id="_idIndexMarker1131"/>step we need is to create the actions for our authentication feature. We will create a file named <strong class="source-inline">auth.actions.ts</strong> in the <strong class="source-inline">auth/state</strong> folder, and we will have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { createAction, props } from '@ngrx/store';
export enum AuthActions {
 LOGIN = '[AUTH] Login',
 SET_TOKEN = '[AUTH] Set Token',
 CREATE_USER = '[AUTH] Create User',
 AUTH_ERROR = '[AUTH] AUTH_ERROR',
}
export const setToken = createAction(
    AuthActions.SET_TOKEN,
    props&lt;{ token: string }&gt;(),
);
export const setError = createAction(
    AuthActions.AUTH_ERROR,
    props&lt;{ error: any }&gt;(),
);</pre>
			<p>In the preceding code, we can see that we have created four action types: the <strong class="source-inline">LOGIN</strong> type will be used for the effect responsible for calling the login API; the <strong class="source-inline">CREATE_USER</strong> type will be used for the effect accountable for calling the register API; the <strong class="source-inline">SET_TOKEN</strong> type will be used by a reducer that will set the generated JWT in the store after the login API has been reached; and lastly, the <strong class="source-inline">AUTH_ERROR</strong> type will be used to set errors in the store if the login or register API has returned <span class="No-Break">an error.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor287"/>Creating the effects</h2>
			<p>After <a id="_idIndexMarker1132"/>creating our actions, now, we will create the effects for calling the login and register API. We will create a file named <strong class="source-inline">auth.effects.ts</strong> in the <strong class="source-inline">auth/state</strong> folder, and we will have the <span class="No-Break">following implementation:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Login Effect</p>
			<pre class="source-code">
@Injectable()
  loginUser$ = createEffect(() =&gt; {
    return this.actions$.pipe(
        ofType(AuthActions.LOGIN),
        mergeMap(((data: {type: string, payload: User}) =&gt;
          this.authService.login(data.payload)
          .pipe(
            map(data =&gt; ({ type: AuthActions.SET_TOKEN,
                           token: data.token })),
            tap(() =&gt;
              this.router.navigate(["anti-heroes"])),
            catchError(async (data) =&gt; ({ type:
              AuthActions.AUTH_ERROR, error: data.error }))
          ))
        ))
    }, {dispatch: true}</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Register Effect</p>
			<pre class="source-code">
  createUser$ = createEffect(() =&gt; {
    return this.actions$.pipe(
        ofType(AuthActions.CREATE_USER),
        mergeMap(((data: {type: string, payload: User}) =&gt;
          this.authService.register(data.payload)
          .pipe(
            tap(() =&gt;  this.router.navigate(["login"])),
            catchError(async (data) =&gt; ({ type:
              AuthActions.AUTH_ERROR, error: data.error }))
          ))
        ))
    }, {dispatch: true}
  );</pre>
			<p>In the <a id="_idIndexMarker1133"/>preceding code, we have created effects for the login and register API. In the <strong class="source-inline">loginUser$</strong> effect, once the login API is successful, it will dispatch the <strong class="source-inline">SET_TOKEN</strong> action and pass the generated JWT, and this will also redirect us to the <span class="No-Break">anti-heroes page.</span></p>
			<p>This is the same behavior we implemented in the previous section. On the other hand, the <strong class="source-inline">createUser$</strong> effect, once the register API is successful, will redirect us to the login page again. This is a simple behavior, and you can customize what will happen next if the registration <span class="No-Break">is successful.</span></p>
			<p>We have also implemented the <strong class="source-inline">AUTH_ERROR</strong> action, which will be called when the login or register <span class="No-Break">API fails.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor288"/>Creating the reducers</h2>
			<p>The<a id="_idIndexMarker1134"/> next step we need is to create the reducers. We will create a file named <strong class="source-inline">auth.reducers.ts</strong> in the <strong class="source-inline">auth/state</strong> folder, and we will have the <span class="No-Break">following implementation:</span></p>
			<pre class="source-code">
export interface AuthState {
    token: string;
    error: any
}
export const initialState: AuthState = {
    token: "",
    error: null
}
export const authReducer = createReducer(
  initialState,
  on(setToken, (state, { token }) =&gt; { return {...state,
     token}}),
  on(setError, (state, { error }) =&gt; { return {...state,
     error}}),
  );</pre>
			<p>In the <a id="_idIndexMarker1135"/>preceding code example, we can see that <strong class="source-inline">AuthState</strong> has two fields, which are <strong class="source-inline">token</strong> and <strong class="source-inline">error</strong>. The <strong class="source-inline">token</strong> field will contain the valid JWT once the <strong class="source-inline">setToken</strong> action is called when the authentication API is successful, and the <strong class="source-inline">error</strong> field will contain the generated error if the login or register <span class="No-Break">API fails.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor289"/>Creating the selectors</h2>
			<p>After<a id="_idIndexMarker1136"/> creating the reducers, we will now create our selector. In this case, our selector will be simple as we only need a selector for the <strong class="source-inline">error</strong> field. We will create a file named <strong class="source-inline">auth.selectors.ts</strong> in the <strong class="source-inline">auth/state</strong> folder, and we will have the <span class="No-Break">following implementation:</span></p>
			<pre class="source-code">
import { createSelector, createFeatureSelector } from '@ngrx/store';
import { AppState } from 'src/app/state/app.state';
import { AuthState } from './auth.reducers';
export const selectAuthState = createFeatureSelector&lt;AuthState&gt;('authState')
export const selectError = () =&gt; createSelector(
    selectAuthState,
    (state: AuthState) =&gt; state.error
)</pre>
			<p>In the <a id="_idIndexMarker1137"/>preceding code example, we have created a selector for our <strong class="source-inline">error</strong> field; we will need this selector to display the error message in our component for <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor290"/>Syncing in local storage</h2>
			<p>The<a id="_idIndexMarker1138"/> next feature we will implement is the syncing of our state in local storage. We can achieve this by using <strong class="source-inline">localStorage.setItem()</strong> in our application. However, using this will not be maintainable, and the setting of values in the storage will be in <span class="No-Break">different places.</span></p>
			<p>To have a better implementation, we will use the <strong class="source-inline">ngrx-store-localstorage</strong> library. To install the library, we will execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
npm install ngrx-store-localstorage --save</pre>
			<p>After successfully installing the library, we should determine the states we want to sync with our local storage. In our case, we want the <strong class="source-inline">token</strong> field in our <strong class="source-inline">auth</strong> state to be synced. To achieve this, we make the following code changes <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">auth.module.ts</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import { localStorageSync } from 'ngrx-store-localstorage';
export function localStorageSyncReducer(reducer: ActionReducer&lt;any&gt;): ActionReducer&lt;any&gt; {
  return localStorageSync({keys: ['token']})(reducer);
}
const metaReducers: Array&lt;MetaReducer&lt;any, any&gt;&gt; = [localStorageSyncReducer];
@NgModule({
  declarations: [
   … declared components
  ],
  imports: [
   … other imported modules
    StoreModule.forFeature('authState', authReducer,
     {metaReducers}),
    EffectsModule.forFeature([AuthEffects]),
  ]
})</pre>
			<p>In the <a id="_idIndexMarker1139"/>preceding code, we can see that we have created a dedicated reducer that calls the <strong class="source-inline">localStorageSync</strong> from the <strong class="source-inline">ngrx-store-localstorage</strong>, which is responsible for adding values in the <span class="No-Break">local storage.</span></p>
			<p>We can also specify what fields we want to sync and, in this case, we have added the token in the keys array. Once the token state changes its value, the new value will also be placed in <span class="No-Break">our storage.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor291"/>Dispatching and selecting a component</h2>
			<p>The<a id="_idIndexMarker1140"/> last step is to dispatch the actions and use the selector <a id="_idIndexMarker1141"/>for our login and register a component. Let’s have a look at the following code implementation for the login and register <span class="No-Break">a component:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">login.component.ts</p>
			<pre class="source-code">
export class LoginComponent{
  error$ = this.store.select(selectError());
  errorSub: Subscription | undefined;
  constructor(private store: Store, private authService:
    AuthenticateService, private router: Router,
      private _snackBar: MatSnackBar) {
    this.checkJWT();
    this.getError();
  }
  submit(data: User) {
    this.store.dispatch({type: AuthActions.LOGIN,
                         payload: data})
  }
  ngOnDestroy(): void {
    this.errorSub?.unsubscribe();
  }
  getError() {
    this.error$.subscribe(data =&gt; {
      if(data) {
        this._snackBar.open(data.message, "Error");
      }
    })
  }
… other code implementation
}</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">register.component.ts</p>
			<pre class="source-code">
export class RegisterComponent implements OnInit, OnDestroy {
  error$ = this.store.select(selectError());
  errorSub: Subscription | undefined;
  constructor(private store: Store,  private _snackBar:
              MatSnackBar) {
    this.getError();
  }
  ngOnDestroy(): void {
    this.errorSub?.unsubscribe();
  }
  submit(data: User) {
    this.store.dispatch({type: AuthActions.CREATE_USER,
                         payload: data})
  }
  getError() {
    this.errorSub = this.error$.subscribe(data =&gt; {
       if(data) {
         this._snackBar.open(data.message, "Error");
       }
     })
   }
… other code implementation
}</pre>
			<p>We <a id="_idIndexMarker1142"/>can see in the preceding code the login and register pages<a id="_idIndexMarker1143"/> have almost the same implementation. We have already removed the call for the login and register service in the <strong class="source-inline">submit</strong> function and replaced it with the dispatching of an action. We have also used the <strong class="source-inline">selectError()</strong> selector to listen to see if the APIs have <span class="No-Break">produced errors.</span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor292"/>Summary</h1>
			<p>With this, we have reached the end of this chapter; let’s have a recap of the valuable things you <span class="No-Break">have learned.</span></p>
			<p>We now know how to implement user authentication in the Angular application, and we have used an HTTP interceptor to intercept HTTP requests to transform its headers and add the valid JWT for the API calls. We have also learned about the different route guards that allow us to protect routes from unauthorized access or prevent accidental loss of data when navigating out from the route. Lastly, we have learned how to use NgRx state management by improving how to implement authentication <span class="No-Break">in Angular.</span></p>
			<p>The next chapter will teach us how to write end-to-end testing in Angular using the <span class="No-Break">Cypress framework.</span></p>
		</div>
	</body></html>