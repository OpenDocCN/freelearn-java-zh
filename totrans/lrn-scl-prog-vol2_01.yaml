- en: Building Blocks of Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"You can''t build a great building on a weak foundation. You must have a solid
    foundation if you''re going to have a strong superstructure."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Gordon B. Hinckley'
  prefs: []
  type: TYPE_NORMAL
- en: Our aim as programmers is to provide a solution to a problem through some logical
    implementation. Programming languages work as a tool for just that. When we implement
    a solution to a problem, we must be able to describe the problem (specification)
    so that a programming language can verify (verification) whether the solution
    indeed solves the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Problem Solution
  prefs: []
  type: TYPE_NORMAL
- en: 'For implementation, we use various programming constructs, which are basic
    entities with some syntactic rules. These entities work as building blocks for
    any programming language. In Scala, we have similar syntax to almost any other
    programming language. We use `keyword/name/classifier/bound-entity`*.* In this
    chapter, our aim is to get familiar with some of the building blocks. We''ll go
    through:'
  prefs: []
  type: TYPE_NORMAL
- en: The `val` and `var` keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type Inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapper classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is underneath a Scala program?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Scala program is a tree of nested definitions. A definition may start with
    a keyword, definition''s name, a classifier, and if it''s a concrete definition,
    then also an entity to which that definition is bound. So the syntax is regular,
    just like any other programming language has `keyword/name/classifier/bound-entity`.
    Let''s take an example. We''ll use Scala REPL to see how a simple Scala program
    is built. For that, let''s import a Scala package named `universe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `import` clause brings all the definitions within the `universe` package
    in scope. It means that the required functions we are going to use are in scope,
    and available for us to use. Then we''ll use a `reify` method, which returns an
    `Expr` to construct `tree` out of our simple Scala program expression. We passed
    a Scala class to our `reify` method. Let''s pretend that a Scala class encapsulates
    some members like a value with the name `segment`and a`name`definitions. We''ll
    talk about all these members as we go along in subsequent sections. For now, let''s
    execute this line and see what we get in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows Scala''s `reify` method''s response. It looks like
    alien code (only for now) that we have no idea about, so let''s find out what''s
    meaningful to us. We know which is somewhat using the class `Car` that we passed
    to generate some code. We recognize this `Car` classand that it''s extending some
    construct named `AnyRef`*.* Every class we define in Scala is a subclass of `AnyRef`,
    hence we can see the interpreter has shown the explicit view of our class definition
    with modifiers, constructors, and members that we defined. We''ll use the `showRaw(expr.tree)`
    method to print tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll take a closer look at the response `res0`*.* The expression started
    with `Block`*,* that'*s* a tree representing the class we defined. Our class `Car`
    contained a value declaration named `segment`, and a method named `name`*.* The
    representation of our class as a tree contains all the entities that we defined.
    And these together construct our program. A tree that we got using the method `showRaw(tree)`give
    us the skeleton of the program we wrote. The tree has String literals like `SUV` and
    `Q7`, value definitions like `segment`, and other meaningful constructs. We'll
    learn the basics of these literals and types of data in Scala in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Vals and vars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing our Scala programs, we can define our member fields using either
    `val` or `var` keywords**.** When we use a `val` keyword to assign a value to
    any attribute, it becomes a value**.** We''re not allowed to change that value
    in the course of our program. So a `val` declaration is used to allow only immutable
    data binding to an attribute. Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used a `val` keyword with an attribute named `a`, and assigned
    it a value `10`. Furthermore, if we try to change that value, the Scala compiler
    will give an error saying: `reassignment to val`*:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala recommends use of `val` as much as possible to support immutability.
    But if an attribute''s value is going to change in the course of our program,
    we can use the `var` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define an attribute using a `var` keyword, we''re allowed to change
    its value. The `var` keyword here stands for variable, which may vary over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a closer look at our declaration of value `a`, you will find that
    we''re not providing the *type* information anywhere, but still the Scala interpreter
    is able to infer the type of defined value, which in our case is an integer. That
    happens because of the Scala compiler''s type inference characteristic. We''ll
    learn about Scala''s type inference later on in this chapter. Scala''s compiler
    is able to infer the type of declared value. So it''s up to the programmer if
    he/she wants to explicitly give type information for good readability of the code,
    or let Scala do this job for him/her. In Scala, we can explicitly give types after
    the attribute''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit different to how we declare fields in Java. First, we use a `val`
    or `var`  keyword , then we give its type, and then give a literal value. Here,
    it''s a `String` literal. When we explicitly define type information for an attribute,
    then the value we give to it should justify to the type specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is not going to work for us, because the type specified is
    `Int`, and the literal bound to our attribute is a `String`, and as expected,
    Scala gifted an error saying type mismatch*.* Now that we know that the bound
    value to our attribute is a literal, I think we're ready to discuss literals in
    Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous discussion, we''ve seen a String literal and an Integer too.
    Here, we''ll discuss all available literals, and how to define them in Scala.
    If you''re coming from a Java background, then quite a few will be the same for
    you: Integer, Floating point, Boolean, Character, and String are similar. Along
    with those, the Tuple and Function literals can be treated as something new to
    learn. All the literals are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll discuss them one by one. Let's start with Integer literals.
  prefs: []
  type: TYPE_NORMAL
- en: Integer literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numeric literals can be expressed in the form of decimal, octal, or hexadecimal
    forms. These are basic integer values that can be signed or unsigned. Octal values
    are deprecated since version 2.10, so if you try out a numeric with a leading
    `0`, it''ll give you a compile time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you define a literal with prefix `0x` or `0X`, it''s going to be a hexadecimal
    literal. Also, the Scala interpreter prints these values as a decimal value. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value to be printed is converted to its decimal equivalent, and then printed.
    Hexadecimal literals can contain digits (0 to 9) and letters (A to F) in upper/lower
    case. Integer literals are further classified into different types such as `Int`,
    `Long`, `Byte`, and `Short` literals. These literals are divided based on the
    range of values. The following table shows the minimum and maximum values for
    specified types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Minimum value** | **Maximum value** |'
  prefs: []
  type: TYPE_TB
- en: '| `Int` | -2^31 | 2^31 - 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Long` | -2^63 | 2^63- 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Short` | -2^15 | 2^15 - 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Byte` | -2^7 | 2^7 - 1 |'
  prefs: []
  type: TYPE_TB
- en: 'If we try to define any literal outside of these ranges for specified types,
    the compiler is going to give some error stating type mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined a normal `Byte` value with type information given explicitly.
    If we try to give a value that is out of the range for a `Byte`, the compiler
    will try to convert that value to an integer, and then try to assign it to the
    attribute, but will fail to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This happened because the compiler tries to assign the converted value of `Int(123456)`
    to `aByte`, which is of `Byte` type. Hence, the types do not match. If we do not
    use type explicitly, then Scala itself is capable of inferring the type due to
    type inference. What if we try to assign an attribute, an integer value that does
    not come under any of the mentioned ranges? Let''s try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In these cases, the Scala compiler is smart enough to sense that things are
    out of control, and gives this error message stating integer number too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define `long` literals, we put the character `L` or `l` at the end of our
    literal. Otherwise, we can also give type information for our attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Byte` and `Short` values can be defined by explicitly telling the interpreter
    about the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Floating point literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Floating point literals include a decimal point that can be at the beginning
    or in between decimal digits, but not at the end. What we mean by this is that
    if you write the following statement, it won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It won''t work if you try this in Scala REPL, the expression will be continued
    in the next line. A quick trick: if you give two more returns in REPL, it''ll
    start a new command. But this is how we cannot create a floating point in Scala,
    so now let''s see how we can define a `Double` or a `Float` value. By default,
    Scala treats decimal point values as `Double`, if we don''t specify it to be a
    `Float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify our values to be of `Float` type the same way we did for `Long` literals
    but with an invisible asterisk. Let''s check that condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All three were supposed to work and give us `Float` values but unfortunately
    only the latter two give back a `Float` value. The first one is going to give
    a type mismatch error stating what you specified is a `Float`, and what you bound
    is of `Double` type. So in Scala, to specify a literal to be of `Float` value,
    we'll have to give suffix `f` or `F`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then we can optionally append `D` or `d` for a `Double` value, but we hardly
    do so. Floating point literals can also have an exponential part in it. That is
    going to be an `e` or `E` followed by an optional `+` or `-`, then few digits.
    `E` or `e` indicates the power of 10\. So a value 3.567e2 means 3.567 multiplied
    by 10^2, which is 356.7, that is, 3.567 times 100.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are simple, they indicate 0 or 1, which mean true or false*.* The basic
    use of Boolean literals is for operating on comparisons, or conditions. These
    two are called Boolean literal, which can''t be replaced by 0 or 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To define a Boolean value, we simply give `true` or `false`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That's all for Boolean literals.
  prefs: []
  type: TYPE_NORMAL
- en: Character literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if you want to break down some words and spaces into separate characters?
    If you do so, you''re creating Character literals. We represent Character literals
    in single quotes. Any Unicode character or escape sequence can be represented
    as a Character literal. What''s an escape sequence, by the way? Let''s take this
    `backslash` for example. If we try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not work at all, because this `''\''` is an escape character. By
    definition, an escape sequence or character is something that does not represent
    itself in String or Character literal. To define these characters, we use this
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used our `doublequotes` as prefix and suffix to our
    string `treatme a string`, and get a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve a list of escape sequence characters shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sequence** | **Value** | **Unicode** |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Backspace | `\u0008` |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Horizontal Tab | `\u0009` |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Carriage Return | `\u000D` |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Line Feed | `\u000A` |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | Form Feed | `\u000C` |'
  prefs: []
  type: TYPE_TB
- en: '| `\"` | Double Quote | `\u0022` |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Backslash | `\u005C` |'
  prefs: []
  type: TYPE_TB
- en: '| `\''` | Single Quote | `\u0027` |'
  prefs: []
  type: TYPE_TB
- en: 'You can also use the hex code to represent a Character literal, but we need
    to put a `\u` preceding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: String literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already used `String` literals in several places at this point. So here,
    apart from a formal introduction to what a `String` literal is, we''ll take a
    look at how `String` literals in Scala are different, since there''s more than
    one way to write `String` literals. Up till now we''ve declared `String` literals
    within double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s start with a `String` literal declaration within triple quotes. Sounds
    interesting! Isn''t it? Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Got an idea about it after seeing it? A string quoted in triple quotes can
    be spanned over multiple lines, thus they are called multi-line string literals.
    These are also called raw strings, because if you try to give any escape character
    inside triple quotes, these multi-line string literals treat them as normal characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So these escape characters are treated as defined if inside multi-line strings.
    This can contain any character, even spaces. There's more to strings, such as
    string interpolation, where we can dynamically assign values to a string from
    the current scope. For that, we use interpolators. We'll study these further a
    little later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Symbol literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A symbol has a name, and it can be defined as a single quote ('') followed
    by alphanumeric identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t use symbols a lot in normal Scala programs. If we try to dig down
    deeper into symbols in Scala, we get to know that everything that we define in
    Scala and give a name to is a symbol. We can check the absolute type for a symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So this `Symbol` is from Scala's reflection package. We're not going to dig
    any deeper. If you're curious though, I would recommend going through the Scala
    documentation at [http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html](http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html).
  prefs: []
  type: TYPE_NORMAL
- en: So that's all about Symbol literals.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuple is a data type in Scala. We''ll discuss the type in this chapter later
    on. First, let''s take a look at how we can define a literal of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined a `Tuple3`, which took three parameters that are in parentheses
    and comma separated. Its type is going to be `Tuple3`, the same way we can define
    `TupleN` with `N` being 1 to 22\. Take a closer look at the REPL response for
    the first declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here `aTuple` has a `Type (String, String, String)`*,* so as we assigned values
    to our identifier, `aTuple` Scala was able to construct type based on values we
    gave. Tuple values can be accessed using a special underscore syntax. Here, we
    use the tuple attribute name, along with an underscore (_), followed by the index
    of value. In our example, we're using `val1`, so we gave *`aTuple._1 value`.*
  prefs: []
  type: TYPE_NORMAL
- en: '*A tuple with two elements is also called a **Pair**, it can be defined using
    the *arrow assoc* (`->`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Function literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function literals are a syntactical way of representing a function. The basic
    structure of a function is something that can take some parameters and return
    a response. If we''ve to represent a function that takes an `Int` value and respond
    in `String`, it will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The left-hand side represents the input parameters, and the right-hand side
    gives parameters that are response type. The type of preceding function literal
    is `Function1[Int, String]`*,* and parameters `Int` and `String` are representing
    input and output parameters respectively. We'll discuss these more when we talk
    about functions in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed how literals are represented in Scala, and now that we know
    this, we've got a heads up to go ahead with data types.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just covered literals in Scala, and with that, we''ve almost covered
    the introduction to all the data types existing as well. We discussed how to define
    `Int`, `Long`, `Short`, and `Byte` data types. Along with these, we also covered
    `Float` and `Double` type. Together, all these are called numeric data types.
    The `Byte`, `Short`, and `Char` are called **sub-range types***.* We also talked
    about Boolean, character, and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Numeric value types
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, these numeric types are called **Primitive Types**, and then there
    are user-defined types as well. But in Scala, these somewhat similar types to
    primitives, are called **value types**. Objects of these value types are not represented
    by an object in the underlying runtime system. Thus, arithmetic operations performed
    are in the form of methods defined for `Int`, and other numeric value types. Think
    about it, it means that we can perform method operations on these. So let''s take
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `x` and `y` are two Integer objects created, and there''s another
    named *`z`.* The result is `*z*`, addition of `x` and `y`*.* The sign *+* here
    is a method on the `Int` object, which means more than just an operator, it''s
    a method that is defined for `Int` types and expects a parameter of `Int` type.
    This is going to have a definition similar :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we get from this? It means that the construct is more powerful because
    the methods look more natural and can also be written for other types. And that''s
    how it''s written for `Int`. Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This happened because there''s a method + overloaded for the type character.
    Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You may refer to the class `Int.scala` at [http://www.scala-lang.org/api/2.12.0/scala/Int.html](http://www.scala-lang.org/api/2.12.0/scala/Int.html),
    and go through how these methods are structured. I would recommend taking a closer
    look at the source of this class, and see if there's anything particular.
  prefs: []
  type: TYPE_NORMAL
- en: Scala's class hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss Scala's class hierarchy, and also a few extra types that exist,
    such as bottom types in Scala. Scala has a unified type hierarchy, which means
    there's only one top-level class that's `Any`, and all other types extend directly
    or indirectly from this top-level type. It also means that any class that we define
    or a class pre-existing in Scala, has access to universal methods defined in the
    top-level class `Any`*.* Two variants of a relationship shown in the following
    figure are **subtypes** and **view***.* The first one, *subtypes* depicts a relationship
    between two types, whereas the latter one shows that one type can be typecasted
    to another one. View relations are shown for value types, where a `Char` can be
    typecasted into `Int`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the relationship between classes in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Scala class hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A little excerpt from Scala''s official website about the *root* of all classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*Class* *Any is the root of the Scala class hierarchy. Every class in a Scala
    execution environment inherits directly or indirectly from this class. Starting
    with Scala 2.10 it is possible to directly extend* *Any using universal traits.
    A universal trait is a trait that extends* *Any**, only has* *def**s as members,
    and does no initialization.*"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, `Any` is the super class of all the existing or defined classes in Scala.
    If you don''t know what inheritance or super class is, here''s a quick example
    for you. Let''s say we defined a type *Item* for our newly opened store''s order
    management application. Each *Item* has some parameters such as `id`. We further
    want to categorize our items and come up with several item categories, such as
    `ElectronicItem` and others. Now, `ElectronicItem` can be a subtype of `Item`*,*
    and `Item` will be called a super type of `ElectronicItem`, hence it doesn''t
    have to declare those three parameters again, and can use them directly to assign
    values. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This example shows what we intended with inheritance. "The `ElectronicItem`
    function extends `Item`" that means "every `ElectronicItem` is an item." That's
    why we're able to refer to ID, UUID, and the name from an `ElectronicItem` instance.
    We've used the `import` statement to bring UUID type in scope of our compilation
    unit, so that when we use UUID, it should not give a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we discussed, every class is a subclass of `Any`*.* Hence, we have
    access to all non-private members of `Any`*.* Methods like *`!=` , `==`*, `asInstanceOf`,
    `equals`, `isInstanceOf`*,* `toString`, and `hashCode` are defined in `Any` class.
    These are in the form of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And yes! You can override these non-final methods, which means you can have
    your own definition of these.
  prefs: []
  type: TYPE_NORMAL
- en: AnyVal and AnyRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both `AnyVal` and `AnyRef` are two subclasses of root class `Any`*.* These
    two represent two families of types in Scala: the first ones are object references,
    the latter are value classes.'
  prefs: []
  type: TYPE_NORMAL
- en: AnyRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AnyRef` class represents all values that are/can be represented as objects
    in the underlying runtime system. It includes all user-defined classes that explicitly
    do not inherit from `AnyVal`. Some standard reference classes are `String`, `Tuple`,
    `Function`, and `Array`. The Scala compiler either provides syntactic sugar for
    them, or generates special code at the time of compilation for their operations.
    We've already seen a bit of syntactic sugar such as `Tuple2`, which can be represented
    as `(A, B)` where A and B are type parameters. An applied form of this `Tuple2`
    can be (`String` and `Int`). In Scala, we represent this as `Tuple2[String, Int]`.
  prefs: []
  type: TYPE_NORMAL
- en: AnyVal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latter, `AnyVal`, represents values not implemented as objects in the underlying
    runtime system. Scala has some predefined numeric and non-numeric value classes
    as shown in the class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to define user-defined value types as well, with some conditions
    applied. Remember I asked you to take a closer look at the source of the `Int.scala`
    file? You may have noticed that there are no `val`  or `var` declarations in the
    class `Int` that extends `AnyVal`*.* This is one of the constraints of defining
    a subtype of `AnyVal`*.* One of the reasons you might consider defining an `AnyVal`
    type is to avoid object instantiation at runtime. Some of the constraints are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It must have a single `val` parameter that is the underlying representation.
    It means that if you declare `class Num(val underlying: Int) extends AnyVal`***,***
    then the compile time representation of it will be of type `Num`, but at runtime
    it''ll be converted to `Int`, and methods defined within will be used as statics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must define only `def`, no `val`, `var`, nested classes, traits, or objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can only extend *universal traits, traits* that extend only the super type
    *Any.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can't be used for pattern-matching, or type tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala's implementation of `AnyVal` includes nine implementations. Out of them,
    `Byte`, `Short`, `Int`, `Long`, `Char`, `Float`, and `Double` are numeric value
    types, while Boolean and Unit are non-numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: Unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala''s `Unit` is a subtype of `AnyVal`, and the implementation contains the
    equals method, which returns a true value if the passed argument is also a `Unit` which
    means a value `()`, that is, just a pair of parentheses otherwise false. Other
    methods are `hashCode` and `toString`, which return an implementation-specific
    hash code and `()` respectively, because Unit has only one value: `()`, which
    is equivalent to Java''s `void` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Boolean represents two values: `true` and `false`. As expected, it implements
    Boolean arithmetic methods such as *and*, *or*, *strict and*, *strict or*, *equality*,
    *inequality*, and negation in the form of `&&`, `||`, `&`, `|`, `==`, `!=`, and
    `unary_`! respectively. Boolean also implements `equals`, `hashCode`, and `toString`
    from the class `Any`.
  prefs: []
  type: TYPE_NORMAL
- en: The equals method checks for argument evaluation and returns its result, while `hashCode`
    returns a fixed implementation-specific hash code based on value `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Null and Nothing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Null and Nothing are called **Bottom types** in Scala. Why do we need these
    Bottom types? Take a look at the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The method `checkIf10AndReturn20` expects a returned value of `Int` type, but
    what's happening here is different. If the passed argument value is not 10, we
    are throwing an exception, yet still the compiler is OK with our code. How can
    this be possible?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because of Type Inference. It always looks for common types in both
    branches of an `if` statement, so if in the other branch, the type extends everything,
    then the inferred type will automatically be the first one. In Scala, `Nothing`
    is a subtype of everything, hence the inferred type automatically becomes of type
    `Int`. Let''s visualize this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing Types Inferred
  prefs: []
  type: TYPE_NORMAL
- en: With this, it's important to understand that Type Inference plays an important
    role in Scala's ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can call type inference a built-in Scala feature that permits us to omit
    type information while writing code. This means we don''t have to specify the
    type while declaring any variables; Scala compiler can do it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not specify our `val`, to be of `String` type, but seeing the value
    of `Invisible`, Scala compiler was able to infer its type. Also with some constraints,
    we can also omit the method''s return types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we did not give the return type, as Scala compiler was able to infer its
    type. But for recursive methods, this doesn''t work. The famous factorial method
    expects you to specify the return type if implementation is recursive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala uses a constraints-driven algorithm to implement type inference. It means
    that Scala compiler tries to infer constraints, and then attempts to unify the
    type. We''re talking about *constraints*, but what are they? A constraint is a
    statement about the types of expression. And even if it''s not an expression,
    for example, when we bind a value to a variable, we must deduce their type too.
    But first think about what we can deduce from the type of an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: If it is related to the type of some identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is related to the type of some other expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is a base type, such as numbers and Booleans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is a constructed type such as a function, whose domain and range types
    are further constrained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scala compiler uses this approach to deduce constraints and then apply unification
    (explanation is beyond the scope of this book) to infer the type. In instances
    where we can''t take out any statements about an expression, inferring type is
    impossible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of type inference only, we''re able to use *syntactic sugar* for cases
    where we''re not expected to specify types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Exciting, isn't it? This way, we've performed our logic simply with less information
    about types. The underscore (`_`) used is syntactic sugar, and it's possible to
    use here because of type inference.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue our good work and learn about implementing this, perform operations
    using all these types, and strengthen our basics.
  prefs: []
  type: TYPE_NORMAL
- en: Operators in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the way we use them, the Scala operators can be classified into three
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: Infix operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postfix operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use operators to perform some operation on operands, which is obvious, and
    the way we implement makes them infix, prefix, or postfix. A basic example of
    an infix operator is addition `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two operands (1 and 10) on which this addition operation is being performed.
    We''ve already discussed that *operators are methods.* It means that somehow the
    operation is being performed as `1.+(10)`, and `1 + 10` is just syntactic sugar
    of how we can write this. This is possible because the method + is defined for
    the given types. Here, in our case, the addition (+) method is defined for `Int`*.* Along
    with this, there are several versions of overloaded methods that support other
    numeric value types as well. It means that we can pass in any other type and it''ll
    be a normal addition operation performed, given that the overloaded version of
    that method is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the method `def+(arg: Char): Int` is invoked and has given an `Int` as
    a result. Think about it, if these methods are not native Scala operators and
    are methods, then we can also create methods like these that work as operators.
    This makes you feel powerful. Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Great! `taxApplied` is the first operator that we defined, it is defined for
    the type `Amount`*.* Our program has a class `Amount` that is just a `Double`
    value, and defines a method `taxApplied`*.* This method expects a double value
    for `tax` to be applied on `this` which is going to be the current value for the
    amount. Operators are a way we can use methods, which is why we have this operator.
    We've used it in object, `Order` while defining a function, `amountAfterTax`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It can also be written as `amount.taxApplied(tax)`*.* There are also a few examples
    in Scala; for example, the `indexOf` operator that works on `String`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve talked about *infix* operators, where the operator sits between two
    operands. Now let''s take a look at another way of using operators, that is, *prefix*
    and *postfix.* The first one, *prefix* operators, sits before an operand. Examples
    of these are `-`, `!`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `!lie`*,* uses the *prefix* operator `!`, and this is the way we put
    an operand to the right of our operator. But this is getting invoked as a method.
    What happens in the background is that Scala uses `unary_` to call these operators,
    and that''s obvious because these operators use only one operand. So our implementation
    looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator `!` is defined for Boolean types, hence we were allowed to make
    calls on Boolean. The other way is where the operand sits on the left side, called
    *postfix* operators. Examples of these operators are convertors such as `toLowerCase`,
    `toInt`, `toString`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It means that these operators are defined as methods in the corresponding types.
    This is one way to classify operators in Scala. Now we''ll go and have a quick
    look at types of operators based on the context they are used in programming languages.
    These are basically classified as:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can perform arithmetic operations using the arithmetic operators. Arithmetic
    operators contain operators for addition (+), subtraction (-), multiplication
    (*), division (/), and remainder (%). We've already seen many examples for addition,
    not mentioning that these operators are methods!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take examples of others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'These operators have their overloaded versions also defined, to see that we
    may try with different types as operands. Let''s take an `Int` and `Double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first operand is an `Int`, and the second one is a `Double`, and since
    `Int` is view-bounded to `Double`, the result is converted to `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Relational operators are used to compare two operands. We have quite enough
    of these, ==, !=, >, <, >= and <=. Let''s try them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: With these operators, we compare two operands for their values, and these operations
    yield a Boolean result.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logical operators include `!` (NOT), `&&` (AND), and `||` (OR), and obviously
    we use these to perform logical operations on operands. These methods are written
    for Boolean, so they expect Boolean operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Logical AND and OR are short-circuiting operators. It means that these are only
    evaluated till the result is undetermined. This is achievable in Scala even though
    operators are methods, because of a feature of function calls named *by-name parameters.*
    It allows us to pass parameters by name that get evaluated later on when required
    at the time of method call.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can perform operations on individual bits of Integer types using Bitwise
    operators. These includes Bitwise AND (&), OR (|), and XOR (^):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'These operators can be performed only on `Int`. If you try this on `Double`,
    it''ll throw an error: *value & is not a member of Double.* These operators perform
    operations on individual bits; in our case, 1 is converted into bits as 01 and
    2 as 10, and then AND, OR, and XOR operations are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 0001 AND 0010 resulted into 00 means 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0001 OR 0010 resulted into 11 means 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0001 XOR 0010 resulted into 11 means 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can perform a logical not-operating using `~` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There are also *three shift methods* for `Int` types named *shift right (>>),
    shift left (<<) and unsigned-shift right (>>>).* These are binary operators working
    on two operands. Bits of operand on the left are shifted by value to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operations such as *2 + 3 * 4 / 2 - 1* can give different results if there''s
    no rule for evaluation of these. Hence we have some precedence-based rules for
    these. We''re going to talk about it in this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For reference purposes, we have the preceding expression. The evaluation gives
    back the result *`7`.* How?
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression *(2 + ((3 * 4) / 2))) - 1* is evaluated in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(2 + (12 / 2)) - 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*(2 + 6) - 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*8 - 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*7*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s based on operator precedence. That''s in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Operator precedence
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, Scala operator expressions are evaluated based
    on the precedence shown. As per the figure, *****, **/**, and **%** are of top
    priority, then comes **+** and **-**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other operators also follow the same precedence as shown. If operators of the
    same precedence level appear together, the operands are evaluated from left to
    right. It means that the expression `1 + 2 + 3 * 3 * 4 - 1` will result in `38`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression *(1 + 2) + ((3 * 3) * 4) - 1* will be evaluated in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1 + 2 + 9 * 4 - 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*1 + 2 + 36 - 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*3 + 36 - 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*39 - 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*38*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This gives clarity of evaluation of expressions in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, we can create our own universe, apart from the native methods provided,
    we can add our own implementations, which we call *Rich Wrapper* classes. This
    is possible because of *Implicit Conversions.* First, we''ll list out some *Wrappers*
    available already:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rich wrappers
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it happens, let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression tries to check if the value of `x` can be converted
    into a `Byte`, and suffices range of a `Byte`, and finds it to be `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you know, range for a `Byte` is -128 to 127\. If you try to assign it to
    a value that's out of range of a `Byte` and expect it to behave like a `Byte`*,* it
    won't work. Thus, the result for the preceding expression is `false`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this `isValidByte`, there are a number of utility methods present
    in the class `RichByte` wrapper class*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'These wrappers methods look like they''re natively defined for the types existing.
    One of the examples is a wrapper around a `String` that is `StringOps`. A String
    in Scala is nothing more than an instance of `java.lang.String`*,* so it''s clear
    that all methods implemented for `java.lang.String` are applicable here as well.
    For example, the `charAt` method does pretty good here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now let's try some methods from `StringOps`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The three methods `capitalize`*,* `toUpperCase`*,* and `toLowerCase` are defined
    in the `StringOps` class and not in `String` classes, but still it works the same
    way as calling a native method for a `String` type. There are more of these methods
    that work as a utility method for `Strings`. This is because of the power of *Implicit
    Conversions.* We'll learn how *Implicits* work in Scala in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the ways to create a `Range` class out of `Int` types can be achieved
    using a method *to.* We call these **rich methods**. It''s really simple to use
    them, and based on the purpose they solve, we can also name them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding are few examples of methods from the `Range` class, which provide
    rich methods for `Int` to create a `Range` with. The `Range` can contain values
    inclusive of those. It''s built with, and can also exclude, those values. Methods
    for building these are `to` and `until`*.* The first includes both values we use
    to build a `Range`; the latter includes only the beginning value. We''ve tried
    all these. As you can see, `rangeOfNumbersUntil` does not contain `199`. We can
    also create a `Range` with some `step` difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty simple; pretty and simple. Especially with the syntax, we are
    able to write concisely because of *Implicit Conversions* and *Type Inference*
    happening at the backend. Scala Compiler is taking care of all those parts, leaving
    us with the simple job of writing code in a beautiful way. Another way of utilizing
    conciseness while writing a String is by using String Interpolators.
  prefs: []
  type: TYPE_NORMAL
- en: String Interpolators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already used String Interpolators, it''s hard to avoid using them when
    they are available to you. Remember when we used them? Yes! When we were learning
    to create operators on our own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This little `s` here is a String interpolator. While using these, we precede
    our `String` with a character named `s`, and inside double quotes of the String,
    we can use any variable with a `$` and it''ll be replaced by its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of how we can use interpolators. The `s` is not the only
    interpolator existing in Scala. We have a couple more interpolators. We'll go
    through them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The `s` interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `f` interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `raw` interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The s interpolator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll look at the `s` interpolator. We''ve already seen how we can
    create a processed String with variables. Now, let''s take an example that takes
    on expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used `${...}` where a `$` sign is followed by a pair of braces {<expression>},
    consisting of the expression to be evaluated. It can be any expression. An arithmetic
    operation like we just did, or a method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined a method named `incrementBy1` that increments any Int passed
    by 1 and gives back the result. We've called that method from our interpolator.
    By the way, it's good to know that our interpolator `s` is a method just like
    any other operator in Scala. We're allowed to create our own interpolators in
    Scala.
  prefs: []
  type: TYPE_NORMAL
- en: f Interpolator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To have something like `printf` styled formatting in Scala, we can use the
    `f` interpolator. We do this by using a `f` preceding the double quotes of our
    string, and then within the String we can use one of the format specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding example, it's clear that we use *f* as a prefix to our string
    and use `$` followed by the expression that includes our format specifier. This
    works as a formatter for our strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few format specifiers are listed as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Format Specifiers
  prefs: []
  type: TYPE_NORMAL
- en: The raw interpolator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final one pre-existing interpolator in Scala is the `raw` interpolator.
    This interpolator does not allow you to use any escape sequence characters in
    your string, it means that if you try to give an escape sequence character, it''ll
    be treated as a normal literal and nothing more. The way we write `raw` interpolator
    is almost similar to the other two interpolators. We precede our String with a
    *raw* keyword and it works for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the string escape character, `\n` was treated as a normal literal,
    and in the resulting string it remained the same. In a normal string, `\n` would
    have converted into a *newline* character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Using this raw interpolator, we can avoid escape sequences. These constructs
    give us a way to write code more efficiently and concisely.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's summarize what we have learned in this chapter. We started with the
    most basic `val` and `var` variable constructs. Then, we learned how we can write
    literals, and what data types we have in Scala. We then studied the interesting
    class hierarchy in Scala, in which we talked about unified class hierarchy and
    value and reference type classes. Later, we learned one of the most important
    concepts of Type Inference in Scala. After that, we started with operators, and
    their precedence. We learned how wrapper classes provide all the richness of functionalities
    to us as programmers. Finally, we learned a simple, but useful way of processing
    our String literals using interpolators. Now, it's clear that with some more practice
    of all these constructs that we've learned we'll be ready to go further and learn
    about some logical and looping constructs that shape up our programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss some looping constructs in Scala, logical
    constructs, and an introduction to pattern matching and how we can control our
    program flow using pattern matching and enabling us to strengthen our programs
    on logical ground.*
  prefs: []
  type: TYPE_NORMAL
