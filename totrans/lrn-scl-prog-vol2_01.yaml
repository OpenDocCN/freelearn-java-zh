- en: Building Blocks of Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala的构建块
- en: '"You can''t build a great building on a weak foundation. You must have a solid
    foundation if you''re going to have a strong superstructure."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"你不能在薄弱的基础上建造一座伟大的建筑。如果你想有一个强大的上层结构，你必须有一个坚实的基础。"'
- en: '- Gordon B. Hinckley'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 戈登·B·欣克利'
- en: Our aim as programmers is to provide a solution to a problem through some logical
    implementation. Programming languages work as a tool for just that. When we implement
    a solution to a problem, we must be able to describe the problem (specification)
    so that a programming language can verify (verification) whether the solution
    indeed solves the problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为程序员的目的是通过某种逻辑实现来提供一个问题的解决方案。编程语言正是为此而工作的工具。当我们实现一个问题的解决方案时，我们必须能够描述这个问题（规范），以便编程语言可以验证（验证）该解决方案是否确实解决了问题。
- en: '![](img/00009.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: Problem Solution
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决方案
- en: 'For implementation, we use various programming constructs, which are basic
    entities with some syntactic rules. These entities work as building blocks for
    any programming language. In Scala, we have similar syntax to almost any other
    programming language. We use `keyword/name/classifier/bound-entity`*.* In this
    chapter, our aim is to get familiar with some of the building blocks. We''ll go
    through:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，我们使用各种编程结构，这些是具有一些语法规则的基本实体。这些实体作为任何编程语言的构建块。在Scala中，我们有与几乎所有其他编程语言相似的语法。我们使用`关键字/名称/分类符/绑定实体`*.*
    在本章中，我们的目标是熟悉一些构建块。我们将探讨：
- en: The `val` and `var` keywords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`和`var`关键字'
- en: Literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字面量
- en: Data types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Type Inference
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断
- en: Operators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: Wrapper classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装类
- en: String interpolation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串插值
- en: What is underneath a Scala program?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala程序下面是什么？
- en: 'A Scala program is a tree of nested definitions. A definition may start with
    a keyword, definition''s name, a classifier, and if it''s a concrete definition,
    then also an entity to which that definition is bound. So the syntax is regular,
    just like any other programming language has `keyword/name/classifier/bound-entity`.
    Let''s take an example. We''ll use Scala REPL to see how a simple Scala program
    is built. For that, let''s import a Scala package named `universe`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Scala程序是一个嵌套定义的树。一个定义可能以一个关键字、定义的名称、一个分类符开始，如果是具体定义，那么还有一个与该定义绑定的实体。所以语法是规范的，就像任何其他编程语言都有`关键字/名称/分类符/绑定实体`。让我们举一个例子。我们将使用Scala
    REPL来查看一个简单的Scala程序是如何构建的。为此，让我们导入一个名为`universe`的Scala包：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `import` clause brings all the definitions within the `universe` package
    in scope. It means that the required functions we are going to use are in scope,
    and available for us to use. Then we''ll use a `reify` method, which returns an
    `Expr` to construct `tree` out of our simple Scala program expression. We passed
    a Scala class to our `reify` method. Let''s pretend that a Scala class encapsulates
    some members like a value with the name `segment`and a`name`definitions. We''ll
    talk about all these members as we go along in subsequent sections. For now, let''s
    execute this line and see what we get in response:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`import`子句将`universe`包内的所有定义都纳入作用域。这意味着我们将要使用的所需函数都在作用域内，可供我们使用。然后我们将使用一个`reify`方法，它返回一个`Expr`来从我们的简单Scala程序表达式构建`tree`。我们向`reify`方法传递了一个Scala类。让我们假装一个Scala类封装了一些成员，如名为`segment`的值和一个`name`定义。我们将在后续章节中讨论所有这些成员。现在，让我们执行这一行并查看我们得到的响应：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code shows Scala''s `reify` method''s response. It looks like
    alien code (only for now) that we have no idea about, so let''s find out what''s
    meaningful to us. We know which is somewhat using the class `Car` that we passed
    to generate some code. We recognize this `Car` classand that it''s extending some
    construct named `AnyRef`*.* Every class we define in Scala is a subclass of `AnyRef`,
    hence we can see the interpreter has shown the explicit view of our class definition
    with modifiers, constructors, and members that we defined. We''ll use the `showRaw(expr.tree)`
    method to print tree:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码显示了Scala的`reify`方法的响应。它看起来像是外星代码（目前是这样），我们对此一无所知，所以让我们找出对我们有意义的内容。我们知道它使用我们传递的`Car`类来生成一些代码。我们认出这个`Car`类，并且知道它扩展了一个名为`AnyRef`*.*
    的结构。我们在Scala中定义的每个类都是`AnyRef`的子类，因此我们可以看到解释器已经显示了我们的类定义的显式视图，包括我们定义的修饰符、构造函数和成员。我们将使用`showRaw(expr.tree)`方法来打印树：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we'll take a closer look at the response `res0`*.* The expression started
    with `Block`*,* that'*s* a tree representing the class we defined. Our class `Car`
    contained a value declaration named `segment`, and a method named `name`*.* The
    representation of our class as a tree contains all the entities that we defined.
    And these together construct our program. A tree that we got using the method `showRaw(tree)`give
    us the skeleton of the program we wrote. The tree has String literals like `SUV` and
    `Q7`, value definitions like `segment`, and other meaningful constructs. We'll
    learn the basics of these literals and types of data in Scala in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更仔细地查看响应 `res0`*.* 表达式以 `Block` 开头*，*这是一个表示我们定义的类的树。我们的类 `Car` 包含一个名为
    `segment` 的值声明和一个名为 `name` 的方法*.* 我们将类表示为树的表示包含我们定义的所有实体。这些共同构成了我们的程序。使用方法 `showRaw(tree)`
    获得的树为我们编写的程序的骨架。这个树包含字符串字面量如 `SUV` 和 `Q7`，值定义如 `segment`，以及其他有意义的结构。我们将在本章学习这些字面量和Scala中的数据类型的基本知识。
- en: Vals and vars
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值和变量
- en: 'While writing our Scala programs, we can define our member fields using either
    `val` or `var` keywords**.** When we use a `val` keyword to assign a value to
    any attribute, it becomes a value**.** We''re not allowed to change that value
    in the course of our program. So a `val` declaration is used to allow only immutable
    data binding to an attribute. Let''s take an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的Scala程序时，我们可以使用 `val` 或 `var` 关键字来定义我们的成员字段**。**当我们使用 `val` 关键字将值分配给任何属性时，它就变成了一个值**。**在程序执行过程中不允许更改该值。因此，`val`
    声明用于允许将不可变数据绑定到属性。让我们举一个例子：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we have used a `val` keyword with an attribute named `a`, and assigned
    it a value `10`. Furthermore, if we try to change that value, the Scala compiler
    will give an error saying: `reassignment to val`*:*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `val` 关键字和一个名为 `a` 的属性，并给它赋值 `10`。此外，如果我们尝试更改该值，Scala编译器将给出一个错误，说：`reassignment
    to val`*:*
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Scala recommends use of `val` as much as possible to support immutability.
    But if an attribute''s value is going to change in the course of our program,
    we can use the `var` declaration:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Scala建议尽可能使用 `val` 以支持不可变性。但如果属性值在程序执行过程中将要改变，我们可以使用 `var` 声明：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we define an attribute using a `var` keyword, we''re allowed to change
    its value. The `var` keyword here stands for variable, which may vary over time:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `var` 关键字定义一个属性时，我们可以更改其值。这里的 `var` 关键字代表变量，它可能随时间变化：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you take a closer look at our declaration of value `a`, you will find that
    we''re not providing the *type* information anywhere, but still the Scala interpreter
    is able to infer the type of defined value, which in our case is an integer. That
    happens because of the Scala compiler''s type inference characteristic. We''ll
    learn about Scala''s type inference later on in this chapter. Scala''s compiler
    is able to infer the type of declared value. So it''s up to the programmer if
    he/she wants to explicitly give type information for good readability of the code,
    or let Scala do this job for him/her. In Scala, we can explicitly give types after
    the attribute''s name:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察我们的值声明 `a`，你会发现我们并没有在任何地方提供 *类型* 信息，但Scala解释器仍然能够推断出定义的值的类型，在我们的例子中是一个整数。这是因为Scala编译器的类型推断特性。我们将在本章后面学习Scala的类型推断。Scala的编译器能够推断出声明的值的类型。因此，取决于程序员是否希望显式地给出类型信息以增强代码的可读性，或者让Scala为他/她完成这项工作。在Scala中，我们可以在属性名称之后显式地给出类型：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a bit different to how we declare fields in Java. First, we use a `val`
    or `var`  keyword , then we give its type, and then give a literal value. Here,
    it''s a `String` literal. When we explicitly define type information for an attribute,
    then the value we give to it should justify to the type specified:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在Java中声明字段的方式略有不同。首先，我们使用 `val` 或 `var` 关键字，然后给出其类型，然后给出一个字面量值。在这里，它是一个
    `String` 字面量。当我们显式地为属性定义类型信息时，我们给出的值应该与指定的类型相符：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code is not going to work for us, because the type specified is
    `Int`, and the literal bound to our attribute is a `String`, and as expected,
    Scala gifted an error saying type mismatch*.* Now that we know that the bound
    value to our attribute is a literal, I think we're ready to discuss literals in
    Scala.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对我们不起作用，因为指定的类型是 `Int`，而绑定到我们的属性上的字面量是一个 `String`，正如预期的那样，Scala抛出了一个类型不匹配*错误*。现在我们知道绑定到我们的属性上的值是一个字面量，我认为我们已经准备好讨论Scala中的字面量了。
- en: Literals
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量
- en: 'In the previous discussion, we''ve seen a String literal and an Integer too.
    Here, we''ll discuss all available literals, and how to define them in Scala.
    If you''re coming from a Java background, then quite a few will be the same for
    you: Integer, Floating point, Boolean, Character, and String are similar. Along
    with those, the Tuple and Function literals can be treated as something new to
    learn. All the literals are listed as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的讨论中，我们已经看到了字符串字面量和整数。在这里，我们将讨论所有可用的字面量，以及如何在 Scala 中定义它们。如果你来自 Java 背景，那么其中相当一部分对你来说将是相同的：整数、浮点数、布尔、字符和字符串是相似的。除了这些之外，元组和函数字面量可以被视为新学习的内容。所有字面量如下所示：
- en: Integer literals
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数字面量
- en: Floating point literals
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点字面量
- en: Boolean literals
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔字面量
- en: Character literals
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符字面量
- en: String literals
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: Symbol literals
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号字面量
- en: Tuple literals
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组字面量
- en: Function literals
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数字面量
- en: We'll discuss them one by one. Let's start with Integer literals.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一讨论它们。让我们从整数字面量开始。
- en: Integer literals
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数字面量
- en: 'Numeric literals can be expressed in the form of decimal, octal, or hexadecimal
    forms. These are basic integer values that can be signed or unsigned. Octal values
    are deprecated since version 2.10, so if you try out a numeric with a leading
    `0`, it''ll give you a compile time error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数值字面量可以表示为十进制、八进制或十六进制形式。这些是基本整数值，可以是带符号或无符号的。自版本 2.10 起已弃用八进制值，因此如果你尝试使用前导`0`的数值，它将给出编译时错误：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you define a literal with prefix `0x` or `0X`, it''s going to be a hexadecimal
    literal. Also, the Scala interpreter prints these values as a decimal value. For
    example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前缀`0x`或`0X`定义字面量，它将是一个十六进制字面量。此外，Scala 解释器将这些值作为十进制值打印出来。例如：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value to be printed is converted to its decimal equivalent, and then printed.
    Hexadecimal literals can contain digits (0 to 9) and letters (A to F) in upper/lower
    case. Integer literals are further classified into different types such as `Int`,
    `Long`, `Byte`, and `Short` literals. These literals are divided based on the
    range of values. The following table shows the minimum and maximum values for
    specified types:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印的值被转换为它的十进制等效值，然后打印出来。十六进制字面量可以包含数字（0到9）和字母（A到F），大小写不敏感。整数字面量进一步分为不同类型，如`Int`、`Long`、`Byte`和`Short`字面量。这些字面量根据值的范围进行划分。以下表格显示了指定类型的最大和最小值：
- en: '| **Type** | **Minimum value** | **Maximum value** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **最小值** | **最大值** |'
- en: '| `Int` | -2^31 | 2^31 - 1 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | -2^31 | 2^31 - 1 |'
- en: '| `Long` | -2^63 | 2^63- 1 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Long` | -2^63 | 2^63- 1 |'
- en: '| `Short` | -2^15 | 2^15 - 1 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | -2^15 | 2^15 - 1 |'
- en: '| `Byte` | -2^7 | 2^7 - 1 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Byte` | -2^7 | 2^7 - 1 |'
- en: 'If we try to define any literal outside of these ranges for specified types,
    the compiler is going to give some error stating type mismatch:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试为指定类型定义超出这些范围的任何字面量，编译器将给出一些错误，指出类型不匹配：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we defined a normal `Byte` value with type information given explicitly.
    If we try to give a value that is out of the range for a `Byte`, the compiler
    will try to convert that value to an integer, and then try to assign it to the
    attribute, but will fail to do so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个带有显式类型信息的普通`Byte`值。如果我们尝试赋予一个超出`Byte`值范围的值，编译器将尝试将该值转换为整数，然后尝试将其分配给属性，但将无法完成：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This happened because the compiler tries to assign the converted value of `Int(123456)`
    to `aByte`, which is of `Byte` type. Hence, the types do not match. If we do not
    use type explicitly, then Scala itself is capable of inferring the type due to
    type inference. What if we try to assign an attribute, an integer value that does
    not come under any of the mentioned ranges? Let''s try:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器试图将`Int(123456)`转换后的值分配给`Byte`类型的`aByte`，因此类型不匹配。如果我们不显式使用类型，Scala 本身就足以通过类型推断推断出类型。如果我们尝试分配一个属性，一个不属于任何提到的范围的整数值，会怎样呢？让我们试试：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In these cases, the Scala compiler is smart enough to sense that things are
    out of control, and gives this error message stating integer number too large.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Scala 编译器足够聪明，能够感知到情况失控，并给出整数数值过大的错误信息。
- en: 'To define `long` literals, we put the character `L` or `l` at the end of our
    literal. Otherwise, we can also give type information for our attribute:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义`long`字面量，我们在字面量的末尾放置字符`L`或`l`。否则，我们也可以为我们的属性提供类型信息：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Byte` and `Short` values can be defined by explicitly telling the interpreter
    about the type:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过明确告诉解释器类型来定义`Byte`和`Short`值：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Floating point literals
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点字面量
- en: 'Floating point literals include a decimal point that can be at the beginning
    or in between decimal digits, but not at the end. What we mean by this is that
    if you write the following statement, it won''t work:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点字面量包括一个可以位于开头或数字之间的十进制点，但不能位于末尾。我们的意思是，如果你写下以下语句，它将不会工作：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It won''t work if you try this in Scala REPL, the expression will be continued
    in the next line. A quick trick: if you give two more returns in REPL, it''ll
    start a new command. But this is how we cannot create a floating point in Scala,
    so now let''s see how we can define a `Double` or a `Float` value. By default,
    Scala treats decimal point values as `Double`, if we don''t specify it to be a
    `Float`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在Scala REPL中这样做，表达式将会继续到下一行。一个快速技巧：如果你在REPL中给出两个额外的回车，它将开始一个新的命令。但这就是我们无法在Scala中创建浮点数的原因，所以现在让我们看看我们如何定义一个`Double`或`Float`值。默认情况下，Scala将十进制点值视为`Double`，如果我们不指定它为`Float`：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can specify our values to be of `Float` type the same way we did for `Long` literals
    but with an invisible asterisk. Let''s check that condition:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像对`Long`字面量那样指定我们的值要为`Float`类型，但有一个不可见的星号。让我们检查一下这个条件：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All three were supposed to work and give us `Float` values but unfortunately
    only the latter two give back a `Float` value. The first one is going to give
    a type mismatch error stating what you specified is a `Float`, and what you bound
    is of `Double` type. So in Scala, to specify a literal to be of `Float` value,
    we'll have to give suffix `f` or `F`*:*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的三个都应该工作并给我们返回`Float`值，但不幸的是，只有后两个返回了`Float`值。第一个将会返回一个类型不匹配的错误，指出你指定的是`Float`类型，而你绑定的是`Double`类型。所以，在Scala中，为了指定一个字面量为`Float`类型，我们必须给出后缀`f`或`F`：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then we can optionally append `D` or `d` for a `Double` value, but we hardly
    do so. Floating point literals can also have an exponential part in it. That is
    going to be an `e` or `E` followed by an optional `+` or `-`, then few digits.
    `E` or `e` indicates the power of 10\. So a value 3.567e2 means 3.567 multiplied
    by 10^2, which is 356.7, that is, 3.567 times 100.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以选择性地追加`D`或`d`以表示`Double`值，但我们很少这样做。浮点字面量也可以包含指数部分。这将是一个`e`或`E`，后面跟着一个可选的`+`或`-`，然后是一些数字。`E`或`e`表示10的幂。所以，一个3.567e2的值意味着3.567乘以10^2，即356.7，也就是说，3.567乘以100。
- en: Boolean literals
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔字面量
- en: 'These are simple, they indicate 0 or 1, which mean true or false*.* The basic
    use of Boolean literals is for operating on comparisons, or conditions. These
    two are called Boolean literal, which can''t be replaced by 0 or 1:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些很简单，它们表示0或1，这意味着true或false。布尔字面量的基本用途是在比较或条件上操作。这两个被称为布尔字面量，不能被0或1替换：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To define a Boolean value, we simply give `true` or `false`*:*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个布尔值，我们只需给出`true`或`false`：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's all for Boolean literals.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是布尔字面量的全部内容。
- en: Character literals
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符字面量
- en: 'What if you want to break down some words and spaces into separate characters?
    If you do so, you''re creating Character literals. We represent Character literals
    in single quotes. Any Unicode character or escape sequence can be represented
    as a Character literal. What''s an escape sequence, by the way? Let''s take this
    `backslash` for example. If we try this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将一些单词和空格分解成单独的字符，你会创建字符字面量。我们用单引号表示字符字面量。任何Unicode字符或转义序列都可以表示为字符字面量。顺便问一下，什么是转义序列？以这个`backslash`为例。如果我们尝试这样做：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will not work at all, because this `''\''` is an escape character. By
    definition, an escape sequence or character is something that does not represent
    itself in String or Character literal. To define these characters, we use this
    sequence:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完全不工作，因为这个`\'`是一个转义字符。根据定义，转义序列或字符是在字符串或字符字面量中不表示自身的字符。为了定义这些字符，我们使用这个序列：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we used our `doublequotes` as prefix and suffix to our
    string `treatme a string`, and get a response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用我们的`doublequotes`作为字符串`treatme a string`的前缀和后缀，并得到一个响应。
- en: 'We''ve a list of escape sequence characters shown in the following table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下表中展示了以下转义序列字符列表：
- en: '| **Sequence** | **Value** | **Unicode** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **序列** | **值** | **Unicode** |'
- en: '| `\b` | Backspace | `\u0008` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 退格 | `\u0008` |'
- en: '| `\t` | Horizontal Tab | `\u0009` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 水平制表符 | `\u0009` |'
- en: '| `\r` | Carriage Return | `\u000D` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 | `\u000D` |'
- en: '| `\n` | Line Feed | `\u000A` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 | `\u000A` |'
- en: '| `\f` | Form Feed | `\u000C` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 分页符 | `\u000C` |'
- en: '| `\"` | Double Quote | `\u0022` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 | `\u0022` |'
- en: '| `\\` | Backslash | `\u005C` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 | `\u005C` |'
- en: '| `\''` | Single Quote | `\u0027` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 | `\u0027` |'
- en: 'You can also use the hex code to represent a Character literal, but we need
    to put a `\u` preceding it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用十六进制代码来表示字符字面量，但我们需要在其前面加上`\u`：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: String literals
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'We''ve already used `String` literals in several places at this point. So here,
    apart from a formal introduction to what a `String` literal is, we''ll take a
    look at how `String` literals in Scala are different, since there''s more than
    one way to write `String` literals. Up till now we''ve declared `String` literals
    within double quotes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在几个地方使用了`String`字面量。所以在这里，除了对`String`字面量的正式介绍外，我们还将看看Scala中的`String`字面量是如何不同的，因为写`String`字面量的方式不止一种。到目前为止，我们已经在双引号内声明了`String`字面量：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So let''s start with a `String` literal declaration within triple quotes. Sounds
    interesting! Isn''t it? Take a look at this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们从三引号内的`String`字面量声明开始。听起来很有趣！不是吗？看看这个：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Got an idea about it after seeing it? A string quoted in triple quotes can
    be spanned over multiple lines, thus they are called multi-line string literals.
    These are also called raw strings, because if you try to give any escape character
    inside triple quotes, these multi-line string literals treat them as normal characters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看到它后有什么想法吗？三引号引起来的字符串可以跨越多行，因此它们被称为多行字符串字面量。这些也被称为原始字符串，因为如果你在三个引号内尝试给出任何转义字符，这些多行字符串字面量会将它们视为普通字符：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So these escape characters are treated as defined if inside multi-line strings.
    This can contain any character, even spaces. There's more to strings, such as
    string interpolation, where we can dynamically assign values to a string from
    the current scope. For that, we use interpolators. We'll study these further a
    little later on in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些转义字符在多行字符串内部被视为已定义。这可以包含任何字符，甚至是空格。字符串还有很多其他功能，比如字符串插值，我们可以从当前作用域动态地将值分配给字符串。为此，我们使用插值符。我们将在本章稍后进一步研究这些内容。
- en: Symbol literals
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号字面量
- en: 'A symbol has a name, and it can be defined as a single quote ('') followed
    by alphanumeric identifier:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 符号有一个名称，它可以定义为单引号（'）后跟字母数字标识符：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We don''t use symbols a lot in normal Scala programs. If we try to dig down
    deeper into symbols in Scala, we get to know that everything that we define in
    Scala and give a name to is a symbol. We can check the absolute type for a symbol:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的Scala程序中，我们并不经常使用符号。如果我们试图深入了解Scala中的符号，我们会知道我们在Scala中定义并命名的每一件事都是符号。我们可以检查符号的绝对类型：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So this `Symbol` is from Scala's reflection package. We're not going to dig
    any deeper. If you're curious though, I would recommend going through the Scala
    documentation at [http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html](http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个`Symbol`来自Scala的反射包。我们不会深入挖掘。如果你好奇的话，我建议你阅读Scala文档[http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html](http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html)。
- en: So that's all about Symbol literals.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是关于符号字面量的全部内容。
- en: Tuple literals
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组字面量
- en: 'Tuple is a data type in Scala. We''ll discuss the type in this chapter later
    on. First, let''s take a look at how we can define a literal of the same type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是Scala中的数据类型。我们将在本章后面讨论类型。首先，让我们看看我们如何定义相同类型的字面量：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we defined a `Tuple3`, which took three parameters that are in parentheses
    and comma separated. Its type is going to be `Tuple3`, the same way we can define
    `TupleN` with `N` being 1 to 22\. Take a closer look at the REPL response for
    the first declaration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`Tuple3`，它接受三个参数，这些参数用括号和逗号分隔。它的类型将是`Tuple3`，就像我们可以用`N`为1到22来定义`TupleN`一样。让我们仔细看看第一个声明的REPL响应：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here `aTuple` has a `Type (String, String, String)`*,* so as we assigned values
    to our identifier, `aTuple` Scala was able to construct type based on values we
    gave. Tuple values can be accessed using a special underscore syntax. Here, we
    use the tuple attribute name, along with an underscore (_), followed by the index
    of value. In our example, we're using `val1`, so we gave *`aTuple._1 value`.*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`aTuple`有`Type (String, String, String)`，所以当我们为我们的标识符分配值时，`aTuple` Scala能够根据我们给出的值构造类型。元组值可以使用特殊下划线语法来访问。在这里，我们使用元组属性名称，以及一个下划线（_），然后是值的索引。在我们的例子中，我们使用`val1`，所以我们给出了*`aTuple._1
    value`*。
- en: '*A tuple with two elements is also called a **Pair**, it can be defined using
    the *arrow assoc* (`->`) operator:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*有两个元素的元组也称为**对**，可以使用*箭头关联*（`->`）运算符来定义：'
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Function literals
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字面量
- en: 'Function literals are a syntactical way of representing a function. The basic
    structure of a function is something that can take some parameters and return
    a response. If we''ve to represent a function that takes an `Int` value and respond
    in `String`, it will be like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量是一种表示函数的语法方式。函数的基本结构是能够接受一些参数并返回响应的东西。如果我们必须表示一个接受 `Int` 值并返回 `String`
    的函数，它将像这样：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The left-hand side represents the input parameters, and the right-hand side
    gives parameters that are response type. The type of preceding function literal
    is `Function1[Int, String]`*,* and parameters `Int` and `String` are representing
    input and output parameters respectively. We'll discuss these more when we talk
    about functions in subsequent chapters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 左边表示输入参数，右边给出响应类型的参数。前置函数字面量的类型是 `Function1[Int, String]`，参数 `Int` 和 `String`
    分别代表输入和输出参数。我们将在后续章节讨论函数时进一步讨论这些内容。
- en: We have discussed how literals are represented in Scala, and now that we know
    this, we've got a heads up to go ahead with data types.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在 Scala 中字面量的表示方式，现在我们知道了这一点，我们就有了继续进行数据类型学习的先机。
- en: Data types
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'We have just covered literals in Scala, and with that, we''ve almost covered
    the introduction to all the data types existing as well. We discussed how to define
    `Int`, `Long`, `Short`, and `Byte` data types. Along with these, we also covered
    `Float` and `Double` type. Together, all these are called numeric data types.
    The `Byte`, `Short`, and `Char` are called **sub-range types***.* We also talked
    about Boolean, character, and strings:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了 Scala 中的字面量，并且随着这一点，我们几乎涵盖了所有现有数据类型的介绍。我们讨论了如何定义 `Int`、`Long`、`Short`
    和 `Byte` 数据类型。除了这些，我们还涵盖了 `Float` 和 `Double` 类型。所有这些统称为数值数据类型。`Byte`、`Short` 和
    `Char` 被称为 **子范围类型**。我们还讨论了布尔值、字符和字符串：
- en: '![](img/00010.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: Numeric value types
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数值值类型
- en: 'In Java, these numeric types are called **Primitive Types**, and then there
    are user-defined types as well. But in Scala, these somewhat similar types to
    primitives, are called **value types**. Objects of these value types are not represented
    by an object in the underlying runtime system. Thus, arithmetic operations performed
    are in the form of methods defined for `Int`, and other numeric value types. Think
    about it, it means that we can perform method operations on these. So let''s take
    an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，这些数值类型被称为 **原始类型**，然后还有用户定义的类型。但在 Scala 中，这些与原始类型有些相似的类型被称为 **值类型**。这些值类型的对象在底层运行时系统中不是由对象表示的。因此，执行的计算操作是以
    `Int` 和其他数值值类型定义的方法的形式进行的。想想看，这意味着我们可以对这些执行方法操作。所以，让我们举一个例子：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, `x` and `y` are two Integer objects created, and there''s another
    named *`z`.* The result is `*z*`, addition of `x` and `y`*.* The sign *+* here
    is a method on the `Int` object, which means more than just an operator, it''s
    a method that is defined for `Int` types and expects a parameter of `Int` type.
    This is going to have a definition similar :'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建了两个名为 `x` 和 `y` 的 Integer 对象，还有一个名为 *`z`* 的对象。结果是 `*z*`，即 `x` 和 `y` 的和。这里的符号
    *+* 是 `Int` 对象上的一个方法，这意味着它不仅仅是一个运算符，它是一个为 `Int` 类型定义的方法，并期望一个 `Int` 类型的参数。这将有一个类似的定义：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What do we get from this? It means that the construct is more powerful because
    the methods look more natural and can also be written for other types. And that''s
    how it''s written for `Int`. Let''s try this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这得到了什么？这意味着这个结构更强大，因为方法看起来更自然，也可以为其他类型编写。这就是为 `Int` 编写的方式。让我们试试：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This happened because there''s a method + overloaded for the type character.
    Something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为为字符类型有一个重载的 + 方法。类似于这样：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You may refer to the class `Int.scala` at [http://www.scala-lang.org/api/2.12.0/scala/Int.html](http://www.scala-lang.org/api/2.12.0/scala/Int.html),
    and go through how these methods are structured. I would recommend taking a closer
    look at the source of this class, and see if there's anything particular.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考类 `Int.scala` 在 [http://www.scala-lang.org/api/2.12.0/scala/Int.html](http://www.scala-lang.org/api/2.12.0/scala/Int.html)，并了解这些方法是如何结构的。我建议您仔细查看这个类的源代码，看看是否有任何特别之处。
- en: Scala's class hierarchy
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 的类层次结构
- en: Let's discuss Scala's class hierarchy, and also a few extra types that exist,
    such as bottom types in Scala. Scala has a unified type hierarchy, which means
    there's only one top-level class that's `Any`, and all other types extend directly
    or indirectly from this top-level type. It also means that any class that we define
    or a class pre-existing in Scala, has access to universal methods defined in the
    top-level class `Any`*.* Two variants of a relationship shown in the following
    figure are **subtypes** and **view***.* The first one, *subtypes* depicts a relationship
    between two types, whereas the latter one shows that one type can be typecasted
    to another one. View relations are shown for value types, where a `Char` can be
    typecasted into `Int`*.*
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论 Scala 的类层次结构，以及一些存在的额外类型，例如 Scala 中的底层类型。Scala 有一个统一的类型层次结构，这意味着只有一个顶级类
    `Any`，所有其他类型都直接或间接地从这个顶级类型扩展。这也意味着我们定义的任何类或 Scala 中预先存在的类都可以访问顶级类 `Any` 中定义的通用方法。以下图中显示的关系的两种变体是
    **子类型** 和 **视图**。前者，*子类型* 描述了两种类型之间的关系，而后者显示了一种类型可以被转换为另一种类型。视图关系用于值类型，其中 `Char`
    可以转换为 `Int`。
- en: 'The following figure shows the relationship between classes in Scala:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了 Scala 中类之间的关系：
- en: '![](img/00011.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: Scala class hierarchy
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 类层次结构
- en: Any
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Any
- en: 'A little excerpt from Scala''s official website about the *root* of all classes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Scala 官方网站关于所有类 *根* 的一个片段：
- en: '"*Class* *Any is the root of the Scala class hierarchy. Every class in a Scala
    execution environment inherits directly or indirectly from this class. Starting
    with Scala 2.10 it is possible to directly extend* *Any using universal traits.
    A universal trait is a trait that extends* *Any**, only has* *def**s as members,
    and does no initialization.*"'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '"*类 *Any 是 Scala 类层次结构的根。在 Scala 执行环境中，每个类都直接或间接地继承自这个类。从 Scala 2.10 开始，可以直接使用通用特质扩展
    *Any*。通用特质是一个扩展 *Any* 的特质，只有 *def* 成员，并且不进行初始化。*"'
- en: 'Yes, `Any` is the super class of all the existing or defined classes in Scala.
    If you don''t know what inheritance or super class is, here''s a quick example
    for you. Let''s say we defined a type *Item* for our newly opened store''s order
    management application. Each *Item* has some parameters such as `id`. We further
    want to categorize our items and come up with several item categories, such as
    `ElectronicItem` and others. Now, `ElectronicItem` can be a subtype of `Item`*,*
    and `Item` will be called a super type of `ElectronicItem`, hence it doesn''t
    have to declare those three parameters again, and can use them directly to assign
    values. Take a look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`Any` 是 Scala 中所有现有或定义的类的超类。如果你不知道继承或超类是什么，这里有一个快速示例给你。假设我们为我们的新开店铺的订单管理应用程序定义了一个类型
    *Item*。每个 *Item* 都有一些参数，例如 `id`。我们进一步想要对商品进行分类，并提出了几个商品类别，例如 `ElectronicItem`
    等。现在，`ElectronicItem` 可以是 `Item` 的子类型，而 `Item` 将被称为 `ElectronicItem` 的超类型，因此它不需要再次声明这三个参数，可以直接使用它们来赋值。看看下面的例子：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is the result:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的结果是：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example shows what we intended with inheritance. "The `ElectronicItem`
    function extends `Item`" that means "every `ElectronicItem` is an item." That's
    why we're able to refer to ID, UUID, and the name from an `ElectronicItem` instance.
    We've used the `import` statement to bring UUID type in scope of our compilation
    unit, so that when we use UUID, it should not give a compile-time error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们用继承想要表达的内容。"`ElectronicItem` 函数扩展 `Item`" 意味着 "每个 `ElectronicItem`
    都是一个项目。"这就是为什么我们能够从一个 `ElectronicItem` 实例中引用 ID、UUID 和名称。我们已经使用了 `import` 语句将
    UUID 类型引入我们的编译单元的作用域，所以当我们使用 UUID 时，它不应该在编译时产生错误。
- en: 'Now, as we discussed, every class is a subclass of `Any`*.* Hence, we have
    access to all non-private members of `Any`*.* Methods like *`!=` , `==`*, `asInstanceOf`,
    `equals`, `isInstanceOf`*,* `toString`, and `hashCode` are defined in `Any` class.
    These are in the form of:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们讨论的那样，每个类都是 `Any` 的子类。因此，我们可以访问 `Any` 的所有非私有成员。如 *`!=`、`==`、`asInstanceOf`、`equals`、`isInstanceOf`*、`toString`
    和 `hashCode` 等方法都在 `Any` 类中定义。这些是以以下形式存在的：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And yes! You can override these non-final methods, which means you can have
    your own definition of these.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并且是的！你可以覆盖这些非最终方法，这意味着你可以有自己的定义。
- en: AnyVal and AnyRef
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AnyVal 和 AnyRef
- en: 'Both `AnyVal` and `AnyRef` are two subclasses of root class `Any`*.* These
    two represent two families of types in Scala: the first ones are object references,
    the latter are value classes.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyVal` 和 `AnyRef` 都是根类 `Any` 的两个子类。这两个代表了 Scala 中的两种类型家族：前者是对象引用，后者是值类。'
- en: AnyRef
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AnyRef
- en: The `AnyRef` class represents all values that are/can be represented as objects
    in the underlying runtime system. It includes all user-defined classes that explicitly
    do not inherit from `AnyVal`. Some standard reference classes are `String`, `Tuple`,
    `Function`, and `Array`. The Scala compiler either provides syntactic sugar for
    them, or generates special code at the time of compilation for their operations.
    We've already seen a bit of syntactic sugar such as `Tuple2`, which can be represented
    as `(A, B)` where A and B are type parameters. An applied form of this `Tuple2`
    can be (`String` and `Int`). In Scala, we represent this as `Tuple2[String, Int]`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyRef`类代表在底层运行时系统中可以表示为对象的全部值。它包括所有明确不继承自`AnyVal`的用户定义类。一些标准引用类包括`String`、`Tuple`、`Function`和`Array`。Scala编译器要么为它们提供语法糖，要么在编译时生成特殊代码以执行它们的操作。我们已经看到了一些语法糖，例如`Tuple2`，它可以表示为`(A,
    B)`，其中A和B是类型参数。这种`Tuple2`的应用形式可以是(`String`和`Int`)。在Scala中，我们将其表示为`Tuple2[String,
    Int]`。'
- en: AnyVal
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AnyVal
- en: The latter, `AnyVal`, represents values not implemented as objects in the underlying
    runtime system. Scala has some predefined numeric and non-numeric value classes
    as shown in the class hierarchy.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 后者，`AnyVal`，代表在底层运行时系统中未实现为对象的值。Scala有一些预定义的数值和非数值值类，如类层次结构所示。
- en: 'It''s possible to define user-defined value types as well, with some conditions
    applied. Remember I asked you to take a closer look at the source of the `Int.scala`
    file? You may have noticed that there are no `val`  or `var` declarations in the
    class `Int` that extends `AnyVal`*.* This is one of the constraints of defining
    a subtype of `AnyVal`*.* One of the reasons you might consider defining an `AnyVal`
    type is to avoid object instantiation at runtime. Some of the constraints are:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义用户自定义的值类型，但需要满足一些条件。记得我让你仔细查看`Int.scala`文件源码吗？你可能已经注意到，在扩展`AnyVal`*.*的`Int`类中没有`val`或`var`声明。这是定义`AnyVal`*.*子类型的一个约束。你可能考虑定义`AnyVal`类型的原因之一是避免在运行时进行对象实例化。一些约束包括：
- en: 'It must have a single `val` parameter that is the underlying representation.
    It means that if you declare `class Num(val underlying: Int) extends AnyVal`***,***
    then the compile time representation of it will be of type `Num`, but at runtime
    it''ll be converted to `Int`, and methods defined within will be used as statics.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '它必须有一个单一的`val`参数作为底层表示。这意味着如果你声明`class Num(val underlying: Int) extends AnyVal`***，***那么它的编译时表示将是`Num`类型，但在运行时它将被转换为`Int`，并且定义在其中的方法将被用作静态方法。'
- en: It must define only `def`, no `val`, `var`, nested classes, traits, or objects.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须只定义`def`，不能有`val`、`var`、嵌套类、特质或对象。
- en: It can only extend *universal traits, traits* that extend only the super type
    *Any.*
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能扩展通用特质，即只扩展超类型*Any*的特质。
- en: It can't be used for pattern-matching, or type tests.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能用于模式匹配或类型测试。
- en: Scala's implementation of `AnyVal` includes nine implementations. Out of them,
    `Byte`, `Short`, `Int`, `Long`, `Char`, `Float`, and `Double` are numeric value
    types, while Boolean and Unit are non-numeric types.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的`AnyVal`实现包括九种实现。其中，`Byte`、`Short`、`Int`、`Long`、`Char`、`Float`和`Double`是数值值类型，而`Boolean`和`Unit`是非数值类型。
- en: Unit
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unit
- en: 'Scala''s `Unit` is a subtype of `AnyVal`, and the implementation contains the
    equals method, which returns a true value if the passed argument is also a `Unit` which
    means a value `()`, that is, just a pair of parentheses otherwise false. Other
    methods are `hashCode` and `toString`, which return an implementation-specific
    hash code and `()` respectively, because Unit has only one value: `()`, which
    is equivalent to Java''s `void` type.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的`Unit`是`AnyVal`的子类型，其实现包含一个`equals`方法，如果传入的参数也是一个`Unit`（即一个值`()`），则返回true值，否则返回false。其他方法包括`hashCode`和`toString`，分别返回实现特定的哈希码和`()`，因为`Unit`只有一个值：`()`，这与Java的`void`类型等价。
- en: Boolean
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boolean
- en: A Boolean represents two values: `true` and `false`. As expected, it implements
    Boolean arithmetic methods such as *and*, *or*, *strict and*, *strict or*, *equality*,
    *inequality*, and negation in the form of `&&`, `||`, `&`, `|`, `==`, `!=`, and
    `unary_`! respectively. Boolean also implements `equals`, `hashCode`, and `toString`
    from the class `Any`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值代表两个值：`true`和`false`。正如预期的那样，它实现了布尔算术方法，如`and`、`or`、`strict and`、`strict
    or`、`equality`、`inequality`和`negation`，分别以`&&`、`||`、`&`、`|`、`==`、`!=`和`unary_`!的形式。布尔值还实现了来自`Any`类的`equals`、`hashCode`和`toString`方法。
- en: The equals method checks for argument evaluation and returns its result, while `hashCode`
    returns a fixed implementation-specific hash code based on value `true` or `false`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 等于方法检查参数评估并返回其结果，而`hashCode`方法则返回基于值`true`或`false`的固定实现特定哈希码。
- en: Null and Nothing
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Null和Nothing
- en: 'Null and Nothing are called **Bottom types** in Scala. Why do we need these
    Bottom types? Take a look at the code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，Null和Nothing被称为**底类型**。为什么我们需要这些底类型呢？看看以下代码片段：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method `checkIf10AndReturn20` expects a returned value of `Int` type, but
    what's happening here is different. If the passed argument value is not 10, we
    are throwing an exception, yet still the compiler is OK with our code. How can
    this be possible?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`checkIf10AndReturn20`期望返回`Int`类型的值，但这里发生的情况不同。如果传递的参数值不是10，我们会抛出异常，然而编译器对我们的代码仍然满意。这是怎么可能的？
- en: 'This is because of Type Inference. It always looks for common types in both
    branches of an `if` statement, so if in the other branch, the type extends everything,
    then the inferred type will automatically be the first one. In Scala, `Nothing`
    is a subtype of everything, hence the inferred type automatically becomes of type
    `Int`. Let''s visualize this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为类型推断。它总是在`if`语句的两个分支中寻找公共类型，所以如果在另一个分支中，类型扩展了一切，那么推断的类型将自动是第一个。在Scala中，`Nothing`是所有类型的子类型，因此推断的类型自动变为`Int`类型。让我们可视化这个：
- en: '![](img/00012.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: Visualizing Types Inferred
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化推断的类型
- en: With this, it's important to understand that Type Inference plays an important
    role in Scala's ecosystem.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，了解类型推断在Scala生态系统中的重要作用是很重要的。
- en: Type inference
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'We can call type inference a built-in Scala feature that permits us to omit
    type information while writing code. This means we don''t have to specify the
    type while declaring any variables; Scala compiler can do it for us:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将类型推断称为Scala的一个内置功能，允许我们在编写代码时省略类型信息。这意味着我们不需要在声明任何变量时指定类型；Scala编译器会为我们完成：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We did not specify our `val`, to be of `String` type, but seeing the value
    of `Invisible`, Scala compiler was able to infer its type. Also with some constraints,
    we can also omit the method''s return types:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有指定`val`的类型为`String`，但看到`Invisible`的值后，Scala编译器能够推断其类型。此外，在某些约束下，我们还可以省略方法的返回类型：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here we did not give the return type, as Scala compiler was able to infer its
    type. But for recursive methods, this doesn''t work. The famous factorial method
    expects you to specify the return type if implementation is recursive:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们没有指定返回类型，因为Scala编译器能够推断其类型。但对于递归方法，这不起作用。著名的阶乘方法期望你在实现递归时指定返回类型：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Scala uses a constraints-driven algorithm to implement type inference. It means
    that Scala compiler tries to infer constraints, and then attempts to unify the
    type. We''re talking about *constraints*, but what are they? A constraint is a
    statement about the types of expression. And even if it''s not an expression,
    for example, when we bind a value to a variable, we must deduce their type too.
    But first think about what we can deduce from the type of an expression:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Scala使用基于约束的算法来实现类型推断。这意味着Scala编译器试图推断约束，然后尝试统一类型。我们正在谈论**约束**，那么它们是什么呢？约束是关于表达式类型的陈述。即使它不是一个表达式，例如，当我们将值绑定到变量时，我们也必须推断它们的类型。但首先考虑一下我们能从表达式类型中推断出什么：
- en: If it is related to the type of some identifier
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它与某些标识符的类型相关
- en: If it is related to the type of some other expression
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它与某些其他表达式的类型相关
- en: If it is a base type, such as numbers and Booleans
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个基本类型，例如数字和布尔值
- en: If it is a constructed type such as a function, whose domain and range types
    are further constrained
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个构造类型，例如一个函数，其域和范围类型进一步受到约束
- en: 'Scala compiler uses this approach to deduce constraints and then apply unification
    (explanation is beyond the scope of this book) to infer the type. In instances
    where we can''t take out any statements about an expression, inferring type is
    impossible:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编译器使用这种方法来推断约束，然后应用统一（解释超出了本书的范围）来推断类型。在无法从表达式提取任何语句的情况下，推断类型是不可能的：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because of type inference only, we''re able to use *syntactic sugar* for cases
    where we''re not expected to specify types:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仅类型推断，我们能够使用*语法糖*来处理不需要指定类型的情况：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Exciting, isn't it? This way, we've performed our logic simply with less information
    about types. The underscore (`_`) used is syntactic sugar, and it's possible to
    use here because of type inference.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 激动人心的，不是吗？这种方式，我们用更少的类型信息简单地执行了逻辑。这里使用的下划线（`_`）是语法糖，并且由于类型推断，这里可以使用。
- en: We'll continue our good work and learn about implementing this, perform operations
    using all these types, and strengthen our basics.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续我们的良好工作，学习如何实现这一点，使用所有这些类型执行操作，并加强我们的基础知识。
- en: Operators in Scala
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的运算符
- en: 'Based on the way we use them, the Scala operators can be classified into three
    types:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们使用它们的方式，Scala运算符可以分为三种类型：
- en: Infix operators
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中缀运算符
- en: Prefix operators
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀运算符
- en: Postfix operators
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀运算符
- en: 'We use operators to perform some operation on operands, which is obvious, and
    the way we implement makes them infix, prefix, or postfix. A basic example of
    an infix operator is addition `+`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用运算符在操作数上执行某些操作，这是显而易见的，而我们实现的方式使它们成为中缀、前缀或后缀。一个基本的中缀运算符示例是加法`+`：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We have two operands (1 and 10) on which this addition operation is being performed.
    We''ve already discussed that *operators are methods.* It means that somehow the
    operation is being performed as `1.+(10)`, and `1 + 10` is just syntactic sugar
    of how we can write this. This is possible because the method + is defined for
    the given types. Here, in our case, the addition (+) method is defined for `Int`*.* Along
    with this, there are several versions of overloaded methods that support other
    numeric value types as well. It means that we can pass in any other type and it''ll
    be a normal addition operation performed, given that the overloaded version of
    that method is present:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个操作数（1和10）在这个加法运算上执行。我们已经讨论过，*运算符是方法*。这意味着某种方式，操作是以`1.+(10)`的形式执行的，而`1 +
    10`只是我们如何书写它的语法糖。这是因为加法方法为给定的类型定义了。在这里，在我们的例子中，加法（+）方法为`Int`*.* 除此之外，还有几个重载方法的版本，支持其他数值类型。这意味着我们可以传递任何其他类型，只要该方法的重载版本存在，它就会执行正常的加法运算：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, the method `def+(arg: Char): Int` is invoked and has given an `Int` as
    a result. Think about it, if these methods are not native Scala operators and
    are methods, then we can also create methods like these that work as operators.
    This makes you feel powerful. Let''s try this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，调用了方法`def+(arg: Char): Int`并返回了一个`Int`。想想看，如果这些方法不是原生的Scala运算符而是方法，那么我们也可以创建类似这些作为运算符工作的方法。这让你感觉很有力量。让我们试试这个：'
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is the result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Great! `taxApplied` is the first operator that we defined, it is defined for
    the type `Amount`*.* Our program has a class `Amount` that is just a `Double`
    value, and defines a method `taxApplied`*.* This method expects a double value
    for `tax` to be applied on `this` which is going to be the current value for the
    amount. Operators are a way we can use methods, which is why we have this operator.
    We've used it in object, `Order` while defining a function, `amountAfterTax`*:*
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`taxApplied`是我们定义的第一个运算符，它针对的类型是`Amount`*.* 我们程序中有一个名为`Amount`的类，它只是一个`Double`值，并定义了一个名为`taxApplied`*.*
    这个方法期望一个用于应用在`this`上的`tax`双精度值，`this`将是金额的当前值。运算符是我们使用方法的一种方式，这就是为什么我们有这个运算符。我们在`Order`对象中定义函数`amountAfterTax`*:*
    时使用了它：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It can also be written as `amount.taxApplied(tax)`*.* There are also a few examples
    in Scala; for example, the `indexOf` operator that works on `String`*:*
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '它也可以写成`amount.taxApplied(tax)`*.* 在Scala中也有一些例子；例如，在`String`上工作的`indexOf`运算符*:* '
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ve talked about *infix* operators, where the operator sits between two
    operands. Now let''s take a look at another way of using operators, that is, *prefix*
    and *postfix.* The first one, *prefix* operators, sits before an operand. Examples
    of these are `-`, `!`, and so on:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了*中缀*运算符，其中运算符位于两个操作数之间。现在让我们看看另一种使用运算符的方式，那就是*前缀*和*后缀*。第一个，*前缀*运算符位于操作数之前。这些运算符的例子有`-`、`!`等等：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, `!lie`*,* uses the *prefix* operator `!`, and this is the way we put
    an operand to the right of our operator. But this is getting invoked as a method.
    What happens in the background is that Scala uses `unary_` to call these operators,
    and that''s obvious because these operators use only one operand. So our implementation
    looks something like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`!lie`*:* 使用了前缀运算符`!`，这是我们放置操作数在运算符右侧的方式。但这是作为一个方法调用的。在后台发生的事情是Scala使用`unary_`来调用这些运算符，这是显而易见的，因为这些运算符只使用一个操作数。所以我们的实现看起来像以下这样：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The operator `!` is defined for Boolean types, hence we were allowed to make
    calls on Boolean. The other way is where the operand sits on the left side, called
    *postfix* operators. Examples of these operators are convertors such as `toLowerCase`,
    `toInt`, `toString`, and so on:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `!` 是为布尔类型定义的，因此我们可以在布尔类型上调用。另一种方式是操作数位于左侧，称为 *后缀* 运算符。这些运算符的例子包括转换器，如 `toLowerCase`，`toInt`，`toString`
    等：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It means that these operators are defined as methods in the corresponding types.
    This is one way to classify operators in Scala. Now we''ll go and have a quick
    look at types of operators based on the context they are used in programming languages.
    These are basically classified as:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这些运算符是在相应的类型中定义为方法的。这是在 Scala 中对运算符进行分类的一种方式。现在我们将快速查看根据它们在编程语言中使用时的上下文对运算符类型进行分类。这些基本上被分类为：
- en: Arithmetic operators
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Relational operators
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Logical operators
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Bitwise operators
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符
- en: Arithmetic operators
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算符
- en: We can perform arithmetic operations using the arithmetic operators. Arithmetic
    operators contain operators for addition (+), subtraction (-), multiplication
    (*), division (/), and remainder (%). We've already seen many examples for addition,
    not mentioning that these operators are methods!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用算术运算符进行算术运算。算术运算符包括加法 (+)，减法 (-)，乘法 (*)，除法 (/)，和取余 (%)。我们已经看到了很多加法的例子，不提这些运算符也是方法！
- en: 'Let''s take examples of others:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他例子：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'These operators have their overloaded versions also defined, to see that we
    may try with different types as operands. Let''s take an `Int` and `Double`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符也有它们重载的版本定义，为了看到我们可以用不同的类型作为操作数。让我们拿一个 `Int` 和一个 `Double`：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, the first operand is an `Int`, and the second one is a `Double`, and since
    `Int` is view-bounded to `Double`, the result is converted to `Double`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个操作数是 `Int` 类型，第二个操作数是 `Double` 类型，由于 `Int` 类型可以看作是 `Double` 类型的子集，所以结果会被转换为
    `Double` 类型。
- en: Relational operators
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系运算符
- en: 'Relational operators are used to compare two operands. We have quite enough
    of these, ==, !=, >, <, >= and <=. Let''s try them:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符用于比较两个操作数。我们有相当多的这些，==，!=，>，<，>= 和 <=。让我们试试：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With these operators, we compare two operands for their values, and these operations
    yield a Boolean result.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些运算符，我们比较两个操作数的值，这些操作会得到一个布尔结果。
- en: Logical operators
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators include `!` (NOT), `&&` (AND), and `||` (OR), and obviously
    we use these to perform logical operations on operands. These methods are written
    for Boolean, so they expect Boolean operands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符包括 `!`（非），`&&`（与），和 `||`（或），显然我们使用这些来对操作数执行逻辑运算。这些方法是为布尔类型编写的，因此它们期望布尔类型的操作数：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Logical AND and OR are short-circuiting operators. It means that these are only
    evaluated till the result is undetermined. This is achievable in Scala even though
    operators are methods, because of a feature of function calls named *by-name parameters.*
    It allows us to pass parameters by name that get evaluated later on when required
    at the time of method call.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与和或都是短路运算符。这意味着这些运算符只会在结果未确定时进行评估。在 Scala 中，即使运算符是方法，也可以实现这一点，因为函数调用有一个名为
    *按名参数* 的特性。它允许我们通过名称传递参数，这些参数在方法调用时需要时才会进行评估。
- en: Bitwise operators
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'We can perform operations on individual bits of Integer types using Bitwise
    operators. These includes Bitwise AND (&), OR (|), and XOR (^):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用位运算符对整型类型的单个位进行操作。这些包括位与 (&)，位或 (|)，和位异或 (^)：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'These operators can be performed only on `Int`. If you try this on `Double`,
    it''ll throw an error: *value & is not a member of Double.* These operators perform
    operations on individual bits; in our case, 1 is converted into bits as 01 and
    2 as 10, and then AND, OR, and XOR operations are performed:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符只能在 `Int` 上执行。如果你在 `Double` 上尝试这样做，将会抛出一个错误：*value & 不是 Double 的成员.* 这些运算符对单个位执行操作；在我们的例子中，1
    被转换为位 01，2 被转换为位 10，然后执行 AND，OR 和 XOR 操作：
- en: 0001 AND 0010 resulted into 00 means 0
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0001 AND 0010 结果为 00 表示 0
- en: 0001 OR 0010 resulted into 11 means 3
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0001 OR 0010 结果为 11 表示 3
- en: 0001 XOR 0010 resulted into 11 means 3
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0001 XOR 0010 结果为 11 表示 3
- en: 'We can perform a logical not-operating using `~` operator:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `~` 运算符执行逻辑非操作：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There are also *three shift methods* for `Int` types named *shift right (>>),
    shift left (<<) and unsigned-shift right (>>>).* These are binary operators working
    on two operands. Bits of operand on the left are shifted by value to the right.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Int`类型，还有三种名为*右移(>>), 左移(<<)和无符号右移(>>>)*的位移方法。这些是作用于两个操作数的二进制运算符。操作数左侧的位根据值向右移动。
- en: Operator precedence
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: 'Operations such as *2 + 3 * 4 / 2 - 1* can give different results if there''s
    no rule for evaluation of these. Hence we have some precedence-based rules for
    these. We''re going to talk about it in this part:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有评估这些运算符的规则，像*2 + 3 * 4 / 2 - 1*这样的运算可能会得到不同的结果。因此，我们有一些基于优先级的规则。我们将在本部分讨论它：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For reference purposes, we have the preceding expression. The evaluation gives
    back the result *`7`.* How?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考目的，我们有了前面的表达式。评估返回结果*`7`。它是如何做到的？
- en: 'The expression *(2 + ((3 * 4) / 2))) - 1* is evaluated in the following steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式*(2 + ((3 * 4) / 2))) - 1*将被按以下步骤评估：
- en: '*(2 + (12 / 2)) - 1*'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(2 + (12 / 2)) - 1*'
- en: '*(2 + 6) - 1*'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(2 + 6) - 1*'
- en: '*8 - 1*'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*8 - 1*'
- en: '*7*'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*7*'
- en: 'It''s based on operator precedence. That''s in the following order:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于运算符优先级。顺序如下：
- en: '![](img/00013.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: Operator precedence
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: As shown in the preceding figure, Scala operator expressions are evaluated based
    on the precedence shown. As per the figure, *****, **/**, and **%** are of top
    priority, then comes **+** and **-**.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Scala运算符表达式是根据显示的优先级评估的。根据图示，*****, **/**, 和 **%** 具有最高优先级，然后是 **+** 和
    **-**。
- en: 'Other operators also follow the same precedence as shown. If operators of the
    same precedence level appear together, the operands are evaluated from left to
    right. It means that the expression `1 + 2 + 3 * 3 * 4 - 1` will result in `38`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 其他运算符也遵循相同的优先级。如果相同优先级级别的运算符一起出现，则从左到右评估操作数。这意味着表达式`1 + 2 + 3 * 3 * 4 - 1`的结果将是`38`：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The expression *(1 + 2) + ((3 * 3) * 4) - 1* will be evaluated in the following
    steps:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式*(1 + 2) + ((3 * 3) * 4) - 1*将被按以下步骤评估：
- en: '*1 + 2 + 9 * 4 - 1*'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*1 + 2 + 9 * 4 - 1*'
- en: '*1 + 2 + 36 - 1*'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*1 + 2 + 36 - 1*'
- en: '*3 + 36 - 1*'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*3 + 36 - 1*'
- en: '*39 - 1*'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*39 - 1*'
- en: '*38*'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*38*'
- en: This gives clarity of evaluation of expressions in Scala.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这为Scala中表达式的评估提供了清晰性。
- en: Wrapper classes
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装类
- en: 'In Scala, we can create our own universe, apart from the native methods provided,
    we can add our own implementations, which we call *Rich Wrapper* classes. This
    is possible because of *Implicit Conversions.* First, we''ll list out some *Wrappers*
    available already:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，我们可以创建自己的宇宙，除了提供的原生方法外，我们还可以添加自己的实现，这些我们称之为*富包装*类。这是由于*隐式转换*的可能。首先，我们将列出一些已经可用的*包装*类：
- en: '![](img/00014.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: Rich wrappers
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 富包装
- en: 'To see how it happens, let''s see an example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它是如何发生的，让我们看一个例子：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding expression tries to check if the value of `x` can be converted
    into a `Byte`, and suffices range of a `Byte`, and finds it to be `true`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式试图检查`x`的值是否可以转换为`Byte`，并检查其是否在`Byte`的范围内，并发现它是`true`：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you know, range for a `Byte` is -128 to 127\. If you try to assign it to
    a value that's out of range of a `Byte` and expect it to behave like a `Byte`*,* it
    won't work. Thus, the result for the preceding expression is `false`*.*
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`Byte`的范围是-128到127。如果你尝试将其分配给超出`Byte`范围的值，并期望它像`Byte`一样行为，它将不起作用。因此，前面表达式的结果是`false`。
- en: Apart from this `isValidByte`, there are a number of utility methods present
    in the class `RichByte` wrapper class*.*
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个`isValidByte`之外，类`RichByte`包装类中还有许多实用方法。
- en: 'These wrappers methods look like they''re natively defined for the types existing.
    One of the examples is a wrapper around a `String` that is `StringOps`. A String
    in Scala is nothing more than an instance of `java.lang.String`*,* so it''s clear
    that all methods implemented for `java.lang.String` are applicable here as well.
    For example, the `charAt` method does pretty good here:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包装方法看起来像是为现有类型原生定义的。其中一个例子是围绕`String`的包装，即`StringOps`。在Scala中，`String`不过是一个`java.lang.String`的实例，所以很明显，为`java.lang.String`实现的所有方法在这里也同样适用。例如，`charAt`方法在这里表现得相当不错：
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now let's try some methods from `StringOps`*:*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些`StringOps`的方法：
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The three methods `capitalize`*,* `toUpperCase`*,* and `toLowerCase` are defined
    in the `StringOps` class and not in `String` classes, but still it works the same
    way as calling a native method for a `String` type. There are more of these methods
    that work as a utility method for `Strings`. This is because of the power of *Implicit
    Conversions.* We'll learn how *Implicits* work in Scala in later chapters.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize`*、`toUpperCase`* 和 `toLowerCase` 这三个方法定义在 `StringOps` 类中，而不是 `String`
    类中，但它们仍然以相同的方式工作，就像调用 `String` 类型的本地方法一样。还有更多这样的方法，它们作为 `String` 的实用方法工作。这是因为
    *隐式转换* 的力量。我们将在后面的章节中学习 Scala 中的 *隐式* 如何工作。'
- en: 'One of the ways to create a `Range` class out of `Int` types can be achieved
    using a method *to.* We call these **rich methods**. It''s really simple to use
    them, and based on the purpose they solve, we can also name them:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Int` 类型创建 `Range` 类的一种方法可以通过使用一个 *方法* 实现。我们称这些为 **丰富的方法**。使用它们非常简单，根据它们解决的问题，我们也可以给它们命名：
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding are few examples of methods from the `Range` class, which provide
    rich methods for `Int` to create a `Range` with. The `Range` can contain values
    inclusive of those. It''s built with, and can also exclude, those values. Methods
    for building these are `to` and `until`*.* The first includes both values we use
    to build a `Range`; the latter includes only the beginning value. We''ve tried
    all these. As you can see, `rangeOfNumbersUntil` does not contain `199`. We can
    also create a `Range` with some `step` difference:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些来自 `Range` 类的方法的例子，它们为 `Int` 提供了创建 `Range` 的丰富方法。`Range` 可以包含这些值，也可以构建时包含或排除这些值。构建这些值的函数是
    `to` 和 `until`*.* 第一个包含我们用于构建 `Range` 的两个值；后者只包含起始值。我们已经尝试了所有这些。如您所见，`rangeOfNumbersUntil`
    不包含 `199`。我们也可以创建具有某些 `step` 差别的 `Range`：
- en: '[PRE70]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following is the result:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is pretty simple; pretty and simple. Especially with the syntax, we are
    able to write concisely because of *Implicit Conversions* and *Type Inference*
    happening at the backend. Scala Compiler is taking care of all those parts, leaving
    us with the simple job of writing code in a beautiful way. Another way of utilizing
    conciseness while writing a String is by using String Interpolators.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；既简单又漂亮。特别是由于后端发生的 *隐式转换* 和 *类型推断*，我们能够以简洁的语法编写。Scala 编译器正在处理所有这些部分，让我们只需以美观的方式编写代码。在编写字符串时利用简洁性的另一种方法是使用字符串插值器。
- en: String Interpolators
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串插值器
- en: 'We''ve already used String Interpolators, it''s hard to avoid using them when
    they are available to you. Remember when we used them? Yes! When we were learning
    to create operators on our own:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了字符串插值器，当它们可用时很难避免使用它们。记得我们什么时候使用过它们吗？是的！当我们学习自己创建运算符时：
- en: '[PRE72]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This little `s` here is a String interpolator. While using these, we precede
    our `String` with a character named `s`, and inside double quotes of the String,
    we can use any variable with a `$` and it''ll be replaced by its value:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `s` 是一个字符串插值器。在使用这些插值器时，我们在 `String` 前面加上一个名为 `s` 的字符，并在字符串的双引号内可以使用任何带有
    `$` 的变量，它将被其值替换：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is an example of how we can use interpolators. The `s` is not the only
    interpolator existing in Scala. We have a couple more interpolators. We'll go
    through them one by one.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用插值器的例子。`s` 并不是 Scala 中唯一的插值器。我们还有一些其他的插值器。我们将逐一介绍它们。
- en: The `s` interpolator
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 插值器'
- en: The `f` interpolator
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f` 插值器'
- en: The `raw` interpolator
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raw` 插值器'
- en: The s interpolator
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`s` 插值器'
- en: 'First, we''ll look at the `s` interpolator. We''ve already seen how we can
    create a processed String with variables. Now, let''s take an example that takes
    on expressions:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看 `s` 插值器。我们已经看到了如何使用变量创建处理过的字符串。现在，让我们举一个使用表达式的例子：
- en: '[PRE74]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here, we used `${...}` where a `$` sign is followed by a pair of braces {<expression>},
    consisting of the expression to be evaluated. It can be any expression. An arithmetic
    operation like we just did, or a method call:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `${...}`，其中 `$` 符号后面跟着一对花括号 {<expression>}，包含要评估的表达式。它可以是一个任何表达式。就像我们刚才做的算术运算，或者方法调用：
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we defined a method named `incrementBy1` that increments any Int passed
    by 1 and gives back the result. We've called that method from our interpolator.
    By the way, it's good to know that our interpolator `s` is a method just like
    any other operator in Scala. We're allowed to create our own interpolators in
    Scala.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `incrementBy1` 的方法，该方法将任何传入的 `Int` 增加 1 并返回结果。我们已经从我们的插值器中调用了该方法。顺便说一下，了解我们的插值器
    `s` 就像 Scala 中的任何其他运算符一样是一个方法。我们在 Scala 中可以创建自己的插值器。
- en: f Interpolator
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: f 插值器
- en: 'To have something like `printf` styled formatting in Scala, we can use the
    `f` interpolator. We do this by using a `f` preceding the double quotes of our
    string, and then within the String we can use one of the format specifiers:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Scala中实现类似于`printf`样式的格式化，我们可以使用`f`插值器。我们这样做是通过在字符串的双引号前使用一个`f`，然后在字符串内部我们可以使用一个格式说明符：
- en: '[PRE76]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: From the preceding example, it's clear that we use *f* as a prefix to our string
    and use `$` followed by the expression that includes our format specifier. This
    works as a formatter for our strings.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，我们使用`f`作为字符串的前缀，并使用`$`后跟包含格式说明符的表达式。这作为我们的字符串格式化器工作。
- en: 'A few format specifiers are listed as following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一些格式说明符如下所示：
- en: '![](img/00015.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00015.jpeg)'
- en: Format Specifiers
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符
- en: The raw interpolator
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始插值器
- en: 'The final one pre-existing interpolator in Scala is the `raw` interpolator.
    This interpolator does not allow you to use any escape sequence characters in
    your string, it means that if you try to give an escape sequence character, it''ll
    be treated as a normal literal and nothing more. The way we write `raw` interpolator
    is almost similar to the other two interpolators. We precede our String with a
    *raw* keyword and it works for us:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中预存的最终插值器之一是`raw`插值器。这个插值器不允许你在字符串中使用任何转义序列字符，这意味着如果你尝试给出一个转义序列字符，它将被视为一个普通字面量，不再有其他作用。我们编写`raw`插值器的方式几乎与其他两个插值器相似。我们在字符串前加上一个`raw`关键字，它就会为我们工作：
- en: '[PRE77]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, in the string escape character, `\n` was treated as a normal literal,
    and in the resulting string it remained the same. In a normal string, `\n` would
    have converted into a *newline* character.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，字符串中的转义字符`\n`被视为一个普通字面量，在生成的字符串中保持不变。在一个普通字符串中，`\n`会转换成*换行*字符。
- en: '[PRE78]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Using this raw interpolator, we can avoid escape sequences. These constructs
    give us a way to write code more efficiently and concisely.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个原始插值器，我们可以避免转义序列。这些结构为我们提供了一种更高效、更简洁地编写代码的方法。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: So, let's summarize what we have learned in this chapter. We started with the
    most basic `val` and `var` variable constructs. Then, we learned how we can write
    literals, and what data types we have in Scala. We then studied the interesting
    class hierarchy in Scala, in which we talked about unified class hierarchy and
    value and reference type classes. Later, we learned one of the most important
    concepts of Type Inference in Scala. After that, we started with operators, and
    their precedence. We learned how wrapper classes provide all the richness of functionalities
    to us as programmers. Finally, we learned a simple, but useful way of processing
    our String literals using interpolators. Now, it's clear that with some more practice
    of all these constructs that we've learned we'll be ready to go further and learn
    about some logical and looping constructs that shape up our programs.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下在本章中学到的内容。我们从最基本的`val`和`var`变量结构开始。然后，我们学习了如何编写字面量，以及Scala中有哪些数据类型。接着，我们研究了Scala中有趣的类层次结构，其中我们讨论了统一类层次结构和值类型和引用类型类。后来，我们学习了Scala中类型推断最重要的概念之一。之后，我们开始学习运算符及其优先级。我们学习了包装类如何为我们程序员提供所有丰富的功能。最后，我们学习了一种简单但实用的方法，即使用插值器处理我们的字符串字面量。现在，很明显，通过练习我们所学到的所有这些结构，我们将准备好进一步学习一些逻辑和循环结构，这些结构塑造了我们的程序。
- en: In the next chapter, we'll discuss some looping constructs in Scala, logical
    constructs, and an introduction to pattern matching and how we can control our
    program flow using pattern matching and enabling us to strengthen our programs
    on logical ground.*
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Scala中的一些循环结构、逻辑结构，以及模式匹配的介绍和如何使用模式匹配和启用程序流程控制来加强我们的程序在逻辑基础上的能力。
