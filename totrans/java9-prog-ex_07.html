<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Building a Commercial Web Application Using REST</h1>
            

            <article>
                
<p class="calibre2">We were playing around till now, but Java is not a toy. We want to use Java for something real and serious, commercial and professional. In this chapter, we will do that. The example is not something that is only interesting to play with, such as Mastermind in the previous three chapters, but rather a real commercial application. Not a real-life application actually. You should not expect anything like that in a book. It would be too long and not educating enough. However, the application that we will develop in this chapter can be extended and can be used as a core for a real-life application in case you decided to do so.</p>
<p class="calibre2">In the previous chapter, we created servlets. To do so, we used the servlet specification, and we hand-implemented servlets. That is something you will rarely do these days. Instead, we will use a readily available framework, this time, Spring. It is the most widely used framework for Java commercial applications, and I dare say it is the de facto standard. It will do all the tedious work that we had to do (at least to understand and learn how a servlet works) in the previous chapter. We will also use Spring for dependency injection (why use two frameworks when one does it all?), and we will use Tomcat.</p>
<div class="packttip">In the previous chapter, we used Guice as a DI framework and Jetty as a servlet container. They can be a perfectly good choice for some projects. For other projects, other frameworks do better. To have the opportunity to look at different tools in this book, we will use different frameworks even though all the examples could be created by simply using Tomcat and Spring.</div>
<p class="calibre2">The commercial application we will develop will be an ordering system targeting resellers. The interface we will provide to the users will not be a web browser; rather, it will be REST. The users will themselves develop applications that communicate with our system and place orders for different products. The structure of the application we will develop will be microservices architecture, and we will use soapUI to test the application, in addition to the standard Chrome developer tool features.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The MyBusiness web shop</h1>
            

            <article>
                
<p class="calibre2">Imagine that we have a huge trading and logistics company. There are tens of thousands of different products on the shelves; hundreds of lorries come to our warehouse bringing new goods, and hundreds of lorries deliver goods to our customers. To manage the information, we have an inventory system that keeps track of the goods every day, hour, and minute to know what we actually have in the warehouse. We serve our customers without humans managing the warehouse information. Formerly, there were phones, fax machines, and even telex, but today, all we use is the Internet and web services. We do not provide a website for our customers. We have never directly served the end users in our imagined business, but these days, we have a subsidiary that we started off as a separate company to do just that. They have a website, and it is totally independent from us. They are just one of our hundreds of registered partners who each use a web service interface to see the products we have, order products, and track the order status.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Sample business architecture</h1>
            

            <article>
                
<p class="calibre2">Our partners are also large companies with automated administration, with several programs running on several machines. We have no interest in their architecture and the technology they use, but we want to integrate their operations. We want to serve them in a way that doesn't require any human interaction for the administration to order goods on either of our sides. To do so, a web service interface is provided that can be utilized no matter what IT infrastructure they use.</p>
<p class="calibre2">On our side, as we imagine the example, we recently replaced our monolithic application with microservices architecture, and though there are still some SOAP-based solutions in the system, most of the backend modules communicate using HTTPS and REST protocols. Some of the modules still rely on asynchronous file transfers done on a daily basis using FTP started from a UNIX <kbd class="calibre11">cron</kbd> job. The General Ledger system was programmed in COBOL. Fortunately, we do not need to deal with these dinosaurs.</p>
<div class="packttip">All this structure is an imagined setup but a realistic one. I made up and described these parts to give you a picture of how you may see mixed technologies in a large enterprise. What I described here is a very simple setup. There are companies that have more than a thousand software modules in their systems using different technologies and totally different interfaces, all interconnected with each other. This is not because they like the mess, but that is the way it becomes after 30 years of continuous IT development. New technologies come and old technologies fade out. The business changes and you cannot stick to the old technologies if you want to stay competitive. At the same time, you just cannot replace the entire infrastructure instantaneously. The result is that we see in an enterprise fairly old technologies still running and, many times, new technologies. Old technologies get rolled out by time. They do not stay forever, and still, we are surprised sometimes when a dinosaur comes in front of us.</div>
<p class="calibre2">What we have to deal with is the two frontend components that we will develop. These are as follows:</p>
<ul class="calibre14">
<li class="calibre15">Product Information</li>
<li class="calibre15">Order Placement and Tracking</li>
</ul>
<p class="calibre2">In the following image, you can see the architectural UML diagram of the structure that we look at. The parts we will have interaction with are only the frontend components, but it helps understand the working and their role if we have a bigger picture:</p>
<div class="packtfigure"><img class="image-border35" src="../images/00049.gif"/></div>
<p class="calibre2">Product Information delivers information about a single product, but it can also deliver a list of products based on the query criteria. Order Placement and Tracking provides functions to place an order and also lets the client to query the state of past orders.</p>
<p class="calibre2">To provide product information, we need access to the Product Catalog module that holds the actual product details.</p>
<div class="packtinfobox">There can be a lot of other tasks that the Product Catalog does, and that is the reason it is a separate module. It can have, for example, a workflow and approval engine that lets product administrators to enter product data and managers to check and approve the data. Approval is usually a complex process, considering typos and legal questions (we do not want to trade unlicensed drugs, explosives, and so on), and checking the quality and approval state of the source of the goods. Many complex tasks are included that make it a backend module. In large enterprise applications, the frontend systems rarely do anything else other than the very basic functionality of serving the outside parties. But this is good for us; we can focus on the service that we have to deliver. And this is also good for the architecture. It is the same principle as in object-oriented programming: single responsibility.</div>
<p class="calibre2">The Product Information module also has to consult with the Access Control module to see if a certain product can be delivered to the actual customer, and with the inventory to see if there is any product left, so we do not offer a product that is out of stock.</p>
<p class="calibre2">The Order Placement and Tracking also needs access to Product Inventory and Access Control modules to check whether the order can be fulfilled. At the same time, it also needs services from the Pricing module, which can calculate the price for the order, and from the Logistics module, which triggers the collection of goods from the inventory locations and shipment to the customer. Logistics also has a connection to invoicing, which has a connection to the General Ledger, but these are on the picture only to show that the travel of information does not end there. There are many other modules that run the company, all of which are none of our interest at the moment.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Microservices</h1>
            

            <article>
                
<p class="calibre2">The architecture described in the previous chapter is not a clean microservice architecture. You will never meet one in its pure form in any enterprise. It is more like something that we really meet in a real company moving from monolithic to microservices.</p>
<p class="calibre2">We talk about the microservice architecture when the application is developed in the form of many small services that communicate with each other using some simple API, usually over HTTP and REST. The services implement business functionalities and can be deployed independently. Many times, it is desirable that the service deployment is automated.</p>
<p class="calibre2">The individual services can be developed using different programming languages, can use different data storage, and can run on different operating systems; thus, they are highly independent of each other. They can be, and usually are, developed by different teams. The important requirement is that they can cooperate; thus, the API one service implements is usable by the other services that build upon it.</p>
<p class="calibre2">The microservice architecture is not the Holy Grail of all architectures. It gives different answers to some problems from monolithic architectures, and many times, these answers work better using modern tools. The applications still have to be tested and debugged, performance has to be managed, and bugs and issues have to be addressed. The difference is that testing can be separated along different technologies; debugging may need more network-related work. These may be good, bad, or both at the same time. For the developers, however, the advantage is clear. They can work on a smaller unit independently and can see the result of their work faster. When developing a single module of a monolithic application, the result can be seen when the entire application gets deployed. In the case of a large application, that may be rare. A typical deployment cycle in a large corporate developing monolithic is every few months, say 3, but it is not rare to see the release development twice or even once a year. Developing microservices, the new module can be deployed as soon as it is ready and tested.</p>
<p class="calibre2">If you want to read more on microservices, the first and the most authentic source is the article by Martin Fowler (<a href="http://www.martinfowler.com/articles/microservices.html" class="calibre6"><span>http://www.martinfowler.com/articles/microservices.html</span></a>).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Service interface design</h1>
            

            <article>
                
<p class="calibre2">We design the two interfaces that we will implement. When we design interfaces, we focus on the functionality first. Formatting and protocol come later. Interfaces generally should be simple and, at the same time, should accommodate the future change. This is a hard problem because we cannot see the future. Business, logistics, and all other experts may see some part of the future: how the world will change and what it will impose on the operation of the company and, especially, on the interface we provide for our partners.</p>
<p class="calibre2">The stability of an interface is of utmost importance because the partners are outside entities. We cannot refactor the code they use. When we change a Java interface in our code, the compiler will complain at all the code locations where the change should be followed. In case of an interface that is used outside of our realm, this is not the case. Even if it is only a Java interface that we publish as open source on <em class="calibre12">GitHub</em>, we should be prepared that our users will face issues if we change the library in an incompatible way. In that case, their software will not compile and work with our library. In the case of an ordering system, it means that they will not order from us and we will soon be out of business.</p>
<p class="calibre2">This is one of the reasons why interfaces should be simple. Although this is generally true for most of the things in life, it is extremely important for such interfaces. It is tempting to provide convenience features for the partners because they are easy to implement. In the long run, however, these features may become very expensive as they need maintenance, should be kept backward compatible, and, in the long run, may not gain as much as they cost.</p>
<p class="calibre2">To access product information, we need two functions. One of them lists certain products and another returns the details of a specific product. If it were a Java API, it would look as follows:</p>
<pre class="calibre20">
List&lt;ProductId&gt; query(String query); <br class="title-page-name"/>ProductInformation byId(ProductId id);
</pre>
<p class="calibre2">Similarly, order placement may look as shown in the following:</p>
<pre class="calibre20">
OrderId placeOrder(Order order);
</pre>
<p class="calibre2">We provide these functionalities in our application via a web service interface and, more specifically, REST using JSON. We will discuss these technologies in a bit more detailed manner along with the Spring framework and Model View Controller design pattern, but first let's look at the product information controller to get some feeling of how our program will look:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@RestController <br class="title-page-name"/>public class ProductInformationController { <br class="title-page-name"/><br class="title-page-name"/>    @Autowired <br class="title-page-name"/>    ProductLookup lookup; <br class="title-page-name"/><br class="title-page-name"/>    @RequestMapping("/pi/{productId}") <br class="title-page-name"/>    public ProductInformation <br class="title-page-name"/>           getProductInformation(@PathVariable String productId) { <br class="title-page-name"/>        ProductInformation productInformation = <br class="title-page-name"/>                                lookup.byId(productId); <br class="title-page-name"/>        return productInformation; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @RequestMapping("/query/{query}") <br class="title-page-name"/>    public List&lt;String&gt; lookupProductByTitle(@PathVariable String query, HttpServletRequest request) { <br class="title-page-name"/>        //to be developed later <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">If you compare the code of the servlet with the preceding code, you can see that this is much simpler. We do not need to deal with the <kbd class="calibre11">HttpServletRequest</kbd> object, call an API to get a parameter, or create an HTML output and write it to the response. The framework does this. We annotate the <kbd class="calibre11">@RestController</kbd> class, telling Spring that this is a controller that utilizes the <em class="calibre12">REST</em> web services; thus, it will by default create a <strong class="calibre1">JSON</strong> response from the object we return. We do not need to care about the conversion of the object to <em class="calibre12">JSON</em>, although we can if there is really a need. The object will automatically be converted to <em class="calibre12">JSON</em> using the field names used in the class and the field values of the instance we return. If the object contains more complex structures than just plain <kbd class="calibre11">String</kbd>, <kbd class="calibre11">int</kbd>, and <kbd class="calibre11">double</kbd> values, then the converter is prepared for nested structures and the most common data types.</p>
<p class="calibre2">To have different code handling and different URLs on the servlet, all we need to do is to annotate the method with <kbd class="calibre11">@RequestMapping</kbd>, providing the path part of the URL. The <kbd class="calibre11">{productId}</kbd> notation inside the mapping string is readable and easy to maintain. Spring just cuts the value from there and puts it for us in the <kbd class="calibre11">productId</kbd> variable, as requested by the <kbd class="calibre11">@PathVariable</kbd> annotation.</p>
<p class="calibre2">The actual lookup of the product is not implemented in the controller. That is not the function of the controller. The controller only decides what business logic to invoke and what view to use. A part of it is implemented in the framework, and the very small part you can see the preceding code. The business logic is implemented in a service class. An instance of this class is injected to the <kbd class="calibre11">lookup</kbd> field. This is also done by Spring. The actual work we have to do is to invoke the business logic, which this time, since we have only one, is fairly easy.</p>
<p class="calibre2">Most of these things seem magic without some more details about what the framework does for us. Therefore, before going on, we will have a look at the building blocks: JSON, REST, MVC, and a bit of the Spring framework.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">JSON</h1>
            

            <article>
                
<p class="calibre2"><strong class="calibre1">JSON</strong> stands for <strong class="calibre1">JavaScript Object Notation</strong>. It is defined on the site, <a href="http://www.json.org/" class="calibre6"><span>http://www.json.org/</span></a>. This is a textual notation in the same way as the object literals are defined in JavaScript . An object representation starts with the <kbd class="calibre11">{</kbd> character and ends with the <kbd class="calibre11">}</kbd> character. The text in between defines the fields of the objects in the form, <kbd class="calibre11">string : value</kbd>. The string is the name of the field, and since JSON wants to be language agnostic, it allows any characters to be a part of the name of a field, and thus this string (as well as any string in JSON) should start and end with the <kbd class="calibre11">"</kbd> characters.</p>
<div class="packttip">This may seem strange and, many times, when you start working with JSON, it is easy to forget and write <kbd class="calibre22">{ myObject : "has a string" }</kbd> instead of the correct <kbd class="calibre22">{ "myObject" : "has a string" }</kbd> notation.</div>
<p class="calibre2">Commas separate the fields. You can also have arrays in JSON. They start and end with <kbd class="calibre11">[</kbd> and <kbd class="calibre11">]</kbd> characters, respectively, and they contain comma-separated values. The value in an object field or in an array can be a string, a number, an object, an array, or one of the constants, <kbd class="calibre11">true</kbd>, <kbd class="calibre11">false</kbd>, and <kbd class="calibre11">null</kbd>.</p>
<p class="calibre2">Generally speaking, JSON is a very simple notation to describe data that can be stored in an object. It is easy to write using text editors and easy to read, and thus it is easier to debug any communication that uses JSON instead of more complex formats. Ways to convert JSON to a Java object and the other way round, are readily available in libraries that we will use in this chapter. A sample JSON object that describes a product from our sample code is also available in the source code of the program, as follows:</p>
<pre class="calibre20">
{"id":"125","title":"Bar Stool","description":"another furniture","size":[20.0,2.0,18.0],"weight":300.0}
</pre>
<p class="calibre2">Note that the formatting of JSON does not require a new line, but at the same time, this is also possible. Program-generated JSON objects are usually compact and are not formatted. When we edit some object using a text editor, we tend to format the indentation of the fields in the same way as we usually do in Java programming.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">REST</h1>
            

            <article>
                
<p class="calibre2">There is no exact definition of the <strong class="calibre1">REST</strong> protocol. It stands for <strong class="calibre1">Representational state transfer</strong>, which probably does not mean a thing to someone who has never heard of it. When we program the REST API, we use the HTTP(S) protocol. We send simple requests to the server, and we get simple answers that we program. This way, the client of the web server is also a program (by the way, the browser is also a program) that consumes the response from the server. The format of the response, therefore, is not HTML formatted using CSS and enriched by client-side functionalities by JavaScript<strong class="calibre1">,</strong> but rather some data descriptive format such as JSON. REST does not set restrictions on the actual format, but these days, JSON is the most widely used.</p>
<p class="calibre2">The wiki page that describes REST is available at <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" class="calibre6"><span>https://en.wikipedia.org/wiki/Representational_state_transfer</span></a>. REST interfaces are usually made simple. The HTTP requests almost always use the <kbd class="calibre11">GET</kbd> method. It also makes the testing of REST services simple since nothing is easier than issuing a <kbd class="calibre11">GET</kbd> request from a browser. <kbd class="calibre11">POST</kbd> requests are only used when the service performs some transaction or change on the server, and that way, the request is sending data to the server rather than getting some data.</p>
<p class="calibre2">In our application, we will use the <kbd class="calibre11">GET</kbd> method to query a list of products and get information about a product, and we will only use <kbd class="calibre11">POST</kbd> to order products. The application that serves these requests will run in a servlet container. You have learnt how to create a naked servlet without the use of a framework. In this chapter, we will use the Spring framework, which offloads many of the tasks from the developer. There are many program constructs in servlet programming that are just the same most of the time. They are called boilerplate code. The Spring framework utilizes the Model View Controller design pattern to develop web applications; thus, we will look at it in brief, before discussing Spring in general.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Model View Controller</h1>
            

            <article>
                
<p class="calibre2"><strong class="calibre1">Model View Controller</strong> (<strong class="calibre1">MVC</strong>) is a design pattern. Design patterns are programming constructs: simple structures that give some hint on how to solve some specific problems. The term, <strong class="calibre1">design pattern</strong> was coined and formally described in the book, <em class="calibre12">Design Patterns, Elements of Reusable Object-Oriented Software</em>, written by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. The book defines a design pattern as a structure with a <em class="calibre12">name</em>, a <em class="calibre12">problem</em>, and a <em class="calibre12">solution</em>. The <em class="calibre12">name</em> describes the pattern and gives the vocabulary for the developer community to use when talking about these patterns. It is important that different developers use the same language terminology in order to understand each other. The <em class="calibre12">problem</em> describes the situation, that is, the design problem where the pattern can be applied. The <em class="calibre12">solution</em> describes classes and objects and the relations between them, which contribute to a good design.</p>
<p class="calibre2">One of them is MVC, which is suitable for programming web applications but generally for any application that has a user interface. In our case, we do not have a classical user interface because the client is also a program; still, MVC can be and is a good choice to use.</p>
<div class="packtfigure"><img class="image-border36" src="../images/00050.gif"/></div>
<p class="calibre2">The MVC pattern, as the name also indicates, has three parts: a model, a view, and a controller. This separation follows the single responsibility principle, requiring one part for each distinct responsibility. The controller is responsible for handling the inputs of the system, and it decides what model and view to use. It controls the execution but usually does not do any business logic. The model does the business logic and contains the data. View converts the model data to a representation that is consumable by the client.</p>
<p class="calibre2">MVC is a well-known and widely used design pattern, and it is directly supported by Spring in such a way that when you create a web application, you program the controller built into the framework, using annotations; thus, you essentially configure it. You can program the view, but it is more likely that you will use one that is built into the framework. You will want to send data to the client in XML, JSON<strong class="calibre1">,</strong> or HTML. If you are very exotic, you may want to send YAML, but generally, that is it. You do not want to implement a new format that needs to be programmed on the server and, since this is new, also on the client.</p>
<p class="calibre2">We create the model, and this time, we also program it. After all, that is the business logic. Frameworks can do many things for us, mainly the things that are the same for most of the applications but for the business logic. Business logic is the code that distinguishes our code from other programs. That is what we have to program.</p>
<p class="calibre2">On the other hand, that is what we like to do. Focus on the business code and avoid all boilerplate provided by the framework.</p>
<p class="calibre2">Now that we know what JSON, REST, and the general Model View Controller design pattern are, let's look at how these are managed by Spring and how we can put these technologies into action.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Spring framework</h1>
            

            <article>
                
<p class="calibre2">The Spring framework is a huge one with several modules. The first version of the framework was released in 2003, and since then, there have been four major releases delivering new and enhanced features. Currently, Spring is the de facto enterprise framework used, perhaps more widely than the standard <strong class="calibre1">EJB 3.0</strong></p>
<p class="calibre2">Spring supports dependency injection, <strong class="calibre1">Aspect-Oriented Programmin</strong>g (<strong class="calibre1">AOP</strong>), persistence for <strong class="calibre1">SQL</strong> and <strong class="calibre1">NoSQL</strong> databases in a conventional and Object Relational Mapping way, transactional support, messaging, web programming, and many other features. You can configure it using <strong class="calibre1">XML</strong> configuration files, annotations, or Java classes.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Architecture of Spring</h1>
            

            <article>
                
<p class="calibre2">Spring is not monolithic. You can use a part of it, or only some of the features. You can include some of the modules of Spring that you need and leave out others. Some modules depend on some others, but Gradle, Maven, or some other build tool handles that.</p>
<p class="calibre2">The following image shows you the modules of the Spring framework for version 4:</p>
<div class="packtfigure"><img class="image-border37" src="../images/00051.gif"/></div>
<p class="calibre2">Spring is constantly developing since its first release, and it is still considered as a modern framework. The core of the framework is a dependency injection container similar to the one we saw in the previous chapter. As the framework developed, it also supported AOP and many other enterprise functionalities, such as message oriented patterns and web programming with an implementation of Model View Controller, supporting not only servlets but also portlets and WebSockets. Since Spring targets the enterprise application arena, it also supports database handling in many different ways. It supports JDBC using templates, <strong class="calibre1">Object Relational Mapping</strong> (<strong class="calibre1">ORM</strong>), and transaction management.</p>
<p class="calibre2">In the sample program, we use a fairly recent module: Spring boot. This module makes it extremely easy to start writing and running applications, assuming a lot of configurations that are usually the same for many programs. It contains an embedded servlet container that it configures for default settings and configures Spring wherever it is possible, so we can focus on the programming aspect rather than on the Spring configuration.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Spring core</h1>
            

            <article>
                
<p class="calibre2">The central element of the core module is the context. When a Spring application starts, the container needs a context in which the container can create different beans. This is very general and true for any dependency injection container. If we programmatically create two different contexts, they may live independent of each other in the same <strong class="calibre1">JVM</strong>. If there is a bean declared as a singleton so that there should be only one single instance of it, then the container will create a single instance of it for a context when we need one instance. The objects representing the context have a reference to the object that we have already created. If there are multiple contexts, however, they will not know that there is another context in the JVM that already has an instance, and the container will create a new instance of the singleton bean for the other context.</p>
<p class="calibre2">Usually, we do not use more than one context in a program, but there are numerous examples of there being many contexts in a single JVM. When different servlets run in the same servlet container, they run in the same JVM separated by the class loader and they may each use Spring. In this case, the context will belong to the servlet and each will have a new context.</p>
<div class="packtinfobox">In the previous chapter, we used Guice. The Spring context is similar to the Guice injector. In the previous chapter, I was cheating a bit because I was programming Guice to create a new injector for each request. This is far from optimal, and Guice provides an injector implementation that can handle servlet environments. The reason for cheating was that I wanted to focus more on the DI architecture essentials, and I did not want to complicate the code by introducing a complex (well, more complex) implementation of the injector.</div>
<p class="calibre2">In the Spring context behavior, what it does, is defined by the interface <kbd class="calibre11">ApplicationContext</kbd>. There are two extensions of this interface and many implementations. <kbd class="calibre11">ConfigurableApplicationContext</kbd> extends <kbd class="calibre11">ApplicationContext</kbd>, defining setters, and <kbd class="calibre11">ConfigurableWebApplicationContext</kbd> defines methods needed in the web environment. When we program web applications, we usually do not need to interfere directly with the context. The framework configures the servlet container programmatically, and it contains servlets that create the context and invoke our methods. This is all boilerplate code created for us.</p>
<p class="calibre2">The context keeps track of the beans created, but it does not create them. To create beans, we need bean factories (at least one). The topmost interface of bean factories in Spring is <kbd class="calibre11">BeanFactory</kbd>. The difference between an object and a bean is that a bean factory creates the bean, it is registered in the context, and it has a <kbd class="calibre11">String</kbd> name. This way, the program can refer to the bean by the name.</p>
<p class="calibre2">Different beans can be configured in several different ways in Spring. The oldest approach is to create an XML file that describes the different beans, specifying the names, the class that has to be instantiated to create the bean, and fields in case the bean needs other beans to be injected for its creation.</p>
<p class="calibre2">The motivation behind this approach is that this way, the bean wiring and configuration can be totally independent of the application code. It becomes a configuration file that can be maintained separately. If we have a large application that may work in several different environments, the access to inventory data may be available in multitude ways. In one environment, the inventory is available by calling SOAP services. In another environment, the data is accessible in an SQL database. In the third environment, it can be available in some NoSQL store. Each of these accesses is implemented as a separate class, implementing a common inventory access interface. The application code depends only on the interface, and it is the container that has to provide one or the other implementation.</p>
<p class="calibre2">When the configuration of the bean wiring is in XML, then only this XML file is to be edited, and the code can be started with the implementation of the interface that is suitable for that environment.</p>
<p class="calibre2">The next possibility is to configure the beans using annotations. Many times, we use beans and Spring not because there are many implementations for a bean functionality, but because we want to separate the creation of the object instance from the functionality. This is a good style: separation of the concerns even if the implementation is single without alternatives. However, in this case, creating the XML configuration is redundant. If there is an interface and a single implementation of it in our code, then why should I specify in an XML that by creating an object with a class that implements that interface, I should use the class that implements that interface? Quite obvious, isn't it? We do not like programming things that can be automated.</p>
<p class="calibre2">To signal that a class can be used as a bean, and to possibly provide a name, we can use the <kbd class="calibre11">@Component</kbd> annotation. We do not need to provide a name as an argument. In that case, the name will be an empty string, but why have a name if we do not refer to it? Spring scans all the classes that are on the classpath and recognizes the classes annotated, and it knows that they are the candidates to be used for bean creation. When a component needs another bean to be injected, the field can be annotated with <kbd class="calibre11">@Autowired</kbd> or <kbd class="calibre11">@Inject</kbd>. The <kbd class="calibre11">@Autowired</kbd> annotation is a Spring annotation and existed before the <kbd class="calibre11">@Inject</kbd> annotation was standardized. If you intend to use your code outside of the Spring container, it is recommended to use standard annotations. Functionally, they are equivalent.</p>
<p class="calibre2">In our code, when Spring creates an instance of the <kbd class="calibre11">ProductInformationController</kbd> component, it sees that it needs an instance of <kbd class="calibre11">ProductLookup</kbd>. This is an interface, and thus, Spring starts to look for some class that implements this interface, creates an instance of it, possibly first creating other beans, and then injects it, setting the field. You can decide to annotate the setter of the field instead of the field itself. In such a case, Spring will invoke the setter even if the setter is private. You can inject dependencies through constructor arguments. The major difference between the setter, field injection, and constructor injection is that you cannot create a bean without dependency in case you use constructor injection. When the bean is instantiated, it should and will have all other beans injected so that it depends on using the constructor injection. At the same time, the dependencies that need to be injected through the setter injection, or directly into a field, could be instantiated later by the container sometime between instantiating the class and readying the bean.</p>
<p class="calibre2">This slight difference may not seem interesting or important until your constructor code may become more complex than the simple dependency settings or until the dependencies become complex. In the case of a complex constructor, the code should pay attention to the fact that the object is not fully created. This is generally true for any constructor code, but in the case of beans created by a dependency injection container, it is even more important. Thus, it may be advisable to use constructor injection. In that case, the dependencies are there; if a programmer makes a mistake, forgetting that the object is not fully initialized, and uses it in the constructor or a method that is called from a constructor, the dependency is there. Also, it is clean and well-structured to use the constructor to initialize the dependencies and have those fields declared <kbd class="calibre11">final</kbd>.</p>
<p class="calibre2">On the other hand, constructor injection has its downsides.</p>
<p class="calibre2">If different objects depend on each other and there is a ring in the dependency graph, then Spring will face a hard time if you use constructor dependencies. When class <em class="calibre12">A</em> needs class <em class="calibre12">B</em> and the other way round, as the simplest circle, then neither <em class="calibre12">A</em> nor <em class="calibre12">B</em> can be created without the other if the dependency injection is constructor dependency. In situations like this, the constructor injection cannot be used, and the circle should be broken at least as a single dependency. In situations like this, setter injection is inevitable.</p>
<p class="calibre2">Setter injection may also be better when there are optional dependencies. Many times, some class may not need all its dependencies at the same time. Some class may use a database connection or a NoSQL database handle but not both at the same time. Although it may also be a code smell and probably a sign of poor OO design, it may happen. It may be a deliberate decision to do that because the pure OO design would result in too deep object hierarchies and too many classes, beyond the maintainable limit. If such is the situation, the optional dependencies may be better handled using setter injection. Some are configured and set; some are left with default values, usually <kbd class="calibre11">null</kbd>.</p>
<p class="calibre2">Last but not least, we can configure the container using Java classes in case the annotations are not enough. For example, there are multiple implementations of the <kbd class="calibre11">ProductLookup</kbd> interface, as it is, in our code base. (Don't worry if you did not recognize that; I have not told you about that yet.) There is a <kbd class="calibre11">ResourceBasedProductLookup</kbd> class that reads properties files from the package and is mainly to test the application, and there is <kbd class="calibre11">RestClientProductLookup</kbd>, which is a production-like implementation of the interface. If I have no other configuration than annotating the <kbd class="calibre11">lookup</kbd> field with <kbd class="calibre11">@Autowired</kbd>, Spring will not know which implementation to use and will reward the use during startup with the following error message:</p>
<pre class="calibre20">
Error starting ApplicationContext. To display the auto-configuration report re-run your application with 'debug' enabled. <br class="title-page-name"/>2016-11-03 07:25:01.217 ERROR 51907 --- [  restartedMain] o.s.b.d.LoggingFailureAnalysisReporter   :  <br class="title-page-name"/><br class="title-page-name"/>*************************** <br class="title-page-name"/>APPLICATION FAILED TO START <br class="title-page-name"/>*************************** <br class="title-page-name"/><br class="title-page-name"/>Description: <br class="title-page-name"/><br class="title-page-name"/>Parameter 0 of constructor in packt.java9.by.example.mybusiness.productinformation.ProductInformationController required a single bean, but 2 were found: <br class="title-page-name"/>        - resourceBasedProductLookup: defined in file [/.../sources/ch07/productinformation/build/classes/main/packt/java9/by/example/mybusiness/productinformation/lookup/ResourceBasedProductLookup.class] <br class="title-page-name"/>        - restClientProductLookup: defined in file [/.../sources/ch07/productinformation/build/classes/main/packt/java9/by/example/mybusiness/productinformation/lookup/RestClientProductLookup.class] <br class="title-page-name"/><br class="title-page-name"/>Action: <br class="title-page-name"/><br class="title-page-name"/>Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed
</pre>
<p class="calibre2">This is a fairly self-explanatory error message; it tells a lot. Now is the time when we can configure the bean in XML, but at the same time, we can also configure it using Java.</p>
<p class="calibre2">Many developers do not get the point the first time. I did not get it either. The whole XML configuration was to separate the configuration from the code. It was to create the possibility that a system administrator changes the configuration and is free to select one or the other implementation of some interface, wiring the application together. Now Spring tells me that it is better to return to the programmatic way?</p>
<p class="calibre2">At the same time, I could hear concerns for many years that XML is not really any better than Java code. XML writing is essentially programming, except that the tooling and IDE support is not as good for XML as it is for Java code (the latter developed a lot in recent years, although for Spring XML configuration).</p>
<p class="calibre2">To understand the concept of returning to Java code from XML, we have to get back to the pure reason and aim of the XML way of configuration. The main advantage of XML Spring configuration is not that the format is not programmatic but rather that the configuration code is separated from application code. If we write the configuration in Java and keep those configuration classes to the bare minimum, and they stay as they should, then the separation of application versus configuration code still stands. It is only the format of the configuration that we change from XML to Java. The advantages are numerous. One is that the names of the classes are recognized by the IDE as we edit and we can have autocomplete in Java (note that this also works using XML in some of the IDEs utilizing some of the extensions of plugins). In the case of Java, IDE support is ubiquitous. Java is more readable than XML. Well, this is a matter of taste, but most of us like Java more than XML.</p>
<p class="calibre2">System administrators can also edit Java code. When they edit the XML configuration, they usually have to extract it from a JAR or WAR file, edit it, and then package the archive again. In the case of Java editing, they also have to issue a <kbd class="calibre11">gradle war</kbd> command or something similar. This should not be a showstopper for a system manager who runs Java applications on a server. And again, it is not Java programming. It is only editing some Java code files and replacing some class name literals and string constants.</p>
<p class="calibre2">We follow this approach in our sample application code. We have two configuration files in the application: one for local deployment and testing and another for production. The <kbd class="calibre11">@Profile</kbd> annotation specifies which profile the configuration should use. The profile, when the code is executed, can be specified on the command line as a system property, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">$ gradle -Dspring.profiles.active=local bootRun</strong>
</pre>
<p class="calibre2">The configuration class is annotated with <kbd class="calibre11">@Configuration</kbd>. The methods that are bean factories are annotated with <kbd class="calibre11">@Bean</kbd>:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation; <br class="title-page-name"/>import ... <br class="title-page-name"/>@Configuration <br class="title-page-name"/>@Profile("local") <br class="title-page-name"/>public class SpringConfigurationLocal { <br class="title-page-name"/>    @Bean <br class="title-page-name"/>    @Primary <br class="title-page-name"/>    public ProductLookup productLookup() { <br class="title-page-name"/>        return new ResourceBasedProductLookup(); <br class="title-page-name"/>    } <br class="title-page-name"/>    @Bean <br class="title-page-name"/>    public ProductInformationServiceUrlBuilder urlBuilder(){ <br class="title-page-name"/>        return null; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The bean factory simply returns a new instance of the <kbd class="calibre11">ResourceBasedProductLookup</kbd> class that implements the <kbd class="calibre11">ProductLookup</kbd> interface. This implementation can be used to run the application for local testing when there are no external services to rely on. This implementation reads the product data from local resource files packaged into the JAR application.</p>
<p class="calibre2">The production version of the configuration is not much different, but as it may be expected, there are a few more things to configure:</p>
<pre class="calibre20">
@Configuration <br class="title-page-name"/>@Profile("production") <br class="title-page-name"/>public class SpringConfiguration { <br class="title-page-name"/><br class="title-page-name"/>    @Bean <br class="title-page-name"/>    @Primary <br class="title-page-name"/>    public ProductLookup productLookup() { <br class="title-page-name"/>        return new RestClientProductLookup(urlBuilder()); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @Bean <br class="title-page-name"/>    public ProductInformationServiceUrlBuilder urlBuilder(){ <br class="title-page-name"/>        return new ProductInformationServiceUrlBuilder( <br class="title-page-name"/>                                         "http://localhost"); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This version of the <kbd class="calibre11">ProductLookup</kbd> service class uses an external REST service to retrieve the data that it will present to the clients. To do so, it needs the URLs of these services. Such URLs should usually be configured. In our example, we implement a solution where these URLs can be computed on the fly. I tried to make up a situation where it may be needed in real life, but all reasoning was contorted and I gave up. The real reason is that, this way, we can see code that contains a bean that needs another bean to be injected. For now, note that the <kbd class="calibre11">ProductInformationServiceUrlBuilder</kbd> instance bean is defined in the same way as the <kbd class="calibre11">ProductLookup</kbd> bean, and when it has to be injected into the constructor of the <kbd class="calibre11">ProductLookup</kbd> bean, its defining bean method is used and not the following expression directly:</p>
<pre class="calibre20">
new ProductInformationServiceUrlBuilder("http://localhost");
</pre>
<p class="calibre2">The latter may work, but not in all situations and we should not use it. For the reasons, we will return when we discuss AOP with Spring in a subsequent section.</p>
<p class="calibre2">Also note that there is no need to define an interface to define a bean. The type that the bean method returns can also be a class. The context will use the method that fits the needed type, and if there are more than one suitable types and the configuration is not precise enough, as we saw, the container will log an error and will not work.</p>
<p class="calibre2">In the configuration that serves the local profile, we create a <kbd class="calibre11">null</kbd> value for <kbd class="calibre11">ProductInformationServiceBuilder</kbd>. This is because we do not need it when we use local testing. Also, if any method from this class is invoked, it will be an error. Errors should be detected as soon as possible; thus, a <kbd class="calibre11">null</kbd> value is a good choice.</p>
<p class="calibre2">The <kbd class="calibre11">ProductInformationServiceUrlBuilder</kbd> class is very simple:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation; <br class="title-page-name"/><br class="title-page-name"/>public class ProductInformationServiceUrlBuilder { <br class="title-page-name"/>    private final String baseUrl; <br class="title-page-name"/><br class="title-page-name"/>    public ProductInformationServiceUrlBuilder(String baseUrl) { <br class="title-page-name"/>        this.baseUrl = baseUrl; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public String url(String service, String parameter) { <br class="title-page-name"/>        final String serviceUrl; <br class="title-page-name"/>        switch (service) { <br class="title-page-name"/>            case "pi": <br class="title-page-name"/>                serviceUrl =  <br class="title-page-name"/>                  baseUrl + ":8081/product/{id}"; <br class="title-page-name"/>                break; <br class="title-page-name"/>            case "query": <br class="title-page-name"/>                serviceUrl =  <br class="title-page-name"/>                  baseUrl + ":8081/query/{query}"; <br class="title-page-name"/>                break; <br class="title-page-name"/>            case "inventory": <br class="title-page-name"/>                serviceUrl =  <br class="title-page-name"/>                  baseUrl + ":8083/inventory/{id}"; <br class="title-page-name"/>                break; <br class="title-page-name"/>            default: <br class="title-page-name"/>                serviceUrl = null; <br class="title-page-name"/>                break; <br class="title-page-name"/>        } <br class="title-page-name"/>        return serviceUrl; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This bean also needs a constructor parameter, and we used a string constant in the configuration. This clearly shows that it is possible to use a simple object to initialize some of the dependencies (what would stop us, it is pure Java after all), but it may hinder the working of some Spring features.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Service classes</h1>
            

            <article>
                
<p class="calibre2">We have two service classes. These classes serve the controllers with data and implement the business logic, no matter how simple they are. One of the service class implementations calls REST-based services, while the other one reads data from properties files. The latter can be used to test the application offline. The one that calls REST services is used in the production environment. Both of them implement the <kbd class="calibre11">ProductLookup</kbd> interface:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation; <br class="title-page-name"/>import java.util.List; <br class="title-page-name"/>public interface ProductLookup { <br class="title-page-name"/>    ProductInformation byId(String id); <br class="title-page-name"/>    List&lt;String&gt; byQuery(String query); <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre11">ResourceBasedProductLookup</kbd> stores the whole database in a map called products. It is filled from the properties files when one of the service methods is invoked. The <kbd class="calibre11">private</kbd> method <kbd class="calibre11">loadProducts</kbd> is invoked from each of the service methods when they start, but it loads the data only if it is not loaded yet:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation.lookup; <br class="title-page-name"/>import... <br class="title-page-name"/><br class="title-page-name"/>@Service <br class="title-page-name"/>public class ResourceBasedProductLookup implements ProductLookup { <br class="title-page-name"/>    private static Logger log = LoggerFactory.getLogger(ResourceBasedProductLookup.class);
</pre>
<p class="calibre2">The class is annotated using <kbd class="calibre11">@Service</kbd>. This annotation is practically equivalent to the <kbd class="calibre11">@Component</kbd> annotation. This is only an alternative name to the same annotation. Spring also handles the <kbd class="calibre11">@Component</kbd> annotation such that if an annotation interface is annotated using the <kbd class="calibre11">@Component</kbd> annotation, the annotation can also be used to signal that a class is a Spring component. You can write your own annotation interfaces if you want to signal for better readability that a class is not a simple component but some other special type.</p>
<p class="calibre2">For example, start up your IDE and navigate to the source code of the <kbd class="calibre11">org.springframework.stereotype.Service</kbd> interface:</p>
<pre class="calibre20">
    private ProductInformation <br class="title-page-name"/>                  fromProperties(Properties properties) { <br class="title-page-name"/>        final ProductInformation pi = new ProductInformation(); <br class="title-page-name"/>        pi.setTitle(properties.getProperty("title")); <br class="title-page-name"/>        pi.setDescription(properties.getProperty("description")); <br class="title-page-name"/>        pi.setWeight( <br class="title-page-name"/>           Double.parseDouble(properties.getProperty("weight"))); <br class="title-page-name"/>        pi.getSize()[0] = <br class="title-page-name"/>           Double.parseDouble(properties.getProperty("width")); <br class="title-page-name"/>        pi.getSize()[1] =  <br class="title-page-name"/>           Double.parseDouble(properties.getProperty("height")); <br class="title-page-name"/>        pi.getSize()[2] =  <br class="title-page-name"/>           Double.parseDouble(properties.getProperty("depth")); <br class="title-page-name"/>        return pi; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The <kbd class="calibre11">fromProperties</kbd> method creates an instance of <kbd class="calibre11">ProductInformation</kbd> and fills it from the parameters given in the <kbd class="calibre11">Properties</kbd> object. The <kbd class="calibre11">Properties</kbd> class is an old and widely used type. Although there are more modern formats and classes, this is still widely used and it is likely that you will meet this class. This is the very reason we use it here.</p>
<div class="packtinfobox"><kbd class="calibre22">ProductInformation</kbd> is a simple <strong class="calibre24">Data Transfer Object</strong> (<strong class="calibre24">DTO</strong>) that contains no logic, only fields, setters, and getters. It also contains a constant, <kbd class="calibre22">emptyProductInformation</kbd>, holding a reference to an instance of the class with empty values.</div>
<p class="calibre2">A <kbd class="calibre11">Properties</kbd> object is similar to a <kbd class="calibre11">Map</kbd> object. It contains <kbd class="calibre11">String</kbd> values assigned to <kbd class="calibre11">String</kbd> keys. There are methods, as we will see in our examples, that help the programmer to load a <kbd class="calibre11">Properties</kbd> object from a so-called properties file. Such a file usually has the <kbd class="calibre11">.properties</kbd> extension, and it contains key value pairs in the following format:</p>
<pre class="calibre20">
key=value
</pre>
<p class="calibre2">For example, the <kbd class="calibre11">123.properties</kbd> file contains the following:</p>
<pre class="calibre20">
id=123 <br class="title-page-name"/>title=Book Java 9 by Example <br class="title-page-name"/>description=a new book to learn Java 9 <br class="title-page-name"/>weight=300 <br class="title-page-name"/>width=20 <br class="title-page-name"/>height=2 <br class="title-page-name"/>depth=18
</pre>
<p class="calibre2">The <kbd class="calibre11">properties</kbd> files are used to store simple configuration values and are almost exclusively used to contain language-specific constants. This is a very contorted use because <kbd class="calibre11">properties</kbd> files are <strong class="calibre1">ISO Latin-1</strong> encoded files, and in case you need to use some special UTF-8 characters, you have to type them using the  <kbd class="calibre11">\uXXXX</kbd> format or using the native2ascii converter program. You cannot save them simply as UTF-8. Nevertheless, this is the file format used for language-specific strings used for program internationalization (also abbreviated as i18n because there are 18 characters between the starting i and the last n).<br class="title-page-name"/>
To get the <kbd class="calibre11">Properties</kbd> object, we have to read the files in the project and get them packaged into a JAR file. The Spring class, <kbd class="calibre11">PathMatchingResourcePatternResolver</kbd>, helps us in doing so.</p>
<div class="packttip"><span class="URLPACKT">Gosh, yes, I know! We have to get used to these long names when we use Spring. Anyway, such long and descriptive names are widely used in an enterprise environment and they are needed to explain the functionality of the classes.</span></div>
<p class="calibre2"><span>We declare a map that will contain all the products during the testing:</span></p>
<pre class="calibre20">
    final private Map&lt;String, ProductInformation&gt; <br class="title-page-name"/>                            products = new HashMap&lt;&gt;();
</pre>
<p class="calibre2">The key is the product ID, which is a string in our example. The values are the <kbd class="calibre11">ProductInformation</kbd> objects that we fill up using the <kbd class="calibre11">fromProperties</kbd> method:</p>
<pre class="calibre20">
    private boolean productsAreNotLoaded = true;
</pre>
<p class="calibre2">The next field signals that the products are not loaded:</p>
<div class="packttip">Novice programmers usually use the opposite value with the name <kbd class="calibre22">productsAreLoaded</kbd> and set to <kbd class="calibre22">false</kbd> by default. In that case, the only place where we will read a value will negate the value, or the main branch of the <kbd class="calibre22">if</kbd> command becomes the do nothing part. Neither is a best practice.</div>
<pre class="calibre20">
    private void loadProducts() { <br class="title-page-name"/>        if (productsAreNotLoaded) { <br class="title-page-name"/>            try { <br class="title-page-name"/>                Resource[] resources = <br class="title-page-name"/>                   new PathMatchingResourcePatternResolver() <br class="title-page-name"/>                            .getResources( <br class="title-page-name"/>                               "classpath:products/*.properties"); <br class="title-page-name"/>                for (Resource resource : resources) { <br class="title-page-name"/>                    loadResource(resource); <br class="title-page-name"/>                    } <br class="title-page-name"/>                } <br class="title-page-name"/>                productsAreNotLoaded = false; <br class="title-page-name"/>            } catch (IOException ex) { <br class="title-page-name"/>                log.error("Test resources can not be read",ex); <br class="title-page-name"/>            } <br class="title-page-name"/>        } <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The <kbd class="calibre11">getResources</kbd> method returns all the resources (files) that are on the classpath under the <kbd class="calibre11">products</kbd> directory and that have a<kbd class="calibre11">.properties</kbd> extension:</p>
<pre class="calibre20">
private void loadResource(Resource resource) throws IOException { <br class="title-page-name"/>    final int dotPos = resource.getFilename().lastIndexOf('.'); <br class="title-page-name"/>    final String id = resource.getFilename().substring(0, dotPos); <br class="title-page-name"/>    Properties properties = new Properties(); <br class="title-page-name"/>    properties.load(resource.getInputStream()); <br class="title-page-name"/>    final ProductInformation pi = fromProperties(properties); <br class="title-page-name"/>    pi.setId(id); <br class="title-page-name"/>    products.put(id, pi); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The product ID is given by the name of the file. This is calculated using simple string manipulation, cutting off the extension. The <kbd class="calibre11">Resource</kbd> can also provide an input stream that the <kbd class="calibre11">Properties</kbd> class's <kbd class="calibre11">load</kbd> method can use to load all the properties at once from the file. Finally, we save the new <kbd class="calibre11">ProductInformation</kbd> object in the map.</p>
<p class="calibre2">We also have a special <kbd class="calibre11">noProduct</kbd> list that is empty. This is returned if there is no product for the query when we want to search for products:</p>
<pre class="calibre20">
    private static final List&lt;String&gt; noProducts = <br class="title-page-name"/>                                            new LinkedList&lt;&gt;();
</pre>
<p class="calibre2">The product lookup service just takes a product from the <kbd class="calibre11">Map</kbd> and returns it, or if it does not exist, it returns an empty product:</p>
<pre class="calibre20">
@Override <br class="title-page-name"/>public ProductInformation byId(String id) { <br class="title-page-name"/>    loadProducts(); <br class="title-page-name"/>    if (products.containsKey(id)) { <br class="title-page-name"/>        return products.get(id); <br class="title-page-name"/>    } else { <br class="title-page-name"/>        return ProductInformation.emptyProductInformation; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The query is a bit more complex. It implements searching for a product by title. Real-life implementations may implement a more complex logic, but this version is for local testing only; thus, the search by title is enough, perhaps even more complex than would be really necessary:</p>
<pre class="calibre20">
@Override <br class="title-page-name"/>public List&lt;String&gt; byQuery(String query) { <br class="title-page-name"/>    loadProducts(); <br class="title-page-name"/>    List&lt;String&gt; pis = new LinkedList&lt;&gt;(); <br class="title-page-name"/>    StringTokenizer st = new StringTokenizer(query, "&amp;="); <br class="title-page-name"/>    while (st.hasMoreTokens()) { <br class="title-page-name"/>        final String key = st.nextToken(); <br class="title-page-name"/>        if (st.hasMoreTokens()) { <br class="title-page-name"/>            final String value = st.nextToken(); <br class="title-page-name"/>            log.debug("processing {}={} query", key, value); <br class="title-page-name"/>            if (!"title".equals(key)) { <br class="title-page-name"/>                return noProducts; <br class="title-page-name"/>            } <br class="title-page-name"/>            for (String id : products.keySet()) { <br class="title-page-name"/>                ProductInformation pi = products.get(id); <br class="title-page-name"/>                if (pi.getTitle().startsWith(value)) { <br class="title-page-name"/>                    pis.add(id); <br class="title-page-name"/>                } <br class="title-page-name"/>            } <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    return pis; <br class="title-page-name"/>}
</pre>
<p class="calibre2">The service class that implements the production functionality is much simpler. Strange, but many times the test code is more complex than the production code:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation.lookup; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@Component <br class="title-page-name"/>public class RestClientProductLookup implements ProductLookup { <br class="title-page-name"/>    private static Logger log = LoggerFactory.getLogger(RestClientProductLookup.class); <br class="title-page-name"/><br class="title-page-name"/>    final private ProductInformationServiceUrlBuilder piSUBuilder; <br class="title-page-name"/><br class="title-page-name"/>    public RestClientProductLookup( <br class="title-page-name"/>               ProductInformationServiceUrlBuilder piSUBuilder) { <br class="title-page-name"/>        this.piSUBuilder = piSUBuilder; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The constructor is used to inject the URL builder bean and this is all the auxiliary code the class has. The rest are the two service methods:</p>
<pre class="calibre20">
    @Override <br class="title-page-name"/>    public ProductInformation byId(String id) { <br class="title-page-name"/>        Map&lt;String, String&gt; uriParameters = new HashMap&lt;&gt;(); <br class="title-page-name"/>        uriParameters.put("id", id); <br class="title-page-name"/>        RestTemplate rest = new RestTemplate(); <br class="title-page-name"/>        InventoryItemAmount amount = rest.getForObject( <br class="title-page-name"/>                        piSUBuilder.url("inventory"), <br class="title-page-name"/>                        InventoryItemAmount.class, <br class="title-page-name"/>                        uriParameters); <br class="title-page-name"/>        if ( amount.getAmount() &gt; 0) { <br class="title-page-name"/>            return rest.getForObject(piSUBuilder.url("pi"), <br class="title-page-name"/>                    ProductInformation.class, <br class="title-page-name"/>                    uriParameters); <br class="title-page-name"/>        } else { <br class="title-page-name"/>            return ProductInformation.emptyProductInformation; <br class="title-page-name"/>        } <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The <kbd class="calibre11">byId</kbd> method first calls the inventory service to see if there are any products on the inventory. This REST service returns a JSON that has the format, <kbd class="calibre11">{ amount : nnn }</kbd>; thus, we need a class (so simple that we do not list here) that has the <kbd class="calibre11">int amount</kbd> field, the setter, and the getter.</p>
<p class="calibre2">The Spring <kbd class="calibre11">RestTemplate</kbd> provides an easy way to access a REST service. All it needs is the URL template, a type that is used to convert the result, and a <kbd class="calibre11">Map</kbd> object with the parameters. The URL template string may contain parameters in the same way as the request mapping in the Spring controllers, the name of the parameter being between the <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd> characters. The template class provides simple methods to access REST services. It automatically does marshaling, sending parameters, and un-marshaling, receiving the response. In the case of a <kbd class="calibre11">GET</kbd> request, the marshaling is not needed. The data is in the request URL, and the <kbd class="calibre11">{xxx}</kbd> placeholders are replaced with the values from the map supplied as a third argument. The un-marshaling is readily available for most of the formats. In our application, the REST service sends JSON data, and it is indicated in the response <kbd class="calibre11">Content-Type</kbd> HTTP header. <kbd class="calibre11">RestTemplate</kbd> converts the JSON to the type provided as argument. If ever the server decides to send the response in XML, and it will also be indicated in the HTTP header, <kbd class="calibre11">RestTemplate</kbd> will handle the situation automatically. As a matter of fact, looking at the code, we cannot tell how the response is encoded. This is also nice because it makes the client flexible and at the same time, we do not need to deal with such technical details. We can focus on the business logic.</p>
<p class="calibre2">At the same time, the class also provides configuration parameters in the case of marshaling or some other functionality so that it automatically needs that. You can, for example, provide marshaling methods, though I recommend that you use whatever is available by default. In most cases, when a developer thinks that there is a need for a special version of any of these functions, the original design of their code is flawed.</p>
<p class="calibre2">The business logic is very simple. We first ask the inventory if there is any product in stock. If there is (more than zero), then we query the product information service and return the details. If there is none, then we return an empty record.</p>
<p class="calibre2">The other service is even simpler. It simply calls the underpinning service and returns the result:</p>
<pre class="calibre20">
    @Override <br class="title-page-name"/>    public List&lt;String&gt; byQuery(String query) { <br class="title-page-name"/>        Map&lt;String, String&gt; uriParameters = new HashMap&lt;&gt;(); <br class="title-page-name"/>        uriParameters.put("query", query); <br class="title-page-name"/>        RestTemplate rest = new RestTemplate(); <br class="title-page-name"/>        return rest.getForObject( <br class="title-page-name"/>                  piSUBuilder.url("query"), <br class="title-page-name"/>                  List.class, <br class="title-page-name"/>                  uriParameters); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Compiling and running the application</h1>
            

            <article>
                
<p class="calibre2">We use <kbd class="calibre11">gradle</kbd> to compile and run the application. Since the application does not have any specific configuration that would not appear in most similar applications, it is wise to use the Spring boot. The Spring boot makes it extremely simple to create and run a web application. We need a Java standard <kbd class="calibre11">public static void main</kbd> method that starts up the application via Spring:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation; <br class="title-page-name"/>import ... <br class="title-page-name"/>@SpringBootApplication( <br class="title-page-name"/>        scanBasePackageClasses = <br class="title-page-name"/>          packt.java9.by.example.mybusiness.SpringScanBase.class) <br class="title-page-name"/>public class Application { <br class="title-page-name"/>    public static void main(String[] args) { <br class="title-page-name"/>        SpringApplication.run(Application.class, args); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The method does nothing but start the <kbd class="calibre11">StringApplication</kbd> class's <kbd class="calibre11">run</kbd> method. It passes the original arguments and also the class that the application is in. Spring uses this class to read the annotation. The <kbd class="calibre11">@SpringBootApplication</kbd> annotation signals that this class is a Spring boot application and provides arguments to configure the packages that contain the application. To do so, you can provide the name of the package that contains the classes, but you can also provide a class in the base package that contains all the classes that Spring has to be aware of. You may not be able to use the class version of the annotation parameter because the root package may not contain any class, only sub-packages. At the same time, providing the name of the root package as <kbd class="calibre11">String</kbd>, will not reveal any typo or misalignment during compile time. Some <em class="calibre12">IDE</em> may recognize that the parameter is supposed to be a package name, or it may scan the strings of the program for package names when you refactor or rename a package and give you support for that, but this is more heuristics only. It is a common practice to create a placeholder class that does nothing in the root package in case there is no class there. This class can be used to specify <kbd class="calibre11">scanBasePackageClasses</kbd> as an annotation parameter instead of <kbd class="calibre11">scanBasePackages</kbd> that needs <kbd class="calibre11">String</kbd>. In our example, we have an empty interface, <kbd class="calibre11">SpringScanBase</kbd>, as a placeholder.</p>
<p class="calibre2">Spring scans all the classes that are on the classpath, recognizes the components and field annotations that it can interpret, and uses this knowledge to create beans without configuration when needed.</p>
<div class="packttip">Note that the abstract class, <kbd class="calibre22">ClassLoader</kbd>, included in the JDK does not provide any class scanning method. Since Java environments and frameworks can implement their own <kbd class="calibre22">ClassLoaders</kbd>, it is possible (but very unlikely) that some implementation does not provide the scanning functionality provided by the <kbd class="calibre22">URLClassLoader</kbd>. <kbd class="calibre22">URLClassLoader</kbd> is a non-abstract implementation of the class loading functionality and is a part of the <em class="calibre27">JDK</em> just as well as <kbd class="calibre22">ClassLoader</kbd>. We will discuss the intricacies of the class loading mechanism in the subsequent chapters.</div>
<p class="calibre2">The <kbd class="calibre11">gradle</kbd> build file contains the usual things. It specifies the repositories, the plugins for Java, the IDEs, and also for Spring boot. It also specifies the name of the JAR file that it generates during build. The most important part is the dependency list:</p>
<pre class="calibre20">
buildscript { <br class="title-page-name"/>    repositories { <br class="title-page-name"/>        mavenCentral() <br class="title-page-name"/>    } <br class="title-page-name"/>    dependencies { <br class="title-page-name"/>        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.4.1.RELEASE") <br class="title-page-name"/>    } <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>apply plugin: 'java' <br class="title-page-name"/>apply plugin: 'eclipse' <br class="title-page-name"/>apply plugin: 'idea' <br class="title-page-name"/>apply plugin: 'spring-boot' <br class="title-page-name"/><br class="title-page-name"/>jar { <br class="title-page-name"/>    baseName = 'packt-ch07-microservice' <br class="title-page-name"/>    version =  '1.0.0' <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>repositories { <br class="title-page-name"/>    mavenCentral() <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>bootRun { <br class="title-page-name"/>    systemProperties System.properties <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>sourceCompatibility = 1.9 <br class="title-page-name"/>targetCompatibility = 1.9 <br class="title-page-name"/><br class="title-page-name"/>dependencies { <br class="title-page-name"/>    compile("org.springframework.boot:spring-boot-starter-web") <br class="title-page-name"/>    compile("org.springframework.boot:spring-boot-devtools") <br class="title-page-name"/>    compile("org.springframework:spring-aop") <br class="title-page-name"/>    compile("org.springframework:spring-aspects") <br class="title-page-name"/>    testCompile("org.springframework.boot:spring-boot-starter-test") <br class="title-page-name"/>}
</pre>
<p class="calibre2">We depend on Spring boot packages, some test packages, AOP support (which we will look at soon), and also on Spring boot devtools.</p>
<p class="calibre2">Spring boot devtools make it possible to restart a web application whenever it is recompiled, without restarting the built-in Tomcat server. Suppose, we start the application using the following command line:</p>
<pre class="calibre20">
    <strong class="calibre1">gradle -Dspring.profiles.active=production bootRun</strong>
</pre>
<p class="calibre2">The Gradle starts up the application and whenever it sees that the classes it runs are modified, it reloads them, and we can test the modified application within a few seconds.</p>
<p class="calibre2">The <kbd class="calibre11">-Dspring.profiles.active=production</kbd> argument specifies that the production profile should be active. To be able to use this command line parameter, we will also need the <kbd class="calibre11">bootRun{}</kbd> configuration closure in the build file.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Testing the application</h1>
            

            <article>
                
<p class="calibre2">The application should have unit tests for each and every class it has except, perhaps, for the DTO classes that contain no functionality. The setters and getters are created by the IDE and are not typed in by the programmer, so it is unlikely that there will be any errors in those. If there is some error related to those classes, it is more likely that it is some integration problem that cannot be discovered using unit tests. Since we discussed unit tests in the previous chapters in detail, we will focus more on integration tests and application tests here.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Integration test</h1>
            

            <article>
                
<p class="calibre2">Integration tests are very similar to unit tests, and many times, novice programmers claim they do unit testing when they actually do integration testing.</p>
<p class="calibre2">Integration tests drive the code but do not test the individual classes (units) in isolation, mocking everything that the class may use. Rather, they test the functionality of most of the classes that are needed to perform a test. This way, the integration test does test that the classes are able to work together and not only satisfy their own specifications but also ensure that these specifications work together.</p>
<p class="calibre2">In integration test, the external world (like external services) and access to database are mocked only. That is because the integration tests are supposed to run on integration servers, in the same environment where the unit tests are executed, and there these external interfaces may not be available. Many times, databases are mocked using in-memory SQL, and external services are mocked using some mock classes.</p>
<p class="calibre2">Spring provides a nice environment to execute such integration tests. In our project, we have a sample integration test:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation; <br class="title-page-name"/>import ...  <br class="title-page-name"/>@RunWith(SpringRunner.class) <br class="title-page-name"/>@SpringBootTest(classes = Application.class) <br class="title-page-name"/>@AutoConfigureMockMvc <br class="title-page-name"/>@ActiveProfiles("local") <br class="title-page-name"/>public class ProductInformationControllerTest { <br class="title-page-name"/>    @Autowired <br class="title-page-name"/>    private MockMvc mockMvc; <br class="title-page-name"/>    @Test <br class="title-page-name"/>    public void noParamGreetingShouldReturnDefaultMessage()  <br class="title-page-name"/>                                             throws Exception { <br class="title-page-name"/>        this.mockMvc.perform(get("/pi")).andDo(print()) <br class="title-page-name"/>                .andExpect(status().isNotFound()); <br class="title-page-name"/>    } <br class="title-page-name"/>    @Test <br class="title-page-name"/>    public void paramGreetingShouldReturnTailoredMessage() <br class="title-page-name"/>                                             throws Exception { <br class="title-page-name"/><br class="title-page-name"/>        this.mockMvc.perform(get("/pi/123")) <br class="title-page-name"/>                .andDo(print()).andExpect(status().isOk()) <br class="title-page-name"/>                .andExpect(jsonPath("$.title") <br class="title-page-name"/>                .value("Book Java 9 by Example")); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>}
</pre>
<p class="calibre2">This is far from being a complete and full-fledged integration test. There are many situations that are not tested, but here it is good as an example. To have all the support for the Spring environment, we have to use the <kbd class="calibre11">SpringRunner</kbd> class. The <kbd class="calibre11">@RunWith</kbd> annotation is handled by the JUnit framework, all other annotations are for Spring. When the JUnit framework sees that there is a <kbd class="calibre11">@RunWith</kbd> annotation and a runner class specified, it starts that class instead of the standard runner. <kbd class="calibre11">SpringRunner</kbd> sets up a Spring context for the test and handles the annotations.</p>
<p class="calibre2"><kbd class="calibre11">@SpringBootTest</kbd> specifies the applications that we need to test. This helps Spring to read that class and the annotation on that class, identifying the packages to be scanned.</p>
<p class="calibre2"><kbd class="calibre11">@AutoConfigureMockMvc</kbd> tells Spring to configure a mock version of the Model View Controller framework, which can be executed without a servlet container and web protocol. Using that, we can test our REST services without really going to the network.</p>
<p class="calibre2"><kbd class="calibre11">@ActiveProfiles</kbd> tells Spring that the active profile is local and that Spring has to use the configuration that is denoted by the annotation, <kbd class="calibre11">@Profile("local")</kbd>. This is a version that uses the .<kbd class="calibre11">properties</kbd> files instead of external HTTP services; thus, this is appropriate for integration testing.</p>
<p class="calibre2">The test performs <kbd class="calibre11">GET</kbd> requests inside the mocking framework, executes the code in the controller, and tests the returned value using the mocking framework and fluent API in a very readable way.</p>
<div class="packttip">Note that using the properties files and having the service implementation based on properties file is a bit of an overkill. I created this so that it is possible to start up the application interactively without any real backing service. Consider the following command: <kbd class="calibre22">gradle -Dspring.profiles.active=local bootRun</kbd> .<br class="calibre23"/>
If we issue the preceding command, then the server starts up using this local implementation. If we only aim for integration testing, then the local implementation of the service classes should be under the <kbd class="calibre22">test</kbd> directory and should be much simpler, mainly only returning constant responses for any expected request and throwing errors if any non-expected request comes.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Application test</h1>
            

            <article>
                
<p class="calibre2">Consider the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">gradle -Dspring.profiles.active=production bootRun</strong>
</pre>
<p class="calibre2">If we start up the application issuing the preceding command and fire up the browser to the URL, <kbd class="calibre11">http://localhost:8080/pi/123</kbd>, we will get a fat error message on the browser screen. Ouch...</p>
<p class="calibre2">It says <kbd class="calibre11">Internal Server Error, status=500</kbd> or something similar. That is because our code wants to connect to the backing services, but we do not have any yet. To have some to test the application on this level, we should create the backing services or at least something that mocks them. The easiest way is to use the soapUI program.</p>
<p class="calibre2">The soapUI is a Java program available from <a href="https://www.soapui.org/" class="calibre6"><span>https://www.soapui.org/</span></a>. There is an open source and free version of it, and there is a commercial version. For our purposes, the free version is enough. We can install it in the simplest click-forward way as it has a setup wizard. After that, we can start it up and use the graphical user interface.</p>
<p class="calibre2">We create a new test project, <span>Catalog and inventory</span>, and set up two REST mock services in it: <span>Catalog</span> and <span>Inventory</span>, as shown in the following screenshot:</p>
<div class="packtfigure"><img class="image-border38" src="../images/00052.jpeg"/></div>
<p class="calibre2">We set up, for each of the mock services, requests to be matched and responses. The content of the response is text and can be typed into the text field on the user interface. It is important that we do not forget to set the media type of the response to <kbd class="calibre11">application/json</kbd> (the default is XML).</p>
<div class="packtfigure"><img class="image-border39" src="../images/00053.jpeg"/></div>
<p class="calibre2">Before starting the services, we have to set the port numbers by clicking on the cogwheel to something that is available on the server. Since 8080 is used by the Tomcat server executed by Gradle, and 8082 is used by soapUI to list the mock services that are currently running, I set the catalog to listen on 8081 and inventory on 8083. You can also see these port numbers in the listing of the <kbd class="calibre11">ProductInformationServiceUrlBuilder</kbd> class.</p>
<p class="calibre2">The soapUI saves the project in an XML file, and it is available for you on GitHub in the <kbd class="calibre11">project</kbd> directory.</p>
<p class="calibre2">After starting the mock services, the error message disappears from the browser screen when we press refresh:</p>
<div class="packtfigure"><img class="image-border" src="../images/00054.jpeg"/></div>
<p class="calibre2">What we see is exactly what we typed into soapUI.</p>
<p class="calibre2">If now I change the inventory mock service to return 0 instead of 100, as in the original version, what I get is the following empty record:</p>
<pre class="calibre20">
{"id":"","title":"","description":"","size":[0.0,0.0,0.0],"weight":0.0}
</pre>
<p class="calibre2">The testing even on this level can be automated. Now, we were playing around using the browser and this is something nice. Somehow, I feel I am producing something when there is a program that is really doing something, when I can see that there is some response in the browser window. However, after a while, this becomes boring and testing manually that the application is still working is cumbersome. It is especially boring for those functions that were not changed. The fact is that they do change miraculously many times even when we do not touch the code that influences them. We touch the code that does influence the function except that we are not aware of it. Poor design, poor coding, or maybe we just forgot, but it happens. Regression test is inevitable.</p>
<p class="calibre2">Although browser testing user interfaces can also be automated, this time, we are having a REST service that we can test and that is what soapUI is for. We have already installed the tool, we have already started it, and we have some mock services running in it. The next thing is to add a <span>New REST service from URI</span> to the project and specify the URL, <kbd class="calibre11">http://localhost:8080/pi/{id}</kbd>, exactly the same way as we did for Spring:</p>
<div class="packtfigure"><img class="image-border40" src="../images/00055.jpeg"/></div>
<p class="calibre2">When we have a REST service defined in the project, we can create a new Test Suite and a Test Case inside the suite. We can then add a step to the Test Case that will call the REST service using the parameter <kbd class="calibre11">123</kbd> if we modify the default value, which is the same as the name of the parameter, in this case, <kbd class="calibre11">id</kbd>. We can run the test step using the green triangle on the upper-left corner of the window, and since we have the tested application and the soapUI mock services running, we should get an answer in JSON. We have to select JSON on the response side; otherwise, soapUI tries to interpret the response as XML, and since we have a JSON response, it is not too fruitful. What we see is the following window:</p>
<div class="packtfigure"><img class="image-border" src="../images/00056.jpeg"/></div>
<p class="calibre2">It is the same response that we saw in the browser. There are no miracles when we program computers. Sometimes, we do not understand what happens, and some things are so complex that they seem to be a miracle, but they are actually not. There is an explanation for everything, it may just not be known to us. In this case, we certainly know what is happening, but why is it any better to see the JSON on the screen of soapUI than it is on the browser? The reason is that soapUI can execute assertions and in some cases, further test steps based on the result of the REST invocation, and the final result is a simple YES or NO. The test is OK, or it FAILS.</p>
<p class="calibre2">To add an assertion, click on the <span>Assertions</span> text on the lower-left corner of the window. As you can see in the preceding screenshot, I have already added one that compares the <kbd class="calibre11">"title"</kbd> field of the returned JSON with the text <kbd class="calibre11">"Bar Stool"</kbd>. When we add the assertion, the default value it suggests is the one that was actually returned, which is just a very handy feature.</p>
<p class="calibre2">After this, running the whole test suite again will run all the test cases (we have only one), and all the test steps, one after the other (we again have only one), and finally it will display a green <span>FINISHED</span> bar on the UI, as shown in the following screenshot:</p>
<div class="packtfigure"><img class="image-border" src="../images/00057.jpeg"/></div>
<p class="calibre2">This is not all that soapUI can do. This is a well-developed test tool that has been in the market for many years. soapUI can test SOAP services and REST services, and it can handle JMS messages. You can create tests of many steps with these calls, loops, and assertions in calls or in separate tests, and in case all else fails, you can do just anything by creating programmed steps in the Groovy language or creating extensions in Java.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Servlet filters</h1>
            

            <article>
                
<p class="calibre2">The services work fine by now and anyone can query the details of our products. That may be a problem. The details of the products are not necessarily public information. We have to ensure that we serve the data only to partners who are eligible to see it.</p>
<p class="calibre2">To ensure that, we need something in the request that proves that the request comes from a partner. This information is typically a password or some other secret. It could be placed into the <kbd class="calibre11">GET</kbd> request parameters or into the HTTP request header. It is better to put it into the header because the information is secret and not to be seen by anybody.</p>
<div class="packttip">The GET parameters are a part of the URL, and the browser history remembers that. It is also very easy to enter this information into the browser location window, copy paste it, and send it over a chat channel or over e-mail. This way, a user of the application, who is not so educated and concerned about security, may disclose secret information. Although it is not impossible to do the same with information that is sent in an HTTP header, it is not likely to happen. If the information is in the header and somebody sends the information in an e-mail, they probably know what they are doing; they cross a security border willingly and not by simple negligence.</div>
<p class="calibre2">To send authentication information along the HTTP request, Spring provides a security module that can easily be configured with annotations and configuration XMLs and/or classes. This time, we will do it a bit differently to introduce servlet filters.</p>
<p class="calibre2">We will require that the vendors insert the <kbd class="calibre11">X-PartnerSecret</kbd> header into the request. This is a non-standard header, and thus it must have the <kbd class="calibre11">X-</kbd> prefix. Following this approach is also some extra security feature. This way, we can prevent the user from reaching the service using a simple browser. There is, at least, a need for some extra plugin that can insert a custom header or some other program such as soapUI. This way, it will ensure that our partners will use the interface programmatically, or if ever they need to test the interface ad hoc, only users with a certain level of technology can do so. This is important to keep the support costs controlled.</p>
<p class="calibre2">Since this secret has to be checked in the case of each and every service, we better not insert the checking code into each and every service controller. Even if we create the code properly and factor the check for the secret into a separate class, the invocation of the method asserting that the secret is there and is correct will have to be inserted in each and every controller. The controller does the service; checking the client authenticity is an infrastructure issue. They are different concerns, and thus, they have to be separated.</p>
<p class="calibre2">The best way that the servlet standard provides for us is a servlet filter. A servlet filter is a class invoked by the servlet container before the servlet itself if the filter is configured. The filter can be configured in the <kbd class="calibre11">web.xml</kbd> configuration file of the servlet container or by using an annotation when we use the Spring boot. The filter does not only get the request and response as parameters but also a third argument of the <kbd class="calibre11">FilterChain</kbd> type that it should use to call the servlet or the next filter in the chain.</p>
<p class="calibre2">There can be more than one filter defined and they get chained up. The filter may, at its discretion, decide to call or not to call the next in the chain.</p>
<div class="packtfigure"><img class="image-border41" src="../images/00058.gif"/></div>
<p class="calibre2">We put our servlet filter into the <kbd class="calibre11">auth</kbd> sub-package of our application:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation.auth; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@Component <br class="title-page-name"/>public class AuthFilter implements Filter { <br class="title-page-name"/>    private static Logger log = <br class="title-page-name"/>           LoggerFactory.getLogger(AuthFilter.class); <br class="title-page-name"/>    public static final int NOT_AUTHORIZED = 401; <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void init(FilterConfig filterConfig) <br class="title-page-name"/>                                throws ServletException { <br class="title-page-name"/>    } <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void doFilter(ServletRequest request, <br class="title-page-name"/>                         ServletResponse response, <br class="title-page-name"/>                         FilterChain chain) <br class="title-page-name"/>                          throws IOException, ServletException { <br class="title-page-name"/>        HttpServletRequest httpRequest = <br class="title-page-name"/>                     (HttpServletRequest) request; <br class="title-page-name"/>        final String secret = <br class="title-page-name"/>                     httpRequest.getHeader("X-PartnerSecret"); <br class="title-page-name"/>        log.info("Partner secret is {}", secret); <br class="title-page-name"/>        if ("packt".equals(secret)) { <br class="title-page-name"/>            chain.doFilter(request, response); <br class="title-page-name"/>        } else { <br class="title-page-name"/>            HttpServletResponse httpResponse = <br class="title-page-name"/>                     (HttpServletResponse) response; <br class="title-page-name"/>            httpResponse.sendError(NOT_AUTHORIZED); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void destroy() { <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The filter implements the <kbd class="calibre11">Filter</kbd> interface that defines three methods. In our case, we do not have any parameters to consider in the filter, and we do not allocate any resources to release; thus, both <kbd class="calibre11">init</kbd> and <kbd class="calibre11">destroy</kbd> methods are empty. The main work of the filter is the <kbd class="calibre11">doFilter</kbd> method. It has three parameters, two of them are the same as the parameters of a servlet and the third is <kbd class="calibre11">FilterChain</kbd>.</p>
<p class="calibre2">The request is converted to <kbd class="calibre11">HttpServletRequest</kbd>, so we can get access to the <kbd class="calibre11">X-PartnerSecret</kbd> header through the <kbd class="calibre11">getHeader</kbd> method. If the value sent in this header field is good, we call the next in the chain. In our application, there are no more filters configured; therefore, the next in the chain is the servlet. If the secret is not acceptable, then we do not call the next in the chain. Instead, we return the <em class="calibre12">401 Not Authorized</em> HTTP error to the client.</p>
<div class="packtinfobox">In this application, the secret is very simple. This is the constant string <kbd class="calibre22">packt</kbd>. This is not really a big secret, especially now that it is published in this book. A real-life application would require something more cryptic and less known. It is very probable that each partner would use different secrets and that the secret has to change from time to time.</div>
<p class="calibre2">When there is an error condition in a servlet that our program handles, it is a good practice to use the HTTP error handling mechanism. Instead of sending back a message with the status code <em class="calibre12">200 OK</em> and explaining, for example, in a JSON format that the authentication was not successful, we have to send back the <em class="calibre12">401 code</em>. This is defined by the standard and does not need any further explanation or documentation.</p>
<p class="calibre2">There is one thing left in our program, and that is audit logging.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Audit logging and AOP</h1>
            

            <article>
                
<p class="calibre2">We have logging in our sample code and for that we use slf4j, which we covered in the previous chapter. Logging is more or less the decision of the developer and supports technical levels of operation. There, we also touched on a few sentence audit loggings. This type of logging is usually explicitly required in a functional requirement.</p>
<p class="calibre2">Generally, AOP is separating the different aspects of code functionality into separate code fragments, and implementing them independent of each other. This is very much the single responsibility principle. This time, it is implemented in a way that not only the different functionalities are implemented separately but also how we connect them together is defined separately. What is executed before and after what other parts are encoded separately gets to the Spring configuration. We have seen something similar already. The dependencies that a class needs to properly operate are defined in a separate segment (XML or Java code). It is not a surprise that in the case of AOP, the same is done using Spring. Aspects are configured in the configuration file or class.</p>
<p class="calibre2">A typical aspect is audit logging, and we will use this as an example. There are many topics that can be implemented using aspects, and some of them are even worth implementing that way.</p>
<p class="calibre2">We do not want to implement the audit logging code in each business method or class that needs it. Instead, we implement a general aspect and configure the wiring such that whenever a bean method that needs audit logging is invoked, Spring invokes the audit logging.</p>
<p class="calibre2">There are other important terminologies that we should understand for AOP and especially how AOP can be configured in Spring.</p>
<p class="calibre2">The first and most important is the aspect. This is the functionality that we want to implement, in our example, the audit logging.</p>
<p class="calibre2">Join point is the point in execution when an aspect is invoked. When using a full-scale aspect solution in Java that modifies the byte code of the generated class, a join point can be almost anything. It can be access to a field, read or write; it can be the invocation of a method or exception throwing. In the case of Spring, the class byte code is not modified; thus, Spring is not able to identify the access of a field or an exception throwing. Using Spring, a join point is always used when a method is invoked.</p>
<p class="calibre2">An advice is how the aspect is invoked at the join point. It can be before advice, after advice, or around advice. When the advice is before, the aspect is invoked before the method is called. When the advice is after, the aspect is invoked after the method is invoked. Around means that the aspect is invoked before the method call, and the aspect also has an argument to call the method and still perform some actions after the method is called. This way, the around advice is very similar to servlet filters.</p>
<p class="calibre2">The before advice is called before the method call, and after it returns, the framework will invoke the method. There is no way for the aspect to prevent the invocation of the original method. The only exception is when the aspect, well, throws an exception.</p>
<p class="calibre2">The after advice is also affected by exceptions. There can be an after returning advice that is invoked when the method is returning. The after throwing is invoked only if the method were throwing an exception. After finally is invoked in the case of an exception or return.</p>
<p class="calibre2">Pointcut is a special string expression that identifies join points. A pointcut expression may match zero, one, or more join points. When the aspect is associated with a pointcut expression, the framework will know the join points and when and where to invoke the aspect. In other words, pointcut is the string that tells when and for which method to invoke the aspect.</p>
<p class="calibre2">Even though Spring implementation of AOP does not use AspectJ and does not modify the byte code that was created for the classes, it supports the pointcut expression language. Although this expression language provides more features than what Spring implements, it is a well-established and widely used and accepted expression language to describe pointcuts, and it just would not make sense to invent something new.</p>
<p class="calibre2"><em class="calibre12">Introduction</em> is adding methods or fields to a type that already exists and doing it during runtime. Spring allows this AOP functionality to add an interface to an existing type and add an implementation of the interface in the form of an advice class. In our example, we do not use this functionality.</p>
<p class="calibre2"><em class="calibre12">Target object</em> is the object that is being advised by the aspect. This is the bean that contains the method around the aspect, that is, before or after the aspect is invoked.</p>
<p class="calibre2">That was just a condensed set of definitions, almost like in a math book. If you did not get the point just reading it, don't worry. I did not understand it either. That is why we have the following example, after which all we just covered will make more sense:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.productinformation; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@Configuration <br class="title-page-name"/>@Aspect <br class="title-page-name"/>public class SpringConfigurationAspect { <br class="title-page-name"/>    private static Logger log = <br class="title-page-name"/>              LoggerFactory.getLogger("AUDIT_LOG"); <br class="title-page-name"/><br class="title-page-name"/>    @Around("execution(* byId(..))") <br class="title-page-name"/>    public ProductInformation byIdQueryLogging( <br class="title-page-name"/>                            ProceedingJoinPoint jp) <br class="title-page-name"/>                                         throws Throwable { <br class="title-page-name"/>        log.info("byId query is about to run"); <br class="title-page-name"/>        ProductInformation pi = <br class="title-page-name"/>             (ProductInformation) jp.proceed(jp.getArgs()); <br class="title-page-name"/>        log.info("byId query was executed"); <br class="title-page-name"/>        return pi; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @Around("execution(* url(..))") <br class="title-page-name"/>    public String urlCreationLogging(ProceedingJoinPoint jp) <br class="title-page-name"/>                                            throws Throwable { <br class="title-page-name"/>        log.info("url is to be created"); <br class="title-page-name"/>        String url = (String) jp.proceed(jp.getArgs()); <br class="title-page-name"/>        log.info("url created was "+url); <br class="title-page-name"/>        return url; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The class is annotated with the <kbd class="calibre11">@Configuration</kbd> annotation so that Spring knows that this class contains the configuration. The <kbd class="calibre11">@Aspect</kbd> annotation denotes that this configuration may also contain aspect definitions. The <kbd class="calibre11">@Around</kbd> annotation on the methods gives the type of advice, and the argument string for the annotation is the pointcut expression. If the type of advice is different, one of the annotations, <kbd class="calibre11">@Before</kbd>, <kbd class="calibre11">@After</kbd>, <kbd class="calibre11">@AfterReturning</kbd>, or <kbd class="calibre11">@AfterThrowing</kbd>, should be used.</p>
<p class="calibre2">In our example, we use the <kbd class="calibre11">@Around</kbd> aspect to demonstrate the most complex scenario. We log the execution of the target method before and after the execution of the method, and we also call the original method through the <kbd class="calibre11">ProceedingJoinPoint</kbd> object. Because the two objects return different types and we want to log differently, we define two aspect methods.</p>
<p class="calibre2">The argument of the advice annotation is the pointcut string. In this case, it is a simple one. The first one, <kbd class="calibre11">execution(* byId(..))</kbd>, says that the aspect should be invoked for any execution of any method that has the name byId and has any arguments. The second is very similar, except the name of the method is different. These are simple pointcut expressions, but in a large application that heavily uses AOP, they can be very complex.</p>
<p class="calibre2">The pointcut expression syntax in Spring mainly follows the syntax used by AspectJ. The expression uses the notion of <strong class="calibre1">point cut designator</strong> (<strong class="calibre1">PCD</strong>) that is usually execution. It is followed by the pattern that defines which method to intercept. The general format is as follows:</p>
<pre class="calibre20">
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
</pre>
<p class="calibre2">Except for the return type part, all other parts are optional. For example, we can write the following:</p>
<pre class="calibre20">
execution(public * *(..))
</pre>
<p class="calibre2">This will intercept all <kbd class="calibre11">public</kbd> methods. The following expression intercepts all methods that have a name starting with set:</p>
<pre class="calibre20">
execution(* set*(..))
</pre>
<p class="calibre2">We can use the <kbd class="calibre11">*</kbd> character as a joker in the same way as we can use it on the command line in Windows or Unix shell. The argument matching definition is a bit more complex. <kbd class="calibre11">(..)</kbd> means any arguments, <kbd class="calibre11">()</kbd> means no arguments, and <kbd class="calibre11">(*)</kbd> means exactly one argument of any type. The last one can also be used when there are more arguments; for example, <kbd class="calibre11">(*,Integer)</kbd> means that there are two arguments, the second being an <kbd class="calibre11">Integer</kbd>, and we just do not care what the type of the first one is.</p>
<p class="calibre2">Pointcut expressions can be more complex, joining together match expressions with the <kbd class="calibre11">&amp;&amp;</kbd> (and) and <kbd class="calibre11">||</kbd> (or) logical operators, or using the <kbd class="calibre11">!</kbd> (negation) unary operator.</p>
<p class="calibre2">Using the <kbd class="calibre11">@Pointcut()</kbd> annotation, the configuration can define pointcuts putting the annotations on methods. For example, consider the following:</p>
<pre class="calibre20">
@Pointcut("execution(* packt.java.9.by.example.service.*.*(..))")  <br class="title-page-name"/>public void businessService() {}
</pre>
<p class="calibre2">It will define a join point for any method that is implemented in any class in the <kbd class="calibre11">packt.java.9.by.example.service</kbd> package. This merely defines the pointcut expression and assigns it to the name <kbd class="calibre11">businessService</kbd>, which is given by the name of the method. Later, we can refer to this expression in aspect annotations, for example:</p>
<pre class="calibre20">
@After("businessService()")
</pre>
<p class="calibre2">Note that the use of the method is purely for its name. This method is not invoked by Spring. It is only used to borrow its name to the expression that is defined on it using the <kbd class="calibre11">@Pointcut</kbd> annotation. There is a need for something, such as a method, to put this annotation on, and since methods have names, why not use it: Spring does it. When it scans the configuration classes and sees the annotation, it assigns it in its internal structures to the name of the method, and when that name (along with the parenthesis, to confuse the novice programmer mimicking a method call) is used, it looks up the expression for that name.</p>
<p class="calibre2">AspectJ defines other designators. Spring AOP recognizes some of them, but it throws <kbd class="calibre11">IllegalArgumentException</kbd> because Spring implements only method execution pointcuts. AspectJ, on the other hand, can also intercept object creation for which the PCD is initialization, as an example. Some other PCDs, in addition to execution, can limit an execution PCD. For example, the PCD, <kbd class="calibre11">within</kbd>, can be used to limit the aspect to join points belonging to classes within certain packages, or the <kbd class="calibre11">@target</kbd> PCD can be used to limit the matching to methods in objects that have the annotation given between <kbd class="calibre11">(</kbd> and <kbd class="calibre11">)</kbd> after the keyword <kbd class="calibre11">@target</kbd> in the pointcut expression.</p>
<p class="calibre2">There is a PCD that Spring uses that does not exist in AspectJ. This is a bean. You can define a pointcut expression that contains <kbd class="calibre11">bean(name pattern)</kbd> to limit the join point to method executions that are in the named bean. The pattern can be the entire name or it can be, as almost any PCD expression matching, <kbd class="calibre11">*</kbd> as a joker character.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Dynamic proxy-based AOP</h1>
            

            <article>
                
<p class="calibre2">Spring AOP, when first presented to Java programmers, seems like magic. How does it happen that we have a variable of <kbd class="calibre11">class</kbd><kbd class="calibre11">X</kbd> and we call some method on that object, but instead, it executes some aspect before or after the method execution, or even around it, intercepting the call</p>
<p class="calibre2">The technique that Spring does is called dynamic proxy. When we have an object, which implements an interface, we can create another object—the proxy object—that also implements that interface, but each and every method implementation invokes a different object called handler, implementing the JDK interface, <kbd class="calibre11">InvocationHandler</kbd>. When a method of the interface is invoked on the proxy object, it will call the following method on the handler object:</p>
<pre class="calibre20">
public Object invoke(Object target, Method m, Object[] args)
</pre>
<p class="calibre2">This method is free to do anything, even calling the original method on the target object with the original or modified argument.</p>
<div class="packtfigure"><img class="image-border42" src="../images/00059.jpeg"/></div>
<p class="calibre2">When we do not have an interface at hand that the class to be proxied implements, we cannot use JDK methods. Luckily, there are widely used libraries, such as <kbd class="calibre11">cglib</kbd>, which are also used by Spring and that can do something similar. <kbd class="calibre11">Cglib</kbd> can create a proxy object that extends the original class and implements its methods, invoking the handler object's invoke method in a way similar to how the JDK version does for the interface methods.</p>
<div class="packttip">These technologies create and load classes into the Java memory during runtime, and they are very deep technical tools. They are advanced topics. I do not say not to play with them while being a novice Java programmer. After all, what can happen? Java is not a loaded gun. It is, however, important that you do not lose your interest when you do not understand some of the details or something does not work first. Or second. Or third... Keep swimming.</div>
<p class="calibre2">AOP implementation in Spring works by generating proxy objects for the target objects, and the handlers invoke the aspects that we define in the Spring configuration. This is the reason you cannot put aspects on <kbd class="calibre11">final</kbd> classes or on <kbd class="calibre11">final</kbd> methods. Also, you cannot configure aspects on <kbd class="calibre11">private</kbd> or <kbd class="calibre11">protected</kbd> methods. The <kbd class="calibre11">protected</kbd> methods could be proxied in principle, but this is not a good practice, and thus Spring AOP does not support it. Similarly, you cannot put aspects on classes that are not Spring beans. They are created by the code directly and not through Spring and have no chance to return a proxy instead of the original object when the object is created. Simply put, if Spring is not asked to create the object, it cannot create a custom one. The last thing we want to do is to execute the program and see how the aspects perform. The implementation of our audit logging is extremely simple. We use the standard logging, which is not really sufficient for a real-life application of audit logging. The only special thing we do is that we use a logger identified by the name, <kbd class="calibre11">AUDIT_LOG</kbd> and not by the name of a class. This is a legitimate use of the loggers in most of the logging frameworks. In spite of the fact that we usually use the class to identify the logger, it is absolutely possible to use a string to identify a logger. In the case of our logging, this string will also be printed on the console in the log lines, and it will visually stand out.</p>
<p class="calibre2">Consider the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">gradle -Dspring.profiles.active=production bootRun</strong>
</pre>
<p class="calibre2">If we again start the application with the preceding command, start soapUI for the project, start the mock services, and execute the test, we will see on the console the following log lines that the aspects print:</p>
<pre class="calibre20">
    <strong class="calibre1">2016-11-10 19:14:09.559  INFO 74643 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.567  INFO 74643 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.626  INFO 74643 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 59 ms</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.629  INFO 74643 --- [nio-8080-exec-1] p.j.b.e.m.p.auth.AuthFilter              : Partner secret is packt</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.655  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : byId query is about to run</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.666  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url is to be created</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.691  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url created was http://localhost:8083/inventory/{id}</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.715  INFO 74643 --- [nio-8080-exec-1] p.j.b.e.m.p.l.RestClientProductLookup    : amount {id: 123, amount: 100}.</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.716  INFO 74643 --- [nio-8080-exec-1] p.j.b.e.m.p.l.RestClientProductLookup    : There items from 123. We are offering</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.716  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url is to be created</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.716  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url created was http://localhost:8081/product/{id}</strong><br class="title-page-name"/><strong class="calibre1">2016-11-10 19:14:09.725  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : byId query was executed</strong>
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we built a simple business application that supports business-to-business transactions. We implemented a REST service in a microservices (almost) architecture using the features that are provided by the de facto standard enterprise framework: Spring. Looking back at the chapter, it is amazing how few lines of code we wrote to achieve all the functionality, and that is good. The less code we need to develop what we want, the better. This proves the power of the framework.</p>
<p class="calibre2">We discussed microservices, HTTP, REST, JSON, and how to use them using the MVC design pattern. We learned how Spring is built up, what modules are there, how dependency injection works in Spring, and we even touched a bit of AOP. This was very important because along with AOP, we discovered how Spring works using dynamic proxy objects, and this is something that is very valuable when you need to debug Spring or some other framework that uses a similar solution (and there are a few frequently used).</p>
<p class="calibre2">We started to test our code using a simple browser, but after that we realized that REST services are better tested using some professional testing tool, and for that we used soapUI and built up a simple REST test suite with REST test steps and mock services.</p>
<p class="calibre2">Having learnt all that, nothing will stop us from extending this application using very modern and advanced Java technologies, such as reflection (which we have already touched on a bit when we discussed the JDK dynamic proxy), Java streams, lambda expressions, and scripting on the server side.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>