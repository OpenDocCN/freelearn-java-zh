- en: Part 3. Module 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分第3模块
- en: '**Mastering Clojure**'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**精通Clojure**'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Understand the philosophy of the Clojure language and dive into its inner
    workings to unlock its advanced features, methodologies, and constructs*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*理解Clojure语言的哲学，深入其内部工作原理，以解锁其高级功能、方法和结构*'
- en: Chapter 1. Working with Sequences and Patterns
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：处理序列和模式
- en: 'In this chapter, we''ll revisit a few basic programming techniques, such as
    recursion and sequences, with Clojure. As we will see, Clojure focuses on the
    use of higher-order functions to abstract computation, like any other functional
    programming language. This design can be observed in most, if not all, of the
    Clojure standard library. In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些基本的编程技术，例如递归和序列，使用Clojure。正如我们将看到的，Clojure侧重于使用高阶函数来抽象计算，就像任何其他函数式编程语言一样。这种设计可以在Clojure标准库的大部分甚至所有部分中观察到。在本章中，我们将涵盖以下主题：
- en: Exploring recursion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索递归
- en: Learning about sequences and laziness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解序列和惰性
- en: Examining zippers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查zippers
- en: Briefly studying pattern matching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要研究模式匹配
- en: Defining recursive functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义递归函数
- en: '**Recursion** is one of the central methodologies of computer science. It allows
    us to elegantly solve problems that have cumbersome non-recursive solutions. Yet,
    recursive functions are discouraged in quite a few imperative programming languages
    in favor of non-recursive functions. Clojure does no such thing and completely
    embraces recursion along with all its pros and cons. In this section, we will
    explore how to define recursive functions.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归**是计算机科学的核心方法之一。它使我们能够优雅地解决那些具有繁琐的非递归解决方案的问题。然而，在许多命令式编程语言中，递归函数是不被鼓励的，而是倾向于使用非递归函数。Clojure并没有这样做，而是完全拥抱递归及其所有优缺点。在本节中，我们将探讨如何定义递归函数。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c1/recur.clj` of the book's
    source code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c1/recur.clj`中找到。
- en: 'In general, a function can be made recursive by simply calling it again from
    within the body of the function. We can define a simple function to return the
    first `n` numbers of the Fibonacci sequence as shown in *Example 1.1*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个函数可以通过在函数体内再次调用自身来使其成为递归函数。我们可以定义一个简单的函数来返回斐波那契数列的前`n`个数字，如*示例1.1*所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Example 1.1: A simple recursive function*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.1：一个简单的递归函数*'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Fibonacci sequence is a series of numbers that can be defined as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列是一系列可以定义为以下形式的数字：
- en: The first element *F[0]* is `0` and the second element *F[1]* is `1`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素*F[0]*是`0`，第二个元素*F[1]*是`1`。
- en: The rest of the numbers are the sum of the previous two numbers, that is the
    nth Fibonacci number *F[n] = F[n-1] + F[n-2]*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的数字是前两个数字的和，即第n个斐波那契数*F[n] = F[n-1] + F[n-2]*。
- en: 'In the previously defined `fibo` function, the last two elements of the list
    are determined using the `nth` and `last` functions, and the sum of these two
    elements is appended to the list using the `conj` function. This is done in a
    recursive manner, and the function terminates when the length of the list, determined
    by the `count` function becomes equal to the supplied value `n`. Also, the values
    `0N` and `1N`, which represent `BigInteger` types, are used instead of the values
    `0` and `1`.This is done because using long or integer values for such a computation
    could result in an arithmetic overflow error. We can try out this function in
    the REPL shown as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前定义的`fibo`函数中，列表的最后两个元素是通过使用`nth`和`last`函数确定的，然后使用`conj`函数将这两个元素的和附加到列表中。这是以递归方式完成的，当由`count`函数确定的列表长度等于提供的值`n`时，函数终止。此外，使用代表`BigInteger`类型的值`0N`和`1N`代替值`0`和`1`。这样做是因为使用长整型或整型值进行此类计算可能会导致算术溢出错误。我们可以在以下REPL中尝试这个函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `fibo` function returns a vector of the first `n` Fibonacci numbers as
    expected. However, for larger values of `n`, this function will cause a stack
    overflow:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibo`函数返回一个包含前`n`个斐波那契数的向量，正如预期的那样。然而，对于较大的`n`值，此函数将导致栈溢出：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason for this error is that there were too many nested function calls.
    A call to any function requires an additional call stack. With recursion, we reach
    a point where all of the available stack space in a program is consumed and no
    more function calls can be performed. A *tail call* can overcome this limitation
    by using the existing call stack for a recursive call, which removes the need
    for allocating a new call stack. This is only possible when the return value of
    a function is the return value of a recursive call made by the function, in which
    case an additional call stack is not required to store the state of the function
    that performs the recursive call. This technique is termed as *tail call elimination*.
    In effect, a tail call optimized function consumes a constant amount of stack
    space.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误的原因是函数调用嵌套太多。对任何函数的调用都需要额外的调用栈。在递归中，我们会达到一个点，此时程序中所有可用的栈空间都被消耗，不能再执行更多的函数调用。通过使用现有的调用栈进行递归调用，*尾调用*可以克服这一限制，从而不需要分配新的调用栈。这只有在函数的返回值是函数执行的递归调用的返回值时才可能，在这种情况下，不需要额外的调用栈来存储执行递归调用的函数的状态。这种技术被称为*尾调用消除*。实际上，尾调用优化的函数消耗的栈空间是恒定的。
- en: 'In fact, the `fibo` function does indeed make a tail call, as the last expression
    in the body of the function is a recursive call. Still, it consumes stack space
    for each recursive call. This is due to the fact that the underlying virtual machine,
    the JVM, does not perform tail call elimination. In Clojure, tail call elimination
    has to be done explicitly using a `recur` form to perform a recursive call. The
    `fibo` function we defined earlier can be refined to be *tail recursive* by using
    a `recur` form, as shown in *Example 1.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`fibo`函数确实执行了尾调用，因为函数体中的最后一个表达式是一个递归调用。尽管如此，它仍然为每个递归调用消耗栈空间。这是因为底层虚拟机，即JVM，不执行尾调用消除。在Clojure中，必须显式地使用`recur`形式来执行递归调用以进行尾调用消除。我们之前定义的`fibo`函数可以通过使用`recur`形式来改进，使其成为*尾递归*，如*示例
    1.2*所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Effectively, the `fibo-recur` function can perform an infinite number of nested
    recursive calls. We can observe that this function does not blow up the stack
    for large values of `n`, shown as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`fibo-recur`函数可以执行无限次的嵌套递归调用。我们可以观察到，对于大的`n`值，该函数不会使栈爆炸，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should note that a call to `fibo-recur` can take quite a while to terminate
    for large values of `n`. We can measure the time taken for a call to `fibo-recur`
    to complete and return a value, using the `time` macro, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，对于大的`n`值，`fibo-recur`的调用可能需要相当长的时间才能终止。我们可以使用`time`宏来测量`fibo-recur`调用完成并返回值所需的时间，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `fibo-recur` function can also be expressed using the `loop` and `recur`
    forms. This eliminates the need for using a second function arity to pass the
    `[0N 1N]` value around, as shown in the `fibo-loop` function defined in *Example
    1.3*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibo-recur`函数也可以使用`loop`和`recur`形式来表示。这消除了使用第二个函数参数传递`[0N 1N]`值的需求，如*示例 1.3*中定义的`fibo-loop`函数所示：'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Example 1.3: A recursive function defined using loop and recur*'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 1.3：使用循环和递归定义的递归函数*'
- en: 'Note that the `loop` macro requires a vector of bindings (pairs of names and
    values) to be passed as its first argument. The second argument to the `loop`
    form must be an expression that uses the `recur` form. This nested `recur` form
    calls the surrounding expression recursively by passing in the new values for
    the declared bindings in the `loop` form. The `fibo-loop` function returns a value
    that is equal to that returned by the `fibo-recur` function, from *Example 1.2*,
    shown as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`loop`宏需要将绑定（名称和值的对）的向量作为其第一个参数传递。`loop`形式的第二个参数必须是一个使用`recur`形式的表达式。这个嵌套的`recur`形式通过在`loop`形式中传递声明的绑定的新值来递归地调用周围的表达式。`fibo-loop`函数返回的值与*示例
    1.2*中`fibo-recur`函数返回的值相等，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another way to handle recursion is by using the `trampoline` function. The
    `trampoline` function takes a function as its first argument, followed by the
    values of the parameters to be passed to the supplied function. A `trampoline`
    form expects the supplied function to return another function, and in such a case,
    the returned function will be invoked. Thus, a `trampoline` form manages recursion
    by obtaining a return value, and invoking the returned value again if it''s a
    function. Thus, the `trampoline` function avoids using any stack space. Each time
    the supplied function is invoked, it returns and the result gets stored in the
    process heap. For example, consider the function in *Example 1.4* that calculates
    the first `n` numbers of the Fibonacci sequence using a `trampoline`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 处理递归的另一种方式是使用`trampoline`函数。`trampoline`函数将其第一个参数作为函数，然后是传递给该函数的参数值。`trampoline`形式期望提供的函数返回另一个函数，在这种情况下，将调用返回的函数。因此，`trampoline`形式通过获取返回值并再次调用该返回值（如果它是一个函数）来管理递归。因此，`trampoline`函数避免了使用任何栈空间。每次调用提供的函数时，它都会返回并将结果存储在进程堆中。例如，考虑*示例1.4*中的函数，该函数使用`trampoline`计算斐波那契数列的前`n`个数字：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Example 1.4: A recursive function defined using trampoline*'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.4：使用trampoline定义的递归函数*'
- en: 'In the `fib-trampoline` function, the internal `fibo-fn` function returns either
    a sequence, denoted by `xs`, or a closure that takes no arguments, represented
    by `#(fibo-fn xs'' n)`. This function is equivalent to the `fibo-recur` function
    we defined earlier, even in terms of performance, shown as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fib-trampoline`函数中，内部`fibo-fn`函数返回一个序列，表示为`xs`，或者一个不接受任何参数的闭包，表示为`#(fibo-fn
    xs' n)`。这个函数在性能上等同于我们之前定义的`fibo-recur`函数，如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Mutual recursion* can also be handled effectively using a trampoline. In mutual
    recursion, two functions call each other in a recursive manner. For example, consider
    the function that utilizes two mutually recursive functions in *Example 1.5*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*相互递归*也可以通过使用`trampoline`函数有效地处理。在相互递归中，两个函数以递归方式相互调用。例如，考虑在*示例1.5*中利用两个相互递归函数的函数：'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Example 1.5: A simple function that uses mutual recursion*'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.5：使用相互递归的简单函数*'
- en: 'The `sqrt-div2-recur` function from *Example 1.5* defines two mutually recursive
    functions internally, namely `sqrt` and `div2`, that repeatedly square root and
    halve a given value `n` until the calculated value is less than 1\. The `sqrt-div2-recur`
    function declares these two functions using a `letfn` form and invokes the `sqrt`
    function. We can convert this to use a `trampoline` form as shown in *Example
    1.6*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例1.5*中的`sqrt-div2-recur`函数在内部定义了两个相互递归的函数，即`sqrt`和`div2`，这两个函数会重复平方根和除以2给定的值`n`，直到计算出的值小于1。`sqrt-div2-recur`函数使用`letfn`形式声明这两个函数并调用`sqrt`函数。我们可以将其转换为使用*示例1.6*中所示的`trampoline`形式：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Example 1.6: A function that uses mutual recursion using trampoline*'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.6：使用trampoline进行相互递归的函数*'
- en: 'In the previous `sqrt-div2-trampoline` function shown, the functions `sqrt`
    and `div2` return closures instead of calling a function directly. The `trampoline`
    form in the body of the function calls the `sqrt` function while supplying the
    value `n`. Both the `sqrt-div2-recur` and `sqrt-div2-trampoline` functions take
    about the same time to return a value for the given value of `n`. Hence, using
    a `trampoline` form does not have any additional performance overhead, shown as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前显示的`sqrt-div2-trampoline`函数中，函数`sqrt`和`div2`返回闭包而不是直接调用函数。函数体内的`trampoline`形式在提供值`n`的情况下调用`sqrt`函数。`sqrt-div2-recur`和`sqrt-div2-trampoline`函数在给定`n`的值时返回值所需的时间大致相同。因此，使用`trampoline`形式不会产生任何额外的性能开销，如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As the preceding examples demonstrate, there are various ways to define recursive
    functions in Clojure. Recursive functions can be optimized using tail call elimination,
    by using `recur`, and mutual recursion, which is done using the `trampoline` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述示例所示，在Clojure中定义递归函数有多种方式。递归函数可以通过使用`recur`、尾调用消除以及相互递归（通过使用`trampoline`函数实现）进行优化。
- en: Thinking in sequences
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考序列
- en: A **sequence**, shortened as a **seq**, is essentially an abstraction of a list.
    This abstraction provides a unified model or interface to interact with a collection
    of items. In Clojure, all the primitive data structures, namely strings, lists,
    vectors, maps, and sets can be treated as sequences. In practice, almost everything
    that involves iteration can be translated into a sequence of computations. A collection
    is termed as **seqable** if it implements the abstraction of a sequence. We will
    learn everything there is to know about sequences in this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列**，简称为**seq**，本质上是对列表的抽象。这种抽象提供了一个统一的模型或接口，用于与一系列项目进行交互。在Clojure中，所有原始数据结构，即字符串、列表、向量、映射和集合，都可以被视为序列。在实践中，几乎所有涉及迭代的操作都可以转换为计算序列。如果一个集合实现了序列的抽象，则该集合被称为**seqable**。在本节中，我们将学习有关序列的所有知识。'
- en: Sequences can also be *lazy*. A lazy sequence can be thought of as a possibly
    infinite series of computed values. The computation of each value is deferred
    until it is actually needed. We should note that the computation of a recursive
    function can easily be represented as a lazy sequence. For example, the Fibonacci
    sequence can be computed by lazily adding the last two elements in the previously
    computed sequence. This can be implemented as shown in *Example 1.7*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 序列也可以是惰性的。一个惰性序列可以被视为一系列可能无限的计算值。每个值的计算被推迟到实际需要时。我们应该注意，递归函数的计算可以很容易地表示为惰性序列。例如，斐波那契序列可以通过惰性地添加先前计算序列中的最后两个元素来计算。这可以像*示例1.7*中所示的那样实现。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c1/seq.clj` of the book's
    source code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c1/seq.clj`中找到。
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Example 1.7: A lazy Fibonacci sequence*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.7: 惰性斐波那契序列*'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The threading macro `->>` is used to pass the result of a given expression as
    the last argument to the next expression, in a repetitive manner for all expressions
    in its body. Similarly, the threading macro `->` is used to pass the result of
    a given expression as the first argument to the subsequent expressions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 线程宏`->>`用于将给定表达式的结果作为下一个表达式的最后一个参数传递，以重复的方式对其主体中的所有表达式进行传递。同样，线程宏`->`用于将给定表达式的结果作为后续表达式的第一个参数传递。
- en: The `fibo-lazy` function from *Example 1.7* uses the `iterate`, `map`, and `take`
    functions to create a lazy sequence. We will study these functions in more detail
    later in this section. The `fibo-lazy` function takes a single argument `n`, which
    indicates the number of items to be returned by the function. In the `fibo-lazy`
    function, the values `0N` and `1N` are passed as a vector to the `iterate` function,
    which produces a lazy sequence. The function used for this iteration creates a
    new pair of values `b` and `(+ a b)` from the initial values `a` and `b`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例1.7*中的`fibo-lazy`函数使用`iterate`、`map`和`take`函数来创建一个惰性序列。我们将在本节的后面部分更详细地研究这些函数。`fibo-lazy`函数接受一个参数`n`，该参数表示函数返回的项目数量。在`fibo-lazy`函数中，值`0N`和`1N`被作为向量传递给`iterate`函数，该函数生成一个惰性序列。用于此迭代的函数从初始值`a`和`b`创建一个新的值对`b`和`(+
    a b)`。'
- en: 'Next, the `map` function applies the `first` function to obtain the first element
    in each resulting vector. A `take` form is finally applied to the sequence returned
    by the `map` function to retrieve the first `n` values in the sequence. The `fibo-lazy`
    function does not cause any error even when passed relatively large values of
    `n`, shown as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`map`函数应用`first`函数以获取每个结果向量的第一个元素。最后，对`map`函数返回的序列应用`take`形式，以检索序列中的前`n`个值。即使传递相对较大的`n`值，`fibo-lazy`函数也不会引起任何错误，如下所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Interestingly, the `fibo-lazy` function in *Example 1.7* performs significantly
    better than the recursive functions from *Example 1.2* and *Example 1.3*, as shown
    here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，*示例1.7*中的`fibo-lazy`函数在性能上显著优于*示例1.2*和*示例1.3*中的递归函数，如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, binding the value returned by the `fibo-lazy` function to a variable
    does not really consume any time. This is because this returned value is lazy
    and not evaluated yet. Also, the type of the return value is `clojure.lang.LazySeq`,
    as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将`fibo-lazy`函数返回的值绑定到变量实际上并不消耗任何时间。这是因为这个返回值是惰性的，尚未被评估。此外，返回值的类型是`clojure.lang.LazySeq`，如下所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can optimize the `fibo-lazy` function even further by using **memoization**,
    which essentially caches the value returned by a function for a given set of inputs.
    This can be done using the `memoize` function, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用**记忆化**来进一步优化`fibo-lazy`函数，这本质上是为给定的一组输入缓存函数返回的值。这可以通过使用`memoize`函数来完成，如下所示：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `fibo-mem` function is a memoized version of the `fibo-lazy` function.
    Hence, subsequent calls to the `fibo-mem` function for the same set of inputs
    will return values significantly faster, shown as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibo-mem`函数是`fibo-lazy`函数的记忆化版本。因此，对于相同的一组输入，对`fibo-mem`函数的后续调用将返回值更快，如下所示：'
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the `memoize` function can be applied to any function, and it is not
    really related to sequences. The function we pass to `memoize` must be free of
    side effects, or else any side effects will be invoked only the first time the
    memoized function is called with a given set of inputs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`memoize`函数可以应用于任何函数，并且实际上与序列无关。传递给`memoize`的函数必须没有副作用，否则任何副作用都只会在使用给定一组输入调用记忆化函数时触发。
- en: Using the seq library
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用seq库
- en: 'Sequences are a truly ubiquitous abstraction in Clojure. The primary motivation
    behind using sequences is that any domain with sequence-like data in it can be
    easily modelled using the standard functions that operate on sequences. This infamous
    quote from the Lisp world reflects on this design:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 序列在Clojure中是一种真正无处不在的抽象。使用序列的主要动机是，任何包含类似序列数据的领域都可以通过操作序列的标准函数轻松建模。以下来自Lisp世界的著名引言反映了这种设计：
- en: '*"It is better to have 100 functions operate on one data abstraction than 10
    functions on 10 data structures."*'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"与其有10个函数操作10个数据结构，不如有100个函数操作一个数据抽象。"*'
- en: 'A sequence can be constructed using the `cons` function. We must provide an
    element and another sequence as arguments to the `cons` function. The `first`
    function is used to access the first element in a sequence, and similarly the
    `rest` function is used to obtain the other elements in the sequence, shown as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`cons`函数构建一个序列。我们必须向`cons`函数提供元素和另一个序列作为参数。`first`函数用于访问序列中的第一个元素，同样地，`rest`函数用于获取序列中的其他元素，如下所示：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `first` and `rest` functions in Clojure are equivalent to the `car` and
    `cdr` functions, respectively, from traditional Lisps. The `cons` function carries
    on its traditional name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中的`first`和`rest`函数分别等同于传统Lisp中的`car`和`cdr`函数，`cons`函数保留了其传统名称。
- en: 'In Clojure, an empty list is represented by the literal `()`. An empty list
    is considered as a *truthy* value, anddoes not equate to `nil`. This rule is true
    for any empty collection. An empty list does indeed have a type – it''s a list.
    On the other hand, the `nil` literal signifies the absence of a value, of any
    type, and is not a truthy value. The second argument that is passed to `cons`
    could be empty, in which case the resulting sequence would contain a single element:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，空列表由字面量`()`表示。空列表被视为*真值*，并且不等于`nil`。这条规则适用于任何空集合。空列表确实有类型——它是一个列表。另一方面，`nil`字面量表示任何类型的值的缺失，并且不是一个真值。传递给`cons`的第二个参数可以是空的，在这种情况下，生成的序列将包含单个元素：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An interesting quirk is that `nil` can be treated as an empty collection, but
    the converse is not true. We can use the `empty?` and `nil?` functions to test
    for an empty collection and a `nil` value, respectively. Note that `(empty? nil)`
    returns `true`, shown as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的特性是`nil`可以被当作一个空集合处理，但反过来则不成立。我们可以使用`empty?`和`nil?`函数分别测试空集合和`nil`值。注意`(empty?
    nil)`返回`true`，如下所示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By the *truthy* value, we mean to say a value that will test positive in a conditional
    expression such as an `if` or a `when` form.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*真值*，我们指的是在条件表达式（如`if`或`when`形式）中测试为正的值。
- en: 'The `rest` function will return an empty list when supplied an empty list.
    Thus, the value returned by `rest` is always truthy. The `seq` function can be
    used to obtain a sequence from a given collection. It will return `nil` for an
    empty list or collection. Hence, the `head`, `rest` and `seq` functions can be
    used to iterate over a sequence. The `next` function can also be used for iteration,
    and the expression `(seq (rest coll))` is equivalent to `(next coll)`, shown as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当向 `rest` 函数提供一个空列表时，它将返回一个空列表。因此，`rest` 函数返回的值始终为真值。`seq` 函数可以用来从一个给定的集合中获取序列。对于空列表或集合，它将返回
    `nil`。因此，`head`、`rest` 和 `seq` 函数可以用来遍历序列。`next` 函数也可以用来进行迭代，表达式 `(seq (rest coll))`
    等价于 `(next coll)`，如下所示：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `sequence` function can be used to create a list from a sequence. For example,
    `nil` can be converted into an empty list using the expression `(sequence nil)`.
    In Clojure, the `seq?` function is used to check whether a value implements the
    sequence interface, namely `clojure.lang.ISeq`. Only lists implement this interface,
    and other data structures such as vectors, sets, and maps have to be converted
    into a sequence by using the `seq` function. Hence, `seq?` will return `true`
    only for lists. Note that the `list?`, `vector?`, `map?`, and `set?` functions
    can be used to check the concrete type of a given collection. The behavior of
    the `seq?` function with lists and vectors can be described as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequence` 函数可以用来从一个序列创建一个列表。例如，可以使用表达式 `(sequence nil)` 将 `nil` 转换为空列表。在 Clojure
    中，`seq?` 函数用来检查一个值是否实现了序列接口，即 `clojure.lang.ISeq`。只有列表实现了这个接口，而其他数据结构如向量、集合和映射必须通过使用
    `seq` 函数转换为序列。因此，`seq?` 只在列表上返回 `true`。请注意，`list?`、`vector?`、`map?` 和 `set?` 函数可以用来检查给定集合的具体类型。`seq?`
    函数在列表和向量上的行为可以描述如下：'
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Only lists and vectors provide a guarantee of sequential ordering among elements.
    In other words, lists and vectors will store their elements in the same order
    or sequence as they were created. This is in contrast to maps and sets, which
    can reorder their elements as needed. We can use the `sequential?` function to
    check whether a collection provides sequential ordering:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只有列表和向量提供元素之间的顺序保证。换句话说，列表和向量将按照它们创建的顺序或序列存储它们的元素。这与映射和集合形成对比，映射和集合可以根据需要重新排序它们的元素。我们可以使用
    `sequential?` 函数来检查一个集合是否提供顺序：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `associative?` function can be used to determine whether a collection or
    sequence associates a key with a particular value. Note that this function returns
    `true` only for maps and vectors:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`associative?` 函数可以用来确定一个集合或序列是否将一个键与特定的值关联起来。请注意，此函数仅在映射和向量上返回 `true`：'
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The behavior of the `associative?` function is fairly obvious for a map since
    a map is essentially a collection of key-value pairs. The fact that a vector is
    also associative is well justified too, as a vector has an implicit key for a
    given element, namely the index of the element in the vector. For example, the
    `[:a :b]` vector has two implicit keys, `0` and `1`, for the elements `:a` and
    `:b` respectively. This brings us to an interesting consequence – vectors and
    maps can be treated as functions that take a single argument, that is a key, and
    return an associated value, shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射来说，`associative?` 函数的行为相当明显，因为映射本质上是一系列键值对。同样，向量也是关联的，这一点也得到了很好的证明，因为向量对于给定元素有一个隐含的键，即元素在向量中的索引。例如，`[:a
    :b]` 向量有两个隐含的键，分别是 `0` 和 `1`，分别对应元素 `:a` 和 `:b`。这引出了一个有趣的后果——向量与映射可以被当作接受单个参数（即键）并返回相关值的函数，如下所示：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although they are not associative by nature, sets are also functions. Sets
    return a value contained in them, or `nil`, depending on the argument passed to
    them, shown as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们本质上不是关联的，但集合也是函数。集合根据传递给它们的参数返回集合中包含的值或 `nil`，如下所示：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that we have familiarized ourselves with the basics of sequences, let's
    have a look at the many functions that operate over sequences.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了序列的基础知识，让我们来看看操作序列的许多函数。
- en: Creating sequences
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建序列
- en: 'There are several ways to create sequences other than using the `cons` function.
    We have already encountered the `conj` function in the earlier examples of this
    chapter. The `conj` function takes a collection as its first argument, followed
    by any number of arguments to add to the collection. We must note that `conj`
    behaves differently for lists and vectors. When supplied a list, the `conj` function
    adds the other arguments at the head, or start, of the list. In case of a vector,
    the `conj` function will insert the other arguments at the tail, or end, of the
    vector:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `cons` 函数之外，还有几种创建序列的方法。我们在本章前面的例子中已经遇到了 `conj` 函数。`conj` 函数将其第一个参数作为集合，然后是任何要添加到集合中的参数。我们必须注意，`conj`
    对于列表和向量有不同的行为。当提供一个列表时，`conj` 函数将其他参数添加到列表的头部或开始处。在向量的情况下，`conj` 函数将其他参数插入到向量的尾部或结束处：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `concat` function can be used to join or *concatenate* any number of sequences
    in the order in which they are supplied, shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 函数可以用来按提供的顺序连接或 *连接* 任意数量的序列，如下所示：'
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A given sequence can be reversed using the `reverse` function, shown as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `reverse` 函数来反转给定的序列，如下所示：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `range` function can be used to generate a sequence of values within a
    given integer range. The most general form of the `range` function takes three
    arguments—the first argument is the start of the range, the second argument is
    the end of the range, and the third argument is the step of the range. The step
    of the range defaults to `1`, and the start of the range defaults to `0`, as shown
    here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数可以用来生成给定整数范围内的值序列。`range` 函数最一般的形式接受三个参数——第一个参数是范围的开始，第二个参数是范围的结束，第三个参数是范围的步长。范围的步长默认为
    `1`，范围的开始默认为 `0`，如下所示：'
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We must note that the `range` function expects the start of the range to be
    less than the end of the range. If the start of the range is greater than the
    end of the range and the step of the range is positive, the `range` function will
    return an empty list. For example, `(range 15 10)` will return `()`. Also, the
    `range` function can be called with no arguments, in which case it returns a lazy
    and infinite sequence starting at `0`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，`range` 函数期望范围的开始小于范围的结束。如果范围的开始大于范围的结束，并且范围的步长是正数，`range` 函数将返回一个空列表。例如，`(range
    15 10)` 将返回 `()`。此外，`range` 函数可以不带参数调用，在这种情况下，它返回一个从 `0` 开始的懒加载和无限序列。
- en: 'The `take` and `drop` functions can be used to take or drop elements in a sequence.
    Both functions take two arguments, representing the number of elements to take
    or drop from a sequence, and the sequence itself, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`take` 和 `drop` 函数可以用来在序列中取或丢弃元素。这两个函数都接受两个参数，表示从序列中取或丢弃的元素数量，以及序列本身，如下所示：'
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To obtain an item at a particular position in the sequence, we should use the
    `nth` function. This function takes a sequence as its first argument, followed
    by the position of the item to be retrieved from the sequence as the second argument:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取序列中特定位置的项，我们应该使用 `nth` 函数。这个函数将其第一个参数作为序列，然后是第二个参数，即从序列中检索项的位置：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To repeat a given value, we can use the `repeat` function. This function takes
    two arguments and repeats the second argument the number of times indicated by
    the first argument:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要重复一个给定的值，我们可以使用 `repeat` 函数。这个函数接受两个参数，并按照第一个参数指示的次数重复第二个参数：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `repeat` function will evaluate the expression of the second argument and
    repeat it. To call a function a number of times, we can use the `repeatedly` function,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat` 函数将评估第二个参数的表达式并重复它。要多次调用一个函数，我们可以使用 `repeatedly` 函数，如下所示：'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, the `repeat` form first evaluates the `(rand-int 100)` form,
    before repeating it. Hence, a single value will be repeated several times. Note
    that the `rand-int` function simply returns a random integer between `0` and the
    supplied value. On the other hand, the `repeatedly` function invokes the supplied
    function a number of times, thus producing a new value every time the `rand-int`
    function is called.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`repeat` 表达式首先评估 `(rand-int 100)` 表达式，然后再重复它。因此，一个值将被重复多次。请注意，`rand-int`
    函数简单地返回一个介于 `0` 和提供的值之间的随机整数。另一方面，`repeatedly` 函数调用提供的函数多次，因此每次调用 `rand-int` 函数时都会产生一个新的值。
- en: 'A sequence can be repeated an infinite number of times using the `cycle` function.
    As you might have guessed, this function returns a lazy sequence to indicate an
    infinite series of values. The `take` function can be used to obtain a limited
    number of values from the resulting infinite sequence, shown as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `interleave` function can be used to combine any number of sequences. This
    function returns a sequence of the first item in each collection, followed by
    the second item, and so on. This combination of the supplied sequences is repeated
    until the shortest sequence is exhausted of values. Hence, we can easily combine
    a finite sequence with an infinite one to produce another finite sequence using
    the `interleave` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another function that performs a similar operation is the `interpose` function.
    The `interpose` function inserts a given element between the adjacent elements
    of a given sequence:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `iterate` function can also be used to create an infinite sequence. Note
    that we have already used the `iterate` function to create a lazy sequence in
    *Example 1.7*. This function takes a function `f` and an initial value `x` as
    its arguments. The value returned by the `iterate` function will have `(f x)`
    as the first element, `(f (f x))` as the second element, and so on. We can use
    the `iterate` function with any other function that takes a single argument, as
    follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Transforming sequences
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are also several functions to convert sequences into different representations
    or values. One of the most versatile of such functions is the `map` function.
    This function *maps* a given function over a given sequence, that is, it applies
    the function to each element in the sequence. Also, the value returned by `map`
    is implicitly lazy. The function to be applied to each element must be the first
    argument to `map`, and the sequence on which the function must be applied is the
    next argument:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that `map` can accept any number of collections or sequences as its arguments.
    In this case, the resulting sequence is obtained by passing the first items of
    the sequences as arguments to the given function, and then passing the second
    items of the sequences to the given function, and so on until any of the supplied
    sequences are exhausted. For example, we can sum the corresponding elements of
    two sequences using the `map` and `+` functions, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `mapv` function has the same semantics of map, but returns a vector instead
    of a sequence, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Another variant of the `map` function is the `map-indexed` function. This function
    expects that the supplied function will accept two arguments—one for the index
    of a given element and another for the actual element in the list:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, the function supplied to `map-indexed` simply returns its arguments
    as a vector. An interesting point that we can observe from the preceding example
    is that a string can be treated as a sequence of characters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapcat` function is a combination of the `map` and `concat` function.
    This function maps a given function over a sequence, and applies the `concat`
    function on the resulting sequence:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we use the `split` function from the `clojure.string` namespace
    to split a string using a regular expression, shown as `#"\d"`. The `split` function
    will return a vector of strings, and hence the `mapcat` function returns a sequence
    of strings instead of a sequence of vectors like the `map` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reduce` function is used to combine or *reduce* a sequence of items into
    a single value. The `reduce` function requires a function as its first argument
    and a sequence as its second argument. The function supplied to `reduce` must
    accept two arguments. The supplied function is first applied to the first two
    elements in the given sequence, and then applied to the previous result and the
    third element in the sequence, and so on until the sequence is exhausted. The
    `reduce` function also has a second arity, which accepts an initial value, and
    in this case, the supplied function is applied to the initial value and the first
    element in the sequence as the first step. The `reduce` function can be considered
    equivalent to loop-based iteration in imperative programming languages. For example,
    we can compute the sum of all elements in a sequence using `reduce`, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, when the `reduce` function is supplied an empty collection,
    it returns `0`, since `(+)` evaluates to `0`. When an initial value of `1` is
    supplied to the `reduce` function, it returns `1`, since `(+ 1)` returns `1`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'A *list comprehension* can be created using the `for` macro. Note that a `for`
    form will be translated into an expression that uses the `map` function. The `for`
    macro needs to be supplied a vector of bindings to any number of collections,
    and an expression in the body. This macro binds the supplied symbol to each element
    in its corresponding collection and evaluates the body for each element. Note
    that the `for` macro also supports a `:let` clause to assign a value to a variable,
    and also a `:when` clause to filter out values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `for` macro can also be used over a number of collections, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `doseq` macro has semantics similar to that of `for`, except for the fact
    that it always returns a `nil` value. This macro simply evaluates the body expression
    for all of the items in the given bindings. This is useful in forcing evaluation
    of an expression with side effects for all the items in a given collection:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As shown in the preceding example, both the first and second `doseq` forms return
    `nil`. However, the second form prints the value of the expression `(* x x)`,
    which is a side effect, for all items in the sequence `(range 3 7)`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The `into` function can be used to easily convert between types of collections.
    This function requires two collections to be supplied to it as arguments, and
    returns the first collection filled with all the items in the second collection.
    For example, we can convert a sequence of vectors into a map, and vice versa,
    using the `into` function, shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We should note that the `into` function is essentially a composition of the
    `reduce` and `conj` functions. As `conj` is used to fill the first collection,
    the value returned by the `into` function will depend on the type of the first
    collection. The `into` function will behave similar to `conj` with respect to
    lists and vectors, shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A sequence can be partitioned into smaller ones using the `partition`, `partition-all`
    and `partition-by` functions. Both the `partition` and `partition-all` functions
    take two arguments—one for the number of items `n` in the partitioned sequences
    and another for the sequence to be partitioned. However, the `partition-all` function
    will also return the items from the sequence, which have not been partitioned
    as a separate sequence, shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `partition` and `partition-all` functions also accept a step argument,
    which defaults to the supplied number of items in the partitioned sequences, shown
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `partition` function also takes a second sequence as an optional argument,
    which is used to pad the sequence to be partitioned in case there are items that
    are not partitioned. This second sequence has to be supplied after the step argument
    to the `partition` function. Note that the padding sequence is only used to create
    a single partition with the items that have not been partitioned, and the rest
    of the padding sequence is discarded. Also, the padding sequence is only used
    if there are any items that have not been partitioned. This can be illustrated
    in the following example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we first provide a padding sequence in the second statement
    as `(range 11 12)`, which only comprises of a single element. In the next statement,
    we supply a larger padding sequence, as `(range 11 15)`, but only the first item
    `11` from the padding sequence is actually used. In the last statement, we also
    supply a padding sequence but it is never used, as the `(range 11)` sequence is
    partitioned into sequences of 3 elements each with a step of `4`, which will have
    no remaining items.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The `partition-by` function requires a higher-order function to be supplied
    to it as the first argument, and will partition items in the supplied sequence
    based on the return value of applying the given function to each element in the
    sequence. The sequence is essentially partitioned by `partition-by` whenever the
    given function returns a new value, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, the second statement partitions the given sequence into sequences
    that each contain a single item as we have used the `identity` function, which
    simply returns its argument. For the `[-2 -1 0 1 2]` sequence, the `identity`
    function returns a new value for each item in the sequence and hence the resulting
    partitioned sequences all have a single element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sort` function can be used to change the ordering of elements in a sequence.
    The general form of this function requires a function to compare items and a sequence
    of items to sort. The supplied function defaults to the `compare` function, whose
    behavior changes depending on the actual type of the items being compared:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we intend to apply a particular function to each item in a sequence before
    performing the comparison in a `sort` form, we should consider using the `sort-by`
    function for a more concise expression. The `sort-by` function also accepts a
    function to perform the actual comparison, similar to the `sort` function. The
    `sort-by` function can be demonstrated as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this example, the first and second statements both compare items after applying
    the `first` function to each item in the given sequence. The last statement passes
    the `>` function to the `sort-by` function, which returns the reverse of the sequence
    returned by the first two statements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Filtering sequences
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sequences can also be *filtered*, that is transformed by removing some elements
    from the sequence. There are several standard functions to perform this task.
    The `keep` function can be used to remove values from a sequence that produces
    a `nil` value for a given function. The `keep` function requires a function and
    a sequence to be passed to it. The `keep` function will apply the given function
    to each item in the sequence and remove all values that produce `nil`, as shown
    here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, the first statement removes all even numbers from the given
    sequence. In the second statement, the `seq` function is used to remove all empty
    collections from the given sequence.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'A map or a set can also be passed as the first argument to the `keep` function
    since they can be treated as functions, as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `filter` function can also be used to remove some elements from a given
    sequence. The `filter` function expects a predicate function to be passed to it
    along with the sequence to be filtered. The items for which the predicate function
    does not return a truthy value are removed from the result. The `filterv` function
    is identical to the filter function, except for the fact that it returns a vector
    instead of a list:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Both the `filter` and `keep` functions have similar semantics. However, the
    primary distinction is that the `filter` function returns a subset of the original
    elements, whereas `keep` returns a sequence of non `nil` values that are returned
    by the function supplied to it, as shown in the following example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that in this example, if we passed the `odd?` function to the `keep` form,
    it would return a list of `true` and `false` values, as these values are returned
    by the `odd?` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, a `for` macro with a `:when` clause is translated into an expression
    that uses the `filter` function, and hence a `for` form can also be used to remove
    elements from a sequence:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A vector can be *sliced* using the `subvec` function. By sliced, we mean to
    say that a smaller vector is selected from the original vector depending on the
    values passed to the `subvec` function. The `subvec` function takes a vector as
    its first argument, followed by the index indicating the start of the sliced vector,
    and finally another optional index that indicates the end of the sliced vector,
    as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Maps can be filtered by their keys using the `select-keys` function. This function
    requires a map as the first argument and a vector of keys as a second argument
    to be passed to it. The vector of keys passed to this function indicates the key-value
    pairs to be included in the resulting map, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another way to select key-value pairs from a map is to use the `find` function,
    as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`take-while` and `drop-while` are analogous to the `take` and `drop` functions,
    and require a predicate to be passed to them, instead of the number of elements
    to take or drop. The `take-while` function takes elements as long as the predicate
    function returns a truthy value, and similarly the `drop-while` function will
    drop elements for the same condition:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Lazy sequences
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`lazy-seq` and `lazy-cat` are the most elementary constructs to create lazy
    sequences. The value returned by these functions will always have the type `clojure.lang.LazySeq`.
    The `lazy-seq` function is used to wrap a lazily computed expression in a `cons`
    form. This means that the rest of the sequence created by the `cons` form is lazily
    computed. For example, the `lazy-seq` function can be used to construct a lazy
    sequence representing the Fibonacci sequence as shown in *Example 1.8*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Example 1.8: A lazy sequence created using lazy-seq*'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `fibo-cons` function requires two initial values, `a` and `b`, to be passed
    to it as the initial values, and returns a lazy sequence comprising the first
    value `a` and a lazily computed expression that uses the next two values in the
    sequence, that is, `b` and `(+ a b)`. In this case, the `cons` form will return
    a lazy sequence, which can be handled using the `take` and `last` functions, as
    shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that the `fibo-cons` function from *Example 1.8* recursively calls itself
    without an explicit `recur` form, and yet it does not consume any stack space.
    This is because the values present in a lazy sequence are not stored in a call
    stack, and all the values are allocated on the process heap.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to define a lazy Fibonacci sequence is by using the `lazy-cat`
    function. This function essentially concatenates all the sequences it is supplied
    in a lazy fashion. For example, consider the definition of the Fibonacci sequence
    in *Example 1.9*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*Example 1.9: A lazy sequence created using lazy-cat*'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `fibo-seq` variable from *Example 1.9* essentially calculates the Fibonacci
    sequence using a lazy composition of the `map`, `rest,` and `+` functions. Also,
    a sequence is required as the initial value, instead of a function as we saw in
    the definition of `fibo-cons` from *Example 1.8*. We can use the `nth` function
    to obtain a number from this sequence as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As shown previously, `fibo-cons` and `fibo-seq` are concise and idiomatic representations
    of the infinite series of numbers in the Fibonacci sequence. Both of these definitions
    return identical values and do not cause an error due to stack consumption.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting fact is that most of the standard functions that return sequences,
    such as `map` and `filter`, are inherently lazy. Any expression that is built
    using these functions is lazy, and hence never evaluated until needed. For example,
    consider the following expression that uses the `map` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this example, the `println` function is not called when we define the `xs`
    variable. However, once we try to print it in the REPL, the sequence is evaluated
    and the numbers are printed out by calling the `println` function. Note that `xs`
    evaluates to `(nil nil nil)` as the `println` function always returns `nil`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is necessary to eagerly evaluate a lazy sequence. The `doall`
    and `dorun` functions are used for this exact purpose. The `doall` function essentially
    forces evaluation of a lazy sequence along with any side effects of the evaluation.
    The value returned by `doall` is a list of all the elements in the given lazy
    sequence. For example, let''s wrap the `map` expression from the previous example
    in a `doall` form, shown as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, the numbers are printed out as soon as `xs` is defined, as we force evaluation
    using the `doall` function. The `dorun` function has similar semantics as the
    `doall` function, but it always returns `nil`. Hence, we can use the `dorun` function
    instead of `doall` when we are only interested in the side effects of evaluating
    the lazy sequence, and not the actual values in it. Another way to call a function
    with some side effects over all values in a collection is by using the `run!`
    function, which must be passed a function to call and a collection. The `run!`
    function always returns `nil`, just like the `dorun` form.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Using zippers
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are well versed with sequences, let's briefly examine **zippers**.
    Zippers are essentially data structures that help in traversing and manipulating
    *trees*. In Clojure, any collection that contains nested collections is termed
    as a tree. A zipper can be thought of as a structure that contains location information
    about a tree. Zippers are not an extension of trees, but rather can be used to
    traverse and realize a tree.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The following examples can be found in `src/m_clj/c1/zippers.clj` of the book's
    source code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a simple tree using vector literals, as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The vector `tree` is a tree, comprised of the nodes `:a`, `[1 2 3]`, `:b`,
    and `:c`. We can use the `vector-zip` function to create a zipper from the vector
    `tree` as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The variable `root` defined previously is a zipper and contains location information
    for traversing the given tree. Note that the `vector-zip` function is simply a
    combination of the standard `seq` function and the `seq-zip` function from the
    `clojure.zip` namespace. Hence, for trees that are represented as sequences, we
    should use the `seq-zip` function instead. Also, all other functions in the `clojure.zip`
    namespace expect their first argument to be a zipper.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'To traverse the zipper, we must use the `clojure.zip/next` function, which
    returns the next node in the zipper. We can easily iterate over all the nodes
    in the zipper using a composition of the `iterate` and `clojure.zip/next` functions,
    as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As shown previously, the first node of the zipper represents the original tree
    itself. Also, the zipper will contain some extra information, other than the value
    contained in the current node, which is useful in navigating across the given
    tree. In fact, the return value of the `next` function is also a zipper. Once
    we have completely traversed the given tree, a zipper pointing to the root of
    the tree will be returned by the `next` function. Note that some information in
    a zipper has been truncated from the preceding REPL output for the sake of readability.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'To navigate to the adjacent nodes in a given zipper, we can use the `down`,
    `up`, `left`, and `right` functions. All of these functions return a zipper, as
    shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `down`, `up`, `left`, and `right` functions change the location of the
    `root` zipper in the `[:a [1 2 3] :b :c]` tree, as shown in the following illustration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Using zippers](img/B05024_01_01.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows a zipper at three different locations in the given
    tree. Initially, the location of the zipper is at the root of the tree, which
    is the entire vector. The `down` function moves the location to the first child
    node in the tree. The `left` and `right` functions move the location of the zipper
    to other nodes at the same level or depth in the tree. The `up` function moves
    the zipper to the parent of the node pointed to by the zipper's current location.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the node representing the current location of a zipper in a tree,
    we must use the `node` function, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To navigate to the extreme left or right of a tree, we can use the `leftmost`
    and `rightmost` functions, respectively, as shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `lefts` and `rights` functions return the nodes that are present to the
    left and right, respectively, of a given zipper, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As the `:a` node is the leftmost element in the tree, the `rights` function
    will return all of the other nodes in the tree when passed a zipper that has `:a`
    as the current location. Similarly, the `lefts` function for the zipper at the
    `:a` node will return an empty value, that is `nil`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The `root` function can be used to obtain the root of a given zipper. It will
    return the original tree used to construct the zipper, as shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `path` function can be used to obtain the path from the root element of
    a tree to the current location of a given zipper, as shown here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the preceding example, the path of the `1` node in `tree` is represented
    by a vector containing the entire tree and the subtree `[1 2 3]`. This means that
    to get to the `1` node, we must pass through the root and the subtree `[1 2 3]`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have covered the basics of navigating across trees, let''s see
    how we can modify the original tree. The `insert-child` function can be used to
    insert a given element into a tree as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can also remove a node from the zipper using the `remove` function. Also,
    the `replace` function can be used to replace a given node in a zipper:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: One of the most noteworthy examples of tree-like data is XML. Since zippers
    are great at handling trees, they also allow us to easily traverse and modify
    XML content. Note that Clojure already provides the `xml-seq` function to convert
    XML data into a sequence. However, treating an XML document as a sequence has
    many strange implications.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: One of the main disadvantages of using `xml-seq` is that there is no easy way
    to get to the root of the document from a node if we are iterating over a sequence.
    Also, `xml-seq` only helps us iterate over the XML content; it doesn't deal with
    modifying it. These limitations can be overcome using zippers, as we will see
    in the upcoming example.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following XML document:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The document shown above contains countries and cities represented as XML nodes.
    Each country has a number of cities, and a single city as its capital. Some information,
    such as the name of the country and a flag indicating whether a city is a capital,
    is encoded in the XML attributes of the nodes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following example expects the XML content shown previously to be present
    in the `resources/data/sample.xml` file, relative to the root of your Leiningen
    project.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a function to find out all the capital cities in the document,
    as shown in *Example 1.10*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '*Example 1.10: Querying XML with zippers*'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Firstly, we must note that the `parse` function from the `clojure.xml` namespace
    reads an XML document and returns a map representing the document. Each node in
    this map is another map with the `:tag`, `:attrs`, and `:content` keys associated
    with the XML node's tag name, attributes, and content respectively.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In *Example 1.10*, we first define a simple function, `is-capital-city?`, to
    determine whether a given XML node has the `city` tag, represented as `:city`.
    The `is-capital-city?` function also checks whether the XML node contains the
    `capital` attribute, represented as `:capital`. If the value of the `capital`
    attribute of a given node is the `"true"` string, then the `is-capital-city?`
    function returns `true`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The `find-capitals` function performs most of the heavy lifting in this example.
    This function first parses XML documents present at the supplied path `file-path`,
    and then converts it into a zipper using the `xml-zip` function. We then iterate
    over the zipper using the `next` function until we arrive back at the root node,
    which is checked by the `take-while` function. We then map the `node` function
    over the resulting sequence of zippers using the `map` function, and apply the
    `filter` function to find the capital cities among all the nodes. Finally, we
    use the `mapcat` function to obtain the XML content of the filtered nodes and
    flatten the resulting sequence of vectors into a single list.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'When supplied a file containing the XML content we described earlier, the `find-capitals`
    function returns the names of all capital cities in the document:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As demonstrated previously, zippers are apt for dealing with trees and hierarchical
    data such as XML. More generally, sequences are a great abstraction for collections
    and several forms of data, and Clojure provides us with a huge toolkit for dealing
    with sequences. There are several more functions that handle sequences in the
    Clojure language, and you are encouraged to explore them on your own.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Working with pattern matching
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine *pattern matching* in Clojure. Typically, functions
    that use conditional logic can be defined using the `if`, `when`, or `cond` forms.
    Pattern matching allows us to define such functions by declaring patterns of the
    literal values of their parameters. While this idea may appear quite rudimentary,
    it is a very useful and powerful one, as we shall see in the upcoming examples.
    Pattern matching is also a foundational programming construct in other functional
    programming languages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, there is no pattern matching support for functions and forms in
    the core language. However, it is a common notion among Lisp programmers that
    we can easily modify or extend the language using macros. Clojure takes this approach
    as well, and thus pattern matching is made possible using the `match` and `defun`
    macros. These macros are implemented in the `core.match` ([https://github.com/clojure/core.match](https://github.com/clojure/core.match))
    and `defun` ([https://github.com/killme2008/defun](https://github.com/killme2008/defun))
    community libraries. Both of these libraries are also supported on ClojureScript.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The following examples can be found in `src/m_clj/c1/match.clj` of the book's
    source code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a simple example that we can model using pattern matching.
    The XOR logic function returns a true value only when its arguments are exclusive
    of each other, that is, when they have differing values. In other words, the XOR
    function will return false when both of its arguments have the same values. We
    can easily define such a function using the `match` macro, as shown in *Example
    1.11*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '*Example 1.11: Pattern matching using the match macro*'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `xor` function from *Example 1.11* simply matches its arguments, `x` and
    `y`, against a given set of patterns, such as `[true true]` and `[true false]`.
    If both the arguments are `true` or `false`, then the function returns `false`,
    or else it returns `true`. It''s a concise definition that relies on the values
    of the supplied arguments, rather than the use of conditional forms such as `if`
    and `when`. The `xor` function can be defined alternatively, and even more concisely,
    by the `defun` macro, as shown in *Example 1.12*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '*Example 1.12: Pattern match using the defun macro*'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The definition of the `xor` function that uses the `defun` macro simply declares
    the actual values as its arguments. The expression to be returned is thus determined
    by the values of its inputs. Note that the `defun` macro rewrites the definition
    of the `xor` function to use the `match` macro. Hence, all patterns supported
    by the `match` macro can also be used with the `defun` macro. Both the definitions
    of the `xor` function, from *Example 1.11* and *Example 1.12*, work as expected,
    as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `xor` function will throw an exception if we try to pass values that have
    not been declared as a pattern:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can define a simple function to compute the *n^(th)* number of the Fibonacci
    sequence using the `defun` macro, as shown in *Example 1.13*:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Note the use of the variable `n` in the function''s pattern rules. This signifies
    that any value other than `0` and `1` will match with the pattern definition that
    uses `n`. The `fibo` function defined in *Example 1.13* does indeed calculate
    the *n^(th)* Fibonacci sequence, as shown here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'However, the definition of `fibo`, shown in *Example 1.13*, cannot be optimized
    by tail call elimination. This is due to the fact that the definition of `fibo`
    is tree recursive. By this, we mean to say that the expression `(+ (fibo ...)
    (fibo ...))` requires two recursive calls in order to be evaluated completely.
    In fact, if we replace the recursive calls to the `fibo` function with `recur`
    expressions, the resulting function won''t compile. It is fairly simple to convert
    tree recursion into linear recursion, as shown in *Example 1.14*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '*Example 1.14: A tail recursive function with pattern matching*'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It is fairly obvious from the definition of the `fibo-recur` function, from
    *Example 1.14*, that it is indeed tail recursive. This function does not consume
    any stack space, and can be safely called with large values of `n`, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As the preceding examples show us, pattern matching is a powerful tool in functional
    programming. Functions that are defined using pattern matching are not only correct
    and expressive, but can also achieve good performance. In this respect, the `core.match`
    and `defun` libraries are indispensible tools in the Clojure ecosystem.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced a few programming constructs that can be used
    in the Clojure language. We've explored recursion using the `recur`, `loop`, and
    `trampoline` forms. We've also studied the basics of sequences and laziness, while
    describing the various functions in the Clojure language that are used in creating,
    transforming, and filtering sequences. Next, we had a look at zippers, and how
    they can be used to idiomatically handle trees and hierarchical data such as XML.
    Finally, we briefly explored pattern matching using the `core.match` and `defun`
    libraries.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore concurrency and parallelism. We will study
    the various data structures and functions that allow us to leverage these concepts
    in Clojure in ample detail.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Orchestrating Concurrency and Parallelism
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now examine how concurrent and parallel programming are supported in
    Clojure. The term *concurrent programming* refers to managing more than one task
    at the same time. *Parallel programming* or *parallelism*, on the other hand,
    deals with executing multiple tasks at the same time. The distinction between
    these two terms is that concurrency is about how we structure and synchronize
    multiple tasks, and parallelism is more about running multiple tasks in parallel
    over multiple cores. The main advantages of using concurrency and parallelism
    can be elaborated as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent programs can perform multiple tasks simultaneously. For example,
    a desktop application can have a single task for handling user interaction and
    another task for handling I/O and network communication. A single processor can
    be shared among several tasks. Processor utilization is thus more effective in
    concurrent programs.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel programs take advantage of having multiple processor cores. This means
    that such programs can be made to run faster by executing them on a system with
    more processor cores. Also, tasks that are computationally expensive can be parallelized
    to complete in a lesser amount of time.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Explore how we can create and synchronize tasks that run concurrently
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to deal with a shared state between concurrent tasks
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine how computations can be parallelized and how we can control the amount
    of parallelism used to perform these computations
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing concurrent tasks
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure has a couple of handy constructs that allow us to define concurrent
    tasks. A *thread* is the most elementary abstraction of a task that runs in the
    background. In the formal sense, a thread is simply a sequence of instructions
    that can be scheduled for execution. A task that runs in the background of a program
    is said to execute on a separate thread. Threads will be scheduled for execution
    on a specific processor by the underlying operating system. Most modern operating
    systems allow a process to have several threads of execution. The technique of
    managing multiple threads in a single process is termed as *multithreading*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: While Clojure does support the use of threads, concurrent tasks can be modeled
    in more elegant ways using other constructs. Let's explore the different ways
    in which we can define concurrent tasks.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c2/concurrent.clj` of the
    book's source code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Using delays
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *delay* can be used to define a task whose execution is delayed, or *deferred*,
    until it is necessary. A delay is only run once, and its result is cached. We
    simply need to wrap the instructions of a given task in a `delay` form to define
    a delay, as shown in *Example 2.1*:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '*Example 2.1: A delayed value*'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The static `Thread/sleep` method suspends execution of the current thread of
    execution for a given number of milliseconds, which is passed as the first argument
    to this method. We can optionally specify the number of nanoseconds by which the
    current thread must be suspended as the second argument to the `Thread/sleep`
    method.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delay` form in *Example 2.1* simply sleeps for `3000` milliseconds, prints
    a string and returns the value `1`. However, it is not yet *realized*, in the
    sense that, it is has not been executed yet. The `realized?` predicate can be
    used to check whether a delay has been executed, as shown here:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can check whether a value is a delay using the `delay?` predicate.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The body expressions in a `delay` form will not be executed until the value
    returned by it is actually used. We can obtain the value contained in a delay
    by dereferencing it using the at-the-rate symbol (`@`):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the at-the-rate symbol (`@`) to dereference a value is the same as using
    the `deref` function. For example, the expression `@x` is equivalent to `(deref
    x)`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The `deref` function also has a variant form that accepts three arguments—a
    value to dereference, the number of milliseconds to wait before timing out, and
    a value that will be returned in case of a timeout.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown previously, the expression `@delayed-1` returns the value `1`, after
    a pause of 3 seconds. Now, the call to `realized?` returns `true`. Also, the value
    returned by the expression `@delayed-1` will be cached, as shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: It is thus evident that the expression `@delayed-1` will be blocked for 3 seconds,
    will print a string, and return a value only once.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to execute a delay is by using the `force` function, which takes
    a delay as an argument. This function executes a given delay if needed, and returns
    the value of the delay's inner expression.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Delays are quite handy for representing values or tasks that need not be executed
    until required. However, a delay will always be executed in the same thread in
    which it is dereferenced. In other words, delays are *synchronous*. Hence, delays
    aren't really a solution for representing tasks that run in the background.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Using futures and promises
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, threads are the most elementary way of dealing with
    background tasks. In Clojure, all functions implement the `clojure.lang.IFn` interface,
    which in turn extends the `java.lang.Runnable` interface. This means that any
    Clojure function can be invoked in a separate thread of execution. For example,
    consider the function in *Example 2.2*:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '*Example 2.2: A function that waits for 3 seconds*'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `wait-3-seconds` function in *Example 2.2* waits for `3000` milliseconds
    and prints a new line and a string. We can execute this function on a separate
    thread by constructing a `java.lang.Thread` object from it using the `Thread.`
    constructor. The resulting object can then be scheduled for execution in the background
    by invoking its `.start` method, as shown here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The call to the `.start` method returns immediately to the REPL prompt. The
    `wait-3-seconds` function gets executed in the background, and prints to standard
    output in the REPL after 3 seconds. While using threads does indeed allow execution
    of tasks in the background, they have a couple shortcomings:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: There is no obvious way to obtain a return value from a function that is executed
    on a separate thread.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, using the `Thread.` and `.start` functions is essentially interop with
    the underlying JVM. Thus, using these functions in a program's code would mean
    that the program could be run only on the JVM. We essentially lock our program
    into a single platform, and the program can't be run on any of the other platforms
    that Clojure supports.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *future* is a more idiomatic way to represent a task that is executed in
    a separate thread. Futures can be concisely defined as values that will be realized
    in the future. A future represents a task that performs a certain computation
    and returns the result of the computation. We can create a future using the `future`
    form, as shown in *Example 2.3*:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '*Example 2.3: A future that sleeps for some time and returns a value*'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `val-as-future` function defined in *Example 2.3* invokes a future that
    waits for the number of seconds specified by the argument `secs`, prints a new
    line and a string, and finally returns the supplied value `n`. A call to the `val-as-future`
    function will return a future immediately, and a string will be printed after
    the specified number of seconds, as shown here:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `realized?` and `future-done?` predicates can be used to check whether
    a future has completed, as shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can check whether a value is a future using the `future?` predicate.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'A future that is being executed can be stopped by using the `future-cancel`
    function, which takes a future as its only argument and returns a Boolean value
    indicating whether the supplied future was cancelled, as depicted here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can check whether a future has been cancelled using the `future-cancelled?`
    function. Also, dereferencing a future after it has been cancelled will cause
    an exception, as shown here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now that we are familiar with the notion of representing tasks as futures,
    let''s talk about how multiple futures can be synchronized. Firstly, we can use
    *promises* to synchronize two or more futures. A promise, created using the `promise`
    function, is simply a value that can be set only once. A promise is set, or *delivered*,
    using the `deliver` form. Subsequent calls to the `deliver` form on a promise
    that has been delivered will not have any effect, and will return `nil`. When
    a promise is not delivered, dereferencing it using the `@` symbol or the `deref`
    form will block the current thread of execution. Hence, a promise can be used
    with a future in order to pause the execution of the future until a certain value
    is available. The `promise` and `deliver` forms can be quickly demonstrated as
    follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As shown in the preceding output, the first call to the `deliver` form using
    the promise `p` sets the value of the promise to `100`, and the second call to
    the `deliver` form has no effect.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `realized?` predicate can be used to check whether a promise instance has
    been delivered.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to synchronize concurrent tasks is by using the `locking` form.
    The `locking` form allows only a single task to hold a lock variable, or a *monitor*,
    at any given point in time. Any value can be treated as a monitor. When a monitor
    is held, or *locked*, by a certain task, any other concurrent tasks that try to
    acquire the monitor are blocked until the monitor is available. We can thus use
    the `locking` form to synchronize two or more concurrent futures, as shown in
    *Example 2.4*:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '*Example 2.4: Using the locking form*'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `lock-for-2-seconds` function in *Example 2.4* creates two functions, `task-1`
    and `task-2`, which both invoke futures that try to acquire a monitor, represented
    by the variable `lock`. In this example, we use a boring `java.lang.Object` instance
    as a monitor for synchronizing two futures. The future invoked by the `task-1`
    function sleeps for two seconds, whereas the future called by the `task-2` function
    sleeps for a single second. The future called by the `task-1` function is observed
    to complete first as the future invoked by the `task-2` function will not be executed
    until the `locking` form in the future obtains the monitor `lock`, as shown in
    the following output:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We can thus use the `locking` form to synchronize multiple futures. However,
    the `locking` form must be used sparingly as careless use of it could result in
    a deadlock among concurrent tasks. Concurrent tasks are generally synchronized
    to pass around a shared state. Clojure allows us to avoid using the `locking`
    form and any possible deadlocks through the use of reference types to represent
    shared state, as we will examine in the following section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Managing state
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A program can be divided into several parts which can execute concurrently.
    It is often necessary to share data or state among these concurrently running
    tasks. Thus, we arrive at the notion of having multiple observers for some data.
    If the data gets modified, we must ensure that the changes are visible to all
    observers. For example, suppose there are two threads that read data from a common
    variable. This data gets modified by one thread, and the change must be propagated
    to the other thread as soon as possible to avoid inconsistencies.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages that support mutability handle this problem by locking
    over a monitor, as we demonstrated with the `locking` form, and maintaining local
    copies of the data. In such languages, a variable is just a container for data.
    Whenever a concurrent task accesses a variable that is shared with other tasks,
    it copies the data from the variable. This is done in order to prevent unwanted
    overwriting of the variable by other tasks while a task is performing a computation
    on it. In case the variable is actually modified, a given task will still have
    its own copy of the shared data. If there are two concurrent tasks that access
    a given variable, they could simultaneously modify the variable and thus both
    of the tasks would have an inconsistent view of the data in the given variable.
    This problem is termed as a *race condition*, and must be avoided when dealing
    with concurrent tasks. For this reason, monitors are used to synchronize access
    to shared data. However, this methodology is not really *deterministic*, in the
    sense that we cannot easily reason about the actual data contained in a variable
    at a given point in time. This makes developing concurrent programs quite cumbersome
    in programming languages that use mutability.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other functional programming languages, Clojure tackles this problem using
    *immutability*—all values are immutable by default and cannot be changed. To model
    mutable state, there is the notion of *identity*, *state*, and *time*:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: An *identity* is anything that is associated with a changing state. At a given
    point in time, an identity has a single state.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*State* is the value associated with an identity at a given point in time.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Time* defines an ordering between the states of an identity.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that actually use state can thus be divided into two layers. One layer
    is purely functional and has nothing to do with state. The other layer constitutes
    parts of the program that actually require the use of mutable state. This decomposition
    allows us to isolate the parts of a program that actually require the use of mutable
    state.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to define mutable state in Clojure, and the data structures
    used for this purpose are termed as *reference types*. A reference type is essentially
    a mutable reference to an immutable value. Hence, the reference has to be changed
    explicitly, and the actual value contained in a reference type cannot be modified
    in any way. Reference types can be characterized in the following ways:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The change of state in some reference types can either be *synchronous* or *asynchronous*.
    For example, suppose we are writing data to a file. A synchronous write operation
    would block the caller until all data is written to the file. On the other hand,
    an asynchronous write operation would start off a background task to write all
    data to the file and return to the caller immediately.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutation of a reference type can be performed in either a *coordinated* or an
    *independent* manner. By coordinated, we mean that state can only be modified
    within transactions that are managed by some underlying system, which is quite
    similar to the way a database works. A reference type that mutates independently,
    however, can be changed without the explicit use of a transaction.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in some state can be visible to only the thread in which the change
    occurs, or they could be visible to all threads in the current process.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now explore the various reference types that can be used to represent
    mutable state in Clojure.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Using vars
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Vars* are used to manage state that is changed within the scope of a thread.
    We essentially define vars that can have state, and then bind them to different
    values. The modified value of a var is only visible to the current thread of execution.
    Hence, vars are a form of the *thread-local* state.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c2/vars.clj` of the book's
    source code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic vars are defined using the `def` form with the `:dynamic` meta keyword.
    If we omit the `:dynamic` metadata, it would be the same as defining an ordinary
    variable, or a static var, using a `def` form. It''s a convention that all dynamic
    var names must start and end with the asterisk character (`*`), but this is not
    mandatory. For example, let''s define a dynamic variable shown as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `*thread-local-state*` variable defined in *Example 2.5* represents a thread-local
    var that can change dynamically. We have initialized the var `*thread-local-state*`
    with the vector `[1 2 3]`, but it's not really required. In case an initial value
    is not supplied to a `def` form, then the resulting variable is termed as an *unbound*
    var. While the state of a var is confined to the current thread, its declaration
    is global to the current namespace. In other words, a var defined with the `def`
    form will be visible to all threads invoked from the current namespace, but the
    state of the variable is local to the thread in which it is changed. Thus, vars
    using the `def` form are also termed as *global vars*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the `def` form creates a static var, which can only be redefined
    by using another `def` form. Static vars can also be redefined within a scope
    or context using the `with-redefs` and `with-redefs-fn` forms. A dynamic var,
    however, can be set to a new value after it has been defined by using the `binding`
    form, shown as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: In this example, the `binding` form changes the value contained in the `*thread-local-state*`
    var to the vector `[10 20]`. This causes the `map` form in the example to return
    a different value when called without a `binding` form surrounding it. Thus, the
    `binding` form can be used to temporarily change the state of the vars supplied
    to it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'The Clojure namespace system will resolve free symbols, or rather variable
    names, to their values. This process of resolving a variable name to a namespace
    qualified symbol is termed as *interning*. Also, a `def` form will first look
    for an existing global var depending on the symbol it is passed, and will create
    one if it hasn''t been defined yet. The `var` form can be used to obtain the fully
    qualified name of a variable, instead of its current value, as shown here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Note
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `#'` symbol is the same as using the `var` form. For example, `#'x`
    is equivalent to `(var x)`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'The `with-bindings` form is another way to rebind vars. This form accepts a
    map of var and value pairs as its first argument, followed by the body of the
    form, shown as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can check if a var is bound to any value in the current thread of execution
    using the `thread-bound?` predicate, which requires a var to be passed as its
    only argument:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We can also define vars that are not interned, or *local vars*, using the `with-local-vars`
    form. These vars will not be resolved by the namespace system, and have to be
    accessed manually using the `var-get` and `var-set` functions. These functions
    can thus be used to create and access mutable variables, as shown in *Example
    2.5*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the at-the-rate symbol (`@`) with a non-interned var is the same as using
    the `var-get` function. For example, if `x` is a non-interned var, `@x` is equivalent
    to `(var-get x)`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '*Example 2.5: Mutable variables using the with-local-vars form*'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `factorial` function defined in *Example 2.5* calculated the factorial of
    `n` using two mutable local vars `i` and `acc`, which are initialized with the
    values `n` and `1` respectively. Note that the code in this function exhibits
    an imperative style of programming, in which the state of the variables `i` and
    `acc` is manipulated using the `var-get` and `var-set` functions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can check whether a value has been created through a `with-local-vars` form
    using the `var?` predicate.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Using refs
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Software Transactional Memory** (**STM**) system can also be used to model
    mutable state. STM essentially treats mutable state as a tiny database that resides
    in a program's memory. Clojure provides an STM implementation through *refs*,
    and they can only be changed within a transaction. Refs are a reference type that
    represent *synchronous* and *coordinated* state.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c2/refs.clj` of the book's
    source code.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a ref by using the `ref` function, which requires a single argument
    to indicate the initial state of the ref. For example, we can create a ref as
    follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The variable `state` defined here represents a ref with the initial value of
    `0`. We can dereference `state` using `@` or `deref` to obtain the value contained
    in it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to modify a ref, we must start a transaction by using the `dosync`
    form. If two concurrent tasks invoke transactions using the `dosync` form simultaneously,
    then the transaction that completes first will update the ref successfully. The
    transaction which completes later will be retried until it completes successfully.
    Thus, I/O and other side-effects must be avoided within a `dosync` form, as it
    can be retried. Within a transaction, we can modify the value of a ref using the
    `ref-set` function. This function takes two arguments—a ref and the value that
    represents the new state of the ref. The `ref-set` function can be used to modify
    a ref as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Initially, the expression `@state` returns `0`, which is the initial state of
    the ref `state`. The value returned by this expression changes after the call
    to `ref-set` within the `dosync` form.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: We can obtain the latest value contained in a ref by using the `ensure` function.
    This function returns the latest value of a ref, and has to be called within a
    transaction. For example, the expression `(ensure state)`, when called within
    a transaction initiated by a `dosync` form, will return the latest value of the
    ref `state` in the transaction.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'A more idiomatic way to modify a given ref is by using the `alter` and `commute`
    functions. Both these functions require a ref and a function to be passed to it
    as arguments. The `alter` and `commute` functions will apply the supplied function
    to the value contained in a given ref, and save the resulting value into the ref.
    We can also specify additional arguments to pass to the supplied function. For
    example, we can modify the state of the ref `state` using `alter` and `commute`
    as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The preceding transactions with the `alter` and `commute` forms will save the
    value `(+ @state 2)` into the ref `state`. The main difference between `alter`
    and `commute` is that a `commute` form must be preferred when the supplied function
    is *commutative*. This means two successive calls of the function supplied to
    a `commute` form must produce the same result regardless of the ordering among
    the two calls. Using the `commute` form is considered an optimization over the
    `alter` form in which we are not concerned with the ordering among concurrent
    transactions on a given ref.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ref-set`, `alter`, and `commute` functions all return the new value contained
    in the supplied ref. Also, these functions will throw an error if they are not
    called within a `dosync` form.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'A mutation performed by the `alter` and `commute` forms can also be validated.
    This is achieved using the `:validator` key option when creating a ref, as shown
    here:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As shown previously, the ref `r` throws an exception when we try to change its
    state to a negative value. This is because the `pos?` function is used to validate
    the new state of the ref. Note that the `:validator` key option can be used with
    other reference types as well. We can also set the validation function of a ref
    that was created without a `:validator` key option using the `set-validator!`
    function.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `:validator` key option and the `set-validator!` function can be used with
    *all* reference types. The supplied validation function must return `false` or
    throw an exception to indicate a validation error.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'The *dining philosophers problem* depicts the use of synchronization primitives
    to share resources. The problem can be defined as follows: five philosophers are
    seated on a round table to eat spaghetti, and each philosopher requires two forks
    to eat from his plate of spaghetti. There are five forks on the table, placed
    in between the five philosophers. A philosopher will first have to pick up a fork
    from his left side as well as one from his right side before he can eat. When
    a philosopher cannot obtain the two forks to his left and right side, he must
    wait until both the forks are available. After a philosopher is done eating his
    spaghetti, he will think for some time, thereby allowing the other philosophers
    to use the forks that he used. The solution to this problem requires that all
    philosophers share the forks among them, and none of the philosophers starve due
    to being unable to get two forks. The five philosophers'' plates and forks are
    placed on the table as illustrated in the following diagram:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![Using refs](img/B05024_02_01.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: A philosopher must obtain exclusive access to the forks on his left and right
    side before he starts eating. If both the forks are unavailable, the philosopher
    must wait for some time for either one of the forks to be free, and retry obtaining
    the forks. This way, each philosopher can access the forks in tandem with the
    other philosophers and avoid starvation.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, this solution can be implemented by using synchronization primitives
    to access the available forks. Refs allow us to implement a solution to the dining
    philosophers problem without the use of any synchronization primitives. We will
    now demonstrate how we can implement and simulate a solution to this problem in
    Clojure. Firstly, we will have to define the states of a fork and a philosopher
    as refs, as shown in *Example 2.6*:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '*Example 2.6: The dining philosophers problem using refs*'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `make-fork` and `make-philosopher` functions create refs to represent the
    states of a fork and a philosopher, respectively. A fork is simply the state of
    a Boolean value, indicating whether it is available or not. And a philosopher,
    created by the `make-philosopher` function, is a map encapsulated as a state,
    which has the following keys:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: The `:name` key contains the name of a philosopher that is a string value.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:forks` key points to the forks on the left and the right side of a philosopher.
    Each fork will be a ref created by the `make-fork` function.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:eating?` key indicates whether a philosopher is eating at the moment.
    It is a Boolean value.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:food` key represents the amount of food available to a philosopher. For
    simplicity, we will treat this value as an integer.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s define some primitive operations to help in handling forks, as
    shown in *Example 2.7*:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '*Example 2.7: The dining philosophers problem using refs (continued)*'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `has-forks?` function defined previously checks whether both the forks
    that are placed to the left and right of a given philosopher ref `p` are available.
    The `update-forks` function will modify the state of both the associated forks
    of a philosopher ref `p` using a `commute` form, and returns the ref `p`. Obviously,
    these functions can only be called within a transaction created by the `dosync`
    form, since they use the `ensure` and `commute` functions. Next, we will have
    to define some functions to initiate transactions and invoke the `has-forks?`
    and `update-forks` functions for a given philosopher, as shown in *Example 2.8*:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '*Example 2.8: The dining philosophers problem using refs (continued)*'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The heart of the solution to the dining philosophers problem is the `start-eating`
    function in *Example 2.8*. This function will check whether both the forks on
    either side of a philosopher are available, using the `has-forks?` function. The
    `start-eating` function will then proceed to update the states of these forks
    by calling the `update-forks` function. The `start-eating` function will also
    change the state of the philosopher ref `p` by invoking `commute` with the `assoc`
    and `update-in` functions, which both return a new map. Since the `start-eating`
    function uses a `when` form, it will return `nil` when any of the philosophers'
    forks are unavailable. These few steps are the solution; in a nutshell, a philosopher
    will eat only when both his forks are available.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The `stop-eating` function in *Example 2.8* reverses the state of a given philosopher
    ref after the `start-eating` function has been invoked on it. This function basically
    sets the `:eating` key of the map contained in the supplied philosopher ref `p`
    to `false` using a `commute` form, and then calls `update-forks` to reset the
    state of the associated forks of the philosopher ref `p`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The `start-eating` and `stop-eating` function can be called repeatedly in a
    loop using a `while` form, as long as the `:food` key of a philosopher ref `p`,
    or rather the amount of available food, is a positive value. This is performed
    by the `dine` function in *Example 2.8*. This function will call the `start-eating`
    function on a philosopher ref `p`, and will wait for some time if the philosopher's
    forks are being used by any other philosophers. The amount of time that a philosopher
    waits for is indicated by the `retry-ms` argument that is passed to the dine function.
    If a philosopher's forks are available, he eats for a random amount of time, as
    indicated by the expression `(rand-int max-eat-ms)`. Then, the `stop-eating` function
    is called to reset the state of the philosopher ref `p` and the forks that it
    contains. Finally, the `dine` function waits for a random amount of time, which
    is represented by the `(rand-int max-think-ms)` expression, to indicate that a
    philosopher is thinking.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now define some function and actually create some refs representing
    philosophers and associated forks, as shown in *Example 2.9*:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '*Example 2.9: The dining philosophers problem using refs (continued)*'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `init-forks` function from *Example 2.9* will simply invoke the `make-fork`
    function a number of times, as indicated by its argument `nf`. The `init-philosophers`
    function will create `np` number of philosophers and associate each of them with
    a vector of two forks and a certain amount of food. This is done by mapping the
    function `init-fn`, which is a function that matches the arity of the `make-philosopher`
    function in *Example 2.6*, over a range of philosopher names `p-names` and forks
    `p-forks`, and an infinite range `p-food` of the value `food`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now define a function to print the collective state of a sequence of
    philosophers. This can be done in a fairly simple manner using the `doseq` function,
    as shown in *Example 2.10*:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '*Example 2.10: The dining philosophers problem using refs (continued)*'
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `check-philosophers` function in *Example 2.10* iterates through all of
    its supplied philosopher refs, represented by `philosophers`, and associated forks,
    represented by `forks`, and prints their state. The `if-let` form is used here
    to check if a dereferenced ref from the collection `philosophers` is not `nil`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a function to concurrently invoke the `dine` function over
    a collection of philosopher. This function could also pass in values for the `retry-ms`,
    `max-eat-ms`, and `max-think-ms` arguments of the `dine` function. This is implemented
    in the `dine-philosophers` function in *Example 2.11*:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '*Example 2.11: The dining philosophers problem using refs (continued)*'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finally, let''s define five instances of philosophers and five associated forks
    for our simulation, using the `init-forks`, `init-philosophers`, and `make-philosopher`
    functions, as shown in *Example 2.12* as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '*Example 2.12: The dining philosophers problem using refs (continued)*'
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can now use the `check-philosopher` function to print the state of the philosopher
    and fork refs created in *Example 2.12*, as shown here:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Initially, all of the forks are available and none of the philosophers are
    eating. To start the simulation, we must call the `dine-philosophers` function
    on the philosopher refs `all-philosophers` and the fork refs `all-forks`, as shown
    here:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'After invoking the `dine-philosophers` function, each philosopher is observed
    to consume the allocated food, as shown in the output of the previous `check-philosophers`
    function. At any given point of time, one or two philosophers are observed to
    be eating, and the other philosophers will wait until they complete using the
    available forks. Subsequent calls to the `check-philosophers` function also indicate
    the same output, and the philosophers will eventually consume all of the allocated
    food:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We can pause the simulation by calling the `future-cancel` function, as shown
    here. Once the simulation is paused, it can be resumed by calling the `dine-philosophers`
    function again, as `(dine-philosophers all-philosophers)`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: To summarize, the preceding example is a concise and working implementation
    of a solution to the dining philosophers problem using Clojure futures and refs.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Using atoms
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Atoms* are used to handle state that changes atomically. Once an atom is modified,
    its new value is reflected in all concurrent threads. In this way, atoms represent
    *synchronous* and *independent* state. Let''s quickly explore the functions that
    can be used to handle atoms.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c2/atoms.clj` of the book's
    source code.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an atom using the `atom` function, which requires the initial
    state of the atom to be passed to it as the first argument, as shown here:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `reset!` and `swap!` functions can be used to modify the state of an atom.
    The `reset!` function is used to directly set the state of an atom. This function
    takes two arguments—an atom and the value that represents the new state of the
    atom, as shown here:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `swap!` function requires a function and additional arguments to pass to
    the supplied function as arguments. The supplied function is applied to the value
    contained in the atom along with the other additional arguments specified to the
    `swap!` function. This function can thus be used to mutate an atom using a supplied
    function, as shown here:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The call to the preceding `swap!` function sets the state of the atom to the
    result of the expression `(+ @state 2)`. The `swap!` function may call the function
    `+` multiple times due to concurrent calls to the `swap!` function on the atom
    `state`. Hence, functions that are passed to the `swap!` function must be free
    of I/O and other side effects.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `reset!` and `swap!` functions both return the new value contained in the
    supplied atom.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'We can watch for any change in an atom, and other reference types as well,
    using the `add-watch` function. This function will call a given function whenever
    the state of an atom is changed. The `add-watch` function takes three arguments—a
    reference, a key and a *watch function*, that is, a function that must be called
    whenever the state of the supplied reference type is changed. The function that
    is supplied to the `add-watch` function must accept four arguments—a key, the
    reference that was changed, the old value of the reference, and the new value
    of the reference. The value of the key argument that is passed to the `add-watch`
    function gets passed to the `watch` function as its first argument. A `watch`
    function can also be unlinked from a given reference type using the `remove-watch`
    function. The `remove-watch` function accepts two arguments—a reference and a
    key that was specified while adding a `watch` function to the reference. *Example
    2.13* depicts how we can track the state of an atom using a `watch` function:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '*Example 2.13: Using the add-watch function*'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `make-state-with-watch` function defined in *Example 2.13* returns a vector
    of two atoms. The second atom in this vector initially contains the value `false`.
    Whenever the state of the first atom in the vector returned by the `make-state-with-watch`
    function is changed, the state of the second atom in this vector is changed to
    the value `true`. This can be verified in the REPL, as shown here:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Thus, watch functions can be used with the `add-watch` function to track the
    state of atoms and other reference types.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `add-watch` function can be used with *all* reference types.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Using agents
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *agent* is used to represent state that is associated with a queue of actions
    and a pool of worker threads. Any action that modifies the state of an agent must
    be sent to its queue, and the supplied function will be called by a thread selected
    from the agent's pool of worker threads. We can send actions asynchronously to
    agents as well. Thus, agents represent *asynchronous* and *independent* state.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c2/agents.clj` of the book's
    source code.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'An agent is created using the `agent` function. For example, we can create
    an agent with an empty map as its initial value as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: We can modify the state of an agent by using the `send` and `send-off` functions.
    The `send` and `send-off` functions will send a supplied action and its additional
    arguments to an agent's queue in an asynchronous manner. Both these functions
    return the agent they are passed immediately.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference between the `send` and `send-off` functions is that the
    `send` function assigns actions to a thread selection from a pool of worker threads,
    whereas the `send-off` function creates a new dedicated thread to execute each
    action. Blocking actions that are sent to an agent using the `send` function could
    exhaust the agent's pool of threads. Thus, the `send-off` function is preferred
    for sending blocking actions to an agent.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the `send` and `send-off` functions, let''s first define a function
    that returns a closure that sleeps for a certain amount of time, and then, call
    the `assoc` function, as shown in *Example 2.14*:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '*Example 2.14: A function that returns a closure which sleeps and calls assoc*'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A closure returned by the `set-value-in-ms` function, in *Example 2.14*, can
    be passed as an action to the `send` and `send-off` functions, as shown here:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The calls to the preceding `send` and `send-off` functions will call the closures
    returned by the `set-value-in-ms` function, from *Example 2.14*, asynchronously
    over the agent `state`. The agent's state changes over a period of 10 seconds,
    which is required to execute the closures returned by the `set-value-in-ms` function.
    The new key-value pair `{:value 5}` is observed to be saved into the agent `state`
    after five seconds, and the state of the agent again changes to `{:value 10}`
    after another five seconds.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Any action that is passed to the `send` and `send-off` functions can use the
    `*agent*` var to access the agent through which the action will be executed.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'The `await` function can be used to wait for all actions in an agent''s queue
    to be completed, as shown here:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The expression `(await state)` is observed to be blocked until the previous
    action that was sent to the agent `state` using the `send-off` function is completed.
    The `await-for` function is a variant of `await`, which waits for a certain number
    of milliseconds, indicated by its first argument, for all the actions on an agent,
    its second argument, to complete.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'An agent also saves any error it encounters while performing the actions in
    its queue. An agent will throw the error it has encountered on any subsequent
    calls to the `send` and `send-off` functions. The error saved by an agent can
    be accessed using the `agent-error` function, and can be cleared using the `clear-agent-errors`
    function, as shown here:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: An agent that has encountered an error can also be restarted using the `restart-agent`
    function. This function takes an agent as its first argument and the new state
    of the agent as its second argument. All actions that were sent to an agent while
    it was failed will be executed once the `restart-agent` is called on the agent.
    We can avoid this behavior by passing the `:clear-actions true` optional argument
    to the `restart-agent` function. In this case, any actions held in an agent's
    queue are discarded before it is restarted.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a pool of threads, or a *threadpool*, to use with an agent, we must
    call the static `newFixedThreadPool` method of the `java.util.concurrent.Executors`
    class by passing the desired number of threads in the pool as an argument, as
    follows:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The pool of threads defined previously can be used to execute the actions of
    an agent by using the `send-via` function. This function is a variant of the `send`
    function that accepts a pool of threads, such as the `pool` defined previously,
    as its first argument, as shown here:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can also specify the thread pools to be used by all agents to execute actions
    sent to them using the `send` and `send-off` functions using the `set-agent-send-executor!`
    and `set-agent-send-off-executor!` functions respectively. Both of these functions
    accept a single argument representing a pool of threads.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: All agents in the current process can be stopped by invoking the `(shutdown-agents)`.
    The `shutdown-agents` function should only be called before exiting a process,
    as there is no way to restart the agents in a process after calling this function.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try implementing the dining philosophers problem using agents.
    We can reuse most of the functions from the previous implementation of the dining
    philosophers problem that was based on refs. Let''s define some functions to model
    this problem using agents, as shown in *Example 2.15*:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '*Example 2.15: The dining philosophers problem using agents*'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In *Example 2.15*, the `make-philosopher-agent` function will create an agent
    representing a philosopher. The initial state of the resulting agent is a map
    of the keys `:name`, `:forks`, `:eating?`, and `:food`, as described in the previous
    implementation of the dining philosophers problem. Note that the forks in this
    implementation are still represented by refs.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: The `start-eating` function in *Example 2.15* will start a transaction, check
    whether the forks placed to the left and right sides of a philosopher are available,
    changes the state of the forks and philosopher agent accordingly, and then suspends
    the current thread for some time to indicate that a philosopher is eating. The
    `stop-eating` function in *Example 2.15* will similarly update the state of a
    philosopher and the forks he had used, and then suspend the current thread for
    some time to indicate that a philosopher is thinking. Note that both the `start-eating`
    and `stop-eating` functions reuse the `has-forks?` and `update-forks` functions
    from *Example 2.7* of the previous implementation of the dining philosophers problem.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: The `start-eating` and `stop-eating` functions are called by the `dine` function
    in *Example 2.15*. We can assume that this function will be passed as an action
    to a philosopher agent. This function checks the value of the `:eating?` key contained
    in a philosopher agent to decide whether it must invoke the `start-eating` or
    `stop-eating` function in the current call. Next, the `dine` function invokes
    itself again using the `send-off` function and dereferencing the agent returned
    by the `send-off` function. The `dine` function also checks the state of the atom
    `running?` and does not invoke itself through the `send-off` function in case
    the expression `@running` returns `false`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The `dine-philosophers` function in *Example 2.15* starts the simulation by
    setting the value of the `running?` atom to `true` and then invoking the `dine`
    function asynchronously through the `send-off` function for all the philosopher
    agents passed to it, represented by `philosophers`. The function `stop-philosophers`
    simply sets the value of the `running?` atom to `false`, thereby stopping the
    simulation.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s define five instances of forks and philosophers using the `init-forks`
    and `init-philosophers` functions from *Example 2.9*, shown in *Example 2.16*
    as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '*Example 2.16: The dining philosophers problem using agents (continued)*'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can now start the simulation by calling the `dine-philosophers` function.
    Also, we can print the collective state of the fork and philosopher instances
    in the simulation using the `check-philosophers` function defined in *Example
    2.10*, as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: As shown in the preceding output, all philosopher agents share the fork instances
    among themselves. In effect, they work in tandem to ensure that each philosopher
    eventually consumes all of their allocated food.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: In summary, vars, refs, atoms, and agents can be used to represent mutable state
    that is shared among concurrently executing tasks.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Executing tasks in parallel
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simultaneous execution of several computations is termed as *parallelism*.
    The use of parallelism tends to increase the overall performance of a computation,
    since the computation can be partitioned to execute on several cores or processors.
    Clojure has a couple of functions that can be used for the parallelization of
    a particular computation or task, and we will briefly examine them in this section.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c2/parallel.clj` of the book's
    source code.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a function that pauses the current thread for some time and
    then returns a computed value, as depicted in *Example 2.17*:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '*Example 2.17: A function that pauses the current thread*'
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The function `square-slowly` in *Example 2.17* requires a single argument `x`.
    This function pauses the current thread for two seconds and returns the square
    of its argument `x`. If the function `square-slowly` is invoked over a collection
    of three values using the `map` function, it takes three times as long to complete,
    as shown here:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The previously shown `map` form returns a lazy sequence, and hence the `doall`
    form is required to realize the value returned by the map form. We could also
    use the `dorun` form to perform this realization of a lazy sequence. The entire
    expression is evaluated in about six seconds, which is thrice the time taken by
    the `square-slowly` function to complete. We can parallelize the application of
    the `square-slowly` function using the `pmap` function instead of `map`, as shown
    here:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The entire expression now evaluates in the same amount of time required for
    a single call to the `square-slowly` function. This is due to the `square-slowly`
    function being called in parallel over the supplied collection by the `pmap` form.
    Thus, the `pmap` form has the same semantics as that of the `map` form, except
    that it applies the supplied function in parallel.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pvalues` and `pcalls` forms can also be used to parallelize computations.
    The `pvalues` form evaluates the expressions passed to it in parallel, and returns
    a lazy sequence of the resulting values. Similarly, the `pcalls` form invokes
    all functions passed to it, which must take no arguments, in parallel and returns
    a lazy sequence of the values returned by these functions:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: As shown in the preceding output, both expressions that use the `pvalues` and
    `pcalls` forms take the same amount of time to evaluate as a single call to the
    `square-slowly` function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pmap`, `pvalues`, and `pcalls` forms *all* return lazy sequences that have
    to be realized using the `doall` or `dorun` form.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Controlling parallelism with thread pools
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pmap` form schedules parallel execution of the supplied function on the
    default threadpool. If we wish to configure or tweak the threadpool used by `pmap`,
    the `claypoole` library ([https://github.com/TheClimateCorporation/claypoole](https://github.com/TheClimateCorporation/claypoole))
    is a good option. This library provides an implementation of the `pmap` form that
    must be passed a configurable threadpool. We will now demonstrate how we can use
    this library to parallelize a given function.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `pmap` function from the `com.climate.claypoole` namespace is essentially
    a variant of the standard `pmap` function to which we supply a threadpool instance
    to be used in parallelizing a given function. We can also supply the number of
    threads to be used by this variant of the `pmap` function in order to parallelize
    a given function, as shown here:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: As previously shown, the `pmap` function from the `claypoole` library can be
    used to parallelize the `square-slowly` function that we defined earlier in *Example
    2.17* over a collection of three values. These three elements are computed over
    in two batches, in which each batch will parallely apply the `square-slowly` function
    over two elements in two separate threads. Since the `square-slowly` function
    takes two seconds to complete, the total time taken to compute over the collection
    of three elements is around four seconds.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an instance of a pool of threads using the `threadpool` function
    from the `claypoole` library. This threadpool instance can then be passed to the
    `pmap` function from the `claypoole` library. The `com.climate.claypoole` namespace
    also provides the `ncpus` function that returns the number of physical processors
    available to the current process. We can create a threadpool instance and pass
    it to this variant of the `pmap` function as shown here:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Assuming that we are running the preceding code on a computer system that has
    two physical processors, the call to the `threadpool` function shown previously
    will create a threadpool of two threads. This threadpool instance can then be
    passed to the `pmap` function as shown in the preceding example.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can fall back to the standard behavior of the `pmap` function by passing
    the `:builtin` keyword as the first argument to the `com.climate.claypoole/pmap`
    function. Similarly, if the keyword `:serial` is passed as the first argument
    to the `claypoole` version of the `pmap` function, the function behaves like the
    standard `map` function.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The `threadpool` function also supports a couple of useful key options. Firstly,
    we can create a pool of non-daemon threads using the `:daemon false` optional
    argument. Daemon threads are killed when the process exits, and all threadpools
    created by the `threadpool` function are pools of daemon threads by default. We
    can also name a threadpool using the `:name` key option of the `threadpool` function.
    The `:thread-priority` key option can be used to indicate the priority of the
    threads in the new threadpool.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks can also be prioritized using the `pmap`, `priority-threadpool`, and
    `with-priority` forms from the `claypoole` library. A priority threadpool is created
    using the `priority-threadpool` function, and this new threadpool can be used
    along with the `with-priority` function to assign a priority to a task that must
    be parallelized using `pmap`, as shown here:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Tasks with higher priority are assigned to threads first. Hence, the task represented
    by `task-1` will be assigned to a thread of execution before the task represented
    by `task-2` in the previous output.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'To gracefully deallocate a given threadpool, we can call the `shutdown` function
    from the `com.climate.claypoole` namespace, which accepts a threadpool instance
    as its only argument. The `shutdown!` function from the same namespace will forcibly
    shut down the threads in a threadpool. The `shutdown!` function can also be called
    using the `with-shutdown!` macro. We specify the threadpools to be used for a
    series of computations as a vector of bindings to the `with-shutdown!` macro.
    This macro will implicitly call the `shutdown!` function on all of the threadpools
    that it has created once all the computations in the body of this macro are completed.
    For example, we can define a function to create a threadpool, use it for a computation,
    and finally, shut down the threadpool, using the `with-shutdown!` function as
    shown in *Example 2.18*:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '*Example 2.18: Using a priority threadpool*'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `square-slowly-with-pool` function defined in *Example 2.18* will create
    a new threadpool, represented by `pool`, and then use it to call the `pmap` function.
    The `shutdown!` function is implicitly called once the `doall` form completely
    evaluates the lazy sequence returned by the `pmap` function.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The `claypoole` library also supports *unordered parallelism*, in which results
    of individual threads of computation are used as soon as they are available in
    order to minimize latency. The `com.climate.claypoole/upmap` function is an unordered
    parallel version of the `pmap` function.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'The `com.climate.claypoole` namespace also provides several other functions
    that use threadpools, as described here:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: The `com.climate.claypoole/pvalues` function is a threadpool-based implementation
    of the `pvalues` function. It will evaluate its arguments in parallel using a
    supplied threadpool and return a lazy sequence.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `com.climate.claypoole/pcalls` function is a threadpool-based version of
    the `pcalls` function, which invokes several no-argument functions to return a
    lazy sequence.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A future that uses a given threadpool can be created using the `com.climate.claypoole/future`
    function.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can evaluate an expression in a parallel fashion over the items in a given
    collection using the `com.climate.claypoole/pfor` function.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `upvalues`, `upcalls`, and `upfor` functions in the `com.climate.claypoole`
    namespace are unordered parallel versions of the `pvalues`, `pcalls`, and `pfor`
    functions, respectively, from the same namespace.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is quite evident that the `pmap` function from the `com.climate.claypoole`
    namespace will eagerly evaluate the collection it is supplied. This may be undesirable
    when we intend to call `pmap` over an infinite sequence. The `com.climate.claypoole.lazy`
    namespace provides versions of `pmap` and other functions from the `com.climate.claypoole`
    namespace that preserve the laziness of a supplied collection. The lazy version
    of the `pmap` function can be demonstrated as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The previously defined `lazy-pmap` sequence is a lazy sequence created by mapping
    the `square-slowly` function over the infinite sequence `(range)`. As shown previously,
    the call to the `pmap` function returns immediately, and the first four elements
    of the resulting lazy sequence are realized in parallel using the `doall` and
    `take` functions.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, Clojure has the `pmap`, `pvalues`, and `pcalls` primitives to
    deal with parallel computations. If we intend to control the amount of parallelism
    utilized by these functions, we can use the `claypoole` library's implementations
    of these primitives. The `claypoole` library also supports other useful features
    such as prioritized threadpools and unordered parallelism.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored various constructs that can be used to create concurrent and
    parallel tasks in Clojure. You learned to handle shared mutable state through
    the use of reference types, namely vars, refs, atoms and agents. As we described
    earlier, the dining philosophers problem can be easily implemented using refs
    and agents. You also studied how tasks can be executed in parallel. Lastly, we
    explored the `claypoole` library, which allows us to control the amount of parallelism
    used for a given computation.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our exploration of parallelism in Clojure
    through the use of reducers.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Parallelization Using Reducers
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Reducers* are another way of looking at collections in Clojure. In this chapter,
    we will study this particular abstraction of collections, and how it is quite
    orthogonal to viewing collections as sequences. The motivation behind reducers
    is to increase the performance of computations over collections. This performance
    gain is achieved mainly through parallelization of such computations.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in [Chapter 1](ch16.html "Chapter 1. Working with Sequences
    and Patterns"), *Working with Sequences and Patterns*, sequences and laziness
    are a great way to handle collections. The Clojure standard library provides several
    functions to handle and manipulate sequences. However, abstracting a collection
    as a sequence has an unfortunate consequence; any computation performed over all
    the elements of a sequence is inherently sequential. Also, all of the standard
    sequence functions create a new collection that is similar to the collection passed
    to these functions. Interestingly, performing a computation over a collection
    without creating a similar collection, even as an intermediary result, is quite
    useful. For example, it is often required to reduce a given collection to a single
    value through a series of transformations in an iterative manner. This sort of
    computation does not necessarily require the intermediary results of each transformation
    to be saved.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of iteratively computing values from a collection is that we cannot
    parallelize it in a straightforward way. Modern *MapReduce* frameworks handle
    this kind of computation by pipelining the elements of a collection through several
    transformations in parallel, and finally, reducing the results into a single result.
    Of course, the result could as well be a new collection. A drawback of this methodology
    is that it produces concrete collections as intermediate results of each transformation,
    which is rather wasteful. For example, if we wanted to filter out values from
    a collection, the MapReduce strategy would require creating empty collections
    to represent values that are left out of the reduction step to produce the final
    result.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: This incurs unnecessary memory allocation and also creates additional work for
    the reduction step, which produces the final result. Hence, there's a scope for
    optimizing these sorts of computations.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the notion of treating computations over collections as *reducers*
    to attain better performance. Of course, this doesn''t mean that reducers are
    a replacement for sequences. Sequences and laziness are great for abstracting
    computations that create and manipulate collections, while reducers are a specialized
    high-performance abstraction of collections in which a collection needs to be
    piped through several transformations, and finally, combined to produce the final
    result. Reducers achieve a performance gain in the following ways:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the amount of memory allocated to produce the desired result
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelizing the process of reducing a collection into a single result, which
    could be an entirely new collection
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `clojure.core.reducers` namespace provides several functions to process
    collections using reducers. Let's now examine how reducers are implemented and
    a few examples that demonstrate how reducers can be used.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Using reduce to transform collections
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequences and functions that operate on sequences preserve the sequential ordering
    between elements. Lazy sequences avoid the unnecessary realization of elements
    in a collection until they are required for a computation, but the realization
    of these values is still performed in a sequential manner. However, this characteristic
    of sequential ordering may not be desirable for all computations performed over
    it. For example, it's not possible to map a function over a vector and then lazily
    realize values in the resulting collection out of order; since the `map` function
    converts the supplied collection into a sequence. Also, functions such as `map`
    and `filter` are lazy, but still sequential by nature.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: What's wrong with sequences?
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the limitations of sequences is that they are realized in *chunks*. Let's
    study a simple example to illustrate what this means. Consider a unary function,
    as shown in *Example 3.1*, which we intend to map over a given vector. The function
    must compute a value from the one it is supplied, and also perform a side effect
    so that we can observe its application over the elements in a collection.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c3/reducers.clj` of the book's
    source code.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '*Example 3.1: A simple unary function*'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `square-with-side-effect` function simply returns the square of a number
    `x` using the `*` function. This function also prints the value of `x` using a
    `println` form whenever it is called. Suppose this function is mapped over a given
    vector. The resulting collection would have to be realized completely if a computation
    has to be performed over it, even if all the elements from the resulting vector
    are not required. This can be demonstrated as follows:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: As shown previously, the `mapped` variable contains the result of mapping the
    `square-with-side-effect` function over a vector. If we try to sum the first three
    values in the resulting collection using the `reduce`, `take`, and `+` functions,
    all the values in the `[0 1 2 3 4 5]` vector are printed as a side effect, as
    shown in the preceding output. This means that the `square-with-side-effect` function
    was applied to all the elements in the initial vector, despite the fact that only
    the first three elements were actually required by the `reduce` form. Of course,
    this can be solved using the `seq` function to convert the vector to a sequence
    before mapping the `square-with-side-effect` function over it. But then, we lose
    the ability to efficiently access elements in a random order in the resulting
    collection.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why this actually happens, we first need to understand how the
    standard `map` function is actually implemented. A simplified definition of the
    `map` function is shown in *Example 3.2*:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '*Example 3.2: A simplified definition of the map function*'
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The definition of `map` in *Example 3.2* is a simplified and rather incomplete
    one, as it doesn't check for an empty collections and cannot be used over multiple
    collections. That aside, this definition of `map` does indeed apply a function
    `f` to all the elements in a collection `coll`. This is implemented using a composition
    of the `cons`, `first`, `rest`, and `lazy-seq` forms.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation can be interpreted as "applying the function `f` to the
    first element in the collection `coll`, and then mapping `f` over the rest of
    the collection in a lazy manner". An interesting consequence of this implementation
    is that the `map` function has the following characteristics:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: The ordering among elements in the collection `coll` is preserved.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This computation is performed recursively.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lazy-seq` form is used to perform the computation in a lazy manner.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `first` and `rest` forms indicate that `coll` must be a sequence,
    and the `cons` form will also produce a result that is a sequence. Hence, the
    `map` function accepts a sequence and builds a new one.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, none of these properties of sequences are needed to transform a given
    collection into a result that is not a sequence. Another characteristic of lazy
    sequences is how they are realized. By the term realized, we mean to say a given
    lazy sequence is evaluated to produce concrete values. Lazy sequences are realized
    in *chunks*. Each chunk is comprised of 32 elements, and this is done as an optimization.
    Sequences that behave this way are termed as *chunked sequences*. Of course, not
    all sequences are chunked, and we can check whether a given sequence is chunked
    using the `chunked-seq?` predicate. The `range` function returns a chunked sequence,
    as shown here:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Both the statements in the preceding output select a single element from a sequence
    returned by the `map` function. The function passed to the `map` function in both
    the preceding statements prints the`!` character and returns the value supplied
    to it. In the first statement, the first 32 elements of the resulting sequence
    are realized even though only the first element is required. Similarly, the second
    statement is observed to realize the first 64 elements of the resulting sequence
    when the element at the 32nd position is obtained using the `nth` function. But
    again, realizing a collection in chunks isn't required to perform a computation
    over the elements in the collection.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chunked sequences have been an integral part of Clojure since version 1.1.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are to handle such computations efficiently, we cannot build on functions
    that return sequences, such as `map` and `filter`. Incidentally, the `reduce`
    function does not necessarily produce a sequence. It also has a couple of other
    interesting properties:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: The `reduce` function actually lets the supplied collection define how it is
    computed over or reduced. Thus, `reduce` is *collection independent*.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the `reduce` function is versatile enough to build a single value or an
    entirely new collection as well. For example, using `reduce` with the `*` or `+`
    functions will create a single valued result, while using it with the `cons` or
    `concat` functions can create a new collection as a result. Thus, `reduce` can
    *build anything*.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the `reduce` function can be used as a premise to generalize any
    computation or transformation that has to be applied on a collection.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Introducing reducers
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A collection is said to be *reducible* when it defines its behavior with the
    `reduce` function. The binary function used by the `reduce` function along with
    a collection is also termed as a *reducing function*. A reducing function requires
    two arguments—one to represent the accumulated result of the reduction, and another
    to represent an input value that has to be combined into the result. Several reducing
    functions can be composed into one, which effectively changes how the `reduce`
    function processes a given collection. This composition is done using *reducing
    function transformers*, or simply *reducers*.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: The use of sequences and laziness can be compared to using reducers to perform
    a given computation by Rich Hickey's infamous pie-maker analogy. Suppose a pie-maker
    has been supplied a bag of apples, with an intent to *reduce* the apples to a
    pie. There are a couple transformations needed to perform this task. First, the
    stickers on all the apples have to be removed, as in we *map* a function to "take
    the sticker off" over the apples in the collection. Also, all the rotten apples
    will have to be removed, which is analogous to using the `filter` function to
    remove elements from a collection. Instead of performing this work herself, the
    pie-maker delegates it to her assistant. The assistant could first take the stickers
    off of all the apples, thus producing a new collection, and then take out the
    rotten apples to produce another new collection, which illustrates the use of
    lazy sequences. But then, the assistant would be doing unnecessary work by removing
    the stickers from the rotten apples, which will have to be discarded later.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the assistant could delay this work until the actual reduction
    of the processed apples into a pie is performed. Once the work is actually needed
    to be performed, the assistant will compose the two tasks of *mapping* and *filtering*
    the collection of apples, thus avoiding any unnecessary work. This case depicts
    the use of reducers to compose and transform the tasks needed to effectively reduce
    the collection of apples into a pie. Thus, the use of intermediary collections
    between each transformation is avoided, which is an optimization in terms of memory
    allocations performed to produce the result.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a smart assistant would simply discard the rotten apples first, which
    is essentially filtering the apples before mapping them. However, not all recipes
    are that trivial, and moreover, we can achieve a more interesting optimization
    through the use of reducers—parallelism. By using reducers, we create a *recipe*
    of tasks to reduce a collection of apples into a pie that can be parallelized.
    Also, all processing is delayed until the final reduction, instead of dealing
    with collections as intermediary results of each task. This is the gist of how
    reducers achieve performance though function composition and parallelization.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The `clojure.core.reducers` namespace requires Java 6 with the `jsr166y.jar`
    JAR or Java 7+ for fork/join support.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now briefly explore how reducers are actually implemented. Functions
    that operate on sequences use the `clojure.lang.ISeq` interface to abstract the
    behavior of a collection. In the case of reducers, the common interface that we
    must build upon is that of a reducing function. As we mentioned earlier, a reducing
    function is a two-arity function in which the first argument is the accumulated
    result so far and the second argument is the current input that has to be combined
    with the first argument. The process of performing a computation over a collection
    and producing some result can be generalized into three distinct cases. They can
    be described as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: A new collection with the same number of elements as the collection it is supplied
    needs to be produced. This *one-to-one* case is analogous to using the `map` function.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computation *shrinks* the supplied collection by removing elements from
    it. This can be done using the `filter` function.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computation could also be *expansive*, in which case it produces a new collection
    that contains an increased number of elements. This is like what the `mapcat`
    function does.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These cases depict the different ways in which a collection can be transformed
    into the desired result. Any computation, or reduction, over a collection can
    be thought of as an arbitrary sequence of such transformations. These transformations
    are represented by *transformers*, which are essentially functions that transform
    a reducing function. They can be implemented as shown in *Example 3.3*:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '*Example 3.3: Transformers*'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `mapping`, `filtering`, and `mapcatting` functions in *Example 3.3* represent
    the core logic of the `map`, `filter`, and `mapcat` functions respectively. All
    of these functions are transformers that take a single argument and return a new
    function. The returned function transforms a supplied reducing function, represented
    by `rf`, and returns a new reducing function, created using the expression `(fn
    [result input] ... )`. Functions returned by the `mapping`, `filtering`, and `mapcatting`
    functions are termed as *reducing function transformers*.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: The `mapping` function applies the `f` function to the current input, represented
    by the `input` variable. The value returned by the function `f` is then combined
    with the accumulated result, represented by `result`, using the reducing function
    `rf`. This transformer is a frighteningly pure abstraction of the standard `map`
    function that applies a function `f` over a collection. The `mapping` function
    makes no assumptions of the structure of the collection it is supplied or how
    the values returned by the function `f` are combined to produce the final result.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `filtering` function uses a predicate `p?` to check whether the
    current input of the reducing function `rf` must be combined into the final result,
    represented by `result`. If the predicate is not true, then the reducing function
    will simply return the value `result` without any modification. The `mapcatting`
    function uses the `reduce` function to combine the value `result` with the result
    of the expression `(f input)`. In this transformer, we can assume that the function
    `f` will return a new collection and the reducing function `rf` will somehow combine
    two collections.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the foundations of the `reducers` library is the `CollReduce` protocol
    defined in the `clojure.core.protocols` namespace. This protocol abstracts the
    behavior of a collection when it is passed as an argument to the `reduce` function,
    and is declared as shown in *Example 3.4*:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '*Example 3.4: The CollReduce protocol*'
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `clojure.core.reducers` namespace defines a `reducer` function that creates
    a reducible collection by dynamically extending the `CollReduce` protocol, as
    shown in *Example 3.5*:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '*Example 3.5: The reducer function*'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `reducer` function combines a collection `coll` and a reducing function
    transformer `xf`, which is returned by the `mapping`, `filtering`, and `mapcatting`
    functions, to produce a new reducible collection. When `reduce` is invoked on
    a reducible collection, it will ultimately ask the collection to reduce itself
    using the reducing function returned by the expression `(xf rf)`. Using this mechanism,
    several reducing functions can be composed into a single computation to be performed
    over a given collection. Also, the `reducer` function needs to be defined only
    once, and the actual implementation of `coll-reduce` is provided by the collection
    supplied to the `reducer` function.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can redefine the `reduce` function to simply invoke the `coll-reduce`
    function implemented by a given collection, as shown in *Example 3.6*:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '*Example 3.6: Redefining the reduce function*'
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As shown in *Example 3.6*, the `reduce` function delegates the job of reducing
    a collection to the collection itself using the `coll-reduce` function. Also,
    the `reduce` function will use the reducing function `rf` to also supply the `init`
    argument when it is not specified. An interesting consequence of this definition
    of `reduce` is that the function `rf` must produce an *identity value* when supplied
    no arguments. The standard `reduce` function also uses the `CollReduce` protocol
    to delegate the job of reducing a collection to the collection itself, but will
    also fall back on the default definition of `reduce` in case the supplied collection
    does not implement the `CollReduce` protocol.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Clojure 1.4, the `reduce` function allows a collection to define how it
    reduced using the `clojure.core.CollReduce` protocol. Clojure 1.5 introduced the
    `clojure.core.reducers` namespace that extends the use of this protocol.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the standard Clojure collections, namely lists, vectors, sets, and maps,
    implement the `CollReduce` protocol. The `reducer` function can be used to build
    a sequence of transformations to be applied to a collection when it is passed
    as an argument to the `reduce` function. This can be demonstrated as follows:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'In the preceding output, the `mapping` function is used with the `inc` function
    to create a reducing function transformer that increments all the elements in
    a given collection. This transformer is then combined with a vector using the
    `reducer` function to produce a reducible collection. The call to `reduce` in
    both of the preceding statements is transformed into the expression `(reduce +
    [2 3 4 5])`, thus producing the result `14`. We can now redefine the `map`, `filter`,
    and `mapcat` functions using the `reducer` function, as shown in *Example 3.7*:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '*Example 3.7: Redefining the map, filter and mapcat functions using the reducer
    form*'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As shown in *Example 3.7*, the `map`, `filter`, and `mapcat` functions are now
    simply compositions of the `reducer` form with the `mapping`, `filtering`, and
    `mapcatting` transformers respectively.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The definitions of `CollReduce`, `reducer`, `reduce`, `map`, `filter`, and `mapcat`
    as shown in this section are simplified versions of their actual definitions in
    the `clojure.core.reducers` namespace.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'The definitions of the `map`, `filter`, and `mapcat` functions shown in *Example
    3.7* have the same shape as the standard versions of these functions, as shown
    here:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Hence, the `map`, `filter`, and `mapcat` functions from the `clojure.core.reducers`
    namespace can be used in the same way as the standard versions of these functions.
    The `reducers` library also provides a `take` function that can be used as a replacement
    for the standard `take` function. We can use this function to reduce the number
    of calls to the `square-with-side-effect` function (from *Example 3.1*) when it
    is mapped over a given vector, as shown here:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Thus, using the `map` and `take` functions from the `clojure.core.reducers`
    namespace as shown here avoids applying the `square-with-side-effect` function
    to all five elements in the vector `[0 1 2 3 4 5]` as only the first three are
    required.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reducers` library also provides variants of the standard `take-while`,
    `drop`, `flatten`, and `remove` functions, which are based on reducers. Effectively,
    functions based on reducers will require a lesser number of allocations than sequence-based
    functions, thus leading to an improvement in performance. For example, consider
    the `process` and `process-with-reducer` functions shown in *Example 3.8*:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '*Example 3.8: Functions to process a collection of numbers using sequences
    and reducers*'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `process` function in *Example 3.8* applies the `inc` function over a collection
    of numbers represented by `nums` using the `map` function. The `process-with-reducer`
    function performs the same action, but uses the reducer variant of the `map` function.
    The `process-with-reducer` function will take a lesser amount of time to produce
    its result from a large vector when compared to the `process` function, as shown
    here:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The `process-with-reducer` function gets a slight performance boost as it requires
    a lesser number of memory allocations than the `process` function. We should note
    that the available memory should be large enough to load the entire file, or else
    we could run out of memory. The performance of this computation can be improved
    by a greater scale if we can somehow parallelize it, and we shall examine how
    this can be done in the following section.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Using fold to parallelize collections
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection that implements the `CollReduce` protocol is still sequential by
    nature. Using the `reduce` function with `CollReduce` does have a certain amount
    of performance gain, but it still processes elements in a collection in a sequential
    order. The most obvious way to improve the performance of a computation that is
    performed over a collection is parallelization. Such computations can be parallelized
    if we ignore the ordering of elements in a given collection to produce the result
    of the computation. In the reducers library, this is implemented based on the
    *fork/join model* of parallelization from the `java.util.concurrent` namespace.
    The fork/join model essentially partitions a collection over which a computation
    has to be performed into two halves and processes each partition in parallel.
    This halving of the collection is done in a recursive manner. The granularity
    of the partitions affects the overall performance of a computation modeled using
    fork/join. This means that if a fork/join strategy is used to recursively partition
    a collection into smaller collections that contain a single element each, the
    overhead of the mechanics of fork/join would actually bring down the overall performance
    of the computation.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fork/join based method of parallelization is actually implemented in the `clojure.core.reducers`
    namespace using the `ForkJoinTask` and `ForkJoinPool` classes from the `java.util.concurrent`
    namespace in Java 7\. In Java 6, it is implemented in the `ForkJoinTask` and `ForkJoinPool`
    classes of the `jsr166y` namespace. For more information on the Java fork/join
    framework, visit [https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: The parallelization of such computations using reducers is quite different from
    how it is handled in MapReduce-based libraries. In case of reducers, the elements
    are first reduced through a number of transformations into a smaller number of
    elements and then finally, combined to create the result. This contrasts with
    how a MapReduce strategy models such a computation, in which the elements of a
    collection are mapped through several transformations and a final reduction step
    is used to produce the final result. This distinguishes the MapReduce model of
    parallel computation with the *reduce-combine* model used by the `reducers` library.
    This methodology of parallelization using a reduce-combine strategy is implemented
    by the `fold` function in the `clojure.core.reducers` namespace.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Clojure, the `fold` function refers to a parallelizable computation, which
    is very different from the traditional fold left (`foldl`) and fold right (`foldr`)
    functions in other functional programming languages such as Haskell and Erlang.
    The `reduce` function in Clojure actually has the same sequential nature and semantics
    as the `foldl` function in other languages.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: The `fold` function parallelizes a given computation over a collection using
    fork/join based threads. It implements the reduce-combine strategy that we previously
    described and executes the `reduce` function in parallel over equally partitioned
    segments of a given collection. The results produced by these parallel executions
    of the `reduce` function are finally combined using a *combining function*. Of
    course, if the supplied collection is too small to actually gain any performance
    through fork/join based parallelization, a `fold` form will simply call the `reduce`
    function on a single thread of execution. The `fold` function thus represents
    a *potentially parallelizable* computation over a collection. Due to this nature
    of `fold`, we should avoid performing IO and other side effects based on sequential
    ordering when using the `fold` form.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fold` function allows a collection to define how it is *folded* into the
    result, which is similar to the semantics of the `reduce` function. A collection
    is said to be *foldable* if it implements the `CollFold` protocol from the `clojure.core.reducers`
    namespace. The `reducers` library extends the `CollFold` protocol for the standard
    vector and map collection types. The parallelization of these implementations
    of `CollFold` is done using fork/join based parallelism. The definition of the
    `CollFold` protocol is shown in *Example 3.9*:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '*Example 3.9: The CollFold protocol*'
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `CollFold` protocol defines a `coll-fold` function, which requires four
    arguments—a collection `coll`, the number of elements `n` in each segment or partition
    of the collection, a combining function `cf`, and a reducing function `rf`. A
    foldable collection must implement this protocol, as well as the `clojure.core.protocols.CollReduce`
    protocol, as a call to `fold` on a given collection may fall back to a single-threaded
    execution of the `reduce` function.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a foldable collection from a collection and a reduction function
    transformer, the reducers library defines a `folder` function with similar semantics
    as the `reducer` function. This function is implemented as shown in *Example 3.10*:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '*Example 3.10: The folder function*'
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `folder` function creates a new foldable and reducible collection from
    the collection `coll` and the reduction function transformer `xf`. This composition
    of the `xf` and `rf` functions is analogous to that performed by the `reducer`
    function described in *Example 3.5*. Apart from the `xf` and `rf` functions, the
    `coll-fold` function also requires a combining function `cf` with which the results
    of the potentially parallel executions of the `reduce` function are combined.
    Similar to the `reduce` function, the `fold` function passes on the responsibility
    of actually folding a given collection to the collections implementation of the
    `coll-fold` function. An implementation of the `fold` function is described in
    *Example 3.11*:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '*Example 3.11: The fold function*'
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As shown in *Example 3.11*, the `fold` function calls the `coll-fold` function
    of the collection `coll` using the reducing function `rf` and the combining function
    `cf`. The `fold` function can also specify the number of elements `n` in each
    segment processed by the `reduce` function, which defaults to `512` elements.
    We can also avoid specifying the combining function `cf` to the `fold` function,
    in which case the reducing function `rf` itself will be used as the combining
    function.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting aspect of the combining and reducing functions used by the `fold`
    form is that they must be *associative* in nature. This guarantees that the result
    of the `fold` function will be independent of the order in which the elements
    in a given collection are combined to produce the given result. This allows us
    to parallelize the execution of the `fold` function over segments of a given collection.
    Also, analogous to the reducing function required by the `reduce` form, the `fold`
    function requires the combining and reducing functions to produce an *identity
    value* when invoked with no arguments. In functional programming, a function that
    is both associative and provides an identity value is termed as a **monoid**.
    The `clojure.core.reducers` namespace provides the `monoid` function, described
    in *Example 3.12*, to create such a function that can be used as the combining
    function or the reducing function supplied to a `fold` form:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '*Example 3.12: The monoid function*'
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `monoid` function shown in *Example 3.12* produces a function that calls
    a function `op` when supplied with two arguments `a` and `b`. When the function
    returned by the `monoid` function is called with no arguments, it will produce
    an identity value of the operation by simply calling the `ctor` function with
    no arguments. This function allows us to easily create a combining function to
    be used with the `fold` function from any arbitrary functions `ctor` and `op`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now redefine the `map`, `filter`, and `mapcat` operations as compositions
    of the `folder` function and the `mapping`, `filtering`, and `mapcatting` transformers
    defined in *Example 3.3*, as shown in *Example 3.13*:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '*Example 3.13: Redefining the map, filter and mapcat functions using the folder
    form*'
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The definitions of `folder`, `fold`, `monoid`, `map`, `filter`, and `mapcat`
    as shown in this section are simplified versions of their actual definitions in
    the `clojure.core.reducers` namespace.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: The `reducers` library also defines the `foldcat` function. This function is
    a high-performance variant of the `reduce` and `conj` functions. In other words,
    the evaluation of the expression `(foldcat coll)` will be significantly faster
    than that of the expression `(reduce conj [] coll)`, where `coll` is a reducible
    or foldable collection. Also, the collection returned by the `foldcat` function
    will be a foldable collection.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the `fold` and `map` functions to improve the performance of
    the `process` and `process-with-reducer` functions from *Example 3.8*. We can
    implement this as shown in *Example 3.14*:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '*Example 3.14: A function to process a collection of numbers using a fold form*'
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The performance of the `process-with-folder` function with a large vector can
    be compared to the `process` and `process-with-reducer` functions, as shown here:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: It is observed from the preceding output that the `process-with-folder` function
    performs significantly better than the `process` and `process-with-reducer` functions
    due to its inherent use of parallelism. In summary, reducers improve the performance
    of a computation that has to be performed over a collection using fork/join-based
    parallelism.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Processing data with reducers
  id: totrans-700
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now study a simple example that depicts the use of reducers in efficiently
    processing large collections. For this example, we will use the `iota` library
    ([https://github.com/thebusby/iota](https://github.com/thebusby/iota)) to handle
    large memory-mapped files. The usage of the `iota` library with large files is
    encouraged as an efficient alternative to using concrete collections. For example,
    loading the records in a 1 GB TSV file as strings into a Clojure vector would
    consume over 10 GB of memory due to the inefficient storage of Java strings. The
    `iota` library avoids this by efficiently indexing and caching the contents of
    a large file, and this is done with much lower amount of memory overhead when
    compared to using concrete collections.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The following examples can be found in `src/m_clj/c3/io.clj` of the book's source
    code.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a large TSV file that contains several thousands of records.
    Each record represents a person, and can be assumed to have five fields, as shown
    in the following data:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Each record contains two strings and three keywords. The first two string fields
    of a record represent the last and first name of a person, the third column is
    a keyword that indicates the gender of a person, and the fourth column is a keyword
    that identifies a person as a parent or a child. Finally, the fifth column is
    a keyword that represents an arbitrary direction.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following example expects the content shown previously to be present in
    the file `resources/data/sample.tsv`, relative to the root of your Leiningen project.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'The `seq` and `vec` functions from the `iota` library can be used to create
    a sequence and a vector representation of a memory-mapped file. These objects
    can then be used to access the file in a performant way. Both of the `seq` and
    `vec` functions require a file path to be passed to them as the first argument.
    The `vec` function will index the supplied file in *chunks*, and we can specify
    the size of each chunk as the second argument to the `vec` function. The `seq`
    function performs buffered reads of the supplied file as required, similar to
    the way a lazy sequence is realized. The size of the buffer used by this resulting
    sequence can be specified as the second argument to the `seq` function. Both the
    `seq` and `vec` functions split the contents of a file by a predefined byte-separator
    into records represented as strings. These functions also accept an optional third
    argument to indicate the byte separator between records in the supplied file.
    The `vec` function is slower than the `seq` function as it must index the records
    in the file, which can be demonstrated as follows:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Both the statements shown here load the `sample.tsv` file into Clojure data
    structures. As expected, the `vec` function takes a bit more time than the `seq`
    function to return a value. The values returned by `seq` and `vec` can be treated
    just like any other collection. Naturally, iterating over a vector returned by
    the `vec` function is much faster than using a sequence, as shown here:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We will now demonstrate a couple of ways to query the data in the `sample.tsv`
    file using reducers and the `iota` library. We will need to first define a function
    that converts a collection of records into collections of columnar values from
    their string-based representations. This can be implemented using the reducer
    based `map` and `filter` functions, as shown in the `into-records` function in
    *Example 3.15*:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '*Example 3.15: A function to convert a memory-mapped file into a reducible
    collection*'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, let''s say we need to compute the total number of females from the records
    in the `sample.tsv` file. We can implement a function to perform this computation
    using the `map` and `fold` functions, as shown in the `count-females` function
    in *Example 3.16*:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'We can query the total number of females in the `file-as-seq` and `file-as-vec`
    collections by composing the `into-records` and `count-females` functions. This
    can be done using the `->` threading form, as shown here:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Similarly, the reducer-based `map` and `filter` functions can be used to fetch
    the first names of all the children with the same last name or family in a given
    collection, as implemented by the `get-children-names-in-family` function in *Example
    3.17*:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '*Example 3.17: A function to get the first names of all children in a collection
    of persons*'
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `into-records` and `get-children-names-in-family` functions can be composed
    together to query the first names of all children with the last name `"brown"`
    from the available data, as shown here:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The `iota` library provides a couple more useful functions to handle large
    text files:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: The `numbered-vec` function will create a vector representing a memory-mapped
    file in which each string representing a record will be prepended with its position
    in the given file.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subvec` function of the `iota` library can be used to *slice* records from
    a memory-mapped file returned by the `vec` and `numbered-vec` functions. Its semantics
    are identical to the standard `subvec` function that operates on vectors.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers and the `iota` library allow us to idiomatically and efficiently handle
    text files containing a large number of byte-separated records. There are also
    several other libraries and frameworks in the Clojure ecosystem that use reducers
    to handle large amounts of data, and the reader is encouraged to explore these
    libraries and frameworks on their own.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the `clojure.core.reducers` library in detail.
    We had a look at how reducers are implemented and also how we can use reducers
    to handle large collections of data in an efficient manner. We also briefly studied
    the `iota` library that can be used with reducers to handle large amounts of data
    stored in text files.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore Clojure macros.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Metaprogramming with Macros
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers often stumble into situations where they would like to add features
    or constructs to their programming language of choice. Generally, if a feature
    would have to be added to a language, the language's compiler or interpreter would
    need some modification. Alternatively, Clojure (and other Lisps as well) uses
    *macros* to solve this problem. The term *metaprogramming* is used to describe
    the ability to generate or manipulate a program's source code by using another
    program. Macros are a metaprogramming tool that allow programmers to easily add
    new features to their programming language.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Lisps are not the only languages with support for macro-based metaprogramming.
    For example, in C and C++, macros are handled by the compiler's preprocessor.
    In these languages, before a program is compiled, all macro calls in the program's
    source code are replaced by their definitions. In this sense, macros are used
    to generate code through a form of text substitution during the compilation phase
    of a program. On the other hand, Lisps allow programmers to transform or rewrite
    code when macros are interpreted or compiled. Macros can thus be used to concisely
    encapsulate recurring patterns in code. Of course, this can be done in languages
    without macros, as well, without much hassle. But macros allow us to encapsulate
    patterns in code in a clean and concise manner. As we will see ahead in this chapter,
    there's nothing equivalent to Lisp macros in other programming languages in terms
    of clarity, flexibility, and power. Lisps are truly leaps ahead of other programming
    languages in terms of metaprogramming capabilities.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'The rabbit hole of macros in Lisps goes deep enough that there are entire books
    that talk about them. *Mastering Clojure Macros* by *Colin Jones* is one among
    these, and this publication describes the various patterns in which macros can
    be used in great detail. In this chapter, we will explore the foundational concepts
    behind macros and their usage. We will:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: First, have a look at the basics of reading, evaluating, and transforming code
    in Clojure.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later on, we will examine how macros can be defined and used, and also study
    several examples based on macros. We will also describe how we can handle platform-specific
    code using *reader conditionals*.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the reader
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reader is responsible for interpreting Clojure code. It performs several
    steps to translate source code in textual representation into executable machine
    code. In this section, we will briefly describe these steps performed by the reader
    to illustrate how the reader works.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure and other languages from the Lisp family are **homoiconic**. In a homoiconic
    language, the source code of a program is represented as a plain data structure.
    This means that all the code written in a Lisp language is simply a bunch of nested
    lists. Thus, we can manipulate programs'' code just like any other list of values.
    Clojure has a few more data structures, such as vectors and maps in its syntax,
    but they can be handled just as easily. In languages that are not homoiconic,
    any expression or statement in a program has to be translated into an internal
    data structure termed as a *parse tree*, or *syntax tree*, when the program is
    compiled or interpreted. In Lisps, however, an expression is already in the form
    of a syntax tree, since a tree is really just another name for a nested list.
    In other words, there is no distinction between an expression and the syntax tree
    it produces. One might also opine that this design tricks programmers into writing
    code directly as a syntax tree. This distinguishing aspect of Lisps is succinctly
    captured by the following axiom: *Code is Data*.'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the most rudimentary representation of code and
    data in Lisps—an **s-expression**. Any expression comprises of *values* and *symbols*,
    where the symbols represent variables being used. A nested list of symbols is
    known as a *symbolic expression*, *s-expression*, or *sexp*. All source code in
    Clojure is represented as s-expressions. A symbolic expression is formally defined
    as:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: An atom, which refers to a single symbol or literal value.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of two s-expressions `x` and `y`, represented as `(x . y)`. Here,
    the dot (`.`) is used to signify a `cons` operation.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this recursive definition, a list of symbols `(x y z)` is represented
    by the s-expression, `(x . (y . (z . nil)))` or `(x . (y . z))`. When an s-expression
    is used to represent source code, the first element of the expression represents
    the function used, and the rest of the elements are the arguments to the function.
    Of course, this is just a theoretical representation and not really Clojure code.
    This representation is also called *prefix notation*. This recursive structure
    of s-expressions is flexible enough to represent both code as well as data. In
    fact, s-expressions are more-or-less the only form of syntax in Clojure (and other
    Lisps). For example, if we wanted to add two numbers, we would use an expression
    with the `+` function as the first symbol, followed by the values to be added.
    Similarly, if we wanted to define a function, we would have to write an expression
    with `defn` or `def` as the first symbol in the expression. In Clojure and other
    Lisps, we also represent data such as lists, vectors, and maps using s-expressions.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example that depicts how Clojure code is interpreted.
    The expression `(-> [0 1 2] first inc)` that uses a threading macro (`->`) will
    be interpreted in three distinct steps. This expression will be read, *macroexpanded*,
    and evaluated to the value `1`, as illustrated here:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the reader](img/B05024_04_01.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
- en: The reader will first parse textual representations of s-expressions from a
    Clojure program's source code. Once a program's source code is read into s-expressions,
    all macro calls in the code are replaced by their definitions. This transformation
    of macro calls in a program is called *macroexpansion*. Lastly, the resulting
    s-expressions from the macroexpansion phase are evaluated by the Clojure runtime.
    In the evaluation phase, bytecode is generated from the supplied expressions,
    loaded into memory, and executed. In short, code in a program's source code is
    read, transformed through macros, and finally evaluated. Also, macroexpansion
    happens immediately after a program's source code is parsed, thus allowing the
    program to internally transform itself before it is evaluated. This transformation
    of code is exactly what macros are used to achieve.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Clojure, the reader only reads code and performs macroexpansion. The generation
    of bytecode is done by the analyzer and the emitter, and this generated bytecode
    is evaluated by the JVM.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 'All Clojure code is translated to *reader forms* and *special forms* before
    it is evaluated. Special forms are constructs, such as `quote` and `let*`, that
    are implemented directly as bytecode for the underlying runtime, such as the JVM
    for Clojure or the Rhino JavaScript runtime for ClojureScript. Interestingly,
    Clojure source code is composed mostly of reader forms, and these reader forms
    are implemented in Clojure itself. The reader also transforms certain characters
    and forms called *reader macros* as soon as they are read. There are several reader
    macros in the Clojure language, as described in the following table:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '| Reader macro | Usage |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
- en: '| `\x` | This is a character literal. |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
- en: '| `;` | This is used to comment. It ignores the rest of the line. |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
- en: '| `(.method o)` | This is a native method call. It is rewritten to a dot (`.`)
    form as `(. o method)`. Also, `o` must be a native object. |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
- en: '| `@x` or `@( ... )` | This is the dereference operator. It is used with reference
    types and is rewritten to a `deref` form. |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
- en: '| `^{ ... }` | This is the metadata map to be used with a form. It is rewritten
    to a `with-meta` form. |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
- en: '| `''x` or `''( ... )` | This is a quote. |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
- en: '| `` `x `` or `` `( ... ) `` | This is a syntax quote. |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
- en: '| `~x` or `~( ... )` | This is used to unquote. |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
- en: '| `~@x` or `~@( ... )` | This is a splicing unquote. |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
- en: '| `#_x` or `#_( ... )` | This ignores the next form. `#_` should be preferred
    over the `comment` form to comment out code, since comment actually returns `nil`.
    |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
- en: '| `#''x` | This is a var quote. It is equivalent to `(var x)`. |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
- en: '| `#=x` or `#=( ... )` | This will read-evaluate an expression. |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
- en: '| `#?( ... )` | This is a reader conditional form. |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
- en: '| `#?@( ... )` | This is a reader conditional splicing form. |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
- en: We have encountered quite a few of the preceding reader macros in the previous
    chapters. We will demonstrate the usage of several reader forms that are used
    with macros in this chapter.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, Clojure does not support user-defined reader
    macros.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with the Clojure reader and how code
    is interpreted, let's explore the various metaprogramming constructs that help
    us read and evaluate code.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: Reading and evaluating code
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at how code can be parsed and evaluated in Clojure. The
    most elementary way to convert text into an expression is by using the `read`
    function. This function accepts a `java.io.PushbackReader` instance as its first
    argument, as shown here:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples can be found in `src/m_clj/c4/read_and_eval.clj` of the book's
    source code.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a string containing a valid expression is first converted into
    an instance of `java.io.PushbackReader` and then passed to the `read` function.
    It seems like a lot of unnecessary work to read a string, but it is due to the
    fact that the `read` function deals with streams and readers, and not strings.
    If no arguments are passed to the `read` function, it will create a reader from
    the standard input and prompt the user to enter an expression to be parsed. The
    `read` function has several other options as well, and you are encouraged to explore
    these options in the REPL on their own.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: 'A simpler way to read an expression from a string is by using the `read-string`
    function. This function accepts a string as its only argument and converts the
    supplied string into an expression, as shown here:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The `read` and `read-string` forms can only convert strings into valid expressions.
    If we have to evaluate an expression, we must use the `eval` function, as shown
    here:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: In the first statement in the preceding output, we prevent the expression `(list
    1 2 3)` from being evaluated before it is passed to the `eval` function using
    the quote operator (`'`). This technique is termed as *quoting* and we shall explore
    more of it later in this chapter. The `eval` function evaluates the expression
    `(list 1 2 3)` to the list `(1 2 3)`. Similarly, in the second statement, the
    expression `(list + 1 2 3)` is first evaluated as `(+ 1 2 3)` by the reader, and
    then the `eval` function evaluates this list to the value `6`. In the third statement,
    the string `"(+ 1 2 3)"` is first parsed by the `read-string` function and then
    evaluated by the `eval` function.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: 'The read-evaluate macro (`#=`) can be used to force the `read` and `read-string`
    functions to evaluate an expression when it is parsed, as shown here:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'In the preceding output, the `#=` reader macro evaluates the expression `(list
    1 2 3)` when it is read by the `read` and `read-string` functions. If the `#=`
    macro was not used, both statements would return the expression `(list 1 2 3)`
    in verbatim. We can also use the `#=` macro without using `read` or `read-string`,
    in which case it would be equivalent to calling the `eval` function. Also, the
    calls to the `#=` macro can be nested any number of times, as shown here:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'The `#=` macro makes it easy to evaluate expressions while they are being read.
    Oh wait! This is a potential security hazard as the `read` and `read-string` functions
    are evaluating arbitrary strings, even if they contain any malicious code. Thus,
    evaluation of code while it is being parsed is deemed unsafe. As a solution to
    this problem, the `*read-eval*` var can be set to `false` to prevent usage of
    the `#=` macro, as shown here:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Thus, use of the `#=` macro in strings passed to the `read` and `read-string`
    functions will throw an error if `*read-eval*` is set to `false`. Obviously, the
    default value of this var is `true`. For this reason, we must avoid using the
    `#=` macro, or set the `*read-eval*` var to `false`, while processing the user
    input.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to read and evaluate arbitrary strings is by using the `load-string`
    function. This function has the same arity as the `read-string` function, and
    is equivalent to calling the `eval` and `read-string` forms, as shown here:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: There are a couple of semantic differences between using the `load-string` form
    and a composition of the `eval` and `read-string` forms. Firstly, the behavior
    of the `load-string` function is not affected by the changing `*read-eval*` var,
    and is thus unsafe for use with arbitrary user input.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: 'A more important difference is that the `read-string` function only parses
    the first expression it encounters in the string that it has passed. The `load-string`
    function will parse and evaluate all expressions passed to it, as shown here:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: In the preceding output, the `read-string` form skips the second `println` form
    in the string that it is passed, thus printing the value `1` only. The `load-string`
    form, however, parses and evaluates both the `println` forms it is passed as a
    string, and prints both the values `1` and `2`.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: The `load-reader` function is analogous to the `read` function, in the sense
    that it accepts a `java.io.PushbackReader` instance, from which it has to read
    and evaluate forms, as an argument. Another variant of `load-string` is the `load-file`
    function, to which we can pass the path of a file that contains source code. The
    `load-file` function will parse the file in the path that it is passed and evaluate
    all forms present in it.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `*file*` var can be used to obtain the path of the current file
    being executed.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how code can be parsed and evaluated by the Clojure reader.
    There are several constructs that can be used to perform these tasks. However,
    evaluating arbitrary strings is not really a good idea, as the code being evaluated
    is insecure and may be malicious. In practice, we should always set the `*read-eval*`
    variable to `false` in order to prevent the evaluation of arbitrary code by functions
    such as `read` and `read-string`. Next, we will explore how *quoting* and *unquoting*
    can be used to transform expressions.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Quoting and unquoting code
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now explore *quoting* and *unquoting*, which are techniques used to
    generate expressions based on a predefined template for an expression. These techniques
    are foundational in creating macros, and they help structure the code of a macro
    to look more like its macroexpanded form.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c4/` `quoting.clj` of the
    book's source code.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quote` form simply returns an expression without evaluating it. This may
    seem trivial, but preventing the evaluation of an expression is actually something
    that is not possible in all programming languages. The `quote` form is abbreviated
    using the apostrophe character (`''`). If we *quote* an expression, it is returned
    in verbatim, as shown here:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The `quote` form is quite historic in Lisp. It is one of the seven primitive
    operators in the original Lisp language, as described in John McCarthy's paper.
    Incidentally, `quote` is one among the rare special forms that are implemented
    in Java and not in Clojure itself. The `quote` form is used to handle variable
    names, or *symbols*, as values. In a nutshell, using the `quote` form, we can
    treat a given expression as a list of symbols and values. After all, *Code is
    Data*.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An apostrophe (`'`) represents a quoted expression only when it appears as the
    first character in the expression. For example, `x'` is just a variable name.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: 'A syntax quote, written as a backtick character (`` ` ``), will quote an expression
    and allows *unquoting* to be performed within it. This construct allows us to
    create expressions just like quoting, but also has the added benefit of letting
    us interpolate values and execute arbitrary code in a quoted form. This has the
    effect of treating a predefined expression as a template with some parts left
    blank to be filled in later. An expression within a syntax quoted form can be
    unquoted using the tidal character (`~`). Unquoting an expression will evaluate
    it and insert the result into the surrounding syntax quoted form. A *splicing
    unquote*, written as `~@`, can be used to evaluate an expression that returns
    a list and use the returned list of values as arguments for a form. This is something
    like what the `apply` form does, except that it''s within the context of a syntax
    quote. We must note that both of these unquoting operations (`~` and `~@`) can
    only be used within a syntax quoted form. We can try out these operations in the
    REPL, as shown here:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'As shown here, unquoting the variable `a` in the preceding syntax quoted `list`
    form returns the expression `(list 1 2 3)`. Similarly, using a splicing unquote
    with the vector `[1 2 3]` returns the same list. On the other hand, unquoting
    a variable in a quoted form will expand the unquote reader macro (`~`) to a `clojure.core/unquote`
    form, as shown here:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'A more interesting difference between using a quote and a syntax quote is that
    the latter will resolve all variable names to namespace-qualified names. This
    applies to function names as well. For example, let''s look at the following expressions:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: As shown in the preceding output, the variables `x`, `y`, and `z` are resolved
    to `user/x`, `user/y`, and `user/z` respectively by the syntax quoted form, since
    `user` is the current namespace. Also, the `vector` function is translated to
    its namespace-qualified name, shown as `clojure.core/vector`. The unquote and
    quote operations in succession, shown as `~'`, can be used to bypass the resolution
    of a symbol to a namespace-qualified name.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: 'Quoting is supported on data structures other than lists, such as vectors,
    sets, and maps, as well. The effect of a syntax quote is the same on all of the
    data structures; it allows expressions to be unquoted within it, thus transforming
    the quoted form. Also, quoted forms can be nested, as in a quoted forms can contain
    other quoted forms. In such a case, the deepest quoted form is processed first.
    Consider the following quoted vectors:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'There are a lot of interesting aspects that can be inferred from the preceding
    output. Firstly, keywords are apparently not interned to namespace-qualified names
    such as symbols. In fact, this behavior is exhibited by any value that evaluates
    to itself, such as keywords, `nil`, `true`, and `false`, when used in a syntax
    quoted form. Other than that, unquoting followed by quoting an expression in a
    syntax quote, shown as `''~(+ 1 2)`, will evaluate the expression and wrap it
    in a quote. Conversely, unquoting a quoted symbol, shown as `~''b`, will prevent
    it from being resolved to a namespace-qualified name as we mentioned earlier.
    Let''s take a look at another example that uses nested quoting, as shown here:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: In the preceding output, the variables `first`, `second`, and `xs` are prevented
    from being interned to a namespace-qualified names using the quote (`'`) and unquote
    (`~`) operations in tandem. Anyone who's used older Lisps is probably cringing
    at this point. In practice, usage of the `~'` operation should actually be avoided.
    This is because preventing the resolution of a variable to a namespace-qualified
    name isn't really a good idea. In fact, unlike Clojure, some Lisps completely
    disallow it. It causes a peculiar problem called *symbol capture*, which we will
    see ahead while we explore macros.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: Transforming code
  id: totrans-824
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously described in this chapter, it's trivial to read and evaluate code
    in Clojure using the `read` and `eval` functions and their variants. Instead of
    evaluating code right after it is parsed, we can use macros to first transform
    code programmatically using quoting and unquoting, and then evaluate it. Thus,
    macros help us define our own constructs that rewrite and transform expressions
    passed to them. In this section, we will explore the basics of creating and using
    macros.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: Expanding macros
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros need to be *expanded* when they are called. All Clojure code is read,
    macroexpanded, and evaluated by the reader as we described earlier. Let's now
    take a look at how macroexpansion is performed. As you may have guessed already,
    this is done using plain Clojure functions.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the reader of the Clojure runtime also uses these functions
    to process a program''s source code. As an example, we will examine how the `->`
    threading macro is macroexpanded. The `->` macro can be used as shown here:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Note
  id: totrans-830
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples can be found in `src/m_clj/c4/macroexpand.clj` of the book's
    source code.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the three expressions using the `->` macro in the preceding output will
    be evaluated to the value `1`. This is due to the fact that they are all macroexpanded
    to produce the same final expression. How can we claim that? Well, we can prove
    it using the `macroexpand-1`, `macroexpand`, and `clojure.walk/macroexpand-all`
    functions. The `macroexpand` function returns the complete macroexpansion of a
    form, as shown here:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The expression using the `->` threading macro is thus transformed to the expression
    `(inc (first [0 1 2]))`, which evaluates to the value `1`. In this way, the `macroexpand`
    function allows us to inspect the macroexpanded form of an expression.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: 'The `macroexpand-1` function returns the first expansion of a macro. In fact,
    the `macroexpand` function simply applies the `macroexpand-1` function repeatedly
    until no more macroexpansion can be performed. We can inspect how the expression
    `(-> [0 1 2] (-> first inc))` is macroexpanded using these functions:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The `macroexpand` function has a small limitation. It only repeatedly macroexpands
    an expression until the first form in the expression is a macro. Hence, the `macroexpand`
    function will not completely macroexpand the expression `(-> (-> [0 1 2] first)
    inc)`, as shown here:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'As shown in the preceding example, the `macroexpand` function will return the
    same macroexpansion as `macroexpand-1`. This is because the second call to the
    `->` macro is not the first form in the result of the first macroexpansion for
    the previous expression. In such cases, we can use the `macroexpand-all` function
    from the `clojure.walk` namespace to macroexpand a given expression regardless
    of the positions of macro calls in it, as shown here:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Thus, all three expressions using the `->` macro as examples are macroexpanded
    to the same expression `(inc (first [0 1 2]))`, which is evaluated to the value
    `1`.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `macroexpand-1`, `macroexpand`, and `clojure.walk/macroexpand-all` functions
    will have no effect on an expression that does not contain any macros.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: The `macroexpand-1` and `macroexpand` functions are indispensable tools for
    debugging user-defined macros. Additionally, the `clojure.walk/macroexpand-all`
    function can be used in situations where the `macroexpand` function does not completely
    macroexpand a given expression. The Clojure reader also uses these functions for
    macroexpanding a program's source code.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: Creating macros
  id: totrans-845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros are defined using the `defmacro` form. A macro name, a vector of arguments
    for the macro, an optional doc-string, and the body of the macro have to be passed
    to this form. We can also specify multiple arities for a macro. Its similarity
    to the `defn` form is quite obvious. Unlike a `defn` form, however, a macro defined
    using the `defmacro` form will not evaluate the arguments passed to it. In other
    words, the arguments passed to a macro are implicitly quoted. For example, we
    can create a couple of macros to rewrite an s-expression in infix and postfix
    notation, as shown in *Example 4.1*.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '*Example 4.1: Macros to transform a prefix expression*'
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples can be found in `src/m_clj/c4/defmacro.clj` of the book's source
    code.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the macros in *Example 4.1* describes an elegant way to rewrite an
    expression `expr` by treating it as a generic sequence. The function being called
    in the expression `expr` is extracted using the `first` form, and its arguments
    are obtained using the `rest` form. To convert the expression to its infix form,
    we use the `interpose` function. Similarly, the `postfix` form of the expression
    `expr` is generated using the `concat` form. We can use the `macroexpand` function
    to inspect the expression generated by the `to-infix` and `to-postfix` macros,
    as shown here:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Note
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The expression `x + y` is said to be written in an *infix* notation. The *prefix*
    notation of this expression is `+ x y`, and its *postfix* notation is `x y +`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: In this way, by transforming expressions we can effectively modify the language.
    It's that simple! The basis of the `to-infix` and `to-postfix` macros in *Example
    4.1* are that we can treat the terms of an expression as a sequence of elements
    and manipulate them by using sequence functions such as `interpose` and `concat`.
    Of course, the preceding example was simple enough such that we could avoid the
    use of quoting altogether. The `defmacro` form can also be used in combination
    with quoting to easily rewrite more complex expressions. The same rule can be
    applied to *any* form of Clojure code.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, macros are internally represented as functions, and this can
    be verified by dereferencing the fully qualified name of a macro and using the
    `fn?` function, as shown here:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Note
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the time of writing this book, ClojureScript only supports macros written
    in Clojure. Macros have to be referenced using the `:require-macros` keyword in
    a ClojureScript namespace declaration, as shown here:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'The `symbol` and `gensym` functions can be used to create temporary variables
    for use within the body of a macro. The `symbol` function returns a symbol from
    a name and an optional namespace, as shown here:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Note
  id: totrans-863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can check whether a value is a symbol using the `symbol?` predicate.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gensym` function can be used to create a unique symbol name. We can specify
    a prefix to be used for the returned symbol name to the `gensym` function. The
    prefix is defaulted to a capital `G` character followed by two underscores (`G__`).
    The `gensym` function can also be used to create a new unique keyword. We can
    try out the `gensym` function in the REPL, as shown here:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'As shown here, the `gensym` function creates a new symbol every time it is
    called. In a syntax quoted form, we can use an automatic symbol name created from
    a prefixed name and the `gensym` function by using the hash character (`#`), shown
    as follows:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Note
  id: totrans-869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `let` form is, in fact, a macro defined using the `let*` special form.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding expression, all occurrences of the *auto-gensym* variable
    `x#` in the syntax quoted form are replaced with an automatically generated symbol
    name. We should note that only symbols, and not strings or keywords, can be used
    as a prefix for an auto-gensym symbol.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'By generating unique symbols in this way, we can create *hygenic macros*, which
    avoid the possibility of *symbol capture* or *variable capture*, which is an interesting
    problem that arises with the use of dynamically scoped variables and macros. To
    illustrate this problem, consider the macros defined in *Example 4.2*:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '*Example 4.2: Macros to depict symbol capture*'
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The macros in *Example 4.2* create a new list using a `list` form and the value
    `x`. Of course, we wouldn''t really need to use a macro here, but it is only done
    for the sake of demonstrating symbol capture. The `to-list-with-capture` macro
    *captures* the variable `x` from the surrounding scope by the use of the `~''`
    operation. If we use a `let` form to bind the variable name `x` with a value,
    we will get different results on calling the `to-list` and `to-list-with-capture`
    macros, as shown here:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The `to-list-with-capture` function seems to dynamically obtain the value of
    `x` from the surrounding scope, and not from the parameter passed to it. As you
    may have guessed, this can lead to a number of subtle and bizarre bugs. In Clojure,
    the solution to this problem is simple; a syntax quoted form will resolve all
    free symbols to namespace-qualified names. This can be verified by macroexpanding
    the expression that uses the `to-list` function in the preceding example.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we would like to use a temporary variable using a `let` form with
    a macro that performs the same task as the `to-list` macro from *Example 4.2*.
    This may seem rather unnecessary, but it is only being done to demonstrate how
    symbols are resolved by a syntax quote. Such a macro can be implemented as shown
    in *Example 4.3*:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Calling the `to-list-with-error` macro will result in an error due to the use
    of the free symbol `y`, as shown here:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'This error can be quite annoying, as we simply intended to use a temporary
    variable in the body of the `to-list-with-error` macro. This error occurred because
    it is not clear where the variable `y` is resolved from. To get around this error,
    we can declare the variable `y` as an auto-gensym variable, as shown in *Example
    4.4*:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '*Example 4.4: A macro that uses a let form and an auto-gensym variable*'
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `to-list-with-gensym` macro works as expected without any error, as shown
    here:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: We can also inspect the expression generated by the `to-list-with-gensym` macro
    using the `macroexpand` and `macroexpand-1` forms, and the reader is encouraged
    to try this in the REPL.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, macros defined using the `defmacro` form can be used to rewrite
    and transform code. Syntax quote and auto-gensym variables can be used to write
    hygenic macros that avoid certain problems that can arise due the use of dynamic
    scope.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Syntax quote can actually be implemented as a user defined macro. Libraries
    such as `syntax-quote` ([https://github.com/hiredman/syntax-quote](https://github.com/hiredman/syntax-quote))
    and `backtick` ([https://github.com/brandonbloom/backtick](https://github.com/brandonbloom/backtick))
    demonstrate how syntax quote can be implemented through macros.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating patterns in macros
  id: totrans-891
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Clojure, macros can be used to rewrite expressions in terms of functions
    and special forms. However, in languages such as Java and C#, there is a lot of
    additional syntax added to the language for handling special forms. For example,
    consider the `if` construct in these languages, which is used to check whether
    an expression is true or not. This construct does have some special syntax. If
    a recurring pattern of usage of the `if` construct is found in a program written
    in these languages, there is no obvious way to automate this pattern. Languages
    such as Java and C# have the concept of *design patterns* that encapsulate these
    sort of patterns. But without the ability to rewrite expressions, encapsulating
    patterns in these languages can get a bit incomplete and cumbersome. The more
    special forms and syntax we add to a language, the harder it gets to programmatically
    generate code for the language. On the other hand, macros in Clojure and other
    Lisps can easily rewrite expressions to automate recurring patterns in code. Also,
    there is more-or-less no special syntax for code in Lisps, as code and data are
    one and the same. In a way, macros in Lispy languages allow us to concisely encapsulate
    design patterns by extending the language with our own hand-made constructs.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore a few examples that demonstrate how macros can be used to encapsulate
    patterns. The `->` and `->>` threading macros in Clojure are used to compose several
    functions together by passing in an initial value. In other words, the initial
    value is *threaded* through the various forms that are passed as arguments to
    the `->` and `->>` macros. These macros are defined in the `clojure.core` namespace
    as part of the Clojure language, as shown in *Example 4.5*.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c4/threading.clj` of the book's
    source code.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '*Example 4.5: The -> and ->> threading macros*'
  id: totrans-897
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `->` and `->>` macros in *Example 4.5* use a `loop` form to recursively
    thread a value `x` through the expressions represented by `forms`. The first symbol
    in a form, that is the function being called, is determined using the `first`
    function. The arguments to be passed in this function, other than `x`, are extracted
    using the `next` function. If a form is just a function name without any additional
    arguments, we create a new form using the expression `(list form x)`. The `with-meta`
    form is used to preserve any metadata specified with `form`. The `->` macro passes
    `x` as the first argument, whereas `->>` passes `x` as the last argument. This
    is done in a recursive manner for all the forms passed to these macros. Interestingly,
    syntax quoted forms are used sparingly by both of the `->` and `->>` macros. We
    can actually refactor out some parts of these macros into functions. This adds
    a slight advantage as functions can be tested quite easily compared to macros.
    The `->` and `->>` threading macros can be refactored as shown in *Example 4.6*
    and *Example 4.7*:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '*Example 4.6: Refactoring the -> and ->> threading macros*'
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `thread-form` function in *Example 4.6* positions the value `x` in the
    expression form using the `conj` function. The premise here is that the `conj`
    function will add an element in the head of a list and at the end or tail of a
    vector. The `first?` argument is used to indicate whether the value `x` has to
    be passed as the first argument to `form`. The `threading` function simply applies
    the `thread-form` function to all the expressions passed to it, represented by
    `forms`. The macros `->` and `->>` can now be implemented using the `threading`
    function as shown in *Example 4.7*:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '*Example 4.7: Refactoring the -> and ->> threading macros (continued)*'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The threading macros defined in *Example 4.7* work just as well as the ones
    in *Example 4.5*, and we can verify this in the REPL. This is left as an exercise
    for the reader.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: A common pattern of usage of the `let` form is to repeatedly rebind a variable
    to new values by passing it through several functions. This kind of pattern can
    be encapsulated using the `as->` threading macro, which is defined as shown in
    *Example 4.8*.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '*Example 4.8: Refactoring the -> and ->> threading macros*'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s skip past explaining the details of the `as->` macro through words and
    simply describe the code it generates using the `macroexpand` function, as shown
    here:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The `as->` macro binds its first argument to a symbol represented by its second
    argument and generates a `let*` form as a result. This allows us to define expressions
    that have to be threaded over in terms of an explicit symbol. One might even say
    it's a more flexible way to perform the threading of a value through several expressions,
    as compared to using the `->` and `->>` macros.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-911
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `as->` form has been introduced in Clojure 1.5 along with several other
    threading macros.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: Thus, macros are great tools in automating or encapsulating patterns in code.
    Several commonly used forms in the Clojure language are actually defined as macros,
    and we can just as easily define our own macros.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: Using reader conditionals
  id: totrans-914
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often necessary to interoperate with native objects in Clojure and its
    dialects such as ClojureScript. We can define platform-specific code using *reader
    conditionals*. Let's now briefly take a look at how we can use reader conditionals.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reader conditionals have been introduced in Clojure 1.7\. Prior to version 1.7,
    platform-specific Clojure/ClojureScript code had to be managed using the `cljx`
    library ([https://github.com/lynaghk/cljx](https://github.com/lynaghk/cljx)).
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: The *reader conditional form*, written as `#?( ... )`, allows us to define platform-specific
    code using the `:cljs`, `:clj`, `:clr`, and `:default` keywords. The *reader conditional
    splicing form*, written as `#?@( ... )`, has semantics similar to a reader conditional
    form. It can be used to splice a list of platform-specific values or expressions
    into a form. Both these conditional forms are processed when code is read, instead
    of when it is macroexpanded.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Clojure 1.7, the `read-string` function has a second arity in which we
    can specify a map as an argument. This map can have two keys, `:read-cond` and
    `:features`. When a string containing a conditional form is passed to the `read-string`
    function, platform-specific code can be generated by specifying the platform as
    a set of keywords, represented by `:cljs`, `:clj`, or `:clr`, with the `:features`
    key in the map of options. In this case, the keyword `:allow` must be specified
    for the key `:read-cond` in the map passed to the `read-string` function, or else
    an exception will be thrown. We can try out the reader conditional form with the
    `read-string` function in the REPL as shown here:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Note
  id: totrans-921
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples can be found in `src/m_clj/c4/reader_conditionals.cljc` of the
    book's source code.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can read a conditional splicing form into an expression with
    the `read-string` function as shown here:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'We can also prevent the transformation of conditional forms by specifying the
    `:preserve` keyword with the `:read-cond` key in the optional map passed to the
    `read-string` function, as shown here:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'However, wrapping conditional forms in a string is not really something we
    should be doing in practice. Generally, we should write all platform-specific
    code as reader conditional forms in source files with the `.cljc` extension. Once
    the top-level forms defined in the `.cljc` file are processed by the Clojure reader,
    we can use them just like any other reader forms. For example, consider the macro
    written using a reader conditional form in *Example 4.9*:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '*Example 4.9: A macro using a reader conditional*'
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `get-milliseconds-since-epoch` macro in *Example 4.9* calls the `.getTime`
    method on a new `java.util.Date` instance when called from the Clojure code. Also,
    this macro calls the `.getTime` method on a new JavaScript `Date` object when
    used in ClojureScript code. We can macroexpand a call to the `get-milliseconds-since-epoch`
    macro from the Clojure REPL to generate JVM-specific code, as shown here:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Thus, reader conditionals help in encapsulating platform-specific code to be
    used in code that is agnostic of the underlying platform.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding macros
  id: totrans-933
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Macros are an extremely flexible way of defining our own constructs in Clojure.
    However, careless use of macros in a program can become complicated and lead to
    a number of strange bugs that are hidden from plain sight. As described in the
    book, *Programming Clojure* by *Stuart Halloway* and *Aaron Bedra*, the usage
    of macros in Clojure has two thumb rules:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t write macros**: Anytime we try to use a macro, we must think twice
    whether we could perform the same task using a function.'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write macros if it''s the only way to encapsulate a pattern**: A macro must
    be used only if it is easier or more convenient than calling a function.'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s the problem with macros? Well, macros complicate a program''s code
    in several ways:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: Macros cannot be composed like functions as they are not really values. It's
    not possible to pass a macro as an argument to the `map` or `apply` forms, for
    example.
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros cannot be tested as easily as functions. Though it can be done programmatically,
    the only way to test macros is by using macroexpansion functions and quoting.
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, code that calls a macro may have been written as a macro itself,
    thus adding more complexity to our code.
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden bugs caused by problems such as symbol capture make macros a little tricky.
    Debugging macros isn't really easy either, especially in a large codebase.
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, macros have to be used carefully and responsibly. In fact,
    if we can solve a problem using macros as well functions, we should always prefer
    the solution that uses functions. If the use of a macro is indeed required, we
    should always strive to refactor out as much code as possible from a macro into
    a function.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: That aside, macros make programming a lot of fun as they allow us to define
    our own constructs. They allow a degree of freedom and liberty that is not really
    possible in other languages. You may hear a lot of seasoned Clojure programmers
    tell you that macros are evil and you should never use them, but don't let that
    stop you from exploring what is possible with macros. Once you encounter and tackle
    some of the problems that arise with the use of macros, you will have enough experience
    to be able to decide when macros can be used appropriately.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-944
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored how metaprogramming is possible with Clojure in this chapter.
    We discussed how code is read, macroexpanded, and evaluated, as well as the various
    primitive constructs that implement these operations. Macros can be used to encapsulate
    patterns in code, as we demonstrated in the various examples in this chapter.
    Toward the end of the chapter, we also talked about reader conditionals and pointed
    out the various complications that arise with the use of macros.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore how transducers can be used to process
    any data regardless of the source of the data.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Composing Transducers
  id: totrans-947
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get back to our journey of performing computations over data in Clojure.
    We've already discussed how *reducers* can be used to process collections in [Chapter
    3](ch18.html "Chapter 3. Parallelization Using Reducers"), *Parallelization Using
    Reducers*. Transducers are, in fact, a generalization of reducers that are independent
    of the source of data. Also, reducers are more about parallelization, while transducers
    are more focused on generalizing data transformations without restricting us to
    any particular source of data. Transducers capture the essence of the standard
    functions that operate on sequences, such as `map` and `filter`, for several sources
    of data. They allow us to define and compose transformations of data regardless
    of how the data is supplied to us.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, in the context of physics, a transducer is a device that converts
    a signal from one form of energy into another form. In a way, Clojure transducers
    can be thought of as ways to capture the *energy* in functions, such as `map`
    and `filter`, and convert between different sources of data. These sources include
    collections, streams, and asynchronous channels. Transducers can also be extended
    to other sources of data. In this chapter, we will focus on how transducers can
    be used for sequences and collections, and will reserve discussing transducers
    with asynchronous channels until we talk about the `core.async` library in [Chapter
    8](ch23.html "Chapter 8. Leveraging Asynchronous Tasks"), *Leveraging Asynchronous
    Tasks*. Later in this chapter, we will study how transducers are implemented in
    Clojure.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: Understanding transducers
  id: totrans-950
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transducers are essentially a stack of transformations that can be composed
    and applied to *any* representation of data. They allow us to define transformations
    that are agnostic of implementation-specific details about the source of the supplied
    data. Transducers also have a significant performance benefit. This is attributed
    to the avoidance of unnecessary memory allocations for arbitrary containers, such
    as sequences or other collections, to store intermediate results between transformations.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transducers have been introduced in Clojure 1.7.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: Transformations can be composed without the use of transducers as well. This
    can be done using the `comp` and `partial` forms. We can pass any number of transformations
    to the `comp` function, and the transformation returned by the `comp` function
    will be a composition of the supplied transformations in the right-to-left order.
    In Clojure, a transformation is conventionally denoted as `xf` or `xform`.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-955
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c5/transduce.clj` of the book's
    source code.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the expression `(comp f g)` will return a function that applies
    the function `g` to its input and then applies the function `f` to the result.
    The `partial` function will bind a function to any number of arguments and return
    a new function. The `comp` function can be used with a `partial` form to compose
    the `map` and `filter` functions, as shown here:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'In the preceding output, the `partial` function is used to bind the `inc` and
    `even?` functions to the `map` and `filter` functions respectively. The functions
    returned by both the `partial` forms shown above will expect a collection to be
    passed to them. Thus, they represent transformations that can be applied to a
    given collection. These two transformations are then composed with the `comp`
    function to create a new function `xf-using-partial`. This function is then applied
    to a vector of numbers to return a sequence of even numbers. There are a few issues
    with this code:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: The filtering of even numbers using the `even?` function is performed after
    applying the `inc` function. This proves that the transformations passed to the
    `comp` function are applied in the right-to-left order, which is the reverse of
    the order in which they are specified. This can be a little inconvenient at times.
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value returned by the `xf-using-partial` function is a list and not a vector.
    This is because the `map` and `filter` function both return lazy sequences, which
    are ultimately converted into lists. Thus, the use of the `vec` function has no
    effect on the type of collection returned by the `xf-using-partial` function.
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the transformation `(partial map inc)` applied by the `xf-using-partial`
    function will create a new sequence. This resulting sequence is then passed to
    the transformation `(partial filter even?)`. The intermediate use of a sequence
    is both unnecessary and wasteful in terms of memory if we have several transformations
    that must be composed.
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This brings us to transducers, which address the preceding problems related
    to composing transformations using the `comp` and `partial` forms. In the formal
    sense, a transducer is a function that modifies a *step function*. This step function
    is analogous to a reducing function in the context of reducers. A step function
    combines an input value with the accumulated result of a given computation. A
    transducer accepts a step function as an argument and produces a modified version
    of it. In fact, the `xf` and `xform` notations are also used to represent a transducer;
    because a transducer is also a transformation, it transforms a step function.
    While it may be hard to illustrate without any code, this modification of a step
    function performed by a transducer actually depicts how some input data is consumed
    by a given computation to produce a result. Several transducers can also be composed
    together. In this way, transducers can be thought of as a unified model to process
    data.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: 'Several of the standard Clojure functions return a transducer when they are
    called with a single argument. These functions either:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: Accept a function along with a collection as arguments. Examples of such functions
    are `map`, `filter`, `mapcat`, and `partition-by`.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept a value indicating the number of elements, usually specified as `n`,
    along with a collection. This category includes functions such as `take`, `drop`,
    and `partition-all`.
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-967
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [http://clojure.org/transducers](http://clojure.org/transducers) for the
    complete list of standard functions that implement transducers.
  id: totrans-968
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of transducers can be aptly depicted by Rich Hickey's baggage loading
    example. Suppose we intend to load several bags into an airplane. The bags will
    be supplied in pallets, which can be thought of as collections of bags. There
    are several steps that have to be performed to load the bags into the airplane.
    Firstly, the bags must be unbundled from the supplied pallets. Next, we must check
    whether a bag contains any food, and not process it any further if it does. Finally,
    all the bags must be weighed and labeled in case they are heavy. Note that these
    steps needed to load the bags into the airplane do not specify how the pallets
    are supplied to us, or how the labeled bags from the final step are transported
    to the plane.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: 'We can model the process of loading the bags into the plane as shown in the
    `process-bags` function in *Example 5.1*, as follows:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '*Example 5.1: Loading bags into an airplane*'
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The functions `unbundle-pallet`, `non-food?`, and `label-heavy` in *Example
    5.1* represent the three steps of loading bags into an airplane. These functions
    are applied to a collection of bags using the `map`, `filter`, and `mapcat` functions.
    Also, they can be composed using the `comp` and `partial` functions in a right-to-left
    order. As we described earlier, the `map`, `filter`, and `mapcat` functions will
    all produce sequences on being called, hence creating intermediate collections
    of bags between the three transformations. This intermediate use of sequences
    is analogous to putting all the bags on trollies after the step is performed.
    The supplied input and the final result would both be a bag of trollies. The use
    of trollies not only incurs additional work between the steps of our process,
    but the steps are now convoluted with the use of trollies. Thus, we would have
    to redefine these steps if we had to use, say, conveyer belts instead of trollies
    to transport the baggage. This means that the `map`, `filter`, and `mapcat` functions
    would have to be implemented again if we intend to produce a different type of
    collection as a final result. Alternatively, we can use transducers to implement
    the `process-bags` function without specifying the type of collection of either
    the input or the result, as shown in *Example 5.2*:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '*Example 5.2: Loading bags into an airplane using transducers*'
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `process-bags` function in *Example 5.2* shows how transducers can be used
    to compose the `unbundle-pallet`, `non-food?`, and `label-heavy` functions in
    a left-to-right order. Each of the expressions passed to the `comp` function in
    *Example 5.2* return a transducer. This implementation of the `process-bags` function
    does not create any intermediary collections when it is executed.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: Producing results from transducers
  id: totrans-977
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transducers are only recipes for computations, and are not capable of performing
    any actual work on their own. A transducer can produce results when coupled with
    a source of data. There's also another vital piece of the puzzle, that is, the
    step function. To combine a transducer, a step function, and a source of data,
    we must use the `tranduce` function.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: 'The step function passed to `transduce` is also used to create the initial
    value of the result to be produced. This initial value of the result can also
    be specified as an argument to the `transduce` function. For example, the `transduce`
    function can be used with the `conj` form is shown as follows:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The `inc` function is coupled with the `map` function to create a transducer
    `xf`, as shown previously. The `transduce` function can be used to produce either
    a list or a vector from the transducer `xf` using the `conj` function. The order
    of elements in the results of both the `transduce` forms shown previously is different
    due to the fact that the `conj` function will add an element to the head of a
    list, as opposed to adding it at the end of a vector.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also compose several transducers together using the `comp` function,
    as shown here:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'The transducer `xf` in the preceding output encapsulates the application of
    the `inc` and `even?` functions using the `map` and `filter` forms respectively.
    This transducer will produce a vector of even numbers when used with the `transduce`
    and `conj` forms. Note that the `inc` function is indeed applied to the supplied
    collection `(range 10)`, or else the value `10` would not show up in the final
    result. This computation using the transducer `xf` can be illustrated as follows:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '![Producing results from transducers](img/B05024_5_01.jpg)'
  id: totrans-985
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts how the transformations `(map inc)`, `(filter
    even?)`, and `conj` are composed in the transformation `xf`. The `map` form is
    applied first, followed by the `filter` form, and finally the `conj` form. In
    this manner, transducers can be used to compose a series of transformations for
    any source of data.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to produce a collection from a transducer is by using the `into`
    function. The result of this function depends on the initial collection supplied
    to it as the first argument, as shown here:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'The standard `sequence` function can also be used to produce a lazy sequence
    from a transducer. Of course, the returned lazy sequence will be converted to
    a list in the REPL, as shown here:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: So far, we've composed transducers to produce collections with a finite number
    of elements. An infinite series of values could also be produced by a transducer
    when used with the `sequence` function. The `eduction` function can be used to
    represent this sort of computation. This function will transform a collection,
    specified as its last argument, to any number of transformations passed to it
    in right-to-left order. An `eduction` form may also require a fewer number of
    allocations compared to using a sequence.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we were to retrieve the 100th element in a sequence using the
    `nth` function, the first 99 elements would have to be realized and also discarded
    later as they are not needed. On the other hand, an `eduction` form can avoid
    this overhead. Consider the declaration of `simple-eduction` in *Example 5.3*:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '*Example 5.3: Using the eduction function*'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The collection `simple-eduction` shown in *Example 5.3* will first filter out
    even values using the `even?` predicate from the infinite range `(range)` and
    then increment the resulting values using the `inc` function. We can retrieve
    elements from the collection `simple-eduction` using the `nth` function. The same
    computation can also be modeled using lazy sequences, but transducers perform
    much better, as shown here:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The `eduction` form using a transducer performs twice as fast compared to a
    sequence! From the output shown previously, it is quite clear that transducers
    perform significantly better than lazy sequences for composing a number of transformations.
    In summary, transducers created using functions such as `map` and `filter` can
    be easily composed to produce collections using functions such as `transduce`,
    `into`, and `eduction`. We can also use transducers with other sources of data
    such as streams, asynchronous channels, and observables.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: Comparing transducers and reducers
  id: totrans-998
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both transducers and reducers, which were discussed in [Chapter 3](ch18.html
    "Chapter 3. Parallelization Using Reducers"), *Parallelization Using Reducers,*
    are ways to improve the performance of computations performed over collections.
    While transducers are a generalization of data processing for multiple data sources,
    there are a few other subtle differences between transducers and reducers, which
    are described as follows:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: Transducers are implemented as part of the Clojure language in the `clojure.core`
    namespace. However, reducers must be explicitly included in a program, as they
    are implemented in the `clojure.core.reducers` namespace.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transducers only create a collection when producing the final result of a series
    of transformations. There are no intermediary collections required to store the
    results of a transformation that constitutes a transducer. On the other hand,
    reducers produce intermediate collections to store results, and only avoid the
    creation of unnecessary empty collections.
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transducers deal with efficient composition of a series of transformations.
    This is quite orthogonal to how reducers squeeze out performance from a computation
    performed over a collection through the use of parallelization. Transducers perform
    significantly better than both the `reduce` functions from the `clojure.core`
    and `clojure.core.reducers` namespaces. Of course, using the `clojure.core.reducers/fold`
    function is still a good way to implement a computation that can be parallelized.
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These contrasts between transducers and reducers describe how these two methodologies
    of processing data are different. In practice, the performance of these techniques
    depends on the actual computation being implemented. Generally, if we intend to
    implement an algorithm to process data in a performant way, we should use transducers.
    On the other hand, if we are dealing with a lot of data in the memory with no
    need for I/O and laziness, we should use reducers. The reader is encouraged to
    compare the performance of the `transduce` function with that of the `reduce`
    and `fold` functions of the `clojure.core.reducers` library for different computations
    and data sources.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: Transducers in action
  id: totrans-1004
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine how transducers are implemented. We will also
    get a basic idea of how our own *transducible* source of data can be implemented.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: Managing volatile references
  id: totrans-1006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some transducers can internally use state. It turns out that the existing reference
    types, such as atoms and refs, aren't fast enough for the implementation of transducers.
    To circumvent this problem, transducers also introduce a new *volatile* reference
    type. A volatile reference represents a mutable variable that will not be copied
    into the thread-local cache. Also, volatile references are not atomic. They are
    implemented in Java using the `volatile` keyword with a `java.lang.Object` type.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1008
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c5/volatile.clj` of the book's
    source code.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new volatile reference using the `volatile!` function. The
    value contained in the volatile state can then be retrieved using the `@` reader
    macro or a `deref` form. The `vreset!` function can be used to set the state of
    a volatile reference, as shown here:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'In the preceding output, we encapsulate the value `0` in a volatile state,
    and then set its state to `1` using the `vreset!` function. We can also mutate
    the state contained in a volatile reference using the `vswap!` function. We will
    have to pass a volatile reference and a function to be applied to the value contained
    in the reference to this function. We can also specify any other arguments for
    the supplied function as additional arguments to the `vswap!` function. The `vswap!`
    function can be used to change the state of the volatile reference `v` that we
    previously defined, as shown here:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The first call to the `vswap!` function in the preceding output uses the `inc`
    function to increment the value stored in the reference `v`. Similarly, the subsequent
    call to the `vswap!` function adds the value `3` to the new value in the volatile
    reference `v`, thus producing the final value `5`.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1015
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can check whether a value is a volatile using the `volatile?` predicate.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: One may argue that the volatile reference type has the same semantics as that
    of an atom. The `vreset!` and `vswap!` functions have the exact same shape as
    the `reset!` and `swap!` functions that are used with atoms. However, there is
    an important difference between a volatile reference and an atom. Unlike an atom,
    a volatile reference does not guarantee atomicity of operations performed on it.
    Hence, it's recommended to use volatile references in a single thread.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: Creating transducers
  id: totrans-1018
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a transducer modifies a supplied step function, let''s first define what
    a step function actually does. The following aspects need to be considered:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: The step function must be able to provide an initial value to the transformation
    it models. In other words, the step function must have an *identity* form that
    takes no arguments.
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputs must be combined with the result accumulated so far by the computation.
    This is analogous to how a reducing function combines an input value with an accumulated
    result to produce a new result. The arity of this form is also the same as that
    of a reducing function; it requires two arguments to represent the current input
    and the accumulated result.
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The step function must also be able to complete the computation of the modeled
    process to return something. This can be implemented as a function that accepts
    a single argument that represents the accumulated result.
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, a step function is represented as a function with three arities, as described
    previously. *Early termination* may also be needed by some transducers to abruptly
    stop a computational process based on certain conditions.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how some of the standard functions in the `clojure.core`
    namespace are implemented with transducers. The `map` function returns a transducer
    when called with a single argument.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1025
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c5/` `implementing_transducers.clj`
    of the book's source code.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: 'The following *Example 5.4* describes how the `map` function is implemented:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '*Example 5.4: The map function*'
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The 1-arity form of the `map` function returns a function that accepts a step
    function, represented by `step`, and returns another step function. The returned
    step function has three different arities, just like we described earlier in this
    section. The essence of the `map` function is described by the expression `(step
    result (f input))`, which translates to "apply the function `f` on the current
    input `input` and combine it with the accumulated result `result` using the function
    `step`". The returned step function also has two other arities—one that takes
    no arguments and another that takes one argument. These arities correspond to
    the other two cases of a step function that we described earlier.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: The second arity of the `map` function, which returns a collection and not a
    transducer, is merely a composition of the `sequence` function and the transducer
    returned by the expression `(map f)`. The actual creation of a collection is done
    by the `sequence` function. The 1-arity form of the `map` function only describes
    how the function `f` is applied over a transducible context such as a collection.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `filter` function can be implemented using a transducer, as
    shown in *Example 5.5*, as follows:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '*Example 5.5: The filter function*'
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The premise in the implementation of the `filter` function is that a predicate
    `p?` is used to conditionally combine the accumulated result and the current input,
    which are represented by `result` and `input` respectively. If the expression
    `(p? input)` does not return a truthy value, the accumulated result is returned
    without any modification. Similar to the map function in *Example 5.4*, the 2-arity
    form of the filter function is implemented using a `sequence` form and a transducer.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle early termination in transducers, we must use the `reduced` and `reduced?`
    functions. Calling reduce or a step function on a value that has been wrapped
    in a `reduced` form will simply return the contained value. The `reduced?` function
    checks whether a value is already *reduced*, that is, wrapped in a `reduced` form.
    The `reduced` and `reduced?` forms both accept a single argument, as shown here:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Consider the following function `rf` in *Example 5.6* that uses a `reduced`
    form to ensure that the accumulated result is never more than 100 elements:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '*Example 5.6: Using the reduced function*'
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The function `rf` merely sums up all inputs to produce a result. If the `rf`
    function is passed to the `reduce` function along with a sufficiently large collection,
    the `:too-big` value is returned as the final result, as shown here:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: A value wrapped in a `reduced` form can be extracted using the `unreduced` function
    or the `@` reader macro. Also, the `ensure-reduced` function can be used instead
    of `reduced` to avoid re-applying a `reduced` form to a value that has already
    been reduced.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard `take-while` function can be implemented using a `reduced` form
    and a transducer, as shown in the following *Example 5.7*:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '*Example 5.7: The take-while function*'
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that only the 1-arity form of the `take-while` function is described in
    *Example 5.7*. The step function returned by the `take-while` function uses the
    expression `(p? input)` to check if the accumulated result has to be combined
    with the current input. If the `p?` predicate does not return a truthy value,
    the accumulated result is returned by wrapping it in a `reduced` form. This prevents
    any other transformations, which may be composed with the transformation returned
    by the `take-while` function, from modifying the accumulated result any further.
    In this way, the `reduced` form can be used to wrap the result of a transducer
    and perform early termination based on some conditional logic.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how a stateful transducer is implemented. The `take` function
    returns a transducer that maintains an internal state. This state is used to keep
    a track of the number of items that have been processed so far, since the `take`
    function must only return a certain number of items from a collection or any other
    transducible context by definition. *Example 5.8* describes how the `take` function
    is implemented using a volatile reference to maintain state:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '*Example 5.8: The take function*'
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The transducer returned by the `take` function will first create a volatile
    reference `nv` from the supplied value `n` to track the number of items to be
    processed. The returned step function then decrements the volatile reference `nv`
    and combines the result with the input using the `step` function. This is done
    repeatedly until the value contained in the reference `nv` is positive. Once all
    `n` items have been processed, the result is wrapped in an `ensure-reduced` form
    to signal early termination. Here, the `ensure-reduced` function is used to prevent
    wrapping the value `result` in another `reduced` form, since the expression `(step
    result input)` could return a value that is already reduced.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a quick look at how the `transduce` function is implemented,
    as shown in *Example 5.9*:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '*Example 5.9: The transduce function*'
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `transduce` function has two arities. The 4-arity form of the `transduce`
    function calls the `.reduce` method of the transducible context `coll` if it is
    an instance of the `clojure.lang.IReduceInit` interface. This interface defines
    a single method `reduce` that represents how a data source is reduced using a
    given function and an initial value. If the variable `coll` does not implement
    this interface, the `transduce` function will fall back on the `coll-reduce` function
    to process the data source represented by `coll`. In a nutshell, the `transduce`
    function will try to process a transducible context in the fastest possible way.
    The `clojure.lang.IReduceInit` interface must be implemented by all data sources
    that must support the use of `transduce`.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: The 3-arity form of the `transduce` function produces the initial value for
    the transduction by invoking the supplied function `f` without any arguments.
    Thus, this arity of the `transduce` function can only be used with functions that
    provide an identity value.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The definitions of the `map`, `filter`, `take`, and `take-while` functions,
    as shown in this section, are simplified versions of their actual definitions.
    However, the `transduce` function is shown exactly as it is implemented in the
    `clojure.core` namespace.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: This depicts how transducers and the `transduce` function are implemented. If
    we need to implement our own transducible source of data, the implementations
    described in this section can be used as a guideline.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1060
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how we can process data using sequences, reducers, and
    transducers. In this chapter, we described how transducers can be used for performant
    computations. We also briefly studied how transducers are implemented in the Clojure
    language.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore algebraic data structures, such as
    functors, applicatives, and monads, in Clojure. These concepts will deepen our
    understanding of functional composition, which is the keystone of functional programming.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Exploring Category Theory
  id: totrans-1063
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a journey into functional programming, a programmer will eventually stumble
    upon *category theory*. First off, let''s just say that the study of category
    theory is not really needed to write better code. It''s more prevalent in the
    internals of pure functional programming languages, such as Haskell and Idris,
    in which functions are *pure* and more like mathematical functions that do not
    have implicit side effects such as I/O and mutation. However, category theory
    helps us reason about a very fundamental and practical aspect of computation:
    *composition*. Functions in Clojure, unlike in pure functional programming languages,
    are quite different from mathematical functions as they can perform I/O and other
    side effects. Of course, they can be pure under certain circumstances, and thus
    concepts from category theory are still useful in Clojure for writing reusable
    and composable code based on pure functions.'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: Category theory can be thought of as a mathematical framework for modeling composition.
    In this chapter, we will discuss a few concepts from category theory using Clojure.
    We will also study a few algebraic types, such as functors, monoids, and monads.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying category theory
  id: totrans-1066
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Category theory has its own share of quirky notations and conventions. Let's
    start off by exploring some of the terminology used in category theory, in a language
    understandable by us mortal programmers.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: 'A *category* is formally defined as a collection of **objects** and **morphisms**.
    In simple terms, objects represent abstract types, and morphisms represent functions
    that convert between these types. A category is thus analogous to a programming
    language that has a few types and functions, and has two basic properties:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: There exists an *identity morphism* for each object in the category. In practice,
    a single identity function can be used to represent the identity morphism for
    all given objects, but this is not mandatory.
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphisms in a category can be composed together into a new morphism. In fact,
    a composition of two or more morphisms is an optimization of applying the individual
    morphisms one at a time. In this way, the composition of several morphisms is
    said to *commute* with applying the constituting morphisms.
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Morphisms in a category can be composed as illustrated by the following diagram:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '![Demystifying category theory](img/B05024_06_01.jpg)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the vertices *A*, *B*, and *C* are the objects and
    the arrows are morphisms between these objects. The morphisms *I[A]*, *I[B]*,
    and *I[C]* are identity morphisms that map the objects *A*, *B*, and *C* to themselves.
    The morphism *f* maps *A* to *B*, and similarly the morphism *g* maps *B* to *C*.
    These two morphisms can be composed together, as represented by the morphism ![Demystifying
    category theory](img/4900_06_07.jpg) that maps *A* directly to *C*, and hence
    the morphism ![Demystifying category theory](img/4900_06_07.jpg) *commutes* with
    the morphisms *f* and *g*. For this reason, the preceding diagram is termed as
    a *commutative diagram*. Note that identity morphisms in a commutative diagram
    are generally not shown, unlike in the preceding diagram.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c6/` `demystifying_cat_theory.clj`
    of the book's source code.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s translate the previous diagram to Clojure. We shall use the built-in
    string, symbol and keyword types to depict how morphisms, or rather functions,
    between these types can be composed together using the `comp` function:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '![Demystifying category theory](img/B05024_06_02.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the `name` function converts a keyword to
    a string, and the `symbol` function converts a string to a symbol. These two functions
    can be composed into a function that converts a keyword directly to a symbol,
    represented by the `(comp symbol name)` function. Also, the identity morphisms
    for each category translate to the `identity` function.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, the string, symbol, and keyword types are represented by the `java.lang.String`,
    `clojure.lang.Symbol` and `clojure.lang.Keyword` classes respectively.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that the `name` and `symbol` functions can be composed together
    using the `comp` form, as shown in the following REPL output:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: This establishes the fact that concepts from category theory have equivalent
    representations in Clojure, and other programming languages as well. Although
    it is perfectly valid to think about objects in a category as concrete types like
    we just described, *algebraic structures* are a more practical substitute for
    objects. Algebraic structures describe abstract properties of types, rather than
    what data is contained in a type or how data is structured by a type, and are
    more like abstract types. Thus, category theory is all about composing functions
    that operate on abstract types with certain properties.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, algebraic structures can be thought of as protocols. Concrete types
    can implement protocols, and hence a type can represent more than one algebraic
    structure. The `cats` library ([https://github.com/funcool/cats](https://github.com/funcool/cats))
    takes this approach and provides protocol-based definitions of a few interesting
    algebraic structures. The `cats` library also provides types that implement these
    protocols. Additionally, this library extends some of the built-in types through
    these protocols allowing us to treat them as algebraic structures. Although there
    are several alternatives, `cats` is the only library compatible with ClojureScript.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1085
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Now, let's study some of the algebraic structures from the `cats` library.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: Using monoids
  id: totrans-1091
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by exploring **monoids**. In order to define a monoid, we must first
    understand what a semigroup is.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1093
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c6/` `monoids.clj` of the
    book's source code.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: A *semigroup* is an algebraic structure that supports an associative binary
    operation. A binary operation, say ![Using monoids](img/4900_06_08.jpg), is termed
    *associative* if the operation ![Using monoids](img/4900_06_09.jpg) produces the
    same result as the operation ![Using monoids](img/4900_06_10.jpg). A monoid is
    in fact a semigroup with an additional property, as we will see ahead.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mappend` function from the `cats.core` namespace will associatively combine
    a number of instances of the same type and return a new instance of the given
    type. If we are dealing with strings or vectors, the `mappend` operation is implemented
    by the standard `concat` function. Thus, strings and vectors can be combined using
    the `mappend` function, as shown here:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: As strings and vectors support the associative `mappend` operation, they are
    semigroups. They are also *monoids*, which are simply semigroups that have an
    *identity element*. It's fairly obvious that the identity element for strings
    is an empty string, and for vectors it's an empty vector.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: This is a good time to introduce a versatile concrete type from the world of
    functional programming—the `Maybe` type. The `Maybe` type represents an optional
    value, and can either be empty or contain a value. It can be thought of as a value
    in a context or a container. The `just` and `nothing` functions from the `cats.monads.maybe`
    namespace can be used to construct an instance of the `Maybe` type. The `just`
    function constructs an instance with a contained value, and the `nothing` function
    creates an empty `Maybe` value. The value contained in a `Maybe` instance can
    be obtained by either passing it to the `cats.monads.maybe/from-maybe` function,
    or dereferencing it (using the `deref` form or the `@` reader macro).
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: 'Incidentally, the `Maybe` type is also a monoid, since an empty `Maybe` value,
    created using the `nothing` function, is analogous to an identity element. We
    can use the `mappend` function to combine values of the `Maybe` type, just like
    any other monoid, as shown here:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: The `mappend` function can thus be used to associatively combine any values
    that are monoids.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: Using functors
  id: totrans-1103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's take a look at **functors**. A functor is essentially a value in
    a container or a computational context. The `fmap` function must be implemented
    by a functor. This function applies a supplied function to the value contained
    in a functor. In object-oriented terminology, a functor can be thought of as a
    generic type with a single abstract method `fmap`. In a way, reference types,
    such as refs and atoms, can be thought of as functors that save results, as a
    reference type applies a function to its contained value in order to obtain the
    new value that should be stored in it.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c6/` `functors.clj` of the
    book's source code.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fmap` function from the `cats.core` namespace takes two arguments: a function
    and a functor. A functor itself defines what happens when an instance of the functor
    is passed to the `fmap` function. The `cats` library extends vectors as functors.
    When a vector is passed to the `fmap` function along with a function, the supplied
    function is applied to all elements in the vector. Wait a minute! Isn''t that
    what the `map` function does? Well, yes, but the `map` function always returns
    a lazy sequence. On the other hand, the `fmap` function will return a value with
    the same concrete type as the functor that is passed. The behavior of the `map`
    and `fmap` functions can be compared as follows:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'As shown above, the `map` function produces a lazy sequence, which gets realized
    into a list in the REPL, when it is passed a vector along with the `inc` function.
    The `fmap` function, however, produces a vector when passed the same arguments.
    We should note that the `fmap` function is also aliased as `<$>`. Lazy sequences
    and sets can also be treated as functors, as shown here:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'The `Maybe` type is also a functor. The `fmap` function returns a *maybe* when
    it is passed a *maybe*, as shown here:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The `fmap` function applies the function `inc` to a `Maybe` value only when
    it contains a value. This behavior of the `fmap` function can be illustrated by
    the following diagram:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '![Using functors](img/B05024_06_03.jpg)'
  id: totrans-1114
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram depicts how the `fmap` function is passed the `inc` function
    and the expression `(cmm/just 1)`, and returns a new functor instance. The `fmap`
    function extracts the value from this `Maybe` value, applies the `inc` function
    to the value, and creates a new `Maybe` value with the result. On the other hand,
    the `fmap` function will simply return an empty `Maybe` instance, created using
    the `nothing` function, without touching it, as shown in the following diagram:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '![Using functors](img/B05024_06_04.jpg)'
  id: totrans-1116
  prefs: []
  type: TYPE_IMG
- en: 'This behavior of the `fmap` function is defined by the implementation of the
    `Maybe` type. This is because a functor itself gets to define how the `fmap` function
    behaves with it. Of course, implementing the `fmap` function is not enough to
    qualify a type as a functor. There are also functor laws that have to be satisfied
    by any plausible implementation of a functor. The functor laws can be described
    as follows:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing an identity morphism and a functor *F* to `fmap` must return the functor
    *F* without any modification. We can translate this into Clojure using the `identity`
    function, as follows:'
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-1119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Passing a functor *F* and a morphism *f* to `fmap`, followed by passing the
    result and another morphism *g* to `fmap`, must be equivalent to calling `fmap`
    with the functor *F* and the composition ![Using functors](img/4900_06_07.jpg).
    We can verify this using the `comp` function, as shown here:'
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-1121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: The first law describes identity morphisms, and the second law upholds the composition
    of morphisms. These laws can be thought of as optimizations that can be performed
    by the `fmap` function when used with valid functors.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: Using applicative functors
  id: totrans-1123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applicative functors are a subset of functors with a few additional requirements
    imposed on them, thus making them a bit more useful. Similar to functors, applicative
    functors are computational contexts that are capable of applying a function to
    the value contained in them. The only difference is that the function to be applied
    to an applicative functor must itself be wrapped in the context of an applicative
    functor. Applicative functors also have a different interface of functions associated
    with them. An applicative functor, in `cats`, is manipulated using two functions:
    `fapply` and `pure`.'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c6/` `applicatives.clj` of
    the book's source code.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fapply` function from the `cats.core` namespace can be called with an
    applicative functor, as follows:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Here, we again use the `Maybe` type, this time as an applicative functor. The
    `fapply` function unwraps the `inc` function and the value `1` from the `Maybe`
    values, combines them and returns the result `2` in a new `Maybe` instance. This
    can be illustrated with the following diagram:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '![Using applicative functors](img/B05024_06_05.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
- en: 'The `cats.core/pure` function is used to create a new instance of an applicative
    functor. We must pass an implementation-specific context, such as `cats.monads.maybe/context`,
    and a value to the `pure` function, as follows:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'The `cats` library provides an `alet` form to easily compose applicative functors.
    Its syntax is similar to that of the `let` form, as follows:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: The value returned by the body of the `alet` form, shown previously, is wrapped
    in a new applicative functor instance and returned. The surrounding `alet` form
    is dereferenced, and thus the entire expression returns a vector.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<*>` function from the `cats.core` namespace is a variadic form of the
    `fapply` function. It accepts a value representing an applicative functor followed
    by any number of functions that produce applicative functors. The `cats` library
    also provides the `Validation` applicative functor type for validating properties
    of a given object. This type can be constructed using the `ok` and `fail` forms
    in the `cats.applicative.validation` namespace. Let''s say we want to validate
    a map representing a page with some textual content. A page must have a page number
    and an author. This validation can be implemented as shown in *Example 6.1*:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '*Example 6.1: The cats.applicative.validation type*'
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `validate-page-author` and `validate-page-number` functions in *Example
    6.1* check whether a map contains the `:author` and `:number` keys respectively.
    These functions create an instance of the `Validation` type using the `ok` function,
    and similarly use the `fail` function to create a `Validation` instance that represents
    a validation failure. Both the `validate-page-author` and `validate-page-number`
    functions are composed together using the `<*>` function. The first argument passed
    to `<*>` will have to be an instance of the `Validation` type created using the
    `pure` function. The `validate-page` function can thus validate maps representing
    pages, as shown here:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: A successful validation will return a `Validation` instance containing the page
    object, and an unsuccessful one will return an instance of the `Validation` type
    with the appropriate validation messages as a map. The concrete types for these
    two cases are `Ok` and `Fail`, as shown in the preceding output.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: Applicative functors must themselves define the behavior of the `fapply` and
    `pure` functions with them. Of course, there are laws that applicative functors
    must obey too. In addition to the identity and composition laws of functors, applicative
    functors also conform to the *homomorphism* and *interchange* laws. The reader
    is encouraged to find out more about these laws before implementing their own
    applicative functors.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: Using monads
  id: totrans-1143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at an algebraic structure that helps us build and
    compose a sequence of computations: a **monad**. There are countless tutorials
    and articles on the web that explain monads and how they can be used. In this
    section, we will look at monads in our own unique and Clojure-y way.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: In category theory, a monad is a morphism between functors. This means that
    a monad transforms the context of a contained value into another context. In pure
    functional programming languages, monads are data structures used to represent
    computations that are defined in steps. Each step is represented by an operation
    on a monad, and several of these steps can be chained together. Essentially, a
    monad is a composable abstraction of a step of any computation. A distinct feature
    of monads is that they allow us to model impure side effects, which may be performed
    in the various steps of a given computation, using pure functions.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: 'Monads abstract the way a function binds values to arguments and returns a
    value. Formally, a monad is an algebraic structure that implements two functions:
    `bind` and `return`. The `bind` function is used to apply a function to the value
    contained in a monad, and the `return` function can be thought of as a construct
    for wrapping values in a new monad instance. The type signatures of the `bind`
    and `return` functions can be described by the following pseudo code:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: The type signature of the `bind` function states that it accepts a value of
    type `Monad` `A` and a function that converts a value of type `A` to another value
    of type `Monad B`, which is simply a monad containing a value of type `B`. Also,
    the `bind` function returns a type `Monad B`. The `return` function's type signature
    shows that it takes a value of type `A` and returns a type `Monad A`. Implementing
    these two functions allows a monad to execute any code, defined in its `bind`
    implementation, before the supplied function `f` is applied to the value contained
    in the monad. A monad can also define code to be executed when the supplied function
    `f` returns a value, as defined by the monad's implementation of the `return`
    function.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that a monad can do more than just call a function over its
    contained value when passed to the `bind` function, a monad is used to indicate
    side effects in pure functional programming languages. Let's say, we have a function
    that maps type `A` to `B`. A function that maps type `A` to `Monad B` can be used
    to model the side effects that can occur when a value of type `A` is converted
    to another value of type `B`. In this way, monads can be used to represent side
    effects, such as IO, change of state, exceptions, and transactions.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers may even argue that monads are unnecessary in a language with
    macros. This is true in some sense, because macros can encapsulate side effects
    in them. However, monads help us to be explicit about any side-effects, which
    is quite useful. In fact, monads are the only way to model side effects in pure
    functional programming languages. Because monads can represent side effects, they
    allow us to write imperative-style code, which is all about mutation of state,
    in a pure functional programming language.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c6/` `monads.clj` of the book's
    source code.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at how the `Maybe` type from the `cats` library can take the
    form of a monad. We can pass a `Maybe` value along with a function to the `cats.core/bind`
    function to call the supplied function with the contained value in the monad.
    This function is aliased as `>>=`. The behavior of the `bind` function with a
    `Maybe` type is shown here:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'In this way, we can *bind* the `inc` function to a `Maybe` monad. The expression
    shown in the preceding output can be depicted by the following diagram:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '![Using monads](img/B05024_06_06.jpg)'
  id: totrans-1156
  prefs: []
  type: TYPE_IMG
- en: 'The `inc` function is applied to a `Maybe` monad only if it contains a value.
    When a `Maybe` monad does contain a value, applying the `inc` function to it using
    the `bind` function will simply return `2`, and not a monad containing `2`. This
    is because the standard `inc` function does not return a monad. On the other hand,
    an empty `Maybe` value is returned untouched. To return a monad in both the preceding
    cases, we can use the `return` function from the `cats.core` namespace, as shown
    here:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'The `lift-m` form can be used to *lift* a function that returns a type `A`
    to return a monad containing a type `A`. The concrete type of the return value
    of a lifted function depends on the monad context passed to it. If we pass a `Maybe`
    monad to a lifted version of `inc`, it will return a new instance of the `Maybe`
    monad, as shown here:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'We can also compose several calls to the `bind` function, as long as the function
    passed to the `bind` function produces a monad, as shown here:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Of course, we can also compose calls to the `bind` function to change the type
    of monad. For example, we can map a `Maybe` monad to an `Identity` monad, which
    is constructed using the `cats.monads.identity/identity` function. We can modify
    the preceding expression to return an `Identity` monad as shown here:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'As shown in the preceding output, calling the `bind` function multiple times
    can get a bit cumbersome. The `mlet` form lets us compose expressions that return
    monads, as shown in *Example 6.2*:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '*Example 6.2\. The mlet form*'
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In short, the `process-with-maybe` function defined in *Example 6.2* checks
    whether a number is even, then prints a line and increments the number. As we
    use the `Maybe` type, the last two steps of printing a line and incrementing a
    value are performed only if the input `x` is even. In this way, an empty `Maybe`
    monad, created using the `nothing` function, can be used to short-circuit a composition
    of monads. We can verify this behavior of the `process-with-maybe` function in
    the REPL, as shown here:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: As shown here, the `process-with-maybe` function prints a line only when the
    supplied value `x` is an even number. If not, an empty `Maybe` monad instance
    is returned.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples describe how we can use the `Maybe` monad. The `cats`
    library also provides implementations of the `Either` and `Exception` monads,
    in the `cats.monads.either` and `cats.monads.exception` namespaces respectively.
    Let's explore a few constructs from the `cats.monads.exception` namespace.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new `Exception` monad instance using the `success` and `failure`
    functions. The `success` form can be passed any value, and it returns a monad
    that represents a successful step in a computation. On the other hand, the `failure`
    function must be passed a map containing an `:error` key that points to an exception,
    and returns a monad that represents a failure in a computation. The value or exception
    contained in an `Exception` monad can be obtained by dereferencing it (using the
    `deref` form or the `@` reader macro). Another way to create an `Exception` monad
    instance is by using the `try-on` macro. The following output describes how these
    constructs can be used to create an instance of the `Exception` monad:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'The `try-on` macro will return a failure instance of the `Exception` monad
    if the expression passed to it throws an error, as shown here:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'A failure instance of an `Exception` monad can be used to short-circuit a composition
    of monads. This means that binding an `Exception` monad to a function will not
    call the supplied function if the monad contains an error. This is similar to
    how exceptions are used to halt computations. We can verify this using the `bind`
    function, as shown here:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Instances of the `Exception` monad can also be created using the `try-or-else`
    and `try-or-recover` macros from the `cats.monads.exception` namespace. The `try-or-else`
    form must be passed an expression and a default value. If the expression passed
    to this form throws an exception, the default value is wrapped in an `Exception`
    monad instance and returned. The `try-or-recover` form must be passed a 1-arity
    function in place of the default value. In case an error is encountered, the `try-or-recover`
    macro will invoke the supplied function and relay the value returned by it. The
    `try-or-else` and `try-or-recover` f3orms are demonstrated as follows:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: In this way, monads can be used to model side effects using pure functions.
    We've demonstrated how we can use the `Maybe` and `Exception` monad types. The
    `cats` library also implements other interesting monad types. There are monad
    laws as well, and any monad that we implement must conform to these laws. You
    are encouraged to learn more about the monad laws on your own.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about the notations and terminology used in category
    theory. We also discussed several algebraic types from category theory. Each of
    these abstractions have laws that must be satisfied by their implementations,
    and these laws can be thought of as optimizations for computations that use these
    algebraic types.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at a different paradigm of programming altogether—logic
    programming.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Programming with Logic
  id: totrans-1184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now take a step back from the realm of functional programming and explore
    a completely different paradigm—**logic programming**. Logic programming has its
    own unique way of solving computational problems. Of course, logic programming
    isn't the only way to solve a problem, but it's interesting to see what kind of
    problems can be easily solved with it.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: Although logic programming and functional programming are two completely different
    paradigms, they do have a few commonalities. Firstly, both of these paradigms
    are forms of *declarative programming*. Studies and papers have also shown that
    it is possible to implement the semantics of logic programming within a functional
    programming language. Hence, logic programming operates at a much higher degree
    of abstraction than functional programming. Logic programming is more suited for
    problems in which we have a set of rules, and we intend to find all the possible
    values that conform to these rules.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at logic programming in Clojure through the `core.logic`
    library. We will also study a few computational problems and how we can solve
    them in a concise and elegant manner using logic programming.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: Diving into logic programming
  id: totrans-1188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Clojure, logic programming can be done using the `core.logic` library ([https://github.com/clojure/core.logic/](https://github.com/clojure/core.logic/)).
    This library is a port of **miniKanren**, which is a domain-specific language
    for logic programming. miniKanren defines a set of simple constructs for creating
    logical relations and generating results from them.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: miniKanren was originally implemented in the Scheme programming language. You
    can find out more about miniKanren at [http://minikanren.org/](http://minikanren.org/).
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: A program written using logic programming can be thought of as a set of logical
    relations. **Logical relations** are the elementary building blocks of logic programming,
    just as functions are for functional programming. The terms *relation* and *constraint*
    are used interchangeably to refer to a logical relation. The `core.logic` library
    is in fact an implementation of constraint-based logic programming.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: A relation can be thought of as a function that returns a goal, and a goal can
    either be a success or a failure. In the `core.logic` library, a goal is represented
    by the `succeed` and `fail` constants. Another interesting aspect of relations
    is that they can return multiple results, or even no results. This is analogous
    to a function that produces a sequence of values, which could be empty, as a result.
    Functions such as `keep` and `filter` fit this description perfectly.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: The following examples can be found in `src/m_clj/c7/diving_into_logic.clj`
    of the book's source code.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: Solving logical relations
  id: totrans-1200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a convention, relations have their name suffixed with an "o". For example,
    the `conso` construct from the `clojure.core.logic` namespace is a relation that
    represents the behavior of the `cons` function. Logical programming constructs
    that use multiple logical relations, such as `conde` and `matche`, end with an
    "e". We will explore these constructs later on in this chapter. Let's now focus
    on how we can solve problems with logical relations.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: The `run*` macro, from the `clojure.core.logic` namespace, processes a number
    of goals to generate all possible results. The semantics of the `run*` form allow
    us to declare a number of logical variables that can be used in relations to return
    goals. The `run*` form returns a list of possible values for the logical variables
    it defines. An expression using the `run*` form and a set of relations is essentially
    a way of asking the question "What must the universe look like for these relations
    to be true?" to a computer and asking it to find the answer.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: 'An equality test can be performed using the `run*` macro in combination with
    the `clojure.core.logic/==` form, as shown here:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Both the statements using the `run*` form in the preceding output find all possible
    values of the logical variable `x`. The relation `(l/== x 1)` returns a goal that
    succeeds when the value of `x` is equal to `1`. Obviously, the only value that
    `x` can have for this relation to succeed is `1`. The `run*` form evaluates this
    relation to return `1` in a list. On the other hand, the relation `(l/== 1 0)`
    is logically false, and thus produces no results when passed to the `run*` form.
    This means that there are no values of `x` for which `1` is equal to `0`.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: 'A relation built using the `==` form from the `clojure.core.logic` namespace
    is called *unification*. Unification is often used in logic programming like variable
    assignment from other paradigms, as it''s used to assign values to variables.
    Conversely, a *disequality* represents a relation in which a logical variable
    cannot be equal to a given value. The `clojure.core.logic/!=` form is used to
    construct a disequality relation, as shown here:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: The first statement in the preceding output produces no results since the relation
    `(l/!= 1 1)` is logically false. An interesting quirk is that the second statement,
    which has a goal that always succeeds produces a single result `_0`, which represents
    an *unbound* logical variable. As we don't assign a value to `x` through unification,
    its value is said to be unbound. The symbols `_0`, `_1`, `_2`, and so on (also
    written as `_.0`, `_.1`, `_.2`, and so on) represent unbound logical variables
    in the context of a `run*` form.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: The `clojure.core.logic/conso` form is useful in modeling the behavior of the
    standard `cons` function as a relation. It takes three arguments, of which two
    are the same as the `cons` function. The first two arguments passed to a `conso`
    form represent the head and tail of a sequence.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument is a sequence that is expected to be returned on applying
    the `cons` function on the first two arguments. The `conso` relation can be demonstrated
    as follows:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The expression using a `conso` relation, in the preceding output, will solve
    for values of `x` that produce the value `[1 2 3]` when a `cons` form is applied
    to the values `1` and `[2 x]`. Obviously, `x` must be `3` for this relation to
    be true, and hence the result `3` is produced.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical variables can be created without the use of a `run*` form using the
    `lvar` function from the `clojure.core.logic` namespace. Within a `run*` form,
    we can create local logical variables using the `clojure.core.logic/fresh` macro.
    Variables declared using a `fresh` form will not be part of the final result produced
    by the surrounding `run*` form. For example, consider the expressions using the
    `run*` forms in the following output:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: The first expression shown previously produces the vector `[1 1]` as a result,
    whereas the second expression produces `1` as the result. This is because we specify
    a single logical variable `x` and use a `fresh` form to internally declare the
    logical variable `y` in the second expression.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: The `run*` form searches for results exhaustively from the set of relations
    provided to it. If we intend to find a limited number of results and avoid performing
    any additional computation to find any more results, we should use the `run` macro
    from the `clojure.core.logic` namespace instead. The `run` form has the same semantics
    of a `run*` form, but additionally requires the number of desired results to be
    passed to it as the first argument.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clojure.core.logic.fd` namespace provides us with several constructs to
    deal with relations that are constrained over a finite range of values. For example,
    suppose we wanted to find values within the range of `0` to `100` that are greater
    than `10`. We can easily express this relation using the `>`, `in`, and `interval`
    forms from the `clojure.core.logic.fd` namespace and extract the first five values
    from it using a `run` form, as shown here:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: The preceding expression uses the `in` and `interval` forms to constrain the
    value of the variable `x`. The expression using these two forms ensures that `x`
    is within the range of `0` and `100`. Also, the `clojure.core.logic.fd/>` function
    defines a relation in which `x` must be greater than `10`. The surrounding `run`
    form simply extracts the first five possible values of `x` from the relations
    supplied to it. There are also several other arithmetic comparison operators,
    namely `<`, `<=`, and `>=`, implemented in the `clojure.core.logic.fd` namespace.
    Instead of specifying a range of values to the `in` macro, we can also enumerate
    the possible values of a variable by using the `clojure.core.logic.fd/domain`
    form.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: 'The `firsto` form can be used to describe a relation in which the value in
    a given variable must be the first element in a collection. We can try out both
    the `domain` and `firsto` forms in the REPL as shown here:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: In the preceding expression, we solve for the first set of values of `v`, `a`,
    `b`, and `x` that satisfy the following relations. The value of `a` must be less
    than that of `b`, which is shown using the `<` form, and both `a` and `b` must
    constitute the elements of a vector `v`, which is shown using the `==` form. Also,
    `a`, `b`, and `x` must be equal to either `0`, `1`, or `2`, as described by a
    composition of the `in` and `domain` forms. Lastly, the first element of the vector
    `v` must be equal to the value `x`. These relations generate the vector `[0 1]`
    and the values `0`, `1`, and `0` for `a`, `b`, and `x` respectively. Note the
    arity of the `in` form in the previous expression that allows multiple logical
    variables to be passed to it along with a constraint.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: Combining logical relations
  id: totrans-1223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `clojure.core.logic/conde` form allows us to specify multiple relations,
    and is a bit similar to the standard `cond` form. For example, consider the following
    expression that uses the `conde` form:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'The preceding expression, which uses a `conde` form, performs equality checks
    for the symbols `A`, `B`, and `C` against the logical variable `x`. Only two of
    these checks produce a goal that succeeds, which is described using the `succeed`
    and `fail` constants in the clauses of the `conde` form. This logical branching
    by the `conde` form in the preceding expression can be illustrated through the
    following diagram:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining logical relations](img/B05024_07_01.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
- en: The `conde` form in our previous example creates a conditional check for three
    clauses. Out of these three clauses, only two succeed, and hence the symbols `A`
    and `B` are returned as results. We should note that the clauses defined in a
    `conde` form can take any number of relations. Also, the use of the `l/succeed`
    constant is implicit, and we only need to use the `l/fail` constant to represent
    a goal that fails.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to perform equality checks is by pattern matching. This can be
    done using the `clojure.core.logic/matche` form. The `matche` form is thus a more
    idiomatic way to define conditional branches involving logical variables, as shown
    here:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Both of the preceding expressions produce the same result. The only difference
    between these expressions is that the first one uses a `conde` form and the second
    one performs a pattern match using a `matche` form. Also, the `l/succeed` constant
    is implicit and does not need to be specified, similar to a `conde` form. The
    `_` wildcard is also supported by the `matche` form, as shown here:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: In the preceding expression, we solve for all values of `x` that match the pattern
    `'A`. All other cases fail, which is described using the `_` wildcard and the
    `l/fail` constant. Of course, the pattern using the `_` wildcard is implicit and
    is only shown to describe how it can be used in a `matche` form.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matche` construct also supports destructuring of sequences. A sequence
    can be destructured by a `matche` form using a dot (`.`) to delimit the head and
    tail of the sequence, as shown here:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'In the preceding expression, the logical variable `x` must be `(2 3)` for the
    relation defined using the `matche` form to succeed. We can define relations using
    a syntax similar to the `defn` form using the `defne` macro from the `clojure.core.logic`
    namespace. The `defne` form allows us to define relations in pattern matching
    style. Incidentally, a lot of constructs in the `core.logic` library are defined
    using the `defne` form. For example, consider the definition of the `membero`
    relation in *Example 7.1*:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '*Example 7.1: Defining the membero relation using the defne macro*'
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `membero` relation is used to ensure that a value `x` is a member of the
    collections `xs`. The implementation of this relation destructures the collection
    `xs` into its head and tail parts. If the value `x` is the head of the collection
    `xs`, the relation succeeds, otherwise the relation is called recursively with
    the value `x` and the tail of the destructured list `ys`. We can try out this
    relation with the `run*` form in the REPL, as shown here:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: The preceding expression solves for values of `x` that are contained in the
    range `0` to `5` as well as in the range `3` to `10`. The results `3` and `4`
    are produced from these two relations that use the `membero` form.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: 'While dealing with logical variables, it''s important to note that we cannot
    use standard functions to perform any computation with them. In order to extract
    values from a bunch of logical variables, we have to use the `clojure.core.logic/project`
    form. For example, consider the following statement:'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The preceding statement solves for two values of `x` and `y` such that they
    are both in the range `1` to `10` and their sum is equal to `5`. The values `[1
    4]` and `[2 3]` are returned as results. The `project` form is used to extract
    the values of `x` and `y`, or else the `+` function would throw an exception.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the `core.logic` library provides us with a handful of constructs that
    can be used to define logical relations, combine them, and generate results from
    them.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in logical relations
  id: totrans-1246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are well versed with the various constructs from the `core.logic`
    library, let's look at some real world problems that can be solved through logic
    programming.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: Solving the n-queens problem
  id: totrans-1248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **n-queens problem** is an interesting problem that can be implemented using
    logical relations. The objective of the n-queens problem is to place *n* queens
    on an *n* *x* *n* sized chessboard such that no two queens are a threat to each
    other. This problem is a generalization of the *eight queens problem* published
    by Max Bezzel in 1848, which involves eight queens. In fact, we can actually solve
    the n-queens problem for any number of queens, as long as we are dealing with
    four or more queens. Traditionally, this problem can be solved using an algorithmic
    technique called *backtracking*, which is essentially an exhaustive search for
    all possible solutions to a given problem. However, in this section, we will solve
    it using logical relations.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first define how a queen can be used. As we all know, a queen can move
    as she wishes! A queen can move horizontally, vertically, or diagonally on a chessboard.
    If any other chess piece is on the same path on which a queen can be moved, then
    the queen is a threat to it. The position of a chess piece on the chessboard can
    be specified using a pair of integers, just like how Cartesian coordinates can
    be used to represent the position of a point on a plane. Suppose the pairs (*x[1],
    y[1]) and (x[2], y[2]*) represent the positions of two queens on the chessboard.
    As they can threaten each other horizontally, vertically, or diagonally, there
    are three distinct cases we must avoid:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: The queens cannot be on the same vertical path, that is, *x[1]* equal to *x[2]*.
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, the queens cannot be on the same horizontal path, that is, *y[1]*
    equal to *y[2].*
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The queens cannot be on the same diagonal path, in which case the ratio vertical
    and horizontal distance between them is either `1` or `-1`. This is actually a
    trick from coordinate geometry, and its proof is way out of the scope of our discussion.
    This case can be concisely represented by the following equations:![Solving the
    n-queens problem](img/B05024_07_03.jpg)
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the only rules that determine whether two queens threaten each other.
    Yet if you think about them from a procedural or object-oriented perspective,
    implementing them could require a good amount of code. On the contrary, if we
    think in terms of relations, we can implement these three rules fairly easily
    using the `core.logic` library, as shown in the following *Example 7.2*:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c7/nqueens.clj` of the book's
    source code. This example is based on code from *n-queens with core.logic* by
    Martin Trojer([http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html](http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html)).
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '*Example 7.2: The n-queens problem*'
  id: totrans-1258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In *Example 7.2*, we define two relations, namely `safeo` and `nqueenso`, to
    describe the n-queens problem. Both of these relations must be passed a list `qs`
    as an argument, where `qs` contains coordinate pairs that represent the positions
    of queens placed on the chessboard. They are interestingly recursive relations,
    and the termination is specified by the case in which `qs` is empty.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: The `safeo` relation is an implementation of the three rules that determine
    whether two queens threaten each other. Note the way this relation uses a `project`
    form to extract the values `x1`, `y1`, `x2`, and `y2` to handle the case in which
    two queens are on the same diagonal path. The `nqueenso` relation processes all
    positions of queens from the list `qs` and ensures that each queen is safe. The
    `solve-queens` function initializes `n` logical variables using the `clojure.core.logic/lvar`
    form.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: The value `qs` is initialized a list of vector pairs that each contain a logical
    variable and a number within the range of *0* to *n*. In effect, we initialize
    the *y* coordinates of all pairs, and solve for the *x* coordinates. The reasoning
    behind this is that as we are solving for *n* queens on a board with *n* columns
    and *n* rows, and each row will have a queen placed on it.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: 'The `solve-nqueens` function returns a list of solutions that each contain
    a list of coordinate pairs. We can print this data in a more intuitive representation
    by using the `partition` and `clojure.pprint/pprint` functions, as shown in *Example
    7.3*:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '*Example 7.3: The n-queens problem (continued)*'
  id: totrans-1264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, we just need to call the `solve-and-print-nqueens` function by passing
    it the number of queens. Let''s try to use this function to solve the n-queens
    problem for four queens, as shown here:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: The `solve-and-print-nqueens` function prints two solutions for four queens.
    Each solution is printed as a bunch of nested lists, in which each inner list
    represents a row on the chessboard. The value `1` indicates that a queen is placed
    on that position on the chessboard. As you can see, none of the four queens threaten
    each other in either of the two solutions.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the `solve-nqueens` function uses relations to solve the n-queens
    problem. We mentioned earlier that the n-queens problem originally involved eight
    queens. There are totally 92 distinct solutions for eight queens, and the `solve-nqueens`
    function can find every single one of them. You are encouraged to try this out
    by passing the value `8` to the `solve-and-print-nqueens` function and verifying
    the solutions it prints.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: Solving a Sudoku puzzle
  id: totrans-1269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of us may already be in love with the intuitive and mesmerizing Sudoku
    puzzles that we find in newspapers and magazines. This is another problem that
    involves logical rules. A Sudoku board is a *9* *x* *9* grid on which we can place
    digits. The grid is divided into nine smaller grids, each of which is further
    divided into *3* *x* *3* grids that contain digits. These smaller grids are also
    called *squares* or *boxes*. Some of the squares will be filled with boxes. The
    goal is to place digits on all positions on the grid such that each row, each
    column, and each of the smaller grids all contain distinct digits in the range
    1 through 9.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement the rules of a Sudoku puzzle in this way. We will create a logical
    variable for every possible position of a digit on a Sudoku board and solve for
    their values using the rules of the puzzle. The initial values of the digits on
    a Sudoku board can be provided as a single vector comprising of 81 numbers. In
    this implementation, we introduce a couple of new constructs that are useful in
    concisely describing the rules of a Sudoku puzzle. The `everyg` function from
    the `clojure.core.logic` namespace can be used to apply a relation over a list
    of logical variables, thus ensuring that a relation is true for all the supplied
    logical variables. We must also ensure that the logical variables in a row, column,
    and *3* *x* *3* sized grid in a Sudoku puzzle are distinct. This can done by using
    the `clojure.core.logic.fd/distinct` function. An implementation of this design
    of a Sudoku solver is shown in *Example 7.4*.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c7/sudoku.clj` of the book's
    source code.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '*Example 7.4: A Sudoku solver*'
  id: totrans-1275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In *Example 7.4*, the `init-sudoku-board` relation initializes the logical variables
    `vars` from the puzzle `puzzle`, and the `solve-sudoku` function finds all possible
    solutions of the given puzzle. The `solve-sudoku` function creates the logical
    variables through a composition of the `repeatedly` and `clojure.core.logic/lvar`
    forms. These variables are then partitioned into rows, columns, and squares, represented
    by the variables `rows`, `cols`, and `squares` respectively. The `solve-sudoku`
    function then initializes the logical variables using the `init-sudoku-board`
    form, and uses a composition of the `everyg` and `distinct` forms to ensure that
    the rows, columns, and squares of a solution contain distinct values. All the
    logical variables are also bound to the range `1` through `9` using the internally
    defined `in-range` function.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: 'The `solve-sudoku` function defined in *Example 7.4* takes a vector of values
    representing the initial state of a Sudoku board as an argument and returns a
    list of solutions in which each solution is a vector. As a plain vector isn''t
    really an intuitive representation of a Sudoku board, let''s define a simple function
    to find all solutions of a given puzzle and print the solutions, as shown in *Example
    7.5*:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '*Example 7.5: A Sudoku solver (continued)*'
  id: totrans-1279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `solve-and-print-sudoku` function in *Example 7.5* calls the `solve-sudoku`
    function to determine all possible solutions to a given Sudoku puzzle and prints
    the results using the `partition` and `clojure.pprint/pprint` functions. Now,
    let's define a simple Sudoku puzzle to solve, as shown in *Example 7.6*.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '*Example 7.6: A Sudoku solver (continued)*'
  id: totrans-1282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, let''s pass the vector `puzzle-1` to the `solve-and-print-sudoku` function
    to print all possible solutions to it, as shown here:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'The `solve-sudoku` function finds a single solution to the Sudoku puzzle represented
    by the vector `puzzle-1` as shown previously. The puzzle represented by `puzzle-1`
    and its solution are shown on a Sudoku board in the following illustration:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving a Sudoku puzzle](img/B05024_07_02.jpg)'
  id: totrans-1286
  prefs: []
  type: TYPE_IMG
- en: 'Example 7.7: A Sudoku solver (continued)'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very likely that a Sudoku puzzle has multiple solutions. For example,
    the Sudoku puzzle represented by `puzzle-2` in *Example 7.7* has eight distinct
    solutions. You''re more than welcome to find the solutions to this puzzle using
    the `solve-and-print-sudoku` function:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '*Example 7.7: A Sudoku solver (continued)*'
  id: totrans-1290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In conclusion, we can implement the rules of a Sudoku puzzle as logical relations
    using the `core.logic` library.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how Clojure can be used for logic programming.
    We introduced the `core.logic` library by exploring the various constructs provided
    by this library. We also studied how we can implement solutions to the n-queens
    problem and a Sudoku puzzle using the `core.logic` library.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will get back on our journey through functional
    programming and talk about handling asynchronous tasks in Clojure.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Leveraging Asynchronous Tasks
  id: totrans-1295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **asynchronous programming** refers to defining tasks that are executed
    *asynchronously* on different threads of execution. While this is similar to multithreading,
    there are a few subtle differences. Firstly, a thread or a future will remain
    allocated to a single operating system thread until completion. This leads to
    the fact that is there can only be a limited number of futures that can be executed
    concurrently, depending on the number of processing cores available. On the other
    hand, asynchronous tasks are scheduled for execution on threads from a thread
    pool. This way, a program can have thousands, or even millions of asynchronous
    tasks running concurrently. An asynchronous task can be suspended at any time,
    or *parked*, and the underlying thread of execution can be reallocated to another
    task. Asynchronous programming constructs also allow the definition of an asynchronous
    task to look like a sequence of synchronous calls, but each call could potentially
    be executed asynchronously.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore various libraries and constructs that can be
    used for asynchronous programming in Clojure. First off, we will take a look at
    *processes* and *channels* in the `core.async` library for asynchronous programming.
    Later, we will explore *actors* from the *Pulsar* library. Processes and channels
    are constructs similar to *go-routines* in the Go programming language. On the
    other hand, actors were first popularized in the Erlang programming language.
    All of these techniques are different ways of structuring code that executes asynchronously.
    We must understand that the theory behind these concepts isn't really novel, and
    more implementations of these theories have been springing up since the rise of
    distributed and multi-core architectures. With that in mind, let's start off on
    our journey into asynchronous programming.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: Using channels
  id: totrans-1298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `core.async` library ([https://github.com/clojure/core.async](https://github.com/clojure/core.async))
    facilitates asynchronous programming in Clojure. Through this library, we can
    use asynchronous constructs that run on both the JVM and web browsers without
    dealing with how they are scheduled for execution on low-level threads. This library
    is an implementation of the theory in the paper **Communicating Sequential Processes**
    (**CSPs**), originally published in the late ''70s by C. A. R. Hoare. The bottom
    line of CSPs is that any system that processes some input and provides an output
    can be comprised of smaller subsystems, and each subsystem can be defined in terms
    of *processes* and *queues*. A queue simply buffers data, and a process can read
    from and write to several queues. Here, we shouldn''t confuse the term *process*
    with an operating system process. In the context of CSPs, a process is simply
    a sequence of instructions that interacts with some data stored in queues. Several
    processes may exist in a given system and queues are a means of conveying data
    between them. A process that takes data from a single queue and outputs data to
    another queue can be illustrated as follows:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '![Using channels](img/B05024_08_01.jpg)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, input data goes into a queue, a process manipulates
    this data through the queue, and finally, writes the output data to another queue.
    The `core.async` library essentially provides first-class support for creating
    processes and queues. Queues are dubbed as **channels** in the `core.async` library,
    and can be created using the `chan` function. Processes can be created using `go`
    and `thread` macros. Let's dive a bit deeper into the details.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-1304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Processes, created using the `thread` and `go` forms, are scheduled for execution
    on thread pools. In fact, we can create several thousands of these processes in
    a program as they do not require their own dedicated thread. On the other hand,
    creating a large number of threads or futures would result in the excessive jobs
    being queued for execution. This imposes a practical limit on the number of threads
    or futures we can run concurrently. Hence, the `core.async` library, and CSPs
    in general, allows us to model a system as a large number of lightweight and concurrent
    processes.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: Channels can be thought of as data structures for managing the state between
    processes. The `chan` function from the `core.async` namespace returns a channel
    that can be read from and written to by several concurrent processes. Channels
    are *unbuffered* by default, which means a write operation to a channel will not
    complete until a read operation is invoked on it concurrently and vice versa.
    We can also create a *buffered* channel by specifying a number to the `chan` function
    to indicate the buffer size. A buffered channel will allow a certain number of
    values to be written to it without blocking, and the buffered values can then
    be read. A channel can be closed using the `close!` function from the `core.async`
    namespace.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: We can also create a buffered channel by passing a buffer object to the `chan`
    function. A buffer object can be created using the `buffer`, `dropping-buffer`,
    or `sliding-buffer` functions, and these functions require a number, indicating
    the size of the buffer, as an argument. Either of the expressions `(a/chan (a/buffer
    n))` or `(a/chan n)` can be used to create a channel that can buffer `n` values,
    and the channel will block write operations to it once it is filled with `n` values.
    The `dropping-buffer` function creates a buffer that drops newly added values
    once it's full. Conversely, a buffer created using the `sliding-buffer` function
    will drop the oldest values added to it once it is completely filled.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: 'The `core.async` library provides a handful of constructs for reading from
    and writing to channels, and the values passed to and returned by these constructs
    conform to a few simple rules. A read operation on a channel returns a value from
    the channel, or `nil` if the channel is closed. A write operation will return
    `true` if it succeeds, or `false` if the channel is closed and the write operation
    couldn''t be completed. We can read the buffered data from a closed channel, but
    once the channel is exhausted of data, a read operation on it will return `nil`.
    The arguments to the read and write operations for channels conform to the following
    pattern:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to any operation is a channel.
  id: totrans-1311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A write operation must be passed a value to put onto a channel in addition to
    the channel itself.
  id: totrans-1312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we should note that in the context of channels, the terms "write"
    and "put" can be used interchangeably, and similarly, the terms "read" and "take"
    refer to the same operation. The `take!` and `put!` functions take data and put
    data onto a queue. Both these functions return immediately, and can be passed
    a callback function as an argument in addition to the usual parameters. Similarly,
    the `<!!` and `>!!` functions can be used to read from and write to a channel,
    respectively. However, the `<!!` operation can block the calling thread if there
    is no data in the supplied channel and the `>!!` operation will be blocked if
    there is no more buffer space available in a given channel. These two operations
    are meant to be used within a `thread` form. Finally, the parking read and write
    functions, namely `<!` and `>!`, can be used within a `go` form to interact with
    a channel. Both the `<!` and `>!` operations will park the state of the task and
    release the underlying thread of execution if an operation cannot be completed
    immediately.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the details of creating processes using the `core.async` library.
    The `core.async/thread` macro is used to create a single-threaded process. It
    is similar to the `future` form in the sense that the body of a `thread` form
    is executed on a new thread and a call to a `thread` form returns immediately.
    A `thread` form returns a channel from which the output of its body can be read.
    This makes the `thread` form a bit more convenient than the standard `future`
    form for interacting with channels, and is thus preferred over a `future` form.
    The `<!!` and `>!!` functions can be used within a `thread` form to interact with
    a channel.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: To create an asynchronous process that can be parked and scheduled for execution,
    we must use the `go` macro from the `core.async` namespace. Similar to the `thread`
    form, it returns a channel from which the output of its body can be read. All
    channel operations within the body of the `go` form will park, rather than blocking
    the underlying thread of execution. This implies that the executing thread will
    not be blocked and can be reallocated to another asynchronous process. Thus, the
    execution of a number of `go` forms can be interleaved over a much lesser number
    of actual threads. We must ensure that no thread-specific operations, such as
    `Thread/sleep`, are made within a `go` form, as such operations affect the underlying
    thread of execution. Within a `go` form, we must always use the `<!` and `>!`
    parking forms to read from and write to a channel.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [https://clojure.github.io/core.async/](https://clojure.github.io/core.async/)
    for the complete documentation on all the functions and macros in the `core.async`
    library.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: The `go-loop` macro is an asynchronous version of the `loop` form, and accepts
    a vector of bindings as its first argument, followed by any number of forms that
    must be executed. The body of a `go-loop` form will be internally executed within
    a `go` form. The `go-loop` construct is often used to create asynchronous event
    loops that have their own localized state. As an example, let's consider the simple
    `wait-and-print` function that sets off a process that reads from a given channel,
    as shown in *Example 8.1*.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c8/async.clj` of the book's
    source code.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '*Example 8.1: A function that asynchronously reads from a channel*'
  id: totrans-1322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `wait-and-print` function shown previously will repeatedly read from the
    channel `c` passed to it. The `when` form is used to check if the value read from
    channel, represented by `v`, is not `nil`, since `nil` could be returned from
    the `<!` form if the channel `c` is closed. The `go-loop` form in the previous
    example also counts the number of values read from the channel using the variable
    `n`. On receiving a value from the channel, some information is printed and the
    body is looped over using a `recur` form. We can create a channel, pass it to
    the `wait-and-print` function and observe the output of sending values to the
    channel, as shown here:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'As shown previously, a call to the `wait-and-print` function starts an asynchronous
    event loop that reads from the channel `c`. On sending a value to the channel
    `c` using a `>!!` form, the value gets printed along with a total count of values
    sent to the channel. Also, calls to the `>!!` form return the value `true` immediately.
    Now, let''s see what happens when we close the channel `c` using the `close!`
    function, shown as follows:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: After closing the channel `c`, the `>!!` form returns `false` when it is applied
    to the channel, which implies that the channel `c` doesn't allow any more values
    to be put into it. Also, nothing gets printed, which means that the asynchronous
    routine that was trying to take values from the channel `c` has terminated.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to send values into a channel is by using the `onto-chan` function
    from the `core.async` namespace. This function must be passed a channel and a
    collection of values to put *onto* the channel, as shown here:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: The `onto-chan` function will close the channel it has been passed once the
    supplied collection of values is entirely put onto the channel. To avoid closing
    the channel, we can specify `false` as an additional argument to the `onto-chan`
    function.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: The `alts!` and `alts!!` functions from the `core.async` namespace can be used
    to wait for completion of one of several channel operations. The main distinction
    between these functions is that the `alts!` function is intended for use within
    a `go` form and will park the current thread, unlike the `alts!!` function that
    blocks the current thread and must be used in a `thread` form. Both these functions
    must be passed a vector of channels and return a vector of two elements. The first
    element in the returned vector represents the value for a take operation or a
    Boolean value for a put operation, and the second one indicates the channel on
    which the operation completed. We can also specify a default value as a keyword
    argument with the key `:default` to the `alts!` and `alts!!` functions. The default
    value will be returned if none of the operations supplied to the `alts!` or `alts!!`
    forms have completed.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: 'The `core.async` library provides two versatile macros, namely `alt!` and `alt!!`,
    to wait for one among several channel operations to be complete. As you may have
    already guessed, an `alt!` form parks the current task, and an `alt!!` form blocks
    the current thread. Both these forms can also return a default value when used
    with the `:default` keyword argument. We can pass several clauses to the `alt!`
    and `alt!!` forms for reading from and writing to several channels. The `alt!`
    form in *Example 8.2* describes the clauses supported by the `alt!` and `alt!!`
    macros:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '*Example 8.2: An asynchronous process implemented using the alt! form*'
  id: totrans-1334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The preceding `process-channels` function takes six channels as its arguments,
    and uses an `alt!` form within a `go` form to perform asynchronous operations
    on these channels. The channels `c0`, `c1`, `c2`, and `c3` are read, and the channels
    `c4` and `c5` are written to. The `alt!` form tries to read from the channel `c0`
    and returns the keyword `:r` if the operation completes first. The channel `c1`
    is also read from, but the right hand side of its clause contains a parameterized
    expression with the argument `v`, where `v` is the value read from the channel.
    The channels `c2` and `c3` are passed as a vector in one of the clauses of the
    `alt!` form shown previously, and this clause uses a parameterized expression
    with the arguments `v` and `c`, where `c` is the channel on which the read operation
    completed first and `v` is the value read from the channel. Write operations are
    specified in an `alt!` form as a nested vector, where each inner vector contains
    a channel and a value to put onto the channel. The channels `c4` and `c5` are
    written to in the previous `alt!` form, and the value `:w` is returned if either
    of the two write operations completes. In this way, we can specify clauses to
    the `alt!` and `alt!!` forms to read to and write from several channels, and return
    a value based on which channel operation completes first.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Another facility that is often required in asynchronous programming is the ability
    to specify a *timeout* with a given operation. By the term *timeout*, we mean
    a specified amount of time after which the current operation is aborted. The `core.async`
    has an intuitive method for specifying operations with timeouts. This is done
    using the `core.async/timeout` function, which must be supplied a time interval
    in milliseconds and returns a channel that closes after the specified amount of
    time. If we intend to perform an operation with a timeout, we use one of the `alt*`
    forms with a channel returned by the `timeout` function.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, an operation with a channel returned by a `timeout` form will surely
    complete after the specified amount of time. The `timeout` form is also useful
    in parking or blocking the current thread of execution for a given amount of time.
    For example, a blocking read operation from a channel returned by a `timeout`
    form will block the current thread for the specified time interval, as shown here:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: We have now covered the basics of processes and channels in the `core.async`
    library.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: Customizing channels
  id: totrans-1340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Channels can also be programmed to modify or compute values from those put
    into them. A read operation, for instance, on a channel could invoke a computation
    using the values buffered in the same channel, or even other channels. The `reduce`
    function from the `core.async` namespace can be used to compute values from channels
    and has more-or-less the same semantics as that of the standard `reduce` function.
    This variant of the `reduce` function requires a reducing operation, an initial
    value for the reduction operation and a channel to be passed to it, and it will
    return a channel from which the result can be read. Also, this function only produces
    values once the channel passed to it is closed. For example, consider the following
    code that computes a string from the values in a channel using the `core.async/reduce`
    function:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: In the preceding example, the sequence generated by the expression `(range 5)`
    is put onto the channel `c` using an `onto-chan` form, and values from the channel
    are computed over using the channel-based variant of the `reduce` function. A
    single value is read from the resulting channel `rc`, thus producing a string
    containing all the values from the channel `c`. Note that the `reduce` form in
    this example produced a result without explicitly calling the `close!` function,
    as the `onto-chan` function closes the supplied channel after it completes putting
    values onto it.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: A more powerful and intuitive way to compute values from a channel is by using
    a transducer. We have already discussed transducers in some detail in [Chapter
    5](ch20.html "Chapter 5. Composing Transducers"), *Composing Transducers*, and
    we will now have a look at how transducers can be used with channels. Essentially,
    a channel can be associated with a transducer by specifying the transducer as
    a second argument to the `core.async/chan` function. Let's consider the simple
    transducer `xform` shown in *Example 8.3*.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '*Example 8.3: A simple transducer to use with a channel*'
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The transducer `xform` shown is a trivial composition of mapping the functions
    `inc` and `#(* % 2)`. It will simply increment all values in a source of data,
    or rather a channel, and then double all of the results from the previous step.
    Let''s create a channel using this transducer and observe its behavior, as shown
    here:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: The channel `xc` will apply the transducer `xform` to each value contained in
    it. The result of repeatedly taking values from the channel `xc` is thus a sequence
    of even numbers, which is produced by applying the functions `inc` and `#(* %
    2)` to each number in the range `(range 10)`. Note that the `onto-chan` form in
    the previous example does not close the channel `xc` as we pass `false` as its
    last argument.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: A transducer associated with a channel could encounter an exception. To handle
    errors, we can pass a function as an additional argument to the `chan` form. This
    function must take exactly one argument, and will be passed any exception that
    is encountered by a transducer while transforming the values in a channel. For
    example, the expression `(a/chan 10 xform ex-handler)` creates a channel with
    a transducer `xform` and an exception handler `ex-handler`.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the `core.async/reduce` form and transducers can be used to perform
    computations on the values contained in channels.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: Connecting channels
  id: totrans-1352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are familiar with the basics of channels and processes in the `core.async`
    library, let's explore the different ways in which channels can be connected together.
    Connecting two or more channels is useful for aggregating and distributing data
    among them. A connection between two or more channels is called a *joint fitting*,
    or simply a *joint*. We will use diagrams to describe some of the more complex
    joint fittings in this section. Keep in mind that the arrows in these diagrams
    indicate the direction of the flow of data in a given channel.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to connect two channels is by using a *pipe*, which is implemented
    by the `core.async/pipe` function. This function will take values from the first
    channel provided to it, and supplies these values to the second channel passed
    to it. In this way, a pipe between channels is similar to UNIX-style pipes between
    streams. For example, the expression `(a/pipe from to)` will take values from
    the channel `from` and put them onto the channel `to`. The `pipe` function also
    takes an optional third argument, which indicates whether the destination channel
    will be closed when the source channel closes, and this argument defaults to `true`.
    We can also connect two channels using a *pipeline*, using the `pipeline` function
    from the `core.async` namespace. The `pipeline` function will essentially apply
    a transducer to the values in a channel before they are put into another channel.
    The supplied transducer will also be invoked in parallel for each element in the
    supplied channel by the `pipeline` function.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: 'The `merge` function from the `core.async` namespace can be used to combine
    several channels. This function must be passed a vector of channels, and returns
    a channel from which the values from all of the supplied channels can be read.
    The returned channel is unbuffered by default, and we specify the size of the
    channel''s buffer by passing a number as an additional argument to the `merge`
    function. Also, the channel returned by a `merge` form will be closed once all
    the source channels have been closed. The operation of the `merge` function with
    two channels can be illustrated as follows:'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting channels](img/B05024_08_02.jpg)'
  id: totrans-1356
  prefs: []
  type: TYPE_IMG
- en: A channel can be split into two channels using the `core.async/split` function.
    The `split` function must be passed a predicate `p?` and a channel `c`, and returns
    a vector of two channels. The predicate `p?` is used to decide the channel on
    which a value from the channel `c` must be put. All values from the channel `c`
    that return a truthy value when passed to the predicate `p?` will be put onto
    the first channel in the vector returned by the `split` function.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, the second channel in the returned vector will contain all values
    that return `false` or `nil` when `p?` is applied to these values. Both the channels
    returned by this function will be unbuffered by default, and the buffer size of
    both these channels can be specified as additional arguments to a `split` form.
    The `split` function can be depicted by the following illustration:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting channels](img/B05024_08_03.jpg)'
  id: totrans-1359
  prefs: []
  type: TYPE_IMG
- en: 'A more dynamic way to combine several channels, compared to the `merge` function,
    is by using the `mix`, `admix`, and `unmix` functions from the `core.async` namespace.
    The `mix` function creates a *mix*, to which channels with incoming data can be
    connected to using the `admix` function. The `mix` function takes a channel as
    an argument, and the supplied channel will contain values from all the source
    channels added by the `admix` function. A source channel can be removed from a
    mixer by using the `unmix` function. The `admix` and `unmix` functions both accept
    a mix, which is returned by the `mix` function, and a source channel as arguments.
    To remove all channels from a mix, we simply pass the mix as an argument to the
    `unmix-all` function. The gist of a mix is that it allows us to dynamically add
    and remove source channels that send data to a given output channel. A mix, its
    output channel, and source channels can be illustrated as follows:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting channels](img/B05024_08_04.jpg)'
  id: totrans-1361
  prefs: []
  type: TYPE_IMG
- en: In the preceding illustration, the channel `c` is used as the output channel
    of the mix `m`, and the channels `c0` and `c1` are added as source channels to
    the mix `m` using the `admix` function.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: 'The `core.async/mult` function creates a *multiple* of a given channel. The
    data from a multiple can be *tapped into* from another channel using the `tap`
    function. The channel supplied to the `tap` function will receive copies of all
    data sent to the source channel of a multiple. The `untap` function is used to
    disconnect a channel from a multiple, and the `untap-all` function will disconnect
    all channels from a multiple. A multiple essentially allows us to dynamically
    add and remove output channels that read values from a given source channel. The
    `mult` and `tap` functions can be described by the following diagram:'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting channels](img/B05024_08_05.jpg)'
  id: totrans-1364
  prefs: []
  type: TYPE_IMG
- en: In the preceding illustration, the channel `c` is used as the source channel
    by the multiple `m`, and the channels `c0` and `c1` are passed to the `tap` function
    so that they effectively receive copies of the data sent to the channel `c`.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: 'The `core.async` library also supports a *publish-subscribe* model of transferring
    data. This can be done using a *publication*, which is created using the `core.async/pub`
    function. This function must be supplied a source channel and a function to decide
    the topic of a given value in the publication. Here, a topic can be any literal
    value, such as a string or a keyword, which is returned by the function supplied
    to the `pub` form. Channels can subscribe to a publication and a topic via the
    `sub` function, and a channel can unsubscribe from a publication using the `unsub`
    function. The `sub` and `unsub` functions must be passed a publication, a topic
    value and a channel. Also, the `unsub-all` function can be used to disconnect
    all channels that have subscribed to a publication. This function can optionally
    be passed a topic value, and will disconnect all channels that have subscribed
    to the given topic. A publication with two channels subscribed to it is depicted
    in following diagram:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting channels](img/B05024_08_06.jpg)'
  id: totrans-1367
  prefs: []
  type: TYPE_IMG
- en: In the preceding illustration, the publication `p` is created using the channel
    `c` and the function `topic-fn`. The channel `c0` subscribes to the publication
    `p` and the topic `:a`, while the channel `c1` subscribes to the same publication
    but for the topic `:b`. When a value is received on the channel `c`, it will either
    be sent to the channel `c0` if the function `topic-fn` returns `:a` for the given
    value, or to channel `c1` if the function `topic-fn` returns `:b` for the given
    value. Note that the values `:a` and `:b` in the preceding diagram are just arbitrary
    literals, and we could have used any other literal values just as easily.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `core.async` library provides several constructs to create joints
    between channels. These constructs help in modelling different ways in which data
    flows from any number of source channels into any number of output channels.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the dining philosophers problem
  id: totrans-1370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's try to implement a solution to the **dining philosophers problem**
    using the `core.async` library. We have already implemented two solutions to the
    dining philosophers problem in [Chapter 2](ch17.html "Chapter 2. Orchestrating
    Concurrency and Parallelism"), *Orchestrating Concurrency and Parallelism* of
    which one solution used refs and the other one used agents. In this section, we
    will use channels to implement a solution to the dining philosophers problem.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: The dining philosophers problem can be concisely described as follows. Five
    philosophers are seated on a table with five forks placed between them. Each philosopher
    requires two forks to eat. The philosophers must somehow share access to the forks
    placed in between them to consume the food allocated to them, and none of the
    philosophers must starve due to being unable to acquire two forks. In this implementation,
    we will use channels to maintain the state of the forks as well as the philosophers
    on the table.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: The following examples can be found in `src/m_clj/c8/` `dining_philosophers_async.clj`
    of the book's source code. Some of these examples are based on code from *A Dining
    Philosophers solver* by Pepijn de Vos ([http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html](http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html)).
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first define a couple of functions to initialize all the philosophers
    and forks we are dealing with, as shown in *Example 8.4*:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '*Example 8.4: The dining philosophers problem*'
  id: totrans-1379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `make-philosopher` function defined in *Example 8.4* creates a map representing
    the state of a philosopher. The argument `name` will be a string, the argument
    `forks` will be a vector of two fork channels, and the argument `food` will be
    a number indicating the amount of food served to a philosopher. The two forks
    represent the forks on the left- and right-hand side of a philosopher. These forks
    will be allocated and passed to the `make-philosopher` function by the `init-philosophers`
    function that we previously defined in [Chapter 2](ch17.html "Chapter 2. Orchestrating
    Concurrency and Parallelism"), Orchestrating Concurrency and Parallelism. The
    `make-forks` function shown previously creates a specified number of channels,
    puts the value `:fork` onto each of them, and finally returns the new channels.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define the routine of a philosopher as a process. A philosopher
    must try to acquire the forks on his left and right side, eat his food if he acquires
    both forks, and finally release any forks that he successfully acquired. Also,
    since the state of all the philosophers in our simulation is captured in a channel,
    we will have to take a philosopher out of a channel, perform the routine of a
    philosopher, and then put the philosopher''s state back onto the channel. This
    routine is implemented by the `philosopher-process` function in *Example 8.5*:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '*Example 8.5: The dining philosophers problem (continued)*'
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding `philosopher-process` function starts an asynchronous process
    using the `go-loop` macro. The arguments `p-chan`, `max-eat-ms`, and `max-think-ms`
    represent the channel containing the state of all philosophers, the maximum amount
    of time a philosopher can spend eating, and the maximum amount of time a philosopher
    can think, respectively. The asynchronous task started by the `philosopher-process`
    function will try to take values from the forks `fork-1` and `fork-2` of a philosopher
    with a timeout of `100` milliseconds. This is done using a combination of the
    `alt!` and `timeout` functions. If a philosopher is able to acquire two forks,
    he will eat for some time, put down or release both forks, spend some time thinking,
    and repeat the same process. If he is unable to get two forks, the philosopher
    will release any acquired forks and restart the same process. The state of the
    philosopher is always put back onto the channel `p-chan`. This asynchronous process
    is repeated until a philosopher has any remaining food. Next, let''s define a
    couple of functions to start and print the philosophers in our simulation, as
    shown in *Example 8.6*:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '*Example 8.6: The dining philosophers problem (continued)*'
  id: totrans-1386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The preceding `start-philosophers` function will put a sequence of philosophers,
    represented by the argument `philosophers`, onto the channel `p-chan`, and then
    call the `philosopher-process` function for each philosopher in the sequence `philosophers`.
    The `print-philosophers` function uses the blocking channel read and write functions,
    namely `<!!` and `>!!`, to read `n` philosophers from the channel `p-chan` and
    print the amount of food remaining on each philosopher's plate.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's create some instances of philosophers and associated forks by
    using the `make-philosopher` and `make-forks` functions. We will also use the
    `init-philosophers` function from [Chapter 2](ch17.html "Chapter 2. Orchestrating
    Concurrency and Parallelism"), Orchestrating Concurrency and Parallelism, to create
    philosopher objects, using the `make-philosopher` function, and assign two forks
    to each philosopher. These top-level definitions of the philosophers and forks
    in our simulation are shown in *Example 8.7*.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '*Example 8.7: The dining philosophers problem (continued)*'
  id: totrans-1390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As shown here, we define five forks and philosophers, and create a channel
    to represent the state of all philosophers we have created. Note that the channel
    we use for the philosophers has a buffer size of `5`. The simulation can be started
    by calling the `start-philosophers` function, and the state of the philosophers
    can be printed using the `print-philosophers` function, as shown here:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: As the preceding output shows us, the five philosophers share access to the
    forks among themselves and consume their food at the same rate. All philosophers
    get a chance to eat their food, and thus no one starves. Note that the order of
    the philosophers printed by the `print-philosophers` function may differ from
    time to time, and some philosophers may also be printed twice by this function.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can solve a given problem using channels and processes from
    the `core.async` library. Also, we can create any number of such processes without
    bothering about the available number of operating system level threads.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: Using actors
  id: totrans-1395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Actors** are another way of modeling a system as a large number of concurrently
    running processes. Each process in *the actor model* is termed as an actor, and
    this model is based on the philosophy that every piece of logic in a system can
    be represented as an actor. The theory behind actors was first published by Carl
    Hewitt in the early ''70s. Before we explore actors, we must note that the core
    Clojure language and libraries do not provide an implementation of the actor model.
    In fact, it is a widely accepted notion in the Clojure community that processes
    and channels are a much better methodology to model concurrently running processes
    compared to actors. That aside, actors can be used to provide more resilient error
    handling and recovery, and it is possible to use actors in Clojure through the
    Pulsar library ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)).'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about why processes and channels are preferred over actors
    in Clojure, take a look at *Clojure core.async Channels* by Rich Hickey ([http://clojure.com/blog/2013/06/28/clojure-core-async-channels](http://clojure.com/blog/2013/06/28/clojure-core-async-channels)).
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: 'The actor model describes actors as concurrent processes that perform some
    computation on receiving messages. An actor can also send messages to other actors,
    create more actors, and change its own behavior depending on the messages it receives.
    Actors can also have their own internal state. In fact, actors were originally
    described as independent processors with their own local memory that interact
    with each other through a high-speed communication network. Every actor has its
    own *mailbox* to receive messages, and messages are the only means of conveying
    data between actors. The following diagram depicts an actor as an entity that
    receives some input as messages and performs computations to produce some output:'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: '![Using actors](img/B05024_08_07.jpg)'
  id: totrans-1400
  prefs: []
  type: TYPE_IMG
- en: The Pulsar library provides a comprehensive implementation of the actor model.
    In this library, actors are scheduled to execute on **fibers**, which are similar
    to asynchronous tasks created using the `go` form from the `core.async` library.
    Fibers are scheduled to run on fork-join thread pools, unlike regular thread pools
    that are used in the `core.async` library. Due to this design, the Pulsar library
    is available only on the JVM, and not in the browser through ClojureScript.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: Fibers communicate with each other through the Pulsar library's own implementation
    of *promises* and *channels*. Interestingly, the Pulsar library also has several
    thin wrappers around its implementation of channels, to provide an API that is
    fully compatible with that of the `core.async` library. Although we won't discuss
    fibers, promises, and channels from the Pulsar library any further in this section,
    we must understand that channels are quite relevant to actors, since an actor's
    mailbox is implemented using a channel. Now, let's explore the basics of actors
    in the Pulsar library.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: Creating actors
  id: totrans-1403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `spawn` macro, from the `co.paralleluniverse.pulsar.actors` namespace, creates
    a new actor and must be passed a function that takes no arguments. We can specify
    the buffer size of an actor's mailbox using the `:mailbox-size` keyword argument
    of the `spawn` macro. There are several other interesting keyword arguments that
    can be passed to the `spawn` form, and you are encouraged to find out more about
    them on your own.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'Your `project.clj` file must also contain the following entries:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: The function supplied to the `spawn` macro must use the `receive` macro, from
    the `co.paralleluniverse.pulsar.actors` namespace, to process messages received
    by the actor. Within this supplied function, we can use the expression `@self`
    to refer to the actor executing it. The `receive` form also supports pattern matching,
    which is implemented through the `core.match` library. We can also call the `receive`
    macro with no arguments, in which case it will return a message from the actor's
    mailbox. The `receive` form will also park the fiber on which it is executed.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: To send messages to actors, we can use either the `!` or `!!` macros from the
    `co.paralleluniverse.pulsar.actors` namespace. Both these macros must be passed
    an actor and an expression that returns a value, and both of these forms return
    `nil`. The only difference between these two forms is that `!` is asynchronous,
    while `!!` is synchronous and may block the current thread of execution if the
    actor's mailbox is full. An actor may terminate on receiving a particular message,
    and we can check whether an actor is still active using the `done?` function from
    the `co.paralleluniverse.pulsar.actors` namespace. Once an actor terminates, we
    can obtain the final value returned by the actor using the `join` function from
    the `co.paralleluniverse.pulsar.core` namespace. For example, consider the actor
    created using the `spawn` and `receive` forms in *Example 8.8*.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c8/actors.clj` of the book's
    source code. Some of these examples are based on code from the official Pulsar
    documentation (`http://docs.paralleluniverse.co/pulsar/`).
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '*Example 8.8: An actor created using the spawn macro*'
  id: totrans-1417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The actor, represented by the preceding variable `actor`, will receive a message,
    print it and loop using a `recur` form. If the message `:finish` is received,
    it will print a string and terminate. The following code demonstrates how we can
    send a message to the actor:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'As shown here, sending the value `:foo` to the actor returns `nil` immediately,
    and the message gets printed from another thread. As the `done?` function returns
    `false` when passed the variable `actor`, it is evident that the actor does not
    terminate on receiving the value `:foo` as a message. On the other hand, if we
    send the value `:finish` to the actor, it will terminate, as shown here:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'After being sent the value `:finish`, the `done?` function returns `true` when
    applied to the actor, which implies that the actor has terminated. The value returned
    by an actor before termination can be obtained using the `join` function from
    the `co.paralleluniverse.pulsar.core` namespace. We must note that the `join`
    function actually returns the result of any fiber, and will block the calling
    thread of execution until the fiber completes or terminates. For example, consider
    the actor in *Example 8.9* that divides a number by another number:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '*Example 8.9: An actor that performs division of a number by another*'
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can send messages to the actor `divide-actor` defined in *Example 8.9*,
    and obtain the final result from it using the `join` function, as shown here:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: The preceding code shows that we can send two numbers to the actor `divide-actor`,
    and send it the value `:result` to terminate it. After termination, we can obtain
    the result of the actor, that is `3`, by passing the actor to the `join` function.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: Actors can be registered with meaningful names that can be used to locate them.
    This is done using the `register!` function from the `co.paralleluniverse.pulsar.actors`
    namespace, which must be passed an actor instance and a name to register for the
    supplied actor. We can then send messages to a registered actor by specifying
    the actor's name to either the `!` or `!!` functions. For example, suppose the
    variable `actor` represents an actor instance created using the `spawn` macro.
    After registering the actor with the name `:my-actor` by calling `(pa/register!
    actor :my-actor)`, we can send the value `:foo` to the actor by calling `(pa/!
    :my-actor :foo)`.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: Passing messages between actors
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s build a simple simulation of a ping pong game with two actors.
    These two actors will send the messages `:ping` and `:pong` to each other for
    a specified number of times. The code for this simulation is shown in *Example
    8.10* as follows:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '*Example 8.10: Two actors playing a game of ping-pong*'
  id: totrans-1432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `ping-fn` and `pong-fn` functions shown in *Example 8.10* implement the
    logic of two actors playing a game of ping pong. The `ping-fn` will essentially
    send a vector containing the keyword `:ping` and the current actor instance to
    the actor represented by the argument `pong`. This is done `n` times, and finally
    the message `:finished` is sent to the actor `pong`. The function `pong-fn` will
    receive the vector `[:ping ping]`, where `ping` will be the actor sending the
    message. An actor created with the `pong-fn` will terminate once it receives the
    message `:finished`. The `start-ping-pong` function simply creates two actors
    using the functions `ping-fn` and `pong-fn` and waits until they are both finished
    using the `join` function. We can call the `start-ping-pong` function by passing
    in the number of times each of the two actors must send messages to each other,
    as shown here:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: The two actors created by the `start-ping-pong` function pass messages between
    themselves to simulate a game of ping pong, as demonstrated by the preceding output.
    In conclusion, actors from the Pulsar library can be used to implement concurrently
    executing processes.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors with actors
  id: totrans-1436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actors support some interesting methods for error handling. If an actor encounters
    an error while processing a received message, it will terminate. The exception
    that was raised within the fiber executing the actor will be saved and thrown
    again when we pass the actor to the `join` function. In effect, we don't need
    to handle exceptions within the function passed to the `spawn` macro, and instead
    we must catch exceptions when the `join` function is called.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to an interesting consequence of actors. If an actor could encounter
    an error and fail, we can have another actor that monitors the first actor, and
    restart it in case of failure. Thus, an actor can be notified when another actor
    in the system terminates. This principle allows actors to recover from errors
    in an automated fashion. In the Pulsar library, this sort of error handling is
    done through the `watch!` and `link!` functions from the `co.paralleluniverse.pulsar.actors`
    namespace.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: An actor can *watch* or *monitor* another actor by calling the `watch!` function
    from within its body. For example, we must call `(watch! A)` within the body of
    an actor to watch the actor `A`. If the actor being watched encounters an exception,
    the same exception will be thrown from the `receive` form of the monitoring actor.
    The monitoring actor must catch the exception, or else it will be terminated along
    with the actor from which the exception originated. Also, the monitoring actor
    could restart the terminated actor by calling the `spawn` macro. To stop watching
    an actor, we must pass the watched actor to the `unwatch!` function from within
    the body of the monitoring actor.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: Two actors could also be *linked* by passing them to the `link!` function. If
    two actors are linked together, an exception encountered in either of the two
    actors will be caught by the other one. In this way, linking two actors is a symmetrical
    way of monitoring them for errors. The `link!` function can also be called within
    the function passed to a `spawn` form, in which case it must be passed the actor
    to be linked. To unlink two actors, we can use the `unlink!` function.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the Pulsar library provides some interesting ways to watch and link actors
    to perform error handling and recovery.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: Managing state with actors
  id: totrans-1442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, actors can have their own internal mutable state. Of
    course, accessing this state from other actors is not allowed, and immutable messages
    are the only way an actor can communicate with other actors. Another way that
    an actor can maintain or manage its state is by changing its behavior depending
    on the messages it receives, and this technique is called a *selective receive*.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: Every actor created using the `spawn` function can read its internal state using
    the expression `@state`, and can also write to this state using the `set-state!`
    function. The `set-state!` function will also return the new state of the actor,
    as returned by the expression `@state`. Note that both of these forms are implemented
    in the `co.paralleluniverse.pulsar.actors` namespace.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `add-using-state` function in *Example 8.11* that uses an actor
    to add two numbers. Of course, we would never really need such a function in the
    real world, and it is only demonstrated here to depict how an actor can change
    its internal state.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '*Example 8.11: A function to add two numbers using an actor*'
  id: totrans-1447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `add-using-state` function shown in *Example 8.11* creates an actor that
    sets its state to `0`, and adds the first two messages it receives to its state.
    The actor will return the latest state of the actor, as returned by the last call
    to `set-state!` in the function passed to the `spawn` macro. On calling the `add-using-state`
    function with two numbers, it produces their sum as its output, shown as follows:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'Another way in which an actor can modify its state is through a selective receive,
    in which the actor modifies its behavior on receiving a particular message. This
    is done by calling a `receive` form within the body of another `receive` form,
    as shown in *Example 8.12*:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '*Example 8.12: A function to add two numbers using an actor with selective
    receive*'
  id: totrans-1452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `add-using-selective-receive` function shown previously will set its state
    to `0`, receive the messages `m` and `n` through a selective receive, and add
    these messages. This function produces identical results as the `add-using-state`
    function from *Example 8.11*, as shown here:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: In this way, actors can change their internal state and behavior based on the
    messages sent to them.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: Comparing processes and actors
  id: totrans-1456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSPs and actors are two distinct approaches to modeling a system as a large
    number of concurrent processes that execute and interact asynchronously. The logic
    of an asynchronous task can reside within a process created using a `go` block,
    or within the function passed to the `spawn` macro that creates an actor. However,
    there are some subtle contrasts between these two approaches:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: Processes created using the `go` and `thread` forms encourage us to put all
    states onto channels. Actors, on the other hand, can have their own internal state,
    in addition to the state in the form of messages sent to them. Thus, actors are
    more like objects with encapsulated state, while processes are more like functions
    that operate on states stored in channels.
  id: totrans-1458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks created using the `go` or `thread` macros have no implicit error handling,
    and we must handle exceptions using the `try` and `catch` forms in the body of
    the `go` and `thread` macros. Of course, channels do support error handlers, but
    only when combined with a transducer. Actors, however, will save any exception
    they run into until we apply the `join` function on the actor. Also, actors can
    be linked and monitored to provide a form of automated error recovery. In this
    way, actors are more focused on building fault-tolerant systems.
  id: totrans-1459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These distinguishing factors between CSPs and the actor model give us an idea
    about which approach is more suitable for implementing asynchronous tasks in a
    given problem.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can create concurrent and asynchronous
    tasks using the `core.async` and Pulsar libraries. The `core.async` library provides
    an implementation of CSPs, and is supported in both Clojure and ClojureScript.
    We studied the various constructs in the `core.async` library and also demonstrated
    how a solution to the dining philosophers problem can be implemented using this
    library. Later on, we explored actors through the Pulsar library.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: We will explore reactive programming in the following chapter. As we will see
    ahead, reactive programming can be thought of as an extension of asynchronous
    programming for handling data and events.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Reactive Programming
  id: totrans-1464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the many interesting applications of programming with asynchronous tasks
    is *reactive programming*. This methodology of programming is all about asynchronously
    reacting to changes in state. In reactive programming, code is structured in such
    a way that it *reacts* to changes. Generally, this is implemented using asynchronous
    data streams, in which data and events are propagated asynchronously through a
    program. In fact, there are quite a few interesting variants of reactive programming.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is particularly useful in designing graphical user interfaces
    in frontend development, where changes in the internal state of an application
    must asynchronously trickle down to the user interface. A program is thus segregated
    into events and logic that is executed on those events. For programmers used to
    imperative and object-oriented programming techniques, the hardest part of reactive
    programming is thinking in reactive abstractions and letting go of old habits
    like using the mutable state. However, if you've been paying attention so far
    and have started thinking with immutability and functions, you'll find reactive
    programming quite natural. In the JavaScript world, reactive programming with
    *observables* can be thought of as a contrasting alternative to using promises
    to manage asynchronous events and actions.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore a few interesting forms of reactive programming
    through Clojure and ClojureScript libraries. Later on, we will also demonstrate
    how we can build dynamic user interfaces using reactive programming.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming with fibers and dataflow variables
  id: totrans-1468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dataflow programming* is one of the simplest forms of reactive programming.
    In dataflow programming, computations are described by composing variables without
    bothering about when these variables are set to a value. Such variables are also
    called **dataflow variables**, and they will trigger computations that refer to
    them once they are set. The *Pulsar* library ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar))
    provides a few useful constructs for dataflow programming. These constructs can
    also be used with Pulsar **fibers**, which we briefly talked about in [Chapter
    8](ch23.html "Chapter 8. Leveraging Asynchronous Tasks"), *Leveraging Asynchronous
    Tasks*. In this section, we will explore the basics of fibers and dataflow variables
    from the Pulsar library.'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'Your `project.clj` file must also contain the following entries:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: The elementary abstraction of an asynchronous task in the Pulsar library is
    a fiber. Fibers are scheduled for execution on fork-join based thread pools, and
    we can create a large number of fibers without bothering about the number of available
    processing cores. Fibers can be created using the `spawn-fiber` and `fiber` macros
    from the `co.paralleluniverse.pulsar.core` namespace. The `spawn-fiber` macro
    must be passed a function that takes no arguments, and the `fiber` form must be
    passed a body of expressions. The body of both these forms will be executed on
    a new fiber. The `join` function from the `co.paralleluniverse.pulsar.core` namespace
    can be used to retrieve the value returned by a fiber.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: An important rule we must keep in mind while dealing with fibers is that we
    must never call methods or functions that manipulate the current thread of execution
    from within a fiber. Instead, we must use fiber-specific functions from the `co.paralleluniverse.pulsar.core`
    namespace to perform these operations. For example, calling the `java.lang.Thread/sleep`
    method in a fiber must be avoided. Instead, the `sleep` function from the `co.paralleluniverse.pulsar.core`
    namespace can be used to suspend the current fiber for a given number of milliseconds.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c9/fibers.clj` of the book's
    source code. Some of these examples are based on code from the official Pulsar
    documentation ([http://docs.paralleluniverse.co/pulsar/](http://docs.paralleluniverse.co/pulsar/)).
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add two numbers using a fiber as shown in *Example 9.1*.
    Of course, using a fiber for such a trivial operation has no practical use, and
    it is only shown here to demonstrate how we can create a fiber and obtain its
    return value:'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '*Example 9.1: Adding two numbers with a fiber*'
  id: totrans-1483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The preceding `add-with-fiber` function creates a fiber `f` using the `spawn-fiber`
    macro and fetches the return value of the fiber using the `join` function. The
    fiber `f` will suspend itself for `100` milliseconds using the `sleep` function
    and then return the sum of `a` and `b`.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk a bit about dataflow variables. We can create dataflow variables
    using the `df-val` and `df-var` functions from the `co.paralleluniverse.pulsar.dataflow`
    namespace. A dataflow variable created using these functions can be set by calling
    it like a function and passing it a value. Also, the value of a dataflow variable
    can be obtained by dereferencing it using the `@` operator or the `deref` form.
    A dataflow variable declared using the `df-val` function can only be set once,
    whereas one created using the `df-var` function can be set several times.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: 'The `df-var` function can also be passed a function that takes no arguments
    and refers to other dataflow variables in the current scope. This way, the value
    of such a dataflow variable will be recomputed when the values of referenced variables
    are changed. For example, two numbers can be added using dataflow variables as
    shown in the `df-add` function defined in *Example 9.2*:'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '*Example 9.2: Adding two numbers with dataflow variables*'
  id: totrans-1488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The value of the dataflow variable `sum`, declared in the preceding `df-add`
    function, will be recalculated when the referenced dataflow variables `x` and
    `y` are set to a value. The variables `x` and `y` are set by calling them like
    functions. Similarly, we can add a number to each element in a range of numbers
    using the `df-val` and `df-var` functions as shown in the following *Example 9.3*:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '*Example 9.3: Adding a number to a range of number with dataflow variables*'
  id: totrans-1491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `df-add-to-range` function shown previously defines the dataflow variables
    `x`, `y`, and `sum`, where `sum` is dependent on `x` and `y`. The function then
    creates a fiber `f` that uses the `for` macro to return a sequence of values.
    Within the body of the `for` macro, the dataflow variable `y` is set to a value
    from the range `r`, and the value `@sum` is returned. The fiber thus returns the
    result of adding `a` to all elements in the range `r`, as shown in the following
    output:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: In conclusion, we can use the `df-val` and `df-var` functions to define dataflow
    variables, whose value can be recomputed when its referenced variables are changed.
    Effectively, changing the state of a dataflow variable may cause other dataflow
    variables to *react* to the change.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: We should note that the Pulsar library also implements channels, which are analogous
    to channels from the `core.async` library. In a nutshell, channels can be used
    to exchange data with fibers. The Pulsar library also provides constructs for
    reactive programming with channels, through the `co.paralleluniverse.pulsar.rx`
    namespace. These constructs are termed as *reactive extensions*, and are very
    similar to transducers, in the sense that they perform some computation on the
    values in a channel. Reactive extensions are also implemented by the *RxClojure*
    library. We should note that one of the limitations of both the Pulsar and RxClojure
    libraries is that they are available only on the JVM, and can't be used in ClojureScript
    programs. Thus, using `core.async` channels with transducers is a more feasible
    option in ClojureScript. Nevertheless, we will briefly explore reactive extensions
    through the RxClojure library in the following section.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: Using Reactive Extensions
  id: totrans-1496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactive Extensions** (written as **Rx**) are a generalized implementation
    of reactive programming that can be used to model event and data streams. Rx can
    be thought of as an object-oriented approach to reactive programming, in the sense
    that an event stream is an object with certain methods and properties. In Rx,
    asynchronous event streams are termed as *observables*. An entity or object that
    subscribes to events from an observable is called an *observer*. Reactive extensions
    are essentially a library of functions, or methods, to manipulate observables
    and create objects that conform to the observer-observable pattern. For example,
    an observable can be transformed using the Rx variants of the `map` and `filter`
    functions, as shown in the following illustration:'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Reactive Extensions](img/B05024_09_01.jpg)'
  id: totrans-1498
  prefs: []
  type: TYPE_IMG
- en: As shown previously, an observable can be described as a collection of values
    that vary over a period of time. It's quite evident that observables can be treated
    as a sequence of values using the Rx-flavored variants of the `map` and `filter`
    functions. An observable can also be subscribed to by an observer, and the observer
    will be asynchronously invoked for any value produced by an observable.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: We will now discuss the various constructs of the RxClojure library ([https://github.com/ReactiveX/RxClojure](https://github.com/ReactiveX/RxClojure)).
    There are several implementations of Rx across multiple languages, such as C#,
    Java, and PHP. The Java library for reactive extensions is RxJava, and the RxClojure
    library provides Clojure bindings to RxJava. As we mentioned earlier, it's important
    to note that RxClojure can only be used on the JVM. Also, the RxClojure library
    predates the implementation of transducers in Clojure, and thus channels and transducers
    are a more portable and generic approach to reactive programming.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: The `rx.lang.clojure.core` namespace contains functions for creating and manipulating
    observables. Observables are internally represented as collections of values.
    To extract values from observables, we can use functions from the `rx.lang.clojure.blocking`
    namespace. However, we must note that functions from the `rx.lang.clojure.blocking`
    namespace must be avoided in a program and used only for testing purposes. The
    `rx.lang.clojure.interop` namespace contains functions for performing Java interop
    with the underlying RxJava library.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `src/m_clj/c9/rx.clj` of the book's source
    code.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: 'A value can be converted to an observable using the `return` function from
    the `rx.lang.clojure.core` namespace. An observable can be converted to a vector
    of values using the `rx.lang.clojure.blocking/into` function, and similarly, we
    can obtain the first value of an observable using the `rx.lang.clojure.blocking/first`
    function. These functions are demonstrated in the following output:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  id: totrans-1510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'A sequence of values can be converted to an observable using the `seq->o` function
    from the `rx.lang.clojure.core` namespace. To convert the observable back to a
    sequence, we pass it to the `o->seq` function from the `rx.lang.clojure.blocking`
    namespace. For example, we can convert the vector `[1 2 3]` to an observable and
    back to a sequence, as shown here:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'Another way of creating an observable is by using the `cons` and `empty` functions
    from the `rx.lang.clojure.core` namespace. The `empty` function creates an observable
    with no values, and the `cons` function adds or combines a value and an observable
    into a new, observable, similar to the standard `cons` function. We can create
    an observable containing the value `0` using the `cons` and `empty` functions
    as follows:'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'As we mentioned earlier, observers can subscribe to events from observables.
    Observers can be defined by implementing the `rx.lang.clojure.Observer` interface.
    This interface defines three methods, namely `onNext`, `onError`, and `onCompleted`.
    The `onNext` method is called whenever an observable produces a new value, and
    the `onCompleted` method is called when an observable is done producing values.
    The `onError` method will be called in case an exception is encountered. Interestingly,
    all of these methods will be invoked asynchronously from an observable. For example,
    we can create an observer using the `reify` form to implement the `Observer` interface
    as shown in *Example 9.4*:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '*Example 9.4: Implementing the rx.lang.clojure.Observer interface*'
  id: totrans-1517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An observable can call the methods of all its subscribed observers using the
    `on-next`, `on-error` and `on-completed` functions from the `rx.lang.clojure.core`
    namespace. We can also define an observable using these functions and the `observable*`
    form from the `rx.lang.clojure.core` namespace. The `observable*` form must be
    passed a function that takes a single argument, which represents an observer.
    For example, we can define a function to create an observable of two values using
    the `observable*` form as shown in *Example 9.5*:'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '*Example 9.5: Creating an observable using the observable* form*'
  id: totrans-1520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The function passed to the `observable*` form, shown previously, calls the
    `on-next` and `on-completed` functions to produce an observable of two values.
    We can convert this observable into a vector using the `into` function from the
    `rx.lang.clojure.blocking` namespace, as shown here:'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'An observer can also be created using the `subscribe` function from the `rx.lang.clojure.core`
    namespace. This function must be passed a function that takes a single value,
    and an observer will be created by implementing the `onNext` method using the
    supplied function. We can also pass a second argument representing the `onError`
    method, as well as a third argument that represents the `onCompleted` method,
    to the `subscribe` function. For example, we can subscribe to an observable using
    the `subscribe` function, and apply a function to all values in the observable
    using the `rx.lang.clojure.core/map` function, as shown in *Example 9.6*:'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '*Example 9.6: Subscribing to an observable using the subscribe function*'
  id: totrans-1525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can create an observable and pass it to the `rx-inc` function defined in
    *Example 9.6*, as shown here:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'The function passed to the `subscribe` form in *Example 9.6* is executed every
    time the `inc` function is applied to a value in the observable `o`. We could
    as well define the `rx-inc` function using Java interop with RxJava, as shown
    in *Example 9.7*:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '*Example 9.7: Subscribing to an observable using the Java interop*'
  id: totrans-1530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It''s quite clear that using the RxJava library through Java interop isn''t
    pretty, as we would have to wrap all the functions in the `action` and `fn` forms
    from the `rx.lang.clojure.interop` namespace. The `action` macro is used to represent
    a function that performs a side-effect, whereas the `fn` macro is used to wrap
    functions that return values. Observables can also be created using the Java interop.
    This is done using the `from` static method from the `rx.lang.clojure.core.Observable`
    class. The following output demonstrates this method as well as the `rxj-inc`
    function defined in *Example 9.7*:'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'Of course, we should prefer to use functions from the `rx.lang.clojure.core`
    namespace, and we are using Java interop here only to show that it is possible.
    Similar to the `map` function used in *Example 9.6*, there are several other functions
    in the `rx.lang.clojure.core` namespace that allow us to treat observables as
    sequences. Thus, functions such as `map`, `filter`, and `mapcat` comprise the
    interface of observables, and describe the many ways in which we can interact
    with them. For example, the following output demonstrates the Rx variants of the
    `take`, `cycle`, and `range` functions:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'The `rx.lang.clojure.core` namespace also provides a `filter` function that
    can be used with an observable and a predicate, as shown here:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'The `group-by` and `mapcat` functions from the `rx.lang.clojure.core` namespace
    have the same semantics as the standard versions of these functions. For example,
    let''s define a function that uses the `group-by` and `mapcat` functions, as shown
    in *Example 9.8*:'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '*Example 9.8: Using the group-by and mapcat functions*'
  id: totrans-1539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `group-maps` function, defined previously, will transform a number of maps
    into an observable, group the maps by their values for the key `:k`, and create
    a number of vectors using the `mapcat` and `map` functions. Of course, we wouldn''t
    really need such a function in practice, and it''s only shown here to demonstrate
    how the `group-by` and `mapcat` functions can be used. We can pass a vector of
    maps to the `group-maps` function to produce a sequence of vectors, as shown here:'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'Several observables can be combined using the `merge` function from the `rx.lang.clojure.core`
    namespace. The `merge` function can be passed any number of observables, as shown
    here:'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  id: totrans-1543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'An observable can also be split up into two observables using the `split-with`
    function from the `rx.lang.clojure.core` namespace. This function must be passed
    an observable and a predicate function, as shown here:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: In summary, the RxClojure library provides us with several constructs for creating
    and manipulating observables. We can also easily create observers that asynchronously
    *react* to observables using the `subscribe` function from this library. Also,
    the constructs from the `rx.lang.clojure.core` namespace have semantics similar
    to that of standard functions such as `map`, `filter`, and `mapcat`. There are
    several functions in the `rx.lang.clojure.core` namespace that we haven't talked
    about in this section, and you're encouraged to explore them on your own.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: Using functional reactive programming
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A more functional flavor of reactive programming is **functional reactive programming**
    (abbreviated as **FRP**). FRP was first described in the late '90s by Conal Elliott,
    who was a member of the Microsoft Graphics Research Group at the time, and Paul
    Hudak, a major contributor to the Haskell programming language. FRP was originally
    described as a bunch of functions to interact with *events* and *behaviors*. Both
    events and behaviors represent values that change over time. The major difference
    between these two is that events are values that change discretely over time,
    whereas behaviors are continuously changing values. There is no mention of an
    observer-observable pattern in FRP. Also, programs in FRP are written as composable
    transformations of events and behaviors, and are also termed as **compositional
    event systems** (**CESs**).
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: Modern implementations of FRP provide constructs to create and transform asynchronous
    event streams. Also, any form of state change is represented as an event stream.
    In this perspective, a click of a button, a request made to a server, and mutating
    a variable, can all be treated as event streams. The *Bacon.js* library ([https://github.com/baconjs/bacon.js/](https://github.com/baconjs/bacon.js/))
    is a JavaScript implementation of FRP, and the *Yolk* library ([https://github.com/Cicayda/yolk](https://github.com/Cicayda/yolk))
    provides ClojureScript bindings to the Bacon.js library. In this section, we will
    briefly study the constructs provided by the Yolk library.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'In addition to the preceding dependencies, the following examples also use
    the `set-html!` and `by-id` functions from `src/m_clj/c9/common.cljs`. These functions
    are defined as follows:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Ensure that the code in the following ClojureScript examples is compiled, using
    the following command:'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  id: totrans-1558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: The `yolk.bacon` namespace provides several functions to create event streams,
    such as the `later` and `interval` functions. The `later` function creates an
    event stream that produces a single value after a given delay. The `interval`
    function can infinitely repeat a value with a given time interval. Both these
    functions must be passed a number of milliseconds as the first argument and a
    value to produce as the second argument.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: Event streams in the Yolk library may produce an infinite number of values.
    We can limit the number of values produced by an event stream by using the `yolk.bacon/sliding-window`
    function, which creates an event stream that drops older values once it's full.
    This function must be passed an event stream and a number indicating the capacity
    of the event stream returned by it.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: We can also create an *event bus*, onto which we can arbitrarily push values,
    using the `bus` function from the `yolk.bacon` namespace. The `push` function
    puts a value onto an event bus, and the `plug` function connects an event bus
    to another event stream.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: To listen to values produced from event streams, we can use the `on-value`,
    `on-error`, and `on-end` functions. The `on-value` and `on-error` functions will
    call a supplied 1-arity function whenever a given event stream produces a value
    or an error, respectively. The `on-end` function will call a supplied function
    that takes no arguments whenever a stream ends. This function is often used with
    the `yolk.bacon/never` function, which creates an event stream that ends immediately
    without producing a value.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: Event streams can also be combined in several ways. The `merge-all` function
    combines a vector of several event streams into a single one. Another function
    that can collect values from several event streams in this way is the `flat-map`
    function. Alternatively, the `combine-array` function can be used to create a
    single event stream that produces arrays of the values from the supplied streams.
    The `yolk.bacon/when` function can be used to conditionally combine several channels.
    This function must be passed a number of clauses, similar to the `cond` form.
    Each clause must have two parts—a vector of event streams and an expression that
    will be invoked when all the supplied event streams produce values.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: The `yolk.bacon` namespace also provides event stream based variants of the
    standard `map`, `filter`, and `take` functions. These functions take an event
    stream as the first argument, which is a little different from the semantics of
    the standard versions of these functions.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: Using these functions from the Yolk library, we can implement a simplified ClojureScript
    based solution to the dining philosophers problem, which we described in the previous
    chapters. For a detailed explanation of the dining philosophers problem and its
    solution, refer to [Chapter 2](ch17.html "Chapter 2. Orchestrating Concurrency
    and Parallelism"), *Orchestrating Concurrency and Parallelism* and [Chapter 8](ch23.html
    "Chapter 8. Leveraging Asynchronous Tasks"), *Leveraging Asynchronous Tasks*.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following examples can be found in `src/m_clj/c9/yolk/core.cljs` of the
    book''s source code. Also, the HTML page for the following ClojureScript examples
    can be found in `resources/html/yolk.html`. The following scripts will be included
    in this page:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'In this implementation of the dining philosophers problem, we will represent
    the state of the philosophers and the forks on the table using event buses. The
    event buses can then be combined using the `when` function from the Yolk library.
    We won''t maintain much state about the philosophers for the sake of simplicity.
    Let''s first define functions to print the philosophers and represent the routine
    of a philosopher, as shown in the following *Example 9.9*:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '*Example 9.9: Solving the dining philosophers problem with event streams*'
  id: totrans-1571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding `render-philosophers` function will wrap each philosopher in
    a `div` tag, which will be displayed on a web page. The `philosopher-fn` function
    returns a function that represents the routine of a philosopher. The function
    returned by the `philosopher-fn` function sets off a task, using the `setTimeout`
    JavaScript function, to push values representing a particular philosopher and
    his associated forks into the event buses. This function will finally return a
    string indicating that the given philosopher was able to eat the food supplied
    to him. Using these functions, we can create a simulation of the dining philosophers
    problem in a web page, as shown in the following *Example 9.10*:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  id: totrans-1573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '*Example 9.10: Solving the dining philosophers problem with event streams (continued)*'
  id: totrans-1574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the `let` form shown in *Example 9.10*, we created the philosophers and
    forks in our simulation using the `bus` function from the Yolk library. The values
    produced by these event buses are then combined using a `when` form. The `when`
    function in the preceding code will check for events from a philosopher and the
    forks on his left- and right-hand side. The combinations of philosophers and forks
    are, in fact, hardcoded into the clauses of the `when` form. Of course, we must
    understand that the clauses of the `when` form shown previously could have easily
    been generated using a macro. Values are then placed onto the event buses representing
    the philosophers and forks using the `push` function, to start the simulation.
    The last five philosophers who could eat are rendered in the web page, as shown
    here:'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '![Using functional reactive programming](img/B05024_09_02.jpg)'
  id: totrans-1576
  prefs: []
  type: TYPE_IMG
- en: In summary, the Yolk library provides several constructs to handle event streams.
    There are several functions from this library that we haven't discussed, and you
    should explore them on your own. In the following section, we will provide examples
    that demonstrate the other functions from the Yolk library.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the preceding examples are based on code from *Yolk examples* by Wilkes
    Joiner ([https://github.com/Cicayda/yolk-examples](https://github.com/Cicayda/yolk-examples)).
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: Building reactive user interfaces
  id: totrans-1580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary applications of reactive programming is frontend development,
    where we must create user interface components that react asynchronously to changes
    in state. In this section, we will describe a few examples implemented using the
    `core.async` library and the Yolk library. This is meant to give you a comparison
    between channels and event streams, and also demonstrate how we can design solutions
    to problems using both these concepts. Note that only the overall design and code
    for these examples will be described, and you should be able to fill in the details
    on your own.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  id: totrans-1584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'In addition to the preceding dependencies, the following examples also use
    the `set-html!` and `by-id` functions from `src/m_clj/c9/common.cljs`. Ensure
    that the code in the following ClojureScript examples is compiled, using the following
    command:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: As a first example, let's create three asynchronous tasks that each produce
    values at different time intervals. We must fetch all the values produced by these
    tasks and render them on a web page in the same order.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following examples can be found in `src/m_clj/c9/reactive/core.cljs` of
    the book''s source code. Also, the HTML page for the following ClojureScript examples
    can be found in `resources/html/reactive.html`. The following scripts will be
    included in this page:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'We could implement this using processes and channels from the `core.async`
    library. In this case, channels will convey the values produced by three processes,
    and we will use a `merge` operation to combine these channels, as shown in the
    following *Example 9.11*:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '*Example 9.11: Three asynchronous tasks using channels*'
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding `start-process` function will create a process that periodically
    produces values using the `go` form, and returns a channel from which the values
    can be read. The `render-div` function will generate HTML for the values produced
    by the three tasks. Only the ten most recent values will be shown. This code will
    produce the following output:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: '![Building reactive user interfaces](img/B05024_09_03.jpg)'
  id: totrans-1597
  prefs: []
  type: TYPE_IMG
- en: 'We could also implement the preceding example using FRP, in which values produced
    by each of the three tasks are represented as event streams. The `merge-all` function
    from the `yolk.bacon` namespace can be used to combine these event streams, and
    the `sliding-window` function can obtain the ten most recent values produced by
    the resulting stream. The `render-div` function from *Example 9.11* can be reused
    to render the values. This is implemented in *Example 9.12*, and produces the
    same output as *Example 9.11*:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '*Example 9.12: Three asynchronous tasks using FRP*'
  id: totrans-1600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, let''s try to capture mouse events from a particular `div` tag, and display
    the page offset values of the locations of these events. We can do this with channels,
    but we would first need a function to convey DOM events onto a channel. We can
    implement this using the `goog.events/listen` and `cljs.core.async/put!` functions,
    as shown in *Example 9.13*:'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '*Example 9.13: A function to convey events onto a channel*'
  id: totrans-1603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can now use the `listen` function defined previously to listen to the `goog.events.EventType.MOUSEMOVE`
    event type from a particular `div` tag. The values will have to be converted to
    page offsets, and this can be done using the `getPageOffsetLeft` and `getPageOffsetTop`
    functions from the `goog.style` namespace. This implementation is described in
    *Example 9.14*:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '*Example 9.14: Mouse events using channels*'
  id: totrans-1606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can also implement a solution to this problem using the `from-event-stream`
    and `map` functions from the Yolk library. Interestingly, the events produced
    by the stream returned by the `from-event-target` function will have page offsets
    of the event stored as the `pageX` and `pageY` properties. This allows us to have
    a much simpler implementation, as shown in *Example 9.15*:'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '*Example 9.15: Mouse events using FRP*'
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Both of the implementations shown in *Example 9.14* and *Example 9.15* work
    as expected, and produce the following output:'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: '![Building reactive user interfaces](img/B05024_09_04.jpg)'
  id: totrans-1611
  prefs: []
  type: TYPE_IMG
- en: 'As a final example, we will simulate several search queries being performed
    and display the results from the first three queries that return results. The
    queries can be described as: two queries for web results, two queries for image
    results, and two queries for video results. We can implement these simulated queries
    as shown in *Example 9.16*:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '*Example 9.16: Simulating search queries with channels*'
  id: totrans-1614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `chan-search` function returns a function that uses the `cljs.core.async/timeout`
    function to simulate a search query by parking the current task for a random number
    of milliseconds. Using the `chan-search` function, we create several queries for
    the different kinds of results we are interested in. Using these functions, we
    can implement a function to perform all the queries and return the first three
    results, as shown in *Example 9.17*:'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  id: totrans-1616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '*Example 9.17: Simulating search queries with channels (continued)*'
  id: totrans-1617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As shown in the preceding example, the `merge` function can be used to combine
    channels that produce the results of the search queries. Note that the queries
    to all three types of results, namely web, images, and videos, are timed out after
    `80` milliseconds. We can bind the `chan-search-fastest` function to the click
    of a mouse button using the `listen` function we defined earlier, as shown in
    *Example 9.18*:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '*Example 9.18: Simulating search queries with channels (continued)*'
  id: totrans-1620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Clicking on the button bound to the `chan-search-fastest` function will show
    the following output. Note that the `nil` value in the following output indicates
    a timeout of all queries for a particular search result type.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: '![Building reactive user interfaces](img/B05024_09_05.jpg)'
  id: totrans-1622
  prefs: []
  type: TYPE_IMG
- en: 'We can just as easily implement an FRP version of the simulation of search
    queries that was previously described. The queries for the various sources of
    data are defined as shown in the following *Example 9.19*:'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  id: totrans-1624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '*Example 9.19: Simulating search queries with FRP*'
  id: totrans-1625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding functions all return event streams for search results. The search
    results produced can be combined with timeouts using the `later`, `merge`, and
    `combine-as-array` functions from the `yolk.bacon` namespace, as shown in *Example
    9.20*:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '*Example 9.20: Simulating search queries with FRP (continued)*'
  id: totrans-1628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `frp-search-fastest` function can be invoked on clicking a button, as shown
    in *Example 9.21*:'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  id: totrans-1630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '*Example 9.21: Simulating search queries with FRP (continued)*'
  id: totrans-1631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding example produces the following output when the search button
    is clicked:'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '![Building reactive user interfaces](img/B05024_09_06.jpg)'
  id: totrans-1633
  prefs: []
  type: TYPE_IMG
- en: In conclusion, we can use both channels and event streams to implement interactive
    interfaces in web pages. Although the FRP implementations of the preceding examples
    are slightly shorter, we can say that both the `core.async` and Yolk libraries
    have their own elegance.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding examples are based on code from *Communicating Sequential Processes*
    by David Nolen ([http://swannodette.github.io/2013/07/12/communicating-sequential-processes/](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/))
    and *CSP vs. FRP* by Draco Dormiens ([http://potetm.github.io/2014/01/07/frp.html](http://potetm.github.io/2014/01/07/frp.html)).
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Om
  id: totrans-1637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Om* library ([https://github.com/omcljs/om](https://github.com/omcljs/om))
    is a great tool for building dynamic user interfaces in ClojureScript. In fact,
    it's an interface to *React.js* ([http://facebook.github.io/react/](http://facebook.github.io/react/)),
    which is a JavaScript library for creating interactive user interface components.
    Om lets us define a user interface as a hierarchy of components, and each component
    reactively modifies its appearance based on changes to the component's state.
    In this way, Om components *react* to changes in their state.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'In addition to the preceding dependencies, the following examples also use
    the `by-id` function from `src/m_clj/c9/common.cljs`. Ensure that the code in
    the following ClojureScript examples is compiled, using the following command:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: The Om components are generally defined by implementing the `IRender` and `IRenderState`
    protocols from the `om.core` namespace. The `IRender` protocol declares a single
    function `render`, and similarly the `IRenderState` protocol declares the `render-state`
    function. The `render` and `render-state` functions define how a component that
    implements either of these protocols is converted to DOM, which can be rendered
    by a web browser. The implementations of these functions must return a DOM object
    constructed using functions from the `om.dom` namespace. There are also several
    other protocols in the `om.core` namespace that allow us to define a component's
    behavior. Internally, Om uses React.js to perform batched updates to the DOM for
    the sake of performance, and uses *virtual DOM* to maintain the state of the DOM
    to be rendered.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following examples can be found in `src/m_clj/c9/om/core.cljs` of the book''s
    source code. Also, the HTML page for the following ClojureScript examples can
    be found in `resources/html/om.html`. The following scripts will be included in
    this page:'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Let''s now build a simple component using Om. Suppose we want to build a web
    application. One of the first steps in doing so is creating a login page for our
    application. As an example, let''s create a simple login form with Om. A user
    will enter their username and password in this form. The only requirement is that
    the submit button of this form must be enabled only if the user has entered a
    username and password. Let''s start off by defining some functions to create an
    input field of a form, as shown in *Example 9.22*:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '*Example 9.22: A login form using Om*'
  id: totrans-1652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `update-input-value-fn` function defined in *Example 9.22* accepts a component
    `owner` as an argument and returns a function that we can bind to a DOM event.
    The returned function updates the state of the component with the value of the
    `.-value` property using the `set-state!` function from the `om.core` namespace.
    The `input-field` function returns a DOM object for an input field with some associated
    properties. The `input-field` function also creates an event handler using the
    `update-input-value-fn` function and binds it to the `onChange` event of the input
    field.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that a component can change its state or the global application state by
    using the `set-state!`, `update-state!`, `update!`, or `transact!` functions from
    the `om.core` namespace.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define a form as a component using the `om.core/IRenderState`
    protocol and `input-field` function, as shown in *Example 9.23*:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '*Example 9.23: A login form using Om (continued)*'
  id: totrans-1658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding `form` function creates a component by implementing the `render-state`
    function of the `IRenderState` protocol. This component also implements the `IInitState`
    protocol to define the initial state of the component. The `form` function will
    render a login form with two input fields, for a username and password, and a
    login button. The button is enabled only when the username and password are entered.
    Also, the component is mounted onto a `div` using the `om.core/root` function.
    The following output in a web page describes the behavior of the component defined
    by the `form` function:'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Om](img/B05024_09_07.jpg)'
  id: totrans-1660
  prefs: []
  type: TYPE_IMG
- en: The preceding output describes two states of the login form component defined
    by the `form` function. The login button is observed to be disabled when either
    the username or password fields are empty, and is enabled only when the user enters
    values in both of these input fields. In this way, the login form *reacts* to
    changes in the state of its input fields.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [https://github.com/omcljs/om/wiki/Documentation](https://github.com/omcljs/om/wiki/Documentation)
    for complete documentation on all the protocols, functions, and macros in the
    Om library.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the Om library provides us with several constructs for creating interactive
    and stateful components.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed reactive programming through the Pulsar, RxClojure,
    and Yolk libraries. We have also described several ClojureScript examples that
    compare channels from the `core.async` library to reactive event streams from
    the Yolk library. We also demonstrated how we can leverage the Om library to build
    dynamic user interfaces.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore how we can test our Clojure programs.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10. Testing Your Code
  id: totrans-1668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an integral part of developing software. Alongside implementing functionality
    in our software, it is imperative to simultaneously define tests to verify several
    aspects of it. The Clojure standard library provides several constructs to define
    tests and mock data. There are also several community libraries that allow us
    to verify different aspects of the code being tested.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using tests is that they allow us to identify the overall
    impact of a particular change in a program's code. If we have tests to check the
    functionality of a program, we can refactor the program with confidence and without
    the fear of losing any functionality. If there's something that we unavoidably
    missed while refactoring a program, it will surely be brought to our attention
    when we run the program's tests. Thus, tests are indispensable tools for keeping
    code maintainable.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study the different ways in which we can write tests
    in Clojure. We will also discuss how we can perform type checking in Clojure.
    Although we describe several libraries for writing tests in this chapter, we must
    note that there are several more available in the Clojure ecosystem. That aside,
    the libraries described in this chapter are the most mature and battle-hardened
    tools for testing our code.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  id: totrans-1672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being a thoughtfully designed language, Clojure has a built-in unit testing
    library, namely `clojure.test`. Apart from that, there are a couple constructs
    in the core language that are helpful with regard to testing. Of course, these
    constructs don't allow us to define and run any tests in the formal sense, and
    the constructs from the `clojure.test` namespace must be preferred for that purpose.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: Let's start off by briefly discussing the constructs from the core language
    that can be used for unit testing. The `assert` function checks whether an expression
    evaluates to a truthy value at runtime. This function will throw an exception
    if the expression passed to it does not evaluate to a truthy value, and the message
    of this exception can be optionally specified as a second argument to the `assert`
    form. We can effectively disable all the `assert` forms in a given program by
    using the global `*assert*` compile time `var`. This variable can only be changed
    by a top-level `set!` form in a given program or namespace.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting aspect of testing that is easily tackled by the core language
    is *mocking* and *stubbing*. In a nutshell, these techniques allow us to redefine
    the behavior of certain functions within the context of a test case. This is useful
    in preventing functions from performing unwanted side effects or using unavailable
    resources. In the Clojure language, this can be done using the `with-redefs` function.
    This form can be used within tests as well as plain functions, but its usage outside
    of the scope of tests is not really encouraged. Its semantics are similar to that
    of the standard `let` form, and you are encouraged to go through the Clojure docs
    for examples on the `with-redefs` form.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how we can actually define tests using constructs from the
    `clojure.test` namespace.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: Defining unit tests
  id: totrans-1677
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure has support for defining unit tests baked into it. The `clojure.test`
    namespace, which requires no additional dependencies whatsoever, provides several
    constructs for testing our code. Let's explore a few of them.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  id: totrans-1681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: The following examples can be found in `test/m_clj/c10/test.clj` of the book's
    source code.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests can be defined using the `deftest` macro. This form must be passed a
    symbol, indicating the name of the defined test, and any number of expressions.
    Generally, `is` and `are` forms are used within the `deftest` macro. The `is`
    form must be passed an expression, and will fail the test if the supplied expression
    does not return a truthy value. The `are` form must be passed a vector of variable
    names, a condition to test, and values for the defined variables. For example,
    the standard `*` function can be tested as shown in *Example 10.1*:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '*Example 10.1: Defining tests using the clojure.test namespace*'
  id: totrans-1685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding code defines two tests using the `is` and `are` forms. We can
    run tests using the `run-tests` and `run-all-tests` functions from the `clojure.test`
    namespace. The `run-tests` function can be passed any number of namespaces, and
    will run all the tests defined in them. Also, this form can be called without
    passing any arguments, in which case it will run all the tests in the current
    namespace. The `run-all-tests` function will run all the tests in all namespaces
    of the current project. It can optionally be passed a regular expression, and
    will only run the tests from matching namespaces if this argument is supplied.
    In fact, an IDE with integrated support for running tests will call these functions.
    For example, we can run the tests we defined in *Example 10.1* using the `run-tests`
    function shown here:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'As shown in the preceding output, the `run-tests` function executes both the
    tests, and both of them pass. Let''s now define a test that will fail, although
    we shouldn''t really be doing this unless we have a good reason:'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '*Example 10.2: A test that fails*'
  id: totrans-1690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The test `test-*-fails` shown in *Example 10.2* will fail when it is run, as
    shown here:'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: In fact, defining tests that fail should be considered a part and parcel of
    developing a program. To start a feature or fix a bug in a program, we must first
    define a test that validates this change (by failing!). We should then proceed
    to implement the feature or fix, such that all the newly defined tests pass. These
    two steps are then repeated, until all the requirements of our feature or fix
    are met. This is the essence of **test-driven development** (**TDD**).
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also run the tests defined in a given namespace using the following
    command:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: The `clojure.test` namespace must be used for testing programs written strictly
    in Clojure. For testing ClojureScript programs in the same way, we can use the
    *doo* library ([https://github.com/bensu/doo](https://github.com/bensu/doo)),
    which provides ClojureScript implementations of the `deftest`, `is`, and `are`
    constucts.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: Using top-down testing
  id: totrans-1698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more powerful way to define tests in Clojure is by using the *Midje* library
    ([https://github.com/marick/Midje](https://github.com/marick/Midje)). This library
    provides several constructs that allow us to easily define unit tests by describing
    relationships between several functions, rather than describing the implementation
    of the functions themselves. This approach is also called *top-down testing*,
    and Midje champions this kind of testing methodology. Let's dive into the details
    of the Midje library.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'We must also include the following dependencies in the `:plugins` section of
    your `project.clj` file:'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: The following examples can be found in `test/m_clj/c10/midje.clj` of the book's
    source code.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s define a simple function that we intend to test, as shown in
    *Example 10.3*:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '*Example 10.3: A simple function to test*'
  id: totrans-1710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can define tests for the `first-element` function using the `facts` and `fact`
    constructs from the `midje.sweet` namespace, as shown in *Example 10.4*.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  id: totrans-1712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '*Example 10.4: Tests for the first-element function*'
  id: totrans-1713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As shown in the preceding code, the `fact` form describes a test, and can be
    passed any number of clauses. Each clause is comprised of an expression, a `=>`
    symbol, and the expected return value of the supplied expression. The `facts`
    form is simply used to group together several `fact` forms. It's quite apparent
    that instead of checking logical conditions, we use `fact` forms to check expressions
    and the values returned by them.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: 'The `provided` form can be used to mock function calls. The Midje library allows
    us to use *metaconstants* in our tests, and they are often used with the `provided`
    form. Metaconstants can be thought of as generic placeholders for values and functions.
    All metaconstants should start and end with two or more dots (`.`) or hyphens
    (`-`); hyphens are more suitable for metaconstants representing functions. For
    example, we can test the `first-element` function we defined earlier using metaconstants
    and the `provided` form as shown in *Example 10.5*:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '*Example 10.5: Using the provided form and metaconstants*'
  id: totrans-1717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the test shown previously, the metaconstant `..seq..` is used to indicate
    the first argument passed to the `first-element` function, and the `provided`
    form mocks the call to the `empty?` function. This way, we can implement tests
    without completely implementing the functions being tested. Of course, we should
    avoid mocking or redefining standard functions in the `provided` form. For example,
    suppose we have three partially implemented functions, as shown in *Example 10.6*.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  id: totrans-1719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '*Example 10.6: Partially implemented functions to test*'
  id: totrans-1720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that only the `overall-cost-of-car` function is completely implemented
    in the preceding code. Nevertheless, we can still test the relation between these
    three functions using the Midje library, as shown in *Example 10.7*.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '*Example 10.7: Testing the is-diesel?, cost-of-car and overall-cost-of-car
    functions*'
  id: totrans-1723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the test shown previously, the `cost-of-car` and `is-diesel?` functions
    are mocked using the `provided` form and the `..car..` metaconstant, and the value
    returned by the `overall-cost-of-car` function is checked. We can run all of the
    tests we have defined so far using the `autotest` function from the `midje.repl`
    namespace, as shown here:'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Note
  id: totrans-1726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also run the tests defined in a given namespace using the following
    command. Note that the following command will watch your project for file changes,
    and will run the tests in any files once they are changed:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: In this way, we can use the Midje library to write tests, even for functions
    that haven't been completely implemented. Midje allows us to describe tests as
    relations between functions using metaconstants. In summary, the `clojure.test`
    and Midje libraries are great tools for defining unit tests.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: Testing with specs
  id: totrans-1730
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now take a look at the Speclj, pronounced *speckle*, library ([https://github.com/slagyr/speclj](https://github.com/slagyr/speclj)),
    which is used to write *specs*. Specs are similar to unit tests, but are focused
    on the behavior of functions being tested, rather than their internal implementation.
    In fact, **behavior-driven development** (**BDD**) is centered about writing specs.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between TDD and BDD is that BDD focuses on the behavior
    or specifications of functions, rather than their implementation. From this perspective,
    if we change the internal implementation of a function that has been previously
    tested, there is a smaller chance that we have to modify the tests, or rather
    specs, associated with the function. BDD can also be thought of as a refined approach
    to TDD, in which the interface and behavior of a function is more important than
    its internal implementation. Now, let's study the various constructs of the Speclj
    library.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples.
    We must also include the following dependencies in the `:plugins` section of your
    `project.clj` file:'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  id: totrans-1735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: The `describe`, `it`, and `should` forms, from the `speclj.core` namespace,
    are used to define specs for a given function. The `it` form represents a single
    specification for the function being tested, and the `describe` form is used to
    group together several specs together. Assertions within an `it` form can be expressed
    using the `should` form and its variants. For example, we can write a spec for
    the behavior of the standard `*` function, as shown in the following *Example
    10.8*.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `spec/m_clj/c10/speclj.clj` of the book's
    source code.
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '*Example 10.8: A spec for the * function*'
  id: totrans-1742
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The spec shown previously checks a single condition using the `should` and `=`
    forms. There are several variants of the `should` form, such as `should=`, `should-not`,
    `should-fail`, and `should-throw`. These forms are pretty much self-explanatory,
    and you are encouraged to go through the Speclj docs for more details. We can
    describe some specs for the standard `/` function, as shown in *Example 10.9*.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '*Example 10.9: Specs for the / function using several it forms*'
  id: totrans-1745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Within a `describe` form, we can use the `before` and `after` forms to execute
    arbitrary code before or after each `it` form is checked. Similarly, the `before-all`
    and `after-all` forms can specify what to execute before and after all the specs
    are checked in a `describe` form.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: 'Input and output performed by a certain function can be described using specs.
    This is done using the `with-out-str` and `with-in-str` forms. The `with-out-str`
    form returns whatever data is sent to standard output by a given expression. Conversely,
    the `with-in-str` form must be passed a string and an expression, and the supplied
    string will be sent to the standard input once the supplied expression is called.
    For example, let''s say we have a simple function that reads a string and prints
    it. We can write a spec for such a function using the `with-out-str` and `with-in-str`
    forms as shown in *Example 10.10*:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  id: totrans-1748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '*Example 10.10: A spec for a function that reads a string and prints it*'
  id: totrans-1749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can also mock function calls within an `it` form using the standard `with-redefs`
    macro we described earlier. For example, we can write a spec for the `echo` function
    described in *Example 10.10* by mocking the `read-line` and `println` functions
    as shown in *Example 10.11*. Obviously, it's not advisable to mock standard functions,
    and it's only done here to depict the usage of the `with-redefs` macro within
    a spec.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  id: totrans-1751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '*Example 10.11: Using the with-redefs macro within a spec*'
  id: totrans-1752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To run all the specs defined in a given project, we can call the `run-specs`
    macro, as shown here:'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: Note
  id: totrans-1755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also run the specs defined in a given namespace using the following
    command. Note that the following command will watch your project for file changes,
    and will run the specs in any files once they are changed:'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  id: totrans-1757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: To summarize, the Speclj library provides us with several constructs to define
    specs for BDD. Specs for a given function should be modified only when the required
    functionality or behavior of a function must be changed. With specs, there's less
    of a chance that modifying the underlying implementation of a function will require
    a change in its associated specs. Of course, the question of whether you should
    use specs or tests in your project is a subjective one. Some projects do fine
    with simple tests, and others prefer to use specs.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: Generative testing
  id: totrans-1759
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another form of testing is **generative testing**, in which we define properties
    of functions that must hold true for all inputs. This is quite different compared
    to enumerating the expected inputs and outputs of functions, which is essentially
    what unit tests and specs do. In Clojure, generative testing can be done using
    the `test.check` library ([https://github.com/clojure/test.check](https://github.com/clojure/test.check)).
    This library is inspired by Haskell's QuickCheck library, and provides similar
    constructs for testing properties of functions.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  id: totrans-1763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: The following examples can be found in `src/m_clj/c10/check.clj` of the book's
    source code.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a property to check, we can use the `for-all` macro from the `clojure.test.check.properties`
    namespace. This macro must be passed a vector of generator bindings, which can
    be created using constructs from the `clojure.test.check.generators` namespace,
    along with a property to verify. For example, consider the properties defined
    in *Example 10.12*:'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  id: totrans-1768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '*Example 10.12: Simple properties defined using the test.check library*'
  id: totrans-1769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the preceding code, we have defined two properties, namely `commutative-mult-prop`
    and `first-is-min-after-sort-prop`. The `commutative-mult-prop` property asserts
    that a multiplication operation using the `*` function is commutative, and the
    `first-is-min-after-sort-prop` function checks whether the first element of a
    vector of integers sorted using the `sort` function is the smallest value in the
    vector. Note the use of the `int`, `vector` and `non-empty` functions from the
    `clojure.test.check.generators` namespace. We can verify that these properties
    are true using the `quick-check` function from the `clojure.test.check` namespace,
    as shown here:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  id: totrans-1771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'As shown previously, the `quick-check` function must be passed the number of
    checks to run and a property to verify. This function returns a map describing
    the checks performed on the supplied properties, in which the value of the `:result`
    key indicates the outcome of the test. It''s fairly evident that both of the properties
    `commutative-mult-prop` and `first-is-min-after-sort-prop` hold true for the specified
    type of inputs. Now, let''s define a property that is not true, as shown in *Example
    10.13*:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '*Example 10.13: A property that won''t be true defined using the test.check
    library*'
  id: totrans-1774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Running the preceding check will obviously fail, as shown in the following
    output:'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  id: totrans-1776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'We can also define specs based on generative testing using the `defspec` macro
    from the `clojure.test.check.clojure-test` namespace. This form must be passed
    the number of checks to perform and a property, which is analogous to the `quick-check`
    function. Specs defined using the `defspec` form will be checked by the standard
    `clojure.test` runner. For example, we can define the `commutative-mult-prop`
    property as a spec as shown in *Example 10.14*:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '*Example 10.14: A spec defined using the defspec macro*'
  id: totrans-1779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The spec defined in the preceding code can be verified by calling the `run-tests`
    or `run-all-tests` functions from the `clojure.test` namespace, or by running
    the `lein test` Leiningen command. In conclusion, generative testing through the
    `test.check` library is yet another way to test our code. It focuses on specifying
    properties of functions rather than describing the expected output of functions
    for some input.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: Testing with types
  id: totrans-1781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Type checking** is something that is often taken for granted in statically
    typed languages. With type checking, type errors can be found at compile time,
    rather than during runtime. In some dynamic languages such as Clojure, type signatures
    can be declared wherever and whenever they are required, and this technique is
    termed as *optional typing*. Type checking can be done using the `core.typed`
    library ([https://github.com/clojure/core.typed](https://github.com/clojure/core.typed)).
    Using `core.typed`, the type signature of a var can be checked using *type annotations*.
    Type annotations can be declared for any var, which includes values created using
    a `def` form, a `binding` form, or any other construct that creates a var. In
    this section, we will explore the details of this library.'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following library dependencies are required for the upcoming examples.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: Also, the following namespaces must be included in your namespace declaration.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: The following examples can be found in `src/m_clj/c10/typed.clj` of the book's
    source code.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations for vars are declared using the `ann` macro from the `clojure.core.typed`
    namespace. This form must be passed an expression to annotate and a vector of
    types. For example, a type annotation for a function that accepts two numbers
    as arguments and returns a number is shown in *Example 10.15*.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  id: totrans-1790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '*Example 10.15: A type annotation for a function that accepts two numbers and
    returns a number*'
  id: totrans-1791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To check all the type annotations in the given namespace, we must call the
    `clojure.core.typed/check-ns` function by passing it the namespace to be checked,
    as shown here:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  id: totrans-1793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'As shown previously, the `check-ns` function prints some information about
    the namespaces being checked, and returns the keyword `:ok` if all type checks
    in the specified namespace have passed. Now, let''s change the definition of the
    `add` function we previously defined as shown in *Example 10.16*:'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  id: totrans-1795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '*Example 10.16: Redefining the add function*'
  id: totrans-1796
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although the preceding definition is valid, it will not be passed by the type
    checker, as shown here:'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  id: totrans-1798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'The `check-ns` function throws an error stating that a `String` type was found
    where a `Number` type was expected. In this way, the `check-ns` function can find
    type errors in functions that have been annotated with the `ann` macro. Functions
    with multiple arities can be annotated using the `IFn` construct from the `clojure.core.typed`
    namespace, as shown in *Example 10.17*:'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '*Example 10.17: Annotating functions with multiple arities*'
  id: totrans-1801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can also annotate functions with variadic arguments using the `*` symbol
    in the vector of types passed to the `ann` macro, as shown in *Example 10.18*.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  id: totrans-1803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '*Example 10.18: Annotating functions with variadic arguments*'
  id: totrans-1804
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the REPL, we can determine the inferred type of an expression or a value
    using the `cf` macro from the `clojure.core.typed` namespace. This macro can also
    be passed the expected type as the second argument. Note that the `cf` form is
    only for experimentation and should not be used in type annotations. The `cf`
    form returns an inferred type, along with a structure called a *filter set*, which
    is represented as a map. For example, the type and filter sets of the values `nil`,
    `true`, and `false` can be inferred using the `cf` form as shown here:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'In the preceding output, the second value in each of the vectors returned by
    the `cf` macro represents the filter set derived from the supplied expression.
    A filter set can be described as a collection of the two filters:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: The `:then` filter, which is true if the expression is a truthy value
  id: totrans-1808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:else` filter, which is true if the expression is not a truthy value
  id: totrans-1809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of filter sets, there are two *trivial filters*, namely `tt`
    and `ff`, which can be described as follows:'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: '`tt`, which translates to trivially true and means the value is truthy.'
  id: totrans-1811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ff`, which translates to *forever false* and means the value is not truthy.
    This filter is also termed as the *impossible filter*.'
  id: totrans-1812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this perspective, the filter set `{:then tt, :else ff}` translates into
    "the expression could be a truthy value, but it is impossible for it to be a non-truthy
    value". Thus, false values such as `nil` and `false` are never true as inferred
    by the `cf` form, which agrees with the semantics of these values in Clojure.
    Truthy values will always have `tt` as the `:then` filter, as shown in the following
    output:'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  id: totrans-1814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'The `cf` macro can also be used to check the type signature of functions, as
    shown here:'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'A form or expression can be annotated with an expected type using the `ann-form`
    macro, as shown here:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'Aggregate types such as lists and vectors also have types defined for them
    in the `clojure.core.typed` namespace. We can infer the types of these data structures
    using the `cf` macro, as shown here:'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'The types `PersistentList` and `HVec` in the preceding output are concrete
    types for a list and a vector respectively. We can also pass the expected type
    as an extra argument to the `cf` form as shown here:'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  id: totrans-1822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: The `core.typed` library also supports *parameterized types*, *union types*,
    and *intersection types*. Union types are declared using the `U` construct, and
    intersection types are declared using the `I` construct. Intersection types are
    meant to be used with protocols, which implies that the intersection type `(I
    A B)` must implement both the protocols `A` and `B`. On the other hand, union
    types can be defined using concrete types. For example, the `clojure.core.typed`
    namespace defines a parameterized `Option` type, which is simply a union of `nil`
    and the parameterized type. In other words, the type `(Option x)` is defined as
    the union type `(U x nil)`. Another good example of a union type is the `AnyInteger`
    type, which represents a whole number, and is defined in the `clojure.core.typed`
    namespace as shown in *Example 10.19*.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  id: totrans-1824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '*Example 10.19: The AnyInteger union type*'
  id: totrans-1825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Polymorphic types* are also supported by the `core.typed` library, which allow
    us to specify generalized types. For example, the `identity` and `iterate` functions
    have polymorphic type signatures, as shown here:'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: We can annotate functions with polymorphic type signatures using the `All` construct
    from the `clojure.core.typed` namespace, as shown in *Example 10.20*.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '*Example 10.20: Defining a polymorphic type signature*'
  id: totrans-1830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In conclusion, the `core.typed` library provides several constructs to define
    and verify type signatures of vars. There are also several constructs for determining
    the type signature of a given expression. Using `core.typed`, you can find logical
    type errors in your code before it is executed at runtime. Type annotations can
    also be thought of as a form of documentation, which concisely describe the types
    of functions and vars. Thus, there are several benefits of using types through
    the `core.typed` library in Clojure.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1832
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed several libraries that can help us test and verify
    our code. We talked about the `clojure.test` and Midje libraries for defining
    tests. We also explored how we can define specs in the spirit of BDD using the
    Speclj library. Generative testing is another approach to testing, and we demonstrated
    how it can be done using the `test.check` library. Lastly, we talked about how
    we can perform type checking in Clojure using the `core.typed` library. Hence,
    there is a wide array of options for testing our code in Clojure.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will talk about how we can troubleshoot our
    code, as well as some good practices for developing applications in Clojure.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11. Troubleshooting and Best Practices
  id: totrans-1835
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you must be aware of all the features and most of the constructs of
    the Clojure language. Before you start building your own applications and libraries
    in Clojure, we will briefly discuss a few techniques to troubleshoot your code
    and some practices that you should incorporate in your projects.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your code
  id: totrans-1837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along your journey of building applications and libraries in Clojure, you'll
    surely run into situations where it would be helpful to debug your code. The usual
    response to such a situation is to use an **Integrated Development Environment**
    (**IDE**) with a debugger. And while Clojure IDEs such as *CIDER* ([https://github.com/clojure-emacs/cider](https://github.com/clojure-emacs/cider))
    and *Counterclockwise* ([http://doc.ccw-ide.org](http://doc.ccw-ide.org)) do support
    debugging, there are a few simpler constructs and tools that we can use to troubleshoot
    our code. Let's have a look at a few of them.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: One of the easiest ways to debug your code is by printing the value of some
    variables used within a function. We could use the standard `println` function
    for this purpose, but it doesn't always produce the most readable output for complex
    data types. As a convention, we should use the `clojure.pprint/pprint` function
    to print variables to the console. This function is the standard pretty-printer
    of the Clojure language.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1840
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Macros can be quite bewildering to debug. As we mentioned in [Chapter 4](ch19.html
    "Chapter 4. Metaprogramming with Macros"), *Metaprogramming with Macros*, macros
    should be used sparingly and we can debug macros using macroexpansion constructs
    such as `macroexpand` and `macroexpand-all`.
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these built-in constructs, there are a couple of useful libraries
    that we can add to our debugging toolkit.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples can be found in `test/m_clj/c11/` `debugging.clj` of
    the book's source code.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: Using tracing
  id: totrans-1845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Tracing* can be used to determine when and how a form is called. The `tools.trace`
    contrib library ([https://github.com/clojure/tools.trace](https://github.com/clojure/tools.trace))
    provides some handy constructs for tracing our code.'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  id: totrans-1849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  id: totrans-1851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'The `trace` function, from the `clojure.tools.trace` namespace, is the most
    elementary way to trace an expression. It will simply print the value returned
    by the expression passed to it. The `trace` construct can also be passed a string,
    with which the trace can be tagged, as an additional argument. For example, suppose
    we have to trace the function defined in *Example 11.1*:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  id: totrans-1853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '*Example 11.1: A simple function to trace*'
  id: totrans-1854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can trace the expression `(make-vector 0)` using the `trace` function shown
    here:'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  id: totrans-1856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'We can trace all the functions defined in a namespace by passing the namespace
    to the `trace-ns` macro, which is defined in the `clojure.tools.trace` namespace.
    Similarly, specific functions or vars in a namespace can be traced using the `trace-vars`
    macro. Traces added using these forms can be removed using the `untrace-ns` and
    `untrace-vars` marcos. If we want to determine which expression among several
    ones is failing, we can pass the expressions to the `trace-forms` macro, shown
    here:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'As the preceding output shows, the `trace-forms` macro will print the form
    that causes the error. A more informative way to trace a function is by replacing
    the `defn` symbol in its definition by `clojure.tools.trace/deftrace`, which simply
    defines a function whose arguments and return value will be traced. For example,
    consider the function defined in the following *Example 11.2*:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  id: totrans-1860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '*Example 11.2: Tracing a function using the deftrace macro*'
  id: totrans-1861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On calling the `add-into-vector` function defined previously, the following
    trace will be printed:'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  id: totrans-1863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: In this way, tracing can be used to find the value returned by an expression
    during the execution of a program. The tracing constructs from the `tools.trace`
    namespace allow us to determine when a function is called, as well as what its
    return value and arguments are.
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: Using Spyscope
  id: totrans-1865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have already been thinking, you can easily implement your own debugging
    constructs using macros. The Spyscope library ([https://github.com/dgrnbrg/spyscope](https://github.com/dgrnbrg/spyscope))
    takes this approach and implements a few reader macros for debugging code. The
    use of reader macros for debugging is a more favorable approach for languages
    with the parentheses-flavored syntax of Lisps. This is because, in these languages,
    reader macros that print debugging information can be added more easily to an
    existing program compared to forms such as `trace` and `deftrace`. Let's explore
    the constructs of the Spyscope library to get a clearer idea of the advantage
    of debugging code with reader macros.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: The Spyscope library provides the `#spy/p`, `#spy/d`, and `#spy/t` reader macros,
    which can all be used by writing them immediately before expressions that have
    to be debugged. It is a common practice to have these forms made available in
    the REPL using the `:injections` section of the `project.clj` file in a Leiningen
    project.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  id: totrans-1870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'We must also include the following forms as a vector in the `:injections` section
    of your `project.clj` file:'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  id: totrans-1872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  id: totrans-1874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: 'The `#spy/p` reader macro can be used to print a value that is used within
    an expression. An interesting point about this construct is that it is implemented
    using the `clojure.pprint/pprint` function. For example, we can print out the
    intermediate values produced by a `take` form shown here:'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  id: totrans-1876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'To produce more detailed information, such as the call stack and the form that
    returns a value, we can use the `#spy/d` reader macro. For example, we can use
    this construct to produce the following information:'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  id: totrans-1878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'The `#spy/d` reader macro also supports several options, which can be passed
    to it as metadata. The `:fs` key of this metadata map specifies the number of
    stack frames to display. Also, the `:marker` key can be used to declare a string
    tag for a form. We can use these options to display information from the call
    stack of a form, shown here:'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'The preceding output shows the top three stack frames of a call to the `+`
    form. We can also filter out stack frames from the call stack information using
    the `:nses` key with a regular expression, shown here:'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  id: totrans-1882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: To skip printing the form being debugged, we can specify the `:form` key with
    a `false` value in the metadata map specified to the `#spy/d` reader macro, and
    this key defaults to `true`. We can also print out the time at which a form is
    called using the `:time` key. The value for this key can either be `true`, in
    which case the default time format is used, or a string such as `"hh:mm:ss"`,
    which represents the timestamp format with which the time must be displayed.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#spy/t` reader macro is used for tracing a form, and this construct supports
    the same options as the `#spy/d` reader macro. The trace is not printed immediately,
    and can be displayed using the `trace-query` function from the `spyscope.repl`
    namespace. For example, consider the function in *Example 11.3* that adds a number
    of values in a future:'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '*Example 11.3: Tracing a function that adds numbers in a future*'
  id: totrans-1886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Once the `add-in-future` function is called, we can display a trace of the
    call using the `trace-query` function, shown here:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  id: totrans-1888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: In the preceding output, the `trace-next` function is used to start a new *generation*
    of traces. Traces in the Spyscope library are grouped into generations, and a
    new generation can be started using the `spyscope.repl/trace-next` function. All
    trace information from all generations can be cleared using the `trace-clear`
    function from the `spyscope.repl` namespace. We can also pass an argument to the
    `trace-query` function to filter out results. This argument can be either a number,
    which represents the number of recent generations to show, or a regex to filter
    traces by their namespaces.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, there are several ways to debug your code in Clojure without the
    use of a debugger. The `tools.trace` and Spyscope libraries have several useful
    and simple constructs for debugging and tracing the execution of Clojure code.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: Logging errors in your application
  id: totrans-1891
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to analyze what went wrong in an application is by using logs. Logging
    can be done using the `tools.logging` contrib library. This library lets us use
    multiple logging implementations through an agnostic interface, and the implementations
    to choose from include `slf4j`, `log4j`, and `logback`. Let's quickly skim over
    how we can add logging to any Clojure program using the `tools.logging` library
    and `logback`, which is arguably the most recent and configurable implementation
    to use with this library.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1893
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: The following examples can be found in `test/m_clj/c11/` `logging.clj` of the
    book's source code.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
- en: All the logging macros implemented in the `clojure.tools.logging` namespace
    fall into two categories. The first category of macros require arguments like
    those which are passed to the `println` form. All of these arguments are concatenated
    and written to the log. The other category of macros must be passed a format string
    and values to interpolate into the specified format. This second category of macros
    are generally suffixed with an `f` character, such as `debugf` or `infof`. The
    logging macros in the `tools.logging` library can be passed an exception followed
    by the other usual arguments.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: The macros in the `tools.logging` library write log messages at differing log
    levels. For example, the `debug` and `debugf` forms write log messages at the
    `DEBUG` level, and similarly, the `error` and `errorf` macros log at the `ERROR`
    level. In addition, the `spy` and `spyf` macros will evaluate and return the value
    of an expression, and may log the result if the current log level is equal to
    or below the log level specified to it, which defaults to `DEBUG`.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `divide` function, shown in the following *Example 11.4*,
    logs some information, using the `info`, `spyf`, and `error` macros, while performing
    integer division:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  id: totrans-1902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '*Example 11.4: A function that logs information using the tools.logging library*'
  id: totrans-1903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following log messages will be written when the `divide` function is called:'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  id: totrans-1905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: As shown previously, the `divide` function writes several log messages at different
    log levels when it is called. The logging configuration for `logback` must be
    saved in a file named `logback.xml`, which can reside in either the `src/` or
    `resources/` directories of a Leiningen project. We can specify the default log
    level and several other options for `logback` in this file.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're interested in the logging configuration for the previous examples,
    take a look at the `src/logback.xml` file in the book's source code. For detailed
    configuration options, visit [http://logback.qos.ch/manual/configuration.html](http://logback.qos.ch/manual/configuration.html).
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also handy to have a global exception handler that logs exceptions for
    all threads in a program. This can be particularly useful for checking errors
    that are encountered during the execution of `go` and `thread` macros from the
    `core.async` library. Such a global exception handler can be defined using the
    `setDefaultUncaughtExceptionHandler` method from the `java.lang.Thread` class,
    as shown in *Example 11.5*:'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  id: totrans-1910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '*Example 11.5: A global exception handler that logs all errors*'
  id: totrans-1911
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  id: totrans-1912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use *Timbre* ([https://github.com/ptaoussanis/timbre](https://github.com/ptaoussanis/timbre))
    for logging, which can be configured without the use of XML and is also supported
    on ClojureScript.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, there are several options for logging available to us through
    the `tools.logging` library. This library also supports several logging implementations
    that each have their own set of configuration options.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in Clojure
  id: totrans-1915
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s briefly discuss a handful of good practices for building real world
    applications in Clojure. Of course, these practices are only guidelines, and you
    should eventually try to establish your own set of rules and practices for writing
    code in Clojure:'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimize state and use pure functions**: Most applications must inevitably
    use some form of state. You must always strive to reduce the amount of state you''re
    dealing with, and implement most of the heavy lifting in pure functions. State
    can be managed using reference types, channels, or even monads in Clojure, thus
    giving us a lot of proven options. In this way, we can reduce the number of conditions
    that can cause any unexpected behavior in a program. Pure functions are also easier
    to compose and test.'
  id: totrans-1917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t forget about laziness**: Laziness can be used as an alternative to
    solve problems that have solutions based on recursion. Although laziness does
    tend to simplify several aspects of functional programming, it also incurs additional
    memory usage in certain situations, such as holding on to the head of a lazy sequence.
    Take a look at [http://clojure.org/reference/lazy#_don_t_hang_onto_your_head](http://clojure.org/reference/lazy#_don_t_hang_onto_your_head)
    for more information on how laziness can increase the memory usage of your program.
    Most of the standard functions in Clojure return lazy sequences as results, and
    you must always consider laziness when working with them.'
  id: totrans-1918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model your program as transformations of data**: It is unavoidable to think
    in steps as humans, and you must always try to model your code as steps of transforming
    data. Try to avoid thinking in steps that mutate state, but rather in transformations
    of data. This leads to a more composable design, which makes combining a handful
    of transformations very easy.'
  id: totrans-1919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the threading macros -> and ->> to avoid nesting expressions**: You must
    have seen quite a few examples in this book that have used these macros, and have
    probably started enjoying their presence in your own code as well. The `->` and
    `->>` macros improve readability greatly, and must be used wherever possible.
    Don''t hesitate to use these macros even if it avoids a couple of levels of nesting.
    There are several other threading macros, such as `cond->` and `as->`, that can
    often be useful.'
  id: totrans-1920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallelism is at your fingertips**: There are several ways to write programs
    that benefit through the use of parallelism in Clojure. You can choose between
    futures, reducers, `core.async` processes, and several other constructs to model
    concurrent and parallel operations. Also, most of the state management constructs,
    such as atoms, agents, and channels, have been designed with concurrency in mind.
    So, don''t hesitate to use them when you''re dealing with concurrent tasks and
    state.'
  id: totrans-1921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live in the REPL**: It''s an indispensable tool for experimenting with code
    and prototyping your programs. After writing a function or a macro, the first
    thing you should do is play with it in the REPL. You can use the `load-file` function
    to quickly reload changes in your source files without ever restarting the REPL.
    Keep in mind that reloading a source file with the `load-file` form will erase
    any modifications or redefinitions in the namespace of the source file that have
    been made through the REPL.'
  id: totrans-1922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embed a Clojure REPL in your application**: It is possible to embed the REPL
    into an application, thus allowing us to connect to it and modify its behavior
    at runtime as we desire. For more information on how to do this, take a look at
    the constructs in the `clojure.core.server.repl` namespace or the `tools.nrepl`
    library ([https://github.com/clojure/tools.nrepl](https://github.com/clojure/tools.nrepl)).
    But, this is a possible security risk, and should be used with caution.'
  id: totrans-1923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the standard coding style with consistency**: Maintaining a good coding
    style is important in any project or programming language. All of the examples
    in this book are formatted in a standard way, as defined by the Clojure style
    guide ([https://github.com/bbatsov/clojure-style-guide](https://github.com/bbatsov/clojure-style-guide)).'
  id: totrans-1924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1925
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we talked about several ways to troubleshoot our code. The `tools.trace`
    and Spyscope libraries are useful in interactive debugging, while the `tools.logging`
    library can be used to log information in running applications. We also discussed
    a handful of good practices for developing applications and libraries in Clojure.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
- en: You must be quite anxious by now to write your own applications in Clojure.
    If you've been paying attention so far, you must have noticed that Clojure is
    indeed a simple language. Yet, through its simplicity, we are empowered to create
    elegant and scalable solutions to a lot of interesting problems. On your journey
    with Clojure ahead, always strive to make things simpler, if they aren't simple
    enough already. We'll leave you with a few thought provoking quotes as you go
    onwards to realize the possibilities of this elegant, powerful, and simple programming
    language.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"Composing simple components is the way we write robust software."*
    |   |'
  id: totrans-1928
  prefs: []
  type: TYPE_TB
- en: '|   | --*Rich Hickey* |'
  id: totrans-1929
  prefs: []
  type: TYPE_TB
- en: '|   | *"Simplicity is prerequisite for reliability."* |   |'
  id: totrans-1930
  prefs: []
  type: TYPE_TB
- en: '|   | --*Edsger W. Dijkstra* |'
  id: totrans-1931
  prefs: []
  type: TYPE_TB
- en: '|   | *"Simplicity is the ultimate sophistication."* |   |'
  id: totrans-1932
  prefs: []
  type: TYPE_TB
- en: '|   | --*Leonardo da Vinci* |'
  id: totrans-1933
  prefs: []
  type: TYPE_TB
- en: Appendix A. References
  id: totrans-1934
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Anatomy of a Reducer*, Rich Hickey (2012): [http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html](http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html)'
  id: totrans-1935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transducers are Coming*, Rich Hickey (2014): [http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming](http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming)'
  id: totrans-1936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Logic Programming with Clojure*, Ambrose Bonnaire-Sergeant
    (2011): [http://github.com/frenchy64/Logic-Starter/wiki](http://github.com/frenchy64/Logic-Starter/wiki)'
  id: totrans-1937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N-Queens with core.logic*, Martin Trojer (2012): [http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html](http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html)'
  id: totrans-1938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clojure core.async Channels*, Rich Hickey (2013): [http://clojure.com/blog/2013/06/28/clojure-core-async-channels](http://clojure.com/blog/2013/06/28/clojure-core-async-channels)'
  id: totrans-1939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Communicating Sequential Processes*, C. A. R. Hoare (1978): [http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf)'
  id: totrans-1940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Communicating Sequential Processes*, David Nolen (2013): [http://swannodette.github.io/2013/07/12/communicating-sequential-processes/](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/)'
  id: totrans-1941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Dining Philosophers solver*, Pepijn de Vos (2013): [http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html](http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html)'
  id: totrans-1942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CSP vs. FRP*, Draco Dormiens (2014): [http://potetm.github.io/2014/01/07/frp.html](http://potetm.github.io/2014/01/07/frp.html)'
  id: totrans-1943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional Reactive Animation*, Conal Elliott and Paul Hudak (1997): [http://conal.net/papers/icfp97/icfp97.pdf](http://conal.net/papers/icfp97/icfp97.pdf)'
  id: totrans-1944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Yolk* *examples*, Wilkes Joiner (2013): [https://github.com/Cicayda/yolk-examples](https://github.com/Cicayda/yolk-examples)'
  id: totrans-1945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The* *Clojure docs*: [http://clojure.org/](http://clojure.org/)'
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cats* *Documentation*: [http://funcool.github.io/cats/latest](http://funcool.github.io/cats/latest)'
  id: totrans-1947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The* *core.logic wiki*: [http://github.com/clojure/core.logic/wiki](http://github.com/clojure/core.logic/wiki)'
  id: totrans-1948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The* *Pulsar docs*: [http://docs.paralleluniverse.co/pulsar/](http://docs.paralleluniverse.co/pulsar/)'
  id: totrans-1949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The* *Midje wiki*: [http://github.com/marick/Midje/wiki](http://github.com/marick/Midje/wiki)'
  id: totrans-1950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting* *Started with Speclj*: [http://speclj.com/tutorial](http://speclj.com/tutorial)'
  id: totrans-1951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The* *core.typed* *wiki*: [http://github.com/clojure/core.typed/wiki](http://github.com/clojure/core.typed/wiki)'
  id: totrans-1952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
