- en: Exploring Advanced Interactions of WebDriver
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed the WebDriver interface and its features,
    including taking screenshots, working with Windows, frames, alerts, cookies, and
    synchronizing tests. In this chapter, we will go through some advanced ways of
    performing actions on WebElements. We will learn how to perform actions, using
    the actions API of Selenium WebDriver, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Complex mouse actions, such as moving the mouse, double-clicking, and dragging
    and dropping
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard shortcuts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the build and perform actions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know how to perform some basic actions, such as clicking on a button and
    typing text into a textbox; however, there are many scenarios where we have to
    perform multiple actions at the same time, for example, keeping the *Shift* button
    pressed and typing text for uppercase letters, and the dragging and dropping mouse
    actions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple scenario here. Open the [http://guidebook.seleniumacademy.com/Selectable.html](http://guidebook.seleniumacademy.com/Selectable.html).
    A box of tiles numbered 1 to 12 will appear, as seen in this screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83234a72-4071-496d-a528-be94774ba35b.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: 'If you inspect the elements with browser developer tools, you will see an ordered
    list tag:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you click a number, its background color changes to orange. Try selecting
    the tiles 1, 3, and 5\. You do that by holding down *Ctrl* + tile 1 + tile 3 +
    tile 5\. This involves performing multiple actions, that is, holding *Ctrl* continuously
    and clicking on tiles 1, 3, and 5\. How do we perform these multiple actions using
    WebDriver? The following code demonstrates how:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if you refer to the code, we are getting introduced to a new class named
    `Actions`. This `Actions` class is the one that is used to emulate all the complex
    user events. Using this, the developer of the test script could combine all the
    necessary user gestures into one composite action. We have declared all the actions
    that are to be executed to achieve the functionality of clicking on the numbers
    1, 3, and 5\. Once all the actions are grouped together, we build that into a
    composite action. `Action` is an interface that has only the `perform()` method,
    which executes the composite action. When we execute the test, tiles 1, 3, and
    5 will be selected one by one. Finally, tile 5 will be selected, as shown in this
    screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3536f3af-e12e-48f4-8ec0-71bbded32f68.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: 'So, to make WebDriver perform multiple actions at the same time, you need to
    follow a three-step process of using the user-facing API of the actions class
    to group all the actions, then build the composite action, and perform the action.
    This process can be made into a two-step process, as the `perform()` method internally
    calls the `build()` method. So the previous code will look as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we have directly invoked the `perform()` method on the
    `Actions` instance, which internally calls the `build()` method to create a composite
    action before executing it. In the subsequent sections of this chapter, we will
    take a closer look at the `Actions` class. All the actions are basically divided
    into two categories: mouse-based actions and keyboard-based actions. In the following
    sections, we will discuss all the actions that are specific to the mouse and keyboard
    available in the `Actions` class.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们直接在`Actions`实例上调用了`perform()`方法，该方法在执行之前内部调用`build()`方法来创建一个组合动作。在本章的后续部分，我们将更详细地探讨`Actions`类。所有动作基本上分为两类：基于鼠标的动作和基于键盘的动作。在接下来的章节中，我们将讨论`Actions`类中所有特定于鼠标和键盘的动作。
- en: Learning mouse based interactions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基于鼠标的交互
- en: There are around eight different mouse actions that can be performed using the
    actions class. We will see each of their syntax and a working example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动作类可以执行大约八种不同的鼠标动作。我们将看到它们的语法和实际的工作示例。
- en: The moveByOffset action
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动偏移动作
- en: The `moveByOffset()` method is used to move the mouse from its current position
    to another point on the web page. Developers can specify the *x* distance and
    the *y* distance the mouse has to be moved. When the page is loaded, generally
    the initial position of the mouse would be (0, 0), unless there is an explicit
    focus declared by the page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveByOffset()`方法用于将鼠标从当前位置移动到网页上的另一个点。开发者可以指定鼠标需要移动的*x*轴和*y*轴的距离。当页面加载时，鼠标的初始位置通常是(0,
    0)，除非页面有明确的焦点声明。'
- en: 'The API syntax for the `moveByOffset()` method is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveByOffset()`方法的API语法如下：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `xOffSet` is the input parameter providing the WebDriver
    the amount of offset to be moved along the *x* axis. A positive value is used
    to move the cursor to the right, and a negative value is used to move the cursor
    to the left.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`xOffSet`是输入参数，为WebDriver提供沿*x*轴移动的偏移量。正值用于将光标向右移动，负值用于将光标向左移动。
- en: '`yOffSet` is the input parameter providing the WebDriver the amount of offset
    to be moved along the *y* axis. A positive value is used to move the cursor down
    along the *y* axis, and a negative value is used to move the cursor toward the
    top.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`yOffSet`是输入参数，为WebDriver提供沿*y*轴移动的偏移量。正值用于将光标沿*y*轴向下移动，负值用于将光标向上移动。'
- en: When the `xOffSet` and `yOffSet` values result in moving the cursor out of the
    document, a `MoveTargetOutOfBounds` exception is raised.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当`xOffSet`和`yOffSet`的值导致光标移出文档时，会抛出`MoveTargetOutOfBounds`异常。
- en: 'Let''s see a working example of it. The objective of the following code is
    to move the cursor on to tile 3 on the web page:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际的工作示例。以下代码的目标是将光标移动到网页上的瓷砖3上：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will be as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/eabd86c4-a1fb-4b7a-b922-4fb254413d85.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eabd86c4-a1fb-4b7a-b922-4fb254413d85.png)'
- en: We have added `+1` to the coordinates, because if you observe the element in
    Firebug, we have a style border of 1 px. The border is a CSS-style attribute,
    which when applied to an element will add a border of the specified color around
    the element, with the specified amount of thickness. Though the previous code
    does move your mouse over tile 3, we don't realize this, because we are not performing
    any action there. We will see this shortly, when we use the `moveByOffset()` method
    in combination with the `click()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将坐标增加了`+1`，因为如果你在Firebug中观察元素，我们会有一个1像素的边框。边框是一个CSS样式属性，当应用于一个元素时，会在元素周围添加一个指定颜色的边框，并具有指定的厚度。尽管之前的代码确实将鼠标移动到了瓷砖3上，但我们没有意识到这一点，因为我们没有在那里执行任何操作。我们将在使用`moveByOffset()`方法和`click()`方法结合时很快看到这一点。
- en: The click at current location action
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前位置点击动作
- en: The `click()` method is used to simulate the left-click of your mouse at its
    current point of location. This method doesn't really realize where or on which
    element it is clicking. It just clicks wherever it is at that point in time. Hence,
    this method is used in combination with some other action, rather than independently,
    to create a composite action.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`click()`方法用于模拟鼠标在其当前位置的左键点击。此方法实际上并不确定点击的位置或元素。它只是在那个时间点点击任何地方。因此，此方法通常与其他动作结合使用，而不是独立使用，以创建组合动作。'
- en: 'The API syntax for the `click()` method is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`click()`方法的API语法如下：'
- en: '`public Actions click()`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`public Actions click()`。'
- en: 'The `click()` method doesn''t really have any context about where it is performing
    its action; hence, it doesn''t take any input parameter. Let''s see a code example
    of the `click()` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the above example we have used a combination of the `moveByOffset()` and
    `click()` methods to move the cursor from point (0, 0) to the point of tile 7\.
    Because the initial position of the mouse is (0, 0), the *x*, *y* offset provided
    for the `moveByOffset()` method is nothing but the location of the tile 7 element.
    Now let''s try to move the cursor from tile 1 to tile 11, and from there to tile
    5, and see how the code looks. Before we get into the code, let''s inspect the
    `Selectable.html` page using Firebug. The following is the style of each tile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The three elements with which we are concerned for our offset movement in the
    preceding style code are: `height`, `width`, and the `border` thickness. Here,
    the `height` value is `80px`, the `width` value is `100px`, and the `border` value
    is `1px`. Use these three factors to calculate the offset to navigate from one
    tile to the other. Note that the border thickness between any two tiles will result
    in `2 px`, that is, `1 px` from each tile. The following is the code that uses
    the `moveByOffset` and `click()` methods to navigate from tile 1 to tile 11, and
    from there to tile 5:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The click on a WebElement action
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to click a WebElement by calculating the offset to it. This
    process may not be needed every time, especially when the WebElement has its own
    identifiers, such as a name or an ID. We can use another overloaded version of
    the `click()` method to click directly on the WebElement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for clicking on a WebElement is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The input parameter for this method is an instance of the WebElement on which
    the `click` action should be performed. This method, like all the other methods
    in the `Actions` class, will return an `Actions` instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to modify the previous code example to use the `click(WebElement)`
    method, instead of using the `moveByOffset()` method, to move to the location
    of the WebElement and click on it using the `click()` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now the `moveByOffset()` method has been replaced by the `click(WebElement)`
    method, and, all of a sudden, the complex coordinate geometry has been removed
    from the code. If you're a tester, this is one more good reason to push your developers
    to provide identifiers for the WebElements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'If you observe the previous examples for the `moveByOffset` and `click` methods,
    all the operations of moving the mouse and clicking on tiles 1, 11, and 5 are
    built separately and performed separately. This is not how we use our `Actions`
    class. You can actually build all these actions together and then perform them.
    So, the preceding code will turn out to be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The click and hold at current location action
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `clickAndHold()` method is another method of the actions class that left-clicks
    on an element and holds it without releasing the left button of the mouse. This
    method will be useful when executing operations such as drag and drop. This method
    is one of the variants of the `clickAndHold()` method that the actions class provides.
    We will discuss the other variant in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the `Sortable.html` file that came with the book. You can see that
    the tiles can be moved from one position to the other. Now let''s try to move
    tile 3 to the position of tile 2\. The sequence of steps that are involved to
    do this are the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Move the cursor to the position of tile 3.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and hold tile 3.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the cursor in this position to tile 2's location.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s see how this can be accomplished, using the WebDriver''s `clickAndHold()`
    method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s analyze the following line of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The tile movement will be similar to the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/944e4722-7d84-4f9e-9483-70df3f8ed449.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: First, we move the cursor to the location of tile 3\. Then, we click and hold
    tile 3\. Then, we move the cursor by `120px` horizontally to the position of tile
    2\. The last line performs all the preceding actions. Now execute this in your
    eclipse and see what happens. If you observe closely, tile 3 doesn't properly
    go into the position of tile 2\. This is because we are yet to release the left
    button. We just commanded the WebDriver to click and hold, but not to release.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The click and hold a WebElement action
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen the `clickAndHold()` method, which will
    click and hold a WebElement at the current position of the cursor. It doesn't
    care about which element it is dealing with. So, if we want to deal with a particular
    WebElement on the web page, we have to first move the cursor to the appropriate
    position and then perform the `clickAndHold()` action. To avoid the hassle of
    moving the cursor geometrically, WebDriver provides the developers with another
    variant or overloaded method of the `clickAndHold()` method that takes the WebElement
    as input.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax is this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The input parameter for this method is the WebElement that has to be clicked
    and held. The return type, as in all the other methods of the `Actions` class,
    is the `Actions` instance. Now let''s refactor the example in the previous section
    to use this method, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only change is that we have removed the action of moving the cursor to the
    `(200, 20)` position and provided the WebElement to the `clickAndHold()` method
    that will take care of identifying the WebElement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The release at current location action
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, in the previous example, we have seen how to click and hold an element.
    The ultimate action that has to be taken on a held WebElement is to release it
    so that the element can be dropped or released from the mouse. The `release()`
    method is the one that can release the left mouse button on a WebElement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for the `release()` method is as follows: `public Actions release()`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`release()` 方法的 API 语法如下：`public Actions release()`。'
- en: The preceding method doesn't take any input parameter and returns the `Actions`
    class instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法不接收任何输入参数，并返回 `Actions` 类实例。
- en: 'Now, let''s modify the previous code to include the `release` action in it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改前面的代码以包含 `release` 操作：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code will make sure that the mouse is released at the specified
    location.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将确保鼠标在指定位置释放。
- en: The release on another WebElement action
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在另一个 WebElement 上执行释放操作
- en: This is an overloaded version of the `release()` method. Using this, you can
    actually release the currently held WebElement in the middle of another WebElement.
    In this way, we don't have to calculate the offset of the target WebElement from
    the held WebElement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `release()` 方法的重载版本。使用它，您实际上可以在另一个 WebElement 的中间释放当前持有的 WebElement。这样，我们就不必计算目标
    WebElement 从持有 WebElement 的偏移量。
- en: 'The API syntax is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: API 语法如下：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The input parameter for the preceding method is obviously the target WebElement,
    where the held WebElement should be dropped. The return type is the instance of
    the `Actions` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输入参数显然是目标 WebElement，其中应该放下持有的 WebElement。返回类型是 `Actions` 类的实例。
- en: 'Let''s modify the preceding code example to use this method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的代码示例以使用此方法：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Look at how simple the preceding code is. We have removed all the `moveByOffset`
    code and added the `release()` method that takes the WebElement with the name
    `two` as the input parameter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的代码有多简单。我们移除了所有的 `moveByOffset` 代码，并添加了接受名为 `two` 的 WebElement 作为输入参数的 `release()`
    方法。
- en: Invoking the `release()` or `release(WebElement)` methods without calling the
    `clickAndHold()` method will result in an undefined behavior.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在不调用 `clickAndHold()` 方法的情况下调用 `release()` 或 `release(WebElement)` 方法将导致未定义的行为。
- en: The moveToElement action
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动到元素操作
- en: The `moveToElement()` method is another method of WebDriver that helps us to
    move the mouse cursor to a WebElement on the web page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToElement()` 方法是 WebDriver 的另一种方法，它帮助我们将鼠标光标移动到网页上的 WebElement。'
- en: 'The API syntax for the `moveToElement()` method is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToElement()` 方法的 API 语法如下：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The input parameter for the preceding method is the target WebElement, where
    the mouse should be moved. Now go back to the `clickAndHold` at *current location
    action* section of this chapter and try to modify the code to use this method.
    The following is the code we have written in *The click-and-hold-at-current-location
    action* section:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输入参数是目标 WebElement，鼠标应该移动到那里。现在回到本章的 *当前位置点击并按住操作* 部分，尝试修改代码以使用此方法。以下是我们已在
    *当前位置点击并按住操作* 部分编写的代码：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we will replace the `moveByOffset(x, y)` method with
    the `moveToElement(WebElement)` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将用 `moveToElement(WebElement)` 方法替换 `moveByOffset(x, y)` 方法：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we have moved to tile 3, clicked and held it, and then
    moved to the location of tile 2, by specifying its offset. If you want, you can
    add the `release()` method before the `perform()` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经移动到第 3 个瓦片，点击并按住它，然后移动到第 2 个瓦片的位置，通过指定其偏移量。如果您愿意，您可以在 `perform()`
    方法之前添加 `release()` 方法。
- en: There might be a number of ways to achieve the same task. It is up to the user
    to choose the appropriate ones that best suit the given circumstances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完成相同任务可能有多种方式。这取决于用户选择最适合给定情况的方法。
- en: The dragAndDropBy action
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放操作
- en: There might be many instances where we may have to drag and drop components
    or WebElements of a web page. We can accomplish that by using many of the actions
    seen until now. But WebDriver has given us a convenient out-of-the-box method
    to use. Let's see its API syntax.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有很多需要拖放组件或网页上的 WebElement 的情况。我们可以通过使用到目前为止看到的大多数操作来完成。但是 WebDriver 给我们提供了一个方便的即用型方法。让我们看看它的
    API 语法。
- en: 'The API syntax for the `dragAndDropBy()` method is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragAndDropBy()` 方法的 API 语法如下：'
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `WebElement` input parameter is the target WebElement to be dragged, the
    `xOffset` parameter is the horizontal offset to be moved, and the `yOffset` parameter
    is the vertical offset to be moved.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebElement` 输入参数是要拖动的目标 WebElement，`xOffset` 参数是要移动的水平偏移量，而 `yOffset` 参数是要移动的垂直偏移量。'
- en: 'Let''s see a code example for it. Open the HTML file, `DragMe.html`, provided
    with this book. It has a square box, as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例。打开本书提供的 HTML 文件，`DragMe.html`。它有一个正方形框，如下面的截图所示：
- en: '![](img/9dfa2b9d-f4b9-465a-a5e1-c32911386701.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'You can actually drag that rectangle to any location on the web page. Let''s
    see how we can do that, using WebDriver. The following is the code example for
    that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, `dragMe` is the WebElement that is identified by its
    `id`, and that is dragged `300px` horizontally and `200px` vertically. The following
    screenshot shows how an element is dragged from this position:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8db11150-9639-44a0-8c0b-c431f32f1c7d.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: The dragAndDrop action
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dragAndDrop()` method is similar to the `dragAndDropBy()` method. The only
    difference being that, instead of moving the WebElement by an offset, we move
    it on to a target element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for the `dragAndDrop()` method is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The input parameters for the preceding method are the WebElement source and
    the WebElement target, while the return type is the `Actions` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a working code example for it. Open the `DragAndDrop.html` file,
    which is provided with the book, with two square boxes, as shown in this screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a805d005-ebdd-4cdc-80fe-12c29f8158f6.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can actually drag the Drag me to my target rectangle to the Drop here
    rectangle. Try that. Let''s see how that can be achieved, using WebDriver:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, the source and target WebElements are identified by
    their IDs, and the `dragAndDrop()` method is used to drag one to the other. Here,
    out of the script with first square box dropped on the second box shown in the
    following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ee19696-4b35-42f6-ac0c-9b6172088063.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: The double click at current location action
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving on to another action that can be performed using a mouse, `doubleClick()`
    is another out- of-the-box method that WebDriver provides to emulate the double-clicking
    of the mouse. This method, like the `click()` method, comes in two flavors. One
    is double-clicking a WebElement, which we will discuss in next section; the second
    is clicking at the current location of the cursor, which will be discussed here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Obviously, the preceding method doesn''t take any input parameters, as it just
    clicks on the current cursor location and returns an actions class instance. Let''s
    see how the previous code can be converted to use this method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we have used the `moveToElement(WebElement)` method
    to move the mouse to the location of the button element and just double-clicked
    at the current location. Here is the output after performing the double-click
    on the element on the sample page:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f703cd69-1145-43e4-9b43-c8a65cd189bc.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: The double click on WebElement action
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen a method that double-clicks at the current location, we
    will discuss another method that WebDriver provides to emulate the double-clicking
    of a WebElement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for the `doubleClick()` method is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The input parameter for the preceding method is the target WebElement that has
    to be double-clicked, and the return type is the `Actions` class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输入参数是要双击的目标 WebElement，返回类型是 `Actions` 类。
- en: 'Let''s see a code example for this. Open the `DoubleClick.html` file and *single*-click
    on the Click Me button. You shouldn''t see anything happening. Now double-click
    on the button; you should see an alert saying Double Clicked !!. Now we will try
    to do the same thing using WebDriver. The following is the code to do that:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个的代码示例。打开 `DoubleClick.html` 文件，并 *单次* 点击 Click Me 按钮。你不应该看到任何动作发生。现在双击按钮；你应该看到一个提示说双击了
    !!。现在我们将尝试使用 WebDriver 做同样的事情。以下是要做到这一点的代码：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After executing the preceding code, you should see an alert dialog saying that
    the button has been double-clicked.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，你应该会看到一个提示对话框，说明按钮已被双击。
- en: The context click on WebElement action
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 WebElement 上的上下文点击动作
- en: 'The `contextClick()` method, also known as *right-click*, is quite common on
    many web pages these days. It displays a menu similar to this screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextClick()` 方法，也称为 *右键点击*，在许多网页上现在相当常见。它显示一个类似于以下截图的菜单：'
- en: '![](img/3dabf2a1-2c7f-4ab4-a9ed-b66686e65be4.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dabf2a1-2c7f-4ab4-a9ed-b66686e65be4.png)'
- en: This context menu can be accessed by a right-click of the mouse on the WebElement.
    WebDriver provides the developer with an option of emulating that action, using
    the `contextClick()` method. Like many other methods, this method has two variants
    as well. One is clicking on the current location and the other overloaded method
    is clicking on the WebElement. Let's discuss the context of clicking on WebElement
    here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个上下文菜单可以通过在 WebElement 上右键点击鼠标来访问。WebDriver 为开发者提供了一个使用 `contextClick()` 方法模拟该动作的选项。像许多其他方法一样，此方法也有两种变体。一个是点击当前位置，另一个是重载方法，点击
    WebElement。让我们在这里讨论在 WebElement 上点击的上下文。
- en: 'The API syntax for the `contextClick()` method is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextClick()` 方法的 API 语法如下：'
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The input parameter is obviously the WebElement that has to be right-clicked,
    and the return type is the `Actions` instance. As we do normally, its time to
    see a code example. If you open the `ContextClick.html` file, you can right-click
    on the text visible on the page, and it will display the context menu. Now clicking
    any item pops up an alert dialog stating which item has been clicked. Now let''s
    see how to implement this in WebDriver, using the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数显然是要右键点击的 WebElement，返回类型是 `Actions` 实例。像我们通常做的那样，现在是时候看看一个代码示例了。如果你打开 `ContextClick.html`
    文件，你可以在页面上可见的文本上右键点击，它将显示上下文菜单。现在点击任何项都会弹出一个提示对话框，说明哪个项已被点击。现在让我们看看如何使用以下代码在 WebDriver
    中实现这一点：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, first we have right-clicked using the `contextClick()`
    method on the WebElement contextMenu, and then left-clicked on Item 4 from the
    context menu. This should pop up an alert dialog saying Item 4 Clicked.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先使用 `contextClick()` 方法在 contextMenu WebElement 上进行了右键点击，然后从上下文菜单中点击了第
    4 项。这应该会弹出一个提示对话框，说明已点击第 4 项。
- en: The context click at current location action
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前位置的上下文点击动作
- en: 'Now that we have seen context click on a WebElement, it''s time to explore
    the `contextClick()` method at the current mouse location. The API syntax for
    the `contextClick()` method is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在 WebElement 上进行上下文点击，现在是时候探索在当前鼠标位置上的 `contextClick()` 方法了。`contextClick()`
    方法的 API 语法如下：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As expected, the preceding method doesn''t expect any input parameter and returns
    the `Actions` instance. Let''s see the necessary modifications needed for the
    previous example to use this method. The following is the code refactored to achieve
    this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，前面的方法不需要任何输入参数，并返回 `Actions` 实例。让我们看看为了使用此方法需要对前面的示例进行哪些必要的修改。以下是将代码重构以实现此目的的代码：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code first moves the cursor to the `div-context` WebElement and
    then context-clicks it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先将光标移动到 `div-context` WebElement，然后对其进行上下文点击。
- en: Learning keyboard-based interactions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基于键盘的交互
- en: Until now, we have seen all the actions that can be taken using a mouse. Now
    it's time to look at some of the actions that are specific to the keyboard in
    the `Actions` class. Basically, there are three different actions that are available
    in the `Actions` class that are specific to the keyboard. They are the `keyUp`,
    `keyDown`, and `sendKeys` actions, each having two overloaded methods. One method
    is to execute the action directly on the WebElement, and the other is to just
    execute the method irrespective of its context.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了可以使用鼠标执行的所有动作。现在，我们需要看看`Actions`类中一些特定于键盘的动作。基本上，`Actions`类中有三种特定于键盘的不同动作，它们是`keyUp`、`keyDown`和`sendKeys`动作，每个动作都有两个重载方法。一个方法是在`WebElement`上直接执行动作，另一个方法是不考虑其上下文来执行方法。
- en: The keyDown and keyUp actions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`keyDown`和`keyUp`动作'
- en: 'The `keyDown()` method is used to simulate the action of pressing and holding
    a key. The keys that we are referencing here are the *Shift*, *Ctrl*, and *Alt*
    keys. The `keyUp()` method is used to release the key that is already pressed
    using the `keyDown()` method. The API syntax for the `keyDown()` method is as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyDown()`方法用于模拟按下并保持键的动作。我们在这里引用的键是*Shift*、*Ctrl*和*Alt*键。`keyUp()`方法用于释放使用`keyDown()`方法按下的键。`keyDown()`方法的API语法如下：'
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An `IllegalArgumentException` is thrown when the passed key is not one of the
    *Shift*, *Ctrl*, and *Alt* keys. The API syntax for the `keyUp()` method is as
    follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入的键不是*Shift*、*Ctrl*和*Alt*键之一时，会抛出`IllegalArgumentException`异常。`keyUp()`方法的API语法如下：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `keyUp` action performed on a key, on which a `keyDown` action is not already
    being performed, will result in some unexpected results. So, we have to make sure
    we perform the `keyUp` action after a `keyDown` action is performed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个键上执行`keyUp`动作，而该键上尚未执行`keyDown`动作，可能会导致一些意外的结果。因此，我们必须确保在执行`keyDown`动作之后执行`keyUp`动作。
- en: The sendKeys method
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sendKeys`方法'
- en: 'This is used to type in alphanumeric and special character keys into WebElements
    such as textbox, textarea, and so on. This is different than the `WebElement.sendKeys(CharSequence
    keysToSend)` method, as this method expects the WebElements to have the focus
    before being called. The API syntax for the `sendkeys()` method is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于在Web元素（如文本框、文本区域等）中输入字母数字和特殊字符键。这与`WebElement.sendKeys(CharSequence keysToSend)`方法不同，因为这个方法期望在调用之前Web元素已经获得焦点。`sendkeys()`方法的API语法如下：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We expect you to implement a couple of test scripts around these keyboard events
    using the `keyUp`, `keyDown`, and `sendKeys()` methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望你使用`keyUp`、`keyDown`和`sendKeys()`方法编写一些关于这些键盘事件的测试脚本。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to use the actions class to create a set
    of actions, and build them into a composite action to execute it in one pass,
    using the `perform()` method. In this way, we can aggregate a series of complex
    user actions into a single functionality, which can be executed in one pass. In
    the next [chapter](480ab588-a7a3-4592-8b58-1b98060a0568.xhtml), we will learn
    WebDriver events and how we can listen and perform advanced actions, using WebDriver.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用动作类创建一系列动作，并将它们构建成一个组合动作，通过`perform()`方法一次性执行。这样，我们可以将一系列复杂的用户动作聚合到一个单一的功能中，并一次性执行。在下一章中，我们将学习WebDriver事件以及如何使用WebDriver监听和执行高级动作。
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: True or False – the drag and drop action requires the source element and the
    target element.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错——拖放动作需要源元素和目标元素。
- en: List the keyboard methods that we can perform using the actions API.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出我们可以使用actions API执行的键盘方法。
- en: Which method of the actions API will help in performing a double-click operation?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个actions API方法可以帮助执行双击操作？
- en: Using the actions API, how we can perform a save option (that is to say, *Ctrl*
    + *S*)?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用actions API，我们如何执行保存选项（即*Ctrl* + *S*）？
- en: How can we open a context menu using the actions API?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用actions API打开上下文菜单？
- en: Further information
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'You can check the following links for more information about the topics we
    covered in this chapter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接，了解更多关于本章所涉及主题的信息：
- en: Read more about Advanced User Interaction at [https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions](https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions](https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions)了解更多关于高级用户交互的内容
- en: 'See Chapter 4 : *Working with Selenium API* in *Selenium Testing Tools* Cookbook,
    second edition, by Unmesh Gundecha, and Chapter 6, *Utilizing the Advanced User
    Interactions API* in *Master Selenium WebDriver,* byMark Collin, for more examples
    of the actions API'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第四章节：*使用Selenium API*，出自Unmesh Gundecha所著的《Selenium测试工具手册》第二版，以及第六章节，*利用高级用户交互API*，出自Mark
    Collin所著的《精通Selenium WebDriver》，以获取更多关于动作API的示例。
