- en: Deployment and CI/CD Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the big advantages of serverless architectures is the ease, speed, and
    agility with which you can develop and deploy your application. While the various
    serverless frameworks out there give you tools to manage your application's lifecycle,
    there are still many questions to answer when it comes to managing deployments
    and environments. Additionally, the question of unit tests is sometimes more difficult
    to answer since serverless architectures often use managed services such as databases,
    queues, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn deployment tooling, techniques, and considerations.
    We will also discuss **continuous integration** (**CI**) and **continuous delivery**
    (**CD**) systems and how they hook into unit testing and automated deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment options and techniques for serverless applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The landscape of CI/CD systems and how they work with serverless applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General best practices in setting up serverless application code for unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up unit tests for a serverless Python REST application using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up CI with CircleCI to run unit tests and report test coverage on
    each commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up CI with CircleCI to deploy our production application for every
    commit to the `production` branch when tests pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI and CD are often grouped in discussions around software development life
    cycles or software engineering best practices. However, CI and CD are distinct
    concepts with their own sets of best practices, challenges, and goals. This section
    will not attempt to cover the broad subject of CI and CD, but it is essential
    to talk about a few concepts and ideas to have a discussion that applies to serverless
    architectures and systems.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these ideas were born out of the Agile and **Extreme Programming** (**XP**)
    communities. While these are not hard rules that every team needs to follow, they
    do come from groups of people who were looking to solve real-world problems. Adopting
    these practices can help any team and any project, whether the project is serverless
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CI is the process of merging code changes into a mainline branch (for example,
    often a `master` branch if using Git) early and often. Before a merge from a development
    branch to a master branch, some preconditions should be met:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests must be run and pass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New tests must cover the newly added code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another team member must do a code review or be the result of a pair programming
    session
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a serverless system, there aren't many special considerations when talking
    about CI. Pair programming, unit testing, and test coverage are ideas that are
    not unique to any particular architecture. However, there are a few tricks to
    setting up serverless application code that make testing easier and even fun.
    I'll discuss some specific scenarios and tips in the *Setting up unit tests* section.
  prefs: []
  type: TYPE_NORMAL
- en: CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While CI is usually easily understood, I feel that CD is often conflated with
    continuous deployment. Traditional CD is the process of building, testing and
    releasing software rapidly. Since *testing* is wrapped up in this definition,
    there is, of course, a natural relationship with CI. I view CD more on the spectrum
    of setting up automated systems so that the process of fixing a bug and deploying
    that fix safely and reliably to production is as fast and easy to hand off as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment is a particular feature wrapped up within CD, that is,
    every merge to the production branch results in a deployment to the production
    system. A good CD pipeline enables continuous deployments, but it's up to the
    team behind the software whether or not to enable or use continuous deployment.
    More specifically, continuous deployment requires CD, but just because a good
    CD system is in place does not mean that the team is utilizing continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good CD system may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Teammates pair program to implement a feature on a branch named `feature/xyx`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code is checked in, and CI system runs unit tests and code coverage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The team is notified of test results and given code coverage results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Team merges `feature/xyz` branch to `master` branch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tests are rerun on the `master` branch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The team is informed of test results on the `master` branch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`master` branch code is automatically deployed to production'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, it's up to the team whether the final step of automatic deployment occurs
    or not. However, the entire CD pipeline should be set up so that it's *possible*.
    When you set up a CD pipeline to *enable* continuous deployments, you'll have
    solved most of the hard problems, which makes your software development life cycle
    that much faster and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Like CI, serverless systems look mostly the same as traditional software systems
    when it comes to CD. One nice thing here is that the serverless frameworks give
    us tooling to perform deployments. In non-serverless systems, deployment scripts
    are often left as exercises for teams to undertake using a myriad of tooling,
    the choices of which are vast and not always obvious. In the serverless landscape,
    deployment options are usually limited by your framework of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the prior section, there are a few tricks and tips in setting
    up unit tests with a serverless system. The most important thing you can do is
    completely isolate your application code from the fact that it is running in a
    serverless context or within a given cloud provider. This strategy will lend other
    significant benefits other than making our tests easier to run, and I'll discuss
    those advantages in the course of this discussion on testing.
  prefs: []
  type: TYPE_NORMAL
- en: Code organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What does our code layout look like when we attempt to isolate application
    code from cloud provider-specific code? Let''s take a look at the following diagram
    that shows the high-level structure of our REST or GraphQL API from [Chapter 2](svrls-dsnptn-bstprac_ch02.html),
    *A* *Three-Tier Web Application Using REST*, and [Chapter 3](svrls-dsnptn-bstprac_ch03.html),
    *A Three-Tier Web Application Pattern with GraphQL*, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75276d11-2217-4e86-9dcc-9b148456d914.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our example application was authored in Python, but this diagram shows how this
    general code organization can work for Node, Python, or any other language. In
    addition to being language-agnostic, this should be both framework- and cloud
    provider-agnostic. The primary goal of this layout is to isolate your application
    code from any vendor, framework, or other third-party systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main ideas behind this code organization are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The primary handler or entry point that is invoked by the cloud provider contains
    any cloud-specific code and bootstraps the rest of the code (for instance, managing
    paths if necessary).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any additional libraries are wrapped up alongside the handler file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests are isolated in a `tests` directory. Only testing-related code goes in
    here, including mocks or factories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All application logic is namespaced within a separate directory (`cupping`,
    in this example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this setup, there are several advantages and no obvious disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: If you ever decide to change cloud providers, no application code changes are
    necessary. The only changes needed would be in the `handler` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests are wholly isolated from application code and are not deployed with application
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure is very trim and easy to navigate and understand for other developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any path manipulation is needed to find packages (as is the case with Python)
    you only need to add a single directory to the runtime path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is trivial to point any test runner at the single `tests` directory to run
    unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone writing serverless functions with Node shouldn't need to deal with system
    paths explicitly, as is necessary for Python. Node.js will automatically resolve
    `node_modules` as you'd expect. Some of these tips are therefore applicable only
    to Python developers or those using other supported languages that don't resolve
    libraries via convention.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `py.test`, a single file named `conftest.py` controls testing setup and
    configuration. If you can remember back to our discussion on setting up the runtime
    in `handler.py`, we had a few lines of code that added `lib` to our system path,
    which is shown in the following code. The next code block is taken directly from
    our `handler.py` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our tests using `py.test`, the main entry point will be our test
    code rather than `handler.py`. As such, any bootstrapping of our code needs to
    take place in a different location since `handler.py` will not always be imported
    before every test. In a testing context, `conftest.py` is the new entry point
    where any system bootstrapping and configuration will occur. In addition to managing
    our system path, which will now be relative to the `tests/` directory, our `conftest.py`
    file will also be responsible for setting up environment variables that were previously
    managed by our serverless framework stack. The following code from `conftest.py` shows
    the path manipulation and environment variable setup so that our tests can import
    application code and execute successfully during a test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test code will need to import two different types of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Our application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this being the case, we need to add two directories to our system path.
    The first path we add to the system path (`code_dir`) corresponds to the location
    of our application code. The second path we add to the system path (`lib_dir`)
    corresponds to the directory for third-party libraries. In the previous code block,
    you can view how that path manipulation is being handled manually.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll need to manage environment variables. In this project, there aren't
    many to contend with. All of the above environment variables deal with our PostgreSQL
    database, which happens to be running as a linked Docker container. You'll notice
    in the final `if` statement there is a check for an environment variable named
    `CIRCLECI`. If that is present, this setup code will change the host variable
    for our PostgreSQL database. I'll review this in more detail in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up CI with CircleCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a reasonably extensive landscape when it comes to hosted CI systems.
    If you add in self-hosted systems, the list grows even longer. Tools such as Jenkins
    have been around for many years, initially as self-hosted systems. Inevitably,
    hosted versions of tools such as Jenkins have emerged from various companies.
    In this section, we'll walk through the steps of setting up CircleCI ([https://circleci.com](https://circleci.com))
    to run our unit tests and produce a code coverage report on every code commit.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a book about serverless patterns, I'll encourage you to pick whatever
    tool works for your purposes with a very strong lean towards hosted CI/CD system.
    Using a hosted CI/CD systems means that you can focus more on your application
    code rather than the CI/CD system, which is just a tool we need to get our jobs
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a brand new project with CircleCI is quite simple, and it has easy
    integration with both GitHub and Bitbucket. The first thing you'll need to do
    to set up a new project is log in with one of those two services. From there,
    you can go to the Projects item in the left-hand-side navigation menu and click
    on the Add Project button in the upper-right of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows this navigation; however, I''ve already set
    up this example project, which is the reason it shows up in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0057c99a-d861-4a6e-9bf9-3bc67bb4e37d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that I also have my blog set up in CircleCI. CI can be used for
    any repository where you'd like to perform some automated set of steps when code
    is committed, or branches are merged. In the case of my blog, a script will deploy
    any new posts or changes out once they are checked in.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CircleCI builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a plethora of options and controls that you can configure within CircleCI.
    There are only a few settings we'll need to control from within the CircleCI web
    interface. Everything else will be controlled via a `config.yml` configuration
    file, which we will add to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is putting together a `.circleci/config.yml` file. The `.circleci/`
    directory lives in the root of our repository. The following code block shows
    the configuration to run unit tests in for our REST API, which is located in the
    `ch2/` directory of the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is some extra work involved in this setup since our application code lives
    in the `ch2/` directory but commands always start from the root directory. In
    a regular repository where the code isn't contained in a subdirectory, dealing
    with the `working_directory` would be unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: CircleCI 2.0 uses Docker containers for their builds. What this means for us
    is that it's quite easy to pull in any additional resources our application code
    may need to run tests. In this case, we'll pull in the official `postgres` Docker
    image. Another benefit of this is that I use a Docker container for building libraries,
    running tests, and doing deployments. Since all of this functionality is possible
    using the `verypossible/serverless` images, which I built, we can just use the
    same image to run these tests and do deployments as we did during development.
    The first image listed under the `docker` key previously will be the primary container
    where the code will be checked out, and any commands will run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker image and Makefile that I''m using here are set up to use a variable
    named `ENV`. I''ll set the `ENV` variable in this configuration file. After the
    environment section begins, a list of steps that run in sequence and make up the
    actual test run. The steps to set up and run the tests consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restore cache, so that the supporting packages are only downloaded when there
    is a change
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install supporting packages, in case they are not cached
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save cache
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run unit tests with the `make tests` command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store test coverage results, so they are viewable on CircleCI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A few different commands deal with saving and restoring the cache. These cache
    controls are specific to CircleCI, and I encourage you to read about it in detail
    in the CircleCI docs. At a high level, these steps are saving some CPU cycles
    by caching any installed libraries from previous runs rather than doing package
    downloads and installs for every test run.
  prefs: []
  type: TYPE_NORMAL
- en: There are two `run` directives, which perform the bulk of the work. Both `Install
    Python requirements` and `py.test` steps use `make` targets to do their work.
    We've already set up the actual logic of what those commands do, which you can
    review by inspecting the Makefile. Neither of these commands is incredibly complex
    (installing packages and running test). Since we've already done this work of
    wrapping up the details in the Makefile, we can take advantage of these and other make
    shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after tests are run, I'll set up CircleCI to upload the test coverage
    output files to the build's artifacts. Build artifacts are another CircleCI-specific
    task, although I know other CI systems have something similar. After the HTML
    coverage output is uploaded as a CircleCI artifact, we'll be able to view the
    results via the CircleCI website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows all of the `coverage` output files listed in
    the Artifacts tab for each build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eab05a9e-798f-4192-8f0b-017118c53857.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the coverage report is created in HTML format, I can click on the `index.html`
    file to see the complete test results. The following screenshot shows the test
    coverage report after I clicked on `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8154614d-fd83-4ea8-8bab-725da7dd3c71.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, you'll remember that there were some environment variables
    that we needed to take care of in our tests. Additionally, there was a small switch
    in our `conftest.py` file that set the PostgreSQL host based on the presence of
    a particular environment variable. CircleCI is kind enough to inject a couple
    of environment variables during a build, one of which is named `CIRCLECI`. Using
    this variable, we'll update the database host during test runs, which happens
    to be `localhost`. When we're testing our code locally with Docker containers
    that we manage, the hostname will be that of our linked PostgreSQL container.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to handling specific environment variables differently when running
    within a CircleCI build, we'll also need to manage any sensitive variables in
    preparation for deployments. Because those variables relate to the deployment
    of our stack, I'll cover this in the next section about continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up CD and deployments with CircleCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I mentioned in the introductory section of this chapter, the **D** in **CD**
    stands for **Delivery**. In this section, we''ll walk through the details of setting
    up both delivery and deployment of our application via CircleCI. I will admit,
    the boundaries here between delivery and deployment are a bit blurred, and any
    such discussions can become difficult due to disagreements in terminology and
    details. For our purposes, our CD pipeline will focus on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of automated deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For visibility and feedback, we'll use Slack and GitHub badges. Our existing
    deployment script from the Makefile and the serverless framework will be hooked
    into CircleCI to make production deployments fast, simple, and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Slack notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CircleCI has several integrations with various chat systems. Setting up test
    results to be posted to Slack (or your messaging platform of choice) is a straightforward
    and effective way to disseminate test results among team members.
  prefs: []
  type: TYPE_NORMAL
- en: In CircleCI, navigate to the Chat Notifications menu item and click on the link
    in the Slack section. From there, you'll be guided through the setup process for
    you Slack group. Ultimately, you'll get a webhook URL from Slack, which you will
    need to enter into CircleCI. Notification will be sent to this Slack webhook,
    which will post to a particular channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows project settings for this repository within
    CircleCI and the page where you configure chat notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/262832fb-0e9d-4766-b5d3-0adaf9198a2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After tests run, you''ll see the results show up in Slack. The following two
    screenshots show success and failure messages in Slack, delivered by CircleCI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b709706f-41fc-42c2-bb75-d7ca6c9f2775.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If tests fail, the message will look slightly different. The following shows
    the message when tests fail from another project I work on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35568fe0-e410-4012-9f02-46f70e7a96a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up a CircleCI badge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Current test results can also be displayed in markdown files. This badge is
    especially useful in GitHub or Bitbucket `README` files. In the Notifications | Status
    Badges section of CircleCI, you can find a markdown (or another format) snippet,
    which you can copy and put into your `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After putting that CircleCI-generated markdown snippet into the `README.md`
    file, GitHub will display the current status of the last build, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d1d3232-708f-464d-aa4b-933d86aba3fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have our tests running automatically, as well as notifications about
    test results being pushed to Slack. Now, we can work on getting CircleCI to deploy
    our code to AWS for us automatically. I'll be working through the steps to enable
    automated deployments. You may not want to do automated deployments for each of
    your projects. However, you should work toward being *able* to perform continuous
    deployments. Even if you choose not to release production code like this, working
    toward continuous deployment as an end goal means that you will have automated
    the majority of your build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up AWS credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using AWS credentials is such a common task that CircleCI has a special section
    for it in each project's configuration. If you navigate to Permissions | AWS Permissions,
    you'll find two fields for your AWS Access Key ID and AWS Secret Key. Setting
    these here ensures you'll never need to check them into source control and that
    any AWS libraries you use (noted in the following screenshot) will automatically
    pick up the values as environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting these credentials in this section works as we would expect for the
    Serverless framework, allowing any `serverless` command to execute successfully
    provided the keys we attach have the correct IAM permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1869cea-290d-4273-9489-a167700fe922.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the non-critical variables, such as the test database host and username,
    are easy to deal with in code or configuration files that are tracked in version
    control (such as `.circleci/config.yml`). When we turn our attention to deployments,
    however, there are inevitably variables that you would prefer to keep secret and
    never check into version control.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases like this, we can add variables via CircleCI from the Build Settings | Environment
    Variables section. In the following screenshot, you can see how I''m setting the
    database password for the PostgreSQL RDS instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2afea326-5e1a-4e3c-89a3-406667f82e8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a quick review of how this entire system works, variables from the environment
    are picked up by the Serverless framework. In the case of some of the RDS variables,
    we inject the values into our Lambda functions via serverless and use the variables
    when creating and setting up an RDS instance. The related snippets of `serverless.yml`
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Any value we set in CircleCI for the `CUPPING_DB_PASSWORD` will be available
    during any `serverless` commands we execute from within CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: Executing deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of the setup out of the way, we can update our CircleCI configuration
    to deploy code on our behalf. During the CI tasks, we utilized our various `make`
    targets to perform work that we were already doing manually. For deployments,
    we'll reuse another pre-existing `make` target that is already set up, `make deploy`.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `jobs` key, we'll add another step named `deploy`, which comes after
    our build step. This new deploy job has the same configuration options available
    as the previous build step. Our goal in this deploy step is actually to perform
    the deployment out to our production environment. For that to work, there are
    different configuration options that we'll need to set up, the details of which
    you can see in the following YAML snippet from `.circleci/config.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: With CircleCI, each section under the jobs keys is a standalone body of work,
    which you may define and configure on its own. These steps can work together or
    in parallel, as we'll see shortly. In this case, we already have a `build/test`
    section, and we're now adding a `deploy` section. These two jobs will work together,
    so our code is deployed only after tests are run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using the same Docker image to perform our deployments, which you
    can see in the image section. For our deployments to work, some environment variables
    need to exist, as I mentioned earlier in this chapter. Here, we can set up those
    variables in our configuration file. The RDS password is missing from this list
    on purpose since it will be injected into our deployment phase by CircleCI because
    we defined it from the CircleCI web application. Finally, the steps for deploying
    our Serverless project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make libs` from the `ch2` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make deploy` from the `ch2` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code block shows the `deploy` step of `.circleci/config.yml`
    as well as the workflows, that chains together tests and deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These job keys can be named anything you like and make sense to you. I happened
    to name them `build` and `deploy`. However, I could have called them `test` and
    `deploy`, or `build-test` and `rollout`.
  prefs: []
  type: TYPE_NORMAL
- en: With our deploy steps defined, we can instruct CircleCI to do our deployment
    under certain conditions via their workflows feature. The full capabilities of
    this feature are vast, but in our case the goal is simple; we want to do the deployment
    only when we are on the `production` branch and when tests have passed. You can
    see all of this logic in the `workflows` section in the previous configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, I performed the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Checked in some changes to the `feature/circleci` branch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Created a GitHub pull request against the `production` branch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merged the pull request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Very often a deployment flow such as this will work off the `master` branch.
    Here, I've chosen to use a branch named `production`. This change in naming convention
    is because this book's repository may have several commits for the various chapters
    and I don't want every commit to `master` to trigger a CircleCI `build-deploy`
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afbbc5ed-ffa4-4fdf-9579-e40f395c9801.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows the pull request details. With CircleCI set up,
    any pull request will show the details of the test run. Here, we can see our tests
    have successfully run. I also received a Slack notification of the successful
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once I click Merge pull request, another CircleCI build begins. In the following
    screenshot you can see that, because the `production` branch was updated, our
    `build-deploy` workflow is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0331668d-1885-43a7-87da-5239f3b1ec8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the build job runs and tests pass, the deploy step will commence. We
    can see this in CircleCI with their workflows visualization, shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a77a2113-b08a-4a9c-b4c0-3417a108fe00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By clicking on the deploy box, we can watch or see the details of the `deploy`
    phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/013489ab-7648-4f9a-9176-2c6346df9d36.png)'
  prefs: []
  type: TYPE_IMG
- en: Success! Since our `make deploy` command works for creating a brand new stack
    or updating an existing one, there is nothing more we need to do from here on.
    Any merges or commits to our `production` branch will trigger this flow, and we
    now have continuous deployment working.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the meaning and high-level details of CI and CD.
    I also discussed some best practices on how to organize application code in serverless
    projects to help set up and run unit tests. From there, I covered how to set up
    our unit tests to run on every commit using CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we worked through the entire process of setting up CircleCI to perform
    automated deployments triggered by changes to the `production` branch. You learned
    some of the nuances of controlling CI execution via environment variables and
    where to configure sensitive settings such as database passwords and AWS keys.
  prefs: []
  type: TYPE_NORMAL
