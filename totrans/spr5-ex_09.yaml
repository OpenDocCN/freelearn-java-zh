- en: Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some challenges to face when we adopt the microservices architectural
    style. The first one handles operational complexity; services such as service
    discovery and load balancer help us to tackle these points. We solved these challenges
    in the previous chapters and got to know some important tools while doing so.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other important key points to handle in microservices adoption.
    The effective way to monitor what happens in our microservices environments is
    to monitor how many times microservices consume other microservices resources,
    such as HTTP APIs, and how many times they fail. If we have near real-time statistics,
    it can save the developer days of troubleshooting and error investigations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create some services which help us monitor the Hystrix
    commands and aggregate the command's statistics in a distributed environment.
  prefs: []
  type: TYPE_NORMAL
- en: Security is an important characteristic in microservices architecture, especially
    because of the distributed characteristic adopted by the microservices architecture.
    There are a lot of microservices in our architecture; we cannot share state between
    services, so the stateless security fits well for our environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OAuth 2.0 protocol specification has this important characteristic: the
    stateless implementation. Spring Cloud Security provides support for OAuth 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will Dockerize our microservices to use the images in Docker compose
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Turbine server to aggregate Hystrix streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Hystrix Dashboard to use Turbine and input data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a mail service that will integrate an email API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Spring Cloud Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerizing our microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The airline Bookings microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The airline `Bookings` microservice is a standard Spring Boot Application. There
    are some interactions with other services, such as the `flights` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: These interactions were created using Hystrix to bring some desired behaviors,
    such as fault-tolerance and resilience, to the airline `Bookings` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: There are some business rules on this service, they are is not important to
    the learning context now, so we will skip the project creation and execution sections.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code can be found at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking));
    let's check it out and take a look at some code.
  prefs: []
  type: TYPE_NORMAL
- en: The airline Payments microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Airline `Payments` is a microservice that gives payments confirmation for
    our Airline Ticket System. For learning purposes, we will jump this project because
    there are some business rules, nothing important in the Spring Framework context.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the full source code on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments)).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the Turbine server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some integrations in our microservices group; the `Bookings` microservice
    calls the `Fares` microservice and the `Passengers` microservice, these integrations
    are done using Hystrix to make it more resilient and fault tolerant.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the microservices world, there are several instances of service.
    This will require us to aggregate the Hystrix command metrics by instance. Managing
    the instances panel by panel is not a good idea. The Turbine server helps developers
    in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Turbine pulls metrics from servers run by Hystrix, but it is not
    recommended for cloud environments because it can consume high values of network
    bandwidth and it will increase the traffic costs. We will use Spring Cloud Stream
    RabbitMQ to push metrics to Turbine via the **Advanced Message Queuing Protocol**
    (**AMQP**). Due to this, we will need to configure the RabbitMQ connections and
    put two more dependencies in our microservices, the dependencies are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These dependencies will enable the metrics to be sent to the Turbine server
    via the AMQP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The Turbine stream, by default, uses the port `8989` . We will configure it
    to run at `8010`, and we can use the `turbine.stream.port` property in the `application.yaml`
    to customize it.
  prefs: []
  type: TYPE_NORMAL
- en: The Turbine stream will be a Hystrix Dashboard data input to show the commands
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code can be found on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine)).
  prefs: []
  type: TYPE_NORMAL
- en: There are many configurations to customize the Turbine server. They make the
    server extremely adaptable for different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the Turbine documentation in the *Spring Cloud Turbine* section
    ([https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine)).
    There is a great deal of information, especially if you need to customize some
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Turbine server microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create our Turbine server. We will create a standard Spring Boot Application
    with a couple of annotations to enable Turbine stream and discovery client, as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main class should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `@EnableTurbineStream` will enable us to push Hystrix commands
    metrics via the RabbitMQ message broker, which is enough for us.
  prefs: []
  type: TYPE_NORMAL
- en: The Turbine server `application.yaml` file can be found on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml)).
    There are a couple of configurations, such as discovery client and Turbine server
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the application, via the command line or IDE. Run it!
  prefs: []
  type: TYPE_NORMAL
- en: Make some calls to the `flights` microservice. The Create Flight API will call
    the `planes` microservice, which uses the Hystrix command, and will trigger some
    Hystrix command calls.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Postman Collection located at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection)).
    This collection has a Create Flight request, which will call the `planes` microservices
    to get plane details. It is enough to collect metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test whether our Turbine server is running correctly. Go to the
    Turbine stream endpoint and then the JSON data with metrics should be displayed
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897fd218-a456-46b6-b147-7c58822772b2.png)'
  prefs: []
  type: TYPE_IMG
- en: There are some Hystrix commands information, but as we can see, this information
    needs to be organized to make it useful for us. Turbine uses the **Server-Sent
    Events** (**SSE**) technology, which was introduced in [Chapter 6](b82dbdb2-c96b-466f-aa29-2e2c40a69d3c.xhtml),
    *Playing with Server-Sent Events*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce the Hystrix Dashboard. It will help us
    to organize and make this information useful for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Hystrix Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Hystrix Dashboard will help us to organize the Turbine stream information.
    As we saw in the previous section, the Turbine server sends information via SSE.
    It is done using JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Hystrix stream provides a dashboard for us. Let''s create our Hystrix Dashboard
    microservice. The application is a standard Spring Boot Application annotated
    with `@EnableHystrixDashboard`. Let''s add the dependency to enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, now we can create the main class for our application. The main class
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The full source code can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui).'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this is a pretty standard Spring Boot Application annotated with
    `@EnableHystrixDashboard`. It will provide the Hystrix Dashboard for us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can run the application via IDE or the Java command line. Run it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The Hystrix Dashboard can be accessed using the following URL : `http://localhost:50010/hystrix`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, go to the Hystrix Dashboard main page. The following page should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f178ddc-af28-4ae0-b1c6-8176be580b95.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome – our Hystrix Dashboard is up and running. On this page, we can point
    to `hystrix.stream` or `turbine.stream` to consume and show the commands' metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this application running, we will use it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome job, guys, let's move to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Mail microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create our `Mail` microservice. The name is self-explanatory, this
    component will be responsible for sending emails. We will not configure an **SMTP**
    (**Simple Mail Transfer Protocol**) server, we will use SendGrid.
  prefs: []
  type: TYPE_NORMAL
- en: SendGrid is an **SaaS** (**Software as a Service**) service for emails, we will
    use this service to send emails to our Airline Ticket System. There are some triggers
    to send email, for example, when the user creates a booking and when the payment
    is accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Mail` microservice will listen to a queue. Then the integration will be
    done using the message broker. We choose this strategy because we do not need
    the feature that enables us to answer synchronously. Another essential characteristic
    is the retry policy when the communication is broken. This behavior can be done
    easily using the message strategy.
  prefs: []
  type: TYPE_NORMAL
- en: We are using RabbitMQ as a message broker. For this project, we will use RabbitMQ
    Reactor, which is a reactive implementation of RabbitMQ Java client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SendGrid account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to code, we need to create a SendGrid account. We will use the
    trial account which is enough for our tests. Go to the SendGrid portal ([https://sendgrid.com/](https://sendgrid.com/))
    and click on the Try for Free button.
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the required information and click on the Create Account button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main page, on the left side, click on Settings, then go to the API Key
    section, follow the image shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f91bfd7e-d7ca-4a5f-9254-3b9028189fc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can click on the Create API Key button at the top-right corner. The
    page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d9869f8-daef-42e2-8a4b-9da667060d62.png)'
  prefs: []
  type: TYPE_IMG
- en: Fillin the API Key information and choose Full Access. After that the API Key
    will appear on your screen. Take a note of it in a safe place, as we will use
    it as an environment variable soon.
  prefs: []
  type: TYPE_NORMAL
- en: Goob job, our SendGrid account is ready to use, now we can code our `Mail` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Mail microservice project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we did in [Chapter 8](02944733-f452-49bc-bb4f-f4fa819c2405.xhtml), *Circuit
    Breakers and Security,* we will take a look at essential project parts. We will
    be using Spring Initializr, as we have several times in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code can be found at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service)).
  prefs: []
  type: TYPE_NORMAL
- en: Adding RabbitMQ dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the RabbitMQ required dependencies. The following dependencies should
    be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first one is about the reactive implementation for RabbitMQ and the second
    one is the starter AMQP, which will set up some configurations automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring some RabbitMQ stuff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to configure some RabbitMQ exchanges, queues, and bindings. It can be
    done using the RabbitMQ client library. We will configure our required infrastructure
    for the `Mail` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our configuration class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is interesting stuff here, but all of it is about infrastructure in RabbitMQ.
    It is important because when our application is in bootstrapping time, it means
    our application is preparing to run. This code will be executed and create the
    necessary queues, exchanges, and bindings. Some configurations are provided by
    the `application.yaml` file, look at the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling a Mail message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Mail` service is abstract and can be used for different purposes, so we
    will create a simple class to represent a mail message in our system. Our `Mail`
    class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Easy, this class represents an abstract message on our system.
  prefs: []
  type: TYPE_NORMAL
- en: The MailSender class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can expect, we will integrate with the SendGrid services through the REST
    APIs. In our case, we will use the reactive `WebClient` provided by Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use the SendGrid API Key created in the previous section. Our
    `MailSender` class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We received the configurations in the constructor, that is, the `sendgrid.apikey`
    and `sendgrid.url`. They will be configured soon. In the `send()` method, there
    are some interesting constructions. Look at `BodyInserters.fromObject()`: it allows
    us to send a JSON object in the HTTP body. In our case, we will create a `SendGrid`
    mail object.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `onStatus()` function, we can pass a predicate to handle the HTTP errors
    family. In our case, we are interested in the 4xx error family.
  prefs: []
  type: TYPE_NORMAL
- en: This class will process sending the mail messages, but it is necessary to listen
    to the RabbbitMQ queue, which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RabbitMQ queue listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our `MailQueueConsumer` class, which will listen to the RabbitMQ
    queue. The class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The method annotated with `@PostConstruct` will be invoked after `MailQueueConsumer`
    is ready, which will mean that the injections are processed. Then `Receiver` will
    start to process the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Mail microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will run our `Mail` microservice. Find the `MailServiceApplication`
    class, the main class of our project. The main class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is a standard Spring Boot Application.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the application in IDE or via the Java command line.
  prefs: []
  type: TYPE_NORMAL
- en: Run it!
  prefs: []
  type: TYPE_NORMAL
- en: We need to pass `${SENDGRID_APIKEY}` and `${SENDGRID_URL}` as environment variables.
    If you are running the application with the Java command line, the `-D` option
    allows us to pass environment variables. If you are using the IDE, you can configure
    in the Run/Debug Configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Authentication microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to secure our microservices. Security is essential for microservices
    applications, especially because of the distributed characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: On the microservices architectural style, usually, there is a service that will
    act as an authentication service. It means this service will authenticate the
    requests in our microservices group.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Security provides a declarative model to help developers enable
    security on applications. There is support for commons patterns such as OAuth
    2.0\. Also, Spring Boot Security enables **Single Sign-On** (**SSO**).
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Security also supports relay SSO tokens integrating with Zuul proxy.
    It means the tokens will be passed to downstream microservices.
  prefs: []
  type: TYPE_NORMAL
- en: For our architecture, we will use the OAuth 2.0 and JWT patterns, both integrate
    with Zuul proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do so, let''s understand the main entities in OAuth 2.0 flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected resource**: This service will apply security rules; the microservices
    applications, in our case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OAuth authorization server**: The authentication server is a service between
    the application, which can be a frontend or a mobile, and a service that applications
    want to call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: The application that will call the service, the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Owner**: The user or machine that will authorize the client application
    to access their account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s draw the basic OAuth flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/917002f4-1c25-4b28-80a2-3994a64c0db5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can observe the following in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Client** requests the authorization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Resource Owner** sends the authorization grant
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application client requests the access token from the **Authorization Server**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the authorization grant is valid, the **Authorization Server** will provide
    the access token
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application calls the protected resource and sends the access token
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the **Resource Server** recognizes the token, the resource will serve for
    the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the basics of the OAuth 2.0 authorization flow. We will implement
    this flow using Spring Cloud Security. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Auth microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have been doing in this chapter, we will take a look at the important
    parts. Let''s start with our dependencies. We need to put in the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These dependencies will enable us to use the Spring Cloud Security features.
    Let's start to code our Authentication microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start coding our `Auth` microservice. We will start with the authorization
    and authentication, as we want to protect all resources in our microservices,
    then we will configure `WebSecurityConfigureAdapter`. The class should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot of stuff here. Let's start with the `@EnableWebSecurity`, this
    annotation enables Spring Security integrations with Spring MVC. `@EnableGlobalMethodSecurity`
    provides AOP interceptors to enable methods security using the annotations. We
    can use this feature by annotating the methods on a controller, for instance.
    The basic idea is to wrap the methods call in AOP interceptors and apply security
    on the methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`WebSecurityConfigurerAdapter` enables us to configure the secure endpoints
    and some stuff about how to authenticate users, which can be done using the `configure(AuthenticationManagerBuilder
    auth)` method. We have configured our `CredentialsDetailsService` and our `PasswordEncoder`
    to avoid plane password between application layers. In this case, `CredentialsDetailsService`
    is the source of our user''s data.'
  prefs: []
  type: TYPE_NORMAL
- en: In our method, `configure(HttpSecurity http)`, we have configured some HTTP
    security rules. As we can see, all users can access `/login` and `/**/register/**`.
    It's about *Sign In* and *Sign Up* features. All other requests need to be authenticated
    by the Authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CredentialsDetailsService` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special here. We need to override the `loadUserByUsername(String
    email)` method to provide the user data to Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure our token signer and our token store. We will provide these
    beans using the `@Configuration` class, as we did in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have configured our private and public keys in the `application.yaml` file.
    Optionally, we can read the `jks` files from the classpath as well. Then, we provided
    our token signer or token enhancer using the `JwtAccessTokenConverter` class,
    where we have used the private and public key.
  prefs: []
  type: TYPE_NORMAL
- en: In our token store, Spring Security Framework will use this object to read data
    from tokens, then set up the `JwtAccessTokenConverter` on the `JwtTokenStore`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have provided the password encoder class using the `BCryptPasswordEncoder`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last class is the Authorization server configuration. The configuration
    can be done using the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `OAuth2AuthServer` class located on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java)).
  prefs: []
  type: TYPE_NORMAL
- en: We have used `@EnableAuthorizationServer` to configure the Authorization server
    mechanism in our `Auth` microservice. This class works together with `AuthorizationServerConfigurerAdapter`
    to provide some customizations.
  prefs: []
  type: TYPE_NORMAL
- en: On `configure(AuthorizationServerSecurityConfigurer oauthServer),` we have configured
    the security for token endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: At `configure(AuthorizationServerEndpointsConfigurer endpoints),` we have configured
    the endpoints of the token service such as, `/oauth/token` and `/oauth/authorize`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on configure (`ClientDetailsServiceConfigurer` clients), we have configured
    the client's ID and secrets. We used in-memory data, but we can use JDBC implementations
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Auth` microservice main class should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a standard Spring Boot Application with service discovery
    and Zuul proxy enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Auth microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can see, the `Auth` microservice is ready for testing. Our microservice
    is listening to port `7777`, which we configured using the `application.yaml`
    file on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Client credentials flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the client credentials flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application needs to be up on port `7777`, then we can use the following
    command line to get the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, this *client ID* and *client secret* are from the `planes` microservice.
    We did this configuration at the `OAuth2AuthServer` class. Let''s remember the
    exact point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After you call the preceding command, the result should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13bf0165-4bc6-43a7-a57b-3f314d22a2f2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the token was obtained with success. Well done, our client credentials
    flow was configured successfully. Let's move to the implicit flow, which will
    be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit grant flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at how to authenticate in our `Auth` microservice
    using the implicit flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we test our flow, let''s create a user to enable authentication in the
    `Auth` microservice. The following command will create a user in the `Auth` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the email is `john@doe.com` and the password is `john`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the browser to do this task. Let''s go to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:7777/oauth/authorize?client_id=ecommerce&response_type=token&scope=write&state=8777&redirect_uri=https://httpbin.org/anything`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part is the service address. To use the implicit grant flow, we need
    the path `/oauth/authorize`. Also we will use `ecommerce` as a client ID because
    we have configured it previously. `response_type=token` informs the implicit flow,
    `scope` is the scope as what we want in our case is write, `state` is a random
    variable, and `redirect_uri` is the URI to go after the `oauth` login process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the URL in a web browser, and the following page should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49f91e24-a935-420e-81b0-cb11e20051be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After typing the User and Password, the following page will be displayed to
    authorize our protected resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34998698-9d77-44ee-8a59-60d7fb1309da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Authorize button. Then we will see the token in the browser URL
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e1a2819-63ac-45c6-a937-04098bee29aa.png)'
  prefs: []
  type: TYPE_IMG
- en: The full token can be viewed if we copy the browser URL.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome job, guys, our `Auth` microservice is fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will configure the `Auth` microservice to protect Zuul
    proxy downstream microservices, such as the `planes` microservices. Let's jump
    to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the microservices with OAuth 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will configure OAuth 2.0 to protect our microservices; in our case, our
    microservices are the resource servers. Let's start with the `planes` microservices.
    We will add the new dependency and configure the private and public keys. Also,
    we will configure our `JwtTokenStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the security dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the newly required dependency, we will change the `pom.xml` of the `planes`
    microservice. We will add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A piece of cake – our required dependency is configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will configure the `application.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application.yaml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure our private and public keys, we will use the `application.yaml`
    file. We did this configuration in the `Auth` microservice. The configuration
    is pretty easy. We need to add the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the user info URI will be done using the following configuration
    in YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome – our application is fully configured. Now, we will do the last part:
    configuring to get the information token.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the JwtTokenStore Bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create the `JwtTokenStore`, which will be used to get token information.
    The class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Awesome – our token signer is configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add the following annotation to the main class, which should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It will protect our application, and it will require the access token to access
    the application endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we need to do the same task for all microservices that we want to
    protect.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the microservice architectural style, monitoring is a crucial part. There
    are a lot of benefits when we adopt this architecture, such as time to market,
    source maintenance, and an increase of business performance. This is because we
    can divide the business goals for different teams, and each team will be responsible
    for some microservices. Another important characteristic is optimization of computational
    resources, such as cloud computing costs.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, there is no such thing as a free lunch, and this style brings some
    drawbacks, such as operational complexity. There are a lot of *small services*
    to monitor. There are potentially hundreds of different service instances.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented some of these services in our infrastructure but until now,
    we did not have the data to analyze our system health. In this section, we will
    explore our configured services.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze right now!
  prefs: []
  type: TYPE_NORMAL
- en: Collecting metrics with Zipkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have configured our Zipkin server in the previous chapter. Now we will use
    this server to analyze our microservices data. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make some calls to create a flight. The Create Flight API will call the **Auth
    Service** and the **Flight Service**. Look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d874e0e-edc0-4f67-b1fb-26d3cc25dbce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will take a look at the `flights` microservice and the `planes` microservice
    communications. Let''s analyze it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Zipkin main page, `http://localhost:9999/`, select flights, and then
    click on Find a trace. The page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f5af854-2b36-4d7d-ac13-044f49d8ad00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, there is some data on our Zipkin server. Click on Span, which
    has the `flights` and `planes` tags, then we will take a look at this specific
    trace, and we will be redirected to another page with specific span data, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9378b77e-cf44-41e0-a450-89baa56db7a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On this page, we can see important information, such as the total request time.
    Then click on the planes row, where we will be able to see detailed information,
    as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87230629-9881-4fc9-bd39-fe2636017523.png)'
  prefs: []
  type: TYPE_IMG
- en: Look at the request information. There are some interesting things, such as
    `mvc.controller.class` and `mvc.controller.method`. These help developers to troubleshoot
    errors. Also in the first panel, we have the times of the service's interactions.
    It is very helpful to find microservices network latencies; for example, it makes
    environment management easier because we have visual tools to understand data
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the Zipkin server provides others interesting features to find microservices
    statistics, such as finding requests that have delayed for more than a specific
    time. It is very helpful for the operations guys.
  prefs: []
  type: TYPE_NORMAL
- en: We can find more information about Spring Cloud Sleuth on the documentation
    page ([http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html))
    or in the GitHub ([https://github.com/spring-cloud/spring-cloud-sleuth](https://github.com/spring-cloud/spring-cloud-sleuth))
    project page.
  prefs: []
  type: TYPE_NORMAL
- en: Collection commands statistics with Hystrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we want to monitor our Hystrix commands. There are several commands in
    our microservices and probably the most used will be the OAuth token requester,
    because we always need to have a token to call any microservice in our system.
    Our Turbine server and Hystrix UI were configured at the beginning of this chapter
    and we will use these services right now.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we are using `spring-cloud-netflix-hystrix-stream` as an implementation
    to send Hystrix data to the Turbine server, as it performs better than HTTP and
    also brings some asynchronous characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous calls can make the microservice more resilient. In this case, we
    will not use HTTP calls (synchronous calls) to register Hystrix Commands statistics.
    We will use the RabbitMQ queue to register it. In this case, we will put the message
    in the queue. Also, asynchronous calls make our application more optimized to
    use computational resources.
  prefs: []
  type: TYPE_NORMAL
- en: Run the Turbine server application and Hystrix UI application. Turbine will
    aggregate the metrics from the servers. Optionally, you can run several instances
    of the same service, such as `flights`. Turbine will aggregate the statistics
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's call the Create Flights API; we can use the Postman to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Then we can see the real-time commands statistics. Before that, we will configure
    `turbine.stream` in our Hystrix Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Hystrix Dashboard page: `http://localhost:50010/hystrix/`. The following
    page will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50d157c-7333-4ef6-a67e-e5dac0d957aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we have some work to do. Let's configure our Turbine server stream. Our
    Turbine stream is running at `http://localhost:8010/turbine.stream`. Put this
    information below the Hystrix Dashboard information, and then we can click on
    the Monitor Stream button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will redirect to the Hystrix Commands Dashboard; we called the Create Flights
    API a few times ago. The commands metrics will be displayed, like the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42a34f54-fc7b-4bdd-9152-afafc3242b54.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we called the Create Flights API eight times. This API uses some
    commands, such as `flights.plane-by-id,` it calls the planes microservice, and
    the `flights.request-token` calls the `Auth` service.
  prefs: []
  type: TYPE_NORMAL
- en: Look how easy it is to monitor the commands. Operation guys like the Zipkin
    server can use this page.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome job, guys, our services integrations are adequately monitored, which
    makes our microservices adoption more comfortable because we have useful applications
    to monitor our services instances.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing the microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have used the Fabric8 Maven Docker plugin to enable
    us to create Docker images, using the Maven goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to configure our microservices to use this plugin to easily create
    images for us. It can be helpful to integrate with some Continuous Integration
    and Delivery tools, such as Jenkins, because we can call the `docker: build` goal
    easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Each project has the custom configurations, such as port and image name. We
    can find the configuration at the GitHub repository. Remember, the configuration
    is done using the `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list has the GitHub repository addresses for all projects; the
    `pom.xml` has the Maven Docker plugin configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flights**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Planes**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fares**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bookings**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EDGE**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passengers**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auth**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mail**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turbine**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zipkin**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payments**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hystrix-dashboard**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discovery**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Config Server**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can run our Docker containers using our images, which were created in
    the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We will split the services into two Docker compose files. The first one is about
    infrastructure services. The second one is about our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The stacks must be run on the same Docker network, because the service should
    be connected by the container hostname.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker compose file for infrastructure can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker compose file for microservices can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run these files using the `docker-compose` commands. Type the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then the full application will be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Well done, guys.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned some important points on microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We were introduced to some important tools for monitoring the microservices
    environment. We have learned how the Turbine server can help us to monitor our
    Hystrix commands in distributed environments.
  prefs: []
  type: TYPE_NORMAL
- en: We were also introduced to the Hystrix Dashboard feature, which helps the developers
    and operations guys provide a rich dashboard with the commands statistics in near
    real time.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how Spring Cloud Security enables security features for our microservices,
    and we implemented the OAuth 2 server, using JWT to enable resilience for our
    security layer.
  prefs: []
  type: TYPE_NORMAL
