- en: Putting It All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: There are some challenges to face when we adopt the microservices architectural
    style. The first one handles operational complexity; services such as service
    discovery and load balancer help us to tackle these points. We solved these challenges
    in the previous chapters and got to know some important tools while doing so.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用微服务架构风格时，我们会面临一些挑战。第一个是处理操作复杂性；如服务发现和负载均衡器等这样的服务帮助我们解决这些问题。我们在前面的章节中解决了这些挑战，并在解决这些挑战的过程中了解了一些重要的工具。
- en: There are some other important key points to handle in microservices adoption.
    The effective way to monitor what happens in our microservices environments is
    to monitor how many times microservices consume other microservices resources,
    such as HTTP APIs, and how many times they fail. If we have near real-time statistics,
    it can save the developer days of troubleshooting and error investigations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用微服务架构时，还有一些其他重要的关键点需要处理。有效监控我们微服务环境中发生的事情的方法是监控微服务消耗其他微服务资源（如 HTTP API）的次数以及它们失败的次数。如果我们有接近实时的统计数据，可以节省开发者几天的时间进行故障排除和错误调查。
- en: In this chapter, we will create some services which help us monitor the Hystrix
    commands and aggregate the command's statistics in a distributed environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一些服务，这些服务可以帮助我们监控 Hystrix 命令并在分布式环境中聚合命令的统计信息。
- en: Security is an important characteristic in microservices architecture, especially
    because of the distributed characteristic adopted by the microservices architecture.
    There are a lot of microservices in our architecture; we cannot share state between
    services, so the stateless security fits well for our environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是微服务架构中的一个重要特性，尤其是在微服务架构采用的分布式特性方面。在我们的架构中有很多微服务；我们无法在服务之间共享状态，因此无状态安全非常适合我们的环境。
- en: 'The OAuth 2.0 protocol specification has this important characteristic: the
    stateless implementation. Spring Cloud Security provides support for OAuth 2.0.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 协议规范具有这个重要的特性：无状态实现。Spring Cloud Security 提供了对 OAuth 2.0 的支持。
- en: Finally, we will Dockerize our microservices to use the images in Docker compose
    files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 Docker 将我们的微服务 Docker 化，以便使用 Docker Compose 文件中的镜像。
- en: 'In this chapter, we will learn about:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解：
- en: Implementing the Turbine server to aggregate Hystrix streams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现聚合 Hystrix 流的 Turbine 服务器
- en: Configuring the Hystrix Dashboard to use Turbine and input data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Hystrix Dashboard 以使用 Turbine 和输入数据
- en: Creating a mail service that will integrate an email API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将集成电子邮件 API 的邮件服务
- en: Understanding Spring Cloud Security
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Spring Cloud Security
- en: Dockerizing our microservices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的微服务 Docker 化
- en: The airline Bookings microservice
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 航空公司预订微服务
- en: The airline `Bookings` microservice is a standard Spring Boot Application. There
    are some interactions with other services, such as the `flights` microservice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 航空公司 `预订` 微服务是一个标准的 Spring Boot 应用程序。它与其他服务有一些交互，例如 `航班` 微服务。
- en: These interactions were created using Hystrix to bring some desired behaviors,
    such as fault-tolerance and resilience, to the airline `Bookings` microservice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交互是通过 Hystrix 创建的，为航空公司 `预订` 微服务带来了一些期望的行为，例如容错和弹性。
- en: There are some business rules on this service, they are is not important to
    the learning context now, so we will skip the project creation and execution sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务有一些业务规则，它们现在对学习上下文并不重要，所以我们将在项目创建和执行部分跳过。
- en: The full source code can be found at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking));
    let's check it out and take a look at some code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在 GitHub 上找到（[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking)）；让我们查看它并看看一些代码。
- en: The airline Payments microservice
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 航空公司支付微服务
- en: The Airline `Payments` is a microservice that gives payments confirmation for
    our Airline Ticket System. For learning purposes, we will jump this project because
    there are some business rules, nothing important in the Spring Framework context.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 航空公司 `支付` 是一个微服务，为我们的航空公司票务系统提供支付确认。出于学习目的，我们将跳过这个项目，因为其中有一些业务规则，在 Spring 框架的上下文中并不重要。
- en: We can find the full source code on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GitHub上找到完整的源代码（[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments)）。
- en: Learning about the Turbine server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解涡轮服务器
- en: There are some integrations in our microservices group; the `Bookings` microservice
    calls the `Fares` microservice and the `Passengers` microservice, these integrations
    are done using Hystrix to make it more resilient and fault tolerant.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务组中，有一些集成；`Bookings`微服务调用`Fares`微服务和`Passengers`微服务，这些集成是通过Hystrix来实现的，使其更具弹性和容错性。
- en: However, in the microservices world, there are several instances of service.
    This will require us to aggregate the Hystrix command metrics by instance. Managing
    the instances panel by panel is not a good idea. The Turbine server helps developers
    in this context.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在微服务世界中，存在多个服务实例。这将需要我们按实例聚合Hystrix命令指标。逐个管理实例不是一个好主意。在这种情况下，涡轮服务器可以帮助开发者。
- en: 'By default, Turbine pulls metrics from servers run by Hystrix, but it is not
    recommended for cloud environments because it can consume high values of network
    bandwidth and it will increase the traffic costs. We will use Spring Cloud Stream
    RabbitMQ to push metrics to Turbine via the **Advanced Message Queuing Protocol**
    (**AMQP**). Due to this, we will need to configure the RabbitMQ connections and
    put two more dependencies in our microservices, the dependencies are:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，涡轮从由Hystrix运行的服务器中拉取指标，但在云环境中不推荐这样做，因为它可能会消耗大量的网络带宽，并增加流量成本。我们将使用Spring
    Cloud Stream RabbitMQ通过**高级消息队列协议**（**AMQP**）将指标推送到涡轮。因此，我们需要配置RabbitMQ连接，并在我们的微服务中添加两个额外的依赖项，这些依赖项是：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These dependencies will enable the metrics to be sent to the Turbine server
    via the AMQP protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项将使指标可以通过AMQP协议发送到涡轮服务器。
- en: The Turbine stream, by default, uses the port `8989` . We will configure it
    to run at `8010`, and we can use the `turbine.stream.port` property in the `application.yaml`
    to customize it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，涡轮流使用端口`8989`。我们将将其配置为在`8010`上运行，并且我们可以使用`application.yaml`中的`turbine.stream.port`属性来自定义它。
- en: The Turbine stream will be a Hystrix Dashboard data input to show the commands
    metrics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 涡轮流将成为Hystrix仪表板的数据输入，以显示命令指标。
- en: The full source code can be found on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine)）。
- en: There are many configurations to customize the Turbine server. They make the
    server extremely adaptable for different use cases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多配置可以自定义涡轮服务器。这使得服务器能够适应不同的用例。
- en: We can find the Turbine documentation in the *Spring Cloud Turbine* section
    ([https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine)).
    There is a great deal of information, especially if you need to customize some
    configurations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*Spring Cloud Turbine*部分找到涡轮文档（[https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine)）。这里有大量的信息，特别是如果你需要自定义一些配置的话。
- en: Creating the Turbine server microservice
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建涡轮服务器微服务
- en: Let's create our Turbine server. We will create a standard Spring Boot Application
    with a couple of annotations to enable Turbine stream and discovery client, as
    well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的涡轮服务器。我们将创建一个标准的Spring Boot应用程序，并添加一些注解来启用涡轮流和发现客户端。
- en: 'The main class should be:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 主类应该是：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, `@EnableTurbineStream` will enable us to push Hystrix commands
    metrics via the RabbitMQ message broker, which is enough for us.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@EnableTurbineStream`将使我们能够通过RabbitMQ消息代理推送Hystrix命令指标，这对我们来说已经足够了。
- en: The Turbine server `application.yaml` file can be found on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml)).
    There are a couple of configurations, such as discovery client and Turbine server
    configuration.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Turbine服务器的`application.yaml`文件可以在GitHub上找到（[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml)）。有几个配置，例如发现客户端和Turbine服务器配置。
- en: We can run the application, via the command line or IDE. Run it!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过命令行或IDE运行应用程序。运行它！
- en: Make some calls to the `flights` microservice. The Create Flight API will call
    the `planes` microservice, which uses the Hystrix command, and will trigger some
    Hystrix command calls.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对`flights`微服务进行一些调用。创建航班API将调用`planes`微服务，该微服务使用Hystrix命令，并将触发一些Hystrix命令调用。
- en: We can use the Postman Collection located at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection)).
    This collection has a Create Flight request, which will call the `planes` microservices
    to get plane details. It is enough to collect metrics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用位于GitHub上的Postman集合（[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection)）。这个集合有一个创建航班请求，该请求将调用`planes`微服务以获取飞机详情。收集指标就足够了。
- en: 'Now, we can test whether our Turbine server is running correctly. Go to the
    Turbine stream endpoint and then the JSON data with metrics should be displayed
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的Turbine服务器是否运行正确。转到Turbine流端点，然后应该显示带有指标的JSON数据，如下所示：
- en: '![](img/897fd218-a456-46b6-b147-7c58822772b2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/897fd218-a456-46b6-b147-7c58822772b2.png)'
- en: There are some Hystrix commands information, but as we can see, this information
    needs to be organized to make it useful for us. Turbine uses the **Server-Sent
    Events** (**SSE**) technology, which was introduced in [Chapter 6](b82dbdb2-c96b-466f-aa29-2e2c40a69d3c.xhtml),
    *Playing with Server-Sent Events*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些Hystrix命令信息，但正如我们所见，这些信息需要组织以便对我们有用。Turbine使用**服务器端事件**（**SSE**）技术，该技术在第6章中介绍，即*与服务器端事件玩耍*。
- en: In the next section, we will introduce the Hystrix Dashboard. It will help us
    to organize and make this information useful for us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍Hystrix仪表板。它将帮助我们组织和使这些信息对我们有用。
- en: Let's jump to the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到下一节。
- en: Hystrix Dashboard
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hystrix仪表板
- en: The Hystrix Dashboard will help us to organize the Turbine stream information.
    As we saw in the previous section, the Turbine server sends information via SSE.
    It is done using JSON objects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix仪表板将帮助我们组织Turbine流信息。正如我们在上一节中看到的，Turbine服务器通过SSE发送信息。这是通过JSON对象完成的。
- en: 'The Hystrix stream provides a dashboard for us. Let''s create our Hystrix Dashboard
    microservice. The application is a standard Spring Boot Application annotated
    with `@EnableHystrixDashboard`. Let''s add the dependency to enable it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix流为我们提供了一个仪表板。让我们创建我们的Hystrix仪表板微服务。该应用程序是一个标准的带有`@EnableHystrixDashboard`注解的Spring
    Boot应用程序。让我们添加依赖项以启用它：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Good, now we can create the main class for our application. The main class
    should look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以创建我们应用程序的主类。主类应该看起来像这样：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The full source code can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui)。
- en: As we can see, this is a pretty standard Spring Boot Application annotated with
    `@EnableHystrixDashboard`. It will provide the Hystrix Dashboard for us.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个相当标准的带有`@EnableHystrixDashboard`注解的Spring Boot应用程序。它将为我们提供Hystrix仪表板。
- en: Now, we can run the application via IDE or the Java command line. Run it!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过IDE或Java命令行运行应用程序。运行它！
- en: 'The Hystrix Dashboard can be accessed using the following URL : `http://localhost:50010/hystrix`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix仪表板可以通过以下URL访问：`http://localhost:50010/hystrix`。
- en: 'Then, go to the Hystrix Dashboard main page. The following page should be displayed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到Hystrix仪表板的主页面。以下页面应该会显示：
- en: '![](img/4f178ddc-af28-4ae0-b1c6-8176be580b95.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f178ddc-af28-4ae0-b1c6-8176be580b95.png)'
- en: Awesome – our Hystrix Dashboard is up and running. On this page, we can point
    to `hystrix.stream` or `turbine.stream` to consume and show the commands' metrics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——我们的 Hystrix 仪表板已经启动并运行。在这个页面上，我们可以指向 `hystrix.stream` 或 `turbine.stream`
    来消费并显示命令的指标。
- en: Keep this application running, we will use it later in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 保持此应用程序运行，我们将在本章后面使用它。
- en: Awesome job, guys, let's move to the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，让我们进入下一节。
- en: Creating the Mail microservice
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Mail 微服务
- en: Now, we will create our `Mail` microservice. The name is self-explanatory, this
    component will be responsible for sending emails. We will not configure an **SMTP**
    (**Simple Mail Transfer Protocol**) server, we will use SendGrid.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的 `Mail` 微服务。这个名字很直观，这个组件将负责发送电子邮件。我们不会配置一个 **SMTP** (**简单邮件传输协议**)
    服务器，我们将使用 SendGrid。
- en: SendGrid is an **SaaS** (**Software as a Service**) service for emails, we will
    use this service to send emails to our Airline Ticket System. There are some triggers
    to send email, for example, when the user creates a booking and when the payment
    is accepted.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SendGrid 是一个用于电子邮件的 **SaaS** (**软件即服务**) 服务，我们将使用此服务向我们的航空公司票务系统发送电子邮件。有一些触发器用于发送电子邮件，例如，当用户创建预订和当付款被接受时。
- en: Our `Mail` microservice will listen to a queue. Then the integration will be
    done using the message broker. We choose this strategy because we do not need
    the feature that enables us to answer synchronously. Another essential characteristic
    is the retry policy when the communication is broken. This behavior can be done
    easily using the message strategy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Mail` 微服务将监听一个队列。然后，我们将使用消息代理来完成集成。我们选择这种策略是因为我们不需要能够同步回答的功能。另一个基本特征是在通信中断时的重试策略。这种行为可以通过消息策略轻松实现。
- en: We are using RabbitMQ as a message broker. For this project, we will use RabbitMQ
    Reactor, which is a reactive implementation of RabbitMQ Java client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 RabbitMQ 作为消息代理。对于此项目，我们将使用 RabbitMQ Reactor，这是 RabbitMQ Java 客户端的响应式实现。
- en: Creating the SendGrid account
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SendGrid 账户
- en: Before we start to code, we need to create a SendGrid account. We will use the
    trial account which is enough for our tests. Go to the SendGrid portal ([https://sendgrid.com/](https://sendgrid.com/))
    and click on the Try for Free button.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们需要创建一个 SendGrid 账户。我们将使用试用账户，这对于我们的测试来说足够了。访问 SendGrid 门户 ([https://sendgrid.com/](https://sendgrid.com/))
    并点击免费试用按钮。
- en: Fill in the required information and click on the Create Account button.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 填写所需信息并点击创建账户按钮。
- en: 'In the main page, on the left side, click on Settings, then go to the API Key
    section, follow the image shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页面上，在左侧点击设置，然后转到 API 密钥部分，按照这里显示的图片操作：
- en: '![](img/f91bfd7e-d7ca-4a5f-9254-3b9028189fc4.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f91bfd7e-d7ca-4a5f-9254-3b9028189fc4.png)'
- en: 'Then, we can click on the Create API Key button at the top-right corner. The
    page should look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以点击右上角的创建 API 密钥按钮。页面应该看起来像这样：
- en: '![](img/5d9869f8-daef-42e2-8a4b-9da667060d62.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d9869f8-daef-42e2-8a4b-9da667060d62.png)'
- en: Fillin the API Key information and choose Full Access. After that the API Key
    will appear on your screen. Take a note of it in a safe place, as we will use
    it as an environment variable soon.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 填写 API 密钥信息并选择完全访问。之后，API 密钥将出现在您的屏幕上。请将其记在一个安全的地方，因为我们很快就会将其用作环境变量。
- en: Goob job, our SendGrid account is ready to use, now we can code our `Mail` microservice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，我们的 SendGrid 账户已经准备好使用，现在我们可以编写我们的 `Mail` 微服务了。
- en: Let's do it in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中这样做。
- en: Creating the Mail microservice project
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Mail 微服务项目
- en: As we did in [Chapter 8](02944733-f452-49bc-bb4f-f4fa819c2405.xhtml), *Circuit
    Breakers and Security,* we will take a look at essential project parts. We will
    be using Spring Initializr, as we have several times in the previous chapters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 8 章](02944733-f452-49bc-bb4f-f4fa819c2405.xhtml) 中所做的那样，*断路器和安全*，我们将查看基本项目部分。我们将使用
    Spring Initializr，就像我们在前面的章节中多次做的那样。
- en: The full source code can be found at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在 GitHub 上找到 ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service))。
- en: Adding RabbitMQ dependencies
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 RabbitMQ 依赖项
- en: 'Let''s add the RabbitMQ required dependencies. The following dependencies should
    be added:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 RabbitMQ 所需的依赖项。以下依赖项应该添加：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first one is about the reactive implementation for RabbitMQ and the second
    one is the starter AMQP, which will set up some configurations automatically.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个关于 RabbitMQ 的反应式实现，第二个是 starter AMQP，它将自动设置一些配置。
- en: Configuring some RabbitMQ stuff
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一些 RabbitMQ 东西
- en: We want to configure some RabbitMQ exchanges, queues, and bindings. It can be
    done using the RabbitMQ client library. We will configure our required infrastructure
    for the `Mail` microservice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要配置一些 RabbitMQ 交换机、队列和绑定。这可以通过 RabbitMQ 客户端库来完成。我们将为 `Mail` 微服务配置所需的基础设施。
- en: 'Our configuration class should look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础设施配置类应该看起来像这样：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is interesting stuff here, but all of it is about infrastructure in RabbitMQ.
    It is important because when our application is in bootstrapping time, it means
    our application is preparing to run. This code will be executed and create the
    necessary queues, exchanges, and bindings. Some configurations are provided by
    the `application.yaml` file, look at the constructor.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的东西，但所有这些都关于 RabbitMQ 的基础设施。这很重要，因为当我们的应用程序处于引导时间时，这意味着我们的应用程序正在准备运行。这段代码将被执行并创建必要的队列、交换机和绑定。一些配置由
    `application.yaml` 文件提供，请查看构造函数。
- en: Modeling a Mail message
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型邮件消息
- en: 'Our `Mail` service is abstract and can be used for different purposes, so we
    will create a simple class to represent a mail message in our system. Our `Mail`
    class should look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Mail` 服务是抽象的，可以用于不同的目的，因此我们将创建一个简单的类来代表我们系统中的邮件消息。我们的 `Mail` 类应该看起来像这样：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Easy, this class represents an abstract message on our system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，这个类代表了我们系统中的一个抽象消息。
- en: The MailSender class
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MailSender` 类'
- en: As we can expect, we will integrate with the SendGrid services through the REST
    APIs. In our case, we will use the reactive `WebClient` provided by Spring WebFlux.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，我们将通过 REST API 与 SendGrid 服务集成。在我们的案例中，我们将使用 Spring WebFlux 提供的反应式 `WebClient`。
- en: 'Now, we will use the SendGrid API Key created in the previous section. Our
    `MailSender` class should look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用上一节中创建的 SendGrid API 密钥。我们的 `MailSender` 类应该看起来像这样：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We received the configurations in the constructor, that is, the `sendgrid.apikey`
    and `sendgrid.url`. They will be configured soon. In the `send()` method, there
    are some interesting constructions. Look at `BodyInserters.fromObject()`: it allows
    us to send a JSON object in the HTTP body. In our case, we will create a `SendGrid`
    mail object.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中收到了配置，即 `sendgrid.apikey` 和 `sendgrid.url`。它们将很快被配置。在 `send()` 方法中，有一些有趣的结构。看看
    `BodyInserters.fromObject()`：它允许我们在 HTTP 主体中发送一个 JSON 对象。在我们的案例中，我们将创建一个 `SendGrid`
    邮件对象。
- en: In the `onStatus()` function, we can pass a predicate to handle the HTTP errors
    family. In our case, we are interested in the 4xx error family.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onStatus()` 函数中，我们可以传递一个谓词来处理 HTTP 错误系列。在我们的案例中，我们对 4xx 错误系列感兴趣。
- en: This class will process sending the mail messages, but it is necessary to listen
    to the RabbbitMQ queue, which we will do in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将处理发送邮件消息，但我们需要监听 RabbitMQ 队列，这将在下一节中完成。
- en: Creating the RabbitMQ queue listener
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RabbitMQ 队列监听器
- en: 'Let''s create our `MailQueueConsumer` class, which will listen to the RabbitMQ
    queue. The class should look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 `MailQueueConsumer` 类，它将监听 RabbitMQ 队列。这个类应该看起来像这样：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method annotated with `@PostConstruct` will be invoked after `MailQueueConsumer`
    is ready, which will mean that the injections are processed. Then `Receiver` will
    start to process the messages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注解了 `@PostConstruct` 的方法将在 `MailQueueConsumer` 准备就绪后调用，这意味着注入已经处理。然后 `Receiver`
    将开始处理消息。
- en: Running the Mail microservice
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Mail 微服务
- en: 'Now, we will run our `Mail` microservice. Find the `MailServiceApplication`
    class, the main class of our project. The main class should look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行我们的 `Mail` 微服务。找到 `MailServiceApplication` 类，这是我们的项目的主类。主类应该看起来像这样：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is a standard Spring Boot Application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的 Spring Boot 应用程序。
- en: We can run the application in IDE or via the Java command line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 IDE 中或通过 Java 命令行运行应用程序。
- en: Run it!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它！
- en: We need to pass `${SENDGRID_APIKEY}` and `${SENDGRID_URL}` as environment variables.
    If you are running the application with the Java command line, the `-D` option
    allows us to pass environment variables. If you are using the IDE, you can configure
    in the Run/Debug Configurations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要传递 `${SENDGRID_APIKEY}` 和 `${SENDGRID_URL}` 作为环境变量。如果你使用 Java 命令行运行应用程序，`-D`
    选项允许我们传递环境变量。如果你使用 IDE，你可以在运行/调试配置中配置。
- en: Creating the Authentication microservice
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建身份验证微服务
- en: We want to secure our microservices. Security is essential for microservices
    applications, especially because of the distributed characteristics.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要保护我们的微服务。对于微服务应用程序来说，安全性至关重要，尤其是由于分布式特性。
- en: On the microservices architectural style, usually, there is a service that will
    act as an authentication service. It means this service will authenticate the
    requests in our microservices group.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构风格中，通常有一个服务将充当认证服务。这意味着此服务将认证我们微服务组中的请求。
- en: Spring Cloud Security provides a declarative model to help developers enable
    security on applications. There is support for commons patterns such as OAuth
    2.0\. Also, Spring Boot Security enables **Single Sign-On** (**SSO**).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Security提供了一个声明性模型，以帮助开发者启用应用程序的安全性。它支持如OAuth 2.0等常见模式。此外，Spring
    Boot Security还支持**单点登录**（**SSO**）。
- en: Spring Boot Security also supports relay SSO tokens integrating with Zuul proxy.
    It means the tokens will be passed to downstream microservices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Security还支持与Zuul代理集成的中继SSO令牌。这意味着令牌将被传递到下游微服务。
- en: For our architecture, we will use the OAuth 2.0 and JWT patterns, both integrate
    with Zuul proxy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的架构，我们将使用OAuth 2.0和JWT模式，两者都与Zuul代理集成。
- en: 'Before we do so, let''s understand the main entities in OAuth 2.0 flow:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之前，让我们了解OAuth 2.0流程中的主要实体：
- en: '**Protected resource**: This service will apply security rules; the microservices
    applications, in our case'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护资源**：此服务将应用安全规则；在我们的案例中是微服务应用程序'
- en: '**OAuth authorization server**: The authentication server is a service between
    the application, which can be a frontend or a mobile, and a service that applications
    want to call'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth授权服务器**：认证服务器是位于应用程序（可以是前端或移动端）和应用程序想要调用的服务之间的一个服务'
- en: '**Application**: The application that will call the service, the client.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序**：将要调用服务的应用程序，即客户端。'
- en: '**Resource Owner**: The user or machine that will authorize the client application
    to access their account'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：将授权客户端应用程序访问其账户的用户或机器'
- en: 'Let''s draw the basic OAuth flow:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制基本的OAuth流程：
- en: '![](img/917002f4-1c25-4b28-80a2-3994a64c0db5.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/917002f4-1c25-4b28-80a2-3994a64c0db5.png)'
- en: 'We can observe the following in this diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这张图中观察到以下内容：
- en: The **Client** requests the authorization
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端**请求授权'
- en: The **Resource Owner** sends the authorization grant
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**资源所有者**发送授权许可'
- en: The application client requests the access token from the **Authorization Server**
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序客户端从**授权服务器**请求访问令牌
- en: If the authorization grant is valid, the **Authorization Server** will provide
    the access token
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果授权许可有效，**授权服务器**将提供访问令牌
- en: The application calls the protected resource and sends the access token
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用受保护的资源并发送访问令牌
- en: If the **Resource Server** recognizes the token, the resource will serve for
    the application
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**资源服务器**识别了令牌，该资源将为应用程序提供服务
- en: These are the basics of the OAuth 2.0 authorization flow. We will implement
    this flow using Spring Cloud Security. Let's do it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是OAuth 2.0授权流程的基础。我们将使用Spring Cloud Security实现此流程。让我们开始做。
- en: Creating the Auth microservice
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Auth微服务
- en: 'As we have been doing in this chapter, we will take a look at the important
    parts. Let''s start with our dependencies. We need to put in the following dependencies:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中所做的那样，我们将查看重要部分。让我们从我们的依赖项开始。我们需要添加以下依赖项：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These dependencies will enable us to use the Spring Cloud Security features.
    Let's start to code our Authentication microservice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项将使我们能够使用Spring Cloud Security功能。让我们开始编写我们的认证微服务。
- en: Configuring the security
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置安全
- en: 'Let''s start coding our `Auth` microservice. We will start with the authorization
    and authentication, as we want to protect all resources in our microservices,
    then we will configure `WebSecurityConfigureAdapter`. The class should look like
    this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写我们的`Auth`微服务。我们将从授权和认证开始，因为我们想要保护我们微服务中的所有资源，然后我们将配置`WebSecurityConfigureAdapter`。该类应该看起来像这样：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is a lot of stuff here. Let's start with the `@EnableWebSecurity`, this
    annotation enables Spring Security integrations with Spring MVC. `@EnableGlobalMethodSecurity`
    provides AOP interceptors to enable methods security using the annotations. We
    can use this feature by annotating the methods on a controller, for instance.
    The basic idea is to wrap the methods call in AOP interceptors and apply security
    on the methods.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容。让我们从 `@EnableWebSecurity` 注解开始，这个注解使 Spring Security 能够与 Spring MVC
    集成。`@EnableGlobalMethodSecurity` 提供了 AOP 拦截器，以使用注解启用方法安全。我们可以通过在控制器上的方法上注解来使用此功能，例如。基本思想是将方法调用包装在
    AOP 拦截器中，并在方法上应用安全。
- en: '`WebSecurityConfigurerAdapter` enables us to configure the secure endpoints
    and some stuff about how to authenticate users, which can be done using the `configure(AuthenticationManagerBuilder
    auth)` method. We have configured our `CredentialsDetailsService` and our `PasswordEncoder`
    to avoid plane password between application layers. In this case, `CredentialsDetailsService`
    is the source of our user''s data.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSecurityConfigurerAdapter` 允许我们配置安全的端点和一些关于如何认证用户的内容，这可以通过使用 `configure(AuthenticationManagerBuilder
    auth)` 方法来完成。我们已经配置了我们的 `CredentialsDetailsService` 和 `PasswordEncoder` 以避免在应用程序层之间传递明文密码。在这种情况下，`CredentialsDetailsService`
    是我们用户数据的来源。'
- en: In our method, `configure(HttpSecurity http)`, we have configured some HTTP
    security rules. As we can see, all users can access `/login` and `/**/register/**`.
    It's about *Sign In* and *Sign Up* features. All other requests need to be authenticated
    by the Authorization server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `configure(HttpSecurity http)` 方法中，我们配置了一些 HTTP 安全规则。正如我们所看到的，所有用户都可以访问
    `/login` 和 `/**/register/**`。这是关于 *登录* 和 *注册* 功能。所有其他请求都需要通过授权服务器进行认证。
- en: 'The `CredentialsDetailsService` should look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CredentialsDetailsService` 应该看起来像这样：'
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is nothing special here. We need to override the `loadUserByUsername(String
    email)` method to provide the user data to Spring Security.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处。我们需要重写 `loadUserByUsername(String email)` 方法来提供用户数据给 Spring Security。
- en: 'Let''s configure our token signer and our token store. We will provide these
    beans using the `@Configuration` class, as we did in the previous chapters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置我们的令牌签名者和令牌存储。我们将使用 `@Configuration` 类提供这些 Bean，就像我们在前面的章节中所做的那样：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have configured our private and public keys in the `application.yaml` file.
    Optionally, we can read the `jks` files from the classpath as well. Then, we provided
    our token signer or token enhancer using the `JwtAccessTokenConverter` class,
    where we have used the private and public key.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `application.yaml` 文件中配置了我们的私有和公开密钥。可选地，我们还可以从类路径中读取 `jks` 文件。然后，我们使用 `JwtAccessTokenConverter`
    类提供了我们的令牌签名者或令牌增强器，其中我们使用了私有和公开密钥。
- en: In our token store, Spring Security Framework will use this object to read data
    from tokens, then set up the `JwtAccessTokenConverter` on the `JwtTokenStore`
    instance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的令牌存储中，Spring Security 框架将使用此对象从令牌中读取数据，然后在 `JwtTokenStore` 实例上设置 `JwtAccessTokenConverter`。
- en: Finally, we have provided the password encoder class using the `BCryptPasswordEncoder`
    class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `BCryptPasswordEncoder` 类提供了密码编码器类。
- en: 'Our last class is the Authorization server configuration. The configuration
    can be done using the following class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的类是授权服务器配置。配置可以使用以下类来完成：
- en: Look at the `OAuth2AuthServer` class located on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位于 GitHub 上的 `OAuth2AuthServer` 类（[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java)）。
- en: We have used `@EnableAuthorizationServer` to configure the Authorization server
    mechanism in our `Auth` microservice. This class works together with `AuthorizationServerConfigurerAdapter`
    to provide some customizations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Auth` 微服务中使用了 `@EnableAuthorizationServer` 来配置授权服务器机制。这个类与 `AuthorizationServerConfigurerAdapter`
    一起工作，以提供一些自定义设置。
- en: On `configure(AuthorizationServerSecurityConfigurer oauthServer),` we have configured
    the security for token endpoints.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `configure(AuthorizationServerSecurityConfigurer oauthServer)` 上，我们配置了令牌端点的安全设置。
- en: At `configure(AuthorizationServerEndpointsConfigurer endpoints),` we have configured
    the endpoints of the token service such as, `/oauth/token` and `/oauth/authorize`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `configure(AuthorizationServerEndpointsConfigurer endpoints)` 中，我们已配置了令牌服务的端点，例如
    `/oauth/token` 和 `/oauth/authorize`。
- en: Finally, on configure (`ClientDetailsServiceConfigurer` clients), we have configured
    the client's ID and secrets. We used in-memory data, but we can use JDBC implementations
    as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在配置 (`ClientDetailsServiceConfigurer clients`) 中，我们已配置了客户端的 ID 和密钥。我们使用了内存数据，但也可以使用
    JDBC 实现。
- en: 'The `Auth` microservice main class should be:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Auth` 微服务的主类应该是：'
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have created a standard Spring Boot Application with service discovery
    and Zuul proxy enabled.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有服务发现和 Zuul 代理的标准 Spring Boot 应用程序。
- en: Testing the Auth microservice
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Auth 微服务
- en: As we can see, the `Auth` microservice is ready for testing. Our microservice
    is listening to port `7777`, which we configured using the `application.yaml`
    file on GitHub.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Auth` 微服务已准备好测试。我们的微服务正在监听端口 `7777`，这是我们在 GitHub 上的 `application.yaml`
    文件中配置的。
- en: Client credentials flow
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端凭证流程
- en: Let's start with the client credentials flow.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从客户端凭证流程开始。
- en: 'Our application needs to be up on port `7777`, then we can use the following
    command line to get the token:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要运行在端口 `7777` 上，然后我们可以使用以下命令行来获取令牌：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see, this *client ID* and *client secret* are from the `planes` microservice.
    We did this configuration at the `OAuth2AuthServer` class. Let''s remember the
    exact point:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个 *客户端 ID* 和 *客户端密钥* 来自 `planes` 微服务。我们在 `OAuth2AuthServer` 类中进行了此配置。让我们记住确切的位置：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After you call the preceding command, the result should be:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用上述命令后，结果应该是：
- en: '![](img/13bf0165-4bc6-43a7-a57b-3f314d22a2f2.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13bf0165-4bc6-43a7-a57b-3f314d22a2f2.png)'
- en: As we can see, the token was obtained with success. Well done, our client credentials
    flow was configured successfully. Let's move to the implicit flow, which will
    be covered in the next section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，令牌已成功获取。做得好，我们的客户端凭证流程已成功配置。让我们转到隐式流程，这将在下一节中介绍。
- en: Implicit grant flow
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式授权流程
- en: In this section, we will take a look at how to authenticate in our `Auth` microservice
    using the implicit flow.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用隐式流程在我们的 `Auth` 微服务中进行身份验证。
- en: 'Before we test our flow, let''s create a user to enable authentication in the
    `Auth` microservice. The following command will create a user in the `Auth` service:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试我们的流程之前，让我们创建一个用户以在 `Auth` 微服务中启用身份验证。以下命令将在 `Auth` 服务中创建一个用户：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the email is `john@doe.com` and the password is `john`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，电子邮件是 `john@doe.com`，密码是 `john`。
- en: 'We will use the browser to do this task. Let''s go to the following URL:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用浏览器来完成这个任务。让我们访问以下 URL：
- en: '`http://localhost:7777/oauth/authorize?client_id=ecommerce&response_type=token&scope=write&state=8777&redirect_uri=https://httpbin.org/anything`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:7777/oauth/authorize?client_id=ecommerce&response_type=token&scope=write&state=8777&redirect_uri=https://httpbin.org/anything`'
- en: 'Let''s understand the parameters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这些参数：
- en: The first part is the service address. To use the implicit grant flow, we need
    the path `/oauth/authorize`. Also we will use `ecommerce` as a client ID because
    we have configured it previously. `response_type=token` informs the implicit flow,
    `scope` is the scope as what we want in our case is write, `state` is a random
    variable, and `redirect_uri` is the URI to go after the `oauth` login process.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是服务地址。要使用隐式授权流程，我们需要路径 `/oauth/authorize`。我们还将使用 `ecommerce` 作为客户端 ID，因为我们之前已经配置了它。`response_type=token`
    通知隐式流程，`scope` 是我们想要的范围，在我们的案例中是写权限，`state` 是一个随机变量，`redirect_uri` 是 `oauth` 登录过程之后的
    URI。
- en: 'Put the URL in a web browser, and the following page should be displayed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将 URL 放入网页浏览器中，应该会显示以下页面：
- en: '![](img/49f91e24-a935-420e-81b0-cb11e20051be.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49f91e24-a935-420e-81b0-cb11e20051be.png)'
- en: 'After typing the User and Password, the following page will be displayed to
    authorize our protected resources:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入用户名和密码后，将显示以下页面以授权我们的受保护资源：
- en: '![](img/34998698-9d77-44ee-8a59-60d7fb1309da.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34998698-9d77-44ee-8a59-60d7fb1309da.png)'
- en: 'Click on the Authorize button. Then we will see the token in the browser URL
    like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 点击授权按钮。然后我们将在浏览器 URL 中看到令牌，如下所示：
- en: '![](img/6e1a2819-63ac-45c6-a937-04098bee29aa.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e1a2819-63ac-45c6-a937-04098bee29aa.png)'
- en: The full token can be viewed if we copy the browser URL.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们复制浏览器 URL，可以查看完整的令牌。
- en: Awesome job, guys, our `Auth` microservice is fully operational.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 伙计们，干得好，我们的 `Auth` 微服务完全可用。
- en: In the next sections, we will configure the `Auth` microservice to protect Zuul
    proxy downstream microservices, such as the `planes` microservices. Let's jump
    to the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将配置`Auth`微服务以保护Zuul代理下游微服务，例如`planes`微服务。让我们跳到下一节。
- en: Protecting the microservices with OAuth 2.0
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0保护微服务
- en: Now we will configure OAuth 2.0 to protect our microservices; in our case, our
    microservices are the resource servers. Let's start with the `planes` microservices.
    We will add the new dependency and configure the private and public keys. Also,
    we will configure our `JwtTokenStore`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将配置OAuth 2.0来保护我们的微服务；在我们的案例中，我们的微服务是资源服务器。让我们从`planes`微服务开始。我们将添加新的依赖项并配置私钥和公钥。同时，我们还将配置我们的`JwtTokenStore`。
- en: Let's do it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Adding the security dependency
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加安全依赖
- en: 'To add the newly required dependency, we will change the `pom.xml` of the `planes`
    microservice. We will add the following dependency:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加新要求的依赖项，我们将更改`planes`微服务的`pom.xml`文件。我们将添加以下依赖项：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A piece of cake – our required dependency is configured properly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 小菜一碟——我们所需的依赖项已经正确配置。
- en: In the next section, we will configure the `application.yaml` file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将配置`application.yaml`文件。
- en: Configuring the application.yaml file
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置application.yaml文件
- en: 'To configure our private and public keys, we will use the `application.yaml`
    file. We did this configuration in the `Auth` microservice. The configuration
    is pretty easy. We need to add the following snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置我们的私钥和公钥，我们将使用`application.yaml`文件。我们在`Auth`微服务中进行了此配置。配置相当简单。我们需要添加以下片段：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Moreover, the user info URI will be done using the following configuration
    in YAML:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户信息URI将通过以下YAML配置完成：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Awesome – our application is fully configured. Now, we will do the last part:
    configuring to get the information token.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——我们的应用程序已经完全配置好了。现在，我们将进行最后一部分：配置以获取信息令牌。
- en: Let's do that.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做。
- en: Creating the JwtTokenStore Bean
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建JwtTokenStore Bean
- en: 'We will create the `JwtTokenStore`, which will be used to get token information.
    The class should look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`JwtTokenStore`，它将被用来获取令牌信息。这个类应该看起来像这样：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Awesome – our token signer is configured.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——我们的令牌签名者已经配置好了。
- en: 'Finally, we will add the following annotation to the main class, which should
    look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向主类添加以下注解，它应该看起来像这样：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It will protect our application, and it will require the access token to access
    the application endpoints.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它将保护我们的应用程序，并且访问应用程序端点需要访问令牌。
- en: Remember, we need to do the same task for all microservices that we want to
    protect.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们需要为我们想要保护的所有的微服务执行相同的任务。
- en: Monitoring the microservices
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控微服务
- en: In the microservice architectural style, monitoring is a crucial part. There
    are a lot of benefits when we adopt this architecture, such as time to market,
    source maintenance, and an increase of business performance. This is because we
    can divide the business goals for different teams, and each team will be responsible
    for some microservices. Another important characteristic is optimization of computational
    resources, such as cloud computing costs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构风格中，监控是一个关键部分。当我们采用这种架构时，有很多好处，比如上市时间、源维护和业务性能的提升。这是因为我们可以将业务目标分配给不同的团队，每个团队将负责一些微服务。另一个重要特征是计算资源的优化，比如云计算成本。
- en: As we know, there is no such thing as a free lunch, and this style brings some
    drawbacks, such as operational complexity. There are a lot of *small services*
    to monitor. There are potentially hundreds of different service instances.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，没有免费的午餐，这种风格带来了一些缺点，比如操作复杂性。有很多*小服务*需要监控。可能有数百个不同的服务实例。
- en: We have implemented some of these services in our infrastructure but until now,
    we did not have the data to analyze our system health. In this section, we will
    explore our configured services.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的基础设施中实现了一些这些服务，但直到现在，我们还没有数据来分析我们的系统健康。在本节中，我们将探索我们配置的服务。
- en: Let's analyze right now!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即分析！
- en: Collecting metrics with Zipkin
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zipkin收集指标
- en: We have configured our Zipkin server in the previous chapter. Now we will use
    this server to analyze our microservices data. Let's do it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中已经配置了我们的Zipkin服务器。现在我们将使用这个服务器来分析我们的微服务数据。让我们开始吧。
- en: 'Make some calls to create a flight. The Create Flight API will call the **Auth
    Service** and the **Flight Service**. Look at the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 进行一些调用以创建航班。创建航班API将调用**认证服务**和**航班服务**。查看以下图表：
- en: '![](img/4d874e0e-edc0-4f67-b1fb-26d3cc25dbce.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d874e0e-edc0-4f67-b1fb-26d3cc25dbce.png)'
- en: 'We will take a look at the `flights` microservice and the `planes` microservice
    communications. Let''s analyze it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看`flights`微服务和`planes`微服务之间的通信。让我们来分析它：
- en: 'Go to the Zipkin main page, `http://localhost:9999/`, select flights, and then
    click on Find a trace. The page should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前往Zipkin主页面，`http://localhost:9999/`，选择航班，然后点击“查找跟踪”。页面应该看起来像这样：
- en: '![](img/0f5af854-2b36-4d7d-ac13-044f49d8ad00.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f5af854-2b36-4d7d-ac13-044f49d8ad00.png)'
- en: 'As we can see, there is some data on our Zipkin server. Click on Span, which
    has the `flights` and `planes` tags, then we will take a look at this specific
    trace, and we will be redirected to another page with specific span data, like
    this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的Zipkin服务器上有一些数据。点击“跨度”，它带有`flights`和`planes`标签，然后我们将查看这个特定的跟踪，并且将被重定向到另一个页面，其中包含特定的跨度数据，如下所示：
- en: '![](img/9378b77e-cf44-41e0-a450-89baa56db7a6.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9378b77e-cf44-41e0-a450-89baa56db7a6.png)'
- en: 'On this page, we can see important information, such as the total request time.
    Then click on the planes row, where we will be able to see detailed information,
    as in the following image:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以看到一些重要信息，例如总请求时间。然后点击“平面”行，我们将会看到以下图像中的详细信息：
- en: '![](img/87230629-9881-4fc9-bd39-fe2636017523.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87230629-9881-4fc9-bd39-fe2636017523.png)'
- en: Look at the request information. There are some interesting things, such as
    `mvc.controller.class` and `mvc.controller.method`. These help developers to troubleshoot
    errors. Also in the first panel, we have the times of the service's interactions.
    It is very helpful to find microservices network latencies; for example, it makes
    environment management easier because we have visual tools to understand data
    better.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 查看请求信息。这里有一些有趣的内容，例如`mvc.controller.class`和`mvc.controller.method`。这些内容有助于开发者排查错误。在第一个面板中，我们还看到了服务交互的时间。这对于查找微服务网络延迟非常有帮助；例如，它使得环境管理变得更加容易，因为我们有可视化工具来更好地理解数据。
- en: Also, the Zipkin server provides others interesting features to find microservices
    statistics, such as finding requests that have delayed for more than a specific
    time. It is very helpful for the operations guys.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Zipkin服务器还提供了其他一些有趣的功能来查找微服务统计信息，例如查找延迟超过特定时间的请求。这对运维人员非常有帮助。
- en: We can find more information about Spring Cloud Sleuth on the documentation
    page ([http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html))
    or in the GitHub ([https://github.com/spring-cloud/spring-cloud-sleuth](https://github.com/spring-cloud/spring-cloud-sleuth))
    project page.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在文档页面（[http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html)）或GitHub（[https://github.com/spring-cloud/spring-cloud-sleuth](https://github.com/spring-cloud/spring-cloud-sleuth)）项目页面上找到更多关于Spring
    Cloud Sleuth的信息。
- en: Collection commands statistics with Hystrix
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hystrix收集命令统计
- en: Now, we want to monitor our Hystrix commands. There are several commands in
    our microservices and probably the most used will be the OAuth token requester,
    because we always need to have a token to call any microservice in our system.
    Our Turbine server and Hystrix UI were configured at the beginning of this chapter
    and we will use these services right now.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要监控我们的Hystrix命令。在我们的微服务中存在多个命令，可能最常用的是OAuth令牌请求者，因为我们总是需要有一个令牌来调用我们系统中的任何微服务。我们的Turbine服务器和Hystrix
    UI在本章的开头就已经配置好了，我们现在将使用这些服务。
- en: Remember, we are using `spring-cloud-netflix-hystrix-stream` as an implementation
    to send Hystrix data to the Turbine server, as it performs better than HTTP and
    also brings some asynchronous characteristics.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在使用`spring-cloud-netflix-hystrix-stream`作为实现，将Hystrix数据发送到Turbine服务器，因为它比HTTP性能更好，同时也带来了一些异步特性。
- en: Asynchronous calls can make the microservice more resilient. In this case, we
    will not use HTTP calls (synchronous calls) to register Hystrix Commands statistics.
    We will use the RabbitMQ queue to register it. In this case, we will put the message
    in the queue. Also, asynchronous calls make our application more optimized to
    use computational resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 异步调用可以使微服务更加健壮。在这种情况下，我们不会使用HTTP调用（同步调用）来注册Hystrix命令统计信息。我们将使用RabbitMQ队列来注册它。在这种情况下，我们将消息放入队列。此外，异步调用使我们的应用程序更优化地使用计算资源。
- en: Run the Turbine server application and Hystrix UI application. Turbine will
    aggregate the metrics from the servers. Optionally, you can run several instances
    of the same service, such as `flights`. Turbine will aggregate the statistics
    properly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Turbine服务器应用程序和Hystrix UI应用程序。Turbine将聚合来自服务器的指标。可选地，你可以运行相同服务的多个实例，例如`flights`。Turbine将正确地聚合统计信息。
- en: Let's call the Create Flights API; we can use the Postman to do that.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用创建航班API；我们可以使用Postman来完成这个操作。
- en: Then we can see the real-time commands statistics. Before that, we will configure
    `turbine.stream` in our Hystrix Dashboard.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到实时的命令统计信息。在此之前，我们将在Hystrix仪表板中配置`turbine.stream`。
- en: 'Go to the Hystrix Dashboard page: `http://localhost:50010/hystrix/`. The following
    page will be displayed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前往Hystrix仪表板页面：`http://localhost:50010/hystrix/`。以下页面将会显示：
- en: '![](img/d50d157c-7333-4ef6-a67e-e5dac0d957aa.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d50d157c-7333-4ef6-a67e-e5dac0d957aa.png)'
- en: Then we have some work to do. Let's configure our Turbine server stream. Our
    Turbine stream is running at `http://localhost:8010/turbine.stream`. Put this
    information below the Hystrix Dashboard information, and then we can click on
    the Monitor Stream button.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一些工作要做。让我们配置我们的Turbine服务器流。我们的Turbine流运行在`http://localhost:8010/turbine.stream`。将此信息放在Hystrix仪表板信息下方，然后我们可以点击监控流按钮。
- en: 'We will redirect to the Hystrix Commands Dashboard; we called the Create Flights
    API a few times ago. The commands metrics will be displayed, like the following
    image:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重定向到Hystrix命令仪表板；我们之前调用过创建航班API几次。命令指标将显示，如下面的图像所示：
- en: '![](img/42a34f54-fc7b-4bdd-9152-afafc3242b54.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42a34f54-fc7b-4bdd-9152-afafc3242b54.png)'
- en: As we can see, we called the Create Flights API eight times. This API uses some
    commands, such as `flights.plane-by-id,` it calls the planes microservice, and
    the `flights.request-token` calls the `Auth` service.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们调用了创建航班API八次。这个API使用了一些命令，例如`flights.plane-by-id`，它调用飞机微服务，而`flights.request-token`调用`Auth`服务。
- en: Look how easy it is to monitor the commands. Operation guys like the Zipkin
    server can use this page.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 看看监控命令有多简单。运维人员喜欢使用Zipkin服务器这样的页面。
- en: Awesome job, guys, our services integrations are adequately monitored, which
    makes our microservices adoption more comfortable because we have useful applications
    to monitor our services instances.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 了不起的工作，大家，我们的服务集成得到了充分的监控，这使得我们的微服务采用更加舒适，因为我们有有用的应用程序来监控我们的服务实例。
- en: Dockerizing the microservices
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务Docker化
- en: In the previous chapters, we have used the Fabric8 Maven Docker plugin to enable
    us to create Docker images, using the Maven goals.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了Fabric8 Maven Docker插件来启用我们使用Maven目标创建Docker镜像。
- en: 'Now, we need to configure our microservices to use this plugin to easily create
    images for us. It can be helpful to integrate with some Continuous Integration
    and Delivery tools, such as Jenkins, because we can call the `docker: build` goal
    easily.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们需要配置我们的微服务以使用此插件，以便轻松为我们创建镜像。与一些持续集成和持续交付工具（如Jenkins）集成可能会有所帮助，因为我们可以轻松调用`docker:
    build`目标。'
- en: Each project has the custom configurations, such as port and image name. We
    can find the configuration at the GitHub repository. Remember, the configuration
    is done using the `pom.xml`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有自定义配置，例如端口和镜像名称。我们可以在GitHub仓库中找到配置。记住，配置是通过`pom.xml`完成的。
- en: 'The following list has the GitHub repository addresses for all projects; the
    `pom.xml` has the Maven Docker plugin configuration:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含了所有项目的GitHub仓库地址；`pom.xml`文件中包含了Maven Docker插件的配置：
- en: '**Flights**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**航班**：[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml)'
- en: '**Planes**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**飞机**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml)'
- en: '**Fares**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**票价**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml)'
- en: '**Bookings**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml)'
- en: '**Admin**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml)'
- en: '**EDGE**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml)'
- en: '**Passengers**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘客**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml)'
- en: '**Auth**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml)'
- en: '**Mail**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮件**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml)'
- en: '**Turbine**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**涡轮机**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml)'
- en: '**Zipkin**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zipkin**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml)'
- en: '**Payments**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml)'
- en: '**Hystrix-dashboard**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hystrix仪表板**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml)'
- en: '**Discovery**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml)'
- en: '**Config Server**: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置服务器**：[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml)'
- en: Running the system
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行系统
- en: Now we can run our Docker containers using our images, which were created in
    the previous section.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用上一节创建的镜像来运行我们的 Docker 容器。
- en: We will split the services into two Docker compose files. The first one is about
    infrastructure services. The second one is about our microservices.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务分成两个 Docker Compose 文件。第一个是关于基础设施服务。第二个是关于我们的微服务。
- en: The stacks must be run on the same Docker network, because the service should
    be connected by the container hostname.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些堆栈必须在同一个 Docker 网络上运行，因为服务应该通过容器主机名连接。
- en: 'The Docker compose file for infrastructure can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施的 Docker Compose 文件可以在 GitHub 上找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml)。
- en: 'The Docker compose file for microservices can be found at GitHub: [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的 Docker Compose 文件可以在 GitHub 上找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml)。
- en: 'Now, we can run these files using the `docker-compose` commands. Type the following
    commands:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `docker-compose` 命令运行这些文件。请输入以下命令：
- en: '[PRE23]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then the full application will be up and running.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，完整的应用程序将启动并运行。
- en: Well done, guys.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，伙计们。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned some important points on microservices architecture.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于微服务架构的一些重要要点。
- en: We were introduced to some important tools for monitoring the microservices
    environment. We have learned how the Turbine server can help us to monitor our
    Hystrix commands in distributed environments.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被介绍了一些用于监控微服务环境的工具。我们学习了如何使用 Turbine 服务器在分布式环境中帮助我们监控 Hystrix 命令。
- en: We were also introduced to the Hystrix Dashboard feature, which helps the developers
    and operations guys provide a rich dashboard with the commands statistics in near
    real time.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了 Hystrix 仪表板功能，它帮助开发者和运维人员提供一个包含命令统计信息的丰富仪表板，这些统计信息几乎可以实时提供。
- en: We learned how Spring Cloud Security enables security features for our microservices,
    and we implemented the OAuth 2 server, using JWT to enable resilience for our
    security layer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 Spring Cloud Security 为我们的微服务启用安全功能，并实现了 OAuth 2 服务器，使用 JWT 为我们的安全层提供弹性。
