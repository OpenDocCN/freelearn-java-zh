["```java\npublic interface PriorityQueue<E> {\n    E checkMinimum();\n    E dequeueMinimum();\n    void enqueue(E value);\n}\n```", "```java\n2h-1 ≤ n ≤ 2h –1\n=>  h-1 ≤ lg n ≤ lg(2h –1) <lg( 2h)\n=> h-1 ≤ lg n < h\n```", "```java\n2h-1 ≤ n ≤ 2h –1\n=> 2h≤ n ≤ 2h+1 –1\n=>h ≤ lg (2n)< h+1\n```", "```java\nlg n < h ≤ lg (2n)\n=> h = θ(lg n)\n```", "```java\npublic class ArrayHeap<E> implements PriorityQueue<E>{\n\n    protected E[] store;\n\n    protected Comparator<E> comparator;\n    int numElements = 0;\n    public ArrayHeap(int size, Comparator<E> comparator){\n        store = (E[]) new Object[size];\n        this.comparator = comparator;\n}\n```", "```java\n    protected int parentIndex(int nodeIndex){\n        return ((nodeIndex+1)/2)-1;\n    }\n```", "```java\n    protected int leftChildIndex(int nodeIndex){\n        return (nodeIndex+1)*2 -1;\n    }\n```", "```java\n    protected void swap(int index1, int index2){\n        E temp = store[index1];\n        store[index1] = store[index2];\n        store[index2] = temp;\n    }\n    …\n}\n```", "```java\n    protected void trickleUp(int position){\n        int parentIndex = parentIndex(position);\n\n        if(position> 0 && comparator.compare(store[parentIndex], store[position])>0){\n            swap(position, parentIndex);\n            trickleUp(parentIndex);\n        }\n    }\n```", "```java\n    public void insert(E value){\n        if(numElements == store.length){\n            throw new NoSpaceException(\"Insertion in a full heap\");\n        }\n        store[numElements] = value;\n        numElements++;\n        trickleUp(numElements-1);\n    }\n```", "```java\n    protected void trickleDown(int position){\n        int leftChild = leftChildIndex(position);\n        int rightChild = leftChild+1;\n        if(rightChild<numElements) {\n            if (comparator.compare(store[leftChild], store[rightChild]) < 0) {\n                if (comparator.compare(store[leftChild], store[position]) < 0) {\n                    swap(position, leftChild);\n                    trickleDown(leftChild);\n                }\n            } else {\n                if (comparator.compare(store[rightChild], store[position]) < 0) {\n                    swap(position, rightChild);\n                    trickleDown(rightChild);\n                }\n            }\n        }else if(leftChild<numElements){\n            if (comparator.compare(store[leftChild], store[position]) < 0) {\n                  swap(position, leftChild);\n                  trickleDown(leftChild);\n            }\n        }\n    }\n```", "```java\n    public E removeMin(){\n        if(numElements==0){\n            return null;\n        }else{\n            E value  = store[0];\n            store[0] = store[numElements-1];\n            numElements--;\n            trickleDown(0);\n            return value;\n        }\n    }\n```", "```java\n@Override\npublic E checkMinimum() {\nif(numElements==0){\nreturn null;\n}else{\nreturn store[0];\n}\n}\n\n    @Override\n    public E dequeueMinimum() {\n        return removeMin();\n    }\n\n    @Override\n    public void enqueue(E value) {\n        insert(value);\n    }\n```", "```java\npublic class LinkedHeap<E> implements PriorityQueue<E>{\n\n    protected static class Node<E>{\n        protected E value;\n        protected Node<E> left;\n        protected Node<E> right;\n        protected Node<E> parent;\n        public Node(E value, Node<E> parent){\n            this.value = value;\n            this.parent = parent;\n        }\n    }\n    …\n}\n```", "```java\n    protected Node<E> findNodeAtPostion(int position){\n        if(position == 1){\n            return root;\n        }else{\n            int side = position % 2;\n            int parentPosition = position / 2;\n            Node<E> parent = findNodeAtPostion(parentPosition);\n            switch (side){\n                case 0:\n                    return parent.left;\n                case 1:\n                    return parent.right;\n            }\n        }\n        return null;\n    }\n```", "```java\n    protected void swapWithParent(Node<E> parent, boolean left){\n        Node<E> node = left? parent.left:parent.right;\n        Node<E> leftChild = node.left;\n        Node<E> rightChild = node.right;\n        Node<E> sibling = left? parent.right:parent.left;\n        Node<E> grandParent = parent.parent;\n        parent.left = leftChild;\n        if(leftChild!=null){\n            leftChild.parent = parent;\n        }\n        parent.right = rightChild;\n        if(rightChild!=null){\n            rightChild.parent = parent;\n        }\n        parent.parent = node;\n        if(left){\n            node.right = sibling;\n            node.left = parent;\n        }else{\n            node.left = sibling;\n            node.right = parent;\n        }\n        node.parent = grandParent;\n        if(sibling!=null)\n            sibling.parent = node;\n\n        if(parent == root){\n            root = node;\n        }else{\n            boolean parentLeft = grandParent.left==parent;\n            if(parentLeft){\n                grandParent.left = node;\n            }else{\n                grandParent.right = node;\n            }\n        }\n    }\n```", "```java\nprotected void trickleUp(Node<E> node){\n    if(node==root){\n        return;\n    }else if(comparator.compare(node.value, node.parent.value)<0){\n        swapWithParent(node.parent, node.parent.left == node);\n        trickleUp(node);\n    }\n}\n```", "```java\n    public void insert(E value){\n        if(root==null){\n            root = new Node<>(value, null);\n        }else{\n            Node<E> parent = findNodeAtPostion((numElements+1)/2);\n            int side = (numElements+1)%2;\n            Node<E> newNode = new Node<>(value, parent);\n            switch (side){\n                case 0:\n                    parent.left = newNode;\n                    break;\n                case 1:\n                    parent.right = newNode;\n                    break;\n            }\n            trickleUp(newNode);\n        }\n        numElements++;\n    }\n```", "```java\n    protected void trickleDown(Node<E> node){\n        if(node==null){\n            return;\n        }\n        if(node.left == null){\n            return;\n        }else if(node.right == null){\n            if(comparator.compare(node.left.value, node.value)<0){\n                swapWithParent(node, true);\n                trickleDown(node);\n            }\n        }else{\n            if(comparator.compare(node.left.value, node.right.value)<0){\n                if(comparator.compare(node.left.value, node.value)<0){\n                    swapWithParent(node, true);\n                    trickleDown(node);\n                }\n            }else{\n                if(comparator.compare(node.right.value, node.value)<0){\n                    swapWithParent(node, false);\n                    trickleDown(node);\n                }\n            }\n        }\n\n    }\n```", "```java\n    public E removeMin(){\n        if(root==null){\n            return null;\n        }\n        Node<E> lastElement = findNodeAtPostion(numElements);\n        if(lastElement==root){\n            root = null;\n            numElements--;\n            return lastElement.value;\n        }\n        E value = root.value;\n        root.value = lastElement.value;\n        Node<E> parent = lastElement.parent;\n        if(parent.left==lastElement){\n            parent.left = null;\n        }else{\n            parent.right=null;\n        }\n        numElements--;\n        trickleDown(root);\n        return value;\n    }\n```", "```java\n    @Override\n    public E checkMinimum() {\n        return root==null? null : root.value;\n    }\n\n    @Override\n    public E dequeueMinimum() {\n        return removeMin();\n    }\n\n    @Override\n    public void enqueue(E value) {\n        insert(value);\n    }\n```", "```java\npublic class BinomialForest<E> implements PriorityQueue<E>{\n\n    protected Comparator<E> comparator;\n    protected static class BinomialTree<E>{\n        E value;\n        LinkedList<BinomialTree<E>> subTrees = new LinkedList<>();\n        public BinomialTree(E value){\n            this.value = value;\n        }\n    }\n\n    public BinomialForest(Comparator<E> comparator){\n        this.comparator = comparator;\n    }\n\n    DoublyLinkedList<BinomialTree<E>> allTrees = new DoublyLinkedList<>();\n    …\n}\n```", "```java\n    protected BinomialTree<E> merge(BinomialTree<E> left, \n      BinomialTree<E> right){\n\n        if(left==null){\n            return right;\n        }else if(right==null){\n            return left;\n        }\n        if(left.subTrees.getLength() != right.subTrees.getLength()){\n            throw new IllegalArgumentException(\n                  \"Trying to merge two unequal trees of sizes \" +\n                    left.subTrees.getLength() + \" and \" + right.subTrees.getLength());\n        }\n        if(comparator.compare(left.value, right.value)<0){\n            left.subTrees.appendLast(right);\n            return left;\n        }else{\n            right.subTrees.appendLast(left);\n            return right;\n        }\n    }\n```", "```java\n    BinomialTree<E> minTree = null;\n    int minTreeIndex = -1;\n```", "```java\n    protected void updateMinTree(){\n        if(allTrees.getLength()==0){\n            minTree = null;\n            minTreeIndex = -1;\n        }\n        E min = null;\n        int index = 0;\n        for(BinomialTree<E> tree:allTrees){\n            if(tree==null){\n                index++;\n                continue;\n            }\n            if(min == null || comparator.compare(min, tree.value)>0){\n                min = tree.value;\n                minTree = tree;\n                minTreeIndex = index;\n            }\n            index++;\n        }\n    }\n```", "```java\n    protected BinomialTree<E> computeOutputWithoutCarry(BinomialTree<E> lhs, BinomialTree<E> rhs, BinomialTree<E> carry){\n        if(carry==null){\n            if(lhs==null){\n                return rhs;\n            }else if(rhs==null){\n                return lhs;\n            }else{\n                return null;\n            }\n        }else{\n            if(lhs==null && rhs==null){\n                return carry;\n            }else if(lhs == null){\n                return null;\n            }else if(rhs == null){\n                return null;\n            }else{\n                return carry;\n            }\n        }\n    }\n    protected BinomialTree<E>  computeCarry(\n      BinomialTree<E> lhs, BinomialTree<E> rhs, BinomialTree<E> carry){\n        if(carry==null){\n            if(lhs!=null && rhs!=null){\n                return merge(lhs, rhs);\n            }else{\n                return null;\n            }\n        }else{\n            if(lhs==null && rhs==null){\n                return null;\n            }else if(lhs == null){\n                return merge(carry, rhs);\n            }else if(rhs == null){\n                return merge(carry, lhs);\n            }else{\n                return merge(lhs, rhs);\n            }\n        }\n    }\n```", "```java\n    public class ListIterator implements Iterator<E> {\n        protected Node<E> nextNode = first;\n        protected Node<E> currentNode = null;\n        protected Node<E> prevNode = null;\n\n        @Override\n        public boolean hasNext() {\n            return nextNode != null;\n        }\n\n        @Override\n        public E next() {\n            if (!hasNext()) {\n                throw new IllegalStateException();\n            }\n            prevNode = currentNode;\n            currentNode = nextNode;\n            nextNode = nextNode.next;\n            return currentNode.value;\n        }\n\n        @Override\n        public void remove() {\n            if(currentNode==null || currentNode == prevNode){\n                throw new IllegalStateException();\n            }\n            if(currentNode==first){\n                first = nextNode;\n            }else{\n                prevNode.next = nextNode;\n            }\n            currentNode=prevNode;\n\n        }\n\n        public void setValue(E value){\n            currentNode.value = value;\n        }\n\n    }\n```", "```java\n    protected void merge(LinkedList<BinomialTree<E>> rhs){\n        LinkedList<BinomialTree<E>>.ListIterator lhsIter\n          = (LinkedList<BinomialTree<E>>.ListIterator)allTrees.iterator();\n        Iterator<BinomialTree<E>> rhsIter = rhs.iterator();\n        BinomialTree<E> carry = null;\n        while(lhsIter.hasNext() || rhsIter.hasNext()){\n            boolean lhsHasValue = lhsIter.hasNext();\n            BinomialTree<E> lhsTree = lhsHasValue? lhsIter.next():null;\n            BinomialTree<E> rhsTree = rhsIter.hasNext()? rhsIter.next():null;\n            BinomialTree<E> entry = computeOutputWithoutCarry(lhsTree, rhsTree, carry);\n            carry = computeCarry(lhsTree, rhsTree, carry);\n            if(lhsHasValue) {\n                lhsIter.setValue(entry);\n            }else{\n                this.allTrees.appendLast(entry);\n            }\n        }\n        if(carry!=null){\n            this.allTrees.appendLast(carry);\n        }\n        updateMinTree();\n    }\n```", "```java\n    public void insert(E value){\n        BinomialTree<E> newTree = new BinomialTree<E>(value);\n        DoublyLinkedList<BinomialTree<E>> newList \n               = new DoublyLinkedList<>();\n        newList.appendLast(newTree);\n        merge(newList);\n    }\n```", "```java\n    public E removeMin(){\n        if(allTrees.getLength()==0){\n            return null;\n        }\n        E min = minTree.value;\n        if(minTreeIndex==allTrees.getLength()-1){\n            allTrees.removeLast();\n        }else {\n            allTrees.setValueAtIndex(minTreeIndex, null);\n        }\n        merge(minTree.subTrees);\n        return min;\n    }\n```", "```java\n    @Override\n    public E dequeueMinimum() {\n        return removeMin();\n    }\n\n    @Override\n    public void enqueue(E value) {\n        insert(value);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return null;\n    }\n```", "```java\npublic void sort(Comparator<E> comparator){\n    PriorityQueue<E> priorityQueue = new LinkedHeap<E>(comparator);\n\n    while (first!=null){\n        priorityQueue.enqueue(getFirst());\n        removeFirst();\n    }\n\n    while (priorityQueue.checkMinimum()!=null){\n        appendLast(priorityQueue.dequeueMinimum());\n    }\n}\n```", "```java\npublic static <E> void heapSort(E[] array, Comparator<E> comparator){\n\n    ArrayHeap<E> arrayHeap = new ArrayHeap<E>(0, (a,b) -> comparator.compare(b,a));\n\n    arrayHeap.store = array;\n\n    for(int i=0;i<array.length;i++){\n        arrayHeap.insert(array[i]);\n    }\n\n    for(int i=array.length-1;i>=0;i--){\n        array[i] = arrayHeap.removeMin();\n    }\n}\n```"]