- en: Chapter 6. Components and Endpoints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have seen how to implement mediation logic and
    routing using processors or beans. However, both expect an incoming Exchange.
    It's one of the key purposes of the components and endpoints—a component creates
    endpoints. We have two kinds of endpoints—the producer responsible for creating
    Exchanges and the consumer who consumes incoming Exchanges.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The components and endpoints are responsible for:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the external systems and Exchanges
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing and handling specific data formats or transformation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand these concepts, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: What are components and endpoints?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing components and how to use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create our own component and endpoints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components are the main Camel extension point. Basically, a component is
    a factory of endpoints that you use in routes. If you take a look in the `Component`
    interface, you can see the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see that a `Component` *lives* in the `CamelContext` (as it extends
    the `CamelContextAware` interface). This means that we instantiate a `Component`
    and add the instance in the `CamelContext`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The `Component` is stored in the `CamelContext` using a unique identifier—the
    `scheme`. Later in the chapter, we will see that this schema is used to refer
    the `Component` in the route definition.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a component
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A component can be bootstrapped in two ways.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The first way is to explicitly instantiate the `Component`. You can do that
    using code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can explicitly instantiate the `MockComponent` and add it
    in the `CamelContext` using two schemes (the expected one `mock`, and a custom
    one `my`):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second way is implicit. Camel provides a discovery mechanism that can leverage
    `classloader` or the IoC framework (such as Spring). Camel is searching for a
    file like this in `classloader`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`/META-INF/services/org/apache/camel/component/my`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The `my` path is the component scheme name. The file contains the actual class
    with the component implementation. For instance:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If Camel finds the class property, it instantiates the component and adds it
    in the `CamelContext`. For instance, just creating the component `bean` using
    `blueprint` (or Spring) is enough for Camel to discover a load in the context:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When used in an OSGi environment (such as in the Karaf OSGi container), Camel
    also looks for the components using OSGi services. This means that, in OSGi, a
    component exposes an OSGi service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, Camel provides more than 150 ready-to-use components:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Some components are directly provided by `camel-core` (the low-level Camel library).
    For instance, `file`, `mock`, `bean`, `properties`, `direct`, `direct-vm`, `seda`,
    `vm`, `rest`, `ref`, `timer`, `xslt`, `controlbus`, `language`, and `log` components
    are directly provided (no need to install additional components).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ahc` allows you to communicate with a HTTP service using the Async HTTP
    Client library from Sonatype.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ahc-ws` allows you to communicate with a WebSocket service using the
    Async Http Client library from Sonatype.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-amqp` allows you to use the AMQP messaging protocol.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-apns` allows you to send notifications on Apple iOS devices.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-atmosphere-websocket` allows you to communicate with a WebSocket service
    using the Atmosphere library.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-atom` allows you to work with Atom feed (internally, using the Apache
    Abdera library).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-avro` allows you to use Apache Avro to serialize data and messages.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-aws` allows you to use the Amazon WebService service.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-beanstalk` allows you to use the Amazon Beanstalk service.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-bean-validator` allows you to validate message payload using the Java
    Validation API (JSR-303 or JAXP Validation and the corresponding Hibernate Validator
    implementation).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-box` allows you to manage files located on a [https://www.box.com/](https://www.box.com/)
    account.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cache` allows you to use the caching mechanism in Camel route.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-chunk` allows you to create a message using the Chunk template.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cmis` allows you to use the Apache Chemistry Client API with CMIS.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cometd` allows you to deliver messages using the `bayeux` protocol (using
    the Jetty cometd implementation).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-couchdb` allows you to interact with the Apache CouchDB database.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-crypto` allows you to sign and verify message payload using Java Cryptographic
    Extensions.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cxf` allows you to use SOAP and REST web services using Apache CXF.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-dns` allows you to manipulate DNS using DNSJava.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-disruptor` allows you to use a SEDA-like component (an asynchronous
    queue) using the disruptor library.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-docker` allows you to deal with `docker.io`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-dropbox` allows you to manipulate files located on a Dropbox account.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ejb` allows you to use EJB3 as regular beans in route definition.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-elasticsearch` allows you to interact with an Elasticsearch database.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-spring` allows you to integrate a Spring application in a route.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-eventadmin` allows you to interact with the OSGi EventAdmin Layer.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-exec` allows you to execute system commands from a route.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-facebook` allows you to interface with the Facebook APIs (using the
    `facebook4j` library).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-flatpack` allows you to use the Flatpack library to deal with fixed
    width and delimited files.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-fop` allows you to render messages (in different formats such as PDF)
    using Apache FOP.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-freemarker` allows you to create messages using the FreeMarker template.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ftp` allows you to consume or send files via an FTP server.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-gae` allows you to interact with the Google App Engine service.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-google-calendar` allows you to interact with Google Calendar (using
    the REST API).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-google-drive` allows you to retrieve or upload files on Google Drive
    (via the REST API).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-google-mail` allows you to retrieve or send e-mails through Gmail (using
    the REST API).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-gora` allows you to access the NoSQL databases using the Apache Gora
    library.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-geocoder` allows you to `lookup` addresses using the geolocalization.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-github` allows you to interface with GitHub.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hazelcast` allows you to use a Hazelcast distributed queue (such as
    SEDA).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hbase` allows you to interact with the Apache HBase database.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hdfs` allows you to interact with Apache Hadoop Distributed File System
    (HDFS).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hl7` allows you to deal with the HL7 MLLP protocol.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-infinispan` allows you to read and write distributed key/value pairs
    on Infinispan.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-http` allows you to interact with the HTTP service using the Apache
    HTTP Client.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ibatis` allows you to query, insert, and update using the Apache iBatis
    database framework.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mail` allows you to retrieve (using imap or pop) or send e-mails.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-irc` allows you to interact with IRC servers and channels.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-javaspace` allows you to receive or send messages using JavaSpace.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jclouds` allows you to interact with jclouds for cloud computing and
    Blobstore.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jcr` allows you to use a Content Management system such as Apache Jackrabbit.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jdbc` allows you to perform database queries using JDBC.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jetty` allows you to expose or use a HTTP service using the Jetty library
    and server.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jgroups` allows you to interact with JGroups clusters.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jira` allows you to interact with the JIRA bug tracker.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jms` allows you to consume or produce messages from JMS queues or topics
    using a broker (such as Apache ActiveMQ or IBM MQ).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jmx` allows you to work with JMX notifications.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jpa` allows you to use a JPA framework (such as Hibernate or Apache
    OpenJPA) to interact with a database.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jsch` allows you to use the Session Control Protocol (SCP) to download
    or upload files.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jt400` allows you to use data queues from AS/400 systems (System i,
    IBM i, i5, and so on).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-kafka` allows you to consume or produce messages on the Apache Kafka
    messages broker.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-kestrel` allows you to consume or produce messages on the Kestrel queues.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-krati` allows you to interface with a Krati data store.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ldap` allows you to query LDAP directories.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-linkedin` allows you to interact with the LinkedIn site (using the REST
    API).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-lucene` allows you to use the Apache Lucene search queries.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-metrics` allows you to use the Metrics library to collect activity metrics.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mina` allows you to use the Apache MINA library to interact with different
    network protocols (such as Telnet and so on).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mongodb` allows you to use MongoDB.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mqtt` allows you to consume or produce messages through MQTT M2M brokers.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-msv` allows you to validate message payload using the MSV library.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mustache` allows you to create or render a message using the Mustache
    template.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mvel` allows you to create or render a message using the MVEL template.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mybatis` allows you to interface with a database using the MyBatis library.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-nagios` allows you to send checks to Nagios (using the JSendNCSA library).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-netty` allows you to use TCP/UDP protocols using Java NIO (using the
    Netty library).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-olingo` allows you to communicate with OData 2.0 services using the
    Apache Olingo library.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-openshift` allows you to interact with Openshift applications.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-optaplanner` allows you to solve planning problems described in a message
    using the OptaPlanner library.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-paxlogging` allows you to receive log messages coming from Pax Logging
    (the logging framework used in Apache Karaf).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-printer` allows you to interface with printers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-quartz` provides advanced trigger endpoints (such as the timer one)
    using the Quartz library.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-quickfix` allows you to receive and produce FIX messages using QuickFIX
    for the Java library.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-rabbitmq` allows you to consume and produce messages with the RabbitMQ
    broker.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-restlet` allows you to expose REST services using the RESTlet library.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-rmi` allows you to use the Java RMI service.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jing` allows you to validate message payload using the RelaxNG compact
    syntax.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-rss` allows you to consume RSS feed (using the ROME library).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-salesforce` allows you to interact with Salesforce.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-sap-netweaver` allows you to interact with the SAP NetWeaver gateway.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-schematron` allows you to validate messages containing the XML document.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-sip` allows you to publish or subscribe using the Telecom SIP protocol.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-smpp` allows you to receive or send SMS messages using the JSMPP library.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-snmp` allows you to receive SNMP events using the SNMP4J library.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-solr` allows you to use an Apache Lucene Solr server via the Solrj API.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-spark-rest` allows you to easily create REST services.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-splunk` allows you to interact with applications hosted on Splunk.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-sql` allows you to perform SQL queries using JDBC.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ssh` allows you to send commands to a SSH server.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-stax` allows you to process XML messages using SAX ContentHandler.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-stream` allows you to interact with standard input, output, and error
    streams.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-stomp` allows you to interact with a broker-supported STOMP protocol
    (such as Apache ActiveMQ).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-twitter` allows you to interact with the Twitter service.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-velocity` allows you to create/render messages using the Velocity template.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-vertx` allows you to interact with Vertx Event Bus.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-weather` allows you to retrieve weather information from Open Weather
    Map.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-websocket` allows you to communicate with WebSocket clients.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-xmlsecurity` allows you to sign and verify message payload using the
    XML signature specification.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-xmpp` allows you to work with the XMPP protocol, allowing you to work
    with instant messaging like Jabber.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-saxon` allows you to use XQuery on message payload (using Saxon).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-yammer` allows you to interact with the Yammer enterprise social network.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camel-yammer`允许您与Yammer企业社交网络交互。'
- en: '`camel-zookeeper` allows you to interface with the Apache Zookeeper server.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camel-zookeeper`允许您与Apache Zookeeper服务器接口。'
- en: 'The updated and complete list of Camel components is available online: [http://camel.apache.org/components.html](http://camel.apache.org/components.html).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Camel组件的更新和完整列表可在网上找到：[http://camel.apache.org/components.html](http://camel.apache.org/components.html)。
- en: Endpoint
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点
- en: As we saw in the `Component` interface, the main function of a `Component` is
    to create an `Endpoint`. This is the purpose of the `createEndpoint()` method.
    This method returns an `Endpoint`. You don't explicitly call this method. The
    Camel routing engine calls this method for you.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`Component`接口中看到的，`Component`的主要功能是创建一个`Endpoint`。这是`createEndpoint()`方法的目的。此方法返回一个`Endpoint`。您不需要显式调用此方法。Camel路由引擎为您调用此方法。
- en: 'When, in a route definition, you use the following syntax:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当在路由定义中使用以下语法时：
- en: '[PRE4]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: During route bootstrap, the Routing Engine is looking for the my component in
    the `CamelContext` (loaded as explained before).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由引导过程中，路由引擎正在`CamelContext`中寻找我的组件（如前所述加载）。
- en: If the component is not found, we will have a no component found for scheme
    my message (wrapped in a `CamelRuntimeException`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到组件，我们将有一个没有找到针对方案my的消息的组件（封装在`CamelRuntimeException`中）。
- en: If the component is found, the routing engine instantiates the endpoint using
    the `createEndpoint()` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到组件，路由引擎将使用`createEndpoint()`方法实例化端点。
- en: 'Let''s take a look at the `Endpoint` interface:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Endpoint`接口：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this `Endpoint` interface snippet, we can note the following points:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Endpoint`接口片段中，我们可以注意以下要点：
- en: We can retrieve the endpoint URI using the `getEndpointUri()` method
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`getEndpointUri()`方法检索端点URI
- en: We can retrieve the endpoint configuration using the `getEndpointConfiguration()`
    method
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`getEndpointConfiguration()`方法检索端点配置
- en: The most important point is that we have different kinds of endpoints. Depending
    on the location of the endpoint in the route definition, Camel creates different
    kinds of endpoints.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们有不同类型的端点。根据端点在路由定义中的位置，Camel创建不同类型的端点。
- en: 'If the endpoint is defined in a `to`, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端点在`to`中定义，如下所示：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Camel routing engine calls the `createProducer()` method. The endpoint will
    act as a producer, meaning that the Exchange will be transformed into an external
    format and sent *outside* of the Camel route.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Camel路由引擎调用`createProducer()`方法。端点将充当生产者，这意味着交换将被转换为外部格式并发送到Camel路由之外。
- en: 'If the endpoint is defined in a `from`, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端点在`from`中定义，如下所示：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Camel routing engine calls the `createConsumer()` or `createPollingConsumer()`
    method (depending on the one provided by the endpoint).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Camel路由引擎调用`createConsumer()`或`createPollingConsumer()`方法（取决于端点提供的那个）。
- en: 'We distinguish two kinds of consumers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们区分两种消费者类型：
- en: An Event-Driven Consumer (created by the `createConsumer()` method) is an Enterprise
    Integration Pattern. Basically, it means that the endpoint acts as a server; it
    waits for incoming events or messages and instantiates an Exchange for each event.
    For instance, CXF, Restlet, and Jetty consumer endpoints are event driven. Camel
    uses a thread pool—each event is processed in its own thread.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动消费者（由`createConsumer()`方法创建）是一种企业集成模式。基本上，这意味着端点充当服务器；它等待传入的事件或消息，并为每个事件实例化一个交换。例如，CXF、Restlet和Jetty消费者端点是事件驱动的。Camel使用线程池——每个事件都在自己的线程中处理。
- en: On the other hand, a Polling Consumer (created by the `createPollingConsumer()`
    method) is also an Enterprise Integration Pattern. Basically, the endpoint periodically
    checks for a resource and instantiates an Exchange for each new resource. For
    instance, file, FTP, IMAP consumer endpoints are polling consumers.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，轮询消费者（由`createPollingConsumer()`方法创建）也是一种企业集成模式。基本上，端点定期检查资源，并为每个新资源实例化一个交换。例如，文件、FTP、IMAP消费者端点是轮询消费者。
- en: We can also design a third kind of consumer, on-demand. Basically, instead of
    periodically polling a resource, we want to trigger the polling on demand. For
    instance, we want to consume a file from the filesystem when we receive an HTTP
    request.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设计第三种消费者类型，按需。基本上，我们不是定期轮询资源，而是希望在需要时触发轮询。例如，当我们收到HTTP请求时，我们希望从文件系统中消费文件。
- en: 'To do so, we start our Karaf container:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们启动我们的Karaf容器：
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We install the camel-blueprint and camel-jetty features in Karaf, using the
    following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The camel-jetty feature provides the camel-jetty component that we will use
    in our route.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Karaf deploy` folder, we create the following `route.xml` Camel Blueprint
    route definition file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This route creates a Jetty event-driven consumer, waiting for incoming HTTP
    requests. We use the content enricher EIP through the `pollEnrich` syntax. It
    means that, when the Exchange is created by the Jetty endpoint, the Camel routing
    engine calls the file endpoint and populates the Exchange with the file consumed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this route, we create the following `test.txt` file in the `/tmp/in`
    folder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we just access the `http://localhost:8181/poll` URL with an Internet
    browser:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Endpoint](img/3151EN_06_01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'In the Karaf log, we can see the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The file endpoint has been called *on-demand* by the `pollEnrich` syntax.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: A custom component example
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if Camel provides a lot of ready-to-use components, you might want to create
    your own, for instance, to support a proprietary protocol.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: It's pretty easy to create our own Camel component.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a component named Packt implementing a simple
    socket communication.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the following Maven `pom.xml` file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this `pom.xml` file, we note the following points:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In terms of dependencies, we depend on `camel-core`, which provides the core
    interfaces and classes to implement components and endpoints. We also depend on
    `slf4j-api` just to be able to log messages.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the maven-bundle-plugin to create the OSGi service for our component.
    This is will allow us to easily deploy the component in an OSGi container like
    Apache Karaf, and leverage the Camel OSGi service discovery. For that, we export
    the `org.apache.camel.spi.ComponentResolver` service with the `Packt` scheme.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the component discovery using the OSGi service, we also create
    the `META-INF/services/org/apache/camel/component/packt` file containing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The class property contains the full qualified name of the `component` class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, we have to create the `PacktComponent` class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our component is pretty simple—it extends the Camel `DefaultComponent`. We just
    override the `createEndpoint()` method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'This method creates `PacktEndpoint`. So, we have to create this `PacktEndpoint`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our `PacktEndpoint` is the actual endpoint factory. In our component, we want
    to be able to create two kinds of endpoints:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The `createProducer()` method creates a `PacktProducer` producer that we can
    use in a route definition with the `to` syntax.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createConsumer()` method creates a `PacktConsumer` event-driven consumer,
    that we can use in a route definition with the `from` syntax.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with `PacktConsumer`. `PacktConsumer` extends Camel `DefaultConsumer`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The `PacktConsumer` creates a server socket at startup. At startup, it also
    creates a new thread to listen for incoming client connection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: For each incoming connection (meaning a client socket connection), we create
    an `InOut` Exchange that we send to the next processor in the route definition.
    To do so, we create a Camel `DefaultExchange` using the `PacktEndpoint` and `InOut`
    exchange pattern.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个传入连接（意味着客户端套接字连接），我们创建一个`InOut`交换，并将其发送到路由定义中的下一个处理器。为此，我们使用`PacktEndpoint`和`InOut`交换模式创建一个Camel
    `DefaultExchange`。
- en: The next processor is provided by the Camel routing engine (via `getProcessor()`
    method).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个处理器由Camel路由引擎提供（通过`getProcessor()`方法）。
- en: As we use an `InOut` Message Exchange Pattern, once forwarded to the next hop
    we are using the out message (and fallback to the `in` message) to reply to the
    client.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`InOut`消息交换模式，一旦转发到下一个跳转点，我们就使用输出消息（并回退到输入消息）来回复客户端。
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our event driven consumer is now ready. We now implement `PacktProducer`, which
    extends Camel `DefaultProducer`. A producer is pretty simple, it just overrides
    the `process()` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件驱动消费者现在已准备好。我们现在实现`PacktProducer`，它扩展了Camel `DefaultProducer`。生产者相当简单，它只是重写了`process()`方法。
- en: The `process()` method has only one argument—the Camel Exchange.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()`方法只有一个参数——Camel交换。'
- en: As it's a producer, the Exchange comes from a previous processor or from an
    endpoint. Thanks to the Exchange, we have access to the `in` message.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个生产者，交换来自前一个处理器或端点。多亏了交换，我们能够访问输入消息。
- en: 'The following is what we do in the processor:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在处理器中我们执行的操作：
- en: We get the body of the `in` message (thanks to the Exchange).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取输入消息的主体（多亏了交换）。
- en: We create a connection to the server socket, and we send the `in` message body
    to this socket.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个连接到服务器套接字，并将输入消息主体发送到该套接字。
- en: We are waiting for the socket server response. This `in` message body is overridden
    by the server response.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在等待套接字服务器响应。此输入消息主体被服务器响应覆盖。
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now build our component using Maven:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Maven构建我们的组件：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our component is now ready to be deployed in Apache Karaf.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件现在已准备好在Apache Karaf中部署。
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动Karaf并安装`camel-blueprint`功能：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now install our component:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安装我们的组件：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see that our component is now ready:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的组件现在已准备好：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we take a look at the OSGi services provided by our component, we can see
    the `Component` service:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的组件提供的OSGi服务，我们可以看到`Component`服务：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Camel will use this service to resolve the component associated to the Packt
    scheme. To test our component, we can create the following `route.xml` Blueprint:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Camel将使用此服务来解决与Packt方案关联的组件。为了测试我们的组件，我们可以创建以下`route.xml`蓝图：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The server route uses the Packt component to create a consumer endpoint while
    waiting for an incoming connection (`from` with `packt:server`).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器路由在等待传入连接（使用`packt:server`）时使用Packt组件创建消费者端点。
- en: We can now see the Packt scheme (defined in both the OSGi service and the META-INF
    service). We log the received message and return the received message prefixed
    by `Echo` (using the simple Camel language).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到Packt方案（在OSGi服务和META-INF服务中定义）。我们记录接收到的消息，并返回以`Echo`前缀的接收到的消息（使用简单的Camel语言）。
- en: On the other hand, the `client` `route` periodically creates an exchange (using
    timer), and we define a `chapter6b` as the body of the `in` message (using `setBody`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，客户端路由定期创建一个交换（使用定时器），我们将`chapter6b`定义为输入消息的主体（使用`setBody`）。
- en: 'This message is sent to the server socket bound by our `server route`, using
    the Packt component to create a producer endpoint (`to` with `packt:client`).
    To deploy these routes, we just drop the `route.xml` file into the `Karaf deploy`
    folder. In the log, we can see the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息发送到由我们的`server route`绑定的服务器套接字，使用Packt组件创建生产者端点（使用`to`与`packt:client`）。为了部署这些路由，我们只需将`route.xml`文件放入`Karaf
    deploy`文件夹。在日志中，我们可以看到以下代码：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can note that:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到：
- en: The server route has been called by the client route
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器路由已被客户端路由调用
- en: The consumer prefixed the message body (with `Echo`) as defined in the simple
    expression
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者将消息主体（使用`Echo`）前缀定义为简单表达式。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the previous chapters, we used beans (POJO) and processors to implement mediation
    logic and act as a producer. However, to implement and simplify support of some
    protocols, systems, data transformations, and so on, Camel components are very
    convenient and provide easy extension points, which are ready to use in Camel
    route. This allows you to decouple implementation of the connectivity from the
    mediation logic.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们使用了豆子（POJO）和处理器来实现中介逻辑并充当生产者。然而，为了实现和简化对某些协议、系统、数据转换等的支持，Camel组件非常方便，并提供易于扩展的点，这些点在Camel路由中即可使用。这允许您将连接性的实现与中介逻辑解耦。
- en: Utilizing a combination of components (provided or custom), processors, beans,
    and route definitions provides a complete and powerful mediation framework. However,
    integration and mediation requires us to address a new challenge—how to handle
    and process errors that can happen in the mediation. This is what we will see
    in the next chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 利用组件（提供的或自定义的）、处理器、豆子和路由定义的组合提供了一个完整且强大的中介框架。然而，集成和中介要求我们面对一个新的挑战——如何在中介过程中处理和错误处理。这就是我们将在下一章中看到的内容。
