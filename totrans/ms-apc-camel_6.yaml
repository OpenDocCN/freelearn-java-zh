- en: Chapter 6. Components and Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have seen how to implement mediation logic and
    routing using processors or beans. However, both expect an incoming Exchange.
    It's one of the key purposes of the components and endpoints—a component creates
    endpoints. We have two kinds of endpoints—the producer responsible for creating
    Exchanges and the consumer who consumes incoming Exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The components and endpoints are responsible for:'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the external systems and Exchanges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing and handling specific data formats or transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand these concepts, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are components and endpoints?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing components and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create our own component and endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components are the main Camel extension point. Basically, a component is
    a factory of endpoints that you use in routes. If you take a look in the `Component`
    interface, you can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see that a `Component` *lives* in the `CamelContext` (as it extends
    the `CamelContextAware` interface). This means that we instantiate a `Component`
    and add the instance in the `CamelContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Component` is stored in the `CamelContext` using a unique identifier—the
    `scheme`. Later in the chapter, we will see that this schema is used to refer
    the `Component` in the route definition.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A component can be bootstrapped in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The first way is to explicitly instantiate the `Component`. You can do that
    using code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can explicitly instantiate the `MockComponent` and add it
    in the `CamelContext` using two schemes (the expected one `mock`, and a custom
    one `my`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is implicit. Camel provides a discovery mechanism that can leverage
    `classloader` or the IoC framework (such as Spring). Camel is searching for a
    file like this in `classloader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/META-INF/services/org/apache/camel/component/my`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `my` path is the component scheme name. The file contains the actual class
    with the component implementation. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If Camel finds the class property, it instantiates the component and adds it
    in the `CamelContext`. For instance, just creating the component `bean` using
    `blueprint` (or Spring) is enough for Camel to discover a load in the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When used in an OSGi environment (such as in the Karaf OSGi container), Camel
    also looks for the components using OSGi services. This means that, in OSGi, a
    component exposes an OSGi service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, Camel provides more than 150 ready-to-use components:'
  prefs: []
  type: TYPE_NORMAL
- en: Some components are directly provided by `camel-core` (the low-level Camel library).
    For instance, `file`, `mock`, `bean`, `properties`, `direct`, `direct-vm`, `seda`,
    `vm`, `rest`, `ref`, `timer`, `xslt`, `controlbus`, `language`, and `log` components
    are directly provided (no need to install additional components).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ahc` allows you to communicate with a HTTP service using the Async HTTP
    Client library from Sonatype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ahc-ws` allows you to communicate with a WebSocket service using the
    Async Http Client library from Sonatype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-amqp` allows you to use the AMQP messaging protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-apns` allows you to send notifications on Apple iOS devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-atmosphere-websocket` allows you to communicate with a WebSocket service
    using the Atmosphere library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-atom` allows you to work with Atom feed (internally, using the Apache
    Abdera library).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-avro` allows you to use Apache Avro to serialize data and messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-aws` allows you to use the Amazon WebService service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-beanstalk` allows you to use the Amazon Beanstalk service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-bean-validator` allows you to validate message payload using the Java
    Validation API (JSR-303 or JAXP Validation and the corresponding Hibernate Validator
    implementation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-box` allows you to manage files located on a [https://www.box.com/](https://www.box.com/)
    account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cache` allows you to use the caching mechanism in Camel route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-chunk` allows you to create a message using the Chunk template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cmis` allows you to use the Apache Chemistry Client API with CMIS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cometd` allows you to deliver messages using the `bayeux` protocol (using
    the Jetty cometd implementation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-couchdb` allows you to interact with the Apache CouchDB database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-crypto` allows you to sign and verify message payload using Java Cryptographic
    Extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-cxf` allows you to use SOAP and REST web services using Apache CXF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-dns` allows you to manipulate DNS using DNSJava.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-disruptor` allows you to use a SEDA-like component (an asynchronous
    queue) using the disruptor library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-docker` allows you to deal with `docker.io`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-dropbox` allows you to manipulate files located on a Dropbox account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ejb` allows you to use EJB3 as regular beans in route definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-elasticsearch` allows you to interact with an Elasticsearch database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-spring` allows you to integrate a Spring application in a route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-eventadmin` allows you to interact with the OSGi EventAdmin Layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-exec` allows you to execute system commands from a route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-facebook` allows you to interface with the Facebook APIs (using the
    `facebook4j` library).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-flatpack` allows you to use the Flatpack library to deal with fixed
    width and delimited files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-fop` allows you to render messages (in different formats such as PDF)
    using Apache FOP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-freemarker` allows you to create messages using the FreeMarker template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ftp` allows you to consume or send files via an FTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-gae` allows you to interact with the Google App Engine service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-google-calendar` allows you to interact with Google Calendar (using
    the REST API).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-google-drive` allows you to retrieve or upload files on Google Drive
    (via the REST API).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-google-mail` allows you to retrieve or send e-mails through Gmail (using
    the REST API).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-gora` allows you to access the NoSQL databases using the Apache Gora
    library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-geocoder` allows you to `lookup` addresses using the geolocalization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-github` allows you to interface with GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hazelcast` allows you to use a Hazelcast distributed queue (such as
    SEDA).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hbase` allows you to interact with the Apache HBase database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hdfs` allows you to interact with Apache Hadoop Distributed File System
    (HDFS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-hl7` allows you to deal with the HL7 MLLP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-infinispan` allows you to read and write distributed key/value pairs
    on Infinispan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-http` allows you to interact with the HTTP service using the Apache
    HTTP Client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ibatis` allows you to query, insert, and update using the Apache iBatis
    database framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mail` allows you to retrieve (using imap or pop) or send e-mails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-irc` allows you to interact with IRC servers and channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-javaspace` allows you to receive or send messages using JavaSpace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jclouds` allows you to interact with jclouds for cloud computing and
    Blobstore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jcr` allows you to use a Content Management system such as Apache Jackrabbit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jdbc` allows you to perform database queries using JDBC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jetty` allows you to expose or use a HTTP service using the Jetty library
    and server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jgroups` allows you to interact with JGroups clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jira` allows you to interact with the JIRA bug tracker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jms` allows you to consume or produce messages from JMS queues or topics
    using a broker (such as Apache ActiveMQ or IBM MQ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jmx` allows you to work with JMX notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jpa` allows you to use a JPA framework (such as Hibernate or Apache
    OpenJPA) to interact with a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jsch` allows you to use the Session Control Protocol (SCP) to download
    or upload files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jt400` allows you to use data queues from AS/400 systems (System i,
    IBM i, i5, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-kafka` allows you to consume or produce messages on the Apache Kafka
    messages broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-kestrel` allows you to consume or produce messages on the Kestrel queues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-krati` allows you to interface with a Krati data store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ldap` allows you to query LDAP directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-linkedin` allows you to interact with the LinkedIn site (using the REST
    API).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-lucene` allows you to use the Apache Lucene search queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-metrics` allows you to use the Metrics library to collect activity metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mina` allows you to use the Apache MINA library to interact with different
    network protocols (such as Telnet and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mongodb` allows you to use MongoDB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mqtt` allows you to consume or produce messages through MQTT M2M brokers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-msv` allows you to validate message payload using the MSV library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mustache` allows you to create or render a message using the Mustache
    template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mvel` allows you to create or render a message using the MVEL template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-mybatis` allows you to interface with a database using the MyBatis library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-nagios` allows you to send checks to Nagios (using the JSendNCSA library).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-netty` allows you to use TCP/UDP protocols using Java NIO (using the
    Netty library).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-olingo` allows you to communicate with OData 2.0 services using the
    Apache Olingo library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-openshift` allows you to interact with Openshift applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-optaplanner` allows you to solve planning problems described in a message
    using the OptaPlanner library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-paxlogging` allows you to receive log messages coming from Pax Logging
    (the logging framework used in Apache Karaf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-printer` allows you to interface with printers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-quartz` provides advanced trigger endpoints (such as the timer one)
    using the Quartz library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-quickfix` allows you to receive and produce FIX messages using QuickFIX
    for the Java library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-rabbitmq` allows you to consume and produce messages with the RabbitMQ
    broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-restlet` allows you to expose REST services using the RESTlet library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-rmi` allows you to use the Java RMI service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-jing` allows you to validate message payload using the RelaxNG compact
    syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-rss` allows you to consume RSS feed (using the ROME library).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-salesforce` allows you to interact with Salesforce.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-sap-netweaver` allows you to interact with the SAP NetWeaver gateway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-schematron` allows you to validate messages containing the XML document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-sip` allows you to publish or subscribe using the Telecom SIP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-smpp` allows you to receive or send SMS messages using the JSMPP library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-snmp` allows you to receive SNMP events using the SNMP4J library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-solr` allows you to use an Apache Lucene Solr server via the Solrj API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-spark-rest` allows you to easily create REST services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-splunk` allows you to interact with applications hosted on Splunk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-sql` allows you to perform SQL queries using JDBC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-ssh` allows you to send commands to a SSH server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-stax` allows you to process XML messages using SAX ContentHandler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-stream` allows you to interact with standard input, output, and error
    streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-stomp` allows you to interact with a broker-supported STOMP protocol
    (such as Apache ActiveMQ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-twitter` allows you to interact with the Twitter service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-velocity` allows you to create/render messages using the Velocity template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-vertx` allows you to interact with Vertx Event Bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-weather` allows you to retrieve weather information from Open Weather
    Map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-websocket` allows you to communicate with WebSocket clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-xmlsecurity` allows you to sign and verify message payload using the
    XML signature specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-xmpp` allows you to work with the XMPP protocol, allowing you to work
    with instant messaging like Jabber.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-saxon` allows you to use XQuery on message payload (using Saxon).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-yammer` allows you to interact with the Yammer enterprise social network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camel-zookeeper` allows you to interface with the Apache Zookeeper server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The updated and complete list of Camel components is available online: [http://camel.apache.org/components.html](http://camel.apache.org/components.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the `Component` interface, the main function of a `Component` is
    to create an `Endpoint`. This is the purpose of the `createEndpoint()` method.
    This method returns an `Endpoint`. You don't explicitly call this method. The
    Camel routing engine calls this method for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'When, in a route definition, you use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: During route bootstrap, the Routing Engine is looking for the my component in
    the `CamelContext` (loaded as explained before).
  prefs: []
  type: TYPE_NORMAL
- en: If the component is not found, we will have a no component found for scheme
    my message (wrapped in a `CamelRuntimeException`).
  prefs: []
  type: TYPE_NORMAL
- en: If the component is found, the routing engine instantiates the endpoint using
    the `createEndpoint()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Endpoint` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `Endpoint` interface snippet, we can note the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve the endpoint URI using the `getEndpointUri()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can retrieve the endpoint configuration using the `getEndpointConfiguration()`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important point is that we have different kinds of endpoints. Depending
    on the location of the endpoint in the route definition, Camel creates different
    kinds of endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the endpoint is defined in a `to`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Camel routing engine calls the `createProducer()` method. The endpoint will
    act as a producer, meaning that the Exchange will be transformed into an external
    format and sent *outside* of the Camel route.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the endpoint is defined in a `from`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Camel routing engine calls the `createConsumer()` or `createPollingConsumer()`
    method (depending on the one provided by the endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: 'We distinguish two kinds of consumers:'
  prefs: []
  type: TYPE_NORMAL
- en: An Event-Driven Consumer (created by the `createConsumer()` method) is an Enterprise
    Integration Pattern. Basically, it means that the endpoint acts as a server; it
    waits for incoming events or messages and instantiates an Exchange for each event.
    For instance, CXF, Restlet, and Jetty consumer endpoints are event driven. Camel
    uses a thread pool—each event is processed in its own thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, a Polling Consumer (created by the `createPollingConsumer()`
    method) is also an Enterprise Integration Pattern. Basically, the endpoint periodically
    checks for a resource and instantiates an Exchange for each new resource. For
    instance, file, FTP, IMAP consumer endpoints are polling consumers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also design a third kind of consumer, on-demand. Basically, instead of
    periodically polling a resource, we want to trigger the polling on demand. For
    instance, we want to consume a file from the filesystem when we receive an HTTP
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we start our Karaf container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We install the camel-blueprint and camel-jetty features in Karaf, using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The camel-jetty feature provides the camel-jetty component that we will use
    in our route.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Karaf deploy` folder, we create the following `route.xml` Camel Blueprint
    route definition file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This route creates a Jetty event-driven consumer, waiting for incoming HTTP
    requests. We use the content enricher EIP through the `pollEnrich` syntax. It
    means that, when the Exchange is created by the Jetty endpoint, the Camel routing
    engine calls the file endpoint and populates the Exchange with the file consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this route, we create the following `test.txt` file in the `/tmp/in`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we just access the `http://localhost:8181/poll` URL with an Internet
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Endpoint](img/3151EN_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Karaf log, we can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The file endpoint has been called *on-demand* by the `pollEnrich` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: A custom component example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if Camel provides a lot of ready-to-use components, you might want to create
    your own, for instance, to support a proprietary protocol.
  prefs: []
  type: TYPE_NORMAL
- en: It's pretty easy to create our own Camel component.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a component named Packt implementing a simple
    socket communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the following Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `pom.xml` file, we note the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of dependencies, we depend on `camel-core`, which provides the core
    interfaces and classes to implement components and endpoints. We also depend on
    `slf4j-api` just to be able to log messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the maven-bundle-plugin to create the OSGi service for our component.
    This is will allow us to easily deploy the component in an OSGi container like
    Apache Karaf, and leverage the Camel OSGi service discovery. For that, we export
    the `org.apache.camel.spi.ComponentResolver` service with the `Packt` scheme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the component discovery using the OSGi service, we also create
    the `META-INF/services/org/apache/camel/component/packt` file containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The class property contains the full qualified name of the `component` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, we have to create the `PacktComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our component is pretty simple—it extends the Camel `DefaultComponent`. We just
    override the `createEndpoint()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method creates `PacktEndpoint`. So, we have to create this `PacktEndpoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `PacktEndpoint` is the actual endpoint factory. In our component, we want
    to be able to create two kinds of endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: The `createProducer()` method creates a `PacktProducer` producer that we can
    use in a route definition with the `to` syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createConsumer()` method creates a `PacktConsumer` event-driven consumer,
    that we can use in a route definition with the `from` syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with `PacktConsumer`. `PacktConsumer` extends Camel `DefaultConsumer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PacktConsumer` creates a server socket at startup. At startup, it also
    creates a new thread to listen for incoming client connection.
  prefs: []
  type: TYPE_NORMAL
- en: For each incoming connection (meaning a client socket connection), we create
    an `InOut` Exchange that we send to the next processor in the route definition.
    To do so, we create a Camel `DefaultExchange` using the `PacktEndpoint` and `InOut`
    exchange pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The next processor is provided by the Camel routing engine (via `getProcessor()`
    method).
  prefs: []
  type: TYPE_NORMAL
- en: As we use an `InOut` Message Exchange Pattern, once forwarded to the next hop
    we are using the out message (and fallback to the `in` message) to reply to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our event driven consumer is now ready. We now implement `PacktProducer`, which
    extends Camel `DefaultProducer`. A producer is pretty simple, it just overrides
    the `process()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `process()` method has only one argument—the Camel Exchange.
  prefs: []
  type: TYPE_NORMAL
- en: As it's a producer, the Exchange comes from a previous processor or from an
    endpoint. Thanks to the Exchange, we have access to the `in` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what we do in the processor:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the body of the `in` message (thanks to the Exchange).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a connection to the server socket, and we send the `in` message body
    to this socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are waiting for the socket server response. This `in` message body is overridden
    by the server response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now build our component using Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our component is now ready to be deployed in Apache Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now install our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that our component is now ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the OSGi services provided by our component, we can see
    the `Component` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Camel will use this service to resolve the component associated to the Packt
    scheme. To test our component, we can create the following `route.xml` Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The server route uses the Packt component to create a consumer endpoint while
    waiting for an incoming connection (`from` with `packt:server`).
  prefs: []
  type: TYPE_NORMAL
- en: We can now see the Packt scheme (defined in both the OSGi service and the META-INF
    service). We log the received message and return the received message prefixed
    by `Echo` (using the simple Camel language).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `client` `route` periodically creates an exchange (using
    timer), and we define a `chapter6b` as the body of the `in` message (using `setBody`).
  prefs: []
  type: TYPE_NORMAL
- en: 'This message is sent to the server socket bound by our `server route`, using
    the Packt component to create a producer endpoint (`to` with `packt:client`).
    To deploy these routes, we just drop the `route.xml` file into the `Karaf deploy`
    folder. In the log, we can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can note that:'
  prefs: []
  type: TYPE_NORMAL
- en: The server route has been called by the client route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consumer prefixed the message body (with `Echo`) as defined in the simple
    expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we used beans (POJO) and processors to implement mediation
    logic and act as a producer. However, to implement and simplify support of some
    protocols, systems, data transformations, and so on, Camel components are very
    convenient and provide easy extension points, which are ready to use in Camel
    route. This allows you to decouple implementation of the connectivity from the
    mediation logic.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a combination of components (provided or custom), processors, beans,
    and route definitions provides a complete and powerful mediation framework. However,
    integration and mediation requires us to address a new challenge—how to handle
    and process errors that can happen in the mediation. This is what we will see
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
