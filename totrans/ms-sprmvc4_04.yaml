- en: Chapter 4. File Upload and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will enable our user to upload a profile picture. We will
    also see how to handle errors in Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now make it possible for our user to upload a profile picture. This
    will be available from the profile page later on, but for now, we will simplify
    things and create a new page in the templates directory under `profile/uploadPage.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Not much to see besides the `enctype` attribute on the form. The file will
    be sent by the `POST` method to the `upload` URL. We will now create the corresponding
    controller right beside `ProfileController` in the `profile` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing this code will do is create a temporary file in the `pictures`
    directory, which can be found inside the project's root folder; so, ensure that
    it exists. In Java, a temporary file is just a commodity to obtain a unique file
    identifier on the filesystem. It is up to the user to optionally delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a pictures directory at the root of the project and add an empty file
    called `.gitkeep` to ensure that you can commit it in Git.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Empty directories in Git**'
  prefs: []
  type: TYPE_NORMAL
- en: Git is file-based and it is not possible to commit an empty directory. A common
    workaround is to commit an empty file, such as `.gitkeep`, in a directory to force
    Git to keep it under version control.
  prefs: []
  type: TYPE_NORMAL
- en: The file uploaded by the user will be injected as a `MultipartFile` interface
    in our controller. This interface provides several methods to get the name of
    the file, its size, and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: The method that particularly interests us here is `getInputStream()`. We will
    indeed copy this stream to a `fileOutputStream` method, thanks to the `IOUtils.copy`
    method. The code to write an input stream to an output stream is pretty boring,
    so it's handy to have the Apache Utils in the classpath (it is part of the `tomcat-embedded-core.jar`
    file).
  prefs: []
  type: TYPE_NORMAL
- en: 'We make heavy use of the pretty cool Spring and Java 7 NIO features:'
  prefs: []
  type: TYPE_NORMAL
- en: The resource class of string is a utility class that represents an abstraction
    of resources that can be found in different ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try…with` block will automatically close our streams even in the case of
    an exception, removing the boilerplate of writing a `finally` block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the preceding code, any file uploaded by the user will be copied into the
    `pictures` directory.
  prefs: []
  type: TYPE_NORMAL
- en: There are a handful of properties available in Spring Boot to customize file
    upload. Take a look at the `MultipartProperties` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`multipart.maxFileSize`: This defines the maximum file size allowed for the
    uploaded files. Trying to upload a bigger one will result in a `MultipartException`
    class. The default value is `1Mb`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipart.maxRequestSize`: This defines the maximum size of the multipart
    request. The default value is `10Mb`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The defaults are good enough for our application. After a few uploads, our
    picture directory will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading a file](img/2117_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Wait! Somebody uploaded a ZIP file! I cannot believe it. We better add some
    checks in our controller to ensure that the uploaded files are real images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pretty easy! The `getContentType()` method returns the **Multipurpose Internet
    Mail Extensions** (**MIME**) type of the file. It will be `image/png`, `image/jpg`,
    and so on. So we just have to check if the MIME type starts with "image".
  prefs: []
  type: TYPE_NORMAL
- en: 'We added an error message to the form so we should add something in our web
    page to display it. Place the following code just under the title in the `uploadPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next time you try to upload a ZIP file, you will get an error! This is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading a file](img/2117_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing an image to the response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The uploaded images are not served from the static directories. We will need
    to take special measures to display them in our web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following lines to our upload page, just above the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will try and get the image from our controller. Let''s add the corresponding
    method to the `PictureUploadController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code will write an image found in the `src/main/resources/images/anonymous.png`
    directory directly to the response! How exciting!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go to our page again, we will see the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing an image to the response](img/2117_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I found the anonymous user image on iconmonstr ([http://iconmonstr.com/user-icon](http://iconmonstr.com/user-icon))
    and downloaded it as a 128 x 128 PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: Managing upload properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good thing to do at this point is to allow the configuration of the upload
    directory and the path to the anonymous user image through the `application.properties`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `PicturesUploadProperties` class inside a newly created `config`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we make use of the Spring Boot `ConfigurationProperties`. This
    will tell Spring Boot to automatically map properties found in the classpath (by
    default, in the `application.properties` file) in a type-safe fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we defined setters taking 'String's as arguments but are at liberty
    to let the getters return any type is the most useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to add the `PicturesUploadProperties` class to our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the properties'' values inside the `application.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because we use Spring's `DefaultResourceLoader` class, we can use prefixes such
    as `file:` or `classpath:` to specify where our resources can be found.
  prefs: []
  type: TYPE_NORMAL
- en: This would be the equivalent of creating a `FileSystemResource` class or a `ClassPathResource`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This approach also has the advantage of documenting the code. We can easily
    see that the picture directory will be found in the application root, whereas
    the anonymous picture will be found in the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it. We can now use our properties inside our controller. The following
    are the relevant parts of the `PictureUploadController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, if you launch your application again, you will see that the result
    hasn't changed. The anonymous picture is still displayed and the pictures uploaded
    by our users still end up in the `pictures` directory at the project root.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the uploaded picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be nice to display the user''s picture now, wouldn''t it? To do this,
    we will add a model attribute to our `PictureUploadController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now inject it to retrieve its value when we serve the uploaded picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `@ModelAttribute` annotation is a handy way to create model attributes with
    an annotated method. They can then be injected with the same annotation into controller
    methods. With this code, a `picturePath` parameter will be available in the model
    as long as we are not redirected to another page. Its default value is the anonymous
    picture we defined in our properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to update this value when the file is uploaded. Update the `onUpload`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By injecting the model, we can update the `picturePath` parameter after the
    upload is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the problem is that our two methods, `onUpload` and `getUploadedPicture`,
    will occur in different requests. Unfortunately, the model attributes will be
    reset between each.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why we will define the `picturePath` parameter as a session attribute.
    We can do this by adding another annotation to our controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Phew! That''s a lot of annotations just to handle a simple session attribute.
    You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the uploaded picture](img/2117_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This approach makes code composition really easy. Plus, we didn't use `HttpServletRequest`
    or `HttpSession` directly. Moreover, our object can be typed easily.
  prefs: []
  type: TYPE_NORMAL
- en: Handling file upload errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It must have certainly occurred to my attentive readers that our code is susceptible
    to throw two kinds of exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IOException`: This error is thrown if something bad happens while writing
    the file to disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultipartException`: This error is thrown if an error occurs while uploading
    the file. For instance, when the maximum file size is exceeded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will give us a good opportunity to look at two ways of handling exceptions
    in Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `@ExceptionHandler` annotation locally in a controller method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a global exception handler defined at the Servlet container level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s handle `IOException` with the `@ExceptionHandler` annotation inside
    our `PictureUploadController` class by adding the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple yet powerful approach. This method will be called every time
    an `IOException` is thrown in our controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test the exception handler, since making the Java IO code throw
    an exception can be tricky, just replace the `onUpload` method body during the
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After this change, if we try to upload a picture, we will see the error message
    of this exception displayed on the upload page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling file upload errors](img/2117_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will handle the `MultipartException`. This needs to happen at the Servlet
    container level (that is, at the Tomcat level), as this exception is not thrown
    directly by our controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to add a new `EmbeddedServletContainerCustomizer` bean to our
    configuration. Add this method to the `WebConfiguration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a little verbose. Note that `EmbeddedServletContainerCustomizer` is
    an interface that contains a single method; it can therefore be replaced by a
    lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s just write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new error page, which will be called when a `MultipartException`
    happens. It can also be mapped to an HTTP status. The `EmbeddedServletContainerCustomizer`
    interface has many other features that will allow the customization of the Servlet
    container in which our application runs. Visit [http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers](http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to handle this `uploadError` URL in our `PictureUploadController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The error pages defined in a Servlet environment contain a number of interesting
    attributes that will help debug the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.error.status_code` | This is the HTTP status code of the error.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.error.exception_type` | This is the exception class. |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.error.message` | This is the message of the exception thrown.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.error.request_uri` | This is the URI on which the exception
    occurred. |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.error.exception` | This is the actual exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.error.servlet_name` | This is the name of the Servlet that
    caught the exception. |'
  prefs: []
  type: TYPE_TB
- en: All these attributes are conveniently accessible on the `WebUtils` class of
    Spring Web.
  prefs: []
  type: TYPE_NORMAL
- en: If someone tries to upload too big a file, they will get a very clear error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now test that the error is handled correctly by uploading a really
    big file (> 1Mb) or setting the `multipart.maxFileSize` property to a lower value:
    1kb for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling file upload errors](img/2117_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Translating the error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is really good for a developer to see the exceptions thrown by the application.
    However, for our users, they bear little value. We will therefore translate them.
    In order to do that, we have to inject our application''s `MessageSource` class
    into our controller''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can retrieve messages from our messages bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the English messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the French ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Placing the profile in a session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing we want is the profile to be stored in a session so that it does
    not get reset every time we go on the profile page. This can apparently prove
    tiresome to some users and we have to address it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**HTTP sessions** are a way to store information between requests. HTTP is
    a stateless protocol, which means that there is no way to relate two requests
    coming from the same user. What most Servlet containers do is they associate a
    cookie called `JSESSIONID` to each user. This cookie will be transmitted in the
    request header and will allow you to store arbitrary objects in a map, an abstraction
    called `HttpSession`. Such a session will typically end when the user closes or
    switches web browsers or after a predefined period of inactivity.'
  prefs: []
  type: TYPE_NORMAL
- en: We just saw a method to put objects in a session using the `@SessionAttributes`
    annotation. This works well within a controller but makes the data difficult to
    share when spread across multiple controllers. We have to rely on a string to
    resolve the attribute from its name, which is hard to refactor. For the same reason,
    we don't want to manipulate the `HttpSession` directly. Another argument that
    will discourage the direct usage of the session is how difficult it is to unit
    test the controller that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another popular approach when it comes to saving things in a session
    with Spring: annotate a bean with `@Scope("session")`.'
  prefs: []
  type: TYPE_NORMAL
- en: You will then be able to inject your session bean in your controllers and other
    Spring components to either set or retrieve values from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `UserProfileSession` class in the `profile` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have conveniently provided a way to convert from and to a `ProfileForm`
    object. This will help us store and retrieve the form data from our `ProfileController`
    constructor. We need to inject our `UserProfileSession` variable in the controller''s
    constructor and store it as a field. We also need to expose the `ProfileForm`
    as a model attribute, which will remove the need to inject it in the `displayProfile`
    method. Finally, we can save the profile once it has been validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That's all it takes to save data in a session with Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you complete the profile form and refresh the page, the data will be
    persisted between requests.
  prefs: []
  type: TYPE_NORMAL
- en: Just before moving on to the next chapter, I want to detail a couple of concepts
    we just used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the injection by the constructor. The `ProfileController` constructor
    is annotated with `@Autowired`, which means Spring will resolve the constructor
    arguments from the application context before instantiating the bean. The alternative,
    which is a little less verbose, would have been to use field injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Constructor injection is arguably better because it makes the unit testing of
    our controller easier if we were to move away from the `spring-test` framework
    and it makes the dependencies of our bean somewhat more explicit.
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed discussion on field injection and constructor injection, refer
    to the excellent blog post by Oliver Gierke at [http://olivergierke.de/2013/11/why-field-injection-is-evil/](http://olivergierke.de/2013/11/why-field-injection-is-evil/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing that might need clarification is the `proxyMode` parameter on
    the `Scope` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three `proxyMode` parameters available with Spring, if we don''t
    count the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TARGET_CLASS`: This uses a CGI proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTERFACES`: This creates a JDK proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NO`: This does not create any proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of a proxy typically comes into play when you inject something
    into a long-lived component such as a singleton. Because injection only happens
    once, when the bean is created, subsequent calls to the injected bean might not
    reflect its actual state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, a session bean''s actual state is stored in the session and not
    directly on the bean. This explains why Spring has to create a proxy: it needs
    to intercept calls to our bean methods and listen for its mutations. This way,
    the state of the bean can be transparently stored and retrieved from the underlying
    HTTP session.'
  prefs: []
  type: TYPE_NORMAL
- en: For a session bean, we are forced to use a proxy mode. The CGI proxy will instrument
    your bytecode and work on any class, whereas the JDK approach might be a bit more
    lightweight but requires you to implement an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we made the `UserProfileSession` bean implement the `Serializable` interface.
    This is not strictly required because the HTTP sessions can store arbitrary objects
    in memory, but making objects that end up in the session serializable really is
    a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, we might change the way the session is persisted. In fact, we will store
    the session in a Redis database in [Chapter 8](ch08.html "Chapter 8. Optimizing
    Your Requests"), *Optimizing Your Requests*, where Redis has to work with `Serializable`
    objects. It's always best to think of the session of a generic data store. We
    have to provide a way to write and read objects from this storage system.
  prefs: []
  type: TYPE_NORMAL
- en: For serialization to work properly on our bean, we also need every one of its
    field to be serializable. In our case, strings and dates are serializable so we
    are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Custom error pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot lets you define your own error view instead of the Whitelabel error
    page that we saw earlier. It must have the name `error` and its purpose is to
    handle all exceptions. The default `BasicErrorController` class will expose a
    lot of useful model attributes that you can display on this page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a custom error page in `src/main/resources/templates`. Let''s
    call it `error.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we navigate to a URL that is not handled by our application, we see
    our custom error page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom error pages](img/2117_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A more advanced option to handle errors is to define your own implementation
    of the `ErrorController` class, a controller in charge of handling all the exceptions
    at a global level. Take a look at the `ErrorMvcAutoConfiguration` class and the
    `BasicErrorController` class, which is the default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: URL mapping with matrix variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now aware of what our user is interested in. It would be a good idea
    to improve our Tweet controller so that it allows searching from a list of keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting way to pass key-value pairs in a URL is to use a matrix variable.
    It is pretty similar to request parameters. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the preceding parameter, matrix variables understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'They also allow each parameter to be a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A matrix variable can be mapped to different object types inside a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Map<String, List<?>>`: This handles multiple variables and multiple values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<String, ?>`: This handles a case in which each variable has only one value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<?>`: This is used if we are interested in a single variable whose name
    can be configured'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we want to handle something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter, `popular`, is the result type known by the Twitter search
    API. It can take the following values: `mixed`, `recent`, or `popular`.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of our URL is a list of keywords. We will therefore map them to a simple
    `List<String>` object.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring MVC removes every character following a semicolon in a URL.
    The first thing we need to do to enable matrix variables in our application is
    to turn off this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following code to our `WebConfiguration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new controller in the `search` package, which we will call
    `SearchController`. Its role is to handle the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are able reuse the existing result page to display the tweets.
    We also want to delegate the search to another class called `SearchService`. We
    will create this service in the same package as `SearchController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to implement the `search()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The search operation accessible on `twitter.searchOperations().search(params)`
    takes `searchParameters` as an argument for an advanced search. This object allows
    us to conduct a search on a dozen of criteria. We are interested in the `query`,
    `resultType`, and `count` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a `ResultType` constructor with the `searchType` path
    variable. The `ResultType` is an enum, so we can iterate over its different values
    and find one that matches the input, ignoring the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a `SearchParameters` constructor with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, creating a list of the `SearchParameters` constructor is as easy as conducting
    a map operation (taking a list of keywords and returning a `SearchParameters`
    constructor for each one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to fetch the tweets for each `SearchParameters` constructor. You
    might think of something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you think about it, this will return a list of tweets. What we
    want is to flatten all the tweets to get them as a simple list. It turns out that
    calling `map` and then flattening the result is an operation known as `flatMap`.
    So we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of `flatMap` function, that takes a stream as a parameter, is a
    bit difficult to understand at first. Let me show you the entire code of the `SearchService`
    class so we can take a step back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we navigate to `http://localhost:8080/search/mixed;keywords=scala,java`,
    we get the expected result. A search for the Scala keyword and then for Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '![URL mapping with matrix variables](img/2117_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Putting it together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that everything works separately, it''s time to assemble everything. We
    will do this in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the upload form to the profile page and remove the old upload page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the submit button on the profile page to trigger the taste search directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the home page of our application. It should display search results matching
    our users' tastes right away. If they are unavailable, go to the profile page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I encourage you to try to do it on your own. You will run into very manageable
    problems along the way but you should know enough to resolve them on your own.
    I believe in you.
  prefs: []
  type: TYPE_NORMAL
- en: OK, now that you have done the work (you have, haven't you?), let's take a look
    at my solution.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to remove the old `uploadPage` title. Don't look back, just
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, put these lines just below the `profilePage` title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It is very similar to the content of the late `uploadPage`. We just removed
    the title and changed the label of the submit button. Add the corresponding translation
    to the bundles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In English:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In French:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We also changed the name of the submit button to `upload`. That will help us
    identify this action on the controller side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to upload our picture, it will redirect us to the old upload
    page. We need to fix this in the `onUpload` method of our `PictureUploadController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that we changed the URL that handles the post. It is now `/profile` instead
    of `/upload`. Form handling is much simpler when the `GET` and `POST` requests
    have the same URL, and will save us a lot of trouble especially when dealing with
    exceptions. This way, we will not have to redirect the user after an error.
  prefs: []
  type: TYPE_NORMAL
- en: We also removed the model attribute, `picturePath`. Since we now have a bean
    representing our user in a session, `UserProfileSession`, we decided to add it
    there. We added a `picturePath` attribute to the `UserProfileSession` class and
    the associated getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to inject the `UserProfileSession` class and make it available
    as a field in our `PictureUploadController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that all the properties of our session bean must be serializable,
    unlike resources. So we need to store it differently. The URL class seems to be
    a good fit. It is serializable and it is easy to create a resource from a URL
    with the `UrlResource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The last thing that I had to do is to make the `profileForm` available as a
    model attribute after an error. This is because the `profilePage` requires it
    when it is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here is the final version of the `PictureUploadController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we can go to the profile page and upload our picture as well as provide
    personal information, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it together](img/2117_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s redirect our user to its search after the profile is completed.
    For this, we need to modify the `saveProfile` method in the `ProfileController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are able to search for tweets from our profile, we don't need the
    `searchPage` or `TweetController` we previously made. Simply delete the `searchPage.html`
    page and the `TweetController`.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, we can modify our home page so that it redirects us to a search matching
    our tastes if we have already completed our profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new controller in the controller package. It is responsible
    for redirecting a user arriving at the root of our website either to their profile
    if it''s incomplete or to the `resultPage` if their tastes are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The check point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added two controllers, the `PictureUploadController`, which
    is in charge of writing uploaded files to the disk and handling upload errors,
    and the `SearchController` that can search tweets from a list of keywords with
    matrix parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This controller then delegates the search to a new service, `SearchService`.
  prefs: []
  type: TYPE_NORMAL
- en: We deleted the old `TweetController`.
  prefs: []
  type: TYPE_NORMAL
- en: We created a session bean, `UserProfileSession`, to store the information about
    our user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added two things to `WebConfiguration`. We added the error pages
    for our Servlet container and support for matrix variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the resources side, we added a picture representing an anonymous user and
    a static page to handle errors. We added the file upload to `profilePage` and
    got rid of the old `searchPage`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed file upload and error handling. Uploading a file
    is not really complicated. However, a big design decision is what to do with the
    uploaded files. We could have stored the images it in a database, but instead
    we chose to write it to the disk and save the location of each user's picture
    in their session.
  prefs: []
  type: TYPE_NORMAL
- en: We saw typical ways to handle exceptions at the controller level and at the
    servlet container level. For additional resources on Spring MVC error handling,
    you can refer to the blog post at [https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc](https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc).
  prefs: []
  type: TYPE_NORMAL
- en: Our application is looking pretty good already and yet the amount of code we
    had to write is very reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Stay tuned for the next chapter where we will see that Spring MVC is also a
    powerful framework to build REST applications.
  prefs: []
  type: TYPE_NORMAL
