<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Airline Ticket System</h1>
                </header>
            
            <article>
                
<p class="mce-root">Our last projects—Twitter Consumers, Twitter Gathering, and Twitter Dispatcher<span>—</span>were excellent. We learned several exciting features, and they were implemented using the new features present in Spring 5.0. All of them are implemented in Reactive Streams and use Kotlin as the programming language. They are the hottest features in Spring 5.0; it was an impressive progression.</p>
<p>However, there are notably missing parts on these projects; we have microservice needs in mind. There are no infrastructure services such as service discovery, distributed configurations, API Gateway, distributed tracing, and monitoring. These kinds of services are mandatory in distributed systems such as microservice architectures.</p>
<p>There are several reasons for that. Firstly, we can think of the configuration management. Let's imagine the following scenario – in the development cycle, we have three environments: DEV, TST, and PROD. This is a pretty simple standard found in companies. Also, we have an application decoupled in 4 microservices, then with the minimum infrastructure, we have 12 instances of services; remember, this is a good scenario because in a real situation, we will probably have several instances of microservice applications.</p>
<p>In the earlier scenario, we will maintain at least three configuration files per microservice, remember there are three environments for which we need to keep the configurations. Then, we will have 12 <em>versions</em> of settings. It is a hard task to maintain the configurations, to keep the files synchronized and updated. These files probably contain sensitive information, such as database passwords and message brokers' configurations, and it is not recommended that you put these files on the host machines.</p>
<p>In this case, the distributed configuration can solve our problems easily. We will learn about configuration servers in this chapter, and other infrastructure services as well.</p>
<p>Let's summarize what we will learn in this chapter:</p>
<ul>
<li>How to create a Config Server </li>
<li>Implementing a service discovery with Eureka</li>
<li>Monitoring applications with Spring Cloud Zipkin</li>
<li>Exposing the applications with the Spring Cloud Gateway</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Airline Ticket System</h1>
                </header>
            
            <article>
                
<p>In these last few chapters, we will work on the Airline Ticket System. The solution is quite complex and involves a lot of HTTP integrations and message-based solutions. We will explore what we have learned from the book journey.</p>
<p>We will use Spring Messaging, Spring WebFlux, and Spring Data components to create the solution. The application will split up into several microservices to guarantee the scalability, elasticity, and fault tolerance for the system. </p>
<p>Also, we will have some infrastructure services to help us deliver an efficient system. Some new patterns will be introduced, such as circuit breakers and OAuth. In the infrastructure layer, we will use the Netflix OSS components integrated with the Spring Framework ecosystem.</p>
<p>The main purpose of our application is to sell airline tickets, but to achieve this task, we need to build an entire ecosystem. We will build a microservice which will manage the seats and planes' characteristics. There will also be a microservice to manage available company flights; the basic idea is to manage flight dates and routes. Of course, we will have a microservice to manage passengers, fares, bookings, and payments. Finally, we will have an <kbd>e-commerce</kbd> API with which end users will buy airline tickets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Airline functionalities</h1>
                </header>
            
            <article>
                
<p>We will create some microservices to compose the solution and then we will decompose the solution into small pieces, that is, microservices. For that, we will use the Bounded Context pattern which is an essential part of the <strong>Domain-Driven Design</strong> (<strong>DDD</strong>).</p>
<p>Let's look at the following diagram to have an idea about what we will build:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="408" src="assets/753b73dc-b3dc-42f9-9a97-d71218b84d8c.png" width="478"/></div>
<p>It is a summary of what we will do in these few chapters; we have defined the basic functionalities for each microservice.</p>
<p>Now, we will take a look at components; let's go to the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solution diagram</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The following diagram illustrates the whole solution, which we will implement in the following chapters:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="214" src="assets/4fa12d95-91e4-4a04-a321-d9520ed6e208.png" width="275"/></div>
<p>As we can see, there are different kinds of components. Some components will be exposed through the <strong>Gateway</strong> for end users, in our case, our customers. There is a category which the company users will use to register flights, for instance, where these microservices will be exposed on <strong>Gateway</strong> as well.</p>
<p>The infrastructure category will not be exposed over the internet, except the <strong>Gateway</strong> service. These services help the solution infrastructure and should be not exposed because there is sensitive data in there.</p>
<p>There a lot of things to do; let's get on with the show.</p>
<div class="packt_tip">DDD enables us to deal easily with microservices. Some DDD patterns fit well for the microservices architectural style. There are many interesting books in the Packt catalog.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Cloud Config Server</h1>
                </header>
            
            <article>
                
<p>When we adopt the microservices architectural style, there are some challenges to solve. One of the first problems to solve is how to manage the microservices configurations in the cluster, and how to make them easy and distributed, as well?</p>
<p>Spring Cloud Config provides a Spring way, based on annotations and Spring beans. It is an easy way to solve this problem in a production-ready module. There are three main components in this module, the Configuration Repository, that is, version control system, the Config Server, which will provide the configurations, and finally, the Configuration Client, which will consume the configuration from the Config Server.</p>
<p>This module supplies the configuration files over an HTTP interface. It is the main feature provided by this project and it acts as a central repository for configuration in our architecture.</p>
<p>We want to remove the <kbd>application.yaml</kbd> file from our classpath; we do not need this file in classpath anymore, and so we will use the Config Server to serve this file for our application.</p>
<p>Now, our microservices will not have the configuration file, that is, <kbd>application.yaml</kbd>.  During the application bootstrap, the application will look at the Config Server to get the correct configuration, and after that, the application will finish the bootstrap to get them up and into running status.</p>
<p>The following diagram explains the <strong>Config Server</strong> and Config Client:</p>
<div class="CDPAlignCenter CDPAlign"><img height="183" src="assets/0a9eadf3-88e3-4a7c-af0b-f445593eb38f.png" width="300"/></div>
<p>As we can see, the basic idea here is to try to distribute the configuration through the <strong>Config Server</strong>. There are some advantages to using this approach. The first one keeps the configuration in the central repository. It makes the configuration easy to maintain. The second one is that the configurations are served with a standard protocol, such as HTTP. Most of the developers know the protocol and make the interaction easy to understand. Finally, and most importantly, when the properties change, it can reflect immediately in other microservices.</p>
<p><span>Time to implement it. Let's go there.</span></p>
<div class="packt_infobox">The Config Server is usually maintained on private networks, if we are deploying in cloud environments, although the Spring Cloud Config supports encrypt and decrypt based on symmetric or asymmetric keys. Keep in the mind that the microservices configurations should not be published on public networks.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Config Server project</h1>
                </header>
            
            <article>
                
<p>Let's create our project with Spring Initializr. Go to Spring Initializr (<a href="https://start.spring.io/">https://start.spring.io/</a>) and follow the image instructions:</p>
<div class="CDPAlignCenter CDPAlign"><img height="362" src="assets/6d2e86ae-ec42-42fe-98c6-7b783b332925.png" width="666"/></div>
<p>Click on <span class="packt_screen">Generate Project</span> and then we can open the project on the IDE.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling Spring Cloud Config Server</h1>
                </header>
            
            <article>
                
<p>We will use the Git repository as a property source, and then we need to create a repository to keep these files. However, before that, let's navigate to the <kbd>pom.xml</kbd> file and see some interesting stuff. We can find the following dependency:</p>
<pre style="padding-left: 60px"><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-cloud-config-server<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>It is a Config Server dependency. It enables us to use the Config Server in our application. Remember, we need to put this into the <kbd>pom.xml</kbd> file to achieve the required Config Server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using GitHub as a repository</h1>
                </header>
            
            <article>
                
<p>The Spring Cloud Config Server enables us to use different datastore technologies to work as a properties repository. There are some options such as Git repository, filesystem, or SVN and others, provided by the community.</p>
<p>We will choose the Git repository, and use GitHub as a host. </p>
<div class="packt_tip"><span>We will use the Git repository that has the source code of the book. The repository is located at: </span><a href="https://Github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files">https://GitHub.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files</a><span>.<br/></span>The Spring Cloud Config Server also supports private repositories. For that purpose, we need to supply the private/public keys.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Spring Boot application</h1>
                </header>
            
            <article>
                
<p>It's a piece of cake to enable and run the Config Server and provide our configuration HTTP protocol. To achieve it, we need to put the following annotation in our Spring Boot starter class. The implementation is as follows:</p>
<pre style="padding-left: 60px"><span>package </span>springfive.airline.configserver<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.config.server.<span>EnableConfigServer</span><span>;<br/></span><span><br/></span><span><strong>@EnableConfigServer</strong><br/></span><span>@SpringBootApplication<br/></span><span>public class </span>ConfigServerApplication {<br/><br/>  <span>public static void </span><span>main</span>(String[] args) {<br/>    SpringApplication.<span>run</span>(ConfigServerApplication.<span>class, </span>args)<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>Awesome. <kbd>@EnableConfigServer</kbd> does the magic for us. It will stand up the Config Server and make the application ready to connect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Git repository as a properties source</h1>
                </header>
            
            <article>
                
<p>Our Config Server needs to be configured. For that purpose, we will use the <kbd>application.yaml</kbd> file. This file should be simple and with minimal configurations as well. The configuration file should look like this:</p>
<pre style="padding-left: 60px"><span>server:<br/></span><span>  port: </span><span>5000<br/></span><span><br/></span><span>spring:<br/></span><span>  cloud:<br/></span><span>    config:<br/></span><span>      name: </span>configserver<br/>      <span>server:<br/></span><span>        git:<br/></span><span>          uri: </span><strong>https://github.com/PacktPublishing/Spring-5.0-By-Example<br/>          </strong>search-paths: config-files*</pre>
<p>We have configured the application port, which is a common task. We named our Config Server, and the most important part is the <kbd>server.git.uri</kbd> configuration property which instructs the Spring Framework to get the configurations files.</p>
<p>Another configuration is <kbd>search-paths</kbd>; it allows us to search the configuration in <kbd>git</kbd> repository folders, instead of a root address in the repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Config Server</h1>
                </header>
            
            <article>
                
<p>Awesome job; our configuration server is ready to use. Then let's run it. We can use the JAR file, or through IDE as well, it is up to you to choose the desired way.</p>
<p><span>We can use the Java command line or IDE to run it. I prefer to use IDE because it enables us to debug and make some code changes.</span></p>
<p>Run it.</p>
<p>The output should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3d7333e2-00cb-45fe-9240-725b872db110.png"/></div>
<p>Tomcat started successfully; our Config Server is up and running. We can find some different endpoints in our Config Server. These endpoints are exposed to serve the configuration file.</p>
<p>The Spring Cloud Config Server supports profiles as well, providing different configurations for different environments is important.</p>
<p>The pattern supported by the Config Server is as follows:</p>
<pre>&lt;application-name&gt;-&lt;profile&gt;.&lt;properties|yaml&gt;</pre>
<p>It is really important to keep this in mind. Also, it makes it mandatory to declare the <kbd>application.name</kbd> property in our microservices, to identify the application.</p>
<p>We can find the endpoints provided by the Spring Cloud Config Server on the application bootstrap. Take a look at the log:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3fab23f7-200e-46ed-916d-431284f56b91.png"/></div>
<p>Remember the Config Server supports environments; because of this, there is a kind of regex on endpoints. Look at the <kbd>"/{name}-{profiles}.yml"</kbd> endpoint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing our Config Server</h1>
                </header>
            
            <article>
                
<p>We are able to test our Config Server over the REST API.</p>
<p>Let's create a simple <kbd>yaml</kbd> file to create the test; the file should be called <kbd>dummy.yaml</kbd>:</p>
<pre><span>info:<br/></span><span>  message: </span><span>"Testing my Config Server"<br/></span><span>  </span><span>status: </span><span>"It worked"</span></pre>
<p>Push it to GitHub – if you are using the GitHub book, this step is unnecessary. Then, we can call the Config Server API using the following command:</p>
<pre>curl http://localhost:5000/dummy/default | jq</pre>
<p>The command looks for the <kbd>dummy</kbd> configuration in the profile <kbd>default</kbd>; the URL is self-explanatory. The following output should be displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="252" src="assets/37d49791-5ca9-4f9e-a4ba-42fe9928c9bf.png" width="506"/></div>
<p>Our Config Server is fully operational. Now, we will configure our service discovery using Netflix Eureka.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Cloud service discovery</h1>
                </header>
            
            <article>
                
<p>The service discovery is one of the key points of the microservices architecture. The basis of the microservices architecture is to decouple the monolithic application into smaller pieces of software which have well-defined boundaries.</p>
<p>This impacts our system design in the monolithic application. In general, the application logic stays in a single place with regards to the code. It means the procedure or methods calls are invoked in the same context when the application is running.</p>
<p>When we adopt the microservices architectural style, these invocations are typically external, in other words, they will invoke the service through HTTP calls, for example, in another application context or web server.</p>
<p>Then, the services need to call other services through HTTP, for instance, but how do the services call the others if the instances of these services change with a considerable frequency? Remember, we are creating distributed and scalable systems, where the instances of services can be increased according to the system usage.</p>
<p>The services need to know where the other services are running to be able to call them. Let's imagine that we are considering putting the services IPs in the configuration; it will be hard to manage and impossible to track the machine changes during that time.</p>
<p>The service discovery pattern addresses this challenge. In general, the solution involves a Service Registry, which knows the locations of all the running services. The client then needs to have a kind of Service Registry Client to be able to query this Service Registry to obtain the valid address for the desired service; the Service Registry will then return a healthy address, and finally, the client can invoke the desired service.</p>
<p>Let's look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="208" src="assets/c59a3075-c289-48e0-93db-f68ce5d32989.png" width="252"/></div>
<div class="CDPAlignCenter CDPAlign"/>
<div class="packt_infobox">The full documentation of this pattern can be found at <a href="http://microservices.io/patterns/client-side-discovery.html">http://microservices.io/patterns/client-side-discovery.html</a> and <a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/">https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/</a>. There are so many implementations for that pattern.</div>
<p>The Spring Cloud service discovery supports some service discovery implementations, such as Hashicorp Consul provided by the Spring Cloud Consul, and Apache Zookeeper provided by the Spring Cloud Zookeeper.</p>
<p>We are using the Netflix OSS stack where we will use the Eureka server, which was provided by the Spring Netflix OSS. It enables us to use the Eureka server as a managed Spring bean.</p>
<p>The Spring Eureka Client provides a client aware of the Service Registry, and it can be done with a couple of annotations and some configurations – we will do that soon.</p>
<p>We will start to create and configure the Eureka server in the following sections. Let's do that.</p>
<div class="packt_infobox">The full documentation for the Spring Cloud Consul can be found at: <a href="https://cloud.spring.io/spring-cloud-consul">https://cloud.spring.io/spring-cloud-consul</a>, and the Spring Cloud Zookeeper can be found at: <a href="https://cloud.spring.io/spring-cloud-zookeeper">https://cloud.spring.io/spring-cloud-zookeeper.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Spring Cloud Eureka</h1>
                </header>
            
            <article>
                
<p>To enable service discovery in our infrastructure, we need to create an instance of a service which will act as a service discovery. The Spring Cloud Eureka server enables us to achieve this task. Let's create our project. Go to Spring Initializr and fill in the information, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0f428b3d-b577-4360-987f-f4a4106206dd.png"/></div>
<p>Take a look at the required dependencies. The Eureka server is the dependency which allows us to spin up a service discovery server.</p>
<p>Let's open the project on IDE and start to configure it. We will do this in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Eureka server main class</h1>
                </header>
            
            <article>
                
<p>Before we start the configuration, we will create the <kbd>main</kbd> class. This class will start the Spring Boot application. The Eureka server is embedded in the application. It is a pretty standard Spring Boot application with a single annotation.</p>
<p>The <kbd>main</kbd> application class should look like this:</p>
<pre style="padding-left: 60px"><span>package </span>springfive.airline.eureka<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.server.<span>EnableEurekaServer</span><span>;<br/></span><span><br/></span><span><strong>@EnableEurekaServer</strong><br/></span><span>@SpringBootApplication<br/></span><span>public class </span>EurekaApplication {<br/><br/>  <span>public static void </span><span>main</span>(String[] args) {<br/>    SpringApplication.<span>run</span>(EurekaApplication.<span>class, </span>args)<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>The <kbd>@EnableEurekaServer</kbd> annotation will start the embedded Eureka server in our application and make it ready to use. It will enable the service registry in our application as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Spring Cloud Eureka server</h1>
                </header>
            
            <article>
                
<p>Our Eureka server needs to be configured using the Spring Cloud Server configured in the previous sections. Then, we need to keep the <kbd>application.yaml</kbd> off our project, to use the Config Server properly. Instead of the <kbd>application.yaml,</kbd> we need to put the <kbd>bootstrap.yaml</kbd> and put the Config Server address on it.</p>
<p>Then, we need to:</p>
<ul>
<li>Create <kbd>discovery.yaml</kbd> on GitHub</li>
<li>Create <kbd>bootstrap.yaml</kbd> file in the <span>classpath</span> project </li>
</ul>
<p>Let's start with the <kbd>discovery.yaml</kbd> file. The file should look like this:</p>
<pre style="padding-left: 60px">server:<br/>  port: 8761<br/><br/>eureka:<br/>  instance:<br/>    hostname: localhost<br/>    health-check-url-path: /actuator/health<br/>    status-page-url-path: /actuator/info <br/>  client:<br/>    registerWithEureka: false<br/>    fetchRegistry: false<br/>logging:<br/>  level:<br/>    com.netflix.discovery: 'ON'<br/>    org.springframework.cloud: 'DEBUG'</pre>
<p>There are some interesting things to explore. We are using the localhost as <kbd>hostname</kbd> because we are running on the developer machine. There are a couple of configurations about the URLs health check and status page – pay attention to the configurations that are related to the server. They are placed below the <kbd><span><span>eureka.instance</span></span></kbd> YAML node. The configurations are <kbd>health-check-url-path</kbd> and <kbd>status-page-url-path</kbd>. We can use the default values as well, but the new Spring Boot Actuator changes the URL for those two features, so we need to configure them properly.  </p>
<p>The <kbd>eureka.client</kbd> YAML node is about the client configuration; in our case, we set <kbd>registerWithEureka</kbd> to false. We do not want the Eureka server to act as a client as well. The same is true for the <kbd>fetchRegistry</kbd> configuration, it is a client configuration and it will cache the Eureka registry's information.</p>
<p>The <kbd>logging</kbd> node is about logging configuration.</p>
<p>Awesome – our <kbd>gateway.yaml</kbd> is ready.</p>
<p>Let's create our <kbd>bootstrap.yaml</kbd> file in the Eureka server project classpath. The file should look like this:</p>
<pre style="padding-left: 60px"><span>spring:<br/></span><span>  application:<br/></span><span>    name: </span>discovery<br/>  <span>cloud:<br/></span><span>    config:<br/></span><span>      uri: </span>http://localhost:5000<br/>      <span>label: </span>master</pre>
<p>Easy peasy – we have configured <kbd>spring.cloud.config</kbd>. It instructs Spring of the Config Server address. Also, we have configured the <kbd>label</kbd>, which is the branch when we are using the <strong>version control system</strong> (<strong>VCS</strong>) as a repository.</p>
<p>Well done. The configuration is ready. Time to run it. Let's do it in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Spring Cloud Eureka server</h1>
                </header>
            
            <article>
                
<p>The Eureka server is ready to use. We will start the Spring Boot application and put our Eureka server online. We can use the Java command line or IDE to run it. I prefer to use IDE because it enables us to debug and make some code changes.</p>
<div class="packt_tip">The Config Server needs to be running because the discovery will find the configuration file to bootstrap the server properly.</div>
<p>Run it!</p>
<p>We should see the following lines in the application bootstrap logs:</p>
<div class="CDPAlignCenter CDPAlign"><img height="110" src="assets/989fa49b-7e17-477a-9e57-8afa3d9434d0.png" width="568"/></div>
<p>Awesome. Look at the following line of the log:</p>
<pre style="padding-left: 60px">2018-01-07 14:42:42.636  INFO 11191 --- [      Thread-32] e.s.EurekaServerInitializerConfiguration : <strong>Started Eureka Server</strong></pre>
<p>It means our Eureka server is ready to use. To check the solution, we can go to the Eureka server home page. Go to <kbd>http://localhost:8761/</kbd> and the following page will be displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="272" src="assets/7be8d8e4-c0c9-46b9-8686-8dac3141d1fe.png" width="608"/></div>
<p>As we can see, there is no instance of service available yet. We can find some relevant information such as the server <span class="packt_screen">Uptime</span>, the current <span class="packt_screen">Data center</span>, and the <span class="packt_screen">Current time</span>. There is some information in the <span class="packt_screen">General Info</span> section, information regarding the server where the Eureka server is running.</p>
<p>Good job. Our service discovery service is running. We will use this infrastructure soon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Cloud Zipkin server and Sleuth</h1>
                </header>
            
            <article>
                
<p>Our solution involves some microservices; it makes our solution easy to deploy and easy to write code. Each solution has a particular repository and codebase. </p>
<p>In the monolith solution, the whole problem is solved in the same artifact to be deployed. Usually, in Java, these artifacts are <kbd>.jar</kbd>, <kbd>.war</kbd>, or <kbd>.ear,</kbd> if the application was written in the Java EE 5/6 specifications.</p>
<p>The logging strategies for these kinds of applications is quite easy to work with (hence problems can be solved easily) because everything happens in the same context; the requests are received from the same application server or web server, which have the business components. Now, if we go to the logs, we will probably find the log entries we want. It makes the trace application easier to find errors and debug.</p>
<p>In the microservices solution, the application behaviors are split in the distributed systems; it increases the trace tasks <span>substantially </span>because the request probably arrives in the API Gateway and comes into microservices. They log the information in different sources. In this scenario, we need a kind of log aggregator and a way to identify the whole transaction between services.</p>
<p>For this purpose, the Spring Cloud Sleuth and Spring Cloud Zipkin can help us and make the trace features more comfortable for developers.</p>
<p>In this section, we will look at and understand how it works under the hood.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Infrastructure for the Zipkin server</h1>
                </header>
            
            <article>
                
<p>Before we start to work, we need to configure a service which the Zipkin server needs. By default, the Zipkin server uses in-memory databases, but it is not recommended for production; usually, developers use this feature to demonstrate Zipkin features.</p>
<p>We will use MySQL as a data store. The Zipkin server also supports different sources, such as Cassandra and Elasticsearch.</p>
<p>Spring Cloud Sleuth supports synchronous and asynchronous operations. The synchronous operations are over the HTTP protocol and asynchronous can be done by RabbitMQ or Apache Kafka.</p>
<p>To use the HTTP, that is, REST API, we should use <kbd>@EnableZipkinServer,</kbd> it will delegate the persistence for REST tier through the <kbd>SpanStore</kbd> interface.</p>
<p>We will choose the asynchronous solution, since it fits well for our project, and we do not want the trace collector to cause some performance issues. The asynchronous solution uses the Spring Cloud Stream binder to store the <kbd>Spans</kbd>. We choose the RabbitMQ message broker to do that. It can be achieved using the <kbd>@EnableZipkinStreamServer</kbd> annotations which configure Spring Sleuth to use streams for store <kbd>Spans</kbd>.</p>
<p>Let's create our <kbd>docker-compose-min.yaml</kbd> to bootstrap our RabbitMQ and MySQL containers. The file should look like this:</p>
<pre><span>version: </span><span>'3'<br/></span><span>services:<br/></span><span><br/></span><span>  rabbitmq:<br/></span><span>    hostname: </span>rabbitmq<br/>    <span>image: </span>rabbitmq:3.7.0-management-alpine<br/>    <span>ports:<br/></span><span>      </span>- <span>"5672:5672"<br/></span><span>      </span>- <span>"15672:15672"<br/></span><span>    </span><span>networks:<br/></span><span>      </span>- airline<br/><br/>  <span>mysql:<br/></span><span>    hostname: </span>mysql<br/>    <span>image: </span>mysql:5.7.21<br/>    <span>ports:<br/></span><span>      </span>- <span>"3306:3306"<br/></span><span>    </span><span>environment:<br/></span><span>      </span>- MYSQL_ROOT_PASSWORD=root<br/>      - MYSQL_DATABASE=zipkin<br/>    <span>networks:<br/></span><span>      </span>- airline<br/><br/>  <span>mongo:<br/></span><span>    hostname: </span>mongo<br/>    <span>image: </span>mongo<br/>    <span>ports:<br/></span><span>      </span>- <span>"27017:27017"<br/></span><span>    </span><span>networks:<br/></span><span>      </span>- airline  <br/><br/>  <span>redis:<br/></span><span>    hostname: </span>redis<br/>    <span>image: </span>redis:3.2-alpine<br/>    <span>ports:<br/></span><span>      </span>- <span>"6379:6379"<br/></span><span>    </span><span>networks:<br/></span><span>      </span>- airline<br/><br/><span>networks:<br/></span><span>  airline:<br/></span><span>    driver: </span>bridge</pre>
<div class="packt_tip">The <kbd>docker-compose-min.yaml</kbd> file can be found at <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-min.yaml">GitHub</a>, there is a MongoDB and Redis – they will be used in the next chapter.</div>
<p>There is nothing special here. We have declared two containers—RabbitMQ and MySQL— and exposed the ports on the host machine. Also, we have created the <kbd>airline</kbd> network; we will use this network to attach our infrastructure microservices.</p>
<p>Now, we can create our Zipkin server, which we will do in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Spring Cloud Zipkin server</h1>
                </header>
            
            <article>
                
<p>We will create our Zipkin panel structure in Spring Initializr, and then we need to follow the instructions:</p>
<div class="CDPAlignCenter CDPAlign"><img height="315" src="assets/3a1de65e-052f-4dd6-be13-97f188a67b43.png" width="637"/></div>
<p>Awesome – take a look at the <span class="packt_screen">Selected Dependencies</span> section, all of them are required. Pay attention to the Spring Boot version. We choose <kbd>1.5.9</kbd>, because there is no support for Zipkin server in Spring Boot 2. It is not a problem because we do not need specific features from Spring Boot 2.</p>
<p>Click on the <span class="packt_screen">Generate Project</span> button and wait for the download to finish. Afterwards, open the project in IDE.</p>
<p>In order to enable service discovery and store <kbd>Spans</kbd> on a database, we need to put the following dependencies in our <kbd>pom.xml</kbd>:</p>
<pre style="padding-left: 60px"><span>&lt;dependency&gt;<br/></span><span> &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span> &lt;artifactId&gt;</span><strong>spring-cloud-starter-netflix-eureka-client</strong><span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>&lt;dependency&gt;<br/></span><span> &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span> &lt;artifactId&gt;</span><strong>spring-boot-starter-jdbc</strong><span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>&lt;dependency&gt;<br/></span><span> &lt;groupId&gt;</span>mysql<span>&lt;/groupId&gt;<br/></span><span> &lt;artifactId&gt;</span><strong>mysql-connector-java</strong><span>&lt;/artifactId&gt;<br/></span><span> &lt;version&gt;</span>6.0.6<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>The first dependency is for the service discovery client and the others are to JDBC connections to MySQL. It makes our project dependencies fully configured. </p>
<p>Let's create our <kbd>main</kbd> class to start our Zipkin server. The class is pretty standard but with some new annotations:</p>
<pre style="padding-left: 60px"><span>package </span>springfive.airline<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.<span>EnableEurekaClient</span><span>;<br/></span><span>import </span>org.springframework.cloud.sleuth.zipkin.stream.<span>EnableZipkinStreamServer</span><span>;<br/></span><span><br/></span><span>@SpringBootApplication<br/></span><span><strong>@EnableZipkinStreamServer</strong><br/></span><span>@EnableEurekaClient<br/></span><span>public class </span>ZipkinServerApplication {<br/><br/> <span>public static void </span><span>main</span>(String[] args) {<br/>  SpringApplication.<span>run</span>(ZipkinServerApplication.<span>class, </span>args)<span>;<br/></span><span> </span>}<br/><br/>}</pre>
<p>The <kbd>@EnableEurekaClient</kbd> annotation enables the application to connect to the Eureka server. The new annotation, <kbd>@EnableZipkinStreamServer</kbd>, instructs the framework to connect with the configured broker to receive the <kbd>Spans</kbd>. Remember, it can be done using the Spring Cloud Stream Binder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring boostrap.yaml and application.yaml</h1>
                </header>
            
            <article>
                
<p>In the section, we created our <kbd>main</kbd> class. Before we run it, we should create our two configuration files. The <kbd>bootstrap.yaml</kbd> inside the <kbd>src/main/resources</kbd> directory and the <kbd>application.yaml</kbd> on our GitHub repository. They will be downloaded via Config Server and provided by the Zipkin server project.</p>
<p>Let's start with <kbd>bootstrap.yaml</kbd>:</p>
<pre style="padding-left: 60px"><span>spring:<br/></span><span>  application:<br/></span><span>    name: </span>zipkin<br/>  <span>cloud:<br/></span><span>    config:<br/></span><span>      uri: </span>http://localhost:5000<br/>      <span>label: </span>master</pre>
<p>Nothing special, we have configured our Config Server address.</p>
<p>Let's jump to our <kbd>application.yaml</kbd>:</p>
<pre style="padding-left: 60px">server:<br/>  port: 9999<br/><br/>spring:<br/>  rabbitmq:<br/>    port: 5672<br/>    host: localhost<br/>  datasource:<br/>    schema: classpath:/mysql.sql<br/>    url: jdbc:mysql://${MYSQL_HOST:localhost}/zipkin?autoReconnect=true<br/>    driver-class-name: com.mysql.cj.jdbc.Driver<br/>    username: root<br/>    password: root<br/>    initialize: true<br/>    continue-on-error: true<br/>  sleuth:<br/>    enabled: false<br/><br/>zipkin:<br/>  storage:<br/>    type: mysql<br/><br/>logging:<br/>  level:<br/>    ROOT: INFO<br/><br/>eureka:<br/>  client:<br/>    serviceUrl:<br/>      defaultZone: http://localhost:8761/eureka/</pre>
<p>There are some interesting things here. In the <kbd>spring.rabbitmq</kbd> node, we have configured our RabbitMQ broker connection. It will be used to receive <kbd>Spans</kbd>. In the <kbd>spring.datasource</kbd>, we have configured the MySQL connection. The Zipkin server will use it to store data. Also, we have configured how to execute the DDL script to create the <kbd>zipkin</kbd> database.</p>
<p>The <kbd>spring.sleuth</kbd> node was configured to not produce any <kbd>Span</kbd> because it is a server, not a client application, and we will not perform a trace on the Zipkin server.</p>
<p>The <kbd>zipkin</kbd> node had been used to configure the Zipkin server storage type, MySQL, in our case.</p>
<p>Let's run it!!!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Zipkin server</h1>
                </header>
            
            <article>
                
<p>We have configured the Zipkin server properly, so now we will be able to run it properly.</p>
<p>We can run the main class <kbd>ZipkinServerApplication</kbd>. We can use the IDE or Java command line, after running the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50e1605b-4111-45f1-b8aa-93de1ab85ee4.png"/></div>
<p>Good job – the Zipkin server is running now. We can take a look at the index page to see what it looks like. </p>
<p>Go to Zipkin page; the page should look like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="233" src="assets/1778b765-0f54-4c69-98f8-056a77cb4052.png" width="473"/></div>
<p>Also, we can check the RabbitMQ panel to find the queue created by the Zipkin server. Go to the RabbitMQ Queues (<kbd>http://localhost:15672/#/queues</kbd>) section, the page should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0df399b7-3aba-4bfc-ba86-d1c685e08c1d.png"/></div>
<p>Looking at the queues, the project has created the <kbd>sleuth.sleuth</kbd> queue, well done.</p>
<p>The Zipkin server is ready. For now, we will not have any <kbd>Span</kbd>, because there is no application sending data to Zipkin. We will do that in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Cloud Gateway</h1>
                </header>
            
            <article>
                
<p>The API Gateway pattern helps us to expose our microservices through a single known entrypoint. Usually, it acts as an entrypoint to external access and redirects the call to internal microservices.</p>
<p>There are many benefits when we adopt the API Gateway in our application. The first one can be recognized easily, it makes the API consumption easy for the clients, which means the clients do not need to know the different microservices endpoints.</p>
<p>Other benefits are a consequence of the first one. When we have a unique entrypoint, we can address some cross-application concerns such as filtering, authentication, throttling, and rate limit, as well.</p>
<p>It is an essential part when we adopt the microservices architecture. </p>
<p>The Spring Cloud Gateway enables us to have these features in a Spring-managed bean, in a Spring way using Dependency Injection and other features provided by the Spring Framework. </p>
<p>The project was built on the Spring Framework 5, which uses the Project Reactor as a basis. There are some interesting features provided, such as Hystrix Circuit Breaker integration and with the Spring Cloud Discovery client, as well. </p>
<p>Look at the diagram to understand the benefits of the API Gateway:</p>
<div class="CDPAlignCenter CDPAlign"><img height="227" src="assets/065a670f-fcd5-4050-b27b-f01aaaf076fd.png" width="395"/></div>
<div class="packt_infobox">The full documentation of the API Gateway Pattern can be found at: <a href="http://microservices.io/patterns/apigateway.html">http://microservices.io/patterns/apigateway.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Spring Cloud Gateway project</h1>
                </header>
            
            <article>
                
<p>We will use the Spring Initializr to create our Spring Cloud Gateway project; we will need to add some dependencies manually. Let's go to the <span class="packt_screen">Spring Initializr</span> page and create our project:</p>
<div class="CDPAlignCenter CDPAlign"><img height="367" src="assets/e2b1db6d-1650-42cc-a0c1-c3dd8626220e.png" width="639"/></div>
<p>There is a brand new dependency Gateway, it enables us to work with Spring Cloud Gateway. Then click on <span class="packt_screen">Generate Project</span> and wait for the download to complete.</p>
<p>After that, we need to add a missing dependency. The missing dependency is required by the Gateway to interact with the Eureka server; the name of the dependency is <kbd>spring-cloud-starter-netflix-eureka-client</kbd>. Then, let's add the dependency on our <kbd>pom.xml</kbd>, we will need to add the following snippet:</p>
<pre style="padding-left: 60px"><span>&lt;dependency&gt;<br/></span><span> &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span> &lt;artifactId&gt;</span><strong>spring-cloud-starter-netflix-eureka-client</strong><span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Excellent, our project is configured correctly to work with the Eureka server. In the following section, we will configure the project to work with the Config Server as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Spring Cloud Gateway main class</h1>
                </header>
            
            <article>
                
<p>There is no secret to this part. The Spring Cloud Gateway works in the same way as the common Spring Boot applications. There is a <kbd>main</kbd> class which will start the embedded server and starts the whole application.</p>
<p>Our <kbd>main</kbd> class should look like this:</p>
<pre style="padding-left: 60px"><span>package </span>springfive.airline.gateway<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.<span>EnableEurekaClient</span><span>;<br/></span><span><br/></span><strong>@EnableEurekaClient<br/></strong><span><strong>@SpringBootApplication</strong><br/></span><span>public class </span>GatewayApplication {<br/><br/> <span>public static void </span><span>main</span>(String[] args) {<br/>  SpringApplication.<span>run</span>(GatewayApplication.<span>class, </span>args)<span>;<br/></span><span> </span>}<br/><br/>}</pre>
<p>As we can see, it is a pretty standard Spring Boot application, configured with <kbd>@EnableEurekaClient</kbd> to work with the Eureka server as a service discovery implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Spring Cloud Gateway project</h1>
                </header>
            
            <article>
                
<p>The primary project structure is ready. We will create the project configurations in this section. To achieve this, we need to carry out the following steps:</p>
<ul>
<li>Add a <kbd>gateway.yaml</kbd> file to GitHub</li>
<li>Create the <kbd>bootstrap.yaml</kbd> in the Gateway project</li>
</ul>
<p>We are using the Spring Cloud Config Server, so it is necessary to create the new file in GitHub because the Config Server will try to find the file on the repository. In our case, we are using GitHub as a repository.</p>
<p>The second task is necessary because the <kbd>bootstrap.yaml</kbd> file is processed before the application is fully ready to run. Then, during this phase, the application needs to look up the configuration file and to achieve this, the application needs to know the <kbd>repository</kbd>, in our case, the Config Server. Remember the address of the Config Server always needs to be placed on the <kbd>bootstrap.yaml</kbd>.</p>
<p>Let's create our <kbd>gateway.yaml</kbd> file – the file should look like this:</p>
<pre style="padding-left: 60px">server:<br/>  port: 8888<br/>eureka:<br/>  client:<br/>    serviceUrl:<br/>      <strong>defaultZone: http://localhost:8761/eureka/</strong><br/>logging:<br/>  level: debug</pre>
<p>The <kbd>eureka.client</kbd> node in the YAML file is responsible for configuring the Eureka Client configurations. We need to configure our Eureka server address instance. It should be pointed to the correct address.</p>
<div class="packt_infobox">There are more options for the Eureka Configuration Client properties. The full documentation can be found in <a href="https://github.com/Netflix/eureka/wiki/Configuring-Eureka">https://github.com/Netflix/eureka/wiki/Configuring-Eureka</a>; the Netflix team maintains Eureka.</div>
<p>Then, we need to create our <kbd>bootstrap.yaml</kbd> file on the Gateway project. This file will instruct the Spring Framework to look up the configuration file on the Config Server and then download the required file to finish the application bootstrap. Our file should look like this:</p>
<pre style="padding-left: 60px"><span>spring:<br/></span><span>  application:<br/></span><span>      name: </span><strong>gateway</strong><br/>  <span>cloud:<br/></span><span>    config:<br/></span><span>      uri: </span><strong>http://localhost:5000</strong><br/>      <span>label: </span>master</pre>
<p>Pretty simple. The <kbd>application.name</kbd> is required to instruct the framework to look up the correct file. Usually, there are many configuration files for different applications and environments as well. </p>
<p>On the <kbd>cloud.config</kbd> node, we need to put in the Spring Cloud Config Server address, which we configured in the previous sections.</p>
<p>The project final structure should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="221" src="assets/da5891f8-5e3f-4cce-bc08-ecf657d48c3c.png" width="375"/></div>
<p>Look at the screenshot. There is no <kbd>application.yaml</kbd> in the classpath. This gives us several advantages; there is no configuration file in classpath projects, which helps us a great deal in managing the microservices configurations.</p>
<p>In the next section, we will run it and explain the whole application bootstrap process. Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Spring Cloud Gateway</h1>
                </header>
            
            <article>
                
<p>The project is well-configured, so now it is time to run it. <span>We can use the Java command line or IDE. There is no difference either way. </span></p>
<p>The Config Server and Eureka server need to stay up; it is mandatory that the Gateway project works correctly. Then, we can run the project.</p>
<p>Run the project and look at the logs. We can see some interesting stuff, such as the project connecting to the Config Server and download the configuration and after this, it connects to the Eureka server and self-registers. The following diagram explains the application bootstrap flow:</p>
<div class="CDPAlignCenter CDPAlign"><img height="147" src="assets/ba4406fe-ea05-49d0-b4e8-f229ce72a25b.png" width="297"/></div>
<p>Let's look at what the different flows are and understand them:</p>
<ol>
<li>The Gateway application requests the configuration file</li>
<li>The Config Server serves the config file</li>
<li>The Gateway application registers to the Eureka server</li>
</ol>
<p>Awesome, our Gateway application is connected to our infrastructure services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the Eureka server</h1>
                </header>
            
            <article>
                
<p>Our Gateway is running. Now, we can check the Eureka server page to confirm this information.</p>
<p>Go to <kbd>http://localhost:8761/</kbd>, and check the <span class="packt_screen">Instances currently registered with Eureka</span> section. We should see the Gateway application, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="372" src="assets/82aeb332-a6e7-4c16-b009-4145d35785d2.png" width="746"/></div>
<p>Excellent. It worked well. The Gateway application is successfully registered, and it can be looked up via the service discovery. Our Gateway will connect to the Eureka server to get the service available and distribute the requested calls to the correct services.</p>
<p>Well done. Now, we can create our routes in the Gateway. We will do this in the next chapter when we create our airline microservices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our first route with Spring Cloud Gateway</h1>
                </header>
            
            <article>
                
<p>Our Gateway is running. Before we start the real routes for our Airline application, let's try to use some fake routes to test the Spring Cloud Gateway behaviors. We will use the <a href="https://httpbin.org/">https://httpbin.org/</a> site, which helps us to test some routes.</p>
<p>Let's create a class with the <kbd>@Configuration</kbd> annotation to provide the routes for the Spring Container. Let's create a package called <kbd>springfive.airline.gateway.infra.route</kbd>, then create the following class:</p>
<pre><span>package </span>springfive.airline.gateway.infra.route<span>;<br/></span><span><br/></span><span><br/></span><span>import </span>java.util.function.Function<span>;<br/></span><span>import </span>org.springframework.cloud.gateway.route.RouteLocator<span>;<br/></span><span>import </span>org.springframework.cloud.gateway.route.builder.PredicateSpec<span>;<br/></span><span>import </span>org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder<span>;<br/></span><span>import </span>org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder.Builder<span>;<br/></span><span>import </span>org.springframework.context.annotation.<span>Bean</span><span>;<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration</span><span>;<br/></span><span><br/></span><span><strong>@Configuration</strong><br/></span><span>public class </span>SampleRoute {<br/><br/>  <span>private </span>Function&lt;PredicateSpec<span>, </span>Builder&gt; <span>addCustomHeader </span>= predicateSpec -&gt; predicateSpec<br/>      .path(<span>"/headers"</span>)<br/>      .addRequestHeader(<span>"Book"</span><span>, </span><span>"Spring 5.0 By Example"</span>)<br/>      .uri(<span>"http://httpbin.org:80"</span>)<span>;<br/></span><span><br/></span><span>  </span><span>@Bean<br/></span><span>  </span><span>public </span>RouteLocator <span>sample</span>(RouteLocatorBuilder builder) {<br/>    <span>return </span>builder.routes()<br/>        .route(<span>"custom-request-header"</span><span>, </span><span>addCustomHeader</span>)<br/>        .route(<span>"add-query-param"</span><span>, </span>r -&gt; r.path(<span>"/get"</span>).addRequestParameter(<span>"book"</span><span>, </span><span>"spring5.0"</span>)<br/>            .uri(<span>"http://httpbin.org:80"</span>))<br/>        .route(<span>"response-headers"</span><span>, </span>(r) -&gt; r.path(<span>"/response-headers"</span>)<br/>            .addResponseHeader(<span>"book"</span><span>,</span><span>"spring5.0"</span>)<br/>            .uri(<span>"http://httpbin.org:80"</span>))<br/>        .route(<span>"combine-and-change"</span><span>, </span>(r) -&gt; r.path(<span>"/anything"</span>).and().header(<span>"access-key"</span><span>,</span><span>"AAA"</span>)<br/>            .addResponseHeader(<span>"access-key"</span><span>,</span><span>"BBB"</span>)<br/>            .uri(<span>"http://httpbin.org:80"</span>))<br/>        .build()<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>There are some different types to configure routes; the first one we extracted is the function to a private attribute called <kbd>addCustomHeader,</kbd> which will be used in the <kbd>custom-request-header</kbd> route. We will use <strong>curl</strong> to test some routes created previously.</p>
<p>The first one we will test is the <kbd>custom-request-header,</kbd> the route was configured to route to: <a href="http://httpbin.org:80">http://httpbin.org:80</a> and the path will be <kbd>/headers</kbd>. This service will return the Request Headers sent to the server. Take a look at <kbd>addCustomHeader</kbd>, we have configured it to add a custom header to the Request. It will be <span class="packt_screen">Book</span> as the key and <span class="packt_screen">Spring 5.0 By Example,</span> as the value. Let's call the gateway URL, using curl:</p>
<pre><strong>curl http://localhost:8888/headers</strong></pre>
<p>The output should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="136" src="assets/5a229878-be00-48f8-b602-2408154f73f4.png" width="237"/></div>
<p>Let's analyze the output. The first thing to look at is we have called the localhost address. The <kbd>Host</kbd> key in the Request shows <kbd>httpbin.org</kbd>, it means the Spring Cloud Gateway has changed the address. Awesome, but we expected it. The second one is where we have added the <kbd>Book</kbd> key, and bingo, there it is in the Request Headers. The Gateway worked as expected, and with a few lines of code, we did some interesting stuff.</p>
<p>Let's do one more test. We will test the <kbd>combine-and-change</kbd>, this route is configured to answer the <kbd>/anything</kbd> with the Request <kbd>Header access-key: AAA</kbd>, so the command line should be:</p>
<pre>curl -v -H "access-key: AAA" http://localhost:8888/anything</pre>
<p>As we can see, the <kbd>-v</kbd> argument makes the call in verbose mode, it is useful for debugging purposes and the <kbd>-H</kbd> indicates the Request Headers. Let's look at the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="422" src="assets/d56c40a7-0a13-4f87-ac89-69bf9f651202.png" width="293"/></div>
<p>Awesome. If you look at the <kbd>access-key</kbd> value, the Gateway changed to a requested value <kbd>BBB</kbd>. Good job guys. There are some endpoints to test, feel free to test as you want.</p>
<div class="packt_tip"><span>You can find the httpbin documentation at: </span><a href="https://httpbin.org/">https://httpbin.org/</a><span>. There are some interesting other methods to test HTTP. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting the infrastructure on Docker</h1>
                </header>
            
            <article>
                
<p>Our infrastructure is ready and it enables us to develop the application. We can create a Docker compose file to spin up the infrastructure services; during the development life cycle, components such as Eureka, Config Server, Trace Server, and API Gateway do not suffer changes because they interact as an infrastructure.</p>
<p>Then, it enables us to create component images and use them in the <kbd>docker-compose.yaml</kbd> file. Let's list our components:</p>
<ul>
<li>Config Server</li>
<li>Eureka</li>
<li>Zipkin</li>
<li>RabbitMQ</li>
<li>Redis</li>
</ul>
<p>We know how to create Docker images using the Fabric8 Maven plugin, we have done this several times in the previous chapters – let's do it.</p>
<p>Let's configure one as an example, keep in mind we need do the same configuration for all projects, Eureka, Gateway, Config Server, and Gateway. The following snippet configures the <kbd>docker-maven-plugin</kbd> to generate a Docker image:</p>
<pre><span>&lt;plugin&gt;<br/></span><span>  &lt;groupId&gt;</span>io.fabric8<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>docker-maven-plugin<span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>0.21.0<span>&lt;/version&gt;<br/></span><span>  &lt;configuration&gt;<br/></span><span>    &lt;images&gt;<br/></span><span>      &lt;image&gt;<br/></span><span>        &lt;name&gt;</span>springfivebyexample/${project.build.finalName}<span>&lt;/name&gt;<br/></span><span>        &lt;build&gt;<br/></span><span>          &lt;from&gt;</span>openjdk:latest<span>&lt;/from&gt;<br/></span><span>          &lt;entryPoint&gt;</span>java -Dspring.profiles.active=docker -jar /application/${project.build.finalName}.jar<span>&lt;/entryPoint&gt;<br/></span><span>          &lt;assembly&gt;<br/></span><span>            &lt;basedir&gt;</span>/application<span>&lt;/basedir&gt;<br/></span><span>            &lt;descriptorRef&gt;</span>artifact<span>&lt;/descriptorRef&gt;<br/></span><span>            &lt;inline&gt;<br/></span><span>              &lt;id&gt;</span>assembly<span>&lt;/id&gt;<br/></span><span>              &lt;files&gt;<br/></span><span>                &lt;file&gt;<br/></span><span>                  &lt;source&gt;</span>target/${project.build.finalName}.jar<span>&lt;/source&gt;<br/></span><span>                &lt;/file&gt;<br/></span><span>              &lt;/files&gt;<br/></span><span>            &lt;/inline&gt;<br/></span><span>          &lt;/assembly&gt;<br/></span><span>          &lt;tags&gt;<br/></span><span>            &lt;tag&gt;</span>latest<span>&lt;/tag&gt;<br/></span><span>          &lt;/tags&gt;<br/></span><span>          &lt;ports&gt;<br/></span><span>            &lt;port&gt;</span>8761<span>&lt;/port&gt;<br/></span><span>          &lt;/ports&gt;<br/></span><span>        &lt;/build&gt;<br/></span><span>        &lt;run&gt;<br/></span><span>          &lt;namingStrategy&gt;</span>alias<span>&lt;/namingStrategy&gt;<br/></span><span>        &lt;/run&gt;<br/></span><span>        &lt;alias&gt;</span>${project.build.finalName}<span>&lt;/alias&gt;<br/></span><span>      &lt;/image&gt;<br/></span><span>    &lt;/images&gt;<br/></span><span>  &lt;/configuration&gt;<br/></span><span>&lt;/plugin&gt;</span></pre>
<p>It is a pretty simple configuration. A simple Maven plugin with a couple of configurations. Then, after the plugin configuration, we are able to generate the Docker image. The command to generate Docker images is:</p>
<pre><strong>mvn clean install docker:build</strong></pre>
<p>It will generate a Docker image for us.</p>
<p>The projects configured can be found on GitHub; there are so many configurations to do as in the previous chapters. We need to configure the <kbd>docker-maven-plugin</kbd> and generate the Docker images.</p>
<div class="packt_tip">Fully configured projects can be found in the chapter seven folder. The GitHub repository is: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07.</a></div>
<p>After the images have been created, we are able to create a Docker compose file defining the whole thing. The <kbd>docker-compose-infra-full.yaml</kbd> file should look like this:</p>
<pre><span>version: </span><span>'3'<br/></span><span>services:<br/></span><span><br/></span><span>  config:<br/></span><span>    hostname: </span>config<br/>    <span>image: </span>springfivebyexample/config<br/>    <span>ports:<br/></span><span>      </span>- <span>"5000:5000"<br/></span><span>    </span><span>networks:<br/></span><span>      </span>- airline<br/>      <br/>  <span>rabbitmq:<br/></span><span>    hostname: </span>rabbitmq<br/>    <span>image: </span>rabbitmq:3.7.0-management-alpine<br/>    <span>ports:<br/></span><span>      </span>- <span>"5672:5672"<br/></span><span>      </span>- <span>"15672:15672"<br/></span><span>    </span><span>networks:<br/></span><span>      </span>- airline<br/>      <br/>  <span>mysql:<br/></span><span>    hostname: </span>mysql<br/>    <span>image: </span>mysql:5.7.21<br/>    <span>ports:<br/></span><span>      </span>- <span>"3306:3306"<br/></span><span>    </span><span>environment:<br/></span><span>      </span>- MYSQL_ROOT_PASSWORD=root<br/>      - MYSQL_DATABASE=zipkin<br/>    <span>networks:<br/></span><span>      </span>- airline<br/>      <br/>  <span>redis:<br/></span><span>    hostname: </span>redis<br/>    <span>image: </span>redis:3.2-alpine<br/>    <span>ports:<br/></span><span>      </span>- <span>"6379:6379"<br/></span><span>    </span><span>networks:<br/></span><span>      </span>- airline<br/><br/>  <span>zipkin:<br/></span><span>    hostname: </span>zipkin<br/>    <span>image: </span>springfivebyexample/zipkin<br/>    <span>ports:<br/></span><span>      </span>- <span>"9999:9999"<br/></span><span>    </span><span>networks:<br/></span><span>      </span>- airline<br/>      <br/><span>networks:<br/></span><span>  airline:<br/></span><span>    driver: </span>bridge</pre>
<p>There are some interesting things to pay attention to here. I<span>t is very important that a</span><span>ll container instances are attached to the same Docker network called</span> <kbd>airline</kbd><span>. Pay attention to the ports exposed by the containers, it is important to enable service discovery features in Docker.</span></p>
<p>Then, we can execute the instruction to spin up the whole infrastructure; it can be done using the following command:</p>
<pre><strong>docker-compose -f docker-compose-infra-full.yaml up -d</strong></pre>
<p>The following output should appear:</p>
<div class="CDPAlignCenter CDPAlign"><img height="105" src="assets/09f31f0c-c06b-4f64-a449-958fd0af2308.png" width="348"/></div>
<p>Also, we can execute the following instruction to check the container's execution:</p>
<pre><strong>docker-compose -f docker-compose-infra-full.yaml ps</strong></pre>
<p>It will list the running containers, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="96" src="assets/bdedb2b7-8516-4db5-8d80-9677cb87ca6c.png" width="795"/></div>
<p>All applications are up and running. Well done.</p>
<p>To remove the containers, we can use:</p>
<pre><strong>docker-compose -f docker-compose-infra-full.yaml down</strong></pre>
<p>It will remove the containers from the stack.</p>
<p>Excellent job, our infrastructure is fully operational in Docker containers. It is a base for starting to create our microservices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have built the essential infrastructures services adopting the microservices architectural style. </p>
<p>We have learned how Spring Framework eliminates the infrastructure code from our microservices and enables us to create these services, using a couple of annotations.</p>
<p>We understand how it works under the hood; it is extremely important to debug and troubleshoot when the application gets some errors in the production stage.</p>
<p>Now, we are ready to create scalable, fault tolerant, and responsive systems. We have built the foundations of our system.</p>
<p>In the next chapter, we will start to build our Airline Ticket System, understand how to connect the new microservices with the whole infrastructure, and enable service discovery and other amazing features.</p>
<p>See you there.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>