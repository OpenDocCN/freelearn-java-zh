["```java\napplication.global=app.com.org.AppSettings\n```", "```java\nclass DefaultApplication(\n  override val path: File,\n  override val classloader: ClassLoader,\n  override val sources: Option[SourceMapper],\n  override val mode: Mode.Mode) extends Application with WithDefaultConfiguration with WithDefaultGlobal with WithDefaultPlugins\n```", "```java\ntrait WithDefaultGlobal { \n  self: Application with WithDefaultConfiguration => \n\n  private lazy val globalClass = initialConfiguration.getString(\"application.global\").getOrElse(initialConfiguration.getString(\"global\").map { g => \n Play.logger.warn(\"`global` key is deprecated, please change `global` key to `application.global`\") \n g \n }.getOrElse(\"Global\")) \n\n  lazy private val javaGlobal: Option[play.GlobalSettings] = try { \n    Option(self.classloader.loadClass(globalClass).newInstance().asInstanceOf[play.GlobalSettings]) \n  } catch { \n    case e: InstantiationException => None \n    case e: ClassNotFoundException => None \n  } \n\n  lazy private val scalaGlobal: GlobalSettings = try { \n    self.classloader.loadClass(globalClass + \"$\").getDeclaredField(\"MODULE$\").get(null).asInstanceOf[GlobalSettings] \n  } catch { \n   case e: ClassNotFoundException if !initialConfiguration.getString(\"application.global\").isDefined => DefaultGlobal \n    case e if initialConfiguration.getString(\"application.global\").isDefined => { \n      throw initialConfiguration.reportError(\"application.global\", s\"Cannot initialize the custom Global object ($globalClass) (perhaps it's a wrong reference?)\", Some(e)) \n    } \n  } \n\n  private lazy val globalInstance: GlobalSettings = Threads.withContextClassLoader(self.classloader) { \n try { \n javaGlobal.map(new j.JavaGlobalSettingsAdapter(_)).getOrElse(scalaGlobal) \n } catch { \n case e: PlayException => throw e \n case e: ThreadDeath => throw e \n case e: VirtualMachineError => throw e \n case e: Throwable => throw new PlayException( \n \"Cannot init the Global object\", \n e.getMessage, \n e \n ) \n } \n } \n\n  def global: GlobalSettings = { \n    globalInstance \n  } \n}\n```", "```java\nobject DefaultGlobal extends GlobalSettings\n```", "```java\nclass NettyServer(appProvider: ApplicationProvider, port: Option[Int], sslPort: Option[Int] = None, address: String = \"0.0.0.0\", val mode: Mode.Mode = Mode.Prod) extends Server with ServerWithStop { â€¦ }\n```", "```java\ntrait ApplicationProvider {\n  def path: File\n  def get: Try[Application]\n  def handleWebCommand(requestHeader: play.api.mvc.RequestHeader): Option[Result] = None\n}\n```", "```java\nclass StaticApplication(applicationPath: File) extends ApplicationProvider {\n\n  val application = new DefaultApplication(applicationPath, this.getClass.getClassLoader, None, Mode.Prod)\n\n  Play.start(application)\n\n  def get = Success(application)\n  def path = applicationPath\n}\n```", "```java\nclass ReloadableApplication(buildLink: BuildLink, buildDocHandler: BuildDocHandler) extends ApplicationProvider {\n...\n// First, stop the old application if it exists\n    Play.stop()\n\n    val newApplication = new DefaultApplication(reloadable.path, projectClassloader, Some(new SourceMapper {\n        def sourceOf(className: String, line: Option[Int]) = {\n          Option(buildLink.findSource(className, line.map(_.asInstanceOf[java.lang.Integer]).orNull)).flatMap {\n            case Array(file: java.io.File, null) => Some((file, None))\n            case Array(file: java.io.File, line: java.lang.Integer) => Some((file, Some(line)))\n            case _ => None\n            }\n          }\n              }), Mode.Dev) with DevSettings {\n                import scala.collection.JavaConverters._\n                lazy val devSettings: Map[String, String] = buildLink.settings.asScala.toMap\n              }\n\n              Play.start(newApplication)\n...\n}\n```", "```java\nval appProvider = new ReloadableApplication(buildLink, buildDocHandler)\nval server = new NettyServer(appProvider, httpPort, httpsPort, mode = Mode.Dev)\n```", "```java\nobject Global extends GlobalSettings {\n\n  override def beforeStart(app: Application): Unit = {\n    ResourceHandler.initialize\n  }\n\n  override def onStart(app: Application):Unit={\n    DBHandler.createSchema\n  }\n\n  override def onStop(app: Application): Unit = {\n    Mailer.sendLogs\n  }\n}\n```", "```java\ndef start(app: Application) {\n\n    // First stop previous app if exists\n    stop()\n\n    _currentApp = app\n\n    // Ensure routes are eagerly loaded, so that the reverse routers are correctly\n    // initialized before plugins are started.\n    app.routes\n    Threads.withContextClassLoader(classloader(app)) {\n      app.plugins.foreach(_.onStart())\n    }\n\n    app.mode match {\n      case Mode.Test =>\n      case mode => logger.info(\"Application started (\" + mode + \")\")\n    }\n\n  }\n```", "```java\nclass GlobalPlugin(app: Application) extends Plugin {\n\n  // Call before start now\n  app.global.beforeStart(app)\n\n  // Called when the application starts.\n  override def onStart() {\n    app.global.onStart(app)\n  }\n\n  //Called when the application stops.\n  override def onStop() {\n    app.global.onStop(app)\n  }\n\n}\n```", "```java\nRuntime.getRuntime.addShutdownHook(new Thread { \n override def run { \n server.stop() \n } \n })\n\n```", "```java\noverride def stop() {\n\n    try {\n      Play.stop()\n    } catch {\n      case NonFatal(e) => Play.logger.error(\"Error while stopping the application\", e)\n    }\n\n    try {\n      super.stop()\n    } catch {\n      case NonFatal(e) => Play.logger.error(\"Error while stopping logger\", e)\n    }\n\n    mode match {\n      case Mode.Test =>\n      case _ => Play.logger.info(\"Stopping server...\")\n    }\n\n    // First, close all opened sockets\n    allChannels.close().awaitUninterruptibly()\n\n    // Release the HTTP server\n    HTTP.foreach(_._1.releaseExternalResources())\n\n    // Release the HTTPS server if needed\n    HTTPS.foreach(_._1.releaseExternalResources())\n\n    mode match {\n      case Mode.Dev =>\n        Invoker.lazySystem.close()\n        Execution.lazyContext.close()\n      case _ => ()\n    }\n  }\n```", "```java\n def stop() {\n    Option(_currentApp).map { app =>\n      Threads.withContextClassLoader(classloader(app)) {\n        app.plugins.reverse.foreach { p =>\n try {\n p.onStop()\n } catch { case NonFatal(e) => logger.warn(\"Error stopping plugin\", e) }\n }\n      }\n    }\n    _currentApp = null\n  }\n```", "```java\nval defaultUpStreamHandler = new PlayDefaultUpstreamHandler(this, allChannels)\n```", "```java\nval (requestHeader, handler: Either[Future[Result], (Handler, Application)]) = Exception.allCatch[RequestHeader].either {\n    val rh = tryToCreateRequest\n            // Force parsing of uri\n            rh.path\n            rh\n          }.fold(\n            e => {\n              //Exception Handling\n              ...\n            },\n            rh => server.getHandlerFor(rh) match {\n              case directResult @ Left(_) => (rh, directResult)\n              case Right((taggedRequestHeader, handler, application)) => (taggedRequestHeader, Right((handler, application)))\n            }\n          )\n```", "```java\ntry {\n        applicationProvider.get.map { application =>\n application.global.onRequestReceived(request) match {\n case (requestHeader, handler) => (requestHeader, handler, application)\n }\n }\n      } catch {\n  //Exception Handling\n...\n}\n```", "```java\ndef onRequestReceived(request: RequestHeader): (RequestHeader, Handler) = {\n    val notFoundHandler = Action.async(BodyParsers.parse.empty)(this.onHandlerNotFound)\n    val (routedRequest, handler) = onRouteRequest(request) map {\n      case handler: RequestTaggingHandler => (handler.tagRequest(request), handler)\n      case otherHandler => (request, otherHandler)\n    } getOrElse {\n    // We automatically permit HEAD requests against any GETs without the need to\n      // add an explicit mapping in Routes\n      val missingHandler: Handler = request.method match {\n        case HttpVerbs.HEAD =>\n          new HeadAction(onRouteRequest(request.copy(method = HttpVerbs.GET)).getOrElse(notFoundHandler))\n        case _ =>\n          notFoundHandler\n      }\n      (request, missingHandler)\n    }\n\n    (routedRequest, doFilter(rh => handler)(routedRequest))\n  }\n```", "```java\ndef onRouteRequest(request: RequestHeader): Option[Handler] = Play.maybeApplication.flatMap(_.routes.flatMap {\n    router =>\n      router.handlerFor(request)\n  })\n```", "```java\noverride def onRouteRequest(requestHeader: RequestHeader) = {\n    val path = requestHeader.path\n\n    val pathConditions = path.equals(\"/\") ||\n      path.startsWith(\"/register\") ||\n      path.startsWith(\"/login\") ||\n      path.startsWith(\"/forgot\")\n\n   if (!pathConditions) {\n      val tokenId = requestHeader.headers.get(\"Auth-Token\")\n      val userId = requestHeader.headers.get(\"Auth-User\")\n      if (tokenId.isDefined && userId.isDefined) {\n        val isValidSession = SessionDetails.validateSession(SessionDetails(userId.get.toLong, tokenId.get))\n        if (isValidSession) {\n          super.onRouteRequest(request)\n        }\n        else Some(controllers.SessionController.invalidSession)\n      }\n      else {\n        Some(controllers.SessionController.invalidSession)\n      }\n    }\n    else {\n      super.onRouteRequest(request)\n    }\n  }\n```", "```java\noverride def onRouteRequest(requestHeader: RequestHeader) = {\n  val path = requestHeader.path\n\n  val actualPath = getSupportedPath(path)\n  val customRequestHeader = requestHeader.copy(path = actualPath)\n\n  super.onRouteRequest(customRequestHeader)\n}\n```", "```java\nobject Global extends GlobalSettings {\n  override def doFilter(action: EssentialAction): EssentialAction = HeadersFilter.noCache(action)\n}\n```", "```java\nobject Global extends WithFilters(new CSRFFilter()) with GlobalSettings\n```", "```java\nclass WithFilters(filters: EssentialFilter*) extends GlobalSettings {\n  override def doFilter(a: EssentialAction): EssentialAction = {\n    Filters(super.doFilter(a), filters: _*)\n  }\n}\n```", "```java\noverride def onRequestCompletion(requestHeader: RequestHeader) {\n  if(requestHeader.path.startsWith(\"/search\")){\n    //code to persist request parameters, time, etc\n  }}\n```", "```java\n  def onError(request: RequestHeader, ex: Throwable): Future[Result] = {\n    def devError = views.html.defaultpages.devError(Option(System.getProperty(\"play.editor\"))) _\n    def prodError = views.html.defaultpages.error.f\n    try {\n      Future.successful(InternalServerError(Play.maybeApplication.map {\n        case app if app.mode == Mode.Prod => prodError\n        case app => devError\n      }.getOrElse(devError) {\n        ex match {\n          case e: UsefulException => e\n          case NonFatal(e) => UnexpectedException(unexpected = Some(e))\n        }\n      }))\n    } catch {\n      case NonFatal(e) => {\n        Logger.error(\"Error while rendering default error page\", e)\n        Future.successful(InternalServerError)\n      }\n    }\n  }\n```", "```java\noverride def onError(request: RequestHeader, ex: Throwable) = {\n  log.error(ex)\n  InternalServerError(ex.getMessage)\n}\n```", "```java\ndef onHandlerNotFound(request: RequestHeader): Future[Result] = {\n  Future.successful(NotFound(Play.maybeApplication.map {\n    case app if app.mode != Mode.Prod => views.html.defaultpages.devNotFound.f\n    case app => views.html.defaultpages.notFound.f\n  }.getOrElse(views.html.defaultpages.devNotFound.f)(request, Play.maybeApplication.flatMap(_.routes))))\n  }\n```", "```java\ndef onBadRequest(request: RequestHeader,\n  error: String): Future[Result] = {\n    Future.successful(BadRequest(views.html.defaultpages.badRequest(request, error)))\n}\n```", "```java\nimport play.api.mvc.{Result, RequestHeader,Results}\n override def onBadRequest(request: RequestHeader,\n                           error: String): Future[Result] = {\n    Future{\n      Results.BadRequest(error)\n    }\n  }\n```"]