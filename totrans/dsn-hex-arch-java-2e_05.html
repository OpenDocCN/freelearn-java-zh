<html><head></head><body>
<div id="_idContainer045">
<h1 class="chapter-number" id="_idParaDest-82"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-83"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.2.1">Exploring the Nature of Driving and Driven Operations</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We spent the previous chapters analyzing the elements comprising each hexagon in the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">hexagonal architecture</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">We learned about entities, value objects, and business rules, and how to arrange them in the Domain hexagon to create a meaningful domain model. </span><span class="koboSpan" id="kobo.5.3">After that, when dealing with the Application hexagon, we learned how to utilize use cases and ports to create fully fledged software features on top of the domain model. </span><span class="koboSpan" id="kobo.5.4">Finally, we learned how to create adapters to integrate the hexagonal application features with </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">different technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">To better comprehend a hexagonal system, we also need to be aware of its surroundings. </span><span class="koboSpan" id="kobo.7.2">That’s why, in this chapter, we explore the nature of driving and driven operations, as they represent the external elements interacting with the hexagonal application. </span><span class="koboSpan" id="kobo.7.3">On the driving side, we’ll see how frontend applications act as primary actors, driving the behavior of a hexagonal system. </span><span class="koboSpan" id="kobo.7.4">On the driven side, we will learn what is necessary to enable a message-based system to be driven by a </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Reaching the hexagonal application with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">driving operations</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Integrating web applications with the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">hexagonal system</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Running test agents and calling the hexagonal system from </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">other applications</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Handling external resources with </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">driven operations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">By the end of this chapter, you will know the most common driving and driven operations. </span><span class="koboSpan" id="kobo.19.2">Once you understand these operations and how they influence the inner structure of a hexagonal system, you’ll have learned all the building blocks of the hexagonal architecture, enabling you to develop complete hexagonal applications while leveraging all the techniques presented </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">so far.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">To compile and run the code examples presented in this chapter, you need the  </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.25.1">JDK</span></strong><span class="koboSpan" id="kobo.26.1">) (version 17 or higher) and </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.28.1"> installed on your computer. </span><span class="koboSpan" id="kobo.28.2">They are all available for </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">Linux</span></strong><span class="koboSpan" id="kobo.30.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Mac</span></strong><span class="koboSpan" id="kobo.32.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Windows</span></strong><span class="koboSpan" id="kobo.34.1"> operating systems. </span><span class="koboSpan" id="kobo.34.2">You will also need to download these tools: </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Postman</span></strong><span class="koboSpan" id="kobo.36.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">Newman</span></strong><span class="koboSpan" id="kobo.38.1"> (from </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">npm</span></strong><span class="koboSpan" id="kobo.40.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">Kafka</span></strong><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">We recommend using Linux to run Kafka properly. </span><span class="koboSpan" id="kobo.42.3">If you’re using a Windows system, you can use </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Windows Subsystem for Linux</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">WSL</span></strong><span class="koboSpan" id="kobo.46.1">) to </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">run Kafka.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">You can download the latest version of Kafka </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">from </span></span><a href="https://kafka.apache.org/downloads.html"><span class="No-Break"><span class="koboSpan" id="kobo.50.1">https://kafka.apache.org/downloads.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">You can download the latest version of Postman </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">from </span></span><a href="https://www.postman.com/downloads"><span class="No-Break"><span class="koboSpan" id="kobo.54.1">https://www.postman.com/downloads</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.55.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">You can download the latest version of Newman </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">from </span></span><a href="https://www.npmjs.com/package/newman"><span class="No-Break"><span class="koboSpan" id="kobo.58.1">https://www.npmjs.com/package/newman</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.59.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">You can find the code files for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">on GitHub:</span></span></p>
<p><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.62.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05</span></span></a></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.63.1">Reaching the hexagonal application with driving operations</span></h1>
<p><span class="koboSpan" id="kobo.64.1">We may </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.65.1">consider it inconceivable</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.66.1"> that a system can be self-contained in the sense that no one interacts with it and that this system doesn’t interact with other users or systems. </span><span class="koboSpan" id="kobo.66.2">Such an arrangement goes against the fundamentals of computer architecture (von Neumann, 1940), which presume the presence of input and output operations in any computer system. </span><span class="koboSpan" id="kobo.66.3">Indeed, it’s difficult to imagine a useful software program that doesn’t receive any data or produce </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">any result.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Through the lens of the hexagonal architecture, the input side of a system is controlled by driving operations. </span><span class="koboSpan" id="kobo.68.2">We call them </span><em class="italic"><span class="koboSpan" id="kobo.69.1">driving operations</span></em><span class="koboSpan" id="kobo.70.1"> because they actually initiate and drive the behavior of a </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">hexagonal application.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">In </span><a href="B19777_03.xhtml#_idTextAnchor066"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.74.1">, </span><em class="italic"><span class="koboSpan" id="kobo.75.1">Handling Behavior with Ports and Use Cases</span></em><span class="koboSpan" id="kobo.76.1">, we related driving operations to primary actors. </span><span class="koboSpan" id="kobo.76.2">These actors are in charge of triggering driving operations in the hexagonal system. </span><span class="koboSpan" id="kobo.76.3">The driving operations can assume different facets: they can be users interacting directly with the system through a command-line console, a web </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">User Interface</span></strong><span class="koboSpan" id="kobo.78.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.79.1">UI</span></strong><span class="koboSpan" id="kobo.80.1">) application requesting data to present it in a browser, a testing agent wanting to validate a specific test case, or any other system interested in the features exposed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">hexagonal application.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">All these </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.83.1">different facets are grouped on </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.84.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">driving side</span></strong><span class="koboSpan" id="kobo.86.1">, as shown </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.87.1">in the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 5.1 – The driving side and the hexagonal application" src="image/B19777_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 5.1 – The driving side and the hexagonal application</span></p>
<p><span class="koboSpan" id="kobo.91.1">We saw, in </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.92.1">the previous chapter, how to interact with a hexagonal application using a </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Command-Line Interface</span></strong><span class="koboSpan" id="kobo.94.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.95.1">CLI</span></strong><span class="koboSpan" id="kobo.96.1">) and through </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">HTTP REST</span></strong><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">Now, we’ll</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.99.1"> explore how to integrate other types of driving operations to communicate with the topology and inventory system we’ve been developing </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Once we have these integrations in place, we will analyze the path a request needs to take in order to traverse all the hexagons until it reaches the Domain one. </span><span class="koboSpan" id="kobo.101.2">This exercise will help us to understand the role played by each hexagon and its components in processing the request of a driving operation. </span><span class="koboSpan" id="kobo.101.3">So, let’s start by integrating a web UI with the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">hexagonal system.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.103.1">Integrating web applications with the hexagonal system</span></h1>
<p><span class="koboSpan" id="kobo.104.1">Nowadays, with</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.105.1"> the advent of </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">HTML</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.107.1">5</span></strong><span class="koboSpan" id="kobo.108.1">, modern </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">JavaScript</span></strong><span class="koboSpan" id="kobo.110.1">, and </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.111.1">continuously</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.112.1"> improving</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.113.1"> web development techniques, it’s possible to build highly sophisticated systems that run directly from the web browser. </span><span class="koboSpan" id="kobo.113.2">Faster internet connections, more computational resources, and better and well-established web standards have all contributed to the</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.114.1"> improvement of web applications. </span><span class="koboSpan" id="kobo.114.2">The old and cluttered </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">Flash</span></strong><span class="koboSpan" id="kobo.116.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">Java applet</span></strong><span class="koboSpan" id="kobo.118.1">-based </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.119.1">systems, for example, have been replaced by frontend applications </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.120.1">based </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.121.1">on </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.122.1">fancy frameworks such as </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Angular</span></strong><span class="koboSpan" id="kobo.124.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">React</span></strong><span class="koboSpan" id="kobo.126.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.128.1">Vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Not only has the technology evolved and changed, but the practices surrounding web development have evolved too. </span><span class="koboSpan" id="kobo.130.2">Encouraged </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.131.1">by the </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.133.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.134.1">MVC</span></strong><span class="koboSpan" id="kobo.135.1">) pattern, developers used to group presentation code with business logic in a single software unit. </span><span class="koboSpan" id="kobo.135.2">The MVC’s purpose has been to establish clear boundaries between different categories of components – model, view, and controller – in an application. </span><span class="koboSpan" id="kobo.135.3">But because the presentation and business code were most often part of the same software project and assembled into the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">.ear</span></strong><span class="koboSpan" id="kobo.137.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">.war</span></strong><span class="koboSpan" id="kobo.139.1"> package file, it wasn’t rare to see that the business logic had leaked into the </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">presentation code.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.141.1">Java EE</span></strong><span class="koboSpan" id="kobo.142.1"> (now </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Jakarta EE</span></strong><span class="koboSpan" id="kobo.144.1">) and </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.145.1">other frameworks, such as </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">Struts</span></strong><span class="koboSpan" id="kobo.147.1">, utilized</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.148.1"> technologies </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.149.1">such </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.150.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">Servlets</span></strong><span class="koboSpan" id="kobo.152.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">JSP</span></strong><span class="koboSpan" id="kobo.154.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">JSF</span></strong><span class="koboSpan" id="kobo.156.1"> to allow</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.157.1"> full</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.158.1"> integration between presentation and business code. </span><span class="koboSpan" id="kobo.158.2">After some time, people started to realize that this practice of putting frontend and backend code too close to each other could be a source of entropy for their </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">software projects.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">As a response to such practices, the industry turned to decoupled architectures where the frontend system is a separate, standalone application that interacts via the network with one or more </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">backend systems.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">So, we will create a simple, standalone frontend application that obtains its data from our topology and inventory system. </span><span class="koboSpan" id="kobo.162.2">Our application will be based only on HTML 5, CSS, and </span><em class="italic"><span class="koboSpan" id="kobo.163.1">vanilla</span></em><span class="koboSpan" id="kobo.164.1"> JavaScript. </span><span class="koboSpan" id="kobo.164.2">The application aims to allow users to add networks to a router and retrieve existing routers from the system database. </span><span class="koboSpan" id="kobo.164.3">We will also refactor part of the hexagonal application to enable better integration with our frontend application. </span><span class="koboSpan" id="kobo.164.4">The result will be a web browser application integrated with the hexagonal system, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.166.1"><img alt="Figure 5.2 – The Topology &amp; Inventory frontend application" src="image/B19777_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">Figure 5.2 – The Topology &amp; Inventory frontend application</span></p>
<p><span class="koboSpan" id="kobo.168.1">The frontend </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.169.1">application will allow</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.170.1"> users to add networks to an existing router and view a graphical representation of the router and </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">its networks.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Let’s start enhancing the hexagonal application by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">getRouter</span></strong><span class="koboSpan" id="kobo.174.1"> method to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">RouterNetworkUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
public interface RouterNetworkUseCase {
    Router addNetworkToRouter(RouterId,
    Network network);
    Router getRouter</span><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.178.1">(RouterId routerId);
}</span></pre> <p><span class="koboSpan" id="kobo.179.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">getRouter</span></strong><span class="koboSpan" id="kobo.181.1"> method signature is simple. </span><span class="koboSpan" id="kobo.181.2">It receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">RouterId</span></strong><span class="koboSpan" id="kobo.183.1"> and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Router</span></strong><span class="koboSpan" id="kobo.185.1"> object. </span><span class="koboSpan" id="kobo.185.2">We need this behavior to allow the frontend application to display </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">a router.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Next, we need to provide an implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">getRouter</span></strong><span class="koboSpan" id="kobo.189.1"> method. </span><span class="koboSpan" id="kobo.189.2">We do that by</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.190.1"> implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">RouterNetworkUseCase</span></strong><span class="koboSpan" id="kobo.192.1"> interface</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.193.1"> with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">RouterNetworkInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
public class RouterNetworkInputPort implements RouterNet
  workUseCase {
/** code omitted **/
    @Override
    public Router getRouter(RouterId routerId) {
        return fetchRouter(routerId);
    }
    private Router fetchRouter(RouterId routerId) {
        return routerNetworkOutputPort.
</span><span class="koboSpan" id="kobo.196.2">               fetchRouterById(routerId);
    }
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.197.1">Notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">fetchRouter</span></strong><span class="koboSpan" id="kobo.199.1"> already existed in the input port implementation, but we didn’t have an exposed operation that allowed us to retrieve the router. </span><span class="koboSpan" id="kobo.199.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">fetchRouter</span></strong><span class="koboSpan" id="kobo.201.1"> method is then used not only by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.203.1"> method but now also </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">getRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">It’s necessary to propagate the input port change to the input adapter. </span><span class="koboSpan" id="kobo.207.2">We do that by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">getRouter</span></strong><span class="koboSpan" id="kobo.209.1"> method on the base input adapter defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">RouterNetworkAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.211.1">abstract class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
public Router getRouter(Map&lt;String, String&gt; params) {
    var routerId = RouterId.
</span><span class="koboSpan" id="kobo.212.2">    withId(params.get("routerId"));
    return routerNetworkUseCase.getRouter(routerId);
}</span></pre> <p><span class="koboSpan" id="kobo.213.1">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">RouterNetworkAdapter</span></strong><span class="koboSpan" id="kobo.215.1"> is the base input adapter for both </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">RouterNetworkCLIAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.217.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">RouterNetworkRestAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">To allow the frontend application to communicate with the hexagonal system, we’ll use the REST</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.221.1"> adapter. </span><span class="koboSpan" id="kobo.221.2">So, there are some </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.222.1">changes we need to make in </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">RouterNetworkRestAdapter</span></strong><span class="koboSpan" id="kobo.224.1"> to allow </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">this communication:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
@Override
public Router processRequest(Object requestParams){
/** code omitted **/
    if (exchange.
</span><span class="koboSpan" id="kobo.226.2">      getRequestURI().getPath().equals("/network/add")) {
        try {
            router = this.addNetworkToRouter(params);
        } catch (Exception e) {
            exchange.sendResponseHeaders(
            400, e.getMessage().getBytes().length);
            OutputStream output = exchange.
</span><span class="koboSpan" id="kobo.226.3">            getResponseBody();
            output.write(e.getMessage().getBytes());
            output.flush();
        }
    }
    if (exchange.
</span><span class="koboSpan" id="kobo.226.4">      getRequestURI().getPath().contains("/network/get")) {
        router = this.getRouter(params);
    }
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.227.1">The changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">processRequest</span></strong><span class="koboSpan" id="kobo.229.1"> method were made so it can properly handle requests coming from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">/network/add</span></strong><span class="koboSpan" id="kobo.231.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">network/get</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.234.1"> paths.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">We can move now to the development of the frontend part of our topology and inventory system. </span><span class="koboSpan" id="kobo.235.2">Our focus will be on the HTML and JavaScript elements. </span><span class="koboSpan" id="kobo.235.3">We’ll create two pages: the </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.236.1">first one is to allow users</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.237.1"> to add networks, and the second one is where users will be able to retrieve a graphical view of a router and </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">its networks.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.239.1">Creating the Add Network page</span></h2>
<p><span class="koboSpan" id="kobo.240.1">Let’s start by </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.241.1">creating</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.242.1"> the first HTML page, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.244.1"><img alt="Figure 5.3 – The Add Network page of the Topology &amp; Inventory frontend application" src="image/B19777_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.245.1">Figure 5.3 – The Add Network page of the Topology &amp; Inventory frontend application</span></p>
<p><span class="koboSpan" id="kobo.246.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">Add Network</span></strong><span class="koboSpan" id="kobo.248.1"> page</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.249.1"> contains</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.250.1"> a form, where users are asked to type the necessary data to add a network to an existing router. </span><span class="koboSpan" id="kobo.250.2">Here is the code for </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">the form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Topology &amp; Inventory | Add Network&lt;/title&gt;
    /** code omitted **/
  &lt;/head&gt;
  &lt;body&gt;
      /** code omitted **/
      &lt;form name="addNetwork" onsubmit="return
       false;"&gt;
      /** code omitted **/
      &lt;/form&gt;
    &lt;script src="js/networkTools.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</span></pre> <p><span class="koboSpan" id="kobo.253.1">In order to process the preceding </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">Add Network</span></strong><span class="koboSpan" id="kobo.255.1"> page form, we use a JavaScript function </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.256.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.258.1">, which is </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.259.1">present in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">networkTools.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
function addNetworkToRouter() {
    const routerId = document.
</span><span class="koboSpan" id="kobo.262.2">    getElementById("routerId").value;
    const address = document.
</span><span class="koboSpan" id="kobo.262.3">    getElementById("address").value;
    const name = document.getElementById("name").value;
    const cidr = document.getElementById("cidr").value;
    const xhttp = new XMLHttpRequest();
    xhttp.open("GET",
    "http://localhost:8080/network/add?
</span><span class="koboSpan" id="kobo.262.4">        routerId=" + routerId + "&amp;" +
        "address=" + address + "&amp;" +
        "name=" + name + "&amp;" +
        "cidr=" + cidr, true);
    xhttp.onload = function(
        if (xhttp.status === 200) {
            document.
</span><span class="koboSpan" id="kobo.262.5">            getElementById("message").
</span><span class="koboSpan" id="kobo.262.6">            innerHTML = "Network added with success!"
</span><span class="koboSpan" id="kobo.262.7">        } else {
            document.
</span><span class="koboSpan" id="kobo.262.8">            getElementById("message").
</span><span class="koboSpan" id="kobo.262.9">            innerHTML = "An error occurred while
            trying to add the network."
</span><span class="koboSpan" id="kobo.262.10">        }
    };
    xhttp.send();
}</span></pre> <p><span class="koboSpan" id="kobo.263.1">We use </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.264.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">XMLHttpRequest</span></strong><span class="koboSpan" id="kobo.266.1"> object</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.267.1"> to process </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">GET</span></strong><span class="koboSpan" id="kobo.269.1"> requests in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">/network/add</span></strong><span class="koboSpan" id="kobo.271.1"> endpoint exposed by the REST adapter in the hexagonal application. </span><span class="koboSpan" id="kobo.271.2">It is a short JavaScript code that captures the values entered in the HTML form, processes them, and then shows a success message if everything goes okay or an error message if not, as we can </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">see here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.273.1"><img alt="Figure 5.4 – Adding a new network to the topology and inventory application" src="image/B19777_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 5.4 – Adding a new network to the topology and inventory application</span></p>
<p><span class="koboSpan" id="kobo.275.1">Now, let’s </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.276.1">move </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.277.1">on to the creation of the </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">Get </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.279.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1"> page.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.281.1">Creating the Get Router page</span></h2>
<p><span class="koboSpan" id="kobo.282.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Get Router</span></strong><span class="koboSpan" id="kobo.284.1"> page </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.285.1">contains </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.286.1">an HTML form to process the user request, but it also provides a graphical view based on the JSON response obtained from the hexagonal application. </span><span class="koboSpan" id="kobo.286.2">Let’s start by considering the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">HTML form:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.288.1"><img alt="Figure 5.5 – The Get Router page of the topology and inventory frontend application" src="image/B19777_05_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.289.1">Figure 5.5 – The Get Router page of the topology and inventory frontend application</span></p>
<p><span class="koboSpan" id="kobo.290.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">Get Router</span></strong><span class="koboSpan" id="kobo.292.1"> HTML page follows the same structure as the one we used on the </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">Add Network</span></strong><span class="koboSpan" id="kobo.294.1"> page, but this </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.295.1">form uses only one parameter to query a router from the </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">hexagonal </span></span><span class="No-Break"><a id="_idIndexMarker348"/></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">application.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">To create a JSON-based graphical view of the router and its networks, we’ll use a JavaScript library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">D3</span></strong><span class="koboSpan" id="kobo.300.1"> that consumes the JSON data and produces the graphical view. </span><span class="koboSpan" id="kobo.300.2">The JavaScript code processes the form, and then it uses the JSON response with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">D3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1"> libraries:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
function getRouter() {
    const routerId = document.
</span><span class="koboSpan" id="kobo.303.2">    getElementById("routerId").value;
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        console.log(this.responseText);
        if (this.readyState == 4 &amp;&amp; this.status == 200) {
            const json = JSON.parse(this.responseText)
            createTree(json)
        }
    };
    xhttp.open(
    "GET",
    "http://localhost:8080/network/get?routerId="+routerId,
    true);
    xhttp.send();
}
function createTree(json) {
    const container = document.getElementById("container");
    const vt = new VTree(container);
    const reader = new Vtree.reader.Object();
    var data = reader.read(json);
    vt.data(data).update();
}</span></pre> <p><span class="koboSpan" id="kobo.304.1">Here, we are </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.305.1">passing</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.306.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">/network/get</span></strong><span class="koboSpan" id="kobo.308.1"> endpoint defined previously in the hexagonal application. </span><span class="koboSpan" id="kobo.308.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">getRouter</span></strong><span class="koboSpan" id="kobo.310.1"> function processes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">GET</span></strong><span class="koboSpan" id="kobo.312.1"> requests and uses the JSON response as the parameter for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">createTree</span></strong><span class="koboSpan" id="kobo.314.1"> function that will construct the graphical view of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">If we fill the form with the router ID, </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">ca23800e-9b5a-11eb-a8b3-0242ac130003</span></strong><span class="koboSpan" id="kobo.318.1">, to retrieve a router, the result we get is like the one shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.320.1"><img alt="Figure 5.6 – The network graphical view provided by the Get Router page" src="image/B19777_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">Figure 5.6 – The network graphical view provided by the Get Router page</span></p>
<p><span class="koboSpan" id="kobo.322.1">Remember, the data presented in the preceding screenshot came ultimately from the H2 in-memory database that we attached directly to the REST input adapter used here by the</span><a id="_idIndexMarker351"/> <span class="No-Break"><span class="koboSpan" id="kobo.323.1">frontend </span></span><span class="No-Break"><a id="_idIndexMarker352"/></span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">application.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Now, let’s see how test agents can be integrated with the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">inventory system.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.327.1">Running test agents</span></h2>
<p><span class="koboSpan" id="kobo.328.1">Aside from </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.329.1">frontend applications, another common type of driven operation comes from test and monitoring agents interacting with the hexagonal system to verify whether its features are working well. </span><span class="koboSpan" id="kobo.329.2">With tools such as Postman, we can create comprehensive test cases to validate how the application behaves when faced with </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">certain requests.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">In addition, we can periodically issue requests to certain application endpoints to check whether they are healthy. </span><span class="koboSpan" id="kobo.331.2">This practice has </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.332.1">been popularized with tools such as </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Spring Actuator</span></strong><span class="koboSpan" id="kobo.334.1">, which provides a specific endpoint in the application that allows you to check whether it’s healthy. </span><span class="koboSpan" id="kobo.334.2">Also, some techniques involve the use of probe mechanisms that periodically send a request to the application to see whether it is alive. </span><span class="koboSpan" id="kobo.334.3">For example, if the application is not alive or is causing timeouts, then it can be automatically restarted. </span><span class="koboSpan" id="kobo.334.4">In cloud-native architectures based on </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.336.1">, it’s common to see systems using </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">probe mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">This section will explore how to run a simple test case to confirm whether the application behaves according to our expectations. </span><span class="koboSpan" id="kobo.338.2">There will be no need to change the topology and inventory system we have been developing so far. </span><span class="koboSpan" id="kobo.338.3">Here, we will create a test case using a tool called Postman. </span><span class="koboSpan" id="kobo.338.4">In Postman, test cases are known as </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">testing collections</span></strong><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">Once</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.341.1"> these testing collections are made, we can execute them using </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">Newman</span></strong><span class="koboSpan" id="kobo.343.1">, which is a CLI tool used specifically to run </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">Postman collections.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">To get started, you </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.346.1">have to follow </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.348.1">Download both Postman and Newman. </span><span class="koboSpan" id="kobo.348.2">The download links are available in the </span><em class="italic"><span class="koboSpan" id="kobo.349.1">Technical requirements</span></em><span class="koboSpan" id="kobo.350.1"> section. </span><span class="koboSpan" id="kobo.350.2">The collection used in this chapter is also present in the chapter’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">repository (</span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json"><span class="No-Break"><span class="koboSpan" id="kobo.352.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.353.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.354.1">Import the collection </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">to Postman.</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">Once imported, the collection will present two requests. </span><span class="koboSpan" id="kobo.356.2">One request is for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">getRouter</span></strong><span class="koboSpan" id="kobo.358.1"> endpoint and the other is for </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">addNetwork</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">The following screenshot shows how the two requests should appear after importing the collections </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">to Postman:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.362.1"><img alt="Figure 5.7 – The topology and inventory collection from Postman" src="image/B19777_05_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">Figure 5.7 – The topology and inventory collection from Postman</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.364.1">Before</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.365.1"> running the test on Postman, be sure to bring up the topology and inventory application by running the follow</span><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.366.1">ing command from the project’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">root</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.368.1"> directory:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.369.1">java -jar target/topology-inventory-1.0-SNAPSHOT-jar-with-dependencies.jar rest</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.370.1">Our goal in testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">getRouter</span></strong><span class="koboSpan" id="kobo.372.1"> request is to confirm whether the application returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">HTTP 200</span></strong><span class="koboSpan" id="kobo.374.1"> response code when we try to retrieve a router by passing a </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">router ID.</span></span></p></li> <li><span class="koboSpan" id="kobo.376.1">Then, we want to validate whether the returned value is what we are expecting. </span><span class="koboSpan" id="kobo.376.2">In this case, we expect to encounter only three networks in the system: </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">HR</span></strong><span class="koboSpan" id="kobo.378.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Marketing</span></strong><span class="koboSpan" id="kobo.380.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">Engineering</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">In Postman, we create tests for each request. </span><span class="koboSpan" id="kobo.382.3">So, we will create tests for the two requests present in the collection we imported. </span><span class="koboSpan" id="kobo.382.4">Let’s start by creating a test for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">getRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> request:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
pm.test("Status code is 200", () =&gt; {
  pm.expect(pm.response.code).to.eql(200);
});
pm.test("The response has all properties", () =&gt; {
  const responseJson = pm.response.json();
  pm.expect(
      responseJson.switch.networks).
</span><span class="koboSpan" id="kobo.385.2">      to.have.lengthOf(3);
  pm.expect(
      responseJson.switch.networks[0].networkName).
</span><span class="koboSpan" id="kobo.385.3">      to.eql('HR');
  pm.expect(
      responseJson.switch.networks[1].networkName).
</span><span class="koboSpan" id="kobo.385.4">      to.eql('Marketing');
  pm.expect(
      responseJson.switch.networks[2].networkName).
</span><span class="koboSpan" id="kobo.385.5">      to.eql('Engineering');
});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.386.1">In the preceding </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.387.1">code, we first check whether the HTTP response code is </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">200</span></strong><span class="koboSpan" id="kobo.389.1">. </span><span class="koboSpan" id="kobo.389.2">Then, we proceed to parse and peek at the JSON response data to see whether it matches what we expect. </span><span class="koboSpan" id="kobo.389.3">In this test, we expect a response containing a router with a switch comprising </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">three networks.</span></span></p></li> <li><span class="koboSpan" id="kobo.391.1">The test from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">addNetwork</span></strong><span class="koboSpan" id="kobo.393.1"> request is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">getRouter</span></strong><span class="koboSpan" id="kobo.395.1"> request’s test. </span><span class="koboSpan" id="kobo.395.2">The difference, though, is that the response expected this time contains the additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Finance</span></strong><span class="koboSpan" id="kobo.397.1"> network, as we can see in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">test code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
pm.test("Status code is 200", () =&gt; {
  pm.expect(pm.response.code).to.eql(200);
});
pm.test("The response has all properties", () =&gt; {
  const responseJson = pm.response.json();
  pm.expect(
      responseJson.switch.networks).
</span><span class="koboSpan" id="kobo.399.2">      to.have.lengthOf(4);
  pm.expect(
      responseJson.switch.networks[3].networkName).
</span><span class="koboSpan" id="kobo.399.3">      to.eql('Finance');
});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.400.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">addNetwork</span></strong><span class="koboSpan" id="kobo.402.1"> request </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.403.1">in that collection adds a network named </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Finance</span></strong><span class="koboSpan" id="kobo.405.1">. </span><span class="koboSpan" id="kobo.405.2">That’s why we are only checking to see whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">Finance</span></strong><span class="koboSpan" id="kobo.407.1"> network was correctly added. </span><span class="koboSpan" id="kobo.407.2">Also, we expect the length of the list of networks to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">4</span></strong><span class="koboSpan" id="kobo.409.1"> after adding the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Finance</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1"> network.</span></span></p></li> <li><span class="koboSpan" id="kobo.412.1">If you want to run these tests from outside Postman, you can do that by first exporting the collection to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">.json</span></strong><span class="koboSpan" id="kobo.414.1"> file, then using Newman to execute the tests from </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">that collection:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.416.1">newman run topology-inventory.postman_collection.json</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.417.1">The result is something like the one presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">following screenshot:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 5.8 – Running topology and inventory application tests with Newman" src="image/B19777_05_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 5.8 – Running topology and inventory application tests with Newman</span></p>
<p><span class="koboSpan" id="kobo.421.1">This kind of test execution using Newman is ideal for integrating the hexagonal application </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.422.1">into </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.424.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.425.1">CI</span></strong><span class="koboSpan" id="kobo.426.1">) pipelines. </span><span class="koboSpan" id="kobo.426.2">Developers use Postman to create collections and their respective tests, and these same collections are triggered and validated through</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.427.1"> CI tools (such as </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">Jenkins</span></strong><span class="koboSpan" id="kobo.429.1">) that can use Newman to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">the tests.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Now that we are acquainted with both frontend applications and test agents as means of driving operations, let’s check out one more type of driving operation. </span><span class="koboSpan" id="kobo.431.2">Next, we will discuss the driving operation that occurs in distributed or microservices architecture, where different applications from the same system communicate through </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">the network.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.433.1">Calling the hexagonal system from other applications</span></h2>
<p><span class="koboSpan" id="kobo.434.1">There is a</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.435.1"> recurring debate about whether to develop a monolith or microservices system. </span><span class="koboSpan" id="kobo.435.2">In a monolith, we have data flowing directly between objects and method calls. </span><span class="koboSpan" id="kobo.435.3">All the software instructions are grouped in the same application, diminishing the communication overhead and centralizing the logs generated by </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">With both microservices and a distributed system, we have part of the data flowing through the network between standalone, self-contained applications that cooperate in providing the features of the whole system. </span><span class="koboSpan" id="kobo.437.2">This approach decouples the development, allowing more modularized components. </span><span class="koboSpan" id="kobo.437.3">It also improves compilation times because the packages are smaller, contributing to faster feedback loops in CI tools. </span><span class="koboSpan" id="kobo.437.4">Microservices, though, offer some challenges because the logs are not centralized anymore, and the network communication overhead can represent a limiting factor, depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">system’s purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">In a distributed approach, two or more hexagonal self-contained systems can comprise the whole hexagonal-based system. </span><span class="koboSpan" id="kobo.439.2">In such a scenario, the hexagonal </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">System A</span></strong><span class="koboSpan" id="kobo.441.1"> that initiates the request acts as a primary actor and triggers a driving operation on the hexagonal </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">System B</span></strong><span class="koboSpan" id="kobo.443.1">, as </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.444.1">shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.446.1"><img alt="Figure 5.9 – Multiple hexagonal applications" src="image/B19777_05_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.447.1">Figure 5.9 – Multiple hexagonal applications</span></p>
<p><span class="koboSpan" id="kobo.448.1">Note that </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">System A</span></strong><span class="koboSpan" id="kobo.450.1"> triggers a request through one of its output adapters. </span><span class="koboSpan" id="kobo.450.2">This request goes directly to one of the input adapters from </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">System B</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">An exciting thing about distributed architecture is that you don’t need to use the same programming language to develop all the </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">system components.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">In a distributed architecture scenario, we could write </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">System A</span></strong><span class="koboSpan" id="kobo.456.1"> in Java and </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">System B</span></strong><span class="koboSpan" id="kobo.458.1"> in Python. </span><span class="koboSpan" id="kobo.458.2">As long as they agree on a common medium of communication – JSON and HTTP, for example – they can cooperate in the same system. </span><span class="koboSpan" id="kobo.458.3">With the advent of container technologies such as Docker and Kubernetes, it’s not a big deal to have a </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">technology-hybrid system.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">This section has looked at what driving operations are and how we can use them to interact with </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.461.1">the hexagonal system. </span><span class="koboSpan" id="kobo.461.2">In the next section, we’ll see the other side of the coin: </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">driven operations.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.463.1">Handling external resources with driven operations</span></h1>
<p><span class="koboSpan" id="kobo.464.1">A general </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.465.1">characteristic of business</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.466.1"> applications is their need to send or request data from other systems. </span><span class="koboSpan" id="kobo.466.2">We’ve already seen that output ports and adapters are the hexagonal architecture components we use to allow the hexagonal system to interact with external resources without compromising the business logic. </span><span class="koboSpan" id="kobo.466.3">These external resources are also known as </span><em class="italic"><span class="koboSpan" id="kobo.467.1">secondary actors</span></em><span class="koboSpan" id="kobo.468.1"> and provide data or capabilities absent in the hexagonal application that </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">requests them.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">When the hexagonal application sends a request to a secondary actor – generally, on behalf of a primary actor who first triggered a driving operation from one of the hexagon application’s use cases – we call such a request a </span><em class="italic"><span class="koboSpan" id="kobo.471.1">driven</span></em><span class="koboSpan" id="kobo.472.1"> operation. </span><span class="koboSpan" id="kobo.472.2">It’s driven because these operations are controlled and driven by the </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">So, </span><em class="italic"><span class="koboSpan" id="kobo.475.1">driving</span></em><span class="koboSpan" id="kobo.476.1"> operations come from the primary actor’s requests that drive the behavior of a hexagonal system, whereas </span><em class="italic"><span class="koboSpan" id="kobo.477.1">driven</span></em><span class="koboSpan" id="kobo.478.1"> operations are the requests initiated by the hexagonal application itself toward secondary actors (such as databases or other systems). </span><span class="koboSpan" id="kobo.478.2">The following diagram shows the driven side with some examples of </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">driven operations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.480.1"><img alt="Figure 5.10 – The driven side and the hexagonal application" src="image/B19777_05_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.481.1">Figure 5.10 – The driven side and the hexagonal application</span></p>
<p><span class="koboSpan" id="kobo.482.1">This section</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.483.1"> will explore some of the possible</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.484.1"> driven operations a hexagonal application can perform, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">preceding diagram.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.486.1">Data persistence</span></h2>
<p><span class="koboSpan" id="kobo.487.1">Driven</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.488.1"> operations based on data persistence are the most common. </span><span class="koboSpan" id="kobo.488.2">The H2 output adapter we created in </span><a href="B19777_04.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.489.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.490.1">, </span><em class="italic"><span class="koboSpan" id="kobo.491.1">Creating Adapters to Interact with the Outside World</span></em><span class="koboSpan" id="kobo.492.1">, is one example of a driven operation that deals with data persistence by utilizing an in-memory database. </span><span class="koboSpan" id="kobo.492.2">This</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.493.1"> kind of driven operation often leverages </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">Object-Relational Mapping</span></strong><span class="koboSpan" id="kobo.495.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.496.1">ORM</span></strong><span class="koboSpan" id="kobo.497.1">) techniques to handle and translate </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.498.1">objects </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.499.1">between the hexagonal system and a database. </span><span class="koboSpan" id="kobo.499.2">In the Java world, </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">Hibernate</span></strong><span class="koboSpan" id="kobo.501.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">EclipseLink</span></strong><span class="koboSpan" id="kobo.503.1"> provide</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.504.1"> robust </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">Java Persistence API</span></strong><span class="koboSpan" id="kobo.506.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.507.1">JPA</span></strong><span class="koboSpan" id="kobo.508.1">) implementations with </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">ORM features.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">Transaction mechanisms are also a part of persistence-based driven operations. </span><span class="koboSpan" id="kobo.510.2">When working with transactions, we can make the hexagonal system directly deal with transactional boundaries or delegate this responsibility to an </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">application server.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.512.1">Messaging and events</span></h2>
<p><span class="koboSpan" id="kobo.513.1">Not every</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.514.1"> system relies only </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.515.1">on synchronous communication. </span><span class="koboSpan" id="kobo.515.2">Depending on the situation, you may want to trigger events about your </span><em class="italic"><span class="koboSpan" id="kobo.516.1">stuff</span></em><span class="koboSpan" id="kobo.517.1"> without interrupting the runtime flow of </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">There are types of architecture strongly influenced by techniques where the communication between system components occurs asynchronously. </span><span class="koboSpan" id="kobo.519.2">These systems become more loosely coupled by employing such techniques because their components are no longer attached to the interfaces provided by other applications. </span><span class="koboSpan" id="kobo.519.3">Instead of relying solely on APIs blocking connections, we let messages and events drive the behavior of applications in a </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">non-blocking way.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">By </span><em class="italic"><span class="koboSpan" id="kobo.522.1">blocking</span></em><span class="koboSpan" id="kobo.523.1">, we mean those connections that need to wait for a response to allow the application flow to proceed. </span><span class="koboSpan" id="kobo.523.2">The non-blocking approach allows an application to send a request and move forward without the need for an immediate response. </span><span class="koboSpan" id="kobo.523.3">There are also situations where an application reacts to messages or events to take </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">some action.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">Message-based systems are secondary actors driven by the hexagonal application. </span><span class="koboSpan" id="kobo.525.2">Unlike databases, where the communication will start from the hexagonal application, there are scenarios where the message-based system will start the communication with the hexagonal application. </span><span class="koboSpan" id="kobo.525.3">But, to receive or send messages, the hexagonal system always needs </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.526.1">to first establish </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.527.1">a flow of communication with a message system. </span><span class="koboSpan" id="kobo.527.2">Such a scenario is widespread when dealing with technologies such as Kafka, where the application can be both a consumer and producer of messages. </span><span class="koboSpan" id="kobo.527.3">To be integrated with a message system such as Kafka, the hexagonal application needs to express its intent by joining a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.528.1">Kafka</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.529.1">topic</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">To better understand how a message-based system integrates with a hexagonal application, we’ll implement a feature in our topology and inventory system to allow us to see events produced by the application. </span><span class="koboSpan" id="kobo.531.2">The backend hexagonal part of the system will send events to Kafka, and the frontend will consume those events in real time and display them in the web browser. </span><span class="koboSpan" id="kobo.531.3">We’ll implement this feature by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.533.1">Let’s start by bringing up Kafka and creating a topic for our application. </span><span class="koboSpan" id="kobo.533.2">The Kafka download URL is available in the </span><em class="italic"><span class="koboSpan" id="kobo.534.1">Technical requirements</span></em><span class="koboSpan" id="kobo.535.1"> section. </span><span class="koboSpan" id="kobo.535.2">Once you have downloaded the latest Kafka version, </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">extract it:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.537.1">$ curl "https://downloads.apache.org/kafka/3</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.538.1">.4.0/kafka_2.12-3.4.0</span><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.539.1">.t</span><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.540.1">gz" -o ./kafka_2.12-3.4.0.tgz</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.541.1">$ tar -xzf kafka_2.12-3.4.0.tgz</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.542.1">$ cd kafka_2.12-3.4.0</span></strong></pre></li> <li><span class="koboSpan" id="kobo.543.1">Before proceeding, be sure to have JDK version 17 or higher installed on your system. </span><span class="koboSpan" id="kobo.543.2">Once Java is properly i</span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.544.1">nstalled and configured, you can start the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">zookeeper</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1"> service:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.547.1">$ bin/zookeeper-server-start.sh config/zookeeper.properties</span></strong></pre></li> <li><span class="koboSpan" id="kobo.548.1">Be sure to open a sepa</span><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.549.1">rate shell session or tab and start the Kafka </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">broker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1"> service:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.552.1">$ bin/kafka-server-start.sh config/server.properties</span></strong></pre></li> <li><span class="koboSpan" id="kobo.553.1">At this point, Kafka is</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.554.1"> up </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.555.1">and running in your environment. </span><span class="koboSpan" id="kobo.555.2">Let’s now create the topic for our application in a third shell session </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">or tab:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.557.1">bin/kafka-topics.sh --create --topic topoloy-inventory-events --bootstrap-server localhost:9092</span></strong></pre></li> <li><span class="koboSpan" id="kobo.558.1">Now, we need to add proper ports and adapters to enable the hexagonal application to send and consume events from Kafka. </span><span class="koboSpan" id="kobo.558.2">Let’s do that with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">NotifyEventOutputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.560.1">output port:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
public interface NotifyEventOutputPort {
    void sendEvent(String Event);
    </span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.562.1">String getEvent();
}}</span></pre></li> <li><span class="koboSpan" id="kobo.563.1">Next, we implement the output port with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">NotifyEventKafkaAdapter</span></strong><span class="koboSpan" id="kobo.565.1"> output adapter. </span><span class="koboSpan" id="kobo.565.2">We start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">NotifyEventKafkaAdapter</span></strong><span class="koboSpan" id="kobo.567.1"> adapter implementation by first defining the Kafka </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">connection properties:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
public class NotifyEventKafkaAdapter implements Noti
  fyEventOutputPort {
    private static String KAFKA_BROKERS =
      "localhost:9092";
    private static String
      GROUP_ID_CONFIG="consumerGroup1";
    private static String CLIENT_ID="hexagonal-
      client";
    private static String TOPIC_NAME=
    "topology-inventory-events";
    private static String
      OFFSET_RESET_EARLIER="earliest";
    private static Integer
      MAX_NO_MESSAGE_FOUND_COUNT=100;
    /** code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.570.1">Note</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.571.1"> that </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.572.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">KAFKA_BROKERS</span></strong><span class="koboSpan" id="kobo.574.1"> variable value, set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">localhost:9092</span></strong><span class="koboSpan" id="kobo.576.1">, corresponds to the host and port used to bootstrap the Kafka topic. </span><span class="koboSpan" id="kobo.576.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">TOPIC_NAME</span></strong><span class="koboSpan" id="kobo.578.1"> variable value, set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">topology-inventory-events</span></strong><span class="koboSpan" id="kobo.580.1">, represents the topic that we use to produce and </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">consume messages.</span></span></p></li> <li><span class="koboSpan" id="kobo.582.1">Let’s move on now to create the method to send messages to our </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">Kafka topic:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.584.1">
private static Producer&lt;Long, String&gt; getProducer(){
    Properties properties = new Properties();
    properties.put(ProducerConfig.
</span><span class="koboSpan" id="kobo.584.2">    BOOTSTRAP_SERVERS_CONFIG, KAFKA_BROKERS);
    properties.put(ProducerConfig.
</span><span class="koboSpan" id="kobo.584.3">    CLIENT_ID_CONFIG, CLIENT_ID);
    properties.put(ProducerConfig.
</span><span class="koboSpan" id="kobo.584.4">    KEY_SERIALIZER_CLASS_CONFIG,
    LongSerializer.class.getName());
    properties.put(ProducerConfig.
</span><span class="koboSpan" id="kobo.584.5">    VALUE_SERIALIZER_CLASS_CONFIG,
    StringSerializer.class.getName());
    return new KafkaProducer&lt;&gt;(properties);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.585.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">getProducer</span></strong><span class="koboSpan" id="kobo.587.1"> method configures the Producer properties by setting the </span><a id="_idTextAnchor116"/><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.588.1">required </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.589.1">attributes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">ProducerConfig</span></strong><span class="koboSpan" id="kobo.591.1"> class. </span><span class="koboSpan" id="kobo.591.2">Then, it returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">KafkaProducer</span></strong><span class="koboSpan" id="kobo.593.1"> instance, which we use to produce messages in the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">Kafka topic.</span></span></p></li> <li><span class="koboSpan" id="kobo.595.1">On the other hand, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">getConsumer</span></strong><span class="koboSpan" id="kobo.597.1"> method, which consumes the messages generated by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Producer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
public static Consumer&lt;Long, String&gt; getConsumer(){
    Properties properties = new Properties();
    properties.put(ConsumerConfig.
</span><span class="koboSpan" id="kobo.600.2">    BOOTSTRAP_SERVERS_CONFIG,KAFKA_BROKERS);
    properties.put(ConsumerConfig.
</span><span class="koboSpan" id="kobo.600.3">    GROUP_ID_CONFIG, GROUP_ID_CONFIG);
    properties.put(ConsumerConfig.
</span><span class="koboSpan" id="kobo.600.4">    KEY_DESERIALIZER_CLASS_CONFIG,
    LongDeserializer.class.getName());
    properties.put(ConsumerConfig.
</span><span class="koboSpan" id="kobo.600.5">    VALUE_DESERIALIZER_CLASS_CONFIG,
    StringDeserializer.class.getName());
    properties.put
      (ConsumerConfig.MAX_POLL_RECORDS_CONFIG,
              1);
    properties.put(ConsumerConfig.
</span><span class="koboSpan" id="kobo.600.6">    ENABLE_AUTO_COMMIT_CONFIG,"false");
    properties.put(ConsumerConfig.
</span><span class="koboSpan" id="kobo.600.7">    AUTO_OFFSET_RESET_CONFIG, OFFSET_RESET_EARLIER);
    Consumer&lt;Long, String&gt; consumer =
    new KafkaConsumer&lt;&gt;(properties);
    consumer.
</span><span class="koboSpan" id="kobo.600.8">    subscribe(Collections.singletonList(TOPIC_NAME));
    return consumer;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.601.1">With</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.602.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">getConsumer</span></strong><span class="koboSpan" id="kobo.604.1"> method, we</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.605.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">ConsumerConfig</span></strong><span class="koboSpan" id="kobo.607.1"> class to set the required properties. </span><span class="koboSpan" id="kobo.607.2">This method returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">KafkaConsumer</span></strong><span class="koboSpan" id="kobo.609.1"> instance that we use to consume and read messages from the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">Kafka topic.</span></span></p></li> <li><span class="koboSpan" id="kobo.611.1">Moving ahead, we override the first method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">sendEvent</span></strong><span class="koboSpan" id="kobo.613.1">, declared in </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">NotifyEventOutputPort</span></strong><span class="koboSpan" id="kobo.615.1">. </span><span class="koboSpan" id="kobo.615.2">It’s with this method that we’ll be able to send messages to the Kafka </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">P</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">roducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1"> instance:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.619.1">
@Override
public void sendEvent(String eventMessage){
    var record = new ProducerRecord&lt;Long, String&gt;(
            TOPIC_NAME, eventMessage);
    try {
        var metadata = producer.send(record).get();
        System.out.println("Event message " +
                "sent to the topic "+TOPIC_NAME+": "
                +eventMessage+".");
        getEvent();
    }catch (Exception e){
        e.printStackTrace();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.620.1">The first </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.621.1">line </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.622.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">sendEvent</span></strong><span class="koboSpan" id="kobo.624.1"> method creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">ProducerRecord</span></strong><span class="koboSpan" id="kobo.626.1"> instance that informs the constructor parameters about the topic name and the message we intend to send as an event. </span><span class="koboSpan" id="kobo.626.2">Near the end, we have a call to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">getEvent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.628.1"> method.</span></span></p></li> <li><span class="koboSpan" id="kobo.629.1">As we shall see next in more detail, we call this method to consume messages from Kafka and forward them to a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">WebSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1"> server:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
@Override
public String getEvent(){
    int noMessageToFetch = 0;
    AtomicReference&lt;String&gt; event =
    new AtomicReference&lt;&gt;("");
    while (true) {
    /** code omitted **/
        consumerRecords.forEach(record -&gt; {
            event.set(record.value());
        });
    }
    var eventMessage = event.toString();
    if(sendToWebsocket)
    sendMessage(event</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.633.1">Message);
    return eventMessage;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.634.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">getEvent</span></strong><span class="koboSpan" id="kobo.636.1"> method </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.637.1">relies </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.638.1">on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">KafkaConsumer</span></strong><span class="koboSpan" id="kobo.640.1"> instance assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">consumer</span></strong><span class="koboSpan" id="kobo.642.1"> variable. </span><span class="koboSpan" id="kobo.642.2">With that instance, it retrieves messages from the </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">Kafka topic.</span></span></p></li> <li><span class="koboSpan" id="kobo.644.1">After retrieving the message, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">getEvent</span></strong><span class="koboSpan" id="kobo.646.1"> method calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">sendMessage</span></strong><span class="koboSpan" id="kobo.648.1"> method to forward that message to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">WebSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.650.1"> server:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.651.1">
public void sendMessage(String message){
    try {
        var client = new WebSocketClientAdapter(
        new URI("ws://localhost:8887"));
        client.connectBlocking();
        client.send(message);
        client.closeBlocking();
    } catch (URISyntaxException |
             InterruptedException e) {
        e.printStackTrace();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.652.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">sendMessage</span></strong><span class="koboSpan" id="kobo.654.1"> method receives a parameter as a string, containing the consumed Kafka topic message. </span><span class="koboSpan" id="kobo.654.2">It then forwards that message to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">WebSocket</span></strong><span class="koboSpan" id="kobo.656.1"> server </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.657.1">running </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.658.1">on </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">8887</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.662.1">Let’s see briefly how that </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">WebSocket</span></strong><span class="koboSpan" id="kobo.664.1"> server </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">is implemented:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
public class NotifyEventWebSocketAdapter extends WebSock
  etServer {
/** code omitted **/
public static void startServer() throws IOException, Inter
  ruptedException {
    var ws = new NotifyEventWebSocketAdapter(
    new InetSocketAddress("localhost", 8887));
    ws.setReuseAddr(true);
    ws.start();
    System.out.println("Topology &amp; Inventory" +
    " webSocket started on port: " + ws.getPort());
    BufferedReader sysin =
    new BufferedReader(new InputStreamReader(System.in));
    while (true) {
        String in = sysin.readLine();
        ws.broadcast(in);
        if (in.equals("exit")) {
            ws.stop();
            break;
        }
    }
}
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.667.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">startServer</span></strong><span class="koboSpan" id="kobo.669.1"> method creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">NotifyEventWebSocketAdapter</span></strong><span class="koboSpan" id="kobo.671.1">, containing the host and port of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">WebSocket</span></strong><span class="koboSpan" id="kobo.673.1"> server. </span><span class="koboSpan" id="kobo.673.2">When we </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.674.1">are </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.675.1">starting the hexagonal application, one of the first things that occurs is the callin</span><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.676.1">g of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">startServer</span></strong><span class="koboSpan" id="kobo.678.1"> method to bring up the WebSocket server on </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">8887</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
void setAdapter(String adapter) throws IOException, Inter
  ruptedException {
    switch (adapter) {
        case "rest" -&gt; {
            routerOutputPort =
            RouterNetworkH2Adapter.getInstance();
            notifyOutputPort =
            NotifyEventKafkaAdapter.getInstance();
            usecase =
            new RouterNetworkInputPort(routerOutputPort,
            notifyOutputPort);
            inputAdapter =
            new RouterNetworkRestAdapter(usecase);
            rest();
            NotifyEventWebSocketAdapter.startServer();
        }
        default -&gt; {
            routerOutputPort =
            RouterNetworkFileAdapter.getInstance();
            usecase =
            new RouterNetworkInputPort(routerOutputPort);
            inputAdapter =
            new RouterNetworkCLIAdapter(usecase);
            cli();
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.683.1">Along with a </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.684.1">WebSocket</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.685.1"> server class, we also need to implement a WebSocket client class to process the events coming </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">from Kafka:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.687.1">
public class WebSocketClientAdapter extends
  org.java_websocket.client.WebSocketClient {
    public WebSocketClientAdapter(URI serverUri) {
        super(serverUri);
    }
    @Override
    public void onMessage(String </span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.688.1">message) {
        String channel = message;
    }
    @Override
    public void onOpen(ServerHandshake handshake) {
        System.out.println("Connection has opened");
    }
    @Override
    public void onClose(int code, String reason,
    boolean remote) {
        System.out.println("Connection has closed");
    }
    @Override
    public void onError(Exception e) {
        System.out.println(
        "An error occurred. </span><span class="koboSpan" id="kobo.688.2">Check the exception below:");
        e.printStackTrace();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.689.1">When a message </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.690.1">is </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.691.1">consumed from the Kafka topic, the hexagonal application uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">WebSocketClientAdapter</span></strong><span class="koboSpan" id="kobo.693.1"> to forward the message to the WebSocket server. </span><span class="koboSpan" id="kobo.693.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">onMessage</span></strong><span class="koboSpan" id="kobo.695.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">onOpen</span></strong><span class="koboSpan" id="kobo.697.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">onClose</span></strong><span class="koboSpan" id="kobo.699.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">onError</span></strong><span class="koboSpan" id="kobo.701.1"> methods represent the WebSocket protocol operations that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">WebSocketClientAdapter</span></strong><span class="koboSpan" id="kobo.703.1"> class needs </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">to support.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">The last thing we need to do in the hexagonal application is to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.707.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">getRouter</span></strong><span class="koboSpan" id="kobo.709.1"> methods send events using the ports and adapters we have </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">just created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.711.1">
public class RouterNetworkInputPort implements RouterNet
  workUseCase {
    /** Code omitted **/
    @Override
    public Router addNetworkToRouter(
    RouterId routerId,  Network network) {
        var router = fetchRouter(routerId);
        notifyEventOutputPort.
</span><span class="koboSpan" id="kobo.711.2">        sendEvent("Adding "+network.getName()
        +" network to router "+router.getId().getUUID());
        return createNetwork(router, network);
    }
    @Override
    public Router getRouter(RouterId routerId) {
        notifyEventOutputPort.
</span><span class="koboSpan" id="kobo.711.3">        sendEvent(
        "Retrieving router ID"+routerId.getUUID());
        return fetchRouter(routerId);
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.712.1">Note that now </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.713.1">we</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.714.1"> are calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">sendEvent</span></strong><span class="koboSpan" id="kobo.716.1"> on both methods (</span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.718.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">getRouter</span></strong><span class="koboSpan" id="kobo.720.1">), so whenever we add a network or retrieve a router, the hexagonal application will send an event informing us what </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">has happened.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">We can now add an </span><strong class="bold"><span class="koboSpan" id="kobo.723.1">Events</span></strong><span class="koboSpan" id="kobo.724.1"> page to allow the frontend application to connect with the WebSocket server from the hexagonal application. </span><span class="koboSpan" id="kobo.724.2">The following screenshot shows us the </span><strong class="bold"><span class="koboSpan" id="kobo.725.1">Events</span></strong><span class="koboSpan" id="kobo.726.1"> page that </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">we’ll create:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.728.1"><img alt="Figure 5.11 – The topology and inventory application Events page" src="image/B19777_05_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.729.1">Figure 5.11 – The topology and inventory application Events page</span></p>
<p><span class="koboSpan" id="kobo.730.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.731.1">Events</span></strong><span class="koboSpan" id="kobo.732.1"> page</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.733.1"> follows the same</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.734.1"> structure we used in previous pages. </span><span class="koboSpan" id="kobo.734.2">The important part of this page is the JavaScript code utilized to connect users to the WebSocket server exposed by our </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">hexagonal application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.736.1">
var wsocket;
function connect() {
    wsocket = new WebSocket("ws://localhost:8887");
    wsocket.onopen = onopen;
    wsocket.onmessage = onmessage;
    wsocket.onclose = onclose;
}
    function onopen() {
    console.log("Connected!");
}
    function onmessage(event) {
    console.log("Data received: " + event.data);
    var tag = document.createElement("div");
    tag.id = "message";
    var text = document.createTextNode("&gt;&gt;"+event.data);
    tag.appendChild(text);
    var element = document.getElementById("events");
    element.appendChild(tag);
}
    function onclose(e) {
    console.log("Connection closed.");
}
window.addEventListener("load", connect, false);</span></pre> <p><span class="koboSpan" id="kobo.737.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">onmessage</span></strong><span class="koboSpan" id="kobo.739.1"> method </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.740.1">creates</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.741.1"> and appends a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">div</span></strong><span class="koboSpan" id="kobo.743.1"> HTML element for every new message received from the WebSocket connection. </span><span class="koboSpan" id="kobo.743.2">So, every event generated by the hexagonal application will be sent to Kafka and printed in real time in the frontend application. </span><span class="koboSpan" id="kobo.743.3">The communication between the frontend, the hexagonal application with WebSocket, and the Kafka message system is represented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">following flow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.745.1"><img alt="Figure 5.12 – The flow between the frontend, the hexagonal application with WebSocket, and the message system" src="image/B19777_05_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.746.1">Figure 5.12 – The flow between the frontend, the hexagonal application with WebSocket, and the message system</span></p>
<p><span class="koboSpan" id="kobo.747.1">To test this flow, make </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.748.1">sure </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.749.1">to have your local Kafka instance running. </span><span class="koboSpan" id="kobo.749.2">Then, start the </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">hexagonal application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.751.1">
java -jar target/topology-inventory-1.0-SNAPSHOT-jar-with-dependencies.jar rest
REST endpoint listening on port 8080...
</span><span class="koboSpan" id="kobo.751.2">Topology &amp; Inventory WebSocket started on port 8887...</span></pre> <p><span class="koboSpan" id="kobo.752.1">To create a WebSocket connection between your browser and the application, you need to open the </span><strong class="bold"><span class="koboSpan" id="kobo.753.1">Events</span></strong><span class="koboSpan" id="kobo.754.1"> page from the frontend application. </span><span class="koboSpan" id="kobo.754.2">To see the data flowing to the </span><strong class="bold"><span class="koboSpan" id="kobo.755.1">Events</span></strong><span class="koboSpan" id="kobo.756.1"> page, try to add a network or retrieve a router using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">ca23800e-9b5a-11eb-a8b3-0242ac130003</span></strong><span class="koboSpan" id="kobo.758.1"> ID. </span><span class="koboSpan" id="kobo.758.2">The event entries will appear as follows on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.759.1">Events</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.760.1"> page:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.761.1"><img alt="Figure 5.13 –  The frontend application receiving events from Kafka through a WebSocket connection" src="image/B19777_05_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.762.1">Figure 5.13 –  The frontend application receiving events from Kafka through a WebSocket connection</span></p>
<p><span class="koboSpan" id="kobo.763.1">This integration using Kafka and WebSockets has shown us how a hexagonal application deals with message-driven operations. </span><span class="koboSpan" id="kobo.763.2">We didn’t need to touch the business logic to add these</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.764.1"> technologies. </span><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.765.1">All </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.766.1">we had to do was create more ports and adapters to augment the </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">system’s capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">Now, let’s briefly see one more type of driven operation that a hexagonal application </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">can handle.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.770.1">Mock servers</span></h2>
<p><span class="koboSpan" id="kobo.771.1">The typical </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.772.1">approach for software development is to have multiple environments, such as development, QA, and production. </span><span class="koboSpan" id="kobo.772.2">The first working software releases start going to development environments and then progressively make their way to production. </span><span class="koboSpan" id="kobo.772.3">This journey to production is generally conducted by CI pipelines that constantly validate and ensure the software is </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">working well.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">Among CI validations, unit and integration tests may happen during the pipeline execution. </span><span class="koboSpan" id="kobo.774.2">Integration tests, in particular, depend on external components such as other applications, systems, databases, and services – all of them provided in </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">different environments.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">The execution of integration tests in development environments poses a low risk but can cause problems if there is, for example, concurrent usage of resources. </span><span class="koboSpan" id="kobo.776.2">This concurrency issue can generate inconsistency in test results. </span><span class="koboSpan" id="kobo.776.3">For QA, the situation is slightly more complicated because we must ensure consistency when dealing with test data explicitly tailored to specific scenarios. </span><span class="koboSpan" id="kobo.776.4">If that test data changes inadvertently, we may find inconsistencies in test results. </span><span class="koboSpan" id="kobo.776.5">We need to be careful because the cost of test failures in QA is even higher than in </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">development environments.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">In order to overcome testing obstacles, some tools simulate application endpoints and their responses. </span><span class="koboSpan" id="kobo.778.2">Those tools</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.779.1"> are known as </span><strong class="bold"><span class="koboSpan" id="kobo.780.1">mock solutions</span></strong><span class="koboSpan" id="kobo.781.1">, and they come in various shapes and forms. </span><span class="koboSpan" id="kobo.781.2">You can manually mock the responses and endpoints of a service that your application needs; however, this is not always trivial, and it may take considerable effort. </span><span class="koboSpan" id="kobo.781.3">Also, there are sophisticated tools that do the dirty work and let you focus just on the logic. </span><span class="koboSpan" id="kobo.781.4">That is the role of </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">mocking servers.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">Because mocking servers act as an external entity providing useful resources to the application, we also consider them secondary actors driven by a hexagonal system that wants to leverage mocking server capabilities instead of hitting </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">actual systems.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">By no means</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.786.1"> have we exhausted all the possible driven operations a hexagonal system can have. </span><span class="koboSpan" id="kobo.786.2">But, in this section, we peeked into some of the relevant driven operations present in a </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">hexagonal application.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.788.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.789.1">In this chapter, we had the opportunity to dive deep into the nature of driving and driven operations. </span><span class="koboSpan" id="kobo.789.2">Although we had already dealt with them in previous chapters, we examined these operations in </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">more depth.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">Starting with </span><em class="italic"><span class="koboSpan" id="kobo.792.1">driving operations</span></em><span class="koboSpan" id="kobo.793.1">, we learned that they drive the hexagonal application behavior by calling its input adapters. </span><span class="koboSpan" id="kobo.793.2">To illustrate driving operations, we first created a frontend application to play the role of a primary actor requesting data through the input adapters provided by the topology and inventory hexagonal application. </span><span class="koboSpan" id="kobo.793.3">Then, to explore testing tools as driving operations, we created a Postman collection with tests based on API endpoints exposed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">hexagonal application.</span></span></p>
<p><span class="koboSpan" id="kobo.795.1">On the </span><em class="italic"><span class="koboSpan" id="kobo.796.1">driven operations</span></em><span class="koboSpan" id="kobo.797.1"> side, we saw how to enable the hexagonal application to work with message-based systems such as Kafka. </span><span class="koboSpan" id="kobo.797.2">To better understand the effects of message-based systems on the hexagonal application, we created ports and adapters that enabled the application to send and consume messages from Kafka. </span><span class="koboSpan" id="kobo.797.3">Also, we made a WebSocket server to let the frontend application retrieve the events generated by the hexagonal system in </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">real time.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">By handling different kinds of driving and driven operations, we can now better comprehend the inner workings of a hexagonal system, its surroundings, and how the driving and driven operations influence the </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">hexagonal application.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">The fundamentals acquired from this chapter and the previous ones provide all the building blocks to start developing robust, change-tolerant systems with the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">architecture instruments.</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">In the next chapter, we’ll apply the things we have learned to initiate the construction of a production-grade hexagonal system that will incorporate features from the Java module system and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.804.1">Quarkus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.805.1"> framework.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.806.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.807.1">What are </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">driving operations?</span></span></li>
<li><span class="koboSpan" id="kobo.809.1">Give one example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">driving operation.</span></span></li>
<li><span class="koboSpan" id="kobo.811.1">What are </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">driven operations?</span></span></li>
<li><span class="koboSpan" id="kobo.813.1">Give one example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">driven operation.</span></span></li>
</ol>
<h1 id="_idParaDest-97"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.815.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.816.1">Driving operations are requests initiated by the primary actors that drive the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">application’s behavior.</span></span></li>
<li><span class="koboSpan" id="kobo.818.1">A frontend application calling a hexagonal system through one of its input adapters is an example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">driving operation.</span></span></li>
<li><span class="koboSpan" id="kobo.820.1">Driven operations are requests initiated by the hexagonal application itself, generally on behalf of a use case need, toward secondary actors driven by a </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">hexagonal system.</span></span></li>
<li><span class="koboSpan" id="kobo.822.1">When the hexagonal application accesses a database. </span><span class="koboSpan" id="kobo.822.2">In this case, the database is driven by the </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">hexagonal application.</span></span></li>
</ol>
</div>


<div class="Content" id="_idContainer046">
<h1 id="_idParaDest-98" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.1.1">Part 2: Using Hexagons to Create a Solid Foundation</span></h1>
<p><span class="koboSpan" id="kobo.2.1">By following a real-world example of a system that manages a telco's network and topology inventory, in this part, you will learn how to implement the building blocks for creating such a system using hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">architecture ideas.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This is a hands-on part where we'll have the opportunity to get our hands dirty while applying the hexagonal architecture principles. </span><span class="koboSpan" id="kobo.4.2">We start by implementing the Domain hexagon, which contains the domain model of the topology and inventory system. </span><span class="koboSpan" id="kobo.4.3">Then, we implement the Application hexagon by using use cases and ports to express system behaviors. </span><span class="koboSpan" id="kobo.4.4">To enable and expose the features provided by the hexagonal system, we use adapters to implement the Framework hexagon. </span><span class="koboSpan" id="kobo.4.5">Closing this part, we learn how to use Java modules to apply dependency inversion in our </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B19777_06.xhtml#_idTextAnchor126"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Building the Domain Hexagon</span></em></li>
<li><a href="B19777_07.xhtml#_idTextAnchor152"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Building the Application Hexagon</span></em></li>
<li><a href="B19777_08.xhtml#_idTextAnchor174"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Building the Framework Hexagon</span></em></li>
<li><a href="B19777_09.xhtml#_idTextAnchor192"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Applying Dependency Inversion with Java Modules</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer047">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer048">
</div>
</div>
</body></html>