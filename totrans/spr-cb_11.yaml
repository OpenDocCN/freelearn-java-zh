- en: Chapter 11. Using the Java RMI, HTTP Invoker, Hessian, and REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Java RMI service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying an existing Java RMI service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP Invoker service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying an existing HTTP Invoker service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Hessian service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying an existing Hessian service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying an existing REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about making Spring interact with another piece of software
    over a network. Different protocols can be used for this, but each one of them
    uses a client/server architecture. Spring can be the client or server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/5807OS_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Java RMI and HTTP Invoker are remote method invocation technologies; a Java
    client executes a method located on a Java server just as with a normal method.
    The request contains the method's arguments and the response contains the method's
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: Hessian, REST, and SOAP are web services; the request is an HTTP request to
    a web server, which sends back an HTTP response. Web services are platform agnostic;
    for example, the client could be a Spring application (Java) and the server could
    be a PHP application.
  prefs: []
  type: TYPE_NORMAL
- en: REST is currently the most popular option; it's simple, flexible, and cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb, use:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Invoker to interact with another Spring application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java RMI to interact with another Java application not using Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hessian to interact with another Java application not using Spring when you
    need to go over proxies and firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP if you have to; it won't be covered in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST for all other cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Java RMI service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java RMI is a Java remote method invocation technology; a client executes
    a method ocated on a server, the Java RMI service.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will set up a Java RMI service that will expose the methods
    of a normal Java class. The service will be part of an existing Spring web application
    but will use its own port.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server will expose the methods of the `UserService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` interface is implemented by `UserServiceImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` methods will receive and send `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `User` class implements `Serializable`; this is necessary because
    the `User` objects are serialized before they are transmitted over the network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create a Java RMI service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring configuration, add a `UserService` bean returning an instance
    of `UserServiceImpl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `RmiServiceExporter` bean. Define the Java RMI service name, the interface
    exposed by the service, and the object implementing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Java RMI service is now available at `rmi://localhost:1099/userService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RmiServiceExporter` is a Spring class generating an RMI service from a Java
    interface (`UserService`). For each method defined in `UserService`, the corresponding
    method from `userService()`, in `UserServiceImpl`, will be executed. The RMI service
    is made available by default on the `1099` port.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying an existing Java RMI service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will configure a Spring web application, so that it will
    be able to execute a method on an existing RMI service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will query the Java RMI service of the previous *Creating a Java RMI service*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the `UserService` interface so that our application knows the methods
    available on the RMI service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`User` objects will be exchanged over the network, so we need the `User` class
    of the previous recipe as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In real applications, these classes could be provided to the RMI client as a
    JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to query a Java RMI service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring configuration, add a `RmiProxyFactoryBean` bean named `userService`.
    Define the Java RMI service URL and the `UserService` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a controller class, add an autowired `UserService` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a controller method, execute the `findAll()` method of the `UserService`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The autowired `UserService` object is created behind the scenes by Spring. It's
    actually an `RmiProxyFactoryBean` object that will delegate the execution of the
    `findAll()`method to the Java RMI service located at `rmi://localhost:1099/userService`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTTP Invoker service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP Invoker, like the Java RMI, is a Java remote method invocation technology;
    here, a client executes a method located on a server-the HTTP invoker service.
    HTTP is used instead of a custom port, so it can go over proxies and firewalls.
    However, it's a Spring technology, so both the client and the server must use
    Java and Spring.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will set up an HTTP Invoker service that will expose the
    methods of a normal Java class. The service will be part of an existing Spring
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server will expose the methods of the `UserService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` interface is implemented by `UserServiceImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` methods will receive and send `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `User` class implements `Serializable`; it's necessary because
    `User` objects are serialized before they are transmitted over the network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create an HTTP Invoker service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring configuration, add a `UserService` bean returning an instance
    of `UserServiceImpl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `HttpInvokerServiceExporter` bean named `/userService`. Define the interface
    exposed by the service and the object implementing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The HTTP Invoker service is now available at the `/userService` URL of the Spring
    web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HttpInvokerServiceExporter` is a Spring class generating an HTTP Invoker service
    from a Java interface (`UserService`). For each method defined in `UserService`,
    the corresponding method from `userService()`, in `UserServiceImpl`, will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying an existing HTTP Invoker service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will configure a Spring web application that will be able
    to execute a method on an existing HTTP Invoker service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will query the HTTP Invoker service of the previous *Creating an HTTP Invoker
    service* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the `UserService` interface so that our application knows the methods
    available on the HTTP Invoker service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`User` objects will be exchanged over the network, so we need the `User` class
    of the previous recipe as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps for using an HTTP Invoker service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring configuration, add an `HttpInvokerProxyFactoryBean` bean named
    `userService`. Define the HTTP Invoker service URL and the `UserService` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a controller class, add a `UserService` field as a standard autowired service
    bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a controller method, execute the `findAll()` method of the `UserService`
    object and log the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `UserController` class, the autowired `UserService` object is instantiated
    behind the scenes by Spring. It's actually an `HttpInvokerProxyFactoryBean`, which
    will delegate the execution of the `findAll()`method to the HTTP Invoker service
    located at `http://localhost:8080/http_invoker_server/userService`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Hessian service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hessian is a remote method invocation technology; here, a client executes a
    method located on a server-the Hessian service. It uses HTTP, so it can go over
    proxies and firewalls. It also has implementations in multiple languages (PHP,
    Python, Ruby, and so on). So, for example, the client can use Java and the server
    can use PHP.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will add a Hessian service to an existing Spring web application.
    It will expose the methods of a Java class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server will expose the methods of the `UserService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` interface is implemented by `UserServiceImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` methods will receive and send `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `User` class doesn't need to implement `Serializable`. Hessian
    uses its own object serialization mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create a Hessian service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring configuration, add a `UserService` bean returning an instance
    of `UserServiceImpl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `HessianServiceExporter` bean named `/userService`. Define the interface
    exposed by the service and the object implementing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Hessian service is now available at the `/userService` URL of the Spring
    web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HessianServiceExporter` is a Spring class generating a Hessian service from
    a Java interface (`UserService`). For each method defined in `UserService`, the
    corresponding method from `userService()`, in `UserServiceImpl`, will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying an existing Hessian service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will configure a Spring web application, so that it will
    be able to execute a method on an existing Hessian service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will query the Hessian service of the previous *Creating a Hessian service*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the `UserService` interface, so that our application knows the methods
    available on the Hessian service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`User` objects will be exchanged over the network, so we need the `User` class
    of the previous recipe as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps for using a Hessian service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring configuration, add a `HessianProxyFactoryBean` bean named `userService`.
    Define the Hessian service URL and the `UserService` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a controller class, add a `UserService` field as a standard autowired service
    bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a controller method, execute the `findAll()` method of the `UserService`
    object and log the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `UserController` class, the autowired `UserService` object is instantiated
    behind the scenes by Spring. It's actually a `HessianProxyFactoryBean` that will
    delegate the execution of the `findAll()`method to the Hessian service located
    at `http://localhost:8080/hessian/userService`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST uses a web service architecture; here, a client sends an HTTP request to
    a server, which sends back an HTTP response. JSON is most of the time used for
    data transfer. The list of URLs supported by the server is called the REST API.
    These URLs are kept simple using different HTTP methods. For example, the `/users/3`
    request using the GET method will return the user whose ID is 3\. The `/users/3`
    request using the DELETE method will delete that same user.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a simple REST service that will allow a REST
    client to query and modify a list of `User` objects on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `UserService` class with a preset list of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create a REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Maven dependencies for `jackson` in `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the Spring configuration, add a `UserService` bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a controller class with a URL prefix annotated with `@RestController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an autowired `UserService` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a controller method returning the list of all users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a controller method returning the user corresponding to a given ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Spring web application is now a REST service. It will return User objects
    serialized to JSON in response to the `/users` and `/users/1` URL requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UserController` is a standard Spring controller except for the `@RestController`
    annotation, which will automatically convert the objects returned by the controller
    methods to JSON, using the Jackson library.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a specific HTTP method, add the `method` argument in the `@RequestMapping`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To secure a REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: Use HTTPS so that data transfers between the client and server are encrypted.
    Refer to the *Using HTTPS with Tomcat* recipe in [Chapter 6](ch06.html "Chapter 6. Managing
    Security"), *Managing Security*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want only authorized clients to query it, you can use HTTP Basic Authentication.
    Refer to the *Authenticating users using the default login page* recipe from [Chapter
    6](ch06.html "Chapter 6. Managing Security"), *Managing Security*, especially,
    the `httpBasic()` method. Another possibility is to use an OAuth workflow. It's
    more complicated, but it avoids the client having to send a username and password
    at each request. That's the method chosen by Facebook and Twitter for their REST
    API, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying an existing REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, from a Spring controller method, we will retrieve data from
    an existing REST service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will query the REST service of the previous *Creating a REST service* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will convert the JSON data received from the REST service to `User` objects.
    We will use this `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps for using a REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Maven dependencies for Jackson in `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a controller method, define the URL of the REST service to query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `RestTemplate` class and its `getForObject()` method to query the REST
    service and generate a `User` object from the JSON response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RestTemplate` is a class provided by Spring that provides methods to easily
    query REST services and generate Java objects from the received JSON response.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the response is a list of objects, pass an array class as a second parameter
    to generate an array of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
