<html><head></head><body>
		<div id="_idContainer042">
			<h1 class="chapter-number" id="_idParaDest-73"><a id="_idTextAnchor079"/>4</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor080"/>Setting Up the Database and Spring Data JPA</h1>
			<p>In the previous chapter, you learned about Spring Boot’s fundamentals to develop our backend application, such as dependency injection, beans, and annotations. In addition, we now know how to create a Spring Boot project using <span class="No-Break">Spring Initializr.</span></p>
			<p>This chapter will teach you how to connect your Spring Boot application to a database by adding a PSQL container and PostgreSQL dependencies and accessing data using the <strong class="bold">Java Persistence </strong><span class="No-Break"><strong class="bold">API</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JPA</strong></span><span class="No-Break">).</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Connecting to database using a <span class="No-Break">PSQL container</span></li>
				<li>Spring <span class="No-Break">Data JPA</span></li>
				<li>Adding Spring Data JPA and <span class="No-Break">PostgreSQL dependencies</span></li>
				<li>Connecting to <span class="No-Break">a database</span></li>
			</ul>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor081"/>Technical requirements</h1>
			<p>Here is what you need to complete <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">PostgreSQL</strong></span><span class="No-Break">: </span><a href="https://www.postgresql.org/download/windows/"><span class="No-Break">https://www.postgresql.org/download/windows/</span></a></li>
				<li><span class="No-Break"><strong class="bold">pgAdmin</strong></span><span class="No-Break">: </span><a href="https://www.pgadmin.org/download/"><span class="No-Break">https://www.pgadmin.org/download/</span></a></li>
				<li><span class="No-Break"><strong class="bold">Docker</strong></span><span class="No-Break">: </span><a href="https://docs.docker.com/get-docker/"><span class="No-Break">https://docs.docker.com/get-docker/</span></a></li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor082"/>Connecting to a database using a PSQL container</h1>
			<p>This<a id="_idIndexMarker251"/> section will teach us how to set up and<a id="_idIndexMarker252"/> configure our PostgreSQL in our terminal by using the conventional method, using the installer, or through a Docker container. But first, let’s discuss what PostgreSQL is and what its <span class="No-Break">advantages are.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor083"/>PostgreSQL</h2>
			<p><strong class="bold">PostgreSQL</strong> is an open source <a id="_idIndexMarker253"/>object-relational database system that uses the SQL language to store and handle complicated and large workloads. PostgreSQL also supports both <em class="italic">SQL (relational)</em> and <em class="italic">JSON (non-relational)</em> querying. It is commonly used as primary data storage for geospatial and analytics applications because of its flexibility and rich features. Its community has improved and continuously backed it for more than 20 years to add more features and reliability to the <span class="No-Break">database system.</span></p>
			<p>PostgreSQL’s flexibility means<a id="_idIndexMarker254"/> that it is widely used in developing applications. Here are some of the everyday <span class="No-Break">use cases:</span></p>
			<ul>
				<li><strong class="bold">Scientific data</strong>: Research projects can be demanding in storing data, which requires effective and efficient handling. PostgreSQL provides analytical features and a powerful SQL engine that can process a large amount <span class="No-Break">of data.</span></li>
				<li><strong class="bold">Financial industry</strong>: PostgreSQL is used in financial companies because of its analytical capabilities and easy integration with mathematical software such as MATLAB <span class="No-Break">and R.</span></li>
				<li><strong class="bold">Web applications</strong>: PostgreSQL is also used widely in web applications because apps nowadays require processing thousands of pieces of data. It is compatible with modern web frameworks such as Node.js, Hibernate PHP, <span class="No-Break">and Django.</span></li>
				<li><strong class="bold">Government GIS data</strong>: PostgreSQL<a id="_idIndexMarker255"/> offers extensions such as PostGIS that provide functions to process <span class="No-Break">geometric data.</span></li>
			</ul>
			<h3>The features of PostgreSQL</h3>
			<p>Here’s a list of <a id="_idIndexMarker256"/>some of the features that <span class="No-Break">PostgreSQL offers:</span></p>
			<ul>
				<li><strong class="bold">Compatibility with multiple data types</strong>: PostgreSQL is compatible with several <span class="No-Break">data types:</span><ul><li><strong class="bold">Structured</strong>: Arrays, date and time, <strong class="bold">Universally Unique Identifiers</strong> (<strong class="bold">UUIDs</strong>), <span class="No-Break">and</span><span class="No-Break"><a id="_idIndexMarker257"/></span><span class="No-Break"> range</span></li><li><strong class="bold">Customizations</strong>: Custom types, <span class="No-Break">and composite</span></li><li><strong class="bold">Primitives</strong>: String, integer, numeric, <span class="No-Break">and Boolean</span></li><li><strong class="bold">Geometry</strong>: Polygon, circle, line, <span class="No-Break">and point</span></li><li><strong class="bold">Document</strong>: XML, JSON/JSONB, <span class="No-Break">and key-value</span></li></ul></li>
				<li><strong class="bold">Supports different features of SQL</strong>: It offers the various features of SQL, such as <span class="No-Break">the following:</span><ul><li>Multiple indexing, such as B-tree <span class="No-Break">and expressions</span></li><li><span class="No-Break">SQL subselects</span></li><li>Complex <span class="No-Break">SQL queries</span></li><li><strong class="bold">Multi-Version Concurrency </strong><span class="No-Break"><strong class="bold">Control</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">MVCC</strong></span><span class="No-Break">):</span><ul><li><span class="No-Break">Table partitioning</span></li></ul></li></ul></li>
				<li><strong class="bold">Data integrity compatibility</strong>: It<a id="_idIndexMarker258"/> also offers data integrity, which includes <span class="No-Break">the following:</span><ul><li><span class="No-Break">Primary keys</span></li><li><span class="No-Break">Foreign keys</span></li><li><span class="No-Break">Explicit locks</span></li><li><span class="No-Break">Advisory locks</span></li><li><span class="No-Break"><strong class="source-inline">UNIQUE</strong></span></li><li><span class="No-Break"><strong class="source-inline">NOT NULL</strong></span></li></ul></li>
				<li><strong class="bold">Secure database</strong>: It adheres to standard security protocols, which includes <span class="No-Break">the following:</span><ul><li>Authentications<a id="_idIndexMarker259"/> such<a id="_idIndexMarker260"/> as <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>), SCRAM-SHA-256, and the <strong class="bold">Security Support Provider </strong><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SSPI</strong></span><span class="No-Break">)</span></li><li>Supports column and <span class="No-Break">row-level security</span></li></ul></li>
				<li><strong class="bold">Highly extensible</strong>: It offers several features, making it modifiable, such as <span class="No-Break">the following:</span><ul><li>JSON/SQL <span class="No-Break">path expressions</span></li><li>Stored procedures <span class="No-Break">and functions</span></li><li>Compatibility <a id="_idIndexMarker261"/>with foreign <span class="No-Break">data wrappers</span></li></ul></li>
			</ul>
			<p>Now that we have an overview of the features and use cases of PostgreSQL, let’s move on to installing it on <span class="No-Break">our terminal.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor084"/>Installing PostgreSQL</h2>
			<p>There are two ways for us to<a id="_idIndexMarker262"/> set up our PostgreSQL in our development terminal. The two approaches are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Conventional method</strong>: Download the installer directly from the <span class="No-Break">PostgreSQL website.</span></li>
				<li><strong class="bold">PostgreSQL on a Docker container</strong>: Connect our application directly to <span class="No-Break">a container.</span></li>
			</ul>
			<h3>The conventional method – installation on Windows, macOS, and Linux</h3>
			<p>PostgreSQL<a id="_idIndexMarker263"/> was mainly developed for Unix-like platforms. However, it was created to be portable and can be installed on Windows and <span class="No-Break">macOS platforms.</span></p>
			<p>The first step we need to take is to download the PostgreSQL installer through this <span class="No-Break">URL: </span><a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads"><span class="No-Break">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</span></a><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 4.1 – PostgreSQL installation" src="image/B18159_04_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – PostgreSQL installation</p>
			<p>The steps for the <a id="_idIndexMarker264"/>three operating systems are the same, and we only need to configure <span class="No-Break">some settings:</span></p>
			<ol>
				<li>Click the latest version (<strong class="bold">14.1</strong>) and download the installer, depending on your <span class="No-Break">operating system.</span></li>
				<li>After a successful download, open the installer, click <strong class="bold">Next</strong>, and specify the path where PostgreSQL will <span class="No-Break">be installed:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 4.2 – The PostgreSQL installer (specify the path to install)" src="image/B18159_04_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The PostgreSQL installer (specify the path to install)</p>
			<p>In the preceding example, we have chosen the default installation path. Click <strong class="bold">Next</strong> again, which will ask us what components we want to install. The components that we select are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">PostgreSQL Server</strong>: Installs the server where our database <span class="No-Break">will run</span></li>
				<li><strong class="bold">pgAdmin 4</strong>: A GUI management tool for interacting with <span class="No-Break">the database</span></li>
				<li><strong class="bold">Stack Builder</strong>: A GUI that <a id="_idIndexMarker265"/>allows us to download and install drivers that are compatible <span class="No-Break">with PostgreSQL</span></li>
				<li><strong class="bold">Command Line Tools</strong>: Provides interaction with PostgreSQL using <span class="No-Break">command-line tools:</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 4.3 – The PostgreSQL installer (select the needed components)" src="image/B18159_04_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The PostgreSQL installer (select the needed components)</p>
			<p>We have <a id="_idIndexMarker266"/>checked all the components in the preceding example, as we will need all of them throughout <span class="No-Break">our development.</span></p>
			<ol>
				<li value="3">Click <strong class="bold">Next</strong> again, and you will be asked to specify the directory to store <span class="No-Break">the data:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 4.4 – The PostgreSQL installer (select the directory for the data)" src="image/B18159_04_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The PostgreSQL installer (select the directory for the data)</p>
			<p>In the preceding example, we can see that the default path is the same as where PostgreSQL is installed, and it has created a new folder named <strong class="source-inline">data</strong>. It is recommended that you use the <span class="No-Break">default path.</span></p>
			<ol>
				<li value="4">Click <strong class="bold">Next</strong>, which will let you configure the password for the super <span class="No-Break">user (</span><span class="No-Break"><strong class="source-inline">postgres</strong></span><span class="No-Break">).</span></li>
				<li>Click <strong class="bold">Next</strong>, which will <a id="_idIndexMarker267"/>allow you to set the port to be used for the <span class="No-Break"><strong class="source-inline">postgres</strong></span><span class="No-Break"> database.</span></li>
				<li>Click <strong class="bold">Next</strong> again, and you will now be asked what locale should be used for the <span class="No-Break">database cluster:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 4.5 – The PostgreSQL installer (select a locale for the database cluster)" src="image/B18159_04_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The PostgreSQL installer (select a locale for the database cluster)</p>
			<p>In the preceding example, we have selected <strong class="bold">[Default locale]</strong> as our locale for <span class="No-Break">the database.</span></p>
			<ol>
				<li value="7">Click <strong class="bold">Next</strong> again, which will display all of the settings we have configured; make sure all the details are correct <span class="No-Break">before proceeding.</span></li>
				<li>After reviewing, click <strong class="bold">Next</strong>, which will now install PostgreSQL in <span class="No-Break">our terminal.</span></li>
			</ol>
			<p>After installation, we <a id="_idIndexMarker268"/>can verify whether PostgreSQL is installed successfully by checking the currently <span class="No-Break">installed version.</span></p>
			<ol>
				<li value="9">To do this, open <strong class="bold">SQL Shell (psql)</strong> and enter the information of our databases, such as <strong class="source-inline">Server</strong>, <strong class="source-inline">Port</strong>, <strong class="source-inline">Database</strong>, <strong class="source-inline">Username</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Password</strong></span><span class="No-Break">.</span></li>
				<li>Since we have used the default settings, we can press <em class="italic">Enter</em> until password confirmation. After successful validation of our password, execute the <strong class="source-inline">select version()</strong> command to display<a id="_idIndexMarker269"/> the currently <span class="No-Break">installed PostgreSQL:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer036">
					<img alt="Figure 4.6 – The PostgreSQL installer (displaying the version of PostgreSQL)" src="image/B18159_04_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The PostgreSQL installer (displaying the version of PostgreSQL)</p>
			<p>In the preceding example, we can see that we have successfully installed <strong class="bold">PostgreSQL</strong> version <strong class="bold">13.4</strong> on <span class="No-Break">our terminal.</span></p>
			<p>Now, let’s learn how to install and configure PostgreSQL <span class="No-Break">using Docker.</span></p>
			<h3>PostgreSQL on a Docker container</h3>
			<p>We have installed <a id="_idIndexMarker270"/>PostgreSQL on our terminal using the conventional installer; now, we will learn to configure PostgreSQL using Docker. This method will help us skip the complex steps in configuring PostgreSQL for us to start with development and provide a GUI for <span class="No-Break">database management:</span></p>
			<ol>
				<li value="1">The first step you need to do is install Docker on your terminal. You can install Docker at the following link: <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>. For documentation on the system requirements and installation steps for Docker, you can refer to this <span class="No-Break">link: </span><span class="No-Break">https://docs.dockerocker.com/desktop/windows/install/</span><span class="No-Break">.</span></li>
				<li>After successful installation of Docker, open Docker Desktop and start Docker on your Terminal. Then, open your command line and execute the <span class="No-Break">following command:</span><pre class="console">
<strong class="bold">Docker run --name postgresql-container -p 5434:5434 -e POSTGRES_PASSWORD=pass -d postgres</strong></pre></li>
			</ol>
			<p>The preceding command will pull the PSQL from <strong class="source-inline">Docker-hub</strong>. The <strong class="source-inline">postgresql-container</strong> part in the command can be replaced, as this is a container name that we can define. The <strong class="source-inline">POSTGRES_PASSWORD</strong> parameter is the password for the <strong class="source-inline">postgres</strong> admin, which we can <span class="No-Break">also configure.</span></p>
			<ol>
				<li value="3">After <a id="_idIndexMarker271"/>executing the command, we can verify the newly created container by executing the <strong class="source-inline">Docker ps -a</strong> command or viewing Docker Desktop to check the list of <span class="No-Break">containers running:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="Figure 4.7 – The PostgreSQL installation using Docker" src="image/B18159_04_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The PostgreSQL installation using Docker</p>
			<p>In the <a id="_idIndexMarker272"/>preceding example, we have executed the <strong class="source-inline">Docker ps -a</strong> command, and we can see that our PostgreSQL image has <span class="No-Break">been pulled:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 4.8 – The PostgreSQL installation using Docker (viewing the container in Docker Desktop)" src="image/B18159_04_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The PostgreSQL installation using Docker (viewing the container in Docker Desktop)</p>
			<ol>
				<li value="4">We can <a id="_idIndexMarker273"/>also view the pulled <strong class="source-inline">postgresql-container</strong> in Docker Desktop and verify its status in <span class="No-Break">our terminal.</span></li>
			</ol>
			<p>We have successfully configured our PostgreSQL with Docker. We can connect this to our <strong class="source-inline">pgAdmin</strong> by creating a new server with our terminal IP address <span class="No-Break">and port.</span></p>
			<p>We have configured the PostgreSQL database in our terminal. Now, we will learn about Spring Data JPA and its importance in developing <span class="No-Break">Spring applications.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor085"/>Spring Data JPA</h1>
			<p><strong class="bold">Spring Data JPA</strong> (<strong class="bold">Java Persistence API</strong>) is a widely used specification for managing relational data in Java <a id="_idIndexMarker274"/>applications. It helps develop Spring, as it reduces boilerplate code by not implementing read and write operations. It also handles the complex process involved in JDBC-based accessing of database and <span class="No-Break">object-relational mappings.</span></p>
			<p>Before discussing Spring Data JPA, let’s discuss its clear advantages and why it is commonly used in <span class="No-Break">Spring development.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor086"/>The advantages of Spring Data JPA</h2>
			<p>The following are the advantages of Spring <span class="No-Break">Data JPA:</span></p>
			<ul>
				<li><strong class="bold">No-code repositories</strong>: Spring <a id="_idIndexMarker275"/>Data JPA promotes <em class="italic">no-code</em> repositories, which means that we don’t have to write the repository pattern, which creates a lot of repetitive code. It provides a set of interfaces that we can use to extend our classes to apply <span class="No-Break">data-specific implementations.</span></li>
			</ul>
			<p>For example, we have a <strong class="source-inline">BlogRepository</strong> class in our application; when we extend it with the <strong class="source-inline">CrudRepository&lt;Blog, Long&gt;</strong> interface, it will have methods that have the <span class="No-Break">following functionalities:</span></p>
			<ul>
				<li>Persisting, updating, and deleting one or multiple <span class="No-Break">blog entities</span></li>
				<li>Finding one or multiple blogs by their <span class="No-Break">primary keys</span></li>
				<li>Counting <span class="No-Break">all blogs</span></li>
				<li>Validating whether a single <span class="No-Break">blog exists</span></li>
			</ul>
			<p>Extending the repository with the interface provided by Spring Data JPA includes all data-related methods, which allows us to focus more on <span class="No-Break">business logic.</span></p>
			<ul>
				<li><strong class="bold">Boilerplate reduction</strong>: Spring<a id="_idIndexMarker276"/> Data JPA offers built-in implementations for methods. As stated in the first advantage, we only need to focus on business logic and no longer need to code read and write operations, as written under the interfaces. This also prevents human errors, as all implementations are already registered <span class="No-Break">for us.</span></li>
				<li><strong class="bold">Generated queries</strong>: Spring<a id="_idIndexMarker277"/> Data JPA also can create queries based on method names. For example, if we wanted to query a single blog by an author, the only step we need to take is to create a method on our interface with a name that starts with <strong class="source-inline">findBy</strong>, and Spring will parse the name and create <span class="No-Break">a query:</span><pre class="console">
public interface BlogRepository extends   CrudRepository&lt;Blog, Long&gt; {</pre><pre class="console">
Blog findByAuthor(String author);</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the preceding example, we have created a <strong class="source-inline">findByAuthor()</strong> method, which will allow Spring to generate a query and set the parameters as bind parameter values. It will execute the query once we call <span class="No-Break">the method.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor087"/>Repositories provided by Spring Data JPA</h2>
			<p>Spring Data JPA<a id="_idIndexMarker278"/> provides repositories that provide different methods for data-related implementations. The repositories are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">CrudRepository</strong>: The <a id="_idIndexMarker279"/>interface repository, which provides the<a id="_idIndexMarker280"/> basic <a id="_idIndexMarker281"/>operations to <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <span class="No-Break"><strong class="bold">Delete</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CRUD</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">PagingAndSortingRepository</strong>: Extends <strong class="source-inline">CrudRepostiory</strong> and adds a method named <strong class="source-inline">findAll</strong>, which can<a id="_idIndexMarker282"/> sort results and be retrieved<a id="_idIndexMarker283"/> in a <span class="No-Break">paginated manner.</span></li>
				<li><strong class="source-inline">JpaRepository</strong>: Adds<a id="_idIndexMarker284"/> specific JPA <a id="_idIndexMarker285"/>methods and has all the functions of <strong class="source-inline">CrudRepository</strong> and <strong class="source-inline">PagingAndSortingRepository</strong>. It also adds methods such as <strong class="source-inline">flush()</strong>, which flushes the persistence context, and <strong class="source-inline">deleteInBatch()</strong>, which deletes records in <span class="No-Break">a batch.</span></li>
			</ul>
			<p>We have learned about the different repositories we can use with Spring Data JPA. We will now take a look at Spring Data JPA on <span class="No-Break">Spring Boot.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor088"/>Spring Data JPA on Spring Boot</h2>
			<p>For us to implement Spring Data <a id="_idIndexMarker286"/>JPA in our application, we need the <span class="No-Break">following components:</span></p>
			<ul>
				<li><strong class="source-inline">Entity</strong>: This is a simple class that defines our model. It will be used as a JPA entity, generated with a <span class="No-Break">primary key.</span></li>
			</ul>
			<p>For example, we will create an entity for <strong class="source-inline">Villain</strong> by making a plain class and adding <strong class="source-inline">@Entity</strong> annotations to indicate the <strong class="source-inline">Villain</strong> class as a JPA entity. The entity will be used as the type for extending <span class="No-Break">our repository:</span></p>
			<pre class="console">
@Entity
public class Villain {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO,
                  generator   = "UUID")
  @Column(nullable = false, updatable = false)
  private UUID id;
  @NotNull(message = "First Name is required")
  private String firstName;
  private String lastName;
  private String house;
  private String knownAs;
}</pre>
			<p>We can see in the preceding example that our <strong class="source-inline">Villain</strong> class is annotated with <strong class="source-inline">@Entity</strong>, indicating it as a JPA entity. We have also defined an <strong class="source-inline">id</strong> field of the <strong class="source-inline">UUID</strong> type and annotated it with <strong class="source-inline">@Id</strong> to indicate that this is the primary key, and <strong class="source-inline">@GeneratedValue</strong>, where we specified that this is automatically generated using <strong class="source-inline">strategy = GenerationType</strong>.The <strong class="source-inline">AUTO</strong> and the ID generated should be of the <strong class="source-inline">UUID</strong> type, using <strong class="source-inline">generator = "</strong><span class="No-Break"><strong class="source-inline">UUID"</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="source-inline">Repository</strong>: This is an<a id="_idIndexMarker287"/> interface that we need to extend with JPA repositories for the entities to have <span class="No-Break">built-in operations.</span></li>
			</ul>
			<p>In the previous example, we have a <strong class="source-inline">Villain</strong> entity. To implement the CRUD operations, we will create a <strong class="source-inline">VillainRepository</strong> interface and extend it with <strong class="source-inline">CrudRepository</strong>, with a type of <strong class="source-inline">Villain</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">UUID</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
@Repository
public interface VillainRepository extends CrudRepository&lt;Villain, UUID&gt; {
  // custom composite repository here
}</pre>
			<ul>
				<li><strong class="source-inline">Service</strong>: This is where we will use our created repository. We can use the <strong class="source-inline">@Autowired</strong> annotation to inject the repository and call the JPA and <span class="No-Break">custom-defined methods:</span><pre class="console">
@Service</pre><pre class="console">
public class VillainService {</pre><pre class="console">
private final VillainRepository villainRepository;</pre><pre class="console">
@Autowired</pre><pre class="console">
public VillainService (VillainRepository villainRepository) {</pre><pre class="console">
  this. villainRepository = villainRepository;</pre><pre class="console">
}</pre><pre class="console">
  public Iterable&lt;Villain&gt; findAllVillains() {</pre><pre class="console">
    return villainRepository.findAll();</pre><pre class="console">
  }</pre><pre class="console">
  public Villain findVillainById(UUID id) {</pre><pre class="console">
    return findOrThrow(id);</pre><pre class="console">
  }</pre></li>
			</ul>
			<p>In the preceding example, we can see that we have injected <strong class="source-inline">VillainRepository</strong> in <strong class="source-inline">VillainService</strong> using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Autowired</strong></span><span class="No-Break"> annotation.</span></p>
			<p>Let’s continue with the<a id="_idIndexMarker288"/> following methods using the <span class="No-Break">same file:</span></p>
			<pre class="console">
public void removeVillainById(UUID id) {
    villainRepository.deleteById(id);
  }
  public Villain addVillain(Villain villain) {
    return villainRepository.save(villain);
  }
  public void updateVillain(UUID id, Villain villain) {
    findOrThrow(id);
    villainRepository.save(villain);
  }
  private Villain findOrThrow(final UUID id) {
    return villainRepository
      .findById(id)
      .orElseThrow(
        () -&gt; new NotFoundException("Villain by id " +
          id + " was not found")
      );
  }
}</pre>
			<p>We have also created methods by using the built-in JPA implementation, such as <strong class="source-inline">save()</strong>, <strong class="source-inline">deleteById()</strong>, <strong class="source-inline">findAll()</strong>, and <strong class="source-inline">findById()</strong>, which are found in the <strong class="source-inline">CrudRepository</strong> interface. The service can now be injected into our controllers or<a id="_idIndexMarker289"/> other services to use <span class="No-Break">the methods.</span></p>
			<p>We’ve now learned about Spring Data JPA, its advantages, and an overview of implementation on Spring JPA. In the next section, we will learn how to add Spring Data JPA and PostgreSQL dependencies to our Spring <span class="No-Break">Boot application.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor089"/>Adding Spring Data JPA and PostgreSQL dependencies</h1>
			<p>This section will add Spring Data JPA, PostgreSQL, and other valuable dependencies to our application. We will add the dependencies with Spring Initializr and an existing Spring <span class="No-Break">Boot project.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor090"/>Adding with Spring Initializr</h2>
			<p>Adding dependencies<a id="_idIndexMarker290"/> after creating a Spring Boot application using Spring Initializr is simple. We only need to select the dependencies on Initializr before generating <span class="No-Break">our project:</span></p>
			<ol>
				<li value="1">The first thing to do is to go to <a href="https://start.spring.io/">https://start.spring.io/</a> or to your IntelliJ IDEA (for Ultimate users) to open Spring Initializr (for a recap of the <em class="italic">Using Spring Initializr</em> section, refer to <a href="B18159_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Moving into </em><span class="No-Break"><em class="italic">Spring Boot</em></span><span class="No-Break">).</span></li>
				<li>Choose your project if it will use Maven or Gradle and set the required configurations, which are <strong class="bold">Group</strong>, <strong class="bold">Artifact, Name</strong>, <strong class="bold">Description</strong>, <strong class="bold">Package name</strong>, <strong class="bold">Packaging</strong>, and the <strong class="bold">Java</strong> version of <span class="No-Break">the project.</span></li>
				<li>Next, click <strong class="bold">Add Dependencies</strong> at the top right and select the <span class="No-Break">following dependencies:</span><ul><li><strong class="bold">Spring Data JPA</strong>: This dependency is for adding Spring Data JPA used for built-in data <span class="No-Break">store-related implementation.</span></li><li><strong class="bold">H2 Database</strong>: This is an in-memory database that supports the JDBC API and R2DBC access, which is commonly used for <span class="No-Break">unit testing</span></li><li><strong class="bold">PostgreSQL Driver</strong>: This is a JDBC and R2DBC driver that will allow the connection of Java applications to the <span class="No-Break">PostgreSQL database:</span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Figure 4.9 – Adding dependencies in Spring Initializr" src="image/B18159_04_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Adding dependencies in Spring Initializr</p>
			<p>After successfully adding the dependencies, we can see that our dependencies are <span class="No-Break">already listed.</span></p>
			<ol>
				<li value="4">Click on <strong class="bold">GENERATE</strong>, which will <a id="_idIndexMarker291"/>download our already <span class="No-Break">generated project.</span></li>
				<li>Extract the ZIP file and open the project on your IDE. If you developed your project using Maven, open <strong class="source-inline">pom.xml</strong> in the <strong class="source-inline">src</strong> folder, or if you are using<strong class="bold"> </strong>Gradle, open <strong class="source-inline">build.gradle</strong>, which is also found in the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure ﻿4.10 – The Spring Boot application (a view of pom.xml)" src="image/B18159_04_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – The Spring Boot application (a view of pom.xml)</p>
			<p>In the preceding <a id="_idIndexMarker292"/>example, we can see that the Spring Boot application is generated with Maven, and we can see that our <strong class="source-inline">pom.xml</strong> file has included the dependencies we added in <span class="No-Break">Spring Initializr:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Figure ﻿4.11 – The Spring Boot application (a view of build.gradle)" src="image/B18159_04_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – The Spring Boot application (a view of build.gradle)</p>
			<p>Now, in the<a id="_idIndexMarker293"/> preceding example, where the Spring Boot application is generated with Gradle, we can see the list of dependencies is already added under the <span class="No-Break"><strong class="source-inline">build.gradle</strong></span><span class="No-Break"> file.</span></p>
			<p>We will now add the dependencies to an existing Spring <span class="No-Break">Boot application.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor091"/>Adding an existing project</h2>
			<p>In the previous<a id="_idIndexMarker294"/> example, we added the dependencies to generate our Spring Boot application using Spring Initializr. Now, we will add our dependencies to an existing application. It is simple to add a dependency to an existing Spring app; we only need to modify the <strong class="source-inline">pom.xml</strong> (Maven) or <strong class="source-inline">build.gradle</strong> (<span class="No-Break">Gradle) files.</span></p>
			<p>To install Spring Data JPA, the H2 database, and PostgreSQL Driver using Maven, we will add the dependencies in the form of XML, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;dependencies&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;com.h2database&lt;/groupId&gt;
      &lt;artifactId&gt;h2&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
      &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
   &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>
			<p>And for a Spring <a id="_idIndexMarker295"/>application using Gradle, we will add the dependencies <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
dependencies {
   implementation 'org.springframework.boot:spring-boot-
   starter-data-jpa'
   runtimeOnly 'com.h2database:h2'
   runtimeOnly 'org.postgresql:postgresql'
}</pre>
			<p>IntelliJ will automatically<a id="_idIndexMarker296"/> recognize the added dependencies and install them for the project, and we can successfully build and run the Spring Boot application on <span class="No-Break">the fly.</span></p>
			<p>We have learned how to add Spring Data JPA and PostgreSQL Driver to our Spring Boot application. In the next section, we will learn how to connect our Spring Boot application to our <span class="No-Break">PostgreSQL database.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor092"/>Connecting to a database</h1>
			<p>We have already configured our PostgreSQL database<a id="_idIndexMarker297"/> and initialized our Spring Boot application with the needed dependencies. Now, we will learn how to connect our PostgreSQL to our application. There are two ways we can connect to our database – the first is through Spring JDBC, and the other is Spring Data JPA. Spring Data JPA is the most convenient way to connect to our database, but we will demonstrate both methods in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor093"/>Configuring the database properties</h2>
			<p>The first thing we need to do is <a id="_idIndexMarker298"/>configure the database properties in our Spring Boot application. We need to specify the server URL of the database, the admin username, and the password by adding the following source code to the <span class="No-Break"><strong class="source-inline">application.properties</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
spring.datasource.url=jdbc:postgresql://localhost:5432/springDB
spring.datasource.username=postgres
spring.datasource.password=password</pre>
			<p>In the preceding example, we can see that we have configured the basic connection settings for our PostgreSQL. <strong class="source-inline">springDB</strong> on the URL will be the name of the database in PostgreSQL, which should already exist on <span class="No-Break">our server.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor094"/>Connecting using Spring JDBC</h2>
			<p>The first method to <a id="_idIndexMarker299"/>connect to the database is by using <a id="_idIndexMarker300"/>Spring JDBC. We will add an additional dependency to our application for us to use <span class="No-Break">this method.</span></p>
			<p>To add JDBC, we will add the following code to our <strong class="source-inline">pom.xml</strong> (Maven) or <strong class="source-inline">build.gradle</strong> (<span class="No-Break">Gradle) files:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
			<p>After<a id="_idIndexMarker301"/> successfully adding the JDBC dependency, we <a id="_idIndexMarker302"/>can now use <strong class="source-inline">JdbcTemplate</strong> to execute queries on <span class="No-Break">our application:</span></p>
			<pre class="source-code">
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.jdbc.core.JdbcTemplate;
@SpringBootApplication
public class AwesomeJavaProject  {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    public static void main(String[] args) {
        SpringApplication.run(AwesomeJavaProject .class,
                              args);
    }
    @Override
    public void run(String... args) throws Exception {
        String sql = "INSERT INTO blog (title, author,
          body) VALUES ("+ "'Awesome Java Project',
                        'Seiji Villafranca', 'This is an
                         awesome blog for java')";
        int rows = jdbcTemplate.update(sql);
    }
}</pre>
			<p>In the<a id="_idIndexMarker303"/> preceding example, we can execute <a id="_idIndexMarker304"/>database statements such as <strong class="source-inline">INSERT</strong> in our application and call the <strong class="source-inline">update()</strong> method to modify data in <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor095"/>Connecting using Spring Data JPA</h2>
			<p>The second method is by <a id="_idIndexMarker305"/>using the <a id="_idIndexMarker306"/>Spring Data JPA plugin. The first step we need to take is to add additional details to the <span class="No-Break"><strong class="source-inline">application.properties</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true</pre>
			<p>After adding the new settings, we can now create <strong class="source-inline">Entity</strong> and <strong class="source-inline">Repository</strong> for a specific table in our application – for example, we have a <span class="No-Break"><strong class="source-inline">Blog</strong></span><span class="No-Break"> table:</span></p>
			<pre class="source-code">
package net.codejava;
import javax.persistence.*;
@Entity
@Table(name = "blog")
public class Blog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String title;
    private String body;
    private String author;
}</pre>
			<p>In the preceding example, we have created a <strong class="source-inline">Blog</strong> class and annotated it with <strong class="source-inline">@Entity</strong> and <strong class="source-inline">@Table</strong> to indicate that this is an object connected to our <span class="No-Break">database table:</span></p>
			<pre class="source-code">
package net.codejava;
import org.springframework.data.JPA.repository.JpaRepository;
public interface BlogRepository extends JpaRepository&lt;Blog, Integer&gt; {
}</pre>
			<p>After <a id="_idIndexMarker307"/>creating our entity, we <a id="_idIndexMarker308"/>have made the repository for the blog, which can be extended by the repositories provided by JPA. <strong class="source-inline">BlogRepository</strong> can now be injected into our services or controllers to read, add, modify, or delete data on <span class="No-Break">our database.</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor096"/>Summary</h1>
			<p>That brings you to the end of this chapter. Let’s have a recap of the valuable things you have learned. You learned how to set up PostgreSQL on your local machine using the installer or <span class="No-Break">Docker container.</span></p>
			<p>You have also learned about the concepts and advantages of Spring Data JPA in Spring Boot and how to add it to your application, which is helpful in creating services with CRUD capabilities with less <span class="No-Break">boilerplate code.</span></p>
			<p>Last but not least, you learned how to connect your Spring Boot application with the PostgreSQL database using JDBC and Spring <span class="No-Break">Data JPA.</span></p>
			<p>In the next chapter, we will be learning how to start our server, how to add controllers, models, and services in our code, and about Redis <span class="No-Break">for caching.</span></p>
		</div>
	</body></html>