- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ultra-Fast In-Memory Persistence with Eclipse Store
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NoSQL and SQL databases can be impressive and powerful when handling their
    target use cases. However, users seeking optimal performance need to be aware
    of other aspects that can influence the application in terms of processing efficiency,
    speed, and even code design. In this regard, one example can be mentioned upfront:
    most of these database solutions will require some sort of mapping between the
    database schema and the application data models. As you can imagine, the mapping
    needs to happen every single time data flows back and forth between the application
    and the database. This characteristic, known as **object-relational impedance
    mismatch**, has a high potential to impact most of the database types we’ve mentioned
    so far – SQL and NoSQL.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss another database paradigm, in-memory databases.
    Adding to the significant performance boost, this is definitely the type of database
    to be leveraged when working on use cases such as data processing, web and mobile
    apps, and caching and real-time analytics. For such scenarios, a highly performant
    data storage solution, low-latency data access, and real-time data processing
    appear to be promising alternatives since they allow for the delivery of super-fast
    persistence solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore the aforementioned concepts with **Eclipse Store**, a high-performance,
    lightweight solution for in-memory persistence. One of the points of this database
    is to be faster and eliminate extra processing, and reduce code size and complexity,
    especially when compared with the integration of, for example, SQL databases and
    Hibernate/JPA.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Why is latency secretly added to every database operation? We will understand
    what object-relational impedance mismatch is and how it can affect persistence
    performance.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an in-memory persistence storage and how does it differ from other database
    types?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Eclipse Store.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse Store with Jakarta/MicroProfile.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Object-relational impedance mismatch explained
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Java developers, we know the power of the **object-oriented programming**
    (**OOP**) paradigm – it allows us to explore several patterns based on polymorphism,
    encapsulation, heritage, interface, creating custom types, and so on. We love
    it! Mainly because we can combine these approaches with design patterns to create
    clean and readable code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many of these OOP concepts and behaviors are not available on
    the database side, a characteristic named **impedance mismatch**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-Relational Mapping** (**ORM**) impedance mismatch is a specific type
    of impedance mismatch that occurs when mapping data between an oop language and
    a **relational database management** **system** (**RDBMS**).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象-关系映射**（**ORM**）阻抗不匹配是在将数据在面向对象语言和**关系数据库管理系统**（**RDBMS**）之间映射时发生的一种特定类型的阻抗不匹配。'
- en: OOP languages such as Java, Python, and C# use objects to represent and manipulate
    data, whereas relational databases use tables to store and manage data. ORM is
    a technique used to bridge the gap between these two different paradigms by mapping
    objects to database tables and vice versa.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如Java、Python和C#这样的面向对象（OOP）语言使用对象来表示和操作数据，而关系数据库使用表来存储和管理数据。ORM是一种技术，通过将对象映射到数据库表以及反向映射来弥合这两种不同范式之间的差距。
- en: '![Figure 8.1 – Example of Java object model equivalent mapping on the database
    schema](img/Figure_8.01_B19375.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 数据库模式上Java对象模型等价映射的示例](img/Figure_8.01_B19375.jpg)'
- en: Figure 8.1 – Example of Java object model equivalent mapping on the database
    schema
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 数据库模式上Java对象模型等价映射的示例
- en: The ORM impedance mismatch occurs because objects and tables have different
    properties and structures. For example, objects can have complex data types, inheritance,
    and polymorphism, while tables consist of simple rows and columns. In addition,
    objects can have relationships with other entities, whereas tables have relationships
    between rows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ORM阻抗不匹配发生的原因是对象和表具有不同的属性和结构。例如，对象可以具有复杂的数据类型、继承和多态，而表由简单的行和列组成。此外，对象可以与其他实体有关系，而表则行与行之间存在关系。
- en: To mitigate this impedance mismatch and make the developer more efficient, ORM
    tools provide mapping strategies that allow developers to map objects to tables
    and vice versa. These strategies can include ORM patterns such as table inheritance,
    association mapping, and lazy loading.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种阻抗不匹配并提高开发效率，ORM工具提供了映射策略，允许开发人员将对象映射到表以及反向映射。这些策略可以包括ORM模式，如表继承、关联映射和延迟加载。
- en: Despite these strategies, ORM impedance mismatch can still occur due to differences
    in the query language, performance issues, and scalability problems. As a result,
    developers need to be aware of the limitations and trade-offs involved in using
    ORM tools and consider alternative solutions where necessary.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些策略，但由于查询语言、性能问题和可扩展性问题，ORM阻抗不匹配仍然可能发生。因此，开发人员需要了解使用ORM工具所涉及的限制和权衡，并在必要时考虑替代解决方案。
- en: Another item to highlight in regard to the mapping processing is that it uses
    a mapper. The mapper, used on every app-database interaction, is responsible for
    converting to/from entities and requires a lot of CPU power, which may end up
    being heavier than the executed query itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射处理方面，另一个需要强调的事项是它使用映射器。这个映射器在每次应用程序-数据库交互中使用，负责将实体转换为/从实体转换，并且需要大量的CPU资源，这可能会导致比执行的查询本身更重。
- en: This mapper has a bright mechanism for communicating between paradigms. Even
    with a cache and the most advanced techniques to improve performance, this process
    might be a nightmare in several applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射器具有一种在范式之间通信的明亮机制。即使有缓存和最先进的性能提升技术，这个过程在许多应用程序中也可能是一个噩梦。
- en: A technology we can adopt to beat this challenge and avoid doing extra Java
    processing on every database operation is Eclipse Store. Let’s get into what this
    in-memory database is, how it works, and how you can get started with it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用的一种技术来克服这个挑战，并避免在每次数据库操作上都进行额外的Java处理，就是Eclipse Store。让我们深入了解这个内存数据库是什么，它是如何工作的，以及如何开始使用它。
- en: Eclipse Store is a Java-based, open source, in-memory data storage technology
    that offers a new approach to object persistence.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store是一种基于Java的开源内存数据存储技术，它提供了一种新的对象持久化方法。
- en: Unlike traditional databases that rely on ORM to map objects to relational tables,
    Eclipse Store’s internal mechanisms locate and use Java objects available on the
    heap. It can get the information *directly* from memory, eliminating the need
    for mapping or serialization. This approach results in faster application performance
    since it avoids the ORM impedance mismatch and reduces the need for costly database
    access.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖于ORM将对象映射到关系表的传统数据库不同，Eclipse Store的内部机制定位并使用堆上的Java对象。它可以直接从内存中获取信息，消除映射或序列化的需要。这种方法由于避免了ORM阻抗不匹配并减少了昂贵的数据库访问需求，从而实现了更快的应用程序性能。
- en: Eclipse Store began as MicroStream 10 years ago as a closed source project.
    Recently, MicroStream went open source and became two Eclipse projects, one being
    Eclipse Store.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store 10 年前作为 MicroStream 的一个闭源项目开始。最近，MicroStream 开源了，并成为两个 Eclipse
    项目，其中一个是 Eclipse Store。
- en: Eclipse Store provides a Java API that allows developers to store, load, and
    manipulate Java objects directly in memory without the need to access a separate
    database. The data can optionally be persisted externally, and in such cases,
    it is stored in a compressed binary format, allowing for efficient memory resource
    use. This approach eliminates the need for ORM, which can be time-consuming and
    resource-intensive, especially for complex object hierarchies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store 提供了一个 Java API，允许开发者直接在内存中存储、加载和操作 Java 对象，无需访问单独的数据库。数据可以选择外部持久化，在这种情况下，它以压缩的二进制格式存储，从而允许高效地使用内存资源。这种方法消除了
    ORM 的需求，ORM 可能耗时且资源密集，尤其是对于复杂的对象层次结构。
- en: Eclipse Store operates mostly in memory; therefore, it can provide ultra-fast
    read and write access to data, making it ideal for high-performance data-processing
    applications, such as real-time analytics, financial trading, and gaming.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store 主要在内存中运行；因此，它可以提供对数据的超快读写访问，使其非常适合高性能数据处理应用，如实时分析、金融交易和游戏。
- en: In addition to its speed and performance benefits, Eclipse Store offers a high
    degree of flexibility and scalability. It supports distributed data structures,
    allowing data to be distributed across multiple nodes and integrated with other
    databases or data sources.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其速度和性能优势外，Eclipse Store 还提供了高度的可灵活性和可扩展性。它支持分布式数据结构，允许数据跨多个节点分布，并与其他数据库或数据源集成。
- en: Overall, Eclipse Store provides a compelling alternative to traditional ORM-based
    databases, offering faster performance and reduced complexity for applications
    that require ultra-fast data processing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Eclipse Store 为传统基于 ORM 的数据库提供了一个有吸引力的替代方案，为需要超快数据处理的程序提供了更快的性能和更低的复杂性。
- en: '![Figure 8.2 – Architecture overview of Eclipse Store](img/Figure_8.02_B19375.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Eclipse Store 架构概述](img/Figure_8.02_B19375.jpg)'
- en: Figure 8.2 – Architecture overview of Eclipse Store
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Eclipse Store 架构概述
- en: 'Applications using Eclipse Store as the in-memory data storage solution can
    rely on the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Eclipse Store 作为内存数据存储解决方案的应用程序可以依赖以下功能：
- en: '**Fast performance**: Integrate fast and efficiently, relying on quick read
    and write operations without the extra overhead of an ORM tool.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速性能**：快速高效地集成，依赖于快速读写操作，无需 ORM 工具的额外开销。'
- en: '**In-memory storage**: Fast access to data, as it is obtained directly from
    the memory heap.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存存储**：快速访问数据，因为它直接从内存堆中获取。'
- en: '**Easy to use**: Developers can quickly get up to speed as the technology is
    designed to be simple and easy to use, with a familiar Java syntax and optional
    annotations that make it easy to define and persist data.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：由于该技术旨在简单易用，具有熟悉的 Java 语法和可选的注解，因此开发者可以快速上手，轻松定义和持久化数据。'
- en: '**No external dependencies**: Using it is pretty simple as the only dependency
    you’ll need is Eclipse Store (which basically depends on a logging library). You
    should have no concerns regarding library conflicts or compatibility issues.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无外部依赖**：使用它非常简单，因为您唯一需要的依赖项就是 Eclipse Store（它基本上依赖于一个日志库）。您不应担心库冲突或兼容性问题。'
- en: '**Lightweight**: A data storage solution that doesn’t require a lot of resources
    or configuration, and is easy to set up and deploy.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**：一种不需要大量资源或配置的数据存储解决方案，易于设置和部署。'
- en: '**Flexibility**: Choose from all of the data types (with very few exceptions),
    and use it in various application sizes – from small-scale projects to enterprise-level
    systems.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：从所有数据类型（非常少数例外）中选择，并在各种应用规模中使用它——从小型项目到企业级系统。'
- en: '**Open source**: Eclipse Store is offered in multiple types, one of them being
    a free open source project, meaning unlimited usage and customization that can
    meet your specific needs.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：Eclipse Store 提供多种类型，其中之一是免费开源项目，这意味着无限使用和定制，以满足您的特定需求。'
- en: '**High availability**: When used, it provides built-in high availability and
    redundancy features, ensuring your data is always available and protected.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：使用时，它提供内置的高可用性和冗余功能，确保您的数据始终可用且受保护。'
- en: '**Scalability**: Easily add more nodes or resources to handle increasing data
    volumes, as the database is designed from scratch to meet such goals.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：轻松添加更多节点或资源来处理不断增长的数据量，因为数据库是从零开始设计的，以满足这些目标。'
- en: In the following sections, we’ll drill down into this powerful and flexible
    solution for in-memory data management and persistence that can help developers
    build fast and efficient applications. Let’s learn about the basics of Eclipse
    Store, go through code examples, and understand how to create an ultra-fast application
    with a modern, cloud-native, in-memory, open source solution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将深入探讨这个强大且灵活的内存数据管理和持久化解决方案，它可以帮助开发者构建快速高效的应用程序。让我们了解Eclipse Store的基本知识，通过代码示例，并理解如何使用现代、云原生、内存中、开源的解决方案创建一个超快的应用程序。
- en: In-memory persistence storage – Eclipse Store
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存持久化存储 – Eclipse Store
- en: Eclipse Store is a data storage solution that is fast due to the removal of
    the mapping process, the parse operation on queries, avoiding drawbacks of traditional
    query execution, and using a unique and advanced serialization process. Eclipse
    Store estimates that 90% of the query time is based on these operations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store是一种数据存储解决方案，由于去除了映射过程、查询的解析操作，避免了传统查询执行的缺点，并使用独特且先进的序列化过程，因此运行速度快。Eclipse
    Store估计90%的查询时间基于这些操作。
- en: The benchmarks ([https://eclipsestore.io/](https://eclipsestore.io/)) show results
    that can be up to **1,000 times faster** than a SQL database with JPA. Positive
    aspects from a developer perspective are the short learning curve and the simplicity
    of installation and use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试（[https://eclipsestore.io/](https://eclipsestore.io/)）显示的结果可以比使用JPA的SQL数据库快**1,000倍**。从开发者的角度来看，积极的一面是学习曲线短，安装和使用简单。
- en: To get started, the first step is to install Eclipse Store, which is as simple
    as adding a dependency to your application’s Maven configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，第一步是安装Eclipse Store，这就像在应用程序的Maven配置中添加一个依赖项一样简单。
- en: Some key points of this solution include achieving lightning-fast in-memory
    data processing using pure Java, with the capability for microsecond query times,
    low-latency data access, and handling massive data workloads. This approach enables
    significant savings in CPU power, reduces CO2 emissions, and lowers costs within
    data centers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案的一些关键点包括使用纯Java实现闪电般的内存数据处理，具有微秒级查询时间、低延迟数据访问和处理海量数据负载的能力。这种方法可以实现显著的CPU功率节省，减少二氧化碳排放，并降低数据中心成本。
- en: 'Memory is volatile; therefore, in order to behave as a persistent storage,
    data must be stored somewhere else. Eclipse Store’s default storage target is
    the filesystem, in a local folder. That’s a good option to start with, but thinking
    of production needs, you’ll probably want to save your data in different locations.
    The good news is you can choose from over 15 different options: the storage targets
    ([https://docs.microstream.one/manual/storage/storage-targets/index.html](https://docs.microstream.one/manual/storage/storage-targets/index.html))
    range from relational databases to NoSQL databases, as well as blob services.
    Examples would be MariaDB, PostgreSQL, Redis, and Amazon S3.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是易失的；因此，为了作为持久存储，数据必须存储在其他地方。Eclipse Store的默认存储目标是文件系统，在本地文件夹中。这是一个不错的起点，但考虑到生产需求，你可能希望将数据保存在不同的位置。好消息是你可以从超过15个不同的选项中进行选择：存储目标（[https://docs.microstream.one/manual/storage/storage-targets/index.html](https://docs.microstream.one/manual/storage/storage-targets/index.html)）从关系型数据库到NoSQL数据库，以及blob服务。例如，MariaDB、PostgreSQL、Redis和Amazon
    S3。
- en: Another possibility unlocked by using this technology that you may enjoy as
    well is that you can now create a custom graph structure as per your business
    needs and query with pure Java (no need to use SQL and similar!), decreasing the
    cognitive load for developers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这项技术解锁的另一个可能性，你可能也会喜欢，那就是你现在可以按照业务需求创建自定义的图结构，并使用纯Java进行查询（无需使用SQL等！），这降低了开发者的认知负荷。
- en: You can use Eclipse Store with several runtime technologies, such as Helidon,
    Spring, and Quarkus. In this book, we explain how to use it relying only on CDI;
    in other words, you’ll learn how to use the technology independent of the vendor
    or platform it is going to be integrated with. Once we get up to speed on the
    basics using only the Java standard APIs, we should be able to start trying out
    different Jakarta EE and MicroProfile vendors, such as Helidon, Wildfly, and Payara.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In our context, CDI acts as the glue between our enterprise’s architectural
    components. Thus, it is the mechanism that enables you to inject Eclipse Store
    as a library, a component, a module, and so on. Let’s get started now with seeing
    how to persist and manage data using in-memory database storage and CDI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The basics of how to store and manage data in memory
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explain Eclipse Store further, let’s see it in action: we’ll create our
    first example with Java SE and CDI. The goal of this example is to demonstrate
    how to create a smooth CRUD process for a car, where each car should hold its
    model, make, and year as attributes.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first – create a simple Maven project using `maven-archetype-quickstart`.
    Installing Eclipse Store is simple; all you need is to add its dependencies to
    the Maven project. See an example of `pom.xml` as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the dependency is set, we can start coding. The following Java class,
    the `Car` entity, is our data model. As per Eclipse Store’s recommendation, the
    attributes should be defined as `final`, resulting in an immutable class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step is to create the graph or structure to hold the data and provide
    it to us. To represent the collection of cars, we’ll create a `Garage` repository
    where all data manipulation should happen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: You’re free to manipulate a car’s data or to create any other new data structure;
    you code it using pure Java and leave it to Eclipse Store to handle the rest.
    The only required component we must use is the identification of this `Garage`
    as a structure. To do so, annotate it with the `@``Storage` annotation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Storage` annotation indicates the root object of the graph that will
    be handled by Eclipse Store. In this case, `Garage` is our root object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example covers all the required code and dependencies for us to be able
    to use `Garage` to add and find cars by model. And it only uses Java SE, no specific
    runtime!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we’ll cover the second sample focusing on the service layer,
    where we’ll implement the validation of the entity’s data before it is moved to
    storage. This validation is pretty straightforward; we’ll check whether `car`
    is `null`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: In order to manipulate the `cars` data, we’ll need an instance of `Garage` in
    our `CarService`. To use CDI to provide us with an instance of this class, we
    can use the `@Inject` annotation from CDI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing a database operation, we would probably want it to happen in
    a transaction, right? Yes, in the relational database maybe. Here, we rely on
    the `@Store` annotation to configure which methods should be allowed to change
    the data structure. Observe the `public` `void add` **(Car car)** method as follows
    and its annotation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great, we have enough code at this point in order to test it out and have some
    fun, so let’s execute it! To consume our `CarService` APIs, we’ll need a new class,
    which we can call `App`, and a `public static void main(final String[] args)`
    method. In the first couple of lines of the code demonstrated next, notice the
    following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The service API that retrieves the list of all the cars, `service.getCars()`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search operation invoked by the service API, `service.findByModel("Corolla")`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When running the code for the first time, you’ll observe in the output logs
    that the retrieved cars list will be empty; however, when you run it twice, you
    can see the data:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you try running this code a couple of times, you may notice that around the
    third try, it looks like the items are getting duplicated! This is a behavior
    of our `list` object, which can be easily adjusted to solve this behavior. Update
    the structure to a `Set` instead of `List` and ensure that the `Car` entity has
    the equals and hashcode implemented adequately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The application’s `properties` file holds the settings configuration for the
    *directory* and the *number of threads* used in the engine. The possibility to
    externalize this configuration is facilitated by to the integration with *Eclipse
    MicroProfile Configuration* ([https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html](https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html)).
    We saw a similar configuration approach in the previous chapter about JNoSQL,
    as it relies on the same underlying configuration mechanism:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pretty simple, right? Before we move forward, let’s understand the importance
    of the second setting listed previously, `one.Eclipse Store.channel.count`. This
    in-memory solution can be fine-tuned in multiple ways, one of them being adjusting
    the number of channels (threads) that the engine can use to execute I/O operations.
    This configuration should always be configured with a value equal to 2n.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing the configuration with specification-based approaches facilitates
    service maintenance. It should require very little effort when changing your application
    implementation, as you’ll notice in the upcoming section when we create a microservice
    based on this sample code. The reason for the simplified maintenance is that the
    chosen in-memory database storage, Eclipse Store, uses CDI, which happens to also
    be the core engine for both MicroProfile and Jakarta EE.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: After exploring how to configure and implement a service that relies on in-memory
    data storage, we will next see how to migrate the code sample as part of a microservice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Using in-memory data storage with Jakarta EE and MicroProfile
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to the engines in the MicroProfile and Jakarta EE specifications, we
    can very easily choose which one best fits the application’s goal. In [*Chapter
    5*](B19375_05.xhtml#_idTextAnchor093), we discussed both specifications and why
    they are essential for the Java community:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you can access the MicroProfile website ([https://start.microprofile.io/](https://start.microprofile.io/))
    and the starter project. It works just like the Spring initializer, for Spring-based
    applications.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once on the page, confirm that MicroProfile version 3.3 is available, and choose
    one of the options. Make sure to check the **Config** checkbox in order to save
    some time and get some auto-generated basic files.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this example, we’ll use the **Helidon** runtime.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – MicroProfile starter website](img/Figure_8.03_B19375.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – MicroProfile starter website
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, all we must do is add the Eclipse Store dependency to the `pom.xml` application,
    as the Eclipse MicroProfile implementation already provides both **config** and
    CDI:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, use the ancient programmer technique… copy and paste! You can copy the
    dependency configurations from the previous project into your new MicroProfile-based
    project.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to be able to modify an entity, such as the `Car` entity. As the
    entity is immutable, creating new instances must be done through its constructor.
    The adoption of this good practice is not required by the data storage solution,
    Eclipse Store, but it is a good approach for using the entities in the REST endpoints.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In the `Car` class, identify and annotate its constructor method with `@JsonCreator`
    and `@JsonProperty`, which come from the JSON binding specifications ([https://jakarta.ee/specifications/jsonb/2.0/](https://jakarta.ee/specifications/jsonb/2.0/)).
    Notice that these are not annotations required by Eclipse Store.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `Year` type to `Integer`, to avoid creating a custom interface to
    serialize and deserialize data:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are building the `Car` entity as an immutable class; therefore, its fields
    are final and can be set by using injections on the constructor method. To help
    us achieve this goal, we’ll use a JSONB-compatible implementation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Add the `@JsonbCreator` annotation, to turn this class into an eligible bean
    for the API, and so that the `@JsonProperty` annotation can link the respective
    parameter with the defined JSON property.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Note*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We can delete CarBuilder once the creation process is through JSON.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a resource where we’ll see the path and URL. We’ll expose all
    the services we made using the URL, so we’ll have to list the cars by finding
    a model and inserting a car:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our resource class is ready to be used on our microservices. As you can see
    here, we’re injecting `CarService` and using this integration to connect with
    this `GarageResource`, which we can explore through HTTP requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的资源类已经准备好在我们的微服务中使用。正如你所看到的，我们正在注入`CarService`并使用这个集成来连接到这个`GarageResource`，我们可以通过HTTP请求来探索它。
- en: 'We have all the code ready; let’s build and execute the application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所有代码；让我们构建并执行应用程序：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the service is up, we can explore it by creating a frontend that consumes
    this service or using an HTTP client UI. We’ll run our sample using `curl`. We’ll
    make three cars and then return them from the service:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务启动后，我们可以通过创建一个消耗此服务的客户端前端或使用HTTP客户端UI来探索它。我们将使用`curl`运行我们的示例。我们将创建三辆车，然后从服务中返回它们：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This was a sample HTTP request using the curl program; feel free to use any
    HTTP client that you wish, such as Postman.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用curl程序发出的示例HTTP请求；请随意使用你想要的任何HTTP客户端，例如Postman。
- en: We also need to append the Eclipse Store settings in this application. Another
    point is we updated the `ApplicationPath` annotation to `"/"`. Furthermore, we
    added the `Garage` resources, but we won’t put the full details here; please,
    check out the repository to get all the details.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将Eclipse Store设置附加到这个应用程序中。另一个要点是我们更新了`ApplicationPath`注解为`"/"`。此外，我们添加了`Garage`资源，但在这里不会提供全部细节；请查看仓库以获取所有详细信息。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Eclipse Store brings a new persistence perspective; you can increase performance
    by reducing the mapper process. It impacts not only the application’s response
    time but also cloud costs since it requires fewer machines, and consequently reduces
    infrastructure cost.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store带来了新的持久化视角；你可以通过减少映射器进程来提高性能。它不仅影响应用程序的响应时间，还影响云成本，因为它需要更少的机器，从而降低了基础设施成本。
- en: This chapter looked at Java integration with CDI on Java SE and microservices
    using MicroProfile. We saw the power of several databases and persistence solutions,
    but how can we merge them? You’ll find out in the next chapter, about polyglot
    persistence.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Java SE和微服务中CDI的集成，以及使用MicroProfile。我们看到了几个数据库和持久化解决方案的力量，但我们如何将它们合并？你将在下一章中找到答案，关于多语言持久化。
- en: 'Part 3: Architectural Perspective over Persistence'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：持久化的架构视角
- en: In this section of the book, we take an architectural perspective on persistence,
    exploring various topics related to designing and implementing robust and scalable
    persistence solutions. This session delves into the architectural considerations
    and challenges associated with persistence in modern Java solutions, from polyglot
    persistence to modernization strategies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们从架构的角度探讨了持久化，探讨了与设计和实现健壮和可扩展持久化解决方案相关的各种主题。本节深入探讨了与现代Java解决方案中持久化相关的架构考虑和挑战，从多语言持久化到现代化策略。
- en: 'This part has the following chapters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含以下章节：
- en: '[*Chapter 9*](B19375_09.xhtml#_idTextAnchor165)*, Persistence Practices: Exploring
    Polyglot Persistence*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19375_09.xhtml#_idTextAnchor165)*，持久化实践：探索多语言持久化*'
- en: '[*Chapter 10*](B19375_10.xhtml#_idTextAnchor175)*, Architecting Distributed
    Systems: Challenges and Anti-Patterns*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19375_10.xhtml#_idTextAnchor175)*，构建分布式系统：挑战和反模式*'
- en: '[*Chapter 11*](B19375_11.xhtml#_idTextAnchor184)*, Modernization Strategies
    and Data Integration*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19375_11.xhtml#_idTextAnchor184)*，现代化策略和数据集成*'
- en: '[*Chapter 12*](B19375_12.xhtml#_idTextAnchor195)*, Final Considerations on
    Persistence in Modern Java Solutions*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19375_12.xhtml#_idTextAnchor195)*，现代Java解决方案中持久化的最终考虑*'
