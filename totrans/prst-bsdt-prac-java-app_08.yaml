- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ultra-Fast In-Memory Persistence with Eclipse Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NoSQL and SQL databases can be impressive and powerful when handling their
    target use cases. However, users seeking optimal performance need to be aware
    of other aspects that can influence the application in terms of processing efficiency,
    speed, and even code design. In this regard, one example can be mentioned upfront:
    most of these database solutions will require some sort of mapping between the
    database schema and the application data models. As you can imagine, the mapping
    needs to happen every single time data flows back and forth between the application
    and the database. This characteristic, known as **object-relational impedance
    mismatch**, has a high potential to impact most of the database types we’ve mentioned
    so far – SQL and NoSQL.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss another database paradigm, in-memory databases.
    Adding to the significant performance boost, this is definitely the type of database
    to be leveraged when working on use cases such as data processing, web and mobile
    apps, and caching and real-time analytics. For such scenarios, a highly performant
    data storage solution, low-latency data access, and real-time data processing
    appear to be promising alternatives since they allow for the delivery of super-fast
    persistence solutions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore the aforementioned concepts with **Eclipse Store**, a high-performance,
    lightweight solution for in-memory persistence. One of the points of this database
    is to be faster and eliminate extra processing, and reduce code size and complexity,
    especially when compared with the integration of, for example, SQL databases and
    Hibernate/JPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is latency secretly added to every database operation? We will understand
    what object-relational impedance mismatch is and how it can affect persistence
    performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an in-memory persistence storage and how does it differ from other database
    types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Eclipse Store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse Store with Jakarta/MicroProfile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08).
  prefs: []
  type: TYPE_NORMAL
- en: Object-relational impedance mismatch explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Java developers, we know the power of the **object-oriented programming**
    (**OOP**) paradigm – it allows us to explore several patterns based on polymorphism,
    encapsulation, heritage, interface, creating custom types, and so on. We love
    it! Mainly because we can combine these approaches with design patterns to create
    clean and readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many of these OOP concepts and behaviors are not available on
    the database side, a characteristic named **impedance mismatch**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-Relational Mapping** (**ORM**) impedance mismatch is a specific type
    of impedance mismatch that occurs when mapping data between an oop language and
    a **relational database management** **system** (**RDBMS**).'
  prefs: []
  type: TYPE_NORMAL
- en: OOP languages such as Java, Python, and C# use objects to represent and manipulate
    data, whereas relational databases use tables to store and manage data. ORM is
    a technique used to bridge the gap between these two different paradigms by mapping
    objects to database tables and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Example of Java object model equivalent mapping on the database
    schema](img/Figure_8.01_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Example of Java object model equivalent mapping on the database
    schema
  prefs: []
  type: TYPE_NORMAL
- en: The ORM impedance mismatch occurs because objects and tables have different
    properties and structures. For example, objects can have complex data types, inheritance,
    and polymorphism, while tables consist of simple rows and columns. In addition,
    objects can have relationships with other entities, whereas tables have relationships
    between rows.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this impedance mismatch and make the developer more efficient, ORM
    tools provide mapping strategies that allow developers to map objects to tables
    and vice versa. These strategies can include ORM patterns such as table inheritance,
    association mapping, and lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these strategies, ORM impedance mismatch can still occur due to differences
    in the query language, performance issues, and scalability problems. As a result,
    developers need to be aware of the limitations and trade-offs involved in using
    ORM tools and consider alternative solutions where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Another item to highlight in regard to the mapping processing is that it uses
    a mapper. The mapper, used on every app-database interaction, is responsible for
    converting to/from entities and requires a lot of CPU power, which may end up
    being heavier than the executed query itself.
  prefs: []
  type: TYPE_NORMAL
- en: This mapper has a bright mechanism for communicating between paradigms. Even
    with a cache and the most advanced techniques to improve performance, this process
    might be a nightmare in several applications.
  prefs: []
  type: TYPE_NORMAL
- en: A technology we can adopt to beat this challenge and avoid doing extra Java
    processing on every database operation is Eclipse Store. Let’s get into what this
    in-memory database is, how it works, and how you can get started with it.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Store is a Java-based, open source, in-memory data storage technology
    that offers a new approach to object persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional databases that rely on ORM to map objects to relational tables,
    Eclipse Store’s internal mechanisms locate and use Java objects available on the
    heap. It can get the information *directly* from memory, eliminating the need
    for mapping or serialization. This approach results in faster application performance
    since it avoids the ORM impedance mismatch and reduces the need for costly database
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Store began as MicroStream 10 years ago as a closed source project.
    Recently, MicroStream went open source and became two Eclipse projects, one being
    Eclipse Store.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Store provides a Java API that allows developers to store, load, and
    manipulate Java objects directly in memory without the need to access a separate
    database. The data can optionally be persisted externally, and in such cases,
    it is stored in a compressed binary format, allowing for efficient memory resource
    use. This approach eliminates the need for ORM, which can be time-consuming and
    resource-intensive, especially for complex object hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Store operates mostly in memory; therefore, it can provide ultra-fast
    read and write access to data, making it ideal for high-performance data-processing
    applications, such as real-time analytics, financial trading, and gaming.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its speed and performance benefits, Eclipse Store offers a high
    degree of flexibility and scalability. It supports distributed data structures,
    allowing data to be distributed across multiple nodes and integrated with other
    databases or data sources.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Eclipse Store provides a compelling alternative to traditional ORM-based
    databases, offering faster performance and reduced complexity for applications
    that require ultra-fast data processing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Architecture overview of Eclipse Store](img/Figure_8.02_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Architecture overview of Eclipse Store
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications using Eclipse Store as the in-memory data storage solution can
    rely on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast performance**: Integrate fast and efficiently, relying on quick read
    and write operations without the extra overhead of an ORM tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-memory storage**: Fast access to data, as it is obtained directly from
    the memory heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to use**: Developers can quickly get up to speed as the technology is
    designed to be simple and easy to use, with a familiar Java syntax and optional
    annotations that make it easy to define and persist data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No external dependencies**: Using it is pretty simple as the only dependency
    you’ll need is Eclipse Store (which basically depends on a logging library). You
    should have no concerns regarding library conflicts or compatibility issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightweight**: A data storage solution that doesn’t require a lot of resources
    or configuration, and is easy to set up and deploy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Choose from all of the data types (with very few exceptions),
    and use it in various application sizes – from small-scale projects to enterprise-level
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source**: Eclipse Store is offered in multiple types, one of them being
    a free open source project, meaning unlimited usage and customization that can
    meet your specific needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High availability**: When used, it provides built-in high availability and
    redundancy features, ensuring your data is always available and protected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Easily add more nodes or resources to handle increasing data
    volumes, as the database is designed from scratch to meet such goals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we’ll drill down into this powerful and flexible
    solution for in-memory data management and persistence that can help developers
    build fast and efficient applications. Let’s learn about the basics of Eclipse
    Store, go through code examples, and understand how to create an ultra-fast application
    with a modern, cloud-native, in-memory, open source solution.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory persistence storage – Eclipse Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse Store is a data storage solution that is fast due to the removal of
    the mapping process, the parse operation on queries, avoiding drawbacks of traditional
    query execution, and using a unique and advanced serialization process. Eclipse
    Store estimates that 90% of the query time is based on these operations.
  prefs: []
  type: TYPE_NORMAL
- en: The benchmarks ([https://eclipsestore.io/](https://eclipsestore.io/)) show results
    that can be up to **1,000 times faster** than a SQL database with JPA. Positive
    aspects from a developer perspective are the short learning curve and the simplicity
    of installation and use.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, the first step is to install Eclipse Store, which is as simple
    as adding a dependency to your application’s Maven configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Some key points of this solution include achieving lightning-fast in-memory
    data processing using pure Java, with the capability for microsecond query times,
    low-latency data access, and handling massive data workloads. This approach enables
    significant savings in CPU power, reduces CO2 emissions, and lowers costs within
    data centers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory is volatile; therefore, in order to behave as a persistent storage,
    data must be stored somewhere else. Eclipse Store’s default storage target is
    the filesystem, in a local folder. That’s a good option to start with, but thinking
    of production needs, you’ll probably want to save your data in different locations.
    The good news is you can choose from over 15 different options: the storage targets
    ([https://docs.microstream.one/manual/storage/storage-targets/index.html](https://docs.microstream.one/manual/storage/storage-targets/index.html))
    range from relational databases to NoSQL databases, as well as blob services.
    Examples would be MariaDB, PostgreSQL, Redis, and Amazon S3.'
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility unlocked by using this technology that you may enjoy as
    well is that you can now create a custom graph structure as per your business
    needs and query with pure Java (no need to use SQL and similar!), decreasing the
    cognitive load for developers.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Eclipse Store with several runtime technologies, such as Helidon,
    Spring, and Quarkus. In this book, we explain how to use it relying only on CDI;
    in other words, you’ll learn how to use the technology independent of the vendor
    or platform it is going to be integrated with. Once we get up to speed on the
    basics using only the Java standard APIs, we should be able to start trying out
    different Jakarta EE and MicroProfile vendors, such as Helidon, Wildfly, and Payara.
  prefs: []
  type: TYPE_NORMAL
- en: In our context, CDI acts as the glue between our enterprise’s architectural
    components. Thus, it is the mechanism that enables you to inject Eclipse Store
    as a library, a component, a module, and so on. Let’s get started now with seeing
    how to persist and manage data using in-memory database storage and CDI.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of how to store and manage data in memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explain Eclipse Store further, let’s see it in action: we’ll create our
    first example with Java SE and CDI. The goal of this example is to demonstrate
    how to create a smooth CRUD process for a car, where each car should hold its
    model, make, and year as attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first – create a simple Maven project using `maven-archetype-quickstart`.
    Installing Eclipse Store is simple; all you need is to add its dependencies to
    the Maven project. See an example of `pom.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dependency is set, we can start coding. The following Java class,
    the `Car` entity, is our data model. As per Eclipse Store’s recommendation, the
    attributes should be defined as `final`, resulting in an immutable class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create the graph or structure to hold the data and provide
    it to us. To represent the collection of cars, we’ll create a `Garage` repository
    where all data manipulation should happen.
  prefs: []
  type: TYPE_NORMAL
- en: You’re free to manipulate a car’s data or to create any other new data structure;
    you code it using pure Java and leave it to Eclipse Store to handle the rest.
    The only required component we must use is the identification of this `Garage`
    as a structure. To do so, annotate it with the `@``Storage` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Storage` annotation indicates the root object of the graph that will
    be handled by Eclipse Store. In this case, `Garage` is our root object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example covers all the required code and dependencies for us to be able
    to use `Garage` to add and find cars by model. And it only uses Java SE, no specific
    runtime!
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we’ll cover the second sample focusing on the service layer,
    where we’ll implement the validation of the entity’s data before it is moved to
    storage. This validation is pretty straightforward; we’ll check whether `car`
    is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to manipulate the `cars` data, we’ll need an instance of `Garage` in
    our `CarService`. To use CDI to provide us with an instance of this class, we
    can use the `@Inject` annotation from CDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing a database operation, we would probably want it to happen in
    a transaction, right? Yes, in the relational database maybe. Here, we rely on
    the `@Store` annotation to configure which methods should be allowed to change
    the data structure. Observe the `public` `void add` **(Car car)** method as follows
    and its annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, we have enough code at this point in order to test it out and have some
    fun, so let’s execute it! To consume our `CarService` APIs, we’ll need a new class,
    which we can call `App`, and a `public static void main(final String[] args)`
    method. In the first couple of lines of the code demonstrated next, notice the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The service API that retrieves the list of all the cars, `service.getCars()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search operation invoked by the service API, `service.findByModel("Corolla")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When running the code for the first time, you’ll observe in the output logs
    that the retrieved cars list will be empty; however, when you run it twice, you
    can see the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you try running this code a couple of times, you may notice that around the
    third try, it looks like the items are getting duplicated! This is a behavior
    of our `list` object, which can be easily adjusted to solve this behavior. Update
    the structure to a `Set` instead of `List` and ensure that the `Car` entity has
    the equals and hashcode implemented adequately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application’s `properties` file holds the settings configuration for the
    *directory* and the *number of threads* used in the engine. The possibility to
    externalize this configuration is facilitated by to the integration with *Eclipse
    MicroProfile Configuration* ([https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html](https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html)).
    We saw a similar configuration approach in the previous chapter about JNoSQL,
    as it relies on the same underlying configuration mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pretty simple, right? Before we move forward, let’s understand the importance
    of the second setting listed previously, `one.Eclipse Store.channel.count`. This
    in-memory solution can be fine-tuned in multiple ways, one of them being adjusting
    the number of channels (threads) that the engine can use to execute I/O operations.
    This configuration should always be configured with a value equal to 2n.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing the configuration with specification-based approaches facilitates
    service maintenance. It should require very little effort when changing your application
    implementation, as you’ll notice in the upcoming section when we create a microservice
    based on this sample code. The reason for the simplified maintenance is that the
    chosen in-memory database storage, Eclipse Store, uses CDI, which happens to also
    be the core engine for both MicroProfile and Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: After exploring how to configure and implement a service that relies on in-memory
    data storage, we will next see how to migrate the code sample as part of a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Using in-memory data storage with Jakarta EE and MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to the engines in the MicroProfile and Jakarta EE specifications, we
    can very easily choose which one best fits the application’s goal. In [*Chapter
    5*](B19375_05.xhtml#_idTextAnchor093), we discussed both specifications and why
    they are essential for the Java community:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you can access the MicroProfile website ([https://start.microprofile.io/](https://start.microprofile.io/))
    and the starter project. It works just like the Spring initializer, for Spring-based
    applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once on the page, confirm that MicroProfile version 3.3 is available, and choose
    one of the options. Make sure to check the **Config** checkbox in order to save
    some time and get some auto-generated basic files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this example, we’ll use the **Helidon** runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – MicroProfile starter website](img/Figure_8.03_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – MicroProfile starter website
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, all we must do is add the Eclipse Store dependency to the `pom.xml` application,
    as the Eclipse MicroProfile implementation already provides both **config** and
    CDI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, use the ancient programmer technique… copy and paste! You can copy the
    dependency configurations from the previous project into your new MicroProfile-based
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to be able to modify an entity, such as the `Car` entity. As the
    entity is immutable, creating new instances must be done through its constructor.
    The adoption of this good practice is not required by the data storage solution,
    Eclipse Store, but it is a good approach for using the entities in the REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Car` class, identify and annotate its constructor method with `@JsonCreator`
    and `@JsonProperty`, which come from the JSON binding specifications ([https://jakarta.ee/specifications/jsonb/2.0/](https://jakarta.ee/specifications/jsonb/2.0/)).
    Notice that these are not annotations required by Eclipse Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `Year` type to `Integer`, to avoid creating a custom interface to
    serialize and deserialize data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are building the `Car` entity as an immutable class; therefore, its fields
    are final and can be set by using injections on the constructor method. To help
    us achieve this goal, we’ll use a JSONB-compatible implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `@JsonbCreator` annotation, to turn this class into an eligible bean
    for the API, and so that the `@JsonProperty` annotation can link the respective
    parameter with the defined JSON property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Note*'
  prefs: []
  type: TYPE_NORMAL
- en: We can delete CarBuilder once the creation process is through JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a resource where we’ll see the path and URL. We’ll expose all
    the services we made using the URL, so we’ll have to list the cars by finding
    a model and inserting a car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our resource class is ready to be used on our microservices. As you can see
    here, we’re injecting `CarService` and using this integration to connect with
    this `GarageResource`, which we can explore through HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have all the code ready; let’s build and execute the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the service is up, we can explore it by creating a frontend that consumes
    this service or using an HTTP client UI. We’ll run our sample using `curl`. We’ll
    make three cars and then return them from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This was a sample HTTP request using the curl program; feel free to use any
    HTTP client that you wish, such as Postman.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to append the Eclipse Store settings in this application. Another
    point is we updated the `ApplicationPath` annotation to `"/"`. Furthermore, we
    added the `Garage` resources, but we won’t put the full details here; please,
    check out the repository to get all the details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse Store brings a new persistence perspective; you can increase performance
    by reducing the mapper process. It impacts not only the application’s response
    time but also cloud costs since it requires fewer machines, and consequently reduces
    infrastructure cost.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter looked at Java integration with CDI on Java SE and microservices
    using MicroProfile. We saw the power of several databases and persistence solutions,
    but how can we merge them? You’ll find out in the next chapter, about polyglot
    persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Architectural Perspective over Persistence'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section of the book, we take an architectural perspective on persistence,
    exploring various topics related to designing and implementing robust and scalable
    persistence solutions. This session delves into the architectural considerations
    and challenges associated with persistence in modern Java solutions, from polyglot
    persistence to modernization strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19375_09.xhtml#_idTextAnchor165)*, Persistence Practices: Exploring
    Polyglot Persistence*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19375_10.xhtml#_idTextAnchor175)*, Architecting Distributed
    Systems: Challenges and Anti-Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19375_11.xhtml#_idTextAnchor184)*, Modernization Strategies
    and Data Integration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19375_12.xhtml#_idTextAnchor195)*, Final Considerations on
    Persistence in Modern Java Solutions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
