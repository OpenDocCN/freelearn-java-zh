<html><head></head><body>
		<div id="_idContainer054">
			<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor151"/>8</h1>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor152"/>Ultra-Fast In-Memory Persistence with Eclipse Store</h1>
			<p>NoSQL and SQL databases can be impressive and powerful when handling their target use cases. However, users seeking optimal performance need to be aware of other aspects that can influence the application in terms of processing efficiency, speed, and even code design. In this regard, one example can be mentioned upfront: most of these database solutions will require some sort of mapping between the database schema and the application data models. As you can imagine, the mapping needs to happen every single time <a id="_idIndexMarker336"/>data flows back and forth between the application and the database. This characteristic, known as <strong class="bold">object-relational impedance mismatch</strong>, has a high potential to impact most of the database types we’ve mentioned so far – SQL <span class="No-Break">and NoSQL.</span></p>
			<p>In this chapter, we will discuss another database paradigm, in-memory databases. Adding to the significant performance boost, this is definitely the type of database to be leveraged when working on use cases such as data processing, web and mobile apps, and caching and real-time analytics. For such scenarios, a highly performant data storage solution, low-latency data access, and real-time data processing appear to be promising alternatives since they allow for the delivery of super-fast <span class="No-Break">persistence solutions.</span></p>
			<p>We’ll explore the aforementioned <a id="_idIndexMarker337"/>concepts with <strong class="bold">Eclipse Store</strong>, a high-performance, lightweight solution for in-memory persistence. One of the points of this database is to be faster and eliminate extra processing, and reduce code size and complexity, especially when compared with the integration of, for example, SQL databases <span class="No-Break">and Hibernate/JPA.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Why is latency secretly added to every database operation? We will understand what object-relational impedance mismatch is and how it can affect <span class="No-Break">persistence performance.</span></li>
				<li>What is an in-memory persistence storage and how does it differ from other <span class="No-Break">database types?</span></li>
				<li>Exploring <span class="No-Break">Eclipse Store.</span></li>
				<li>Eclipse Store <span class="No-Break">with Jakarta/MicroProfile.</span></li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor153"/>Technical requirements</h1>
			<p>The following are the technical requirements for <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Git</span></li>
				<li><span class="No-Break">Maven</span></li>
				<li>Any <span class="No-Break">preferred IDE</span></li>
			</ul>
			<p>The source code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08"><span class="No-Break">https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08</span></a><span class="No-Break"><span class="hidden"><a id="_idTextAnchor154"/></span></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor155"/>Object-relational impedance mismatch explained</h1>
			<p>As Java developers, we know the power of the <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) paradigm – it allows us to explore several <a id="_idIndexMarker338"/>patterns based on polymorphism, encapsulation, heritage, interface, creating custom types, and so on. We love it! Mainly because we can combine these approaches with design patterns to create clean and <span class="No-Break">readable code.</span></p>
			<p>Unfortunately, many of these OOP concepts and behaviors are not available on the database side, a characteristic named <span class="No-Break"><strong class="bold">impedance mismatch</strong></span><span class="No-Break">.</span></p>
			<p><strong class="bold">Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) impedance <a id="_idIndexMarker339"/>mismatch is a specific type of impedance mismatch that occurs when mapping data <a id="_idIndexMarker340"/>between an oop language and a <strong class="bold">relational database management </strong><span class="No-Break"><strong class="bold">system</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">RDBMS</strong></span><span class="No-Break">).</span></p>
			<p>OOP languages such as Java, Python, and C# use objects to represent and manipulate data, whereas relational databases use tables to store and manage data. ORM is a technique used to bridge the gap between these two different paradigms by mapping objects to database tables and <span class="No-Break">vice versa.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="Figure 8.1 – Example of Java object model equivalent mapping on the database schema" src="image/Figure_8.01_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Example of Java object model equivalent mapping on the database schema</p>
			<p>The ORM <a id="_idIndexMarker341"/>impedance mismatch occurs because objects and tables have different properties and structures. For example, objects can have complex data types, inheritance, and polymorphism, while tables consist of simple rows and columns. In addition, objects can have relationships with other entities, whereas tables have relationships <span class="No-Break">between rows.</span></p>
			<p>To mitigate this impedance mismatch and make the developer more efficient, ORM tools provide mapping strategies that allow developers to map objects to tables and vice versa. These strategies can include ORM patterns such as table inheritance, association mapping, and <span class="No-Break">lazy loading.</span></p>
			<p>Despite these strategies, ORM impedance mismatch can still occur due to differences in the query language, performance issues, and scalability problems. As a result, developers need to be aware of the limitations and trade-offs involved in using ORM tools and consider alternative solutions <span class="No-Break">where necessary.</span></p>
			<p>Another item to highlight in regard to the mapping processing is that it uses a mapper. The mapper, used on every app-database interaction, is responsible for converting to/from entities and requires a lot of CPU power, which may end up being heavier than the executed <span class="No-Break">query itself.</span></p>
			<p>This mapper has a bright mechanism for communicating between paradigms. Even with a cache and the most advanced techniques to improve performance, this process might be a nightmare in <span class="No-Break">several applications.</span></p>
			<p>A technology we can adopt to beat this challenge and avoid doing extra Java processing on every database operation is Eclipse Store. Let’s get into what this in-memory database is, how it works, and how you can get started <span class="No-Break">with it.</span></p>
			<p>Eclipse Store is a Java-based, open source, in-memory data storage technology that offers a new approach to <span class="No-Break">object persistence.</span></p>
			<p>Unlike traditional databases that rely on ORM to map objects to relational tables, Eclipse Store’s internal mechanisms locate and use Java objects available on the heap. It can get the information <em class="italic">directly</em> from memory, eliminating the need for mapping or serialization. This approach results in faster application performance since it avoids the ORM impedance mismatch and reduces the need for costly <span class="No-Break">database access.</span></p>
			<p>Eclipse <a id="_idIndexMarker342"/>Store began as MicroStream 10 years ago as a closed source project. Recently, MicroStream went open source and became two Eclipse projects, one being <span class="No-Break">Eclipse Store.</span></p>
			<p>Eclipse Store provides a Java API that allows developers to store, load, and manipulate Java objects <a id="_idIndexMarker343"/>directly in memory without the need to access a separate database. The data can optionally be persisted externally, and in such cases, it is stored in a compressed binary format, allowing for efficient memory resource use. This approach eliminates the need for ORM, which can be time-consuming and resource-intensive, especially for complex <span class="No-Break">object hierarchies.</span></p>
			<p>Eclipse Store operates mostly in memory; therefore, it can provide ultra-fast read and write access to data, making it ideal for high-performance data-processing applications, such as real-time analytics, financial trading, <span class="No-Break">and gaming.</span></p>
			<p>In addition to its speed and performance benefits, Eclipse Store offers a high degree of flexibility and scalability. It supports distributed data structures, allowing data to be distributed across multiple nodes and integrated with other databases or <span class="No-Break">data sources.</span></p>
			<p>Overall, Eclipse Store provides a compelling alternative to traditional ORM-based databases, offering faster performance and reduced complexity for applications that require ultra-fast <span class="No-Break">data processing.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 8.2 – Architecture overview of Eclipse Store" src="image/Figure_8.02_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Architecture overview of Eclipse Store</p>
			<p>Applications <a id="_idIndexMarker344"/>using Eclipse Store as the in-memory data storage solution can rely on <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Fast performance</strong>: Integrate fast and efficiently, relying on quick read and write operations without the extra overhead of an <span class="No-Break">ORM tool.</span></li>
				<li><strong class="bold">In-memory storage</strong>: Fast access to data, as it is obtained directly from the <span class="No-Break">memory heap.</span></li>
				<li><strong class="bold">Easy to use</strong>: Developers can quickly get up to speed as the technology is designed to be simple and easy to use, with a familiar Java syntax and optional annotations that make it easy to define and <span class="No-Break">persist data.</span></li>
				<li><strong class="bold">No external dependencies</strong>: Using it is pretty simple as the only dependency you’ll need is Eclipse Store (which basically depends on a logging library). You should have no concerns regarding library conflicts or <span class="No-Break">compatibility issues.</span></li>
				<li><strong class="bold">Lightweight</strong>: A data storage solution that doesn’t require a lot of resources or configuration, and is easy to set up <span class="No-Break">and deploy.</span></li>
				<li><strong class="bold">Flexibility</strong>: Choose from all of the data types (with very few exceptions), and use it in various application sizes – from small-scale projects to <span class="No-Break">enterprise-level systems.</span></li>
				<li><strong class="bold">Open source</strong>: Eclipse Store is offered in multiple types, one of them being a free open source project, meaning unlimited usage and customization that can meet your <span class="No-Break">specific needs.</span></li>
				<li><strong class="bold">High availability</strong>: When used, it provides built-in high availability and redundancy features, ensuring your data is always available <span class="No-Break">and protected.</span></li>
				<li><strong class="bold">Scalability</strong>: Easily add more nodes or resources to handle increasing data volumes, as the database is designed from scratch to meet <span class="No-Break">such goals.</span></li>
			</ul>
			<p>In the following sections, we’ll drill down into this powerful and flexible solution for in-memory <a id="_idIndexMarker345"/>data management and persistence that can help developers build fast and efficient applications. Let’s learn about the basics of Eclipse Store, go through code examples, and understand how to create an ultra-fast application with a modern, cloud-native, in-memory, open <span class="No-Break">source so<a id="_idTextAnchor156"/>lution.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor157"/>In-memory persistence storage – Eclipse Store</h1>
			<p>Eclipse Store is a <a id="_idIndexMarker346"/>data storage solution that is fast due to the removal of the mapping process, the parse operation on queries, avoiding drawbacks of traditional query execution, and using a unique and advanced serialization process. Eclipse Store estimates that 90% of the query time is based on <span class="No-Break">these operations.</span></p>
			<p>The benchmarks (<a href="https://eclipsestore.io/">https://eclipsestore.io/</a>) show results that can be up to <strong class="bold">1,000 times faster</strong> than a SQL database with JPA. Positive aspects from a developer perspective are the short learning curve and the simplicity of installation <span class="No-Break">and use.</span></p>
			<p>To get started, the first step is to install Eclipse Store, which is as simple as adding a dependency to your application’s <span class="No-Break">Maven configuration.</span></p>
			<p>Some key points of this solution include achieving lightning-fast in-memory data processing using pure Java, with the capability for microsecond query times, low-latency data access, and handling massive data workloads. This approach enables significant savings in CPU power, reduces CO<span class="subscript">2</span> emissions, and lowers costs within <span class="No-Break">data centers.</span></p>
			<p>Memory is volatile; therefore, in order to behave as a persistent storage, data must be stored somewhere else. Eclipse Store’s default storage target is the filesystem, in a local folder. That’s a good option to start with, but thinking of production needs, you’ll probably want to save your data in different locations. The good news is you can choose from over 15 different options: the storage targets (<a href="https://docs.microstream.one/manual/storage/storage-targets/index.html">https://docs.microstream.one/manual/storage/storage-targets/index.html</a>) range from relational databases to NoSQL databases, as well as blob services. Examples would be MariaDB, PostgreSQL, Redis, and <span class="No-Break">Amazon S3.</span></p>
			<p>Another possibility <a id="_idIndexMarker347"/>unlocked by using this technology that you may enjoy as well is that you can now create a custom graph structure as per your business needs and query with pure Java (no need to use SQL and similar!), decreasing the cognitive load <span class="No-Break">for developers.</span></p>
			<p>You can use Eclipse Store with several runtime technologies, such as Helidon, Spring, and Quarkus. In this book, we explain how to use it relying only on CDI; in other words, you’ll learn how to use the technology independent of the vendor or platform it is going to be integrated with. Once we get up to speed on the basics using only the Java standard APIs, we should be able to start trying out different Jakarta EE and MicroProfile vendors, such as Helidon, Wildfly, <span class="No-Break">and Payara.</span></p>
			<p>In our context, CDI acts as the glue between our enterprise’s architectural components. Thus, it is the mechanism that enables you to inject Eclipse Store as a library, a component, a module, and so on. Let’s get started now with seeing how to persist and manage data using in-memory database storage <a id="_idTextAnchor158"/><span class="No-Break">and CDI.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor159"/>The basics of how to store and manage data in memory</h2>
			<p>To explain Eclipse Store further, let’s see it in action: we’ll create our first example with Java SE and CDI. The goal of this example is to demonstrate how to create a smooth CRUD <a id="_idIndexMarker348"/>process for a car, where each car should hold its model, make, and year <span class="No-Break">as attributes.</span></p>
			<p>First <a id="_idIndexMarker349"/>things first – create a simple Maven project using <strong class="source-inline">maven-archetype-quickstart</strong>. Installing Eclipse Store is simple; all you need is to add its dependencies to the Maven project. See an example of <strong class="source-inline">pom.xml</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;one.microstream&lt;/groupId&gt;
    &lt;artifactId&gt;eclipse-store-integrations-cdi&lt;/artifactId&gt;
    &lt;version&gt;07.00.00-MS-GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt;
    &lt;artifactId&gt;weld-se-shaded&lt;/artifactId&gt;
    &lt;version&gt;3.1.9.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-config&lt;/artifactId&gt;
    &lt;version&gt;2.7.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>Once the dependency is set, we can start coding. The following Java class, the <strong class="source-inline">Car</strong> entity, is our data model. As per Eclipse Store’s recommendation, the attributes should be defined as <strong class="source-inline">final</strong>, resulting in an <span class="No-Break">immutable class:</span></p>
			<pre class="source-code">
public class Car {    private final String plate;
    private final Year year;
    private final String make;
    private final String model;
<strong class="bold">    // add getters and setters</strong>
<strong class="bold">    </strong><strong class="bold">// they are removed here for brevity</strong>
}</pre>
			<p>The next step is to create the graph or structure to hold the data and provide it to us. To represent the collection of cars, we’ll create a <strong class="source-inline">Garage</strong> repository where all data manipulation <span class="No-Break">should happen.</span></p>
			<p>You’re free <a id="_idIndexMarker350"/>to manipulate a car’s data or to create any <a id="_idIndexMarker351"/>other new data structure; you code it using pure Java and leave it to Eclipse Store to handle the rest. The only required component we must use is the identification of this <strong class="source-inline">Garage</strong> as a structure. To do so, annotate it with the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Storage</strong></span><span class="No-Break"> annotation.</span></p>
			<p>The <strong class="source-inline">@Storage</strong> annotation indicates the root object of the graph that will be handled by Eclipse Store. In this case, <strong class="source-inline">Garage</strong> is our <span class="No-Break">root object:</span></p>
			<pre class="source-code">
@Storagepublic class Garage {
    private List&lt;Car&gt; cars;
    public Garage() {
        this.cars = new ArrayList&lt;&gt;();
    }
    public void add(Car car) {
        this.cars.add(car);
    }
    public List&lt;Car&gt; getCars() {
        return this.cars.stream()
          .collect(Collectors.toUnmodifiableList());
    }
    public Optional&lt;Car&gt; findByModel(String model) {
        return this.cars.stream().filter(c -&gt;
          c.getModel().equals(model))
                .findFirst();
    }
}</pre>
			<p>This example <a id="_idIndexMarker352"/>covers all the required code and dependencies <a id="_idIndexMarker353"/>for us to be able to use <strong class="source-inline">Garage</strong> to add and find cars by model. And it only uses Java SE, no <span class="No-Break">specific runtime!</span></p>
			<p>Moving forward, we’ll cover the second sample focusing on the service layer, where we’ll implement the validation of the entity’s data before it is moved to storage. This validation is pretty straightforward; we’ll check whether <strong class="source-inline">car</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<p>In order to manipulate the <strong class="source-inline">cars</strong> data, we’ll need an instance of <strong class="source-inline">Garage</strong> in our <strong class="source-inline">CarService</strong>. To use CDI to provide us with an instance of this class, we can use the <strong class="source-inline">@Inject</strong> annotation <span class="No-Break">from CDI.</span></p>
			<p>When executing a <a id="_idIndexMarker354"/>database operation, we would probably <a id="_idIndexMarker355"/>want it to happen in a transaction, right? Yes, in the relational database maybe. Here, we rely on the <strong class="source-inline">@Store</strong> annotation to configure which methods should be allowed to change the data structure. Observe the <strong class="source-inline">public </strong><span class="No-Break"><strong class="source-inline">void add</strong></span><strong class="source-inline">
(Car car)</strong> method as follows and <span class="No-Break">its annotation:</span></p>
			<pre class="source-code">
@ApplicationScopedpublic class CarService {
    @Inject
    private Garage garage;
    @Store
    public void add(Car car) {
        Objects.requireNonNull(car, "car is required");
        this.garage.add(car);
    }
    public List&lt;Car&gt; getCars() {
        return this.garage.getCars();
    }
    public Optional&lt;Car&gt; findByModel(String model) {
        Objects.requireNonNull(model, "model is required");
        return this.garage.findByModel(model);
    }
}</pre>
			<p>Great, we have enough code at this point in order to test it out and have some fun, so let’s execute it! To consume our <strong class="source-inline">CarService</strong> APIs, we’ll need a new class, which we can call <strong class="source-inline">App</strong>, and a <strong class="source-inline">public static void main(final String[] args)</strong> method. In the first couple of lines of the code demonstrated next, notice <span class="No-Break">the following:</span></p>
			<ul>
				<li>The service API that retrieves the list of all the <span class="No-Break">cars, </span><span class="No-Break"><strong class="source-inline">service.getCars()</strong></span></li>
				<li>The search operation invoked by the service <span class="No-Break">API, </span><span class="No-Break"><strong class="source-inline">service.findByModel("Corolla")</strong></span></li>
			</ul>
			<p>When running <a id="_idIndexMarker356"/>the code for the first time, you’ll observe <a id="_idIndexMarker357"/>in the output logs that the retrieved cars list will be empty; however, when you run it twice, you can see <span class="No-Break">the data:</span></p>
			<pre class="source-code">
public static void main(final String[] args) {    try (SeContainer container =
      SeContainerInitializer.newInstance().initialize()) {
        final CarService service =
          container.select(CarService.class).get();
        System.out.println("The current car list: " +
          service.getCars());
        Optional&lt;Car&gt; model =
          service.findByModel("Corolla");
        System.out.println("Entity found: " + model);
        Car dodge = Car.builder()
                .make("Dodge")
                .model("Wagon")
                .year(Year.of(1993))
                .plate("JN8AE2KP7D9956349").build();
        Car ford = Car.builder()
                .make("Ford")
                .model("F250")
                .year(Year.of(2005))
                .plate("WBANE73577B200053").build();
        Car honda = Car.builder()
                .make("Honda")
                .model("S2000")
                .year(Year.of(2005))
                .plate("WBANE73577B200053").build();
        Car toyota = Car.builder()
                .make("Toyota")
                .model("Corolla")
                .year(Year.of(2005))
                .plate("WBANE73577B200053").build();
        service.add(ford);
        service.add(honda);
        service.add(toyota);
        service.add(dodge);
    }
    System.exit(0);
}</pre>
			<p>If you try running this code a couple of times, you may notice that around the third try, it looks like <a id="_idIndexMarker358"/>the items are getting duplicated! This is a <a id="_idIndexMarker359"/>behavior of our <strong class="source-inline">list</strong> object, which can be easily adjusted to solve this behavior. Update the structure to a <strong class="source-inline">Set</strong> instead of <strong class="source-inline">List</strong> and ensure that the <strong class="source-inline">Car</strong> entity has the equals and hashcode <span class="No-Break">implemented adequately.</span></p>
			<p>The application’s <strong class="source-inline">properties</strong> file holds the settings configuration for the <em class="italic">directory</em> and the <em class="italic">number of threads</em> used in the engine. The possibility to externalize this configuration is facilitated by to the integration with <em class="italic">Eclipse MicroProfile Configuration</em> (<a href="https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html">https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html</a>). We saw a similar configuration approach in the previous chapter about JNoSQL, as it relies on the same underlying <span class="No-Break">configuration mechanism:</span></p>
			<pre class="source-code">
one.Eclipse Store.storage.directory=target/dataone.Eclipse Store.channel.count=4</pre>
			<p>Pretty simple, right? Before we move forward, let’s understand the importance of the second setting listed previously, <strong class="source-inline">one.Eclipse Store.channel.count</strong>. This in-memory solution can be fine-tuned in multiple ways, one of them being adjusting the number of channels (threads) that the engine can use to execute I/O operations. This configuration should always be configured with a value equal <span class="No-Break">to 2</span><span class="No-Break"><span class="superscript">n</span></span><span class="No-Break">.</span></p>
			<p>Externalizing the configuration with specification-based approaches facilitates service maintenance. It should require very little effort when changing your application implementation, as you’ll notice in the upcoming section when we create a microservice based on <a id="_idIndexMarker360"/>this sample code. The reason for the simplified <a id="_idIndexMarker361"/>maintenance is that the chosen in-memory database storage, Eclipse Store, uses CDI, which happens to also be the core engine for both MicroProfile and <span class="No-Break">Jakarta EE.</span></p>
			<p>After exploring how to configure and implement a service that relies on in-memory data storage, we will next see how to migrate the code sample as p<a id="_idTextAnchor160"/>art of <span class="No-Break">a microservice.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor161"/>Using in-memory data storage with Jakarta EE and MicroProfile</h1>
			<p>Thanks to <a id="_idIndexMarker362"/>the engines in the MicroProfile <a id="_idIndexMarker363"/>and Jakarta EE specifications, we can <a id="_idIndexMarker364"/>very easily <a id="_idIndexMarker365"/>choose which one best fits the application’s goal. In <a href="B19375_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we discussed both specifications and why they are essential for the <span class="No-Break">Java community:</span></p>
			<ol>
				<li>To get started, you can access the MicroProfile website (<a href="https://start.microprofile.io/">https://start.microprofile.io/</a>) and the starter project. It works just like the Spring initializer, for <span class="No-Break">Spring-based applications.</span></li>
				<li>Once on the page, confirm that MicroProfile version 3.3 is available, and choose one of the options. Make sure to check the <strong class="bold">Config</strong> checkbox in order to save some time and get some auto-generated <span class="No-Break">basic files.</span></li>
				<li>For this example, we’ll use the <span class="No-Break"><strong class="bold">Helidon</strong></span><span class="No-Break"> runtime.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 8.3 – MicroProfile starter website" src="image/Figure_8.03_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – MicroProfile starter website</p>
			<ol>
				<li value="4">Next, all <a id="_idIndexMarker366"/>we must do is add <a id="_idIndexMarker367"/>the Eclipse Store dependency to the <strong class="source-inline">pom.xml</strong> application, as the Eclipse <a id="_idIndexMarker368"/>MicroProfile implementation <a id="_idIndexMarker369"/>already provides both <strong class="bold">config</strong> <span class="No-Break">and CDI:</span><pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;one.microstream&lt;/groupId&gt;    &lt;artifactId&gt;eclipse-store-integrations-cdi&lt;/artifactId&gt;    &lt;version&gt;07.00.00-MS-GA&lt;/version&gt;&lt;/dependency&gt;</pre></li>				<li>Next, use the ancient programmer technique… copy and paste! You can copy the dependency configurations from the previous project into your new <span class="No-Break">MicroProfile-based project.</span></li>
			</ol>
			<p>Now, we need to be able to modify an entity, such as the <strong class="source-inline">Car</strong> entity. As the entity <a id="_idIndexMarker370"/>is immutable, creating <a id="_idIndexMarker371"/>new instances must <a id="_idIndexMarker372"/>be done through <a id="_idIndexMarker373"/>its constructor. The adoption of this good practice is not required by the data storage solution, Eclipse Store, but it is a good approach for using the entities in the <span class="No-Break">REST endpoints.</span></p>
			<p>In the <strong class="source-inline">Car</strong> class, identify and annotate its constructor method with <strong class="source-inline">@JsonCreator</strong> and <strong class="source-inline">@JsonProperty</strong>, which come from the JSON binding specifications (<a href="https://jakarta.ee/specifications/jsonb/2.0/">https://jakarta.ee/specifications/jsonb/2.0/</a>). Notice that these are not annotations required by <span class="No-Break">Eclipse Store.</span></p>
			<ol>
				<li value="6">Change the <strong class="source-inline">Year</strong> type to <strong class="source-inline">Integer</strong>, to avoid creating a custom interface to serialize and <span class="No-Break">deserialize data:</span><pre class="source-code">
public class Car {    private final String plate;    private final Integer year;    private final String make;    private final String model;    @JsonbCreator    public Car(@JsonbProperty("plate") String plate,               @JsonbProperty("year") Integer year,               @JsonbProperty("make") String make,               @JsonbProperty("model") String model) {        this.plate = plate;        this.year = year;        this.make = make;        this.model = model;    }}</pre></li>			</ol>
			<p>We <a id="_idIndexMarker374"/>are building the <strong class="source-inline">Car</strong> entity <a id="_idIndexMarker375"/>as an immutable class; therefore, its fields are final and can be set by <a id="_idIndexMarker376"/>using injections <a id="_idIndexMarker377"/>on the constructor method. To help us achieve this goal, we’ll use a <span class="No-Break">JSONB-compatible implementation.</span></p>
			<ol>
				<li value="7">Add the <strong class="source-inline">@JsonbCreator</strong> annotation, to turn this class into an eligible bean for the API, and so that the <strong class="source-inline">@JsonProperty</strong> annotation can link the respective parameter with the defined <span class="No-Break">JSON property.</span></li>
			</ol>
			<p class="callout-heading"><em class="italic">Note</em></p>
			<p class="callout">We can delete CarBuilder once the creation process is <span class="No-Break">through JSON.</span></p>
			<p>We’ll create a resource where we’ll see the path and URL. We’ll expose all the services we made using the URL, so we’ll have to list the cars by finding a model and inserting <span class="No-Break">a car:</span></p>
			<pre class="source-code">
@ApplicationScoped@Path("garage")
public class GarageResource {
    @Inject
    private CarService service;
    @GET
    public List&lt;Car&gt; getCars() {
        return this.service.getCars();
    }
    @Path("{model}")
    @GET
    public Car findByModel(@PathParam("model") String
      model) {
        return this.service.findByModel(model)
                .orElseThrow(() -&gt; new
                  WebApplicationException(NOT_FOUND));
    }
    @POST
    public Car add(Car car) {
        this.service.add(car);
        return car;
    }
}</pre>
			<p>Our resource class is ready to be used on our microservices. As you can see here, we’re injecting <strong class="source-inline">CarService</strong> and using this integration to connect with this <strong class="source-inline">GarageResource</strong>, which we can explore through <span class="No-Break">HTTP requests.</span></p>
			<p>We have all the code ready; let’s build and execute <span class="No-Break">the application:</span></p>
			<pre class="source-code">
 mvn clean packagejava -jar target/garage.jar</pre>
			<p>When <a id="_idIndexMarker378"/>the service is up, we can explore <a id="_idIndexMarker379"/>it by creating a frontend that <a id="_idIndexMarker380"/>consumes this service or using an HTTP client UI. We’ll run our sample using <strong class="source-inline">curl</strong>. We’ll <a id="_idIndexMarker381"/>make three cars and then return them from <span class="No-Break">the service:</span></p>
			<pre class="source-code">
curl --location --request POST 'http://localhost:8080/garage' \--header 'Content-Type: application/json' \
--data-raw '{"make": "Dodge", "model": "Wagon", "year": 1993, "plate": "JN8AE2KP7D9956349"}'
curl --location --request POST 'http://localhost:8080/garage' \
--header 'Content-Type: application/json' \
--data-raw '{"make": "Ford", "model": "F250", "year": 2005, "plate": "WBANE73577B200053"}'
curl --location --request POST 'http://localhost:8080/garage' \
--header 'Content-Type: application/json' \
--data-raw '{"make": "Honda", "model": "S2000", "year": 2005, "plate": "WBANE73577B200053"}'
curl --location --request POST 'http://localhost:8080/garage' \
--header 'Content-Type: application/json' \
--data-raw '{"make": "Toyota", "model": "Corolla", "year": 2005, "plate": "WBANE73577B200053"}'
curl --location --request GET 'http://localhost:8080/garage/Corolla'
curl --location --request GET 'http://localhost:8080/garage'</pre>
			<p>This <a id="_idIndexMarker382"/>was a sample HTTP request using <a id="_idIndexMarker383"/>the curl program; feel free <a id="_idIndexMarker384"/>to use any HTTP client that you <a id="_idIndexMarker385"/>wish, such <span class="No-Break">as Postman.</span></p>
			<p>We also need to append the Eclipse Store settings in this application. Another point is we updated the <strong class="source-inline">ApplicationPath</strong> annotation to <strong class="source-inline">"/"</strong>. Furthermore, we added the <strong class="source-inline">Garage</strong> resources, but we won’t put the full details here; please, ch<a id="_idTextAnchor162"/>eck out the repository to get all <span class="No-Break">the details.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor163"/>Summary</h1>
			<p>Eclipse Store brings a new persistence perspective; you can increase performance by reducing the mapper process. It impacts not only the application’s response time but also cloud costs since it requires fewer machines, and consequently reduces <span class="No-Break">infrastructure cost.</span></p>
			<p>This chapter looked at Java integration with CDI on Java SE and microservices using MicroProfile. We saw the power of several databases and persistence solutions, but how can we merge them? You’ll find out in the next chapter, about <span class="No-Break">polyglot persistence.</span></p>
		</div>
	

		<div class="Content" id="_idContainer055">
			<h1 id="_idParaDest-99"><a id="_idTextAnchor164"/>Part 3: Architectural Perspective over Persistence</h1>
		</div>
		<div id="_idContainer056">
			<p>In this section of the book, we take an architectural perspective on persistence, exploring various topics related to designing and implementing robust and scalable persistence solutions. This session delves into the architectural considerations and challenges associated with persistence in modern Java solutions, from polyglot persistence to <span class="No-Break">modernization strategies.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19375_09.xhtml#_idTextAnchor165"><em class="italic">Chapter 9</em></a><em class="italic">, Persistence Practices: Exploring Polyglot Persistence</em></li>
				<li><a href="B19375_10.xhtml#_idTextAnchor175"><em class="italic">Chapter 10</em></a><em class="italic">, Architecting Distributed Systems: Challenges and Anti-Patterns</em></li>
				<li><a href="B19375_11.xhtml#_idTextAnchor184"><em class="italic">Chapter 11</em></a><em class="italic">, Modernization Strategies and Data Integration</em></li>
				<li><a href="B19375_12.xhtml#_idTextAnchor195"><em class="italic">Chapter 12</em></a><em class="italic">, Final Considerations on Persistence in Modern Java Solutions</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer057">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer058">
			</div>
		</div>
		<div>
			<div id="_idContainer059">
			</div>
		</div>
	</body></html>