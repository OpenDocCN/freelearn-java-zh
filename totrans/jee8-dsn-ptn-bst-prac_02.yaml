- en: Presentation Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover each topic by explaining the concept and showing
    examples of implementations. After reading this chapter, you will know about these
    concepts and will be able to implement them using Java EE 8\. Here are the topics
    that are covered in upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the presentation tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the intercepting filter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the intercepting filter pattern using Java EE 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the front controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the front controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the application controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the application controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the presentation tier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java EE platform is a distributed multitiered application model that has
    three widely used common tiers. These tiers are the presentation tier (or web
    tier), the business tier, and the integration tier (or EIS tier).
  prefs: []
  type: TYPE_NORMAL
- en: 'The presentation tier, also known as the web tier, contains the components
    that create a web application. This tier has many components that use the HTTP
    protocol, construct views and interfaces for users, and provide a web service.
    These components are called web components. There are two types of presentation
    tier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation-oriented tier**: This type of presentation tier contains the
    components to construct an interactive web page and dynamic content using HTML
    and XHTML. These components are JavaServer Faces technology, Java Servlet technology,
    and JavaServer Page technology, which allow us to construct an interactive web
    page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-oriented tier**: This contains the components to construct an endpoint
    of a web service. These components are JAX-RS and JAX-WS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The presentation-oriented tier is generally used on web applications using
    component-based specifications such as **JavaServer Face**s technology, or web
    applications using action-based Java Servlet technology as well as **JavaServer
    Pages** technology. The server-oriented tier is generally used on web applications
    that create a REST API or web service that is consumed by the client running on
    a mobile platform or browser. In the following diagram, we can see how the presentation
    tier works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeb967fa-baf8-48e7-98f6-19fece1ff59c.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the **Client** sends a **Request** to the
    server; the **Presentation Tier** processes the request and sends it to the **Business
    Tier**; the **Business Tier** then sends a response to the **Presentation Tier** if
    the request is not asynchronous, and finally the **Presentation Tier** processes
    and sends the response to the **Client**.
  prefs: []
  type: TYPE_NORMAL
- en: Because the **Presentation Tier** is responsible for promoting HTTP communications
    and connections with external users, this tier fulfills many interactions and
    communications between web components. Numerous tasks need to be performed for
    this to work well. These tasks include validating the data sent by a client, formatting
    it, sending it to the correct business component or class, and filtering the data
    and requests.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining intercepting filter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a client sends a request to the server, the server sometimes processes
    this request/response to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the browser of the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the duration between the request and response; calculating the response
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a cookie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we don't want to put these tasks within the logic of processing the
    main request. Consequently, creating a pre-process and/or post-process to do these
    tasks is a good method for decoupling the main logic from the complementary logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intercepting filter pattern is the pattern that solves problems when we
    want to insert a logic that is not part of the main logic but we want to keep
    the two logics separated and decoupled. Merging the new logic with the main logic
    is a bad practice because these become coupled. This pattern creates a filter
    to pre-process and post-process the request, permitting the creation of a logic
    block to solve some problems that are not part of the main problem, and thus decoupling
    both pieces of logic. Using this pattern, we can create a pluggable solution without
    modifying the main logic. Take a look at the model of the intercepting filter
    pattern in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a97fc373-2329-4de7-b919-f73cd0e92d23.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have a **Client**, **FilterManager**, **FilterChain**,
    **FilterOne**, **FilterTwo**, **FilterThree**, and **Target**. The client sends
    a request to the server; the FilterManager creates a **FilterChain** with its
    filters ordered and initiates the processing; the **FilterChain** is an ordered
    collection of independent filters; **FilterOne**, **FilterTwo**, and **FilterThree**
    are the filters in the **FilterChain**, which can include N filters; Target is
    the resource that contains the main logic. The order of filter execution is important
    because some filters often need to be executed first. An example of filter priority
    is the task of validating authentication, which generally needs to be executed
    first because some tasks are executed after client authentication only.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the intercepting filter pattern using Java EE 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement this pattern with the best practices of Java EE 8, we will use
    the servlet filter from the Java Servlet specification. With the servlet filter,
    we can create an ordered request interceptor to treat the requests and responses.
    These interceptors are mapped by the URL pattern or servlet name. The servlet
    filter can be configured with XML (on `web.xml`) or annotation. In our case, we
    will imagine that we want to create a log of all the requests that are sent to
    the server. We will also have two filters—one to log the access time and another
    to log the information about the browser that the client is using. To log the
    access time, we will create a filter called `LogAccessFilter`, and to log the
    browser information we will create a filter called `LogBrowserFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing LogAccessFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have the implementation of `LogAccessFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the code, to create one servlet filter, we need to create
    a class that extends `javax.servlet.Filter` and puts the `@WebFilter` annotation with
    `filterName` and `urlPatterns` parameters, which define the filter name and the
    URLs to filter, before the definition of class. The following is a snippet of
    code that demonstrates how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the servlet filter uses the chain of responsibility pattern to walk
    throughout the filters (objects that are servlet filter). The following is a snippet of
    code that uses a chain of responsibility pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line of code, we established the filter name as `LogAccess`
    through the `filterName` parameter. This will filter all requests, because the `urlPatterns` parameter
    has the `"/*"` value. If we filter according to servlet name, we need to use the
    following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doFilter` method is responsible for pre-processing and post-processing
    and establishes when to follow the request to the next filter or servlet (main
    logic). To follow the request to the next filter or servlet, the following code
    needs be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the preceding code is executed, the current filter executes only the next
    line when the other filters and servlets finish their processing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing LogBrowserFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of `LogBrowserFilter` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding filter, we get the client IP and browser information and log
    them. The `LogBrowserFilter` operation is similar to that of `LogAccessFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the order of filter execution, we need to configure the `web.xml`
    and add the filter mapping information. Here, we can see `web.xml` with its configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The configurations defined in `web.xml` override the annotation configurations.
    Thus, if we put the `urlPattern` configuration on `web.xml`, then the configuration
    considered is `web.xml`'s configuration. We don't put the filter mapping information on `web.xml`
    because this is already on the annotation configuration in the code. The `web.xml` configuration
    defines the order—`LogBrowserFilter` will be called first, followed by `LogAccessFilter`,
    and then the main logic (servlet).
  prefs: []
  type: TYPE_NORMAL
- en: Deciding filter mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining the mapping method is crucial to implementing the intercepting filter
    pattern. This is because a bad method for mapping can impact the project directly and
    cause rework. We have two filter mapping types—`UrlPattern` and servlet name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `UrlPatterns` is indicated when we want to filter the HTTP Requests
    to non-specific resources or files, but we also want to filter various unknown resources. Here
    are some examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*.jsp`: This filters all requests to JSP pages. If one JSP page is added to
    the server, then the filter will filter the new JSP page without making any modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/*`: This filters all requests to all resources or files on the server. If
    one resource or file is added to the server, then the filter will filter this
    new resource or file without performing any modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/*`: This filters all requests to all resources or files on the server
    that have a URI beginning with `/user`. If one resource or file that is accessed
    by a URI beginning with `/user` is added on servlet, then the filter will filter
    this new resource or file without performing any modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The servlet name used to map the filter indicates when you want to filter a
    specific servlet, independent of its `urlPattern`. This way of mapping allows
    us to modify one `urlPattern` of the mapped servlet without performing any modifications
    on the filter. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{servlet1}`: This only maps the servlet named as `servlet1`. If the `urlPatterns`
    of `servlet1` are modified, then the filter doesn''t need to be modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{servlet1,servlet2}`: This maps two servlets named `servlet1` and `servlet2`.
    Its behavior is similar to the previous example shown, in which only one servlet
    was mapped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the FrontController pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Java EE world, we commonly work with complex projects that have similar
    functionalities and processes. Sometimes, using various controllers to handle
    a request is a bad practice because it needs to be configured at multiple endpoints and
    incurs a large cost of creation and maintenance. Consequently, creating a central
    point to treat a request is a very good solution, as it creates one point to manage
    all or a group of requests and then sends this request to the correct process.
    We can then treat all points that are common to all functionalities and send the
    request to a process to treat the questions that are not common to all but are
    specific to one functionality. Some configurations, such as session configuration, the
    maximum size limit of a request, cookie, and header, are common to all requests
    and can be configured from a central point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FrontController` pattern is a pattern that creates a central manager to
    treat all requests or a request group of an application and then sends the requests
    to one specific process, which is generally a command. This pattern is rarely
    used on common projects because today we have some ready-made solutions, and implementing
    this pattern is generally unnecessary. This pattern is used by frameworks such
    as JSF, Spring MVC, and struts. The following diagram depicts this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff229c63-0c7a-40f5-93b2-40bd5ed7fa5c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have **FrontController**, **AbstractCommand**,
    **Command1**, and **Command2**. **FrontController** receives all requests, treats some
    common points of the request, and sends this request to the matching command.
    **AbstractCommand** is the `abstract` class of command. **Command1** and **Command2**
    are the subclasses of command, which implement its correspondent logic.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will have two pages—a homepage and a login page. If the user
    is logged in at the moment that a request is sent, then the application will launch
    the login page, and then the homepage.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FrontController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have an implementation of `MyAppController`, which is a `FrontController`
    to treat all the requests of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we implement this pattern, it is very important to pay attention to the
    use of attributes on servlets, because all the class attributes on a servlet are
    shared with all threads or all requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'All `GET` requests or `POST` requests are sent to the `processRequest` method,
    which implements the logic to send the request to the respective command and executes
    the respective logic. After the correct command is set, the respective command
    is executed and the page is dispatched. Here, we have the line that executes the
    command and dispatches the request to the correct page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Dispatching the request to the corresponding page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have `AbstractCommand`, which is an `abstract` class with one `execute` method.
    This is the `abstract` command, and the `execute` method is implemented on the
    subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the `LoginCommand` subclass, which is the implementation of `AbstractCommand`.
    The `execute()` method returns the path to the login page (`/login.jsp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The application controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some web applications have a complex logic for defining the correct view, content,
    or action to invoke. The MVC controller can be used to make this decision and
    get the correct view, content, or action. However, sometimes the logic to define
    a decision is very hard, and using the MVC controller to do this can cause duplication
    of a lot of code. To solve this, we need to centralize the logic at one point
    to permit an easy maintenance and a central logic point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application controller pattern is the pattern that permits the centralization
    of all view logic and promotes a unique process to define the flow of pages. This
    pattern is used together with `FrontController`, discussed earlier, and is an
    intermediary between `FrontController` and `Command`. Using this pattern, we will
    promote the decoupling between view treatment and request treatment. The following
    diagram represents this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/639d81e1-6970-4ef2-878b-3f7ce96a3c2d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see the **ApplicationController** between **FrontController**
    and **AbstractController**. When the client sends a request, the **FrontController**
    receives this and treats points about the request. The **FrontController** then
    sends this request to **ApplicationController**, which treats points about the
    view and flow and defines the correct **Command** to execute.
  prefs: []
  type: TYPE_NORMAL
- en: In our example scenario, we want to create one point to download a file on our
    server, and this point can only be accessed by a logged-in user. As well as this,
    we will only accept PDF downloads and JPG files. In this example, we will create
    one class called `DownloadFrontController` to receive the request. We will also
    create a class called `DownloadApplicationController` to process the logic of
    view and content choice. `AbstractCommand` is the `abstract` class for commands.
    In addition to this, we will create `PdfCommand`, which is an implementation of
    `AbstractCommand` that processes the logic to download one PDF file. Finally,
    we will create `JpgCommand`, which is an implementation of `AbstractCommand` that
    processes the logic to download one JPG file.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DownloadFrontController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have the implementation of `DownloadFrontController`, which is a Servlet
    used to download files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding block of code, we have the `DownloadFrontController` class with
    the logic to process a request. This class is a servlet that responds to all requests
    sent to `/download/*` using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All `GET` requests or `POST` requests are sent to the `processRequest` method,
    inside which we have the code to send the request to `DownloadApplicationController`.
    The following line of code does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Implementing DownloadApplicationController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have the implementation of `DownloadApplicationController`, which
    is responsible for deciding the correct command to send the request. The process
    for deciding the correct command can be carried out in several ways, with reflections
    and annotations, using switch cases and maps, among others. In our example, we
    use a map to help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A new instance of the command is then created using the `newInstance()` method :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The command is then executed, passing `request` and `response` as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implementing commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have the `abstract` class `AbstractCommand`, which includes the abstract `execute` method.
    All implementations of this command extend `AbstractCommand`, which is an `abstract`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following block of code, we have the `PdfCommand` class. This is a subclass
    of `AbstractCommand` that implements the logic to download a PDF file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have the `execute()` method, which processes
    the logic to download a PDF file. At this point, all the processes and main validations of
    requests were executed, and the `execute()` method needs only to execute the download
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the `JpgCommand` class, which is a subclass of `AbstractCommand`
    that implements the logic to download a JPG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have the `execute()` method, which processes
    the logic to download a JPG file. At this point, all request and main validation processes have
    already been done.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the application controller and front controller patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application controller and front controller patterns are quite similar and
    can create confusion for some users. The problem that the application controller
    pattern and front controller patterns solve are similar because both are used
    to centralize the logic at one point. As well as that, both work together using
    the design pattern command.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the application controller and the front controller is
    that the application controller works to solve the complexity of view and flow
    page logic, and the front controller works to solve the complexity of the requests
    and the configurations of them. When the view and flow logic is simple, all logic
    is sometimes inserted into the front controller, and the application controller
    is not then used. However, when the logic within the view and flow page is complex,
    it is recommended to use the application controller in order to decouple the view
    and flow logic and organize the code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the presentation tier and looked at the intercepting
    filter pattern, front controller patterns, and application controller pattern
    as well as how to implement them. In the real world, we rarely need to implement
    these patterns because some frameworks, APIs, and specifications already implement
    them for us. However, it is very important to know about these patterns in order
    to improve our understanding of the frameworks, APIs, and specifications that
    implement them. As well as this, we sometimes need to implement some components
    outside of the framework. Consequently, it is a good idea to use this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will address the business tier and its patterns. Here, we will
    cover the patterns that act on the business tier. Knowing about these patterns will
    complement our knowledge of the concepts and implementations of enterprise patterns
    as well as how these patterns promote the use of good tools to solve common problems
    in a business environment.
  prefs: []
  type: TYPE_NORMAL
