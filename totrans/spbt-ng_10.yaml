- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Our Angular Project and Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the concepts of **JUnit**, which
    is a testing framework that offers features such as fixtures, test suites, and
    classes to test the methods in our application. You also learned the application
    of **AssertJ** with JUnit, which gives a more flexible way of asserting objects
    in our unit tests, and lastly, you also understood the importance of Mockito,
    which provides us with the ability to mock objects and services, omitting the
    use of the database in unit tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start building our frontend application using Angular;
    we will be tackling the main fundamentals of Angular, such as components, modules,
    directives, and routes. We will also point out some of the best practices for
    organizing our Angular project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Organizing features and modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Angular material
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The link to the finished version of this chapter is here: [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Organizing features and modules
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be discussing how we can organize and structure our
    Angular project to make it optimized and maintainable. Since Angular is considered
    a **Model View Whatever** (**MVW**) framework, Angular developers have the freedom
    to implement their choice of pattern in developing the project. This could be
    confusing, as you will experience different structures and standards switching
    from one project to another. To solve this dilemma, we will present a commonly
    used structure in the industry or some kind of baseline structure that you will
    typically find in Angular projects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: However, before we proceed to our main topic, let us first discuss how to create
    our Angular project and what the basic concepts that we need to know before coding
    Angular are. You can skip this part if you are already knowledgeable about Angular
    and proceed to the *Organizing the folder* *structure* section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Generating an Angular project
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create or set up the dependencies of our Angular project using a tool
    known as the **Angular CLI**. We can scaffold the project by using a single command
    responsible for downloading the dependencies and generating the required files
    for our Angular project to run. The **Angular CLI** is a handy tool in that it
    also provides several commands that will help us generate boilerplate codes in
    Angular.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: To install the Angular CLI, we should make sure that we have Node.js installed
    on our machine, and we will execute the `npm install -g @angular/cli` command.
    After executing the command, we can verify whether our Angular CLI has been successfully
    installed – we will have a new global `ng` command that we can use to check the
    version of the installed CLI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the version, we will execute the `ng --version` command, and we will
    get the following output:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Installed version of the Angular CLI](img/B18159_10_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Installed version of the Angular CLI
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, we can see that the version of the Angular CLI and
    Node.js installed on your machine is displayed after executing the `ng -- version`
    command. Currently, we have Angular CLI Version 13 installed, which means that
    once we scaffold an Angular project, it will be on **Version 13**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully installing the Angular CLI, we can now execute several commands
    for our project. Here are some of the commands that we can use in the Angular
    CLI:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`ng new <project name> [options]`: Creates or scaffolds a new Angular project'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng serve <project> [options]`: Builds and serves your Angular application'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng generate <schematic> [options]`: Generates and modifies files with a specific
    schematic'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some schematics we can generate are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Component
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directive
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guard
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng build<project> [options]`: Compiles the Angular application into an output
    directory named `dist`, which will be used for production'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng test <project> [options]`: Runs the unit test in the Angular project'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the most commonly used commands of the Angular CLI. For
    the complete commands, you can visit the documentation for Angular at https://angular.io/cli.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We know the commands we can use in the Angular CLI. Now, let’s generate our
    Angular project by executing the `ng new superheroes` command on our desired path.
    This will ask several questions, such as “*would you like to add Angular routing?*”
    and “*which stylesheet format would you like to use?*” We can select *Yes* and
    **Syntactically Awesome Style Sheet** (**SASS**) for these questions, as we need
    routes and SASS to build our application later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: After this step, this will now scaffold a new Angular project named superheroes
    and will be responsible for configuring the web pack, creating the required settings,
    and downloading the project’s dependencies. After the scaffold is accomplished,
    open the superheroes project in Visual Studio Code or any IDE you prefer. We will
    see that the Angular application is configured and ready to run on our local server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Folder structure and dependencies installed after scaffolding](img/B18159_10_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Folder structure and dependencies installed after scaffolding
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our project, we can open the VS Code terminal with the *Ctrl* + *`*
    shortcut and execute the `ng serve` command. We can also use the defined scripts
    in our `package.json` file. In this case, we can perform `npm run start` to run
    our application. We will see in the terminal whether Angular is running successfully
    on our local server in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Folder structure and dependencies installed after scaffolding](img/B18159_10_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Folder structure and dependencies installed after scaffolding
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully running our Angular application, we can now open the app
    using the default URL (`http://localhost:4200`) in our browser, and we will see
    the default page of our Angular project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Angular default page](img/B18159_10_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Angular default page
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully configured and started our Angular application locally.
    Now, let’s discuss the concepts we will use to build our application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Angular features
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular framework is a component-based framework that allows us to develop
    reusable components to promote the reusability and maintainability of code. It
    offers many features that will make our frontend development more powerful. In
    this section, we will discuss the basic features and fundamentals of Angular that
    serve as its building blocks; take note that we will not discuss all of the features
    here, as we will focus more on the organization of the project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the features, you can visit the official documentation
    for Angular: https://angular.io/start.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Components
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@Component` decorator, which assigns several types of metadata that describe
    the component’s HTML, CSS, and selector.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the commands to generate a component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is a code example for a component:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Components have a feature called **data binding**, which allows us to pass
    data into the view. Data binding can be used to display values to the user, respond
    to user events, and modify the styles. Angular binding is classified into two
    groups:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: One-way binding
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-way binding
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-way binding
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As can be inferred from the name, data only flows in one direction here. It
    can be from a component to the view or vice versa.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to achieve one-way binding in Angular, and the two most
    common ways are using interpolation and property binding.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`{{}}` (double curly braces) for expressions inside HTML code.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we have used interpolation to display the value of
    the `title` variable in the view. Using interpolation, we can also use operators
    in the template expression.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Property binding
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`class`, `href`, `disabled`, and `src`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example code on how to use property binding:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we have bound the `isDisabled` variable to the disabled
    property of the button. The button will be disabled, as we have set the value
    of the `isDisabled` to `true`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Two-way binding** is a two-way data flow. Any changes applied to the model
    will be reflected in the view simultaneously and any modifications involved in
    the view are updated in the component. Two-way data binding helps handle forms,
    as we want our model to be updated once the values of the form are also updated
    and vice versa.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: To achieve two-way binding, the `ngModel` directive is used.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: ngModel
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ngModel` is a directive used to achieve two-way binding in Angular. This is
    under the Forms module in `@angular/forms`. `ngModel`, once it is bound to an
    input field or other form element, gives that element a property binding and an
    event binding. Let’s have a look at the following example code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel` 是一个在 Angular 中用于实现双向绑定的指令。这位于 `@angular/forms` 下的表单模块中。一旦 `ngModel`
    绑定到输入字段或其他表单元素，它就会给该元素添加属性绑定和事件绑定。让我们看看下面的示例代码：'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example code, we have bound the model value to an input element
    using the `ngModel` directive. This syntax is also known as the *banana in a box*,
    which encloses `ngModel` with a square bracket and parenthesis. The directive
    will bind the model’s value with the input field using property binding and listen
    to the input value changes by utilizing `ngModelChange`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们使用 `ngModel` 指令将模型值绑定到一个输入元素上。这种语法也被称为 *盒子里的香蕉*，它用方括号和圆括号包围 `ngModel`。该指令将通过属性绑定将模型值与输入字段绑定，并通过利用
    `ngModelChange` 来监听输入值的变化。
- en: Directives
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令
- en: '**Directives** are an Angular feature that helps us manipulate the **Document
    Object Model** (**DOM**). We can modify a DOM element’s layout, behavior, and
    view. Directives are classified into three parts: **components** are one of the
    classifications, and the other two are **attribute** and **structural** directives.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令**是 Angular 的一个功能，帮助我们操作 **文档对象模型**（**DOM**）。我们可以修改 DOM 元素的布局、行为和视图。指令分为三个部分：**组件**是其中一种分类，其他两种是**属性**和**结构**指令。'
- en: Structural directives
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结构指令
- en: '**Structural directives** are directives that can modify the layout of the
    DOM by adding, updating, or removing elements, listed below are some of the structural
    directives in Angular:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构指令**是可以通过添加、更新或删除元素来修改 DOM 布局的指令，以下是一些 Angular 中的结构指令：'
- en: '`*ngIf`: A directive that is used to add or remove elements in the DOM based
    on a condition:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngIf`：一个用于根据条件在 DOM 中添加或删除元素的指令：'
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`*ngFor`: A directive that is used to repeat HTML elements from the items iterated
    in a specific list:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngFor`：一个用于从特定列表中迭代的项重复 HTML 元素的指令：'
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`*ngSwitch`: A directive that allows us to add or remove HTML elements using
    a switch case mechanism. The HTML elements will be displayed if the provided expression
    is matched:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngSwitch`：一个允许我们使用开关机制添加或删除 HTML 元素的指令。如果提供的表达式匹配，则将显示 HTML 元素：'
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Attribute directives
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性指令
- en: '**Attribute directives** are directives used for changing or modifying the
    appearance or behavior of the element. Compared to structural directives, attribute
    directives cannot add or remove elements in the DOM.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性指令**是用于更改或修改元素外观或行为的指令。与结构指令相比，属性指令不能在 DOM 中添加或删除元素。'
- en: 'Listed here are some of the attribute directives in Angular:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了一些 Angular 中的属性指令：
- en: '**ngClass**: A directive used to add CSS classes to or remove them from an
    HTML element; this allows us to change the appearance of elements dynamically:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngClass**：一个用于向 HTML 元素添加 CSS 类或从其中删除它们的指令；这允许我们动态地更改元素的外观：'
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**ngStyle**: A directive that allows us to change the styles of HTML elements:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngStyle**：一个允许我们更改 HTML 元素样式的指令：'
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Modules
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: '**Modules** are one of the essential features of the Angular framework. As
    our application gets more complex, it will consist of large blocks of components,
    directives, and services. This will affect the maintainability of the application’s
    code base. The Angular framework provides a way of organizing and grouping blocks,
    known as modules.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**是 Angular 框架的一个基本特性。随着我们的应用程序变得更加复杂，它将包含大量的组件、指令和服务。这将影响应用程序代码库的可维护性。Angular
    框架提供了一种组织和分组块的方法，称为模块。'
- en: Modules in the Angular framework help us develop our application promoting the
    separation of concerns. They allow us to classify and organize blocks based on
    their functionality. Angular is also built using modules; the `@angular/core`
    framework is the primary Angular module, which provides Angular’s core functionalities
    and services.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架中的模块帮助我们开发应用程序，促进关注点的分离。它们允许我们根据其功能对块进行分类和组织。Angular 也是使用模块构建的；`@angular/core`
    框架是主要的 Angular 模块，它提供了 Angular 的核心功能和服务的实现。
- en: Creating a module
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个模块
- en: We will use the `@NgModule` decorator to create a module. It consists of several
    types of metadata that allow us to define the component, services, pipes, and
    other modules included in the created module.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code shows the properties available for a module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s now discuss the functionality of each property:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarations**: This is where we place the components, directives, and pipes
    of our applications. Remember that components, directives, and pipes must be declared
    in only one module.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providers**: This is where we place services to allow them to be available
    for dependency injection.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Imports**: This is where we place one or more other modules in our application.
    Once we import a specific module, all components, pipes, and directives in the
    imported module can be used.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exports**: This is where we place the components, directives, and pipes to
    be available to other modules once imported.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppModule`), as the root module’s responsibility is to load the first view
    as our application starts.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entry components**: This is where we place components that should be dynamically
    loaded in our application.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how `NgModule` works in an Angular application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Diagram for the flow of an Angular module](img/B18159_10_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Diagram for the flow of an Angular module
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Services and dependency injection
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Services** are also one of the valuable features of Angular. It is code that
    can be reused in different components of your application.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary responsibility of services is the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Reusing logic on different components
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing API communication and data access
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promoting single responsibility, as it separates the independent features of
    components
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a service in the application, we will create a class and annotate
    it with the `@Injectable` decorator. To register the service at the root level
    of your application, we will add the following to our `@``Injectable` decorator:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we have set the value of the `providedIn` metadata in the root, this will
    create a single, shared instance of the service throughout the application. On
    the other hand, if we want to provide the service in a specific module, we will
    place the service in the provider metadata of `@NgModule`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have discussed some of the essential features of Angular, we will
    focus on how to structure your Angular application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Angular folder structure
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular framework is considered an MVW framework, which means that there
    are many possible ways of structuring our application. In this case, we would
    discuss one of the best practices or most commonly used structures that can help
    your Angular application be scalable and maintainable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In the previous part, we learned that Angular blocks could be grouped and organized
    into modules; modules are a good starting point for structuring our Angular application.
    The first step we can implement is to group and classify modules based on their
    functionality. Listed here is the classification of our modules.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Root module
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AppModule` and is found under the `src/app` folder.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Feature module
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **feature** module is where we place modules that apply a specific feature
    of our application. This means that most of what our code uses is inside this
    module. We will create the components, pipes, and directives under the module
    where they should be included and we can also separate components by placing the
    components that have a route in a page folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at an example folder structure of a feature module called
    `AntiHeroModule`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the folder structure here, we have divided our anti-hero module into several
    parts. The first folder is the `components` folder, which contains all of the
    components shared throughout this module. These can also be called **dumb** components,
    which we will discuss in the next section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The next two are the `directives` and `pipes` folders, which contain the directives
    and pipes used in `AntiHeroModule`. Lastly, the `pages` folder includes the components
    in `AntiHeroModule` that have a direct route. These can also be called `index.ts`
    file, known as a barrel file, which will provide a centralized place for exporting
    components, directives, and pipes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Shared module
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **shared** module is a module that is used and shared throughout the application;
    this is composed of the components, pipes, and directives that we are required
    to use in different parts of the application. Remember that a shared module should
    not have a dependency on other modules in the application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Shared modules are created under the `src/app/shared` folder.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the example folder structure of a shared module in our
    application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding folder structure, we can see that we have created two components
    named `footer` and `navbar`; these are some of the most commonly shared components
    in applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Core module
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **core** module is a module for services shared throughout the applications.
    These are singleton services, having only one instance in the application. The
    services that are included in the core module are usually authentication services.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Since it should only have one instance, the core module must only be imported
    into the application’s root module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the following code to our core module to prevent it from being imported
    into other modules:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code example, we have added a `CoreModule` parameter to our
    constructor with `@Optional` and `@SkipSelf` decorators – this will throw an error
    if the core returns a value indicating that `CoreModule` has already been imported
    into the root module.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now proceed to learn how to implement the structure on an Angular application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the structure
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have learned the different module categories for our Angular application,
    let’s apply the folder structure to our superheroes project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Our goal here is to create a frontend application with a simple **Create, Read,
    Update, and Delete** (**CRUD**) functionality for heroes and anti-heroes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create the shared features and the `core` folder under the `app`
    directory, and after completing the three main categories, we will make the blocks
    needed for each module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Blocks under the features module
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to create the blocks under our features module; the first thing we need
    to scaffold is `AntiHeroModule`. Execute the `ng g m anti-hero` command to generate
    the module under the `src/app` folder.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, under the anti-hero folder, we will create the following folders:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '`components`: This will contain components that will be shared in this module.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipes`: This will contain all the pipes used by the anti-hero module.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directives`: This will contain all the directives that the anti-hero module
    will use.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pages`: This will contain components that have a direct route.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating the folders, we will now make the page components for our anti-hero
    module. We will add two pages where the first one will be the page for displaying
    the list of anti-heroes and the second one will be a form that allows us to view,
    create, or modify the selected hero in the list. We can execute the `ng g c anti-hero/pages/pages/form`
    and `ng g c anti-hero/pages/list` commands to make the two pages. This will create
    two new components, `form` and `list`, under the `pages` folder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully creating the page components, we will also add a routing
    module for our anti-hero module. We will execute the `ng g m anti-hero/anti-hero-routing
    --flat` command and we will place the following code in our routing module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example code, we have defined routes for our `form` and `list`
    pages. This means that the page components will have direct routes in our application,
    and we have also defined `ListComponent` as the base route for this module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: After successfully creating the page components and defining routes, we want
    our root module (`AppModule`) to have a route for `AntiHeroModule`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, we will place the following code in `app-routing.module.ts`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example code, we have used lazy loading to create a route for
    `AntiHeroModule`. Once we visit the `{baseUrl}/anti-heroes` URL, this will load
    `AntiHeroModule` and redirect to the base route, which is `ListComponent`. We
    have also used `RouterModule.forRoot()` to import the routes, as this is the root
    module.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully defining the routes for our `AppModule`, we can now see
    the current structure of our application:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Folder structure after creating the anti-hero feature](img/B18159_10_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Folder structure after creating the anti-hero feature
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed our feature module in Angular, we have only the `pages`
    folder. We will add other blocks such as the components and directives later as
    we develop the application. The next step is to make the shared module.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Blocks under the shared module
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, our next goal is to create the blocks under the shared module. We defined
    the shared module as components, directives, and pipes that are shared throughout
    the application and must not have a dependency on other modules. To create our
    shared module, we will execute the `ng g m shared` command. This will create a
    new shared folder and a module file inside the new shared folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Now after completing the shared module, we can generate the blocks that will
    be categorized in this module. In our application, we can include `navbar` and
    `footer` as shared components, as they will be used in every part of our application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We will execute the `ng g c shared/layout/navbar` and `ng g c shared/layout/footer`
    commands to scaffold `navbar` and `footer`. We can see that `FooterComponent`
    and `NavbarComponent` are automatically added to the `shared.module.ts` file as
    Angular detects the module closest to the components:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Remember to add the `navbar` and `footer` components in the `exports` metadata
    of `NgModule` and we will import the shared module in different modules:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can also add shared directives and pipes under the shared folder by executing
    the `ng g c shared/directive/directive-name` and `ng g c shared/pipes/pipe-name`
    commands depending on the needs of our application. After successfully creating
    the blocks, we will have the following folder structure:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Folder structure after creating the shared module](img/B18159_10_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Folder structure after creating the shared module
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We must also remember that a shared module does not need a routing module since
    it does not have components that require routes in our application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Blocks under the core module
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last module that we need to create is the core module. Core modules are
    services that we share throughout the application and they have only one instance.
    One service that always goes into the core module is the authentication service.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To create our shared module, we will execute the `ng g m core;` command after
    completing the core module. We will scaffold the authenticate service by running
    the `ng g s` `core/services/authenticate` command.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully creating the authenticate service, we will provide it under
    the `core.module.ts` file to include the service in the module. We can also add
    shared models under the core module by adding a `models` folder depending on the
    need of our application. Now, we have the following folder structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Folder structure after creating the shared module](img/B18159_10_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Folder structure after creating the shared module
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We will make the contents of the authenticate service as we go through the development
    of the application but now that we have created the base structure of our Angular
    application, we will use this structure to build other parts of the project. Now,
    we will discuss how we can structure our components in Angular.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Structuring components
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already structured our Angular application by categorizing our modules
    based on their use and functionality, which will benefit code reusability and
    maintainability. However, there is still the possibility that a large number of
    components could be created under a specific module, which would further improve
    the maintainability of an application. In this section, we will discuss another
    strategy for building your Angular architecture at the component level.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Smart and dumb or presentation components
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common and recommended **component-level architecture** for building
    Angular applications is the smart and dumb component architecture. In the previous
    section, we split the modules into different categories based on how we were using
    them in the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: This architecture also offers the same concept. We will divide the components
    into two different types – namely, **smart components** and **dumb** or **presentation
    components**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the characteristics of each component type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Smart components
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Smart components** are also known as application-level components or container
    components. The primary responsibility of these components is to communicate with
    services and consume data from a request. Since they are smart, they contain all
    the dependencies and subscriptions required to get the data for the application.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart components can be considered page components that have direct routes
    in our application and they are the parent components holding the dumb components.
    Let’s have a look at the following example code for creating smart components:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example code, we have created a component named `HomeComponent`
    that will display a list of users in the table. We have also injected `UserService`
    to get the users from an HTTP request. We know that this component will successfully
    display the users, but we can see that our template is extensive and might get
    too complicated as we add more features to this component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'What we would want to do is omit elements that are only for presentation purposes.
    In this scenario, we would like to remove the table in our `HomeComponent`, and
    we would have the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding refactored code, we have removed the table displaying the list
    of users. We only want smart components to handle dependency injections, subscriptions,
    and actions. We have now successfully created our smart components and the next
    step is to make the presentation components.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Dumb or presentation components
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dumb components**, also known as presentation components, are responsible
    for displaying data in the application. They should not have dependencies and
    subscriptions, as their only purpose is to present the data in the view.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the table we omitted a while ago as a dumb component:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example code, we have created a separate component for the
    table that displays the list of users. Since dumb components have no dependencies
    injected, the component will need to receive the data from the smart components.
    To achieve this, we have added an `@Input` binding property to accept the list
    of users from `HomeComponent`; on the other hand, we have also added an `@Output`
    binding property to bubble actions to the parent or smart component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Remember that dumb components must not have any logic or actions; in this case,
    we will pass the event in the parent component with the use of `EventEmitter`
    and the parent component will be responsible for the steps needed to be accomplished.
    In the example code, once a row is clicked, we are passing the user to the `userEmitter`
    that `HomeComponent` will retrieve.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully creating `UserListComponent`, we can now use this in our
    `HomeComponent`, and we will have the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example code, we can see that we have used `UsersListComponent`
    as a child component of `HomeComponent`. It accepts the list of the users retrieved
    by `HomeComponent` and emits an event once a specific row is clicked. With that,
    we have now finished discussing the concepts of smart and dumb components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply the architecture to our application now.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Implementing smart and dumb components in the project
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now implement the smart and dumb component architecture in our Angular
    project. We will create our components under `AntiHeroModule`. We have already
    made our `form` and `list` components in the `pages` folder.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We will always place our smart components in the `pages` folder, as these will
    be our container components throughout the application. The next step is to create
    our dumb components. We will create two dumb components, namely the `anti-hero-form`
    and `anti-hero-list` components. To make the components, execute the `ng g c anti-hero/components/anti-hero-form
    anti-hero/components anti-hero-list` command. After successfully generating the
    two dumb components, let’s place the following code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'For `AntiHeroListComponent`, we will place the following code into the `anti-hero-list.component.html`
    file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding HTML code, we have created a table where the headers and the
    items are bound to the `antiHeroes` variable. We have also bound the headers and
    the key values of the anti-hero to display the values dynamically.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the properties for receiving and emitting data into our `AntiHeroList`
    component:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: anti-hero-list.component.ts
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, in the `TypeScript` file of the anti-hero component, we have defined three
    properties that we need for the dumb component to accept data from and emit events
    to the smart component.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The first property is the `headers` property, which has the `@Input` annotation.
    This will get an array of the `{headerName: string, fieldName: keyof AntiHero}`
    type, which will be iterated to display the column headers and display the values
    of each field of an anti-hero item. The second property is `antiHeroes`, which
    also has an `@Input` annotation. This will accept the list of anti-heroes to be
    displayed in each row, and lastly, the `antiHero` property, which is annotated
    with `@Output`. This emits the selected anti-hero to the parent component once
    a user clicks a single row.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We have also added an interface named `AntiHero` in `anti-hero/models/anti-hero.interface.ts`
    that will be used to cast object types.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have the following code for `interface`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code example, we have created an `AntiHero` interface that
    will be used as the blueprint of our object. The properties of the anti-hero object
    are the same as the properties we defined in our Spring application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: After creating the interface for our object, we will now declare and import
    our components and modules into `AntiHeroModule`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: anti-hero.module.ts
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In our `anti-hero.module.ts` file, we want to make sure that our smart components
    and dumb components are declared; otherwise, we will have errors at compilation.
    We also want to check whether our `AntiHeroRoutingModule` is imported for use
    of the routes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add additional styling to improve the user interface of our application.
    Let’s have a look at the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: anti-hero-list.component.scss
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have also added a simple CSS code to style our table in the component. Now,
    we have successfully created our `AntiHeroListComponent`. The next step is to
    use this presentation component on the `ListComponent` page. Let’s have a look
    at the following code example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `TypeScript` file of `ListComponent`, we have created the definition
    of the headers and an example list of `antiHeroes` for the anti-hero list to display.
    This will only be temporary, as we just want to test whether our presentation
    component displays the list of anti-heroes successfully. We have also created
    the `selectAntiHero()` function for future implementation once a specific anti-hero
    is selected.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now define the input and output properties for `AntiHeroList`. Let’s
    have a look at the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: list.component.html
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, in the HTML file of `ListComponent`, we have bound `headers` and `antiHeroes`
    to the properties of `app-anti-hero-list`. We have also used the `selectAntiHero()`
    function to catch the event once `antiHero` has emitted an action.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully implementing our presentation component, we can run the
    application and open the application in the browser. We should see the following
    results:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – AntiHeroList presentation component](img/B18159_10_09.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – AntiHeroList presentation component
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the results that our presentation component has successfully displayed
    the data coming from the parent component. For the form component, we will implement
    its functionalities in the next chapter, as creating forms will be another different
    topic.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have learned about the concepts, structure, and implementation of smart
    and dumb components. In the next section, we will now use a UI framework that
    will help us improve the interface of our Angular application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Adding Angular Material
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already organized our Angular application using the **core**, **feature**,
    and **shared** architecture at the module level and the smart and dumb architecture
    at the component level. Now, we are ready to customize and improve the look and
    UI by styling our components. We all know that writing CSS code from scratch and
    developing a base style is another challenge for us developers. It creates additional
    effort for us beyond just worrying about the logical side of the code. This is
    where Angular Material saves the day!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular Material** is a library created by Google that provides a wide range
    of UI components for use in Angular applications, such as tables, cards, inputs,
    and date pickers. This means that we don’t have to style components from scratch,
    as a list of components from the material library is ready to use.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Angular Material has a wide range of growing components under the hood. It provides
    modules containing the components that can be used in Angular applications which
    can be imported into a specific application module; components are reusable and
    easy to customize in terms of their look and feel, as they have built-in properties
    that we can use.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Let’s configure Angular Material in our Angular project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Angular Material
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular Material is easy to configure in Angular projects, as it provides a
    schematic to install all the dependencies of Angular Material in just one command.
    To install Angular Material, we will execute the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After executing the command, it will ask some questions before installing the
    resources:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**Choose a prebuilt theme name or “custom” for a custom theme**: Angular Material
    provides prebuilt themes or you can configure your custom theme.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set up global Angular Material typography styles**: Choosing **yes** will
    apply the global typography of Angular Material.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BrowserAnimationsModule` in our root module. This is important when we want
    to use animations from Angular Material.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing all the questions, it will now install Angular Material. This
    will execute the following actions for our project:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to `package.json` `(@angular/material` and `@angular/cdk`).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adding the `Roboto` font to the `index.html` file:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Adding the Material Design icon font to the `index.html` file:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Adding the following CSS styles:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting `height` to `100%` for `html` and `body`
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `Roboto` as the default font
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Removing margins from the body:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After successfully installing Angular Material in our application, we are now
    ready to use the components in our application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Angular Material
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now implement Angular Material components in our Angular project. As
    we mentioned a while ago, Angular Material offers a wide range of components that
    we can use for building our application. In this example project, we will only
    define the components that we will use in our application. Let’s list the components
    that we will implement.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Button component
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The native `<button>` or `<a>` elements that are enhanced with Material Design
    styling.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the button component using the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s an example of the button component:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code example for the **Material** button, we can see that
    we are using built-in directives from Material Design to change the style and
    look of the button. The example code will have the following output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Example output for the Material button](img/B18159_10_10.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Example output for the Material button
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Icon component
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component allows us to add vector-based icons to the application and supports
    both icon fonts and SVG icons.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the icon component using the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here’s an example of the icon component:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code example, we can create icons by using the `mat-icon`
    component. This has several input properties such as color that allow us to customize
    the color of the icon. The example code will have the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Example output for the Material icon](img/B18159_10_11.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Example output for the Material icon
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Table component
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component allows us to add a data table with Material Design styling. The
    Material table is based on the foundation of the **CDK data table**. For more
    information on how to implement a CDK data table, see the documentation at https://material.angular.io/cdk/table/overview.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the table component using the following code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here’s an example of the table component:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the preceding example, we can see the table uses several properties. The
    first property is the `dataSource` property, which will be the one accepting the
    list of data to be displayed. The next property is `matColumnDef`, which defines
    the field name of each column that should be included in the `columns` variable
    that is bound to the `matHeaderRowDef` property. Lastly, the `matHeaderCellDef`
    and `mattCelDef` properties display the actual column name and the associated
    values, as shown in the following screenshot:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Example output for the Material table](img/B18159_10_12.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Example output for the Material table
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar component
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component allows us to add a toolbar with Material Design styling. This
    is commonly used as a container for headers, titles, and navigation buttons.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the toolbar component using the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here’s an example of the toolbar component:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code example, we have created a toolbar element using the
    `mat-toolbar` component. The `mat-toolbar` component uses content projection that
    allows us to customize its contents. The example code will have the following
    output:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Example output for the Material toolbar](img/B18159_10_13.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Example output for the Material toolbar
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Form field component
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This component allows us to wrap Material components to apply text field styles
    such as underlining, hint messages, and floating labels. The following components
    can be used inside `<mat-form-field>`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '`input matNativeControl>` and `<textarea matNativeControl>`: Can be used by
    adding `import {MatInputModule}` `from ''@angular/material/input'';`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mat-select>`: Can be used by adding `import {MatSelectModule} from ''@``angular/material/select'';`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mat-chip-list>`: Can be used by adding `import {MatChipsModule} from ''@``angular/material/chips'';`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of the form field component:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding code example, we have created a toolbar element using the
    `mat-form-field` component. The `mat-form-field` component should have the `mat-label`
    component and an input element with the `matInput` directive as its contents.
    The example code will have the following output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Example output for the Material form field](img/B18159_10_14.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Example output for the Material form field
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the list of components from Angular Material, see the
    documentation at https://material.angular.io/components.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have listed the Material components we will use in our application,
    let’s apply Material Design to our components.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step we need to do is to create our Material module. The Material
    modules will be included in the shared module so that we can use Material design
    components throughout the application. To generate our Material module in our
    Angular application, we will execute the following command: `ng g m material`.
    After successfully generating the Material module, we will add the necessary modules
    from Angular Material:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can see in the preceding example that we have also exported the Material
    modules, as we will use them on different modules in the application.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have imported the needed modules for our application, let’s convert
    the components.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Navbar component
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **navbar component** is found under the shared module. We will use the
    toolbar material to create our navbar component. To implement this, we will place
    the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding example, we have used the `mat-toolbar` element to use the
    toolbar material. We can also add a color property to style the toolbar and add
    additional elements inside.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to import `MaterialModule` under `SharedModule` for this to recognize
    `MatToolbarModule` and it will output the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The look of the navbar component after implementing Material](img/B18159_10_15.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The look of the navbar component after implementing Material
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Anti-hero list component
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This component is found under the anti-hero module. We will use the table material
    to create our list component. To implement this, we will place the following code
    for `anti-hero-list.component.html`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will place this for `anti-hero-list.component.ts`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding example code, we have still used the same variables in our
    application; the `antiHeroes` variable that holds the list of anti-heroes is now
    bound to the `dataSource` property and we have also iterated the `headers` property
    to display the column name and its associated values. Lastly, we have created
    a new variable named `headerFields` that contains the `fieldName` to display the
    values of an anti-hero item.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to import `MaterialModule` under `AntiHeroModule` for this to
    recognize `MatTableModule` and it will have the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – The look of the table component after implementing Material](img/B18159_10_16.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – The look of the table component after implementing Material
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Command bar component
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a new dumb component under the anti-hero module. We will execute
    the `ng g c anti-hero/components/anti-hero-command-bar` command and we will place
    the following code for `anti-hero-command-bar.html`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will place this for `anti-hero-command-bar.ts`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the preceding example code, we have also used the toolbar module to create
    our command bar component. Since this is a dumb component, we should only emit
    the actions to its parent component and not hold any dependencies. After successfully
    creating the command bar, we will get the following output:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – The look of the command bar component after implementing Material](img/B18159_10_17.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – The look of the command bar component after implementing Material
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will finalize the application layout by placing the components on the
    following page:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '`app.component.html`:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`list.component.html`:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After successfully implementing the preceding code, we will now have the following
    layout:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Layout for the list component page](img/B18159_10_18.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Layout for the list component page
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: We have now created our anti-heroes page component with Material Design. As
    we go through the following chapters, we will implement the features for the action
    buttons and the form component.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned; you have learned about the concepts and fundamentals
    of Angular and, at the same time, how to scaffold an Angular project and create
    components, directives, and modules using the Angular CLI. You have also learned
    some of the best practices for organizing our Angular components, modules, and
    other parts of our Angular project. This will be very useful for the maintainability
    of the project, especially for enterprise applications.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build Reactive forms, essential form
    control, and grouping form controls in Angular. We will also implement `FormBuilder`
    and validate form input.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
