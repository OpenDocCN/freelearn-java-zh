<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Libraries for Pure Functional Programming</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discussed the purely functional style with the help of essential libraries such as <kbd>cats</kbd>. This library performs quite well on tasks of purely functional programming, but in practice, that is not quite enough for comfortable programming.</p>
<p class="mce-root">If you take a look at conventional imperative languages such as Java, you will see that they usually have a lot of libraries and infrastructure for performing specific tasks. Moreover, it is also possible to argue that the choice of programming language is primarily driven by the infrastructure it provides.</p>
<p class="mce-root">This way, for example, Python is a de facto standard for machine learning, because it provides an elaborate set of scientific libraries to perform scientific computing, and R is a de facto standard for statistical computing. Companies often choose Scala because it provides access to Spark and Akka libraries for machine learning and distributed computing.</p>
<p class="mce-root">Hence, when talking about a particular programming style, it is of great importance to also mention that it is an infrastructure that is developed around the staff. In this chapter, we will cover this infrastructure by looking at a bunch of other libraries that exist for purely functional programming in Scala with <kbd>cats</kbd>.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The Cats effect</li>
<li>Server-side programming</li>
</ul>
<p class="mce-root">We will start this chapter by looking at the concurrency library for <kbd>cats</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cats effect</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Cats effect is a library for concurrent programming in <kbd>cats</kbd>. Its main feature is a bunch of type classes, data types, and concurrency primitives to describe concurrent programming in Scala with <kbd>cats</kbd>.</p>
<p class="mce-root">The concurrency primitives support among other things:</p>
<ul>
<li class="mce-root">Resource management<span>—</span><span>think try-with-resources.</span></li>
<li class="mce-root">Seamless composition of parallel computations.</li>
<li class="mce-root">Communication between parallel computations.</li>
</ul>
<p>We will start discussing the library by looking at its central concurrency primitive, <kbd>IO</kbd>, and some capabilities of Cats that we will need in the process of discussing it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ProductR</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before diving deep into the library and discussing its features, we need to mention a particular operator that is frequently used throughout this library. We have already discussed the Applicative type class, and that it is useful for parallel composition.</p>
<p class="mce-root">An operator from this type class that is frequently used in <kbd>cats</kbd> is a so-called right product operator.</p>
<p class="mce-root">The operator in question takes two computations, performs a product between them, and takes only the right-hand result. Particularly in the Cats effect, the operator is frequently used to specify that one event should happen after another.</p>
<p class="mce-root">It also has a symbolic form, which looks like this: <kbd>*&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IO – the concurrence data type</h1>
                </header>
            
            <article>
                
<p class="mce-root">The primary data type that the Cats effect offers is IO. This is a data type that defines a computation that is to be performed at some point in the future. For example, you can have the following expression:</p>
<pre class="mce-root">object HelloWorld extends App {<br/>  val hello = IO { println("Hello") }<br/>  val world = IO { println("World") }<br/>  (hello *&gt; world).unsafeRunSync<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">Crucial detail to notice about IO is that it is precisely a description of the computation. Here, <kbd>cats</kbd> supports a so-called computation as a value paradigm. Computation as a value dictates that you should not evaluate your competition straight away, but you should store the descriptions of these computations. This way, you will be able to evaluate them at any point in the future.</p>
<p class="mce-root">This approach has a number of benefits, and this is what we are going to discuss next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Referential transparency</h1>
                </header>
            
            <article>
                
<p class="mce-root">The first benefit Cats has is referential transparency. In the preceding example, the computation to print hello world to the command line will not be evaluated right away. It is side effecting, and the fact that we do not evaluate it right away means it is referentially transparent. You can evaluate the computation as follows:</p>
<pre class="mce-root">(hello *&gt; world).unsafeRunSync</pre>
<p class="mce-root">IO has a bunch of methods, the names of which are prepended with the <kbd>unsafe</kbd> word.</p>
<p class="mce-root">Unsafe methods are generally what their prefix says, <kbd>unsafe</kbd>. This means that they may block, produce side effects, throw exceptions, and do other things that may cause you a headache. Following the description of the IO type in the documentation itself, you should only call such a method once, ideally at the end of your program.</p>
<p class="mce-root">So, basically, the main idea is that you describe your entire program in terms of the IO primitive, using the conveniences provided by this primitive by the Cats effect library. Once your entire application is described, you can run the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inversion of control</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since a computation expressed in terms of IO is not executed immediately but is merely stored as a description of a computation, it is possible to execute the computation against different execution strategies. For example, you may want to run the computation against various concurrent backends, each with its own concurrency strategies. You may want to run a competition synchronously or asynchronously. Later in this chapter, we will see how exactly this is done.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchrony with IO</h1>
                </header>
            
            <article>
                
<p class="mce-root">The central domain of the application of the Cats effect is asynchronous programming. Asynchronous programming is an event-driven style of programming, where you do not waste threads and other resources on blocking, waiting for some event to happen.</p>
<p class="mce-root">Consider, for example, that you have a web server that handles incoming HTTP requests. It has a pool of threads that are used by the server to handle each request. Now, the handlers themselves may require some blocking operations. For example, contacting a database for contacting an external HTTP API can be a potentially blocking operation. This is because the database or an HTTP API does not respond immediately as a rule. This means that if a request handler needs to contact such a resource, it will need to wait for the service to reply.</p>
<p class="mce-root">If such waiting is done naively, by blocking an entire thread and reviving it once the request is available, we have a situation where we waste threads. If such a server comes under a high load, there is a danger that all of the threads will be blocked for the majority of the time. Blocking means that they do not do anything and are just waiting for a response from a resource. Since they are not doing anything, these threads could have well been used to handle other requests that possibly do not require such kinds of blocking.</p>
<p class="mce-root">Precisely for this reason, current server-side programming is aimed toward asynchronous processing, which means that if a handler needs to contact some potentially blocking resource, it contacts it. However, once it has nothing else to do, it is supposed to release its thread. It will continue the computation once the response it is waiting for is available.</p>
<p class="mce-root">This kind of strategy allows for very lightweight concurrent modules that do not waste threads. This also ensures that the threads are busy with useful work most of the time, and not with blocking.</p>
<p class="mce-root">However, this model requires dedicated libraries and server-side technologies that are specifically built with asynchrony in mind. The Cats effect precisely aims to meet such asynchronous requirements.</p>
<p class="mce-root">Now, let's take a look at some examples which demonstrate in practice how blocking differs from asynchrony and how Cats facilitates asynchrony. You will also learn a bunch of Cats effect APIs in the process of looking at these examples.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blocking example</h1>
                </header>
            
            <article>
                
<p class="mce-root">First, let's take a look at the API behind creating an asynchronous IO action:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/265727b1-1148-4184-84d6-4729f59758c3.png" style="width:34.33em;height:5.33em;"/></p>
<p class="mce-root">So, you can supply an arbitrary task into an <kbd>apply</kbd> method of IO, and this will construct the description of this task.</p>
<p class="mce-root">We can model blocking of a computation by using the <kbd>Thread.sleep</kbd> Java API under the IO apply method as follows:</p>
<pre class="mce-root">IO { Thread.sleep(1000) }</pre>
<p class="mce-root">Notice that the preceding example will block its thread. IO may be just a description of a computation. However, the computations are supposed to get executed at some point. In the JVM world, any computation runs on a thread. In the preceding example, we are using the Java <kbd>Thread.sleep</kbd> API to explicitly say that we need to block a thread the computation is running on for one second, or 1,000 milliseconds.</p>
<p class="mce-root">With the help of the preceding primitive, let's compose an infinite computation that will be easy for us to trace and study. If we have a long-running computation that outputs something to the command line in equal periods of time, we can easily see whether and how the computation is progressing. Typically, such an infinite computation would be possible in terms of a loop. In functional programming, a loop can be created in terms of Monad's <kbd>tailRecM</kbd>:</p>
<pre class="mce-root">def taskHeavy(prefix: String): IO[Nothing] =<br/>  Monad[IO].tailRecM(0) { i =&gt; for {<br/>    _ &lt;- IO { println(s"${Thread.currentThread.getName}; $prefix: $i") }<br/>    _ &lt;- IO { Thread.sleep(1000) }<br/>  } yield Left(i + 1) }</pre>
<p class="mce-root">In the preceding code, you can see a Monadic infinite loop that utilizes IO to describe an infinite computation. First of all, the computation will output the name of the current thread, the name of the current task, and the number that will be incremented from iteration to iteration.</p>
<p class="mce-root"/>
<p class="mce-root">The thread output can be useful to trace which thread the computation is running on. This information can be used to see how threads in a given thread pool are allocated. The prefix is necessary to distinguish one task from another in case we want to run several such computations at once. We will do this in order to see how such a task performs in a concurrency setting.</p>
<p class="mce-root">Testing out such a blocking task in concurrent environment models requires an HTTP server under a high load. There, you also have a multitude of tasks of the same nature running concurrently. The preceding example models a situation where a handler task blocks the underlying thread.</p>
<p class="mce-root">Finally, the identifier number is used to identify the progress of a given task so that we can see how evenly the tasks progress and whether any task is getting choked.</p>
<p class="mce-root">Since, in the preceding example, we were motivated by the ability to test tasks in the concurrency settings, next, we will talk briefly about the concurrency environment we are going to run the tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrency infrastructure</h1>
                </header>
            
            <article>
                
<p class="mce-root">The concurrency environment is represented by an execution context, which is a Scala class. The official documentation defines it as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/fe9abd00-668c-4d79-b98a-3d458518d117.png" style="width:51.08em;height:7.33em;"/></p>
<p class="mce-root">It is a standard Scala class with a single method to run a Java <kbd>Runnable</kbd>:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/420e034c-d13b-48e7-99fa-839c77d0e4d1.png" style="width:27.33em;height:6.08em;"/></p>
<p class="mce-root">An execution context is necessary whenever we are dealing with concurrency primitives in Scala, such as Future. The Cats effect also relies on this type to describe its own execution environment. We can construct an execution context and specify the number of threads available in its thread pool as follows:</p>
<pre class="mce-root">implicit val ec: ExecutionContext =<br/>  ExecutionContext.fromExecutor(Executors.newFixedThreadPool(2))</pre>
<p class="mce-root">In the preceding code, we are using the <kbd>fromExecutor</kbd> method of the <kbd>ExecutionContext</kbd> class, which is defined as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/9b80d494-eb16-4fa8-8471-db9199cbe54a.png" style="width:39.92em;height:7.00em;"/></p>
<p class="mce-root">This method uses the Java API to construct the execution context. In our concrete preceding example, we are constructing an execution contact that possesses a fixed thread pool that has two threads.</p>
<p class="mce-root">Another motivating factor for our example was running multiple instances of the same concurrently. Next, we will be looking at the API to provide this functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running tasks in bunches</h1>
                </header>
            
            <article>
                
<p class="mce-root">We can define a function to run an arbitrary IO task on a given execution context in multiple instances, as follows:</p>
<pre class="mce-root">def bunch(n: Int)(gen: String =&gt; IO[Nothing]): IO[List[Fiber[IO, Nothing]]] =<br/> (1 to n).toList.map(i =&gt; s"Task $i").traverse(gen(_).start)</pre>
<p class="mce-root">The <kbd>bunch</kbd> function takes the number of tasks we need to launch concurrently as the first argument. As a second argument, it takes a function <kbd>gen</kbd> to construct tasks. The function takes a string as its first argument, which is the name of the task. In the conditions where we have the same task to run in multiple instances, it is crucial to distinguish them somehow. Therefore, we need to provide the name to the generator function.</p>
<p class="mce-root">To understand the output type of the function, let's take a look at the body of the function.</p>
<p class="mce-root"/>
<p class="mce-root">First of all, the body constructs a list of <kbd>n</kbd> elements. The intention is to use the list to specify the loop to create the tasks. We then create the required number of tasks by using the <kbd>map</kbd> function on the list we have created:</p>
<pre class="mce-root">(1 to n).toList.map(i =&gt; s"Task $i")</pre>
<p class="mce-root">Next, we are using the traverse function, which does something to each task we have just created. Let's take a look at what happens inside the traverse function to see how parallelism is achieved in the Cats effect:</p>
<pre class="mce-root">.traverse(gen(_).start)</pre>
<p class="mce-root">The main point of interest is the <kbd>start</kbd> function. Let's take a look at how it is defined:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/549d348a-3e20-48a5-a6a9-a12295d0cd1e.png"/></p>
<p class="mce-root">The function in question produces a so-called <kbd>Fiber</kbd> under the IO primitive. Let's take a look at how <kbd>Fiber</kbd> is defined and what it is all about:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/64e6ee05-fe69-4637-b758-18ff6a2f310d.png"/></p>
<p class="mce-root"/>
<p>It defines the following API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f0a504b4-e6f5-4b0f-b3d9-cf7761afa4c7.png"/></p>
<p class="mce-root">Usually, waiting in an IO-based Monadic flow blocks execution. Of course, that blocking is done asynchronously. <span>However, if you're calling the <kbd>start</kbd> method on an IO, it will not block the Monadic flow. Instead, it will return immediately with a <kbd>Fiber</kbd> object.</span></p>
<p class="mce-root">Think of a <kbd>Fiber</kbd> object as a remote control unit for the underlying alpha complication. It defines two methods, <kbd>cancel</kbd> and <kbd>join</kbd>. These two methods can be used to communicate with the underlying computation. The <kbd>cancel</kbd> method cancels the competition, and the <kbd>join</kbd> method blocks the current Monadic flow until an underlying IO computation finishes. <kbd>join</kbd> returns the value of this computation in the Monadic floor.</p>
<p class="mce-root">Also, notice that these <kbd>cancel</kbd> and <kbd>join</kbd> methods are all returning an IO primitive. This means that you can use this method from a Monadic flow.</p>
<p class="mce-root">So, why are we using the <kbd>start</kbd> method from our bunch example?</p>
<pre class="mce-root">gen(_).start</pre>
<p class="mce-root">Remember, our tasks are infinite. We have defined them has an infinite loop that blocks every second. The job of traverse is to evaluate all of the tasks supplied to it and return a combined task under a single effect type, in this case, IO. However, our tasks cannot be evaluated to some concrete result since they are infinite. Hence, we will perform the start call on every task in order to specify that we do not need the task's result itself; we can only be satisfied with the remote control unit for this task. This way, the traverse method will not wait for any single task to finish, but will start all of them asynchronously on the execution context we discussed previously.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Heavy load with blocking</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now, imagine that our <kbd>taskHeavy</kbd> is a handler for an HTTP server. The server is undergoing a heavy load and has <kbd>1000</kbd> ongoing requests. This means that we need to create <kbd>1000</kbd> tasks to handle them. With the <kbd>bunch</kbd> method, we can define such handling as follows:</p>
<pre class="mce-root">(IO.shift *&gt; bunch(1000)(taskHeavy)).unsafeRunSync</pre>
<p class="mce-root">Notice that we have encountered another new primitive in this example. It is a <kbd>shift</kbd> method that's defined on the IO data type. It is defined as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/03d84edb-7e47-49b6-b2c3-54e99d37edd0.png"/></p>
<p class="mce-root">The <kbd>shift</kbd> method is an instruction for the execution to get shifted to an <kbd>ExecutionContext</kbd>, which is present as an implicit dependency in scope. Here, we implicitly depend on a <kbd>Timer</kbd> object and not an <kbd>ExecutionContext</kbd>. The <kbd>ExecutionContext</kbd> can be used to derive a <kbd>Timer</kbd> object using an implicit method that is a part of the IO API:</p>
<p class="mce-root"/>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/95318aa0-2298-4dab-83bd-5d9e062f295a.png"/></p>
<p class="mce-root">Since we have an <kbd>ExecutionContext</kbd> in the implicit scope, we can call the <kbd>shift</kbd> method to shift the execution of the current IO computation to the thread pool with have defined. Also notice the <kbd>*&gt;</kbd> operator here, which we discussed previously in this chapter. It says that the second competition should be executed after the first one, which is the shift to a concurrent context. We also ran the example in place to see how it goes with the help of <kbd>unsafeRunSync</kbd>. The output of the program is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/1af49cec-3c98-4209-80b5-1541648c31b3.png"/></p>
<p class="mce-root"/>
<p class="mce-root">The first thing to notice here is that both of the threads we have in our <kbd>ExecutionContext</kbd> are used to process the tasks. You can see that by looking at the name of the threads output by the task. It changes from task to task. However, also take note that it is only the first two tasks that get the chance to be executed. This is because we are using a blocking call to <kbd>Thread.sleep</kbd> to specify and delay our execution. So, in the setting of the infinite handling tasks, such a server, it would only be able to handle two requests at a time. In a setting where you need to handle <kbd>1000</kbd> requests, this is inadequate.</p>
<p class="mce-root">Now, let's see how we can benefit from asynchrony to specify lightweight concurrency primitives to handle that volume of requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Synchronous tasks</h1>
                </header>
            
            <article>
                
<p class="mce-root">You can asynchronously define the preceding computation as follows:</p>
<pre class="mce-root">def taskLight(prefix: String): IO[Nothing] =<br/>  Monad[IO].tailRecM(0) { i =&gt; for {<br/>    _ &lt;- IO { println(s"${Thread.currentThread.getName}; $prefix: $i") }<br/>    _ &lt;- IO.sleep(1 second)<br/>  } yield Left(i + 1) }</pre>
<p class="mce-root">Notice that this method is defined similarly to the previous task. However, we no longer block the thread. Instead, we are using a built-in IO primitive called <kbd>sleep</kbd>. <kbd>sleep</kbd> is a non-blocking primitive, meaning that it does not block the underlying thread. That is, it is a description of the <kbd>sleep</kbd> operation. Remember, all of the computations happening defined in terms of IO are descriptions of computations and not computations themselves. So, you can define a <kbd>sleep</kbd> operation as you please. Hence, it is reasonable to define this operation in an unblocking manner so that the underlying thread gets released when this <kbd>sleep</kbd> operation is encountered, and the computation is resumed when the execution environment receives a signal stating that the <kbd>sleep</kbd> operation was terminated successfully. A similar principle is used in all asynchronous computations. We can run this task as follows:</p>
<pre class="mce-root">(IO.shift *&gt; bunch(1000)(taskLight)).unsafeRunSync</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">The output of the program is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/8e1949a9-6ba6-46fb-b263-03a0460e5133.png"/></p>
<p class="mce-root">Notice how all of the <kbd>1000</kbd> tasks get enough resources to get executed. This is because each of these tasks releases the underlying thread once they do not need it anymore. Hence, even with two threads, we are able to handle 1,000 tasks at once successfully. So, computations described asynchronously are quite lightweight and can be used in systems that are designed for high loads. Next, let's take a look at how you can create an asynchronous IO primitive yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing asynchronous tasks</h1>
                </header>
            
            <article>
                
<p class="mce-root">IO provides an API that allows you to transform an existing computation based on callbacks into an asynchronous IO. This can be used to port existing computation to IO in an asynchronous manner.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">Suppose you have the following computation:</p>
<pre class="mce-root">def taskHeavy(name: String): Int = {<br/>  Thread.sleep(1000)<br/>  println(s"${Thread.currentThread.getName}: " +<br/>    s"$name: Computed!")<br/>  42<br/>}</pre>
<p class="mce-root">Like we saw previously, it is blocking a thread as it uses <kbd>Thread.sleep</kbd> to block the computation. The entire point of the computation is that it does not return immediately.</p>
<p class="mce-root">Now, let's take a look at how you can asynchronously run the computation:</p>
<pre class="mce-root">def sync(name: String): IO[Int] =<br/>  IO { taskHeavy(name) }</pre>
<p class="mce-root">Here, we are using an already familiar way to lift a synchronous computation into an IO data type. We have already seen the consequences of doing so in our previous example. This time, since our computation is not infinite, let's take a look at the time difference of handling this computation versus an asynchronous competition we are about to construct from it. To do so, we will need a benchmarking capability:</p>
<pre class="mce-root">def benchmark[A](io: IO[A]): IO[(A, Long)] =<br/>  for {<br/>    tStart &lt;- Timer[IO].clockMonotonic(SECONDS)<br/>    res &lt;- io<br/>    tEnd &lt;- Timer[IO].clockMonotonic(SECONDS)<br/>  } yield (res, tEnd - tStart)</pre>
<p class="mce-root">In the preceding code, we are constructing a benchmarking capability that will run IO and will report on how long it took to run the computation.</p>
<p class="mce-root">The first thing to notice here is how computation as a value strategy that IO implies can be beneficial to augment computations. Here, the benchmark method accepts an IO that is not yet evaluated. It is just a description of a computation. Next, it wraps this computation in a capability to measure time, and, finally, it returns the result of the computation, together with the benchmark.</p>
<p class="mce-root"/>
<p class="mce-root">Also, notice how we are using the <kbd>Timer</kbd> data type here. We have already briefly touched on the <kbd>Timer</kbd> class in the context of the execution context of the IO primitive. The <kbd>Timer</kbd> class happens to be an execution context that IO uses to manage its threading:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/8bbf3032-f573-4fe7-a84c-5655149ca804.png"/></p>
<p class="mce-root"><kbd>Timer</kbd> defines the following abstract methods:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/5ac021b4-7fd1-4bc1-a0b6-00ba741ac609.png"/></p>
<p class="mce-root">We are already familiar with the <kbd>shift</kbd> method. It can be used to shift the execution context of a given IO flow into this <kbd>Timer</kbd>. Remember that <kbd>Timer</kbd> can be constructed from a standard Scala <kbd>ExecutionContext</kbd>. Other methods that <kbd>Timer</kbd> defines are needed for time measurement. One of them is <kbd>clockMonotonic</kbd>, which we are using for our preceding benchmark.</p>
<p class="mce-root">Finally, we may want to define a <kbd>benchmarkFlush</kbd> method to report the measurements to the command line as follows:</p>
<pre class="mce-root">def benchmarkFlush[A](io: IO[A]): IO[Unit] =<br/>  benchmark(io).map { case (res, time) =&gt;<br/>    println(s"Computed result $res in $time seconds") }</pre>
<p class="mce-root">Next, we will try and run our synchronous example concurrently in multiple instances while measuring its time. But first of all, we will need a <kbd>bunch</kbd> function to launch multiple instances of this task:</p>
<pre class="mce-root">def bunch(n: Int)(gen: String =&gt; IO[Int]): IO[List[Int]] =<br/>  (1 to n).toList.map(i =&gt; s"Task $i").traverse(gen(_).start)<br/>    .flatMap(_.traverse(_.join))</pre>
<p class="mce-root">The first part of this function is similar to the one we had in the previous example. However, we have this function slightly extended with the following appendix:</p>
<pre class="mce-root">.flatMap(_.traverse(_.join))</pre>
<p class="mce-root">Remember that the original version of our bunch function started computations asynchronously from its <kbd>traverse</kbd> method. The result was a list of <kbd>Fibers</kbd> that we were not interested in. In the task of benchmarking, we are interested in the time when all the computations terminate. Hence, we would like to use the <kbd>join</kbd> method of the <kbd>Fibers</kbd> that are returned to create a combined IO data type that succeeds when all of the computations succeed. Notice that we still need the <kbd>start</kbd> capability for the tasks to be started asynchronously and not sequentially. If you don't use the <kbd>start</kbd> method from the <kbd>traverse</kbd> method here, tasks we are trying to start in the bunch will be executed synchronously, and we need parallel execution to utilize our shared thread pool.</p>
<p class="mce-root">Next, we can run the synchronous example in a <kbd>bunch</kbd> under the benchmark, as follows:</p>
<pre class="mce-root">benchmarkFlush(IO.shift *&gt; bunch(10)(sync)).unsafeRunSync</pre>
<p class="mce-root"/>
<p class="mce-root">The output of the preceding program is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/0262cf11-caa9-44e5-a3ee-b93cd1fdf274.png"/></p>
<p class="mce-root">It took us five seconds to compute 10 tasks. This is because each of the tasks blocks the underlying thread for one second, and we have two threats in our execution context.</p>
<p class="mce-root">Next, we'll take a look at how to define an asynchronous version of the same task.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous API</h1>
                </header>
            
            <article>
                
<p class="mce-root">First of all, we need to remark what exactly we mean by the word asynchronous. We mean asynchronous with respect to the thread pool that the IO data type is executed on. We assume that we have no control of the task itself, and we are not able to redefine it. In fact, we do not care about how it is implemented; all we care about is the precise moment when it terminates. The task here is to prevent the threads of this precise IO execution from blocking.</p>
<p class="mce-root"/>
<p class="mce-root">To achieve this, we can use the <kbd>IO.async</kbd> method:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/c27285a4-05d7-4659-ab0e-21e329817001.png"/></p>
<p class="mce-root">This method has a somewhat tricky signature. So, first, let's take a look in brief at what it does. Given a particular computation, it provides a callback with which it can notify the IO task to be constructed. The IO task returned from the <kbd>async</kbd> method will be considered completed once the underlying computation calls the callback provided to it.</p>
<p class="mce-root">The benefit of this approach is that the IO does not care about where or how the computational runs. It only cares about when it is completed.</p>
<p class="mce-root">So, the <kbd>async</kbd> method is a function, the argument to which is another function with the following signature:</p>
<pre class="mce-root"><span class="extype">Either</span><span>[</span><span class="extype">Throwable</span><span>, </span><span class="extype">A</span><span>]) ⇒ </span><span class="extype">Unit</span></pre>
<p class="mce-root">It is a callback that an underlying computation will call on its completion. It is provided to the user of the <kbd>async</kbd> method by IO, and acts as a notification stating that the IO should be considered completed.</p>
<p class="mce-root">Next, let's take a look at how this method can be used to create asynchronous computations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous example</h1>
                </header>
            
            <article>
                
<p class="mce-root">We can redefine our previous example in terms of <kbd>async</kbd> as follows:</p>
<pre class="mce-root">def async(name: String): IO[Int] =<br/>  IO.async { cb =&gt;<br/>    new Thread(new Runnable { override def run =<br/>      cb { Right(taskHeavy(name)) } }).start()<br/>  }</pre>
<p class="mce-root">So, here, we are using the <kbd>IO.async</kbd> primitive to lift our computation into an asynchronous context. First of all, this <kbd>async</kbd> method gives us a callback as an input. We are supposed to call this callback once we are done with our computation.</p>
<p class="mce-root"/>
<p class="mce-root">Next, we dispatch our heavy computation to some other execution context. In our case, it is merely starting another thread that does not belong to the thread pool on which we are executing our IO. Many scenarios are possible here, especially in the context of purely asynchronous computations, that is, the ones that do not use blocking at all. For example, you could imagine registering a callback on another asynchronous action from <kbd>async</kbd>. This can be useful, for example, for GUI programming. However, in this example, using a separate thread will suffice. The only thing to keep in mind is that threads are heavyweight primitives. Although we are not blocking the IO thread pool, we are still creating threads, and we are still blocking them. This can drain the resources of the system.</p>
<p class="mce-root">Next, we can run our computation as follows:</p>
<pre class="mce-root">benchmarkFlush(IO.shift *&gt; bunch(10)(async)).unsafeRunSync</pre>
<p class="mce-root">The output is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/1fd47afc-5165-460d-8b33-80023744919c.png"/></p>
<p class="mce-root"/>
<p class="mce-root">Notice that we were able to compute the operation in two seconds. This is because the IO tasks are no longer blocking the underlying execution thread pull the IO is executed on. So, once one IO goes to sleep, it releases its thread.</p>
<p class="mce-root">Next, we will pay a little bit more attention to <kbd>Fibers</kbd> and how you can utilize them for concurrent programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fibers</h1>
                </header>
            
            <article>
                
<p class="mce-root">As we previously discussed, Fibers are essentially remote control units for IO. Let's see how this can be used in practice to run operations in parallel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The computation</h1>
                </header>
            
            <article>
                
<p class="mce-root">Suppose that you have some long-running competition. Suppose that the computation in question has the task of finding a sum of numbers on a specific range. The computation is long-running because the invocation must pause for half a second from number to number:</p>
<pre class="mce-root">def sum(from: Int, to: Int): IO[Int] =<br/>  Monad[IO].tailRecM((from, 0)) { case (i, runningTotal) =&gt;<br/>    if (i == to) IO.pure( Right(runningTotal + i) )<br/>    else if (i &gt; to) IO.pure( Right(runningTotal) )<br/>    else for {<br/>      _ &lt;- IO { println(s"${Thread.currentThread.getName}: " +<br/>        s"Running total from $from to $to, currently at $i: $runningTotal") }<br/>      _ &lt;- IO.sleep(500 milliseconds)<br/>    } yield Left((i + 1, runningTotal + i)) }</pre>
<p class="mce-root">We are defining our competition in terms of a Monadic loop. In the body of the flow of the loop, we have two terminal cases. The first terminal case is when the current number is equal to the upper bound of our range. In that case, the result is the running total plus that number.</p>
<p class="mce-root">Another terminal case is when the number is greater than the upper range of the loop. In principle, this situation should never arise, but it is still a good idea to guard against it to prevent infinite loops. In this scenario, we return the running total without adding the current number.</p>
<p class="mce-root"/>
<p class="mce-root">Also notice the <kbd>pure</kbd> method, which is used in these non-terminal cases. It is defined as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a0ce1cee-5993-40ce-acab-b8b440442402.png"/></p>
<p class="mce-root">It lifts a value into the IO context without doing anything else with it.</p>
<p class="mce-root">Finally, we have a non-terminal case of the Monadic loop:</p>
<pre class="mce-root">else for {<br/>  _ &lt;- IO { println(s"${Thread.currentThread.getName}: " +<br/>    s"Running total from $from to $to, currently at $i: $runningTotal") }<br/>  _ &lt;- IO.sleep(500 milliseconds)<br/>} yield Left((i + 1, runningTotal + i))</pre>
<p class="mce-root">We have some debugging output stating the current thread and the current status of the computation. Then, we block the execution asynchronously by using the <kbd>IO.sleep</kbd> primitive.</p>
<p class="mce-root">Finally, we return with a new state of the computation, that is, the next number, and the updated running total.</p>
<p class="mce-root">The computation is long-running because it will pause for half a second on each number.</p>
<p class="mce-root">Next, let's see what happens if we want to combine the results of two such computations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IO combination without Fibers</h1>
                </header>
            
            <article>
                
<p class="mce-root">Consider that we need to compute a sum of two ranges, and then sum the results. A naive way to combine is as follows:</p>
<pre class="mce-root">def sequential: IO[Int] =<br/> for {<br/>   s1 &lt;- sum(1 , 10)<br/>   s2 &lt;- sum(10, 20)<br/> } yield s1 + s2</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">In the preceding code, we combine our computations using the Monadic flow. Let's see what happens if we try and run the competition under a benchmark function:</p>
<pre class="mce-root">benchmarkFlush(sequential).unsafeRunSync</pre>
<p class="mce-root">The result of the preceding execution is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/380011da-dc89-4732-a245-542013df5c1a.png"/></p>
<p class="mce-root">First, notice that the first range gets computed first. The second range does not even start until the first range finishes. Also notice how both of the threads of the thread pool get utilized in the process of computation. This can be considered a waste of threads and resources since we could use both of the threads to compute sums in parallel. However, we are doing so sequentially here.</p>
<p class="mce-root"/>
<p class="mce-root">We may argue that the preceding scenario occurs because we are using the Monadic flow. As you may recall, Monads define sequential composition. It is not possible to start the next computation until the previous computation finishes. Also, we know that Applicative is used for cases of parallelism. Can we apply the <kbd>traverse</kbd> function to compute all of our computations in parallel? Let's try:</p>
<pre class="mce-root">def sequentialTraverse: IO[Int] =<br/>  List(sum(1, 10), sum(10, 20)).traverse(identity).map(_.sum)</pre>
<p class="mce-root">Now, the computations are independent one from another. What happens if we run them?</p>
<pre class="mce-root">benchmarkFlush(sequentialTraverse).unsafeRunSync</pre>
<p class="mce-root">The output looks precisely the same as it did in the preceding sequential example, which means that the default implementation of Applicative for IO runs the computations one by one, even though they are independent.</p>
<p class="mce-root">How can the situation be remedied with the help of Fibers? Let's take a look at how we can launch the computations in parallel with Fibers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IO combination with Fibers</h1>
                </header>
            
            <article>
                
<p class="mce-root">Previously, we briefly touched on the topic of Fibers. They are remote control units for underlying computations. We know that on any IO, we can call a <kbd>start</kbd> method, and that will cause it to run asynchronously, which means that it will not block the current execution flow of the IO effect type. Also, you know that we can later block on a Fiber in order to obtain the result. Notice that, here, we are blocking with respect to the Monadic flow. It is precisely the Monadic flow that is getting blocked, that is, the execution of the Monadic instructions gets suspended. The underlying thread IO used to run is not blocked by anything.</p>
<p class="mce-root">Let's see how we can implement our sum example with the help of Fibers:</p>
<pre class="mce-root">def parallel: IO[Int] =<br/>  for {<br/>    f1 &lt;- sum(1 , 10).start<br/>    f2 &lt;- sum(10, 20).start<br/>    s1 &lt;- f1.join<br/>    s2 &lt;- f2.join<br/>  } yield s1 + s2</pre>
<p class="mce-root">Our sum instructions are executed asynchronously with respect to the Monadic flow, which means that the Monadic flow application will not wait for either of the two sums to finish and will proceed directly through the first two instructions without blocking. The result is that both of the computations get submitted for execution and will be executed in parallel.</p>
<p class="mce-root">After that, we can block on the Fibers to obtain the results. We can run the application as follows:</p>
<pre class="mce-root">benchmarkFlush(parallel).unsafeRunSync</pre>
<p class="mce-root">The output is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/045e158b-fc1d-4da4-9f04-91698eacc9f8.png"/></p>
<p class="mce-root">Now, both of the tasks are executed concurrently. The time needed to compute the tasks is reduced by a factor of 2.</p>
<p class="mce-root">Next, let's take a look at another capability of Fibers, namely to cancel the underlying computation.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Canceling Fibers</h1>
                </header>
            
            <article>
                
<p class="mce-root">Suppose we have one range shorter than another, and we would like to cancel the longer range computation when the first one is completed. You can do this with Fibers as follows:</p>
<pre class="mce-root">def cancelled: IO[Int] =<br/>  for {<br/>    f1 &lt;- sum(1 , 5 ).start<br/>    f2 &lt;- sum(10, 20).start<br/>    res &lt;- f1.join<br/>    _ &lt;- f2.cancel<br/>  } yield res</pre>
<p class="mce-root">We can run it as follows:</p>
<pre class="mce-root">benchmarkFlush(cancelled).unsafeRunSync</pre>
<p class="mce-root">And the result of the execution is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/6c17f512-d4b0-451a-8d3c-e05cb5b6897d.png"/></p>
<p class="mce-root">Notice that the second range gets cancelled once the first range finishes its execution.</p>
<p class="mce-root">In this chapter, we have discussed the currency capabilities of the Cats effects library in detail. It is the primary objective of the library. However, it has a bunch of other useful methods and primitives. So, next, we will take a look at one of these primitives—the <kbd>bracket</kbd> primitive<span>—</span>which is a try-with-resources for Cats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bracket</h1>
                </header>
            
            <article>
                
<p class="mce-root">Often, we encounter a situation where we need to access a resource that we need to close afterwards. This can be a file reference, a database session, a HTTP connection, or something else. The Cats effect has a dedicated primitive to allow you to work with such resources securely. In Java, there is a dedicated statement for handling resources, which is try-with-resources. Scala does not have a similar statement. However, the situation changes with the <kbd>bracket</kbd> method, which is defined on the IO primitive:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/75d5b6ae-baa6-4740-9c31-0c12b9eab7dd.png"/></p>
<p class="mce-root">As it says in the documentation, the <kbd>bracket</kbd> primitive makes the underlying execution engine treat the result of this IO as a resource to be closed. With the <kbd>bracket</kbd> function, you can pass two arguments. The first one specifies what you wanted to do with the underlying process. It is very much like the argument to the <kbd>flatMap</kbd> function. The second function is the specification of how to close the underlying resource. This second function will be called after the computation is finished, no matter how it finished. It could have finished with an error or canceled, however, the cleanup function will be called in any situation. This prevents memory leaks that can be a problem in the situation of a high-performance environment.</p>
<p class="mce-root"/>
<p class="mce-root">Let's take a look at how we can use it as an example. First of all, we need a closable resource, the closed status of which we can easily check. We can define it as follows:</p>
<pre class="mce-root">class DBSession {<br/>  var closed = false<br/>  def runStatement(stat: String): IO[List[String]] = {<br/>    val computation = IO {<br/>      if (stat.contains("user")) List("John", "Ann")<br/>      else if (stat.contains("post")) List("Post1", "Post2")<br/>      else Nil<br/>    }<br/>    if (!closed) computation<br/>    else IO.raiseError { new RuntimeException("Connection is closed") }<br/>  }<br/>  def close(): Unit = closed = true<br/>  def isClosed = closed<br/>}</pre>
<p class="mce-root">In the preceding code, we have defined a database session connection. It has a <kbd>closed</kbd> flag which prevents any statements to be run against this session when it is set. Next, we have the <kbd>runStatement</kbd> method, which performs some execution logic to model a statement run against a database.</p>
<p class="mce-root">This <kbd>runStatement</kbd> method deserves special attention because it demonstrates the power of treating computations as values. First of all, you can see that we define the computation logic in the <kbd>computation</kbd> value.</p>
<p class="mce-root">Afterwards, we check whether the <kbd>closed</kbd> flag is set. If it isn't, we return the computation as usual. However, if it is, we return an error. The error method is defined as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/3f2cdf87-1612-4ac3-a978-c1fa2f792c19.png"/></p>
<p class="mce-root">It terminates the ongoing IO computation due to a failure.</p>
<p class="mce-root"/>
<p class="mce-root">Next, let's define a few helper methods with which we are going to test our bracket primitive:</p>
<pre class="mce-root">def dbSession: IO[DBSession] = IO { new DBSession }<br/><br/>def selectUsers(db: DBSession): IO[List[String]] =<br/>  dbSession.flatMap(_.runStatement("select * from user"))</pre>
<p class="mce-root">In the preceding code, we have a function to create a database, and a function to query users from this database connection. Everything is done under the IO data type.</p>
<p class="mce-root">Next, let's create a setup that will allow us to see whether a connection was closed or not. We can do so by creating a Monadic flow under the bracket primitive, and from the flow, we are going to leak the reference to our session to a variable outside the flow that we are going to check afterward:</p>
<pre class="mce-root">var sessIntercept: DBSession = null<br/>val computation: IO[Unit] =<br/>  dbSession.bracket(sess =&gt; for {<br/>    users &lt;- selectUsers(sess)<br/><br/>    _ = println(s"Users:\n${users.mkString("\n")}")<br/>    _ = sessIntercept = sess<br/>  } yield ())(sess =&gt; IO { sess.close() })<br/><br/>println(s"Session intercept before execution: $sessIntercept")<br/>computation.unsafeRunSync<br/>println(s"Session intercept after execution: $sessIntercept")<br/>println(s"Session intercept closed status: ${sessIntercept.isClosed}")</pre>
<p class="mce-root">So, in the preceding code, we are using the bracket from the computation value. We are on the Monadic flow inside this bracket, and as a part of this Monadic flow, we are selecting the users to verify that our program works correctly. Finally, we leak the resource to a variable outside the flow. The cleanup function is defined as closing the session.</p>
<p class="mce-root"/>
<p class="mce-root">The result of running the preceding computation is as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/07d634ce-1bad-4bc0-b32a-18c7077b728a.png"/></p>
<p class="mce-root">Together with the asynchronous capabilities of IO, bracket provides you with a great primitive that can be used in an asynchronous environment where you would like to guard against memory leaks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side programming</h1>
                </header>
            
            <article>
                
<p>One large domain for applying functional programming is server-side programming. Server-side programming refers to web applications that constantly run on a server, and have the ability to communicate with the outer world. Such an application will typically listen on a port for incoming HTTP requests. After a request arrives, it will perform some work on the server, and reply back to the requesting client with the result of the computation.</p>
<p class="mce-root"/>
<p>Applications of such systems are wide. Everything from regular websites to mobile applications to <strong>Software as a Service</strong> (<strong>SaaS</strong>) <span>systems </span>are made as web applications. Also, once you have a web application that constantly runs on a server, communicates with the outer world via a well-defined protocol, and performs some computations, you can have a multitude of clients for such an application. For example, you may have an HTML-based frontend, together with a mobile application, together with integration with third-party applications via API.</p>
<p>Scala and the Cats infrastructure happens to have great support for server-side programming. They contain all the primitives that you will need to accept HTTP requests, map them to your domain model objects, communicate with the database, and reply back to the client. In this section, we will see how exactly it is done.</p>
<p>But first of all, let's get a brief overview of the general architecture of server-side applications, as well as specify the application we are going to be using as an example for this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The architecture of a server-side application</h1>
                </header>
            
            <article>
                
<p>First of all, a server application includes a server. A server is an application that will constantly run on the given machine and listen to a given HTTP port for incoming connections. The incoming connections are typically HTTP connections that follow a certain protocol.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Communication protocol</h1>
                </header>
            
            <article>
                
<p>A popular way to structure a communication protocol of a web application is to follow the RESTful paradigm of communication.</p>
<p>Since the application listens for HTTP requests, it is reasonable that these requests are made to a certain path. For example, a typical HTTP request contains the following headers:</p>
<pre>GET http://localhost:8888/order HTTP/1.0<br/>User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:39.0) Gecko/20100101 Firefox/39.0<br/>Pragma: no-cache<br/>Content-Length: 19<br/>Host: localhost:8888</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>So, as you can see, the request contains a destination string or a so-called path, together with HTTP headers. You can reason about the resources the server exposes as entities that have certain behaviors and data defined on them. The RESTful paradigm dictates that the capabilities the server side exposes via HTTP must have the paths and HTTP methods reflect the resources and their behavior that is to be performed.</p>
<p>For example, consider that you have a server that manages a forum. We will have users and forum posts. Regarding the behaviors, over time, we will want to create new posts and users, list existing posts and users, and modify and delete them.</p>
<p>These behaviors can be exposed via the HTTP RESTful API as follows:</p>
<pre>POST /user<br/>POST /post<br/>GET /user<br/>GET /post<br/>PUT /user<br/>PUT /post<br/>DELETE /user/{id}<br/>DELETE /post/{id]</pre>
<p>So, the HTTP methods reflect the nature of the behavior to be performed by the server. The paths reflect the nature of resources involved in the given behavior.</p>
<p>The client must frequently send extra information to the server. The server is supposed to reply to the client with a certain result. This request and response data must follow a certain format that is understandable to both the client and the server. Furthermore, since a web application can be exposed not only to one client but to a multitude of potential third-party clients, it is necessary that such a protocol must be standardized. The same way as the HTTP protocol is a standard protocol which a multitude of independent parties understand and implement, the same way the requests and responses protocol must also be supported by a multitude of independent parties. This is because they will need some libraries to encode and decode this request, and we do not want an overhead for them so that they can implement them themselves.</p>
<p>So, a standard way to encode the requests and responses is to use JSON or XML. In this example, we will be using JSON because it has much better support than XML in Scala. Furthermore, the Cats family of libraries includes capabilities to work with JSON easily.</p>
<p>The communication protocol is only a small part of what is involved in the server architecture. Next, we will briefly discuss which components a server is composed of.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The software architecture of a server</h1>
                </header>
            
            <article>
                
<p>The first component that any server must have is an application that is capable of listening to HTTP requests and responding to them. Such a component is called an HTTP server software. Besides that, most servers need some persistence component<span>—</span>a database. Next, the server will need a way to communicate with the database. So, we need the database access layer.</p>
<p>Finally, an orchestration solution is necessary for the preceding components to play well together, which means that we need an easy capability to bootstrap both the server and the database, and a way to define the communication between them. It is important that the orchestration is well-defined and is reproducible, with minimal setup on a variety of different environments. This is important because you do not want to write the server once for one platform and not be able to port it easily to other platforms.</p>
<p>The preceding components are the basic components for any server-side software. Of course, more complex server-side applications involve much more complex architectures; however, for the purposes of our example, this will suffice.</p>
<p>Now, let's discuss the example we are going to use to demonstrate server-side programming with the cats and Typelevel libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example specification</h1>
                </header>
            
            <article>
                
<p>The example in question will be an online store. So, we will have the entities for the customers, the goods, and we will have an ability to describe orders that the customers make.</p>
<p>We will store all of these entities in a database, and we will expose the functionality to create new users and new orders, and to list existing orders and goods via an HTTP interface.</p>
<p>Next, let's take a look at how this architecture can be put into practice. We will be discussing the architecture as a whole, and we will be introducing various functional programming libraries in the process. This will facilitate an integrated view of how server-side programming can be done with Cats.</p>
<p>Please keep in mind that we will not be going in-depth into any of the libraries we are going to discuss, as this would deserve its own book. Also, we have already mentioned that cat is on the leading edge of functional programming technology, which means that the library develops quickly, and the in-depth information that we could have covered would have become obsolete very soon. However, the general architectural principles will probably stay the same for a substantial time to come.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Orchestration and infrastructure</h1>
                </header>
            
            <article>
                
<p>First of all, we will be talking about our infrastructure and the software we will use to implement our architecture.</p>
<p>There will be two separate components to our server-side software. First of all, it is Scala-based server-side software, and second of all, it is a Postgres-based database.</p>
<p>These two components are orchestrated together via Docker.</p>
<p>Although the topics discussed in this subsection do not deal with functional programming, it is necessary to understand the big picture in order to understand which setting the functional server will operate in.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Docker</h1>
                </header>
            
            <article>
                
<p>We will define all of the components involved in other software as Docker services in a <kbd>docker-compose</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Docker-compose</h1>
                </header>
            
            <article>
                
<p>The file as a whole will look as follows:</p>
<pre>version: '3'<br/>services:<br/>  postgres:<br/>    container_name: mastering_postgres<br/>    build: postgres<br/>    ports:<br/>      - 5432:5432<br/>  backend:<br/>    container_name: mastering_backend<br/>    build: .<br/>    ports:<br/>      - 8888:8888<br/>    volumes:<br/>      - ./_volumes/ivy2:/root/.ivy2<br/>      - ./_volumes/sbt-boot:/root/.sbt/boot<br/>      - ./_volumes/coursier:/root/.cache<br/>      - .:/root/examples<br/>    environment:<br/>      - POSTGRES_HOST=postgres<br/>      - POSTGRES_PORT=5432<br/>    stdin_open: true<br/>    tty: true</pre>
<p>The file consists of two services—the Postgres service and the backend service. The Postgres service is defined as follows:</p>
<pre>postgres:<br/>  container_name: mastering_postgres<br/>  build: postgres<br/>  ports:<br/>    - 5432:5432</pre>
<p>This service defines a container named <kbd>mastering_postgres</kbd>. The <kbd>build</kbd> directive specifies that we want to build the contents of the <kbd>Postgres</kbd> folder, which is located in the current folder, to a separate Docker image. The port's directive specifies which ports the container will expose. The container in question will run the database, so we need to expose the ports that the database will be running on. Basically, it is a mapping from the ports of the container to the ports of the host machine.</p>
<p>The second service is defined as follows:</p>
<pre>backend:<br/>  container_name: mastering_backend<br/>  build: .<br/>  ports:<br/>    - 8888:8888<br/>  volumes:<br/>    - ./_volumes/ivy2:/root/.ivy2<br/>    - ./_volumes/sbt-boot:/root/.sbt/boot<br/>    - ./_volumes/coursier:/root/.cache<br/>    - .:/root/examples<br/>  environment:<br/>    - POSTGRES_HOST=postgres<br/>    - POSTGRES_PORT=5432<br/>  stdin_open: true<br/>  tty: true</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It also provides the name of its container, and it specifies that we want to build the contents of the current folder into a separate image. Docker will look for a <kbd>Dockerfile</kbd> in the provided directory and will build it into a separate image. Next, since this container will host an HTTP server, we also need to perform the port mapping so that we can listen to HTTP connection of the host machine from the container.</p>
<p>After that, we have the <kbd>volumes</kbd> array. This array specifies the directories on the local machine to be mounted to the directories on the container. In the current example, we mount a set of directories of the container that are responsible for caching. The first entry is an <kbd>ivy2</kbd> cache that is used by Scala and SBT to store their dependencies. After that, we also mount the SBT root folder, which hosts the SBT installation. Finally, we mount the cache folder, which is another location where SBT stores its dependencies.</p>
<p>We perform these mounts of the cache directories so that the container remembers what it fetched from invocation to invocation. So, you will not need to wait for the application to fetch its dependencies every time you restart the Docker container because all of the dependencies will be stored on the host machine under the directories that we have mounted.</p>
<p>Finally, we mount the current directory to the examples directory under the container. This is done so that we can access the Scala sources from the container. So, we will be able to run the application from the context of the Docker container, which means that we will be able to access all of the infrastructure defined by the <kbd>docker-compose</kbd> file.</p>
<p>Finally, we have an <kbd>environment</kbd> array. This array specifies the environmental variables set the container will be initialized with. We have the variables that specify the host and port of the Postgres database. We will use these environmental variables in the Scala sources to specify the location of the database.</p>
<p>Finally, we have two technical entries in the file:</p>
<pre>stdin_open: true<br/>tty: true</pre>
<p>These are related to the ability to access the running Docker container from the command line. So, we should be able to open a command line on a running Docker container due to these two entries. Basically, they specify how the Docker container should allocate and treat a console device. If you are interested more in this or any other of the Docker entries, please consult the Docker documentation.</p>
<p>Next, let's discuss the two Dockerfiles corresponding to the two services we have defined in <kbd>docker-compose</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dockerfiles</h1>
                </header>
            
            <article>
                
<p>Dockerfiles contain the descriptions of how a particular image must be built. We have two images: one is for the database, and the other one is for the backend. Let's start with the database image first:</p>
<pre>FROM postgres:latest<br/>ADD ./*.sql /docker-entrypoint-initdb.d/</pre>
<p>The Docker file only contains two lines of code. First of all, we inherit from an existing image of Postgres. Second, we copy all of the SQL files from the current directory to a special directory in the Docker image. This is a standard initialization procedure described in the documentation of the Postgres image we inherit from. The main idea is to initialize the database with a schema that we are going to use. Our schema is as follows:</p>
<pre>CREATE TABLE customer (<br/>  id serial NOT NULL,<br/>  "name" varchar NOT NULL,<br/>  CONSTRAINT customer_pk PRIMARY KEY (id),<br/>  CONSTRAINT customer_un UNIQUE (name)<br/>)<br/>WITH (<br/>  OIDS=FALSE<br/>) ;<br/>CREATE UNIQUE INDEX customer_name_idx ON public.customer USING btree (name) ;<br/><br/>CREATE TABLE good (<br/>  id serial NOT NULL,<br/>  "name" varchar NOT NULL,<br/>  price float4 NOT NULL,<br/>  stock int4 NOT NULL DEFAULT 0,<br/>  CONSTRAINT good_pk PRIMARY KEY (id)<br/>)<br/>WITH (<br/>  OIDS=FALSE<br/>) ;<br/><br/>CREATE TABLE "order" (<br/>  id serial NOT NULL,<br/>  customer int4 NOT NULL,<br/>  good int4 NOT NULL,<br/>  CONSTRAINT store_order_pk PRIMARY KEY (id),<br/>  CONSTRAINT order_customer_fk FOREIGN KEY (customer) REFERENCES customer(id) ON DELETE CASCADE,<br/>  CONSTRAINT order_good_fk FOREIGN KEY (good) REFERENCES good(id) ON DELETE CASCADE<br/>)<br/>WITH (<br/>  OIDS=FALSE<br/>) ;<br/><br/>INSERT INTO good (id, name, price, stock) VALUES(1, 'MacBook Pro 15''', 2500, 15);<br/>INSERT INTO good (id, name, price, stock) VALUES(2, 'iPhone 10', 1000, 10);<br/>INSERT INTO good (id, name, price, stock) VALUES(3, 'MacBook Air', 900, 3);<br/>INSERT INTO good (id, name, price, stock) VALUES(4, 'Samsung Galaxy S5', 500, 8);<br/>INSERT INTO good (id, name, price, stock) VALUES(5, 'Panasonic Camera', 120, 34);</pre>
<p>We also have three tables. First, we have a table for customers and goods. Both customers and goods have an ID that uniquely identifies them. Also, goods has some goods-specific parameters, such as the price and the stock count. Finally, we have a table that will link customers to goods as orders.</p>
<p>After that, we will populate our database with some sample goods that we are going to run our test queries on.</p>
<p>Next, let's take a look at our backend image:</p>
<pre>FROM hseeberger/scala-sbt<br/><br/>RUN mkdir -p /root/.sbt/1.0/plugins<br/>RUN echo "\<br/>addSbtPlugin(\"io.get-coursier\" % \"sbt-coursier\" % \"1.0.0-RC12-1\")\n\<br/>addSbtPlugin(\"io.spray\" % \"sbt-revolver\" % \"0.9.0\" )\n\<br/>" &gt; /root/.sbt/1.0/plugins/plugins.sbt<br/><br/>WORKDIR /root/examples</pre>
<p>The image inherits from a standard Scala SBT image so that we are going to have Scala and SBT in scope. After that, we define some SBT plugins that we are going to use. The first one is to speed up downloading the dependencies, and the second one is used to start the server in a separate JVM. We are going to start a server in a separate JVM because, in this way, we will retain the possibility to manage the server, and start and restart it from the SBT console.</p>
<p>Finally, we set the working directory to our examples directory.</p>
<p>You will find the instructions on how to run the <kbd>Dockerfile</kbd> in the <kbd>README</kbd> file of the examples repository.</p>
<p class="mce-root"/>
<p>Now that we are familiar with the architecture of the components involved, let's start by taking a more detailed look at how the backend software is constructed using Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backend architecture</h1>
                </header>
            
            <article>
                
<p>The backend is composed of three separate layers. We have a model layer for the model of our business domain, the database access later, and the server layer itself. Let's take a look at these layers in turn and see how they can be implemented with Typelevel libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model</h1>
                </header>
            
            <article>
                
<p>The model is represented by a single Scala file. It contains case classes that model our database. Notice that here, we are using plain Scala case classes without any other augmentations. If you are familiar with libraries for the Java-like Hibernate, you will know that there is an entire class of libraries for so-called <strong>object-relational mapping</strong> (<strong>ORM</strong>). These libraries intend to provide a seamless mapping of object-oriented concepts to the database schema. The main idea is to be able to manage the database, query it, and update it without the need to perform SQL statements explicitly. Such libraries aim to provide you with an object-oriented API that allows performing these operations while abstracting the underlying SQL engine.</p>
<p>Such libraries proved to be a bad idea because of the leaking abstractions. There are corner cases that these kinds of ORM libraries are not able to handle well. These libraries may not allow you to perform certain functionality that's native to a given database.</p>
<p>In modern functional programming, object-relational mapping is considered a bad practice. The current consensus seems to be that executing plain old SQL statements is the best way to model interaction with the database. So, unlike object-relational mapping libraries, we are not required to modify our domain model specifically to match the needs of the object-relational framework we are working under. We are not required to implement an interface from our model classes. We are able to define our domain model in terms of plain old case classes.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database layer</h1>
                </header>
            
            <article>
                
<p>A database layer is implemented in terms of the Doobie library. Each entity has a separate Scala file, where there is a singleton object, which has all of the methods that we need for the purposes of this application. For example, let's take a look at the API that the <kbd>customer</kbd> object exposes:</p>
<pre>object customer extends CustomerDbHelpers {<br/>  def create(c: Customer): IO[Int] = ???<br/>  def findByName(name: String): IO[Option[Customer]] = ???<br/>  def list: IO[List[Customer]] = ???<br/>  def get(id: Int): IO[Customer] = ???<br/>  def update(c: Customer): IO[Int] = ???<br/>  def delete(id: Int): IO[Int] = ???<br/>}<br/><br/>trait CustomerDbHelpers {<br/>  val selectCustomerSql = fr"select * from customer"  // to be explained further in the chapter<br/>}</pre>
<p>So, we have several database access methods, and each of them returns an IO<span>—</span><span>p</span>recisely the same IO we were learning about in the previous section. The Doobie library we are going to have a look at in this section integrates nicely with the Cats effect, and we are able to leverage the IO in order to communicate with the database.</p>
<p>Now, let's take a look at how one such method is implemented in terms of Doobie, and what the model of operation of Doobie is:</p>
<pre>def create(c: Customer): IO[Int] =<br/>  sql"""<br/>    insert into customer (name)<br/>    values (${c.name})<br/>  """<br/>  .update.withUniqueGeneratedKeys[Int]("id").transact(tr)</pre>
<p>Here, we have several things going on. First, we have an SQL statement under a string interpolator that Doobie provides. Now, in Scala, you are able to define custom string interpolators that have a form of a certain keyword, written just before the string literal. In our case, such a keyword is <kbd>sql</kbd>. The main idea of string interpolators is that, on compile time, they are going to transform a string in a certain way, possibly producing an entirely different object.</p>
<p>First, let's find out what exactly the string interpolator is doing to the string. To do so, we will consult the documentation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/81f43873-0ac5-4116-a4c7-6712015180e9.png" style="width:13.75em;height:1.75em;"/></p>
<p>So, <kbd>sql</kbd> is an alias for <kbd>fr0</kbd> and is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c438f9f5-ed8b-4bc4-8a72-c52ddc267f4c.png"/></p>
<p>This object has two methods to it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/abf5e587-0a33-4d05-bd0b-fb2e71003f30.png"/></p>
<p>Notice that one of these methods is a macro definition. The macro definition is a special method in Scala, which is invoked at compile time. It is used for metaprogramming in Scala. String interpolators are usually implemented in terms of macros.</p>
<p>Now, macro transforms a string into a <kbd>Fragment</kbd> object. A fragment is a model of an SQL statement under a string interpolator. Notice that, in the preceding screenshot, the string interpolator also gives us external variables to be used in SQL statements, as follows:</p>
<pre>values (${c.name})</pre>
<p>Interpolation is done by the dedicated Doobie macro. It interpolates the variables in a secure way so that you do not need to worry about escaping the variables that you are inserting into an SQL query<span>—</span><span>this way,</span> you don't get an SQL injection. Doobie performs the escapes for you.</p>
<p>One thing to notice about the technique employed by Doobie here is that your SQL code to interact with the database is defined as a string. However, this string is processed at compile time. This provides you with a measure of type safety and compiler assistance at compile time.</p>
<p class="mce-root"/>
<p>Now, let's take a look at the fragment definition:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/770bf606-5a06-446b-bc62-9fde80a8edb1.png"/></p>
<p>Fragment has the following API exposed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6eab09be-6bb4-45d4-b227-ef3221d25647.png"/></p>
<p>For our purposes, the following two methods are of particular importance:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/072fecec-8741-42f5-aef7-787e71b7d31e.png" style="width:42.50em;height:4.25em;"/></p>
<p>The preceding method is used for query operations, such as selecting from the database.</p>
<p><span>The following method is used for update operations, such as making modifications to the database:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1a2e3322-9895-459b-a06d-e1064a9e382f.png" style="width:46.50em;height:3.58em;"/></p>
<p>A fragment is a model of the statement that you have passed to the string interpolator. However, this model does not store the information about which exact operation you want to perform against the database. So, to specify this kind of operation, you call the <kbd>update</kbd> or <kbd>query</kbd> methods on <kbd>Fragment</kbd>. An <kbd>update</kbd> method is used for insert and update operations, and the <kbd>query</kbd> method is used for <kbd>select</kbd> operations.</p>
<p>In our example, we are calling the <kbd>update</kbd> method because we perform an insert query. Next, an <kbd>Update0</kbd> object is generated from the fragment:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4cf9f196-062f-4790-9b6b-35a083d155f1.png"/></p>
<p>It exposes the following API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0ec0d938-de5c-41ec-a42f-9540ea301778.png"/></p>
<p>Note that its API is divided into two sections. First, there is the diagnostics section. Since Doobie constructs an internal model of your query, it allows you to run certain tests on it to check whether your parameters passed to the query are of correct types and whether the query itself is composed correctly. We also have the execution API. The execution API is what you use in order to run the query.</p>
<p>Notice that all of the methods from the execution category return a type under the <kbd>ConnectionIO</kbd> effect type. <kbd>ConnectionIO</kbd> is essentially a so-called free object. If a fragment and <kbd>Update0</kbd> are models of the SQL query you are about to run, the free object of <kbd>ConnectionIO</kbd> models the precise steps the program needs to take against the database to run this query. The free object is a concept that comes from abstract algebra. Essentially, the idea is to model the computation under the free object without actually running it. The idea is precisely the same as with the IO effect type that we looked at in the previous section. That type is also a free object.</p>
<p>Notice that we are calling the <kbd>UniqueGeneratedKeys</kbd> method in our example. The method is aware that the underlying database will generate a primary key for the insert operation we are about to perform. In our case, the primary key is an integer, and we are passing a type parameter of integer to the method.</p>
<p>If you have a look at the <kbd>ConnectionIO</kbd> definition, you will see that it is a <kbd>Free</kbd> Monad:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/47d743ae-9497-4e10-baf5-df4e81da8e22.png" style="width:24.42em;height:2.00em;"/></p>
<p>So, the underlying implementation of DB operations is done using the free Monad library, which is also a part of the Cats infrastructure. As we have previously said, we will not go into detail about these auxiliary libraries and ideas since, by themselves, they deserve a separate book. So, here, the main catch to make is that the Doobie library starts from constructing a model of your SQL query and provides you with an API to gradually transform it into the model of the computation to be performed against your database. Everywhere, the paradigm of computation as a value is maintained, and nothing is run until explicitly instructed to.</p>
<p>We are able to run the <kbd>ConnectionIO</kbd> under the given effect type using the <kbd>transact</kbd> operation on it. This operation is injected via a Rich Wrapper, which is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/25bb8703-cbed-40d3-8de5-6ff523ca346d.png" style="width:25.92em;height:9.08em;"/></p>
<p>The following constructor is used to construct the wrapper:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/836cd659-1ef3-4859-8013-79eb3bc9fc82.png" style="width:41.25em;height:4.58em;"/></p>
<p>It exposes only a single method:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f9d8c294-10b2-49e9-aebd-7788738616ac.png" style="width:44.67em;height:1.75em;"/></p>
<p>Essentially, the method is tasked by running the computation under a certain effect type when given a transactor for the database. Now, the transactor for the database is a driver that knows how to communicate with the underlying database. Notice that so far, Doobie exposes the database-independent API, which is expected of this kind of library. So, the information that is database-specific is stored under the <kbd>Transactor</kbd> object, which must be implemented for your database in order for you to run database queries against that database.</p>
<p>Also notice that the effect type that we are passing to the <kbd>transact</kbd> method has a type parameter. This parameter specifies the effect type under which we are going to run our computation. Remember that <kbd>ConnectionIO</kbd> is just a description of the computation to be performed. In order to perform it, we need to specify which effect type we are going to perform it under.</p>
<p>In our example, we are using the <kbd>tr</kbd> variable as the transactor. So, let's take a look at how it is defined to understand the semantics of our example:</p>
<pre>implicit lazy val tr: Transactor[IO] =<br/> Transactor.fromDriverManager[IO](<br/> "org.postgresql.Driver"<br/> , s"jdbc:postgresql://${sys.env("POSTGRES_HOST")}:${sys.env("POSTGRES_PORT")}/postgres"<br/> , "postgres", "")</pre>
<p>Here, we are using the built-in Doobie method to construct the transactor, given the full class name of the database driver for the database that we are going to use. In our case, we are using Postgres, and we are passing the fully qualified name of the Postgres driver to the driver manager construction API.</p>
<p class="mce-root"/>
<p>The next argument to the driver manager construction method is the address of the database we are going to connect to. Here, we are connecting to a Postgres database, and we are reading its host and port from the environmental variables. Remember that, when we were discussing the Docker orchestration of the backend and the database, we discussed that the backend has environmental variables populated from the <kbd>docker-compose</kbd> file. These variables specify where the database resides for the backend to connect to it.</p>
<p>After the connection string, we have a login and password for the database. In our case, login and password are standard connection strings for the Docker Postgres image that we are using.</p>
<p>Also, notice that our transactor is constructed for the effects type of IO. This means that when we are going to run the query against this transactor, the result will be an IO.</p>
<p>Let's recall what IO is. It is a description of the computation to take place. However, <kbd>ConnectionIO</kbd> is also a description of a computation that is going to take place. So, when we are executing the <kbd>transact</kbd> statement on the <kbd>ConnectionIO</kbd>, we are not actually running it as a computation but translating it from one free language to another. We are translating it from <kbd>ConnectionIO</kbd> to IO. This kind of translation from one free language to another is quite common in purely functional programming. A useful intuition for when it may be useful may be that of high-level programming languages versus low-level programming languages. When you compile a language such as Scala or Java, a translation happens from the high-level language to the low-level language of the bytecode.</p>
<p>For humans, it is more convenient to program in a high-level language, but for the machines, it is more convenient to consume a low-level language. Hence, before we actually run the program, we must first translate it from a high-level language to a low-level language.</p>
<p>Something along these lines can also be said about translating from one free effect type to another free effect type. Essentially, when aiming to specify all of our computations as values, we will sooner or later encounter a situation when certain tasks can be easily described using one, higher level language. However, it is more convenient to run them when they are expressed in a lower level language. So, the translation takes place from a higher level language to a lower level language.</p>
<p>In our example, we are performing their translation from <kbd>ConnectionIO</kbd>, which is a domain-specific language for describing interactions with a database, to the IO language, which is a general purpose low-level language that can describe any input-output operation.</p>
<p class="mce-root"/>
<p>Therefore, our create method of the <kbd>customer</kbd> object outputs as IO, which we can later run when we need their results.</p>
<p>Now, let's take a look at the additional methods that we have already mentioned are members of the <kbd>customer</kbd> object. First of all, let's take a look at the <kbd>list</kbd> method that is supposed to list all of the customers that are present in the database:</p>
<pre class="mce-root">def list: IO[List[Customer]] =<br/>  selectCustomerSql.query[Customer].to[List].transact(tr)</pre>
<p>The <kbd>selectCustomerSql</kbd> variable is defined as follows:</p>
<pre>val selectCustomerSql = fr"select * from customer"</pre>
<p>We define this query in a separate variable since we are going to reuse it in other queries, as we will see a little bit later. Notice how we are using the other string interpolators that are available as part of Doobie:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2cc07c35-73d0-4d5d-a879-d355063a882c.png"/></p>
<p>As you can see from the documentation, Doobie provides you with several ways to specify fragments as string interpolators. The main difference is whether or not they have a trailing whitespace after them. Such a trailing whitespace may be very useful if you want to compose your fragments with other fragments later. To make sure that you don't need to worry about the separating two fragments you are going to concatenate with a whitespace, there is a default string interpolator which injects the white space for <span>you</span>. We will see how this is useful later.</p>
<p>Returning to our <kbd>list</kbd> example, as you can see, we are running the query method on a fragment. This is to be contrasted with the <kbd>update</kbd> method on the <kbd>create</kbd> method of the <kbd>customer</kbd> object. We are performing a <kbd>select</kbd> query, and so we are going to run the <kbd>query</kbd> method.</p>
<p class="mce-root"/>
<p>The method generates a <kbd>Query</kbd> object. An interesting thing to notice here is that Doobie can automatically convert the result from the raw data returned from the database to the data type of your choice. So, we provide the <kbd>Customer</kbd> type as the type parameter to the query, and Doobie is able to automatically infer a way to convert the results to this type. In general, such conversions are supported out of the box for case classes, tuples, and primitive types. This is accomplished at compile time metaprogramming, via macros and type-level computations. This useful feature from Doobie places allows it to pose a direct competition to traditional object-relational mapping libraries because you are able to map your results to your domain model at no additional cost.</p>
<p>The <kbd>Query0</kbd> object produced by the <kbd>query</kbd> method is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/781e4d0b-8ecd-458a-b1cf-7767c2c5e8ea.png"/></p>
<p>Let's take a look at its API. It consists of two parts we are interested in. First, the <span class="packt_screen">Diagnostics</span> part:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0c6047c-4807-4cb2-a191-487163ac3e62.png"/></p>
<p class="mce-root"/>
<p>Next, the <span class="packt_screen">Results</span> part:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5d5879ce-e5d7-437a-a542-9525c01432c6.png"/></p>
<p>As with the case of <kbd>Update</kbd>, the API is separated into diagnostics and results sections. It is the results section that is most interesting to us here. Notice that it contains various methods specifying which kind of result you are expecting to retrieve from your database query. For example, the <kbd>option</kbd> method is to be called when you expect that the query may be returned empty. The <kbd>unique</kbd> method is to be called when you expect one and only one result from the query. Finally, the <kbd>to</kbd> method is to be called whenever you would like to convert your result to some collection. Actually, as you can see, there is no restriction that you can only build a collection from the given result here. As long as your result type conforms to the <kbd>F[_]</kbd> type form, you should be able to build whatever you want, provided that you have a type class this method implicitly depends on. Most frequently, this method is used to create collections from the database.</p>
<p>Other methods for this API can also be used for other types of the results. However, for the purpose of this tutorial, these three will suffice.</p>
<p>Returning to our list example, we are calling the <kbd>to</kbd> method on it to produce a list of all of the customers. As a result, we are getting a <kbd>ConnectionIO</kbd> type, which we have already discussed. We then run it against our transactor, like we did previously.</p>
<p class="mce-root"/>
<p>Now, let's take a look at the <kbd>get</kbd> method of the <kbd>Customer</kbd> object:</p>
<pre>def get(id: Int): IO[Customer] =<br/>  (selectCustomerSql ++ sql"where id = $id")<br/>    .query[Customer].unique.transact(tr)</pre>
<p>The first thing to notice here is that we are performing fragment concatenation. So, the query to select the customers from the database remains the same. However, we are using the concatenation method defined on <kbd>Fragment</kbd> to concatenate it with another fragment and produce a compound fragment. The concatenation method is defined on the fragment as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b43747e3-3a49-4b8e-8923-ebcf38b7afde.png" style="width:31.25em;height:3.58em;"/></p>
<p>Notice that the trailing white space on the left-hand <kbd>Fragment</kbd> comes in handy here. Remember that we have discussed that the <kbd>selectCustomerSql</kbd> fragment is constructed with a strength interpolator that injects a trailing whitespace into the resulting fragment. This is useful precisely for these concatenation situations where we need to concatenate two fragments sequentially. Notice that we do not need to prepend a white space to the second fragment with the filter condition because the first fragment is already built with concatenation in mind.</p>
<p>After that, we run the <kbd>query</kbd> method similarly to the way we did in the example of listing all customers. However, here, we are only expecting one customer. Hence, we will call the <kbd>unique</kbd> method on the query object. Finally, we will call the <kbd>transact</kbd> method to convert the <kbd>ConnectionIO</kbd> to <kbd>IO</kbd>.</p>
<p>Next, let's take a look at the <kbd>findByName</kbd> method:</p>
<pre>def findByName(name: String): IO[Option[Customer]] =<br/>  (selectCustomerSql ++ sql"""where name = $name""")<br/>    .query[Customer].option.transact(tr)</pre>
<p>This method performs a lookup of customers by name. Notice that it is defined very similarly to getting a customer by ID. However, we are not calling the <kbd>unique</kbd> method on the query object, but the <kbd>option</kbd> method. This is because we built the method with the possibility of an empty query result in mind. Whenever we request a user by ID, we are assuming that the user with the given ID exists in the database, at least for the purposes of this example. However, when we are looking up a user in the database, we assume that the user with a given name might not exist.</p>
<p>Hence, our <kbd>findByName</kbd> method returns an <kbd>Option[Customer]</kbd>.</p>
<p>Two final methods that we are going to discuss are the <kbd>update</kbd> and <kbd>delete</kbd> methods:</p>
<pre>def update(c: Customer): IO[Int] =<br/>  sql"""<br/>    update customer set<br/>      name = ${c.name}<br/>    where id = ${c.id}<br/>  """<br/>  .update.run.transact(tr)<br/><br/>def delete(id: Int): IO[Int] =<br/>  sql"""delete from customer where id = $id"""<br/>    .update.run.transact(tr)</pre>
<p>These methods bring nothing new in terms of the Doobie API and are constructed using the API, which we have already learned about.</p>
<p>Now, let 's see how this example works against a live database. To test this example, we will use the following application:</p>
<pre>val customersTest: IO[Unit] = for {<br/>  id1 &lt;- customer.create(Customer(name = "John Smith"))<br/>  id2 &lt;- customer.create(Customer(name = "Ann Watson"))<br/><br/>  _ = println(s"Looking up customers by name")<br/>  c1 &lt;- customer.findByName("John Smith")<br/>  _ = println(c1)<br/>  c2 &lt;- customer.findByName("Foo")<br/>  _ = println(c2)<br/><br/>  _ = println("\nAll customers")<br/>  cs &lt;- customer.list<br/>  _ = println(cs.mkString("\n"))<br/><br/>  _ = println(s"\nCustomer with id $id1")<br/>  c3 &lt;- customer.get(id1)<br/>  _ = println(c3)<br/><br/>  _ = println(s"\nUpdate customer with id $id1")<br/>  r &lt;- customer.update(c3.copy(name = "Bob"))<br/>  _ = println(s"Rows affected: $r")<br/>  c4 &lt;- customer.get(id1)<br/>  _ = println(s"Updated customer: $c4")<br/><br/>  _ = println(s"\nClean-up: remove all customers")<br/>  _ &lt;- List(id1, id2).traverse(customer.delete)<br/>  cx &lt;- customer.list<br/>  _ = println(s"Customers table after clean-up: $cx") <br/>} yield ()<br/><br/>customersTest.unsafeRunSync()</pre>
<p>The preceding application tests all of the methods that we have discussed so far. First, we create a few customers to work with. Then, we test lookup by name. After that, we test the listing of all customers in the database. After that, we test getting a customer by ID. Finally, we test the <kbd>update</kbd> and <kbd>delete</kbd> operations on the customers. The result of running the preceding application is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b35e16d4-4f96-4b6b-b7d4-f0a42259841f.png"/></p>
<p>Besides the methods for the customers, we will also need methods that define how to work with the goods. So, we will need a method to create a good, and we can define it as follows:</p>
<pre>def create(c: Good): IO[Int] =<br/>  sql"""<br/>    insert into good (<br/>      name<br/>    , price<br/>    , stock)<br/>    values (<br/>      ${c.name}<br/>    , ${c.price}<br/>    , ${c.stock})<br/>  """<br/>  .update.withUniqueGeneratedKeys[Int]("id").transact(tr)</pre>
<p>We will need methods to query the goods table, too:</p>
<pre>val selectGoodSql = fr"select * from good"<br/><br/>def findByName(name: String): IO[Option[Good]] =<br/>  (selectGoodSql ++ sql"""where name = $name""")<br/>    .query[Good].option.transact(tr)<br/><br/>def list: IO[List[Good]] =<br/>  selectGoodSql.query[Good].to[List].transact(tr)<br/><br/>def get(id: Int): IO[Good] =<br/>  (selectGoodSql ++ sql"where id = $id")<br/>    .query[Good].unique.transact(tr)</pre>
<p>Finally, we will need <kbd>update</kbd> and <kbd>delete</kbd> methods to modify the database:</p>
<pre>def update(c: Good): IO[Int] =<br/>  sql"""<br/>    update good set<br/>      name = ${c.name }<br/>    , price = ${c.price}<br/>    , stock = ${c.stock}<br/>    where id = ${c.id}<br/>  """<br/>  .update.run.transact(tr)<br/><br/>def delete(id: Int): IO[Int] =<br/>  sql"""delete from good where id = $id"""<br/>    .update.run.transact(tr)</pre>
<p>We also need a database access object for the orders so that we can modify and list them. We will need the following method defined on the order object:</p>
<pre>object order extends OrderDbHelpers {<br/>  def create(o: Order): IO[Int] =<br/>    sql"""<br/>      insert into "order" (customer, good)<br/>      values (${o.customer}, ${o.good})<br/>    """<br/>    .update.withUniqueGeneratedKeys[Int]("id").transact(tr)<br/><br/>  def list: IO[List[Order]] =<br/>    selectOrderSql.query[Order].to[List].transact(tr)<br/><br/>  def get(id: Int): IO[Order] =<br/>    (selectOrderSql ++ sql"where id = $id")<br/>      .query[Order].unique.transact(tr)<br/>}<br/><br/>trait OrderDbHelpers {<br/>  val selectOrderSql = fr"""select * from "order""""<br/>}</pre>
<p>Since these methods do not introduce any new functionality and only demonstrate the use of what we have learned of Doobie so far, we will not go into detail regarding these methods.</p>
<p>Next, we will see how server-side programming can be performed with purely functional style, and how it can leverage the database objects we have defined so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side programming</h1>
                </header>
            
            <article>
                
<p>For the purposes of server-side programming, we will be using libraries called <kbd>HTTP4S</kbd> and <kbd>Circe</kbd>. <kbd>HTTP4S</kbd> is a library with which you can bootstrap an HTTP server, accept requests, and define how to respond to them. <kbd>Circe</kbd> is a library with which you can convert JSON strings to domain objects.</p>
<p><kbd>HTTP4S</kbd> leverages IO under the hood so that it can be nicely integrated into our existing database infrastructure that outputs IO, as well as so that we can be sure that our server runs asynchronously. <kbd>Circe</kbd> uses a technique of compile-time programming via macros (which we have already discussed briefly) to define how to convert JSON strings into Scala case classes or traits.</p>
<p>We are going to bootstrap our server as follows:</p>
<pre>BlazeBuilder[IO]<br/>  .bindHttp(8888, "0.0.0.0")<br/>  .mountService(all, "/")<br/>  .serve.compile.drain.unsafeRunSync()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Under the hood, <kbd>HTTP4S</kbd> relies on the other library for server-side programming, that is, the <kbd>Blaze</kbd> library. As we have already mentioned, the infrastructure for server-side programming involves a wide range of various libraries, so the gist to capture here is the big picture of how server-side programming is done.</p>
<p>We are calling several configuration methods on the <kbd>BlazeBuilder</kbd> object. The <kbd>bindHttp</kbd> method specifies which host and port we are going to listen to. In this case, the host is set to <kbd>localhost</kbd> or <kbd>0.0.0.0</kbd>, and the port is set to <kbd>8888</kbd>.</p>
<p>Next, we define the handlers that the server will use. This is done by the <kbd>mountService</kbd> method. In this case, we bind a single handler, <kbd>all</kbd>, to the root path of this server. The <kbd>all</kbd> handler is a handler we are about to define.</p>
<p>When we are done configuring the server, we will call the <kbd>serve</kbd> method on it. The method returns a Stream which is a member of another library that is a part of the Cats infrastructure. The library is called FS2 (for Functional Streams) and is a dedicated library for working with Streams in a functional way. The Stream is lazily evaluated,  and in order to run it under IO, we are going to run the compile and drain methods on this Stream. The gist of this method is that it is going to run a lazy, side-effecting Stream, under the effects type of IO. The IO is returned from the drain method. Next, we run the IO using the <kbd>unsafeRunSync</kbd> method.</p>
<p>So, as you can see, quite a lot of libraries are involved in bootstrapping an HTTP server in functional programming. However, the central idea is the same across all of these libraries. They all leverage the same effect type, IO, and they all subscribe to the idea of lazily evaluated, referentially transparent computations as values. This means that no computation is run by default; they all are stored as descriptions of computations. Since every library has its own domain, some libraries might have their own language to describe their computations. However, these domain-specific languages are ultimately translated into the single, low-level IO language.</p>
<p>If you are interested in understanding what is going on here in more detail, the best way to do so is to examine the Scala API documentation for the libraries that we have mentioned. Examining the methods that you are calling, the types that they are returning, and understanding the meaning of the methods and the types in question can get you a long way in understanding what is going on inside this library.</p>
<p>Next, we will take a look at how the handlers for the web server are defined.</p>
<p>The <kbd>all</kbd> handler is defined as follows:</p>
<pre>def all = (<br/>    createCustomer<br/>&lt;+&gt; placeOrder<br/>&lt;+&gt; listOrders<br/>&lt;+&gt; listGoods)</pre>
<p>This is a combination of several other handlers. The technique to be noted here is composability. So, we are capable of composing the other handlers with the help of the composition operator.</p>
<p>The composition in question is an <kbd>or</kbd> composition, which means that incoming requests will be checked against every handler specified by the composition operator in turn. The first handler that is capable of handling the request will be used. The individual handlers that compose the whole <kbd>all</kbd> handler are as follows:</p>
<pre>def createCustomer = HttpService[IO] {<br/>  case req @ POST -&gt; Root / "customer" =&gt;<br/>    for {<br/>      reqBody &lt;- req.as[Customer]<br/>      id &lt;- db.customer.create(reqBody)<br/>      resp &lt;- Ok(success(id.toString))<br/>    } yield resp<br/>  }</pre>
<p>We will create our new customer handler with the help of the <kbd>HttpService</kbd> object. The method we are calling is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e3f87af-eec2-437e-b9d0-24d8112ed349.png" style="width:43.50em;height:5.92em;"/></p>
<p>It takes a partial function that maps a request to a response under an effect type <kbd>F</kbd>. A request contains what you would expect a request to have. Here is a definition and some of the API methods that it exposes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18b6e019-d271-4815-9585-cd59bce53628.png" style="width:48.17em;height:7.83em;"/></p>
<p class="mce-root"/>
<p>It exposes the following API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e6bb790-b11f-4f15-ab34-c7b736fd6167.png"/></p>
<p>The partial function passed into the request returns a response under an effect type. Currently, the only supported effect type is IO. The fact that it returns the response under an effect type means that the server is built with asynchrony in mind.</p>
<p>A handler constructed this way will match any incoming request against the partial function.</p>
<p>The <kbd>HttpService</kbd> constructed by the call is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae184c6b-9d91-4688-ac2f-78a4702bcdf3.png" style="width:45.08em;height:4.75em;"/></p>
<p>It is an alias for the <kbd>Kleisli</kbd> type. <kbd>Kleisli</kbd> is a part of the <kbd>cats</kbd> core library and is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/62090901-0506-4e45-b694-3e9d92ee6420.png" style="width:47.25em;height:10.33em;"/></p>
<p>So, essentially, it is nothing more than a function you would pass to, say, the <kbd>flatMap</kbd> method. It is a function of the following kind:</p>
<pre>A ⇒ F[B]</pre>
<p>The partial function we are using to construct the handler does a few things here. First of all, notice that there's a DSL to conveniently extract the HTTP method and a path from the request. These extractors come from the <kbd>HTTP4S</kbd> API and can be used to match on requests conveniently.</p>
<p>Next, we are starting a Monadic flow over IO:</p>
<pre>reqBody &lt;- req.as[Customer]</pre>
<p>The <kbd>as</kbd> call is supposed to extract the <kbd>Customer</kbd> object from the incoming request body. The assumption is made that the body is a valid JSON string, and the <kbd>Circe</kbd> library will be used under the hood to convert the incoming request body to the requested data type. You do not need to perform any other specifications of how exactly a JSON must be converted to a case class, as <kbd>Circe</kbd> defines how to do that under the hood.</p>
<p>The next thing that we do is we create a customer in the database. We are using the database access object that we defined previously in this section to do this. As a result, we get the ID of a newly created customer.</p>
<p>Finally, we construct the response to our query:</p>
<pre>resp &lt;- Ok(success(id.toString))</pre>
<p>We are using the call to the <kbd>Ok</kbd> method to define the <kbd>Ok</kbd> response code <kbd>200</kbd>. <kbd>Ok</kbd> is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ac62b2a5-d356-482b-b2d4-56cbdeed2d88.png" style="width:11.08em;height:2.50em;"/></p>
<p><kbd>Status</kbd> is an abstract class that does not have an <kbd>apply</kbd> method, which is necessary for the object to be callable. So, we should not be able to call it. The reason we are able to call it in our program is because the method is injected into the <kbd>Ok</kbd> object via the following Rich Wrapper:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ab064298-efbc-4a60-a2e2-3e4eea60c613.png" style="width:39.75em;height:8.08em;"/></p>
<p>It exposes the following API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6b18ddcf-459e-4802-922a-b7928a55689b.png"/></p>
<p>This wrapper is parametrized by an effect type under which the response is computed and returned. Currently, <kbd>HTTP4S</kbd> only supports the IO effect type, but this is not a problem since all of the other libraries of Typelevel infrastructure also speak the language of IO.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Notice that we specify a <kbd>payload</kbd> for the response. It is specified with the <kbd>success</kbd> method, which is defined as follows:</p>
<pre>def success[T](payload: T): Map[String, T] =<br/>  Map("success" -&gt; payload)</pre>
<p>So, the payload is set to an ordinary Scala, <kbd>Map[String, Int]</kbd> (Int is inferred because the argument to <kbd>success</kbd> is an integer). Since we are using <kbd>Circe</kbd>, this Scala collection will be automatically encoded into JSON and returned to the requesting client. Again, this is provided out of the box at no additional cost.</p>
<p>Next, the <kbd>placeOrder</kbd> handler is defined as follows:</p>
<pre>def placeOrder = HttpService[IO] {<br/>  case req @ POST -&gt; Root / "order" =&gt;<br/>    for {<br/>      cookieHeader &lt;-<br/>        headers.Cookie.from(req.headers).map(IO.pure).getOrElse(<br/>          IO.raiseError(noAuthCookieError))<br/>      jsonBody &lt;- req.as[Map[String, Int]]<br/>      cookie &lt;- cookieHeader.values.toList<br/>        .find(_.name == "shop_customer_id").map(IO.pure).getOrElse(<br/>          IO.raiseError(noAuthCookieError))<br/>      uId = cookie.content<br/><br/>      oId &lt;- db.order.create(Order(good = jsonBody("good"), customer = uId.toInt))<br/>      order &lt;- db.order.get(oId)<br/>      resp &lt;- Ok(success(order))<br/>    } yield resp<br/>}</pre>
<p>It largely uses the functionality that we have already discussed. However, a few remarks should be made:</p>
<pre>cookieHeader &lt;-<br/>  headers.Cookie.from(req.headers).map(IO.pure).getOrElse(<br/>    IO.raiseError(noAuthCookieError))</pre>
<p>First of all, <kbd>HTTP4S</kbd> provides the capability to extract various parameters from requests, such as cookies. In the preceding code, we extract the cookie header from all of the request headers. If the operation was not successful, we would raise an error via an <kbd>IO</kbd> method. Essentially, rising an error from IO gets the entire Monadic flow short-circuited. This is similar to throwing an exception from imperative code, except that the IO effect type will take care of error handling:</p>
<pre>jsonBody &lt;- req.as[Map[String, Int]]</pre>
<p>In the preceding line, notice how we are able to extract the JSON body of the incoming request as a Scala map. So, not only the primitive types and case classes are supported by <kbd>Circe</kbd>, but also the Scala collection types. <kbd>Circe</kbd> automatically derives encoders and decoders for JSON on compile time:</p>
<pre>resp &lt;- Ok(success(order))</pre>
<p>Notice that the preceding response sets the entire case class as its payload. We are returning a case class that's nested inside a Scala map. <kbd>Circe</kbd> is able to encode this data structure into JSON seamlessly.</p>
<p>Finally, two list handlers are defined as follows:</p>
<pre>def listOrders = HttpService[IO] {<br/>  case req @ GET -&gt; Root / "order" =&gt;<br/>    db.order.list.flatMap(Ok(_))<br/>}<br/><br/>def listGoods = HttpService[IO] {<br/>  case req @ GET -&gt; Root / "good" =&gt;<br/>    db.good.list.flatMap(Ok(_))<br/>}</pre>
<p>Since our database returns the result in IO and since we are using <kbd>Circe</kbd> to encode the model objects into JSON automatically, we can <kbd>flatMap</kbd> the response from the database to wrap it into the response status code. We are able to specify this entire handler as a thin wrapper on top of a database access method in just one line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying the server</h1>
                </header>
            
            <article>
                
<p>In the example repository, there is a shell script that you can use to query the server once you start it. You can start the server with the following command from the SBT console:</p>
<pre><strong>reStart</strong></pre>
<p>Notice that this command must be run under the Docker image. So, it will not work if you just run an SBT console on your machine from the example repository; you will need first to run the Docker image, then run the command from the SBT console that is started on that Docker image.</p>
<p>After that, you can use the client shell script to query the database server. For example, we can create the new customer as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c7932d1-7da4-4e9e-8521-67f1977287c3.png"/></p>
<p>Notice how the response is a nicely formatted JSON with an ID of the created customer.</p>
<p class="mce-root"/>
<p>Next, we can list all of the goods that are present in the database so that we can place an order:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9ad70984-cf8f-4312-b97a-0709089576c9.png"/></p>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>So, we got a JSON array of all the goods as the response. We can place an order as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1c5d0905-7e09-4d31-b46f-d621609dac43.png"/></p>
<p class="mce-root"/>
<p>And finally, we can list all of the orders to confirm that we have the order in the database:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b69642e6-4426-49c6-b3da-6bafa2b13682.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered the broad infrastructure that the Typelevel umbrella of libraries provides for purely functional programming. First, we learned the foundation for asynchronous programming with Cats, that is, the Cats effect library. We discussed the <kbd>IO</kbd> concurrency primitive and the philosophy of computations as values. After that, we learned the foundations for the server-side programming, which involves a range of libraries. The libraries in question were responsible for HTTP request handling and database access, while utilizing a JSON conversion library under the hood. We have had a birds-eye overview of what programming with these may look like.</p>
<p>By now, we have covered enough of material for us to start writing industrial software in a purely functional way. In the next chapter, we will see more advanced patterns of functional programming. These patterns will help our architectures solve broader range of problems and make them more flexible.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Explain the difference between blocking and non-blocking programming.</li>
<li>Why is asynchronous programming mandatory for high-load systems?</li>
<li>How does computation as a value approach benefit concurrent programming?</li>
<li>What is an <kbd>IO</kbd> effect type?</li>
<li>What capabilities for asynchronous programming does <kbd>IO</kbd> expose?</li>
</ol>


            </article>

            
        </section>
    </body></html>