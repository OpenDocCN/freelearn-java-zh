- en: Creating Your First Java Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个Java模块
- en: 'In the previous chapter, we took a detailed look at the problems associated
    with modularizing Java code pre-Java 9, as well as the new module construct in
    Java 9 and *Project Jigsaw*. Before we examine how Java modularity solves these
    problems, you''ll need to first understand what a Java module looks like. In this
    chapter, you''ll create your first Java 9 module and learn what it takes to build
    and execute code in a Java module. Here are the top-level topics you''ll be learning
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细探讨了Java 9之前模块化Java代码时遇到的问题，以及Java 9中的新模块构造和*Project Jigsaw*。在我们检查Java模块化如何解决这些问题之前，您首先需要了解Java模块的外观。在本章中，您将创建您的第一个Java
    9模块，并学习在Java模块中构建和执行代码所需的内容。以下是本章您将学习的顶级主题：
- en: Setting up the JDK with Java 9
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Java 9的JDK
- en: Creating a new Java 9 module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Java 9模块
- en: Defining a module (using `module-info.java`)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块（使用`module-info.java`）
- en: Compiling and executing a module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和执行模块
- en: Handling possible errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可能的错误
- en: You'll be building a sample Java 9 application throughout this book as you learn
    the different concepts related to modularity. The application you'll build is
    an address book viewer application that displays some contacts sorted by last
    name. We'll start simple and enhance this application as we go. When you are done
    with this chapter, you'll have built your first Java 9 module and learned how
    to compile and execute it. Let's start by first installing the JDK.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习与模块化相关的不同概念的过程中，您将在这本书中构建一个示例Java 9应用程序。您将构建的应用程序是一个地址簿查看器应用程序，它按姓氏排序显示一些联系人。我们将从简单开始，并在进行中增强此应用程序。完成本章后，您将构建您的第一个Java
    9模块，并学习如何编译和执行它。让我们首先安装JDK。
- en: Setting up the JDK
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JDK
- en: 'In order to write Java 9 code, you''ll first need to download and install the
    Java 9 SDK (referred to as the Java Development Kit or JDK). In this book, we''ll
    be using the **OpenJDK** build available at [http://jdk.java.net/9/](http://jdk.java.net/9/).
    When you navigate to the URL, you''ll see a list of available downloads based
    on the platform you are using, as shown here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写Java 9代码，您首先需要下载并安装Java 9 SDK（称为Java开发工具包或JDK）。在这本书中，我们将使用位于[http://jdk.java.net/9/](http://jdk.java.net/9/)的**OpenJDK**构建。当您导航到该URL时，您将看到基于您所使用的平台提供的可用下载列表，如下所示：
- en: '![](img/00013.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: 'Make sure you choose the download for your platform in the **JDK** column,
    not the **JRE** column. After accepting the license agreement, you should be able
    to download an installer for your platform. Run the installer and choose the defaults;
    after this, you should have JDK 9 installed in your machine:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在**JDK**列中选择适合您平台的下载，而不是**JRE**列。接受许可协议后，您应该能够下载适合您平台的安装程序。运行安装程序并选择默认选项；之后，您应该在您的机器上安装了JDK
    9：
- en: '![](img/00014.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: 'After the installation is complete, it''s a good idea to verify that the JDK
    installation and configuration process completed successfully. You do that by
    opening a **Command Prompt** or terminal window. Type the command `java -version`
    to output the version of the `java` command currently in the `PATH`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，验证JDK安装和配置过程是否成功完成是个好主意。您可以通过打开**命令提示符**或终端窗口来完成此操作。输入命令`java -version`以输出当前`PATH`中`java`命令的版本：
- en: Note that the installer adds the location of the installed Java binaries to
    your system `PATH` variable, which is why this command works.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，安装程序会将已安装的Java二进制文件的路径添加到您的系统`PATH`变量中，这就是为什么这个命令可以工作。
- en: '![](img/00015.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: Additionally, you can also make sure that the `JAVA_HOME` value is set.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保已设置`JAVA_HOME`值。
- en: 'On macOS/Linux, type the command `echo $JAVA_HOME` and make sure the path to
    the JDK 9 installation is returned:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS/Linux上，输入命令`echo $JAVA_HOME`并确保返回的是JDK 9安装路径：
- en: '![](img/00016.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: On Windows, right-click on My Computer, click Properties, and switch to the
    Advanced tab. Here, click Environment Variables and view the value for the variable
    `JAVA_HOME`. It should point to the location you've chosen to install the JDK.
    For example, the location could be something like `C:\Program Files\Java\jdk9`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，右键单击“我的电脑”，点击“属性”，然后切换到“高级”选项卡。在这里，点击“环境变量”并查看变量`JAVA_HOME`的值。它应指向您选择的JDK安装位置。例如，位置可能是类似`C:\Program
    Files\Java\jdk9`的东西。
- en: With this, you've now successfully installed JDK 9 and you are all set to start
    coding in Java 9!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您现在已成功安装了JDK 9，并准备好开始用Java 9进行编码！
- en: Switching between JDKs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JDK之间切换
- en: Once you've installed a newer version of the JDK with an earlier version already
    installed, it is possible to switch what the currently selected version is.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了比已安装的早期版本更新的JDK，就可以切换当前选定的版本。
- en: On macOS and Linux, you do this by switching the value of `JAVA_HOME`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS和Linux上，你通过切换`JAVA_HOME`的值来完成此操作
- en: 'The following command switches the current Java platform to Java 8:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将当前Java平台切换到Java 8：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To switch to Java 9, use the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到Java 9，请使用以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this command, you are passing the Java version of choice to the `-v` parameter.
    But, note that the format is different between Java 8 and 9\. With Java 8, the
    version string is `1.8`. With Java 9, the version string is just `9`. Traditionally,
    Java has been using the `1.X` version format, for example, Java version 7 had
    the version string `1.7`. This is being changed from Java 9 onward. The idea is
    that subsequent releases of Java will drop the `1.X` format and just use a single
    number to denote the format. So it's Java 9, not Java 1.9.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，你正在将所选的Java版本传递给`-v`参数。但是，请注意，Java 8和9之间的格式不同。对于Java 8，版本字符串是`1.8`。对于Java
    9，版本字符串只是`9`。传统上，Java一直使用`1.X`的版本格式，例如，Java版本7的版本字符串是`1.7`。从Java 9开始，这种格式正在改变。想法是，Java的后续版本将放弃`1.X`格式，只使用一个数字来表示格式。所以是Java
    9，而不是Java 1.9。
- en: It's about time this was changed! Imagine the confusion Java 10 would have caused!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候改变这个了！想象一下Java 10会造成的混乱！
- en: On Windows, you switch JDK versions by changing the `JAVA_HOME` and `PATH` variables.
    Follow the same steps as earlier to get to the Environment Variables section.
    Update the value of `JAVA_HOME` to point to the location where the version you
    need is installed. Also, make sure the `PATH` is updated to point to the corresponding
    folder for the Java version you'd like to switch to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，通过更改`JAVA_HOME`和`PATH`变量来切换JDK版本。遵循前面的步骤进入环境变量部分。更新`JAVA_HOME`的值，使其指向所需版本安装的位置。同时，确保`PATH`已更新，以指向你想要切换到的Java版本的相应文件夹。
- en: Setting up the NetBeans IDE
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置NetBeans IDE
- en: In order to write and follow the code in this book, you don't *have* to use
    any **integrated development environments** (**IDEs**). This book will cover writing,
    compiling, and executing code manually using the command line. You can write code
    using a text editor of your choice. The code samples accompanying this book also
    work with the steps and commands showcased in this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写和遵循本书中的代码，你**不必**使用任何**集成开发环境**（**IDEs**）。本书将涵盖使用命令行手动编写、编译和执行代码。你可以使用你选择的文本编辑器编写代码。本书附带的代码示例也适用于本书中展示的步骤和命令。
- en: 'You could also follow along with an IDE. At the time of writing, NetBeans and
    IntelliJ Idea has growing support for Java modular projects, with Eclipse support
    under development. This chapter outlines the steps to create a modular project
    in NetBeans, should you choose to use the NetBeans IDE. To set it up, in addition
    to following the steps to set up Java, make sure you install the latest version
    of NetBeans with Java 9 module support by going to [https://netbeans.org/downloads/](https://netbeans.org/downloads/)
    and choosing either the Java SE or the Java EE version to download:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以跟随IDE进行操作。在撰写本文时，NetBeans和IntelliJ Idea对Java模块化项目有越来越多的支持，Eclipse的支持正在开发中。本章概述了在NetBeans中创建模块化项目的步骤，如果你选择使用NetBeans
    IDE。为了设置它，除了遵循设置Java的步骤外，请确保通过访问[https://netbeans.org/downloads/](https://netbeans.org/downloads/)并选择Java
    SE或Java EE版本进行下载来安装NetBeans的最新版本，以便支持Java 9模块：
- en: '![](img/00017.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: 'Note that if the release version of NetBeans does not yet support Java 9 when
    you read this, you might have to download an early access copy here: [http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/).
    Once you download the installer and execute it, you should have a shiny new copy
    of NetBeans on your computer ready for you to use.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在阅读此内容时，NetBeans的发布版本尚不支持Java 9，你可能必须在此处下载早期访问副本：[http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/)。一旦下载安装程序并执行它，你应该在你的计算机上有一个全新的NetBeans副本，供你使用。
- en: Most veteran Java programmers would acknowledge that it has been a while since
    they have created folder structures by hand for their Java projects. The Java
    language has benefitted from incredibly useful tooling support over the years.
    IDEs such as Eclipse, NetBeans, and IntelliJ IDEA make it such a breeze to create
    source and package folders that developers don't even tend to think about those
    aspects of code organization too often. However, in this chapter, and in fact
    in the rest of the book, we will learn how to build folders and files by hand,
    as well as compile and run the code by executing commands manually from the command
    line. This is because IDEs, as convenient as they might be, tend to hide the details
    and workings around the process of structuring and compiling code. We intend to
    examine how Java 9 modules work, and the fundamental workings of the code structure,
    as well as compiling and linking commands, are essential to mastering these concepts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数经验丰富的Java程序员都会承认，他们已经很久没有手动为Java项目创建文件夹结构了。多年来，Java语言受益于极其有用的工具支持。例如，Eclipse、NetBeans和IntelliJ
    IDEA等IDE使得创建源和包文件夹变得非常容易，以至于开发者甚至不太经常考虑代码组织的这些方面。然而，在本章中，实际上在本书的其余部分，我们将学习如何手动构建文件夹和文件，以及通过在命令行中手动执行命令来编译和运行代码。这是因为尽管IDE可能很方便，但它们往往隐藏了代码结构和编译过程的细节和运作。我们的目的是检查Java
    9模块是如何工作的，以及代码结构的基本运作，以及编译和链接命令对于掌握这些概念是至关重要的。
- en: While the prospect of writing Java code without an IDE might seem daunting,
    let me assure you that this is something you'll likely get used to very quickly.
    You'll learn the steps to build and execute modular Java 9 code in this chapter,
    and then it's just a matter of applying the same steps independent of the complexity
    of the code base itself.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在没有IDE编写Java代码的前景可能看起来令人畏惧，但请让我向您保证，这将是您很快就会习惯的事情。在本章中，您将学习构建和执行模块化Java 9代码的步骤，然后只需根据代码库本身的复杂性应用相同的步骤即可。
- en: Java 9 modules
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9模块
- en: When writing an application in Java 9, you are ideally creating a modular application.
    It's important to note that a modular Java application isn't just a regular Java
    application (like those we've been building all these years) with just an extra
    module feature thrown in. It actually calls for a completely new way of thinking
    about writing and structuring your code base. Before we get into creating Java
    9 modules, let's do a quick recap of the traditional Java code structure pre-Java
    9.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Java 9中编写应用程序时，理想情况下您正在创建一个模块化应用程序。需要注意的是，模块化Java应用程序并不仅仅是一个带有额外模块功能的常规Java应用程序（就像我们这些年一直在构建的那样），它实际上要求我们以全新的方式思考编写和结构化代码库。在我们开始创建Java
    9模块之前，让我们快速回顾一下Java 9之前的传统Java代码结构。
- en: Traditional Java code structure
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统Java代码结构
- en: 'Traditionally, writing a Java application starts with creating one or more
    source directories. These are special directories that serve two purposes--firstly,
    they act as root locations of your Java source code and secondly, the contents
    of these directories are added to the class path. So, the steps to organize source
    code have typically been:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，编写Java应用程序从创建一个或多个源目录开始。这些目录具有两个特殊目的——首先，它们是Java源代码的根位置，其次，这些目录的内容被添加到类路径中。因此，组织源代码的步骤通常如下：
- en: Create one or more source folders.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个或多个源文件夹。
- en: In a source folder, create package folders to mirror the package name.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件夹中，创建与包名相对应的包文件夹。
- en: 'Place the `.java` files in the right package folders:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.java`文件放置在正确的包文件夹中：
- en: '![](img/00018.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00018.jpeg)'
- en: 'Many Java developers use the directory structure `src/main/java` for the source
    directory. So, for example, a class `Main.java` in the package `com.acme.app`
    would have the overall path `src/main/java/com/acme/app/Main.java`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Java开发者使用`src/main/java`目录结构作为源目录。例如，包`com.acme.app`中的`Main.java`类的完整路径将是`src/main/java/com/acme/app/Main.java`：
- en: '![](img/00019.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00019.jpeg)'
- en: This is how source code in Java has typically been organized by developers for
    many years now. With Java 9 modules, there's a change in the way we approach structuring
    and writing code. Let's switch gears and examine what a module in Java 9 looks
    like.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是多年来开发者通常如何组织Java源代码的方式。随着Java 9模块的出现，我们在结构和编写代码的方式上发生了变化。让我们转换一下思路，看看Java
    9中的模块是什么样的。
- en: What is a module?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模块？
- en: The *module* is a new construct that has been introduced into the Java 9 programming
    language. Think of modules as first-class citizens and as new program components
    in the language, just like classes or packages. A Java 9 module is a named, self-describing
    collection of code and data that you can create and use in Java applications.
    A module can contain any number of Java packages that in turn contain Java code
    elements, such as classes or interfaces. A Java module can also contain files
    such as resource files or property files. An application is built by bringing
    together a collection of these modules. The analogy of building blocks applies
    well here--a module is a building block that exists on its own, but can be a part
    of a bigger whole.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**是Java 9编程语言中引入的新结构。将模块视为一等公民，以及语言中的新程序组件，就像类或包一样。Java 9模块是一个命名、自我描述的代码和数据集合，你可以在Java应用程序中创建和使用它。模块可以包含任意数量的Java包，这些包又包含Java代码元素，如类或接口。Java模块还可以包含资源文件或属性文件等文件。应用程序是通过将这些模块组合在一起来构建的。构建积木的类比在这里适用得很好——模块是一个独立的构建块，但也可以成为更大整体的一部分。'
- en: With Java 9 modular programming, we move away from building applications as
    monolithic code bases and instead look to break down the problem into modules.
    In other words, rather than having one big Java project, you create several modular
    units that work together to form an application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 9模块化编程，我们不再以单体代码库的形式构建应用程序，而是将问题分解为模块。换句话说，与其拥有一个庞大的Java项目，不如创建几个模块单元，它们共同协作形成一个应用程序。
- en: This significantly influences how you design and code your application. In Java
    8 and earlier, your design process involved breaking down the problem into classes
    and packages. In Java 9, you first break the problem down into modules. These
    modules are ideally components that are reusable with a clear interface (inputs
    and outputs) and solve a specific part of the problem. Inside each module, however,
    the process of designing and writing code is, more or less, business as usual
    with packages, classes, interfaces, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上影响了你的应用程序设计和编码方式。在Java 8及之前版本中，你的设计过程涉及将问题分解为类和包。在Java 9中，你首先将问题分解为模块。这些模块理想情况下是具有清晰接口（输入和输出）的可重用组件，解决问题的特定部分。然而，在每个模块内部，设计和编写代码的过程，或多或少，与使用包、类、接口等常规操作相同。
- en: Creating a module
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: 'Here are the steps to create a module in Java 9\. Before you start with *step
    1*, I should mention an obvious starting point--*step 0*: Know what the module''s
    purpose is. Before you begin creating a module, you should have a clear idea of
    what the module is for. Remember the important tenet of modular development here!
    Rather than having one large code base for your application, you instead break
    the problem down into reusable subprojects. Think *reusable libraries*. The main
    difference is that rather than the libraries just being separate JARs that are
    nothing more than a collection of Java packages and types, we are leveraging the
    concept of Java modules to group those packages and types:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建Java 9模块的步骤。在你开始进行**步骤1**之前，我应该提到一个明显的起点——**步骤0**：了解模块的目的。在开始创建模块之前，你应该清楚地知道模块的用途。记住模块化开发的重要原则！与其为应用程序拥有一个大的代码库，不如将问题分解为可重用的子项目。想想可重用库。主要区别在于，这些库不仅仅是作为Java包和类型的集合的独立JAR文件，我们正在利用Java模块的概念来分组这些包和类型：
- en: '**Assign a module name**: The first step to creating a module is to come up
    with a unique name for the module. The name should ideally describe what the module
    is about and the problem it solves. A Java module name should be a valid Java
    identifier, so you cannot use certain characters, such as hyphens and slashes.
    A valid package name is also a valid module name. But apart from that, any name
    will do as long as it is unique in an application. However, to avoid clashing
    names, you don''t want to call a module something very generic, such as `util`.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指定模块名称**：创建模块的第一步是为模块想出一个独特的名称。理想情况下，该名称应描述模块的内容和解决的问题。Java模块名称应是一个有效的Java标识符，因此不能使用某些字符，例如连字符和斜杠。有效的包名也是有效的模块名称。但除此之外，任何名称都可以，只要它在应用程序中是唯一的。然而，为了避免名称冲突，你不希望将模块命名为非常通用的名称，例如`util`。'
- en: The recommended practice is to use the same convention that has worked well
    all these years for package names in Java--using the reverse domain name pattern.
    It's also recommended that you use all lowercase naming for modules, just like
    packages. So, for example, if you are writing a String utilities module for Acme
    Corp, the name of the module could be something such as `com.acme.stringutil`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用多年来在Java中为包名所采用的相同约定--使用反向域名模式。还建议您使用全小写命名模块，就像包一样。例如，如果您为Acme公司编写一个字符串实用模块，模块的名称可以是`com.acme.stringutil`。
- en: '**Create a module root folder**: Every Java module resides in its own folder,
    which acts as the top-level folder for the module and contains all the assets
    of the module. This folder is called the **module root** folder. The module root
    folder has the same name as the module. So, the root folder for the aforementioned
    example module has the name `com.acme.stringutil`. It is named exactly the same
    as the module name, including the periods, if any.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建模块根文件夹**：每个Java模块都位于自己的文件夹中，该文件夹作为模块的最高级文件夹，包含所有模块资产。这个文件夹被称为**模块根**文件夹。模块根文件夹的名称与模块相同。因此，上述示例模块的根文件夹名称为`com.acme.stringutil`。它的命名与模块名称完全相同，包括任何点。'
- en: '**Add the module code**: Inside the module root folder goes the code that belongs
    to the module. This begins with packages, so you start your package folders from
    the module root folder onward. So, if your module `com.acme.stringutil` has the
    class `StringUtil.java` in the package `com.acme.util`, the folder structure should
    look like this:![](img/00020.jpeg)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加模块代码**：模块根文件夹内包含属于模块的代码。这从包开始，因此您从模块根文件夹开始创建包文件夹。所以，如果您的模块`com.acme.stringutil`在`com.acme.util`包中有`StringUtil.java`类，文件夹结构应该如下所示！[](img/00020.jpeg)'
- en: 'Note the difference in the file structure from the pre-Java 9 structure that
    we looked at before. What used to go directly into the source folders in earlier
    versions of Java now goes into the module root folder. As you can see from the
    following table, with Java 9 there''s just an additional folder level with the
    module root folders. From the module root folder onward, there''s nothing new
    in the way Java types are organized:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与之前我们查看的Java 9之前的文件结构的不同。在Java早期版本中直接放入源文件夹的内容现在放入了模块根文件夹。从下面的表格中可以看出，在Java
    9中，只是多了一个模块根文件夹的额外文件夹级别。从模块根文件夹开始，Java类型组织方式上没有新的变化：
- en: '| **The Java 8 (and earlier) way** | **The Java 9 way** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **Java 8（及之前版本）的方式** | **Java 9的方式** |'
- en: '| 1\. Create one or more source folders.2\. In a source folder, create package
    folders to mirror the package name.3\. Place the `.java` files in the right package
    folders. | 1\. Create one or more source folders.2\. In a source folder, create
    a module folder for each module.3\. In the module folders, create package folders
    to mirror the package name.4\. Place the `.java` files in the right package folders.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 1. 创建一个或多个源文件夹。2. 在源文件夹中创建包文件夹以反映包名。3. 将`.java`文件放置在正确的包文件夹中。 | 1. 创建一个或多个源文件夹。2.
    在源文件夹中为每个模块创建一个模块文件夹。3. 在模块文件夹中创建包文件夹以反映包名。4. 将`.java`文件放置在正确的包文件夹中。 |'
- en: 'Here''s a diagram representing the code structure with the modules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示模块代码结构的图示：
- en: '![](img/00021.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: '**Create and configure the module descriptor**: Here''s the final step! Every
    module comes with a file that describes it and contains metadata about the module.
    This file is called the module descriptor. This file contains information about
    the module, such as what it requires (the inputs to the module) and what the module
    exports (the outputs from the module). The module descriptor is always located
    directly at the module root folder, and it is always given the name `module-info.java`.
    That''s right! A module descriptor file is actually a `.java` file. What do the
    contents of this module descriptor file look like?'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建和配置模块描述符**：这是最后一步！每个模块都附带一个描述它的文件，并包含有关模块的元数据。这个文件被称为模块描述符。该文件包含有关模块的信息，例如它需要什么（模块的输入）以及模块导出什么（模块的输出）。模块描述符始终位于模块根目录中，并且始终命名为`module-info.java`。没错！模块描述符文件实际上是一个`.java`文件。这个模块描述符文件的内容看起来是什么样子？'
- en: 'Here is a barebones and minimal module descriptor for the example module--`com.acme.stringutil`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例模块的简单且最基础的模块描述符--`com.acme.stringutil`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The file starts with the `module` keyword followed by the module name and curly
    braces. The curly brace structure resembles other Java type declarations you should
    be familiar with. Note that the name of the module (following the `module` keyword)
    should exactly match the name of the module root folder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文件以`module`关键字开头，后面跟着模块名称和大括号。大括号结构类似于你应该熟悉的其他Java类型声明。请注意，模块的名称（在`module`关键字之后）应该与模块根文件夹的名称完全匹配。
- en: Within the curly braces, you can optionally specify the metadata (the inputs
    and outputs) of the module. In the preceding example, the module descriptor is
    essentially *empty*, with nothing between the curly braces. For any real-world
    module you create, you will more than likely add some metadata here to configure
    the behavior of the module. We'll cover this metadata in more detail in [Chapter
    3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb), *Handling Inter-Module
    Dependencies*, but what you can see in the example is the bare minimum *necessary
    and sufficient* content needed for the module descriptor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在大括号内，你可以选择性地指定模块的元数据（输入和输出）。在上面的例子中，模块描述符基本上是*空的*，大括号之间没有任何内容。对于你创建的任何实际模块，你很可能会在这里添加一些元数据来配置模块的行为。我们将在[第3章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)“处理模块间依赖”中更详细地介绍这些元数据，但你在例子中看到的是模块描述符所需的*最基本且足够*的内容。
- en: 'With the module descriptor file in the **module root**, this is the folder
    and file structure for our simple module:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块根目录中，这是我们的简单模块的文件夹和文件结构：
- en: '![](img/00022.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: 'For someone used to writing Java classes, the name of the `module-info.java`
    file might seem a bit odd at first. This is because of a couple of reasons:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于编写Java类的开发者来说，`module-info.java`文件的名称一开始可能看起来有点奇怪。这是因为几个原因：
- en: The `-` character here isn't a valid identifier to be used in a Java type name,
    and nor is it valid for the name of a `.java` file
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的`-`字符在Java类型名称中不是一个有效的标识符，也不适用于`.java`文件的名称
- en: The name of the `.java` file usually matches the name of the public type contained
    in the file, but in this case, it doesn't
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.java`文件的名称通常与文件中包含的公共类型名称相匹配，但在这个例子中并不如此'
- en: However, some Java developers might also find this familiar, having used a similar-looking
    file name that has been used in Java since Java 1.5--`package-info.java`. The
    `package-info.java` file is used to specify package-level configuration and annotations,
    and has been used for many years now, although not very widely. Both `module-info.java`
    and `package-info.java` files have intentionally been given *invalid* Java type
    names in order to convey their special meaning and purpose, and to separate them
    from the other Java types and files you'd normally create in the process of building
    your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些Java开发者可能也会觉得这个文件名很熟悉，因为自从Java 1.5以来，Java中就使用了类似外观的文件名——`package-info.java`。`package-info.java`文件用于指定包级别的配置和注解，并且已经使用了多年，尽管并不广泛。`module-info.java`和`package-info.java`文件都故意被赋予了*无效*的Java类型名称，以传达它们的特殊含义和目的，并将它们与其他Java类型和文件区分开来，这些类型和文件是你通常在构建应用程序的过程中创建的。
- en: Steps **1** to **4** in the preceding method are the four necessary steps required
    to create a module. Let's put these steps into action by creating an addressbook
    viewer application using the Java 9 modular application approach. This is a simple
    application that helps you view a set of contact information. Nothing too complex,
    but just enough for us to put all the Java modularity concepts we learn in this
    book into practice!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法中的步骤**1**到**4**是创建模块所需的四个必要步骤。让我们通过使用Java 9模块化应用程序方法创建一个地址簿查看器应用程序来将这些步骤付诸实践。这是一个简单的应用程序，可以帮助你查看一组联系信息。没有太多复杂的功能，但足以让我们将本书中学到的所有Java模块化概念付诸实践！
- en: Creating your first Java module
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个Java模块
- en: Let's start by creating our first Java 9 module and walk through the process
    of coding, compiling, and executing a module. Ideally, any application should
    consist of multiple modules, but in this chapter, we'll start small. In this chapter,
    we'll create just **one** module called `packt.addressbook`. This will be our
    first Java module. Over the next few chapters, we'll break this down into multiple
    modules.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的第一个Java 9模块开始，并逐步介绍编码、编译和执行模块的过程。理想情况下，任何应用程序都应该由多个模块组成，但在这个章节中，我们将从小处着手。在这个章节中，我们将创建一个名为`packt.addressbook`的模块。这将是我们第一个Java模块。在接下来的几章中，我们将将其分解成多个模块。
- en: We'll obviously need to start with the folder where all our code resides. In
    the screenshots in this book, I've chosen the path `<home>/code/java9`, but you
    can feel free to use any path of your preference. I'll be referring to this folder
    as the project root folder throughout this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '我们显然需要从所有代码所在的文件夹开始。在这本书的截图里，我选择了路径`<home>/code/java9`，但你可以自由选择任何你喜欢的路径。在这本书中，我会将这个文件夹称为项目根文件夹。 '
- en: 'We''ve just learned the four steps required to create any Java module. Let''s
    run through those four steps for the `addressbook` module now:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了创建任何Java模块所需的四个步骤。现在，让我们为`addressbook`模块运行这四个步骤：
- en: '**Name the module**: We''ve already done this! The name of our `addressbook`
    module is `packt.addressbook`.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**命名模块**：我们已经完成了这个步骤！我们的`addressbook`模块的名称是`packt.addressbook`。'
- en: '**Create a module root folder**: You''ll now need to create one module folder
    for each module you intend to write. Since we are creating only one module called
    `packt.addressbook`, we create a folder with the same name. I recommend keeping
    all your Java source files in a separate folder called `src` in the project root
    folder. You''ll then create all your module root folders in the `src` folder.
    Since my project root is `~/code/java9`, the module root folder resides at `~/code/java9/src/packt.addressbook`.
    This `packt.addressbook` folder is where all the packages and Java files of the
    module reside.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建模块根文件夹**：现在，你需要为每个打算编写的模块创建一个模块文件夹。由于我们正在创建一个名为`packt.addressbook`的模块，我们创建一个具有相同名称的文件夹。我建议将所有Java源文件放在项目根文件夹中的单独文件夹`src`中。然后，你将在`src`文件夹中创建所有模块根文件夹。由于我的项目根文件夹是`~/code/java9`，模块根文件夹位于`~/code/java9/src/packt.addressbook`。这个`packt.addressbook`文件夹是模块中所有包和Java文件所在的地方。'
- en: '**Add code to the module**: This step is business as usual for Java developers.
    From the module root folder onward, your folder structure reflects your package.
    For our first attempt, let''s write a simple *Hello World* application. Create
    a Java file called `Main.java` in the package `packt.addressbook`. The complete
    path for `Main.java` is `~/code/java9/src/packt.addressbook/packt/addressbook/Main.java`.
    Let''s add a main method that just prints a message to the console:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向模块添加代码**：对于Java开发者来说，这一步是常规操作。从模块根目录开始，你的文件夹结构反映了你的包。对于我们第一次尝试，让我们编写一个简单的*Hello
    World*应用程序。在`packt.addressbook`包中创建一个名为`Main.java`的Java文件。`Main.java`的完整路径是`~/code/java9/src/packt.addressbook/packt/addressbook/Main.java`。让我们添加一个主方法，它只是将一条消息打印到控制台：'
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the actual difference from the previous Java 8 directory structure
    is the introduction of the module root folder. It's helpful to think about each
    module as a *subproject* of sorts. The package structure begins from the module
    root folder onward.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与之前的Java 8目录结构相比，实际的不同之处在于引入了模块根文件夹。将每个模块视为某种类型的*子项目*是有帮助的。包结构从模块根文件夹开始。
- en: '**Create a module descriptor**: Create a file called `module-info.java` and
    place it directly in the module root folder. We''ll go over the details of what
    can be configured in this file in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*, but for now, create this file with the following
    contents:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建模块描述符**：创建一个名为`module-info.java`的文件，并将其直接放置在模块根目录中。我们将在[第3章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)“处理模块间依赖关系”中详细介绍这个文件中可以配置的内容，但现在，创建这个文件并包含以下内容：'
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The keyword `module` is followed by the name of the module, which in our case
    is `packt.addressbook`. There's nothing between the curly braces for now because
    we are not specifying any details about the module in this file yet, except for
    the module name. However, adding this file to the module directory is essential
    for the Java compiler to treat this as a module.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`module`后面跟着模块的名称，在我们的例子中是`packt.addressbook`。目前在大括号之间没有内容，因为我们还没有在这个文件中指定任何关于模块的细节，除了模块名称。然而，将此文件添加到模块目录中对于Java编译器将其视为模块是至关重要的。
- en: 'With this, you are done! These four steps are what it takes to create a simple
    Java 9 module. Here''s how the folder structure should look when you are done:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就完成了！这四个步骤就是创建一个简单的Java 9模块所需的所有步骤。完成之后，文件夹结构应该如下所示：
- en: '![](img/00023.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00023.jpeg)'
- en: Now, let's move on to compiling and executing this module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续编译和执行这个模块。
- en: Compiling your module
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译你的模块
- en: 'Compiling code in a Java 9 module requires the use of the `javac` command as
    always, but with a few different options this time. To compile modules in Java
    9, you need to provide the `javac` command with the following information:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9模块中编译代码始终需要使用`javac`命令，但这次有一些不同的选项。要在Java 9中编译模块，您需要向`javac`命令提供以下信息：
- en: The location of your modules. This is the directory that contains the module
    root folders for all the modules in your application. In our case, this is the
    `src` folder. In it, we just have one module root folder.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您模块的位置。这是包含您应用程序中所有模块的模块根文件夹的目录。在我们的例子中，这是`src`文件夹。在其中，我们只有一个模块根文件夹。
- en: The paths and names of the Java files that need to be compiled. In our case,
    it's just one file--`Main.java`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要编译的Java文件的路径和名称。在我们的例子中，只有一个文件——`Main.java`。
- en: The destination location where the compiler needs to output the compiled `.class`
    files. This can be any location, but I recommend choosing a folder named `out`
    directly below the project root folder.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器需要输出编译后的`.class`文件的目标位置。这可以是任何位置，但我建议选择位于项目根文件夹直接下方的名为`out`的文件夹。
- en: 'To compile the module you''ve written, go to the project root (in our example,
    it''s `~/code/java9`) and run the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译您编写的模块，请转到项目根目录（在我们的例子中，它是`~/code/java9`）并运行以下命令：
- en: '![](img/00024.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: Here, you are specifying the module source path (**1**) using the `--module-source-path`
    command option, the output directory for compiled classes (**2**) using the `-d`
    command option, and the list of Java source files (**3**) by specifying them directly
    in the command (in this case, `Main.java` and `module-info.java`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`--module-source-path`命令选项指定模块源路径（**1**），使用`-d`命令选项指定编译后的类的输出目录（**2**），并通过直接在命令中指定它们来指定Java源文件列表（**3**）（在这种情况下，`Main.java`和`module-info.java`）。
- en: 'If the compiler is successful, there is no output to the console. The `out`
    directory should contain the compiled classes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器成功，控制台没有输出。`out`目录应包含编译后的类：
- en: '![](img/00025.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: Note that there is a one-to-one mapping between the source and compiled classes.
    Even the module descriptor `module-info.java` has been compiled to a `.class`
    file--`module-info.class`. This is for a very important reason. The module configuration
    provides metadata information about the module not just to the compiler during
    compile time, but also to the JVM during runtime. Thanks to the `module-info.class`,
    the JVM also has all the information about every Java module, thus enabling the
    runtime to tap into many of the benefits of the module system during execution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，源代码和编译后的类之间存在一对一的映射。甚至模块描述符`module-info.java`也被编译成了`.class`文件--`module-info.class`。这有一个非常重要的原因。模块配置不仅为编译器在编译时提供有关模块的元数据信息，而且还在JVM运行时提供。多亏了`module-info.class`，JVM也拥有了关于每个Java模块的所有信息，从而使得运行时能够在执行过程中充分利用模块系统的许多好处。
- en: Executing your module
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行您的模块
- en: 'Executing your compiled code again uses the familiar `java` command, but with
    some new options. Here is the information you need to tell the `java` command
    in this case:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行编译后的代码使用熟悉的`java`命令，但有一些新的选项。以下是您需要告诉`java`命令的信息：
- en: The location of the compiled modules--also called the **module path**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译后的模块的位置——也称为**模块路径**。
- en: The module that contains the class with the `main` method that needs to start
    the execution.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含需要启动执行的`main`方法的类的模块。
- en: The class with the `main` method in the preceding module that needs to start
    the execution.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的模块中具有需要启动执行的`main`方法的类。
- en: 'To execute the code you just compiled in the previous step, you''d need to
    run the following command in the same directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行您在上一步中编译的代码，您需要在同一目录下运行以下命令：
- en: '![](img/00026.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Here, you are specifying the location of the compiled modules (**1**) using
    the `--module-path` flag. We've told the compiler in the previous step to place
    our compiled code in the `out` folder, and so that's the value we need to provide
    here. You specify the module (**2**) and the class with the main method (**3**)
    using the `--module` option. Note the format of the value--it's `<module-name>/<fully-qualified-classname>`.
    Here, our code consists of just one class, so it feels unnecessary to specify
    this, but you can imagine a code base with multiple modules and classes, many
    of which might have main methods. It's important for the runtime to know which
    main method of which class of which module it needs to start the execution on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: There are alternative option names for many of these options. For example, instead
    of using `--module-path`, you can simply use `-p`, and `--module` can be replaced
    with `-m`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: If the execution completed successfully, you should see the message `Hello World!`
    printed on the console.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: You've learned about two new arguments, `--module-source-path` and `--module-path`.
    They roughly correspond to the `-sourcepath` and `-classpath` options that we've
    been using in Java for a while now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 8 and earlier**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '`sourcepath`: Tells the compiler where the source files are that need to be
    compiled.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`classpath`: Tells the compiler/runtime where the compiled types are that need
    to be included in the `classpath` for compiling/running code.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 9**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '`module-source-path`: Tells the compiler where the source files for the modules
    are.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`module-path`: Tells the compiler/runtime where the compiled modules are that
    need to be considered for compiling/running code your code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module using NetBeans
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you''ve learned how to create, compile, and execute a module using
    the Command Prompt, let''s see how to do the same thing using the NetBeans IDE:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project in the NetBeans IDE by clicking ![](img/00027.jpeg) in
    the toolbar or, through the menu File | New Project, you''ll see a New Project
    overlay with a new option in the `Java` category--Java Modular Project:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'Select that and click Next. In the next dialog, you can specify the name of
    your project (I chose `addressbookviewer`) and the location of your project and
    click Finish:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Once the new project is loaded onto your IDE, you can right-click on the name
    of the project in the Projects tab and choose the option to create a new module:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'In the New Module dialog, enter the name of the module `packt.addressbook`
    and click Finish:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'And just like that, you''ve created a new module! Note how NetBeans has automatically
    created the module descriptor for your module:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Now what's left is to add the `Main.java` class by right-clicking on the module
    and going through the wizard:![](img/00033.jpeg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After adding the `Main.java` class, you can compile and execute it by right-clicking
    on the class and clicking Run File. You should see the message `Hello World` on
    the console panel at the bottom:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了`Main.java`类之后，你可以通过右键单击该类并点击运行文件来编译和执行它。你应该在底部的控制台面板上看到消息`Hello World`。
- en: '![](img/00034.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: Congratulations! You've created, compiled, and executed your first Java module!
    This was a module with just one Java type, `Main.java`. Most of the code you'll
    be writing in this book will have you follow through the same steps that you just
    did. There will be several variations, of course, but we'll be examining the differences
    as we learn more about modules.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了、编译并执行了你的第一个Java模块！这是一个只有一个Java类型`Main.java`的模块。在这本书中，你将要编写的代码大多数都会让你遵循你刚才所做过的相同步骤。当然，会有几个变体，但我们将随着对模块了解的深入来探讨这些差异。
- en: The address book viewer application
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址簿查看应用程序
- en: Now that you are comfortable creating, compiling, and executing a simple Java
    9 module, let's update it and start adding address book viewer functionality.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了创建、编译和执行简单的Java 9模块，让我们更新它并开始添加地址簿查看功能。
- en: 'The following informal class diagram shows how we''ll design the application
    classes to begin with:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的非正式类图显示了我们将如何设计应用程序类：
- en: '![](img/00035.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: The main class has the `main()` method that displays the list of contacts in
    ascending order, sorted by the `lastName` property. It gets the list of contacts
    by calling the `ContactUtil.getContacts()` method and it sorts it using `SortUtil.sortList()`.
    It then displays the list of contacts to the console.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主类有一个`main()`方法，该方法按`lastName`属性升序显示联系人的列表。它通过调用`ContactUtil.getContacts()`方法来获取联系人的列表，并使用`SortUtil.sortList()`对其进行排序。然后它将联系人列表显示到控制台。
- en: 'We''ll start with a new model class `Contact`, which represents a single piece
    of contact information. Apart from the obvious contact-related private member
    variables and getters and setters, this class also has a couple of additions that''ll
    come in handy later:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个新的模型类`Contact`开始，它代表一条联系信息。除了显而易见的与联系相关的私有成员变量和getter和setter之外，这个类还有一些将在以后派上用场的附加功能：
- en: '**The constructor with arguments**: This makes it easy for us to create contact
    objects. This is useful since we''ll be hardcoding our contact list to begin with.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有参数的构造函数**：这使得我们能够轻松地创建联系对象。这很有用，因为我们一开始会硬编码我们的联系列表。'
- en: '**The toString() method**: This provides readable output when we print `Contact`
    objects to the console.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**toString()方法**：当我们向控制台打印`Contact`对象时，它提供了可读的输出。'
- en: '**The compareTo() method**: Since we''ll need to sort `Contact` objects, we''ll
    have the `Contact` class, which implements `Comparable`, and the `compareTo()`
    method, which compares `Contact` instances by their `lastName` property.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**compareTo()方法**：由于我们需要对`Contact`对象进行排序，我们将有一个实现了`Comparable`接口的`Contact`类，以及一个`compareTo()`方法，该方法通过`lastName`属性比较`Contact`实例。'
- en: 'Here''s what the `Contact` class looks like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Contact`类的样子：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s move on to the `ContactUtil` class. We need a source of some contact
    data to start coding with, so for now, we''ll hardcode a few `Contact` objects
    and add them to a list. The `ContactUtil.getContacts()` method just prepares this
    hard coded list for now:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到`ContactUtil`类。我们需要一些联系数据作为编码的起点，所以现在我们将硬编码几个`Contact`对象并将它们添加到一个列表中。`ContactUtil.getContacts()`方法目前只是为这个硬编码的列表做准备：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next is the `SortUtil` class. You don''t typically write sort methods, thanks
    to some good collection libraries that are available out of the box with Java.
    In this case, however, we will implement our own sorting algorithm for the purposes
    of learning about modules because it''ll help us illustrate some important use
    cases throughout this book. Instead of creating a method specifically designed
    to sort `Contact` instances, we''ll instead write a generic Bubble Sort method
    to sort any type that implements `Comparable`. Thanks to `Contact` implementing
    the `Comparable` interface, we should be able to use the `SortUtil` to sort its
    instances too:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`SortUtil`类。通常你不需要编写排序方法，因为Java提供了几个开箱即用的良好集合库。然而，在这种情况下，我们将为了了解模块的目的实现我们自己的排序算法，因为它将帮助我们在这本书的整个过程中说明一些重要的用例。我们不会创建一个专门用于排序`Contact`实例的方法，而是编写一个通用的冒泡排序方法来排序任何实现了`Comparable`接口的类型。由于`Contact`实现了`Comparable`接口，我们应该能够使用`SortUtil`来排序其实例：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s bring it all together in `Main.java`. We''ll first call the `getContacts()`
    method on an instance of `ContactUtil` to get the hardcoded `Contact` list. Then
    we''ll pass it to the `sortList()` method on an instance of `SortList`. We will
    then print the sorted list on the console using `System.out.println()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`Main.java`中将所有内容整合在一起。我们首先在`ContactUtil`的一个实例上调用`getContacts()`方法来获取硬编码的`Contact`列表。然后我们将它传递给`SortList`的一个实例上的`sortList()`方法。然后我们将使用`System.out.println()`在控制台上打印排序后的列表：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this, we are done and ready to compile our code. We''ve seen that the
    command to compile your code looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了，并准备好编译我们的代码。我们看到了编译你的代码的命令看起来是这样的：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The part where we need to specify all Java classes can get tedious. We have
    a handful of classes at this time, and I already don't want to be bothered with typing
    all the class names (with paths!) in the command. This can get worse when we have
    multiple modules in the module source path and we want to compile them. Thankfully,
    there's a shortcut. The compiler also has the `--module` option that lets you
    specify the names of the modules that you need to compile. You can specify multiple
    module names here, separated by commas. The compiler looks for those modules in
    the module source path and compiles all classes in those modules. And as you can
    imagine, using this command is much easier!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定所有 Java 类的部分可能会变得繁琐。我们目前只有一些类，而且我已经不想被麻烦地输入所有类名（包括路径！）在命令中。当我们有多个模块在模块源路径中，并且我们想要编译它们时，这会变得更糟。幸运的是，有一个快捷方式。编译器还有一个`--module`选项，允许你指定需要编译的模块名称。你可以在其中指定多个模块名称，用逗号分隔。编译器会在模块源路径中查找这些模块，并编译这些模块中的所有类。正如你所想象的那样，使用这个命令要容易得多！
- en: 'Since we are compiling just one module here, that''s what we''ll specify as
    the value for the `--module` argument:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里只编译一个模块，这就是我们将为`--module`参数指定的值：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The compilation should complete without any errors. Now, let''s move on to
    execute your code. The command remains unchanged:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 编译应该在没有错误的情况下完成。现在，让我们继续执行你的代码。命令保持不变：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the sorted output from the hardcoded contacts list:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是硬编码联系人列表的排序输出：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you expand the out directory, you''ll again notice the one-to-one mapping
    between the `.java` files and the `.class` files:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开输出目录，你又会注意到`.java`文件和`.class`文件之间的一对一映射：
- en: '![](img/00036.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: Handling possible errors
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理可能的错误
- en: 'Here are some possible errors you could run into when following the steps we
    previously outlined, along with some solutions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循我们之前概述的步骤时，你可能会遇到以下一些可能的错误，以及一些解决方案：
- en: 'Error during compilation:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译时错误：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is probably because you haven't switched to JDK 9 and are still using the
    Java 8 compiler. The `--module-source-path` option has been newly introduced to 
    `javac` as of version 9.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是因为你没有切换到 JDK 9，仍然在使用 Java 8 编译器。`--module-source-path`选项是从版本 9 开始新引入到`javac`中的。
- en: 'Error during compilation:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译时错误：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This error is because the Java compiler is unable to find the `module-info.java`
    file. Make sure it is in the right directory path.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是因为 Java 编译器无法找到`module-info.java`文件。请确保它在正确的目录路径中。
- en: 'Error during runtime:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时错误：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This error indicates that the module file is not available in the module path
    provided. Make sure the path is correctly specified and that the `packt.addressbook`
    folder contains the compiled `module-info.class` file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误表明模块文件不在提供的模块路径中可用。请确保路径已正确指定，并且`packt.addressbook`文件夹包含编译后的`module-info.class`文件。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned what the bare minimum steps to creating a
    Java 9 module are. You've created a simple module from scratch, as well as compiled
    and executed code in the module. You've also learned about a few possible error
    scenarios and how to handle them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了创建 Java 9 模块的最基本步骤。你从头开始创建了一个简单的模块，并在模块中编译和执行了代码。你还了解了一些可能的错误场景以及如何处理它们。
- en: There is something missing though! Since we are dealing with a single module,
    we are not really leveraging the concepts of modularity here. The concepts of
    modularity come into play only when we have multiple modules interacting with
    each other. You'll see just that in action in the next chapter when you create
    your second Java module and set up inter-module dependency!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，还有一些东西是缺失的！由于我们在这里处理的是一个单独的模块，所以我们实际上并没有真正利用模块化的概念。模块化的概念只有在有多个模块相互交互时才会发挥作用。你将在下一章中看到这一点，当你创建第二个
    Java 模块并设置模块间依赖时！
