- en: Creating Your First Java Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we took a detailed look at the problems associated
    with modularizing Java code pre-Java 9, as well as the new module construct in
    Java 9 and *Project Jigsaw*. Before we examine how Java modularity solves these
    problems, you''ll need to first understand what a Java module looks like. In this
    chapter, you''ll create your first Java 9 module and learn what it takes to build
    and execute code in a Java module. Here are the top-level topics you''ll be learning
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the JDK with Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Java 9 module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a module (using `module-info.java`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and executing a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling possible errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll be building a sample Java 9 application throughout this book as you learn
    the different concepts related to modularity. The application you'll build is
    an address book viewer application that displays some contacts sorted by last
    name. We'll start simple and enhance this application as we go. When you are done
    with this chapter, you'll have built your first Java 9 module and learned how
    to compile and execute it. Let's start by first installing the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to write Java 9 code, you''ll first need to download and install the
    Java 9 SDK (referred to as the Java Development Kit or JDK). In this book, we''ll
    be using the **OpenJDK** build available at [http://jdk.java.net/9/](http://jdk.java.net/9/).
    When you navigate to the URL, you''ll see a list of available downloads based
    on the platform you are using, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure you choose the download for your platform in the **JDK** column,
    not the **JRE** column. After accepting the license agreement, you should be able
    to download an installer for your platform. Run the installer and choose the defaults;
    after this, you should have JDK 9 installed in your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the installation is complete, it''s a good idea to verify that the JDK
    installation and configuration process completed successfully. You do that by
    opening a **Command Prompt** or terminal window. Type the command `java -version`
    to output the version of the `java` command currently in the `PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the installer adds the location of the installed Java binaries to
    your system `PATH` variable, which is why this command works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, you can also make sure that the `JAVA_HOME` value is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS/Linux, type the command `echo $JAVA_HOME` and make sure the path to
    the JDK 9 installation is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On Windows, right-click on My Computer, click Properties, and switch to the
    Advanced tab. Here, click Environment Variables and view the value for the variable
    `JAVA_HOME`. It should point to the location you've chosen to install the JDK.
    For example, the location could be something like `C:\Program Files\Java\jdk9`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you've now successfully installed JDK 9 and you are all set to start
    coding in Java 9!
  prefs: []
  type: TYPE_NORMAL
- en: Switching between JDKs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've installed a newer version of the JDK with an earlier version already
    installed, it is possible to switch what the currently selected version is.
  prefs: []
  type: TYPE_NORMAL
- en: On macOS and Linux, you do this by switching the value of `JAVA_HOME`
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command switches the current Java platform to Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch to Java 9, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With this command, you are passing the Java version of choice to the `-v` parameter.
    But, note that the format is different between Java 8 and 9\. With Java 8, the
    version string is `1.8`. With Java 9, the version string is just `9`. Traditionally,
    Java has been using the `1.X` version format, for example, Java version 7 had
    the version string `1.7`. This is being changed from Java 9 onward. The idea is
    that subsequent releases of Java will drop the `1.X` format and just use a single
    number to denote the format. So it's Java 9, not Java 1.9.
  prefs: []
  type: TYPE_NORMAL
- en: It's about time this was changed! Imagine the confusion Java 10 would have caused!
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, you switch JDK versions by changing the `JAVA_HOME` and `PATH` variables.
    Follow the same steps as earlier to get to the Environment Variables section.
    Update the value of `JAVA_HOME` to point to the location where the version you
    need is installed. Also, make sure the `PATH` is updated to point to the corresponding
    folder for the Java version you'd like to switch to.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the NetBeans IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write and follow the code in this book, you don't *have* to use
    any **integrated development environments** (**IDEs**). This book will cover writing,
    compiling, and executing code manually using the command line. You can write code
    using a text editor of your choice. The code samples accompanying this book also
    work with the steps and commands showcased in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also follow along with an IDE. At the time of writing, NetBeans and
    IntelliJ Idea has growing support for Java modular projects, with Eclipse support
    under development. This chapter outlines the steps to create a modular project
    in NetBeans, should you choose to use the NetBeans IDE. To set it up, in addition
    to following the steps to set up Java, make sure you install the latest version
    of NetBeans with Java 9 module support by going to [https://netbeans.org/downloads/](https://netbeans.org/downloads/)
    and choosing either the Java SE or the Java EE version to download:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that if the release version of NetBeans does not yet support Java 9 when
    you read this, you might have to download an early access copy here: [http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/).
    Once you download the installer and execute it, you should have a shiny new copy
    of NetBeans on your computer ready for you to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Most veteran Java programmers would acknowledge that it has been a while since
    they have created folder structures by hand for their Java projects. The Java
    language has benefitted from incredibly useful tooling support over the years.
    IDEs such as Eclipse, NetBeans, and IntelliJ IDEA make it such a breeze to create
    source and package folders that developers don't even tend to think about those
    aspects of code organization too often. However, in this chapter, and in fact
    in the rest of the book, we will learn how to build folders and files by hand,
    as well as compile and run the code by executing commands manually from the command
    line. This is because IDEs, as convenient as they might be, tend to hide the details
    and workings around the process of structuring and compiling code. We intend to
    examine how Java 9 modules work, and the fundamental workings of the code structure,
    as well as compiling and linking commands, are essential to mastering these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: While the prospect of writing Java code without an IDE might seem daunting,
    let me assure you that this is something you'll likely get used to very quickly.
    You'll learn the steps to build and execute modular Java 9 code in this chapter,
    and then it's just a matter of applying the same steps independent of the complexity
    of the code base itself.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing an application in Java 9, you are ideally creating a modular application.
    It's important to note that a modular Java application isn't just a regular Java
    application (like those we've been building all these years) with just an extra
    module feature thrown in. It actually calls for a completely new way of thinking
    about writing and structuring your code base. Before we get into creating Java
    9 modules, let's do a quick recap of the traditional Java code structure pre-Java
    9.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Java code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traditionally, writing a Java application starts with creating one or more
    source directories. These are special directories that serve two purposes--firstly,
    they act as root locations of your Java source code and secondly, the contents
    of these directories are added to the class path. So, the steps to organize source
    code have typically been:'
  prefs: []
  type: TYPE_NORMAL
- en: Create one or more source folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a source folder, create package folders to mirror the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the `.java` files in the right package folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Many Java developers use the directory structure `src/main/java` for the source
    directory. So, for example, a class `Main.java` in the package `com.acme.app`
    would have the overall path `src/main/java/com/acme/app/Main.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how source code in Java has typically been organized by developers for
    many years now. With Java 9 modules, there's a change in the way we approach structuring
    and writing code. Let's switch gears and examine what a module in Java 9 looks
    like.
  prefs: []
  type: TYPE_NORMAL
- en: What is a module?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *module* is a new construct that has been introduced into the Java 9 programming
    language. Think of modules as first-class citizens and as new program components
    in the language, just like classes or packages. A Java 9 module is a named, self-describing
    collection of code and data that you can create and use in Java applications.
    A module can contain any number of Java packages that in turn contain Java code
    elements, such as classes or interfaces. A Java module can also contain files
    such as resource files or property files. An application is built by bringing
    together a collection of these modules. The analogy of building blocks applies
    well here--a module is a building block that exists on its own, but can be a part
    of a bigger whole.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 9 modular programming, we move away from building applications as
    monolithic code bases and instead look to break down the problem into modules.
    In other words, rather than having one big Java project, you create several modular
    units that work together to form an application.
  prefs: []
  type: TYPE_NORMAL
- en: This significantly influences how you design and code your application. In Java
    8 and earlier, your design process involved breaking down the problem into classes
    and packages. In Java 9, you first break the problem down into modules. These
    modules are ideally components that are reusable with a clear interface (inputs
    and outputs) and solve a specific part of the problem. Inside each module, however,
    the process of designing and writing code is, more or less, business as usual
    with packages, classes, interfaces, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to create a module in Java 9\. Before you start with *step
    1*, I should mention an obvious starting point--*step 0*: Know what the module''s
    purpose is. Before you begin creating a module, you should have a clear idea of
    what the module is for. Remember the important tenet of modular development here!
    Rather than having one large code base for your application, you instead break
    the problem down into reusable subprojects. Think *reusable libraries*. The main
    difference is that rather than the libraries just being separate JARs that are
    nothing more than a collection of Java packages and types, we are leveraging the
    concept of Java modules to group those packages and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assign a module name**: The first step to creating a module is to come up
    with a unique name for the module. The name should ideally describe what the module
    is about and the problem it solves. A Java module name should be a valid Java
    identifier, so you cannot use certain characters, such as hyphens and slashes.
    A valid package name is also a valid module name. But apart from that, any name
    will do as long as it is unique in an application. However, to avoid clashing
    names, you don''t want to call a module something very generic, such as `util`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recommended practice is to use the same convention that has worked well
    all these years for package names in Java--using the reverse domain name pattern.
    It's also recommended that you use all lowercase naming for modules, just like
    packages. So, for example, if you are writing a String utilities module for Acme
    Corp, the name of the module could be something such as `com.acme.stringutil`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a module root folder**: Every Java module resides in its own folder,
    which acts as the top-level folder for the module and contains all the assets
    of the module. This folder is called the **module root** folder. The module root
    folder has the same name as the module. So, the root folder for the aforementioned
    example module has the name `com.acme.stringutil`. It is named exactly the same
    as the module name, including the periods, if any.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add the module code**: Inside the module root folder goes the code that belongs
    to the module. This begins with packages, so you start your package folders from
    the module root folder onward. So, if your module `com.acme.stringutil` has the
    class `StringUtil.java` in the package `com.acme.util`, the folder structure should
    look like this:![](img/00020.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note the difference in the file structure from the pre-Java 9 structure that
    we looked at before. What used to go directly into the source folders in earlier
    versions of Java now goes into the module root folder. As you can see from the
    following table, with Java 9 there''s just an additional folder level with the
    module root folders. From the module root folder onward, there''s nothing new
    in the way Java types are organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The Java 8 (and earlier) way** | **The Java 9 way** |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. Create one or more source folders.2\. In a source folder, create package
    folders to mirror the package name.3\. Place the `.java` files in the right package
    folders. | 1\. Create one or more source folders.2\. In a source folder, create
    a module folder for each module.3\. In the module folders, create package folders
    to mirror the package name.4\. Place the `.java` files in the right package folders.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Here''s a diagram representing the code structure with the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Create and configure the module descriptor**: Here''s the final step! Every
    module comes with a file that describes it and contains metadata about the module.
    This file is called the module descriptor. This file contains information about
    the module, such as what it requires (the inputs to the module) and what the module
    exports (the outputs from the module). The module descriptor is always located
    directly at the module root folder, and it is always given the name `module-info.java`.
    That''s right! A module descriptor file is actually a `.java` file. What do the
    contents of this module descriptor file look like?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a barebones and minimal module descriptor for the example module--`com.acme.stringutil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The file starts with the `module` keyword followed by the module name and curly
    braces. The curly brace structure resembles other Java type declarations you should
    be familiar with. Note that the name of the module (following the `module` keyword)
    should exactly match the name of the module root folder.
  prefs: []
  type: TYPE_NORMAL
- en: Within the curly braces, you can optionally specify the metadata (the inputs
    and outputs) of the module. In the preceding example, the module descriptor is
    essentially *empty*, with nothing between the curly braces. For any real-world
    module you create, you will more than likely add some metadata here to configure
    the behavior of the module. We'll cover this metadata in more detail in [Chapter
    3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb), *Handling Inter-Module
    Dependencies*, but what you can see in the example is the bare minimum *necessary
    and sufficient* content needed for the module descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the module descriptor file in the **module root**, this is the folder
    and file structure for our simple module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For someone used to writing Java classes, the name of the `module-info.java`
    file might seem a bit odd at first. This is because of a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-` character here isn't a valid identifier to be used in a Java type name,
    and nor is it valid for the name of a `.java` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the `.java` file usually matches the name of the public type contained
    in the file, but in this case, it doesn't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, some Java developers might also find this familiar, having used a similar-looking
    file name that has been used in Java since Java 1.5--`package-info.java`. The
    `package-info.java` file is used to specify package-level configuration and annotations,
    and has been used for many years now, although not very widely. Both `module-info.java`
    and `package-info.java` files have intentionally been given *invalid* Java type
    names in order to convey their special meaning and purpose, and to separate them
    from the other Java types and files you'd normally create in the process of building
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Steps **1** to **4** in the preceding method are the four necessary steps required
    to create a module. Let's put these steps into action by creating an addressbook
    viewer application using the Java 9 modular application approach. This is a simple
    application that helps you view a set of contact information. Nothing too complex,
    but just enough for us to put all the Java modularity concepts we learn in this
    book into practice!
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Java module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating our first Java 9 module and walk through the process
    of coding, compiling, and executing a module. Ideally, any application should
    consist of multiple modules, but in this chapter, we'll start small. In this chapter,
    we'll create just **one** module called `packt.addressbook`. This will be our
    first Java module. Over the next few chapters, we'll break this down into multiple
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: We'll obviously need to start with the folder where all our code resides. In
    the screenshots in this book, I've chosen the path `<home>/code/java9`, but you
    can feel free to use any path of your preference. I'll be referring to this folder
    as the project root folder throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve just learned the four steps required to create any Java module. Let''s
    run through those four steps for the `addressbook` module now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name the module**: We''ve already done this! The name of our `addressbook`
    module is `packt.addressbook`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a module root folder**: You''ll now need to create one module folder
    for each module you intend to write. Since we are creating only one module called
    `packt.addressbook`, we create a folder with the same name. I recommend keeping
    all your Java source files in a separate folder called `src` in the project root
    folder. You''ll then create all your module root folders in the `src` folder.
    Since my project root is `~/code/java9`, the module root folder resides at `~/code/java9/src/packt.addressbook`.
    This `packt.addressbook` folder is where all the packages and Java files of the
    module reside.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add code to the module**: This step is business as usual for Java developers.
    From the module root folder onward, your folder structure reflects your package.
    For our first attempt, let''s write a simple *Hello World* application. Create
    a Java file called `Main.java` in the package `packt.addressbook`. The complete
    path for `Main.java` is `~/code/java9/src/packt.addressbook/packt/addressbook/Main.java`.
    Let''s add a main method that just prints a message to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the actual difference from the previous Java 8 directory structure
    is the introduction of the module root folder. It's helpful to think about each
    module as a *subproject* of sorts. The package structure begins from the module
    root folder onward.
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a module descriptor**: Create a file called `module-info.java` and
    place it directly in the module root folder. We''ll go over the details of what
    can be configured in this file in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*, but for now, create this file with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `module` is followed by the name of the module, which in our case
    is `packt.addressbook`. There's nothing between the curly braces for now because
    we are not specifying any details about the module in this file yet, except for
    the module name. However, adding this file to the module directory is essential
    for the Java compiler to treat this as a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, you are done! These four steps are what it takes to create a simple
    Java 9 module. Here''s how the folder structure should look when you are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move on to compiling and executing this module.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling your module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiling code in a Java 9 module requires the use of the `javac` command as
    always, but with a few different options this time. To compile modules in Java
    9, you need to provide the `javac` command with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The location of your modules. This is the directory that contains the module
    root folders for all the modules in your application. In our case, this is the
    `src` folder. In it, we just have one module root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The paths and names of the Java files that need to be compiled. In our case,
    it's just one file--`Main.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The destination location where the compiler needs to output the compiled `.class`
    files. This can be any location, but I recommend choosing a folder named `out`
    directly below the project root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To compile the module you''ve written, go to the project root (in our example,
    it''s `~/code/java9`) and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you are specifying the module source path (**1**) using the `--module-source-path`
    command option, the output directory for compiled classes (**2**) using the `-d`
    command option, and the list of Java source files (**3**) by specifying them directly
    in the command (in this case, `Main.java` and `module-info.java`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the compiler is successful, there is no output to the console. The `out`
    directory should contain the compiled classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that there is a one-to-one mapping between the source and compiled classes.
    Even the module descriptor `module-info.java` has been compiled to a `.class`
    file--`module-info.class`. This is for a very important reason. The module configuration
    provides metadata information about the module not just to the compiler during
    compile time, but also to the JVM during runtime. Thanks to the `module-info.class`,
    the JVM also has all the information about every Java module, thus enabling the
    runtime to tap into many of the benefits of the module system during execution.
  prefs: []
  type: TYPE_NORMAL
- en: Executing your module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Executing your compiled code again uses the familiar `java` command, but with
    some new options. Here is the information you need to tell the `java` command
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: The location of the compiled modules--also called the **module path**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The module that contains the class with the `main` method that needs to start
    the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class with the `main` method in the preceding module that needs to start
    the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To execute the code you just compiled in the previous step, you''d need to
    run the following command in the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you are specifying the location of the compiled modules (**1**) using
    the `--module-path` flag. We've told the compiler in the previous step to place
    our compiled code in the `out` folder, and so that's the value we need to provide
    here. You specify the module (**2**) and the class with the main method (**3**)
    using the `--module` option. Note the format of the value--it's `<module-name>/<fully-qualified-classname>`.
    Here, our code consists of just one class, so it feels unnecessary to specify
    this, but you can imagine a code base with multiple modules and classes, many
    of which might have main methods. It's important for the runtime to know which
    main method of which class of which module it needs to start the execution on.
  prefs: []
  type: TYPE_NORMAL
- en: There are alternative option names for many of these options. For example, instead
    of using `--module-path`, you can simply use `-p`, and `--module` can be replaced
    with `-m`.
  prefs: []
  type: TYPE_NORMAL
- en: If the execution completed successfully, you should see the message `Hello World!`
    printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: You've learned about two new arguments, `--module-source-path` and `--module-path`.
    They roughly correspond to the `-sourcepath` and `-classpath` options that we've
    been using in Java for a while now.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 8 and earlier**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sourcepath`: Tells the compiler where the source files are that need to be
    compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: '`classpath`: Tells the compiler/runtime where the compiled types are that need
    to be included in the `classpath` for compiling/running code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 9**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module-source-path`: Tells the compiler where the source files for the modules
    are.'
  prefs: []
  type: TYPE_NORMAL
- en: '`module-path`: Tells the compiler/runtime where the compiled modules are that
    need to be considered for compiling/running code your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module using NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you''ve learned how to create, compile, and execute a module using
    the Command Prompt, let''s see how to do the same thing using the NetBeans IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project in the NetBeans IDE by clicking ![](img/00027.jpeg) in
    the toolbar or, through the menu File | New Project, you''ll see a New Project
    overlay with a new option in the `Java` category--Java Modular Project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select that and click Next. In the next dialog, you can specify the name of
    your project (I chose `addressbookviewer`) and the location of your project and
    click Finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the new project is loaded onto your IDE, you can right-click on the name
    of the project in the Projects tab and choose the option to create a new module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the New Module dialog, enter the name of the module `packt.addressbook`
    and click Finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And just like that, you''ve created a new module! Note how NetBeans has automatically
    created the module descriptor for your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now what's left is to add the `Main.java` class by right-clicking on the module
    and going through the wizard:![](img/00033.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After adding the `Main.java` class, you can compile and execute it by right-clicking
    on the class and clicking Run File. You should see the message `Hello World` on
    the console panel at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You've created, compiled, and executed your first Java module!
    This was a module with just one Java type, `Main.java`. Most of the code you'll
    be writing in this book will have you follow through the same steps that you just
    did. There will be several variations, of course, but we'll be examining the differences
    as we learn more about modules.
  prefs: []
  type: TYPE_NORMAL
- en: The address book viewer application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are comfortable creating, compiling, and executing a simple Java
    9 module, let's update it and start adding address book viewer functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following informal class diagram shows how we''ll design the application
    classes to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The main class has the `main()` method that displays the list of contacts in
    ascending order, sorted by the `lastName` property. It gets the list of contacts
    by calling the `ContactUtil.getContacts()` method and it sorts it using `SortUtil.sortList()`.
    It then displays the list of contacts to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a new model class `Contact`, which represents a single piece
    of contact information. Apart from the obvious contact-related private member
    variables and getters and setters, this class also has a couple of additions that''ll
    come in handy later:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The constructor with arguments**: This makes it easy for us to create contact
    objects. This is useful since we''ll be hardcoding our contact list to begin with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The toString() method**: This provides readable output when we print `Contact`
    objects to the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The compareTo() method**: Since we''ll need to sort `Contact` objects, we''ll
    have the `Contact` class, which implements `Comparable`, and the `compareTo()`
    method, which compares `Contact` instances by their `lastName` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s what the `Contact` class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to the `ContactUtil` class. We need a source of some contact
    data to start coding with, so for now, we''ll hardcode a few `Contact` objects
    and add them to a list. The `ContactUtil.getContacts()` method just prepares this
    hard coded list for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `SortUtil` class. You don''t typically write sort methods, thanks
    to some good collection libraries that are available out of the box with Java.
    In this case, however, we will implement our own sorting algorithm for the purposes
    of learning about modules because it''ll help us illustrate some important use
    cases throughout this book. Instead of creating a method specifically designed
    to sort `Contact` instances, we''ll instead write a generic Bubble Sort method
    to sort any type that implements `Comparable`. Thanks to `Contact` implementing
    the `Comparable` interface, we should be able to use the `SortUtil` to sort its
    instances too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s bring it all together in `Main.java`. We''ll first call the `getContacts()`
    method on an instance of `ContactUtil` to get the hardcoded `Contact` list. Then
    we''ll pass it to the `sortList()` method on an instance of `SortList`. We will
    then print the sorted list on the console using `System.out.println()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we are done and ready to compile our code. We''ve seen that the
    command to compile your code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The part where we need to specify all Java classes can get tedious. We have
    a handful of classes at this time, and I already don't want to be bothered with typing
    all the class names (with paths!) in the command. This can get worse when we have
    multiple modules in the module source path and we want to compile them. Thankfully,
    there's a shortcut. The compiler also has the `--module` option that lets you
    specify the names of the modules that you need to compile. You can specify multiple
    module names here, separated by commas. The compiler looks for those modules in
    the module source path and compiles all classes in those modules. And as you can
    imagine, using this command is much easier!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are compiling just one module here, that''s what we''ll specify as
    the value for the `--module` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation should complete without any errors. Now, let''s move on to
    execute your code. The command remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the sorted output from the hardcoded contacts list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you expand the out directory, you''ll again notice the one-to-one mapping
    between the `.java` files and the `.class` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Handling possible errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some possible errors you could run into when following the steps we
    previously outlined, along with some solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error during compilation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is probably because you haven't switched to JDK 9 and are still using the
    Java 8 compiler. The `--module-source-path` option has been newly introduced to 
    `javac` as of version 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error during compilation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This error is because the Java compiler is unable to find the `module-info.java`
    file. Make sure it is in the right directory path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error during runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This error indicates that the module file is not available in the module path
    provided. Make sure the path is correctly specified and that the `packt.addressbook`
    folder contains the compiled `module-info.class` file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned what the bare minimum steps to creating a
    Java 9 module are. You've created a simple module from scratch, as well as compiled
    and executed code in the module. You've also learned about a few possible error
    scenarios and how to handle them.
  prefs: []
  type: TYPE_NORMAL
- en: There is something missing though! Since we are dealing with a single module,
    we are not really leveraging the concepts of modularity here. The concepts of
    modularity come into play only when we have multiple modules interacting with
    each other. You'll see just that in action in the next chapter when you create
    your second Java module and set up inter-module dependency!
  prefs: []
  type: TYPE_NORMAL
