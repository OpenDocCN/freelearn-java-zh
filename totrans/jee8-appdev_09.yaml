- en: Securing Java EE Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE 8 introduces a new security API that standardizes application security
    across all Java EE 8 compliant application servers. The API includes standardized
    access to identity stores, which allow a uniform way of retrieving user credentials
    from a relational or LDAP database, as well as allowing us to implement access
    to custom identity stores. The new Java EE 8 API includes support for authentication
    mechanisms, allowing us to authenticate users in a standard way. Several authentication
    mechanisms are supported such as basic HTTP authentication, client certificates,
    HTML forms, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identity stores provide access to a persistence storage system, such as a relational
    or **LDAP** (**Lightweight Directory Access Protocol**) database, where user credentials
    are stored. The Java EE Security API supports relational and LDAP databases directly,
    and it allows us to integrate with custom identity stores, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an identity store stored in a relational database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To authenticate a secured resource, such as a Servlet or JAX-RS RESTful web
    service, against credentials stored in a relational database, we need to annotate
    an application-scoped CDI bean with the `@DatabaseIdentityStoreDefinition` annotation,
    as illustrated in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the JNDI name for the JDBC connection for the relational database
    containing user credentials is `jdbc/userAuth`, which is the value we provided
    to the `dataSourceLookup` attribute of the `@DatabaseIdentityStoreDefinition`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The `callerQuery` parameter of `@DatabaseIdentityStoreDefinition` is used to
    specify the SQL query used to retrieve the username and password for the user
    we are authenticating. The values retrieved from the database must match the values
    provided by the user (via an authentication mechanism, covered later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Most secured applications have different types of users separated into roles,
    for example, an application could have "regular" users plus administrators. Administrators
    would be allowed to perform certain actions that regular users would not. For
    example, administrators could be able to reset user passwords and add or remove
    users from the system. The `groupsQuery` attribute of `@DatabaseIdentityStoreDefinition`
    allows us to retrieve all roles for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an identity store stored in an LDAP database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To secure resources against credentials stored in an LDAP database, we need
    to annotate the resource to be secured (such as a servlet or JAX-RS RESTful web
    service) with the `@LdapIdentityStoreDefinition` annotation, the following example
    illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `url` attribute of `@LdapIdentityStoreDefinition` is used to specify the
    URL of the LDAP server containing user credentials for our application, its `callerBaseDn`
    attribute is used to specify the LDAP base-distinguished name to verify user credentials
    supplied by the user. Finally, its `groupSearchBase` attribute is used to retrieve
    the roles for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Custom identity stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, we may need to integrate our application security with an identity
    store not directly supported by the security API, for example, we may have a requirement
    to integrate with an existing commercial security product. For cases like this,
    the Java EE security API allows us to roll our own identity store definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle custom identity stores, we need to create an application-scoped CDI
    bean; the bean must implement the `IdentityStore` interface, as illustrated in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `validate()` method is defined in the `IdentityStore` interface provided
    by the security API; in our example, we implement this method so that we can implement
    custom validation for our application.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are hardcoding valid credentials into the code, do not do
    this for real applications!
  prefs: []
  type: TYPE_NORMAL
- en: The `validate()` method defined in the `IdentityStore` interface accepts an
    instance of a class implementing the `Credential` interface as its sole argument.
    In the body of our method, we cast it down to `UserNamePasswordCredential`, then
    we invoke its `compareTo()` method, passing the expected username and password.
    If the provided credentials match either one of the expected sets of credentials,
    then we allow the user to successfully log in; we do this by returning an instance
    of `CredentialValidationResult` containing the username and a `Set` containing
    all the roles that the user has in our application.
  prefs: []
  type: TYPE_NORMAL
- en: If the supplied credentials don't match either of the expected credentials,
    then we prevent the user from logging in by returning `CredentialValidationResult.INVALID_RESULT`.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication mechanisms provide a way for the user to provide their credentials
    so that they can be authenticated against an identity store.
  prefs: []
  type: TYPE_NORMAL
- en: The Java EE 8 Security API provides support for basic HTTP authentication, a
    standard authentication mechanism supported by most web browsers, as well as form
    authentication, where users provide their credentials via an HTML form. Form authentication,
    by default, submits a form to a security servlet provided by the Java EE implementation.
    If we need more flexibility or to better align with other Java EE technologies,
    the security API provides custom form authentication as well, which allows us,
    as application developers, to have more control over how to authenticate users
    attempting to access our application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic authentication mechanisms can be achieved by annotating the resource
    to secure (that is, a servlet or JAX-RS RESTful web service) with the `@BasicAuthenticationMechanismDefinition`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `realmName` attribute of the `@BasicAuthenticationMechanismDefinition`
    annotation will be sent to the browser in the `WWW-Authenticate` response header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using basic authentication will cause the browser to pop up a window asking
    for a User Name and a Password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/730b4861-a2d8-4f02-8ee3-24755e5695f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the user enters the correct credentials, then access is granted to the
    protected resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac27f484-9430-4bb0-9ae6-e6a27e7e4704.png)'
  prefs: []
  type: TYPE_IMG
- en: Form authentication mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way we can authenticate our users is to develop an HTML form to collect
    the user''s credentials, then delegate authentication to the Java EE Security
    API. The first step when following this approach is to develop an HTML page where
    the user can log in to the application, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the example, the HTML form used for logging in must submit an HTTP
    POST request, the value for its `action` attribute must be `j_security_check`.
    `j_security_check` maps to a servlet provided by the Java EE Security API, we
    don't need to develop any validation logic ourselves. The form must have a couple
    of input fields, one for the username and one for the password, names for these
    fields must be `j_username` and `j_password`, respectively; the security servlet
    provided by the Java EE API will retrieve these values and authenticate the user
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we need to provide an HTML page where the user will be redirected
    if login fails. The page can have any valid HTML markup; in our example, we simply
    provide an error message and a link to direct the user back to the login page
    so that they can try to log in again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, all we need to do is annotate the secured resource with
    the `@FormAuthenticationMechanismDefinition` annotation, which will let the Java
    EE Security API know we are using form-based authentication, and what HTML pages
    to use to log in or to display when logging in fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `@FormAuthenticationMechanismDefinition` annotation has a required `loginToContinue`
    attribute; the value of this attribute must be an instance of the `@LoginToContinue`
    annotation. `@LoginToContinue` has two required attributes, `loginPage` and `errorPage`;
    the value of these attributes must indicate the path for the login page, and the
    path of the page to display in case of authentication failure, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building and deploying our code, then attempting to access a protected
    resource, the user is automatically redirected to our login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04353674-1648-445d-99d7-59a4a19ac00b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the user enters the correct credentials, then access to the protected resource
    is granted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02ee8247-c7ed-4b3e-a7f3-314b8b4dbb17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If invalid credentials are entered, then the user is directed to our error
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08c05df8-e57d-4a10-94c7-9b3d0a243295.png)'
  prefs: []
  type: TYPE_IMG
- en: Custom form authentication mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way we can authenticate users in our application is to use a custom
    form authentication mechanism; this type of authentication mechanism is useful
    when we want to integrate our application with a web framework, such as JSF. In
    our next example, we will illustrate how to do just that, integrating the Java
    EE Security API with JSF, via custom form authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use custom form authentication in our applications, we need to use the aptly
    named `@CustomFormAuthenticationMechanismDefinition` annotation, as illustrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like the `@FormAuthenticationMechanismDefinition` annotation we saw previously,
    the `@CustomFormAuthenticationMechanismDefinition` annotation has a `loginToContinue`
    attribute that takes an instance of the `@LoginToContinue` annotation as its value.
    In this case, since we are integrating with JSF, the value of the `loginPage`
    attribute of `@LoginToContinue` must point to the path of a Facelets page used
    for the user to log in. When using JSF to authenticate the user, it is expected
    that the login page will display an error message if authentication fails, therefore
    we need to leave the `errorPage` attribute of `@LoginToContinue` blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our login page is a standard Facelets page that collects user credentials and
    redirects to a CDI bean that acts as a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our login page has input fields for username and password; it stores those
    values into a CDI named bean (not shown as it is trivial) via value-binding expressions.
    When the user clicks on the Login button, controls go to a `LoginController` CDI
    named bean that performs the actual authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our `LoginController` class, we need to inject an instance of `javax.security.enterprise.SecurityContext`,
    since we will need it for authentication. Our `login()` method is where we implement
    the authentication logic. The first thing we need to do is create an instance
    of `UsernamePasswordCredential`, passing the user-entered username and password
    as parameters to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an instance of `javax.security.enterprise.authentication.mechanism.http.AuthenticationParameters`,
    by invoking the static `withParams()` method on `AuthenticationParameters`, then
    invoking the `credential()` method on the resulting instance of `AuthenticationParameters`.
    We then pass the instance of `UserNamePasswordCredential` we just created as a
    parameter; this returns yet another instance of `AuthenticationParameters`, which
    we can use to actually validate the user-entered credentials.
  prefs: []
  type: TYPE_NORMAL
- en: We validate user-entered credentials by invoking the `authenticate()` method
    on our `SecurityContext` instance, passing the HTTP Request and Response objects
    as parameters, as well as the instance of `AuthenticationParameters` containing
    the user-entered credentials. This method invocation will return an instance of
    `AuthenticationStatus`, we need to check the returned instance to determine whether
    the user entered valid credentials.
  prefs: []
  type: TYPE_NORMAL
- en: If `SecurityContext.authenticate()` returns `AuthenticationStatus.SEND_CONTINUE`,
    then the user-entered credentials were valid and we can allow the user to access
    the requested resource. If, instead, the method returns `AuthenticationStatus.SEND_FAILURE`,
    then the user-entered credentials were invalid, and we need to prevent the user
    from accessing the protected resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'After deploying and running our application, when a user attempts to access
    a protected resource, they are automatically redirected to a login page, which
    in this case, since we are using custom form authentication, is implemented using
    JSF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70475373-3017-48be-8e98-12bb223766ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Entering correct credentials will direct the user to the protected resource
    (not shown) while entering incorrect credentials directs the user back to the
    login page, which should show an appropriate error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60911cf2-0330-4be3-a9dc-f9a22e70de44.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the new Security API introduced in Java EE 8\. We
    covered how we can access different types of identity stores to retrieve user
    credentials, such as relational databases or LDAP databases. We also covered how
    the security API provides the ability to integrate with custom identity stores,
    in case we need to access one that is not directly supported.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we saw how we can use different authentication mechanisms to allow
    access to our secured Java EE applications. This included how to implement the
    basic authentication mechanism provided by all web browsers, as well as how to
    implement form-based authentication mechanisms, where we provide custom HTML pages
    used for authentication. Additionally, we saw how we can use the custom form authentication
    mechanism provided by the security API so that we can integrate our application
    security with a web framework such as JSF.
  prefs: []
  type: TYPE_NORMAL
