- en: Getting Started with Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9入门
- en: You want to learn Java and you have a good reason for it. Java is a modern and
    well-established application programming language, which is widely used in many
    industries, be it telecommunication, finance, or something else. Java developer
    positions are the most numerous and, probably, the best paid. This, among other
    things, makes the language lucrative for young professionals to learn. On the
    other hand, this is not without reason. Java language, the tools, and the whole
    infrastructure around it is complex and compound. Becoming a Java professional
    does not happen in a day or week; it is a work of many years. To be a Java expert,
    you need to know not only about the programming language but also about object-oriented
    programming principles, open source libraries, application servers, network, databases,
    and many other things that you can become an expert in. Nevertheless, learning
    the language is an absolute must that all other practices should build on. Through
    this book, you will be able to learn Java version 9 and a bit more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你想学习Java，并且你有一个很好的理由。Java是一种现代且成熟的编程语言，在许多行业中广泛使用，无论是电信、金融还是其他行业。Java开发者的职位数量最多，可能也是薪酬最高的。这使语言对年轻专业人士来说具有吸引力。另一方面，这并非没有原因。Java语言、工具以及围绕它的整个基础设施都是复杂和综合的。成为一名Java专业人士不是一天或一周就能发生的；这是一项多年的工作。要成为Java专家，你需要了解的不仅仅是编程语言，还包括面向对象编程原则、开源库、应用服务器、网络、数据库以及你可以成为专家的许多其他事物。尽管如此，学习语言是绝对必须的，所有其他实践都应建立在它之上。通过这本书，你将能够学习Java版本9以及更多内容。
- en: 'In this chapter, you will be introduced to the Java environment and given step-by-step
    instructions on how to install it, edit sample code, compile, and run Java. You
    will get acquainted with the basic tools that help development, be they are a
    part of Java or are provided by other vendors. We will cover the following topics
    in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解Java环境，并获得如何安装它、编辑示例代码、编译和运行Java的逐步指导。您将熟悉帮助开发的基本工具，无论是Java的一部分还是由其他供应商提供的。本章将涵盖以下主题：
- en: Introduction to Java
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java简介
- en: Installing Windows, Linux, and Mac OS X
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Windows、Linux和Mac OS X
- en: Executing `jshell`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`jshell`
- en: Using other Java tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他Java工具
- en: Using integrated development environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集成开发环境
- en: Getting started with Java
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java入门
- en: It is like going through a path in a forest. You can focus on the gravel of
    the road but it is pointless. Instead, you can enjoy the view, the trees, the
    birds, and the environment around you, which is more enjoyable. This book is similar
    as I won't be focusing only on the language. From time to time, I will cover topics
    that are close to the road and will give you some overview and directions on where
    you can go further after you finish this book. I will not only teach you the language
    but also talk a bit about algorithms, object-oriented programming principles,
    tools that surround Java development, and how professionals work. This will be
    mixed with the coding examples that we will follow. Lastly, the final chapter
    will be fully devoted to the topic, what to learn next and how to go further to
    become a professional Java developer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在森林中走一条路。你可以专注于道路上的砾石，但这毫无意义。相反，你可以欣赏周围的环境，树木、鸟儿和周围的环境，这会更加愉快。这本书也是类似的，因为我不会只关注语言。不时地，我会涉及与道路接近的主题，并在你完成这本书后，给你一些概述和方向，告诉你可以进一步探索的地方。我不会只教你语言，还会稍微谈谈算法、面向对象编程原则、围绕Java开发的工具以及专业人士是如何工作的。这将会与我们将要遵循的编码示例混合在一起。最后，最后一章将完全致力于这个主题，即接下来要学习什么以及如何进一步成为专业的Java开发者。
- en: 'By the time this book gets into print, Java will have completed 22 years. [http://www.oracle.com/technetwork/java/javase/overview/javahistory-index-198355.html](http://www.oracle.com/technetwork/java/javase/overview/javahistory-index-198355.html).
    The language has changed a lot during this period and got better. The real question
    to ask is not how long has it been here, but rather how long will it stay? Is
    it still worth learning this language? There are numerous new languages that have
    been developed since Java was born ([http://blog.takipi.com/java-vs-net-vs-python-vs-ruby-vs-node-js-who-reigns-the-job-market/](http://blog.takipi.com/java-vs-net-vs-python-vs-ruby-vs-node-js-who-reigns-the-job-market/)).
    These languages are more modern and have functional programming features, which,
    by the way, Java has also had since version 8\. Many say that Java is the past—the
    future is Scala, Swift, Go, Kotlin, JavaScript, and so on. You can add many other
    languages to this list, and for each, you can find a blog article that celebrates
    the burial of Java. There are two answers to this concern-one is a pragmatic business
    approach, the other is more engineering:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书印刷的时候，Java 将已经完成了 22 年的历史。[http://www.oracle.com/technetwork/java/javase/overview/javahistory-index-198355.html](http://www.oracle.com/technetwork/java/javase/overview/javahistory-index-198355.html)。在这段时间里，这种语言发生了很大的变化，并且变得更加完善。真正需要问的问题不是它已经存在了多久，而是它还能持续多久？学习这种语言是否仍然值得？自从
    Java 诞生以来，已经发展出了许多新的语言([http://blog.takipi.com/java-vs-net-vs-python-vs-ruby-vs-node-js-who-reigns-the-job-market/](http://blog.takipi.com/java-vs-net-vs-python-vs-ruby-vs-node-js-who-reigns-the-job-market/))。这些语言更加现代，并且具有函数式编程特性，顺便说一句，Java
    从版本 8 开始也拥有了这些特性。许多人认为 Java 已经是过去式——未来属于 Scala、Swift、Go、Kotlin、JavaScript 等语言。你可以将许多其他语言添加到这个列表中，并且对于每一种语言，你都可以找到一篇庆祝
    Java 被埋葬的博客文章。对于这种担忧，有两种答案——一种是务实的商业方法，另一种则是更偏向于工程：
- en: Considering that COBOL is still actively used in the finance industry and COBOL
    developers are perhaps better paid than Java developers, it is not too risky to
    say that as a Java developer, you will find positions in the next 40 years. Personally,
    I would bet more than a 100 years, but considering my age, it will not be fair
    predicting more than 20 to 40 years ahead.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到 COBOL 仍然在金融行业中积极使用，并且 COBOL 开发者的收入可能比 Java 开发者更高，所以说作为一名 Java 开发者，你将在接下来的
    40 年内找到职位并不太冒险。就我个人而言，我愿意赌超过 100 年，但考虑到我的年龄，预测超过 20 到 40 年之后可能并不公平。
- en: Java is not only a language; it is also a technology that you will learn a bit
    about from this book. The technology includes the **Java Virtual Machine** (**JVM**),
    which is usually referred to as JVM, and gives the runtime environment for many
    languages. Kotlin and Scala, for example, cannot run without JVM. Even if Java
    will be adumbrated, JVM will still be a number one player in the enterprise scene.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 不仅仅是一种语言；它也是一种技术，你将从这本书中了解到一些关于它的内容。这项技术包括 **Java 虚拟机**（**JVM**），通常被称为
    JVM，并为许多语言提供了运行时环境。例如，Kotlin 和 Scala 无法在没有 JVM 的情况下运行。即使 Java 将被边缘化，JVM 仍然在企业场景中占据着领先地位。
- en: To understand and learn the basic operation of JVM is almost as important as
    the language itself. Java is a compiled and interpreted language. It is a special
    beast that forges the best of both worlds. Before Java, there were interpreted
    and compiled languages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和学习 JVM 的基本操作几乎和语言本身一样重要。Java 是一种编译和解释型语言。它是一种结合了两者最佳特性的特殊生物。在 Java 之前，存在解释型语言和编译型语言。
- en: Interpreted languages are read from the source code by the interpreter and then
    the interpreter executes the code. In each of these languages, there is some preliminary
    lexical and syntax analysis step; however, after that, the interpreter, which,
    as a program itself, is executed by the processor and the interpreter continuously,
    interprets the program code to know what to do. Compiled languages are different.
    In such a case, the source code is compiled to binary (`.exe` file on Windows
    platforms), which the operating system loads and the processor directly executes.
    Compiled programs usually run faster, but there is usually a slower compilation
    phase that may make the development slower, and the execution environment is not
    so flexible. Java combined the two approaches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言是由解释器从源代码中读取，然后解释器执行代码。在这些语言中的每一个，都有一个初步的词法和语法分析步骤；然而，在那之后，作为程序本身的解释器由处理器执行，并且解释器持续不断地解释程序代码以了解应该做什么。编译型语言则不同。在这种情况下，源代码被编译成二进制（在
    Windows 平台上是 `.exe` 文件），操作系统加载并直接执行。编译型程序通常运行得更快，但通常有一个较慢的编译阶段，可能会使开发速度变慢，并且执行环境不太灵活。Java
    结合了这两种方法。
- en: To execute a Java program, the Java source code has to be compiled to the JVM
    byte code (`.class` file), which is loaded by JVM and is interpreted or compiled.
    Hmm... is it interpreted or compiled? The thing that came with Java is the **Just
    in Time (JIT)** compiler. This makes the phase of the compilation that is calculation-intensive
    and the compilation for compiled languages relatively slow. JVM first starts to
    interpret the Java byte code and, while doing that, it keeps track of execution
    statistics. When it gathers enough statistics about code executions, it compiles
    to native code (for example, x86 code on an Intel/AMD platform) for direct execution
    of the parts of code that are executed frequently and keeps interpreting the code
    fragments that are rarely used. After all, why waste expensive CPU time to compile
    some code that is hardly ever used? (For example, code that reads configuration
    during startup and does not execute again unless the application server is restarted.)
    Compilation to the byte code is fast and code generation is done only for the
    segments that pay off.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行Java程序，Java源代码必须编译成JVM字节码（`.class`文件），然后由JVM加载并解释或编译。嗯...它是解释还是编译？Java附带的是**即时编译（JIT）**器。这使得计算密集型的编译阶段和编译语言相对较慢。JVM首先开始解释Java字节码，在执行这一过程的同时，它还会跟踪执行统计信息。当它收集到足够的代码执行统计信息时，它会编译成本地代码（例如，在Intel/AMD平台上的x86代码）以直接执行频繁执行的代码部分，并继续解释很少使用的代码片段。毕竟，为什么浪费昂贵的CPU时间来编译一些几乎从未使用过的代码呢？（例如，在启动时读取配置并在应用程序服务器重新启动之前不再执行的代码。）编译到字节码是快速的，并且只为有回报的代码段生成代码。
- en: It is also interesting that JIT uses the statistics of the code execution to
    optimize the code. If, for example, it sees that some conditional branch is executed
    in 99% of the cases and the other branch is executed only in 1%, then it will
    generate native code that runs fast, thus favoring the frequent branch. If the
    behavior of that part of the program changes by time and the statistic shows that
    the ratios changed, the JIT automatically recompiles the byte code from time to
    time. This is all automatic and behind the scenes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有趣的是，即时编译（JIT）利用代码执行的统计数据来优化代码。例如，如果它看到某个条件分支在99%的情况下被执行，而另一个分支只在1%的情况下被执行，那么它将生成运行快速的本地代码，从而优先考虑频繁执行的分支。如果该程序部分的行性行为随时间变化，并且统计数据表明比率发生了变化，JIT会自动定期重新编译字节码。这一切都是自动的，并且是在幕后进行的。
- en: In addition to the automatic compilation, there is also an extremely important
    feature of JVM-it manages the memory for the Java program. The execution environment
    of modern languages do that and Java was the first mainstream language that had
    an automatic garbage collection (GC). Before Java, I was programming in C for
    20 years and it was a great pain to keep track of all memory allocation and not
    to forget to release the memory when the program no longer needed it. Forgetting
    memory allocation at a single point in the code and the long running program was
    eating up all memory slowly. Such problems practically ceased to exist in Java.
    There is a price that we have to pay for it—GC needs processor capacity and some
    extra memory, but that is something we are not short of in most of the enterprise
    applications. Some special programs, like real-time embedded systems that control
    the brakes of a heavy-duty lorry may not have that luxury. Those are still programmed
    in assembly or C. For the rest of us, we have Java, and though it may seem strange
    for many professionals, even *almost-real-time* programs, such as high-frequency
    trading applications, are written in Java.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动编译之外，JVM还有一个极其重要的特性——它管理Java程序的内存。现代语言的执行环境都这样做，Java是第一个主流具有自动垃圾回收（GC）功能的语言。在Java之前，我用了20年的时间在C语言编程，跟踪所有内存分配并确保在程序不再需要时释放内存是一件非常痛苦的事情。在代码的某个点上忘记内存分配，以及长时间运行的程序会慢慢消耗所有内存。这些问题在Java中实际上已经不存在了。我们必须为此付出代价——GC需要处理器容量和一些额外的内存，但在大多数企业应用程序中，我们并不缺少这些。一些特殊的程序，如控制重型卡车刹车的实时嵌入式系统可能没有这样的奢侈。这些程序仍然使用汇编或C语言编写。对于我们其他人来说，我们有Java，尽管对于许多专业人士来说这可能看起来很奇怪，甚至*几乎实时*的程序，如高频交易应用程序，也是用Java编写的。
- en: These applications connect through the network to the stock exchange and they
    sell and buy stocks responding to market change in milliseconds. Java is capable
    of doing that. The runtime environment of Java that you will need to execute a
    compiled Java code, which also includes the JVM itself, contains code that lets
    Java programs access the network, files on disks, and other resources. To do this,
    the runtime contains high-level classes that the code can instantiate, execute,
    and which do the low-level jobs. You will also do this. It means that the actual
    Java code does not need to handle IP packets, TCP connections, or even HTTP handling
    when it wants to use or provide a REST service in some microservices architecture.
    It is already implemented in the runtime libraries, and all the application programmer
    has to do is to include the classes in the code and use the APIs they provide
    on an abstraction level that matches the program. When you program in Java, you
    can focus on the actual problem you want to solve, which is the *business* code
    and not the low-level system code. If it is not in the standard library, you will
    find it in some product in some external library, and it is also very probable
    that you will find an open source solution for the problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序通过网络连接到证券交易所，并以毫秒级的速度买卖股票，以响应市场变化。Java 能够做到这一点。Java 的运行时环境，您需要用它来执行编译后的
    Java 代码，这还包括 JVM 本身，其中包含允许 Java 程序访问网络、磁盘上的文件和其他资源的代码。为此，运行时包含高级类，代码可以实例化、执行，并完成底层工作。您也将这样做。这意味着实际的
    Java 代码在想要使用或提供 REST 服务时，不需要处理 IP 数据包、TCP 连接，甚至 HTTP 处理。这些功能已经在运行时库中实现，应用程序程序员只需在代码中包含这些类，并在与程序匹配的抽象级别上使用它们提供的
    API。当您用 Java 编程时，可以专注于您想要解决的真正问题，即业务代码，而不是底层系统代码。如果它不在标准库中，您可以在某些外部库的某个产品中找到它，而且很可能您还会找到一个针对该问题的开源解决方案。
- en: 'This is also a strong point of Java. There is a vast number of open source
    libraries available for all the different purposes. If you cannot find a library
    fitting your problem if you start to code some low-level code, then probably you
    are doing something wrong. There are topics in this book that are important, such
    as class loaders or reflection, not because you have to use them every day but
    rather because they are used by frameworks, and knowing them helps understand
    how these frameworks work. If you cannot solve your problem without using reflection
    or writing your own class loader or program multithread directly, then you probably
    chose the wrong framework. There is almost certainly a good one: Apache project,
    Google, and many other important players in the software industry publish their
    Java libraries as open source.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是 Java 的一个优点。有大量的开源库可供各种用途使用。如果您在开始编写底层代码时找不到适合您问题的库，那么可能您正在做错事。这本书中有一些重要的话题，例如类加载器或反射，不是因为您每天都需要使用它们，而是因为它们被框架使用，了解它们有助于理解这些框架的工作原理。如果您不使用反射或编写自己的类加载器或直接编写多线程程序就无法解决问题，那么您可能选择了错误的框架。几乎肯定有一个好的选择：Apache
    项目、Google 以及软件行业中的许多其他重要参与者都将他们的 Java 库作为开源发布。
- en: This is also true for multithread programming. Java is a multithread programming
    environment from the very beginning. The JVM and the runtime supports programs
    that execute the code. The execution runs parallel on multiple threads. There
    are runtime language constructs that support parallel executing programs starting
    at the very low level to high abstraction. Multithread code utilizes the multicore
    processors, which are more effective. These processors are more and more common.
    20 years ago, only high-end servers had multiple processors and only Digital Alpha
    processors had 64-bit architecture and CPU clock above 100 MHz. 10 years ago,
    multiprocessor structure was common on the server side, and about 5 years ago,
    multicore processors were on some desktops and on notebooks. Today, even mobile
    phones have them. When Java was started in 1995, the geniuses who created it had
    seen this future.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于多线程编程。Java从一开始就是一个多线程编程环境。JVM和运行时支持执行代码的程序。执行在多个线程上并行运行。有一些运行时语言结构支持从非常低级到高抽象级别的并行执行程序。多线程代码利用多核处理器，这更加高效。这些处理器越来越普遍。20年前，只有高端服务器才有多个处理器，只有Digital
    Alpha处理器具有64位架构和超过100 MHz的CPU时钟。10年前，服务器端普遍采用多处理器结构，大约5年前，多核处理器出现在一些台式机和笔记本电脑上。今天，甚至移动电话也有。当Java在1995年开始时，创造它的天才们已经看到了这个未来。
- en: They envisioned Java to be a *write once, run anywhere* language. At that time,
    the first target for the language was applet running in the browser. Today, many
    think (and I also share this opinion) that applets were a wrong target, or at
    least things were not done in the right way. As for now, you will meet applets
    on the Internet less frequently than Flash applications or dinosaurs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '他们设想Java是一种*一次编写，到处运行*的语言。在当时，该语言的首要目标是运行在浏览器中的applet。如今，许多人（我也持有这种观点）认为applet是一个错误的目标，或者至少事情并没有以正确的方式进行。至于现在，您在互联网上遇到applet的频率比Flash应用程序或恐龙要低。 '
- en: However, at the same time, the Java interpreter was also executing server and
    client applications without any browser; furthermore, as the language and the
    executing environment developed, these application areas became more and more
    relevant. Today, the main use of Java is enterprise computing and mobile applications
    mainly for the Android platform; for the future, the use of the environment is
    growing in embedded systems as the **Internet of things** (**IoT**) comes more
    and more into picture.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与此同时，Java解释器也在没有任何浏览器的情况下执行服务器和客户端应用程序；此外，随着语言和执行环境的发展，这些应用领域变得越来越相关。如今，Java的主要用途是企业计算和移动应用程序，主要是Android平台；对于未来，随着物联网（**IoT**）越来越成为焦点，该环境在嵌入式系统中的使用也在增长。
- en: Installing Java
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Java
- en: To develop, compile, and execute Java programs, you will need the Java execution
    environment. As the operating systems that we usually use for software development
    do not contain the language preinstalled, you will have to download it. Although,
    there is multiple implementation of the language, I recommend that you download
    the official version of the software from Oracle. The official site for java is
    [http://java.com](http://java.com) and this is the site from where the latest
    release of the language can be downloaded. At the time of writing this book, the
    9th version of Java is not yet released. An early pre-release version is accessible
    via [http://jdk9.java.net/](http://jdk9.java.net/)download. Later the release
    versions will also be available from here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发、编译和执行Java程序，您将需要Java执行环境。由于我们通常用于软件开发的操作系统没有预先安装该语言，您将不得不下载它。尽管有多个语言的实现，但我建议您从Oracle下载软件的官方版本。Java的官方网站是[http://java.com](http://java.com)，您可以从这里下载语言的最新版本。在撰写本书时，Java的第九版尚未发布。一个早期预发布版本可以通过[http://jdk9.java.net/](http://jdk9.java.net/)下载。稍后，发布版本也将从这里提供。
- en: '![](img/00005.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: What you can download from here is a so called early access version of the code
    that is available only to experiment with it, and no professionals should use
    it for real professional purposes
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里下载的被称为早期访问版本的代码，仅供实验使用，任何专业人士都不应将其用于真正的专业目的
- en: On the page, you have to click on the radio button to accept the license. After
    that, you can click on the link that directly starts the download of the installation
    kit. The license is a special early access license version that you, as a professional,
    should carefully read, understand, and accept only if you are agreeable with the
    terms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在该页面上，您必须点击单选按钮以接受许可协议。之后，您可以点击链接，直接开始下载安装包。该许可协议是一个特殊的早期访问许可版本，您作为专业人士应仔细阅读、理解，并且只有在您同意条款的情况下才接受。
- en: There is a separate installation kit for Windows 32 and 64 bit systems, Mac
    OS X, Linux 32 and 64 bit versions, Linux for ARM processor, Solaris for SPARC
    processor systems, and Solaris x86 versions. As it is not likely that you will
    use Solaris, I will detail the installation procedure only for Windows, Linux,
    and Mac OS X. In later chapters, the samples will always be Mac OS X, but since
    Java is a *write once, run anywhere* language, there is no difference after the
    installation. The directory separator may be slanted differently, the classpath
    separator character is a semicolon on Windows instead of a colon, and the look
    and feel of the Terminal or command application is also different. However, where
    it is important, I will try not to forget to mention it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有针对Windows 32位和64位系统、Mac OS X、Linux 32位和64位版本、适用于ARM处理器的Linux、适用于SPARC处理器系统的Solaris以及Solaris
    x86版本的单独安装包。由于您不太可能使用Solaris，我将仅详细说明Windows、Linux和Mac OS X的安装过程。在后面的章节中，示例将始终是Mac
    OS X，但既然Java是一种“一次编写，到处运行”的语言，安装后没有区别。目录分隔符可能不同，Windows上的类路径分隔符是分号而不是冒号，终端或命令应用程序的外观和感觉也可能不同。然而，在重要的情况下，我会尽力不忘记提及。
- en: To confuse you, the Java download for each of these operating system versions
    lists a link for the JRE and one for the JDK. **JRE** stands for **Java Runtime
    Environment** and it contains all the tools and executables that are needed to
    run Java programs. **JDK** is the **Java Development Kit** that contains all the
    tools and executables that are needed to develop Java programs including the execution
    of the Java program. In other words, JDK contains its own JRE. For now, all you
    need to do is download the JDK.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您感到困惑，每个操作系统版本的Java下载都列出了JRE和JDK的链接。**JRE**代表**Java运行环境**，它包含运行Java程序所需的所有工具和可执行文件。**JDK**是**Java开发工具包**，它包含开发Java程序所需的所有工具和可执行文件，包括Java程序的执行。换句话说，JDK包含自己的JRE。目前，您只需要下载JDK。
- en: 'There is one important point of the installation that is the same on each of
    the three operating systems that you have to be prepared for before the installation:
    to install Java, you should have administrative privileges.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，有一个重要的点在三个操作系统上都是相同的，您在安装前必须做好准备：安装Java，您应该有管理员权限。
- en: Installation on Windows
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows上的安装
- en: The installation process on Windows starts by double clicking on the downloaded
    file. It will start the installer that will present you a welcome screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的安装过程是从双击下载的文件开始的。它将启动安装程序，显示欢迎界面。
- en: '![](img/00006.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: Pressing the Next button we get a window where you can select the parts you
    want to install. Let's leave here the default selection, which means that we install
    all the downloaded parts of Java and press the button Next. The following window
    is where we can select the destination folder for the installation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按下“下一步”按钮，我们会得到一个窗口，您可以在其中选择要安装的部分。让我们保留默认选择，这意味着我们将安装下载的所有Java部分，然后按下“下一步”按钮。下一个窗口是我们选择安装目标文件夹的地方。
- en: '![](img/00007.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: As for now we do not change the directory selected by the installer. Press Next.
    Later, when you become a professional Java developer, you may decide to install
    Java to a different location but then you will already have to know what you are
    doing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，我们不更改安装程序选择的目录。按“下一步”。稍后，当您成为一名专业的Java开发者时，您可能决定将Java安装到不同的位置，但那时您已经必须知道自己在做什么。
- en: You may need to click the Next button a few times and then the installer finishes.
    Provide the administrative password when asked and voila! Java is installed. This
    is really the very usual Windows installation process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要多次点击“下一步”按钮，然后安装程序完成。当被要求时，提供管理员密码，然后Voilà！Java已安装。这真的是非常常见的Windows安装过程。
- en: The last step is to set the environment variable `JAVA_HOME`. To do that in
    Windows we have to open the control center and select the Edit environment variables
    for your account menu.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是设置环境变量 `JAVA_HOME`。在 Windows 上，我们必须打开控制面板并选择“编辑账户环境变量”菜单。
- en: '![](img/00008.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: This will open a new window that we should use to create a new environment variable
    for the current user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新窗口，我们应该使用它来为当前用户创建一个新的环境变量。
- en: '![](img/00009.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00009.jpeg)'
- en: The name of the new variable has to be `JAVA_HOME` and the value should point
    to the installation directory of the JDK.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 新变量的名称必须是 `JAVA_HOME`，其值应指向 JDK 的安装目录。
- en: '![](img/00010.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: This value on most of the systems is C:Program FilesJavajdk-9\. This is used
    by many Java programs and tools to locate the Java runtime.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统中，此值是 C:Program FilesJavajdk-9\. 这被许多 Java 程序和工具用来定位 Java 运行时。
- en: Installation on MAC OS X
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAC OS X 上的安装
- en: In this section, we will take look at how to install Java step-by-step on an
    OS X platform. I will describe the installation process for the released version
    available at the time of writing this book. As for now, the Java 9 early access
    version is a bit tricky to install. It is probable that version Java 9 will have
    similar or the same install steps as Java 8 update 92 has.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步介绍如何在 OS X 平台上安装 Java。我将描述本书编写时发布的版本安装过程。至于现在，Java 9 预览版安装可能有些棘手。很可能
    Java 9 版本的安装步骤与 Java 8 更新 92 相似或相同。
- en: The OS X version of Java comes in the form of a `.dmg` file. This is a packaging
    format of OS X. To open it, simply double click on the file in the `Download`
    folder where the browser saves it and the operating system will mount the file
    as a read-only disk image.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OS X 版本的 Java 以 `.dmg` 文件的形式提供。这是 OS X 的打包格式。要打开它，只需在浏览器保存文件的 `下载` 文件夹中双击文件，操作系统将文件挂载为只读磁盘镜像。
- en: '![](img/00011.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00011.jpeg)'
- en: 'There is only one file on this disk: the installation image. Double click on
    the file name or icon in the Finder application and the installation process will
    start.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该磁盘上只有一个文件：安装镜像。在 Finder 应用程序中双击文件名或图标，安装过程将开始。
- en: '![](img/00012.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: The first screen opening is a welcome screen. Click Continue and you will see
    the Summary page that displays what will be installed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首次打开的屏幕是欢迎屏幕。点击继续，您将看到显示将要安装内容的摘要页面。
- en: 'It is not a surprise that you will see a standard Java installation. This time,
    the button is called Install. Click on it and you will see the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到一个标准的 Java 安装并不奇怪。这次，按钮的名称是安装。点击它，您将看到以下内容：
- en: '![](img/00013.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00013.jpeg)'
- en: This is the time when you have to provide the login parameters for the administrative
    user—a username and password. When provided, installation starts and, in a few
    seconds, you will see a Summary page.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您必须提供管理员用户登录参数（用户名和密码）的时候。提供后，安装开始，几秒钟后，您将看到一个摘要页面。
- en: '![](img/00014.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00014.jpeg)'
- en: Click Close and you are ready. You have Java installed on your Mac. Optionally,
    you can dismount the installation disk and, sometime later, you can also delete
    the `.dmg` file. You will not need that, and in case you do, you can download
    it any time from Oracle.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 点击关闭，您就准备好了。您已经在您的 Mac 上安装了 Java。可选地，您可以卸载安装磁盘，稍后也可以删除 `.dmg` 文件。您不需要它，如果您需要，您可以从
    Oracle 下载它。
- en: The last thing is to check whether the installation was okay. Proof of the pudding
    is eating it. Start a Terminal window and type `java -version` at the prompt and
    Java will tell you the version installed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要检查安装是否成功。实践是检验真理的唯一标准。启动一个终端窗口，在提示符下输入 `java -version`，Java 将告诉您已安装的版本。
- en: 'On the next screenshot you can see the output on my workstation and also the
    Mac OS commands that are handy to switch between the different versions of Java:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张屏幕截图中，您可以看到我的工作站上的输出以及切换不同 Java 版本时有用的 Mac OS 命令：
- en: '![](img/00015.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00015.jpeg)'
- en: On the screenshot, you can see that I have installed the Java JDK 1.8u92 version
    and, at the same time, I also have a Java 9 early release installation, which
    I will use to test the new features of Java for this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕截图中，您可以看到我已经安装了 Java JDK 1.8u92 版本，同时，我还安装了一个 Java 9 预发布版本，我将用它来测试本书中 Java
    的新特性。
- en: Installation on Linux
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 上的安装
- en: There are several ways to install Java on Linux, depending on its flavor. Here,
    I will describe an installation method that works more or less the same way on
    all flavors. The one I used is Debian.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Linux的版本，有几种方法可以在Linux上安装Java。在这里，我将描述一种在所有版本上大致相同的方法。我使用的是Debian。
- en: 'First step is the same as in any other operating system: download the installation
    kit. In the case of Linux, you should select a package that has a `tar.gz` ending.
    This is a compressed archive format. You should also carefully select the package
    that matches the processor in your machine and the 32/64 bit version of the operating
    system. After the package is downloaded, you have to switch to root mode, issuing
    the `su` command. This the first command you can see on the screenshot that shows
    the installation commands.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步与其他任何操作系统相同：下载安装包。在Linux的情况下，您应该选择以`tar.gz`结尾的包。这是一种压缩归档格式。您还应该仔细选择与您的机器处理器和操作系统的32/64位版本相匹配的包。下载完包后，您必须切换到root模式，发出`su`命令。这是截图上显示的安装命令中的第一个命令。
- en: '![](img/00016.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00016.jpeg)'
- en: The `tar` command uncompressed the archive into a subfolder. In Debian, this
    subfolder has to be moved to `/opt/jdk` and the `mv` command is used for this
    purpose. The two `update-alternatives` command is Debian-specific. These tell
    the operating system to use this newly installed Java in case there is already
    an older Java installed. The Debian I was using to test and demonstrate the installation
    process on a virtual machine came with a 7 year old version of Java.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar`命令将归档解压缩到子文件夹中。在Debian中，此子文件夹必须移动到`/opt/jdk`，并使用`mv`命令来完成此操作。这两个`update-alternatives`命令是Debian特有的。这些告诉操作系统，如果已经安装了较旧的Java，则使用新安装的Java。我用来在虚拟机上测试和演示安装过程的Debian带有7年前的Java版本。'
- en: 'The final step of the installation is the same as any other operating system:
    checking that the installation was successful in issuing the `java -version` command.
    In the case of Linux, this is even more important because the installation process
    does not check that the downloaded version matches the operating system and the
    processor architecture.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的最后一步与其他任何操作系统相同：通过发出`java -version`命令来检查安装是否成功。在Linux的情况下，这一点尤为重要，因为安装过程不会检查下载的版本是否与操作系统和处理器架构相匹配。
- en: Setting JAVA_HOME
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置JAVA_HOME
- en: The `JAVA_HOME` environment variable plays a special role for Java. Even though
    the JVM executable, `java.exe` or `java`, is on the `PATH` (thus you can execute
    it by typing the name `java` without specifying directory on the Command Prompt)
    (Terminal), it is recommended that you use the correct Java installation to set
    this environment variable. The value of the variable should point to the installed
    JDK. There are many Java-related programs, for example, Tomcat or Maven, that
    use this variable to locate the installed and currently used Java version. In
    Mac OS X, setting this variable is unavoidable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`JAVA_HOME`环境变量在Java中扮演着特殊角色。尽管JVM可执行文件`java.exe`或`java`位于`PATH`中（因此您可以在命令提示符（终端）中通过输入名称`java`来执行它，而不需要指定目录），但建议您使用正确的Java安装来设置此环境变量。变量的值应指向已安装的JDK。有许多Java相关程序，例如Tomcat或Maven，它们使用此变量来定位已安装和当前使用的Java版本。在Mac
    OS X中，设置此变量是不可避免的。'
- en: 'In OS X, the program that starts to execute when you type `java` is a wrapper
    that first looks at `JAVA_HOME` to decide which Java version to start. If this
    variable is not set, then OS X will decide on its own, selecting from the available
    installed JDK versions. To see the available versions, you can issue the following
    command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在OS X中，当您输入`java`时开始执行的程序是一个包装器，它首先查看`JAVA_HOME`以决定启动哪个Java版本。如果此变量未设置，那么OS
    X将自行决定，从可用的已安装JDK版本中选择。要查看可用的版本，您可以发出以下命令：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will then get the list of installed JDKs. Note that the command is lowercase,
    but the option is capital. If you do not provide any options and argument to the
    program, it will simply return the JDK it thinks is the newest and most appropriate
    for the purpose. As I copied the output of the command from my Terminal window,
    you can see that I have quite a few versions of Java installed on my machine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将获得已安装JDK的列表。请注意，命令是小写的，但选项是大写的。如果您不向程序提供任何选项和参数，它将简单地返回它认为最新且最适合目的的JDK。正如我从我的终端窗口复制了命令输出一样，您可以看到我在我的机器上安装了相当多的Java版本。
- en: 'The last line of the program response is the home directory of JDK, which is
    the default. You can use this to set your `JAVA_HOME` variable using some bash
    programming:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 程序响应的最后一行是 JDK 的主目录，这是默认的。你可以使用一些 bash 编程来设置你的 `JAVA_HOME` 变量：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can place this file in your `.bashrc` file, which is executed each time
    you start Terminal application and thus `JAVA_HOME` will always be set. If you
    want to use a different version, you can use `-v`, with the lower case option
    this time, to the same utility, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个文件放在你的 `.bashrc` 文件中，每次启动终端应用程序时都会执行它，因此 `JAVA_HOME` 将始终被设置。如果你想使用不同的版本，可以使用
    `-v`（这次是小写的选项）来指定相同的实用程序，如下所示：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The argument is the version of Java you want to use. Note that this versioning
    becomes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是你想要使用的 Java 版本。请注意，这个版本号变成了：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to use Java JDK Early Access version and not 1.9, there is no explanation
    for the same—fact of life.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Java JDK 预览版而不是 1.9，对于这个事实没有解释——这就是生活。
- en: Note that there is another environment variable that is important for Java-`CLASSPATH`.
    We will talk about it later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个对 Java 很重要的环境变量——`CLASSPATH`。我们稍后会讨论它。
- en: Executing jshell
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 jshell
- en: Now that we have spent a lot of time installing Java, it is time to get the
    fingers burnt a bit. As we are using Java 9, there is a new tool that helps developers
    to play around with the language. This is a **Read-Eval-Print-Loop** (**REPL**)
    tool that many language toolsets contain and there were also implementations from
    Java, but version 9 is the first that contains this feature off the shelf.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经花费了很多时间安装 Java，现在是时候稍微烧一下手指了。因为我们使用的是 Java 9，所以有一个新的工具可以帮助开发者与语言互动。这是一个
    **读取-评估-打印-循环**（**REPL**）工具，许多语言工具集都包含这个工具，Java 也有实现，但 9 版本是第一个包含这个功能的版本。
- en: REPL is a tool that has interactive prompt and language commands that can be
    directly entered without editing some standalone file. The entered commands are
    executed directly and then the loop starts again, waiting for the user to type
    in the next command. This is a very effective tool to try out some language constructs
    without the delay of editing, compiling, and loading. The steps are automatically
    and transparently done by the REPL tool.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 是一个具有交互式提示和可以直接输入而无需编辑独立文件的命令语言的工具。输入的命令将被直接执行，然后循环再次开始，等待用户输入下一个命令。这是一个非常有效的工具，可以在不等待编辑、编译和加载的情况下尝试一些语言结构。这些步骤由
    REPL 工具自动且透明地完成。
- en: 'The REPL tool in Java 9 is called jshell. To start it, just type its name.
    If it is not on the `PATH`, then type the full path to jshell that comes installed
    with Java 9, as shown in the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中的 REPL 工具被称为 jshell。要启动它，只需输入其名称。如果它不在 `PATH` 中，那么输入与 Java 9 一起安装的 jshell
    的完整路径，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The jshell starts up in an interactive way and the prompt it displays is `jshell>`
    to help you recognize that jshell is running and what you type is read by the
    program and not the operating system shell. As this is the first time you will
    start jshell, it tells you to type `/help intro`. Let''s do it. It will print
    out a short text about what jshell is, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: jshell 以交互式方式启动，它显示的提示符是 `jshell>`，以帮助您识别 jshell 是否正在运行以及您输入的内容是否被程序读取而不是操作系统
    shell。由于这是您第一次启动 jshell，它会告诉您输入 `/help intro`。让我们试试。它将打印出有关 jshell 的简短文本，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Okay, so we can type Java snippets and `/list`, but that is only one example
    of the available commands. We can hope for more information by typing `/help`,
    as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们可以输入 Java 片段和 `/list`，但这只是可用命令的一个例子。我们可以通过输入 `/help` 来获取更多信息，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the shortest ever Hello World program in Java. Till Java 9, if you wanted
    to do nothing more than print out `Hello World!`, you had to create a program
    file. It had to contain the source code of a class including the `public static
    main` method, which contained the one line we had to type in with Java 9 jshell.
    It was cumbersome just for a simple printout of sample code. Now it is much easier
    and jshell is also lenient, forgiving us the missing semicolon at the end of the
    line.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Java 中最短的 Hello World 程序。在 Java 9 之前，如果你想做的只是打印出 `Hello World!`，你必须创建一个程序文件。它必须包含一个类的源代码，包括
    `public static main` 方法，这个方法包含了我们在 Java 9 jshell 中必须输入的那一行。仅仅为了简单的打印示例代码，这很麻烦。现在它要容易得多，jshell
    也更加宽容，允许我们在行尾省略分号。
- en: 'The next thing we should try is declaring a variable, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来应该尝试的是声明一个变量，如下所示：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We declared a variable, named `a`, and assigned the value to it-`13`. The type
    of the variable is `int`, which is an abbreviation for integer types in Java.
    Now we have this variable already in our snippet, so we can print it out if we
    want to as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为 `a` 的变量，并将其值赋给它-`13`。该变量的类型是 `int`，这是 Java 中整数类型的缩写。现在这个变量已经在我们片段中了，所以如果我们想的话可以打印出来，如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is time to write something more complex into jshell than a one liner.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在 jshell 中输入比单行更复杂的代码了。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The jshell recognizes that this is not a one-liner and that it cannot process
    what we typed so far, when we press *Enter* at the end of the first line, and
    it signals that it expects more characters from us, so it displays `...>` as a
    continuation prompt. We type in the commands that make up the whole hello world
    `main` method, but this time jshell does not let us miss the semicolon. That is
    allowed only in the case of one-line snippets. As jshell is interactive, it is
    easy to correct the mistake; press the up arrow key a few times to get back the
    previous lines and, this time, add the semicolon at the end of the second line:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: jshell 识别出这不是一条单行命令，并且它无法处理我们之前输入的内容，当我们按下第一行末尾的 *Enter* 键时，它会提示我们输入更多的字符，因此它显示
    `...>` 作为续行提示。我们输入组成整个 hello world `main` 方法的命令，但这次 jshell 不允许我们遗漏分号。这只有在单行片段的情况下才被允许。由于
    jshell 是交互式的，所以很容易纠正错误；按上箭头键几次以获取上一行，这次在第二行的末尾添加分号：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method was created for us as a snippet and now we can call it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是为我们创建的片段，现在我们可以调用它：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And it works. You can list all the snippets that were created, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实工作了。你可以列出创建的所有片段，如下所示：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And, as we want to go on writing a full Java version of *hello world*, we can
    save our work from jshell to a file, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，既然我们想要继续编写一个完整的 Java 版本的 *hello world*，我们可以将我们的工作从 jshell 保存到文件中，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we exited from jshell by typing `/exit`. As you get back to the system
    prompt, type `cat HelloWorld.java` (or `type HelloWorld.java` on Windows) to see
    the content of the file. It is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过输入 `/exit` 退出了 jshell。当你回到系统提示符时，输入 `cat HelloWorld.java`（或在 Windows
    上输入 `type HelloWorld.java`）以查看文件的内容。如下所示：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The file contains all the snippets that we typed in one after the other. If
    you think that you have messed up the shell with lots of variables and code snippets
    that you do not need anymore, you can issue the `/reset` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含我们依次输入的所有片段。如果你认为你弄乱了 shell，有很多不再需要的变量和代码片段，你可以发出 `/reset` 命令：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After this command, the jshell is as clean as when it was started earlier
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令之后，jshell 和它早期启动时一样干净
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing just does not produce anything as we deleted it all. Fortunately, we
    saved the state of jshell to a file and we can also load the content of the file
    issuing the `/open` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 仅列出不会产生任何内容，因为我们已经删除了所有内容。幸运的是，我们已经将 jshell 的状态保存到了文件中，我们也可以通过发出 `/open` 命令来加载文件的内容：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It loads the line from the file and executes it just as the characters were
    typed into the Command Prompt.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它从文件中加载行并执行它，就像字符被输入到命令提示符中一样。
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You may recall that the first command we entered was the `System.out.println`
    system call that prints out the argument to the console. When you press *Enter*
    after the `/edit 1` command, you do not get the prompt back. Instead, jshell opens
    a separate graphical editor that contains the snippet to edit as shown in the
    following image:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们输入的第一个命令是 `System.out.println` 系统调用，它将参数打印到控制台。在 `/edit 1` 命令后按下 *Enter*
    键后，你不会得到提示符。相反，jshell 打开一个包含要编辑片段的独立图形编辑器，如下所示：
- en: '![](img/00017.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00017.jpeg)'
- en: 'Edit the text in the box so that it will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑框中的文本，使其看起来像这样：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Click on Accept and then Exit. When you click on Accept, the Terminal will
    execute the snippet and display the following result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 点击接受然后退出。当你点击接受时，终端将执行片段并显示以下结果：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method that we used, `printf`, stands for formatted printing. This may be
    well known from many other languages. It was first introduced by the C language
    and though cryptic, the name survived. This is also part of the standard Java
    class, `PrintStream`, just like `println`. In case of `println`, we had to write
    `System.out` in front of the method name. In case of `printf`, we did not. Why?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 `printf` 方法代表格式化打印。这可能在许多其他语言中很常见。它最初由 C 语言引入，尽管名字晦涩，但名字保留了下来。这也是标准 Java
    类 `PrintStream` 的一部分，就像 `println` 一样。在 `println` 的情况下，我们必须在方法名前写 `System.out`。在
    `printf` 的情况下，我们不需要。为什么？
- en: 'The reason is that jshell defines a few snippets that are automatically loaded
    when jshell starts or resets. You can see these if you issue the `/list` command
    with the `-start` option, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 jshell 定义了一些片段，这些片段在 jshell 启动或重置时自动加载。如果你发出带有 `-start` 选项的 `/list` 命令，你可以看到这些片段，如下所示：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to list all the snippets you entered as well as the predefined
    snippets and also those that contained some error and thus were not executed,
    you can use the `-all` option to the `/list` command, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要列出你输入的所有片段以及预定义的片段，以及那些包含某些错误因此未执行的片段，你可以使用 `/list` 命令的 `-all` 选项，如下所示：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Some of the lines were deleted from the actual output for brevity. The lines
    that are preloaded are numbered with the `s` prefix. The snippets that contain
    an error have a number prefixed with `e`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，一些行已被从实际输出中删除。预加载的行带有 `s` 前缀进行编号。包含错误的片段带有 `e` 前缀的编号。
- en: 'If you want to execute some of the snippets again, you only have to type `/n`
    where `n` is the number of the snippet, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要再次执行一些代码片段，你只需要在相应位置输入 `/n`，其中 `n` 是片段的编号，如下所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You cannot re-execute the preloaded snippets or snippets that contained errors.
    There is no need for any of those anyway. Preloaded snippets declare some imports
    and define a snippet method; erroneous snippets do not execute because they are,
    well...erroneous.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能重新执行预加载的片段或包含错误的片段。实际上，这些都不需要。预加载的片段声明了一些导入并定义了一个片段方法；错误的片段由于是错误的，所以无法执行。
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing all the snippets can also be avoided in other ways. When you are interested
    only in certain types of snippets, you can have special commands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其他方式也可以避免列出所有片段。当你只对某些类型的片段感兴趣时，你可以使用特殊的命令。
- en: 'If we want to see only the variables that we defined in the snippets, then
    we can issue the `/vars` command, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想看到在片段中定义的变量，那么我们可以发出 `/vars` 命令，如下所示：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to see only the classes, the command/types will do that:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想看到类，可以使用 `command/types` 命令：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we just created an empty class and then we listed it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是创建了一个空类，然后列出了它。
- en: 'To list the methods that were defined in the snippets, the `/methods` command
    can be issued:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出在片段中定义的方法，可以发出 `/methods` 命令：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can see in the output that there are only two methods, which are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输出中看到，只有两个方法，如下所示：
- en: '`printf`: This is defined in a preloaded snippet'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printf`：这是在预加载的片段中定义的'
- en: '`main`: This, we defined'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`：这是我们定义的'
- en: If you want to see everything you typed, you have to issue the `/history` command
    for all the snippets and commands that you typed. (I will not copy the output
    here; I do not want to shame myself. You should try yourself and see your own
    history.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看你输入的所有内容，你必须为所有输入的片段和命令发出 `/history` 命令。（我不会在这里复制输出；我不想让自己难堪。你应该亲自尝试并查看你自己的历史。）
- en: 'Recall that we can delete all the snippets issuing the `/reset` command. You
    can also delete snippets individually. To do so, you should issue the `/drop n`
    command, where `n` is the snipped number:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们可以通过发出 `/reset` 命令来删除所有片段。你还可以单独删除片段。为此，你应该发出 `/drop n` 命令，其中 `n` 是片段编号：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that we can drop the second or the fourth snippet, too:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们也可以删除第二个或第四个片段：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The jshell error message says to see the output of the `/types`, `/methods`,
    `/vars`, or `/list` commands. The problem with this is that `/types`, `/methods`,
    and `/vars` do not display the number of the snippet. This is most probably a
    small bug in the jshell prerelease version and may be fixed by the time the JDK
    is released.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: jshell 的错误信息提示查看 `/types`、`/methods`、`/vars` 或 `/list` 命令的输出。问题是 `/types`、`/methods`
    和 `/vars` 并不显示片段的编号。这很可能是 jshell 预发布版本中的一个小的错误，可能在 JDK 发布时得到修复。
- en: 'When we were editing the snippets, jshell opened a separate graphical editor.
    It may happen that you are running jshell using ssh on a remote server and where
    it is not possible to open a separate window. You can set the editor using the
    `/set` command. This command can set quite a few configuration options of the
    jshell. To set the editor to use the ubiquitous vi, issue the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编辑片段时，jshell 打开了一个单独的图形编辑器。可能的情况是，你正在远程服务器上使用 ssh 运行 jshell，并且无法打开一个单独的窗口。你可以使用
    `/set` 命令设置编辑器。这个命令可以设置 jshell 的许多配置选项。要使用无处不在的 vi 设置编辑器，请发出以下命令：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After this, jshell will open the snipped-in vi in the same Terminal window where
    you issue the `/edit` command.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，jshell将在你发出`/edit`命令的同一终端窗口中打开内嵌的vi。
- en: It is not only the editor that you can set. You can set the startup file, and
    the way jshell prints the feedback to the console after a command was executed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅编辑器可以设置。你可以设置启动文件，以及jshell在执行命令后如何将反馈打印到控制台。
- en: If you set the startup file, then the commands listed in the startup file will
    be executed instead of the built-in commands of jshell after the `/reset` command.
    This also means that you will not be able to use the classes directly that are
    imported by default and you will not have the `printf` method snippet, unless
    your own startup file contains the imports and the definition of the snippet.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置了启动文件，那么在`/reset`命令之后，将执行启动文件中列出的命令，而不是jshell的内置命令。这也意味着你将无法直接使用默认导入的类，并且你将没有`printf`方法片段，除非你的启动文件包含导入和片段的定义。
- en: 'Create the `sample.startup` file with the following content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下内容的`sample.startup`文件：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Starting up a new jshell and executing it is done as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的jshell并执行它如下所示：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `println` method is defined but the `printf` method, which was defined in
    the default startup, is not.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`println`方法已定义，但默认启动中定义的`printf`方法没有。'
- en: 'The feedback defines the prompt jshell prints and then waits for the input,
    the prompt for the continuation lines, and the message details after each command.
    There are predefined modes, which are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈定义了jshell打印的提示，然后等待输入，继续行的提示，以及每个命令后的消息详情。有预定义的模式，如下所示：
- en: Normal
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通
- en: Silent
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静默
- en: Concise
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简洁
- en: Verbose
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细
- en: 'Normal is selected by default. If you issue `/set feedback silent`, then prompt
    becomes `->` and jshell will not print details about the commands. The `/set feedback
    concise` code prints a bit more information and `/set feedback verbose` prints
    verbose information about the commands executed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选择普通。如果你发出`/set feedback silent`命令，则提示变为`->`，jshell将不会打印关于命令的详细信息。`/set feedback
    concise`代码打印更多一些信息，而`/set feedback verbose`则打印关于执行命令的详细信息：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can also define your own modes, giving a name to the new mode using the
    `/set mode xyz` command where `xyz` is the name of the new mode. After this, you
    can set prompt, truncation, and format for the mode. When the format is defined,
    you can use it the same way as the built-in modes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义自己的模式，使用`/set mode xyz`命令给新模式命名，其中`xyz`是新模式的名称。之后，你可以为该模式设置提示、截断和格式。当格式定义后，你可以像使用内置模式一样使用它。
- en: Last, but not least, the most important command of jshell is `/exit`. This will
    just terminate the program and you will return to the operating system shell prompt.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，jshell最重要的命令是`/exit`。这将仅终止程序，然后你将返回到操作系统shell提示符。
- en: Now, let's edit the `HelloWorld.java` file to create our first Java program.
    To do so, you can use vi, notepad, Emacs, or whatever is available on your machine
    and fits you. Later on, we will use some integrated development environment (IDE),
    NetBeans, Eclipse, or IntelliJ; however, for now, a simple text editor is enough.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑`HelloWorld.java`文件以创建我们的第一个Java程序。为此，你可以使用vi、记事本、Emacs或你机器上可用的任何东西，只要它适合你。稍后，我们将使用一些集成开发环境（IDE），如NetBeans、Eclipse或IntelliJ；然而，现在一个简单的文本编辑器就足够了。
- en: 'Edit the file so that the content will be as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑文件，使其内容如下所示：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To compile the source code to byte code, which is executable by JVM, we have
    to use the Java compiler named `javac`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要将源代码编译成可由JVM执行的字节码，我们必须使用名为`javac`的Java编译器：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This generates the `java.class` file in the current directory. This is a compiled
    code that can be executed as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中生成`java.class`文件。这是一个可执行的编译代码，可以按照以下方式执行：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With this one, you have created and executed your first full Java program. You
    may still wonder what we were doing. How and why, I will explain it; but first,
    I wanted you to have a feeling that it works.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，你已经创建并执行了你的第一个完整的Java程序。你可能还在想我们在做什么。如何和为什么，我会解释；但首先，我想让你有一种感觉，它确实可以工作。
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In Java, you cannot have standalone methods or functions, like in many other
    languages. Every method belongs to some class and every class should be declared
    in a separate file (well, almost, but for now, let's skip the exceptions). The
    name of the file has to be the same as the name of the class. The compiler requires
    this for `public` classes. Even for non-public classes we usually follow this
    convention. If you renamed the file from `HelloWorld.java` to `Hello.java`, the
    compiler will display an error when you try to compile the file with the new name.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你不能像许多其他语言那样有独立的方法或函数。每个方法都属于某个类，每个类都应该在单独的文件中声明（好吧，几乎是这样，但现在让我们跳过例外）。文件名必须与类名相同。编译器要求
    `public` 类必须这样做。即使是非 `public` 类，我们通常也遵循这个约定。如果你将文件名从 `HelloWorld.java` 改为 `Hello.java`，当你尝试用新名称编译文件时，编译器会显示错误。
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So, let''s move it back to the original name: `mv Hello.java HelloWorld.java`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将其改回原始名称：`mv Hello.java HelloWorld.java`。
- en: The declaration of the class starts with the keyword `class`, then the name
    of the class, an opening curly brace, and lasts until the matching closing brace.
    Everything in between belongs to the class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类的声明从关键字 `class` 开始，然后是类的名称，一个开括号，直到匹配的闭括号。其中之间的一切都属于该类。
- en: For now, let's skip why I wrote `public` in front of the class and focus on
    the main method in it. The method does not return any value, therefore; the return
    value of it is `void`. The argument, named `args`, is a string array. When JVM
    starts the `main` method, it passes the command-line arguments to the program
    in this array. However, this time we do not use it. The `main` method contains
    the line that prints out `Hello World`. Now, let's examine this line a bit more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳过为什么我在类名前写 `public`，而专注于其中的主方法。由于该方法不返回任何值，因此它的返回值是 `void`。参数名为 `args`，是一个字符串数组。当
    JVM 启动 `main` 方法时，它会将命令行参数传递给程序的这个数组。然而，这次我们不使用它。`main` 方法包含打印出 `Hello World`
    的行。现在，让我们更详细地检查这一行。
- en: In other languages, printing something to the console requires only a `print`
    statement or a very similar command. I remember that some BASIC interpreters even
    allowed us to type `?` instead of `print` because printing to the screen was so
    common. This has changed a lot during the last 40 years. We use graphical screens,
    Internet, and many other input and output channels. These days, it is not very
    common to write to the console.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，将内容打印到控制台只需要一个 `print` 语句或一个非常类似的命令。我记得一些 BASIC 解释器甚至允许我们用 `?` 代替 `print`，因为打印到屏幕非常常见。在过去
    40 年中，这种情况发生了很大变化。我们现在使用图形屏幕、互联网以及许多其他输入和输出通道。如今，将内容写入控制台并不常见。
- en: Usually, in professional large-scale enterprise applications, there is not even
    a single line that does that. Instead, we will direct the text to log files, send
    messages to message queues, and send requests and reply with responses over TCP/IP
    protocol. As this is so infrequently used, there is no reason to create a shortcut
    for the purpose in the language. After the first few programs, when you get acquainted
    with the debugger and logging possibilities, you will not print anything directly
    to the console yourself.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在专业的企业级大型应用中，甚至没有一行代码是做这个的。相反，我们会将文本直接导向日志文件，通过消息队列发送消息，以及通过 TCP/IP 协议发送请求并接收响应。由于这种情况很少使用，所以在语言中创建一个快捷方式没有必要。在编写了几个程序之后，当你熟悉了调试器和日志功能时，你将不会直接将任何内容打印到控制台。
- en: 'Still, Java has features that let you send text directly to the standard output
    of a process the good old way, as it was invented originally for UNIX. This is
    implemented in a Java way where everything has to be an object or class. To get
    access to the system output, there is a class named `System` and it, among other
    things, has the following three variables:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Java 具有一些特性，允许你以最初为 UNIX 设计的“老方法”直接将文本发送到进程的标准输出。在 Java 中，所有东西都必须是一个对象或类，因此这是以
    Java 方式实现的。要访问系统输出，有一个名为 `System` 的类，它包含以下三个变量：
- en: '`in`: This is the standard input stream'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`：这是标准输入流'
- en: '`out`: This is the standard output stream'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out`：这是标准输出流'
- en: '`err`: This is the standard error stream'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err`：这是标准错误流'
- en: To refer to the output stream variable, because it is not in our class but in
    `System,` we will have to specify the class name so we will refer to it as `System.out`
    in our program. The type of this variable is `PrintStream`, which is also a class.
    Class and type are synonyms in Java. Every object that is of type `PrintStream`
    has a method named `println` that accepts a `String`. If the actual print stream
    is the standard output, and we are executing our Java code from the command line,
    then the string is sent to the console.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用输出流变量，因为它不在我们的类中，而是在`System`中，我们必须指定类名，因此我们将在程序中将其称为`System.out`。这个变量的类型是`PrintStream`，它也是一个类。在Java中，类和类型是同义词。每个类型为`PrintStream`的对象都有一个名为`println`的方法，它接受一个`String`。如果实际的打印流是标准输出，并且我们是从命令行执行Java代码，那么字符串就会被发送到控制台。
- en: The method is named `main` and this is a special name in Java programs. When
    we start a Java program from the command line, JVM invokes the method named `main`
    from the class that we specify on the command line. It can do that because we
    declared this method `public` so that anyone can see and invoke it. If it was
    `private`, it would be seen and callable only from within the same class, or classes,
    that are defined in the same source file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法被命名为`main`，在Java程序中这是一个特殊的名称。当我们从命令行启动Java程序时，JVM会从我们在命令行上指定的类中调用名为`main`的方法。它可以这样做，因为我们声明了这个方法为`public`，这样任何人都可以看到并调用它。如果它是`private`的，那么它只能从定义在同一个源文件中的同一个类或类中看到和调用。
- en: The method is also declared as `static`, which means that it can be invoked
    without an actual instance of the class that contains the methods. Using static
    methods is usually seen as not a good practice these days, unless they are implementing
    functions that cannot really ever be related to an instance, or have different
    implementations such as the functions in the `java.lang.Math` class; but, somewhere,
    the code execution has to start and the Java runtime will not usually create instances
    of classes for us automatically.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法也被声明为`static`，这意味着它可以在不实际实例化包含这些方法的类的情况下被调用。如今，使用静态方法通常被认为不是一种好的做法，除非它们实现的是根本无法与实例相关联的功能，或者有不同实现，例如`java.lang.Math`类中的函数；但是，代码执行必须从某个地方开始，Java运行时通常不会自动为我们创建类的实例。
- en: 'To start the code, the command line should be as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动代码，命令行应该如下所示：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `-cp` option stands for classpath. The classpath is a fairly complex idea
    for java but, for now, let's make it simple and say that it is a list of directories
    and JAR files that contain our classes. The list separator for the classpath is
    `:` (colon) on UNIX-like systems and `;` (semicolon) on Windows. In our case,
    the classpath is the actual directory, as that is the place where the Java compiler
    created `HelloWorld.class`. If we do not specify classpath on the command line,
    Java will use the current directory as a default. That is the reason our program
    was working without the `-cp` option in the first place.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`-cp`选项代表类路径。对于Java来说，类路径是一个相当复杂的概念，但就目前而言，让我们简单地说，它是一个包含我们的类的目录和JAR文件的列表。类路径的列表分隔符在UNIX-like系统中是`:`（冒号），在Windows中是`;`（分号）。在我们的情况下，类路径是实际的目录，因为Java编译器就是在那里创建了`HelloWorld.class`。如果我们没有在命令行上指定类路径，Java将使用当前目录作为默认值。这就是为什么我们的程序最初在没有`-cp`选项的情况下也能工作。'
- en: Both `java` and `javac` handle many options. To get a list of the options type
    `javac -help` or `java -help`. We use the IDE to edit the code and, many times,
    to compile, build, and run it during development. The environment in this case
    sets the reasonable parameters. For production we use build tools that also support
    the configuration of the environment. Because of this, we rarely meet these command
    line options. Nevertheless, professionals have to understand their meanings at
    least and know where to learn their actual use in case it is needed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`java`和`javac`都处理许多选项。要获取选项列表，请输入`javac -help`或`java -help`。我们使用IDE来编辑代码，并且在开发过程中，我们经常使用IDE来编译、构建和运行代码。在这种情况下，环境设置了合理的参数。对于生产，我们使用支持环境配置的构建工具。正因为如此，我们很少遇到这些命令行选项。尽管如此，专业人士至少需要理解它们的含义，并且知道在哪里学习它们实际的使用方法，以防万一需要。'
- en: Looking at the byte code
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看字节码
- en: The class file is a binary file. The main role of this format is to be executed
    by the JVM and to provide symbolic information for the Java compiler when a code
    uses some of the classes from a library. When we compile our program that contains
    `System.out.println`, the compiler looks at the compiled `.class` files and not
    at the source code. It has to find the class named `System`, the field named `out`,
    and the method `println`. When we debug a piece of code or try to find out why
    a program does not find a class or method, we will need a way to look into the
    binary of the `.class` files. This is not an everyday task and it takes some advanced
    knowledge
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件是一个二进制文件。这种格式的最主要作用是让 JVM 执行，并在代码使用库中的某些类时为 Java 编译器提供符号信息。当我们编译包含 `System.out.println`
    的程序时，编译器会查看编译后的 `.class` 文件，而不是源代码。它必须找到名为 `System` 的类、名为 `out` 的字段和 `println`
    方法。当我们调试一段代码或试图找出为什么程序找不到类或方法时，我们需要一种方法来查看 `.class` 文件的二进制内容。这不是日常任务，需要一些高级知识。
- en: 'To do so, there is a *decompiler* that can display the content of a `.class`
    file in a more or less readable format. This command is called `javap`. To execute
    it, you can issue the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，有一个可以以或多或少可读的格式显示 `.class` 文件内容的 *反汇编器*。这个命令叫做 `javap`。要执行它，你可以发出以下命令：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output of the program shows that the class file contains Java class that
    has something called `HelloWorld()`; it seems to be a method having the same name
    as the class and it also contains the method we have written.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出显示，类文件包含一个名为 `HelloWorld()` 的 Java 类；这似乎是一个与类名相同的名称的方法，它还包含我们编写的那个方法。
- en: The *method* that has the same name as the class is the constructor of the class.
    As every class in java can be instantiated, there is a need for a constructor.
    If we do not give one, then the Java compiler will create one for us. This is
    the default constructor. The default constructor does nothing special but returns
    a new instance of the class. If we provide a constructor on our own, then the
    Java compiler will not have bothered creating one.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与类名相同名称的 *方法* 是类的构造函数。由于 Java 中的每个类都可以被实例化，因此需要一个构造函数。如果我们不提供，那么 Java 编译器会为我们创建一个。这就是默认构造函数。默认构造函数没有做任何特殊的事情，只是返回一个新实例。如果我们自己提供一个构造函数，那么
    Java 编译器就不会费心创建一个。
- en: 'The `javap` decompiler does not show what is inside the methods or what Java
    code it contains unless we provide the `-c` option:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`javap` 反汇编器不会显示方法内部的内容或它包含的 Java 代码，除非我们提供 `-c` 选项：'
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It is very cryptic and is not for ordinary humans. Only a few experts, who
    deal with the Java code generation, can fluently read that. But, to have a look
    at it helps you get a glimpse of what byte code means. It is something like a
    good old assembly. Although this is binary code, there is nothing secret in it:
    Java is open source, the class file format is well documented and debuggable for
    the experts.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常晦涩难懂，不是普通人类能理解的。只有少数处理 Java 代码生成的专家才能流畅地阅读它。但是，看看它可以帮助你了解字节码的含义。它就像一个古老的汇编语言。尽管这是二进制代码，但其中并没有什么秘密：Java
    是开源的，类文件格式有很好的文档记录，并且对专家来说是可调试的。
- en: Packaging classes into a JAR file
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类打包到 JAR 文件中
- en: 'When you deliver a Java application, usually the code is packaged into JAR,
    WAR, EAR, or some other packaged format. We learn something again that seems to
    be obscure at first sight, but in reality, this is not that complex. They are
    all ZIP files. You can open any of these files using WinZip or some other zip
    manager that you have a license for. The extra requirement is that, for example,
    in the case of a JAR file, the archive should contain a directory named `META-INF`
    and inside it a file named `MANIFEST.MF`. This file is a text file and contains
    meta information in the format, which is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你交付一个 Java 应用程序时，通常代码会被打包成 JAR、WAR、EAR 或其他一些打包格式。我们再次学到一些看似晦涩难懂的东西，但实际上，这并不复杂。它们都是
    ZIP 文件。你可以使用 WinZip 或其他有许可证的压缩管理器打开这些文件。额外的要求是，例如，在 JAR 文件的情况下，归档应包含一个名为 `META-INF`
    的目录，并在其中包含一个名为 `MANIFEST.MF` 的文件。这个文件是一个文本文件，包含以下格式的元信息：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There can be a lot of other information in the file, but this is the minimum
    that the Java provided tool `jar` puts there if we package our class file into
    a jar issuing the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中可能包含很多其他信息，但如果我们使用以下命令将类文件打包到 jar 中，Java 提供的工具 `jar` 会放入这些信息的最小版本：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `-c` option tells the JAR archiver to create a new JAR file and the option
    `f` is used to specify the name of the new archive. The one we specified here
    is `hello.jar` and the file added to it is the class file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c`选项告诉JAR归档器创建一个新的JAR文件，而`f`选项用于指定新存档的名称。我们在这里指定的是`hello.jar`，添加到其中的是类文件。'
- en: The packaged JAR file can also be used to start the Java application. Java can
    read directly from JAR archives and load classes from there. The only requirement
    is that they are on the classpath.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的JAR文件也可以用来启动Java应用程序。Java可以直接从JAR存档中读取并从那里加载类。唯一的要求是它们必须在类路径上。
- en: Note that you cannot put individual classes on the classpath, only directories.
    As JAR files are archives with an internal directory structure in them, they behave
    like a directory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不能将单个类放在类路径上，只能是目录。由于JAR文件是包含内部目录结构的存档，它们的行为就像目录一样。
- en: Check that the JAR file was created using `ls hello.jar` and remove the `rm
    HelloWorld.class` class file just to ensure that when we issue the command line,
    the code is executed from the JAR file and not the class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ls hello.jar`检查JAR文件是否已创建，并删除`rm HelloWorld.class`类文件，只是为了确保当我们发出命令行时，代码是从JAR文件而不是从类中执行的。
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To see the content of the JAR file, however, it is recommended that you use
    the JAR tool and not WinZip even though that may be cozier. Real professionals
    use the Java tools to handle Java files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要查看JAR文件的内容，建议您使用JAR工具而不是WinZip，尽管这可能更舒适。真正的专业人士使用Java工具来处理Java文件。
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Managing the running Java application
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理正在运行的Java应用程序
- en: 'The Java toolset that comes with the JDK supports the execution and management
    of running Java applications as well. To have some program that we can manage
    while executing, we will need a code that runs not only for a few milliseconds
    but, while it runs, it also prints something to the console. Let''s create a new
    program called `HelloWorldLoop.java` with the following content:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: JDK附带的一套Java工具支持运行和管理正在运行的Java应用程序。为了有一个在执行时我们可以管理的程序，我们需要一个不仅运行几毫秒，而且在运行时还会向控制台打印一些内容的代码。让我们创建一个名为`HelloWorldLoop.java`的新程序，其内容如下：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The program contains a `for` loop. Loops allow repeated execution of a code
    block, and we will discuss them in [Chapter 2](part0041.html), *The First Real
    Java Program - Sorting Names*. The loop we created here is a special one that
    never terminates but repeats the printing method call, printing `Hello World`
    until we kill the program by pressing *Ctrl* + *c* or issuing a `kill` command
    on Linux or on OSX, or terminate the program in the task manager under Windows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含一个`for`循环。循环允许重复执行代码块，我们将在[第2章](part0041.html)，“第一个真正的Java程序 - 排序姓名”中讨论它们。我们在这里创建的循环是一个特殊的循环，它永远不会终止，而是重复打印方法调用，打印`Hello
    World`，直到我们通过按*Ctrl* + *c*或发出Linux或OSX上的`kill`命令或通过Windows的任务管理器终止程序来结束程序。
- en: Compile and start it in one window and open another Terminal window to manage
    the application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个窗口中编译并启动它，然后打开另一个终端窗口来管理应用程序。
- en: 'The first command that we should get familiar with is `jps`. [http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html](http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html)
    It lists the Java processes that run on the machine, which are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该熟悉的是`jps`命令。[http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html](http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html)它列出了在机器上运行的Java进程，如下所示：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can see that there are two processes—one is the program we execute and the
    other is the `jps` program itself. Not surprisingly, the jps tool is also written
    in Java. You can also pass options to `jps`, which are documented on the web.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到有两个进程——一个是我们要执行的程序，另一个是`jps`程序本身。不出所料，jps工具也是用Java编写的。您也可以向`jps`传递选项，这些选项在网上有文档说明。
- en: There are many other tools and we will examine one of them, which is a very
    powerful and easy-to-use tool—Java VisualVM.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他工具，我们将考察其中之一，这是一个非常强大且易于使用的工具——Java VisualVM。
- en: '![](img/00018.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: VisualVM is a command-line graphical tool that connects to the running Java
    process and displays the different performance parameters. To start the VisualVM
    tool, you will issue the `jvisualvm` command without any parameters. Soon, a window
    will appear with an exploring tree on the left-hand side and a welcome pane on
    the right. The left side shows all the running Java processes under the branch
    named Local. If you double click on `HelloWorldLoop`, it will open the details
    of the process on the right pane. On the header tabs, you can select Overview,
    Monitor, Threads, Sampler, and Profiler. The first three tabs are the most important
    and give you a good view of what is happening in JVM regarding the number of threads,
    CPU usage, memory consumption, and so on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Using an IDE
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrated development environments are outstanding tools that help the development
    by offloading the mechanical tasks from the developer's shoulders. They recognize
    many of the programming errors as we type the code, help us find the needed library
    methods, display the documentation of the libraries, and provide extra tools for
    style checking, debugging, and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at some IDEs and how to leverage the functions
    they provide.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: To get an IDE, you will have to download and install it. It does not come with
    the Java development tools because they are not part of the language environment.
    But, don't worry. They can be downloaded free of charge and are easy to install.
    They may be more complex to start up than a notepad editor, but even after a few
    hours of work, they will pay back the time you devote to learning them. After
    all, it is not without reason that no developer is coding Java in notepad or vi.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The three topmost IDEs are *NetBeans*, *Eclipse*, and *IntelliJ*. All are available
    in community versions, which means that you need not pay for them. IntelliJ has
    a *full* version that you can also buy. The community edition will be usable for
    learning the language. In case you do not like IntelliJ, you can use Eclipse or
    NetBeans. These are all free of charge. Personally, I use the IntelliJ community
    edition for most of my projects and the screen samples that show an IDE in this
    book will feature this IDE. But, it does not necessarily mean that you have to
    stick to this IDE.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'In the developer community, there are topics that can be heavily debated. These
    topics are about opinions. Were they about facts the debate would easily be soon
    over. One such topic is: "Which is the best IDE?" It is a matter of taste. There
    is no definite answer. If you learn how to use one, you will like that and you
    will be reluctant to learn another one, unless you see that the other one is so
    much better. That is the reason developers love the IDE they use (or just hate,
    depending on their personality), but they keep using the same IDE usually for
    a long time. There is no best IDE.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the IDE of your choice, you can visit either one of the following
    websites:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[https://netbeans.org/](https://netbeans.org/) for NetBeans'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.eclipse.org/](http://www.eclipse.org/) for Eclipse'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/) for IntelliJ'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetBeans
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NetBeans is supported by Oracle and is continuously developed. It contains components,
    such as the NetBeans profiler, that became part of the Oracle Java distribution.
    You may notice that when you start Visual VM and start the profiling, the Java
    process started has `netbeans` in its name.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Generally, NetBeans is a framework to develop rich client applications and the
    IDE is only one application of the many that are built on top of the framework.
    It supports many languages, not only Java. You can develop PHP, C, or JavaScript
    code using NetBeans and have similar services for Java. For the support of different
    languages, you can download plugins or a special version of NetBeans. These special
    versions are available from the download page of the IDE and they are nothing
    more than the basic IDE with some preconfigured plugins. In the C package, the
    developers configure the plugins that are needed when you want to develop C; in
    the PHP version, they plugin for PHP.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse is supported by IBM. Similar to NetBeans, it is also a platform for
    rich client application and it is built around the *OSGi* container architecture,
    which itself is a topic that can fill a book like this. Most of the developers
    use Eclipse and, almost exclusively, it is the choice when developers create code
    for the *IBM WebSphere* application server. The Eclipse special version contains
    a developer version of WebSphere.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse also has plugins to support different programming languages and also
    has different variations similar to NetBeans. The variations are plugins prepackaged
    with the basic IDE.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last one in the preceding enumeration is IntelliJ. This IDE is the only
    one that does not want to be a framework. IntelliJ is an IDE. It also has plugins,
    but most of the plugins that you will need to download to use in NetBeans or Eclipse
    are preconfigured. When you want to use some more advanced plugin, it may however
    be something you have to pay for, which should not be a problem when you are doing
    professional, paid work, should it? These things are not that expensive. For learning
    the subjects in this book, you will not need any plugin that is not in the community
    edition. As in this book, I will develop the samples using IntelliJ and I recommend
    that you follow me during your learning experience.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: I want to emphasize that the examples in this book are independent of the actual
    IDE to be used. You can follow the book using NetBeans, Eclipse, or even Emacs,
    notepad, or vi.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: IDE services
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrated development environments provide us with services. The most basic
    service is that you can edit files with them, but they also help build the code,
    find bugs, run the code, deploy to the application server in development mode,
    debug, and so on. In the following sections, we will look at these features. I
    will not give an exact and precise introduction on how to use one or the other
    IDE. A book like this is not a good medium for such a tutorial.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境为我们提供了服务。最基本的服务是您可以用它们编辑文件，但它们还帮助构建代码、查找错误、运行代码、以开发模式部署到应用服务器、调试等等。在接下来的章节中，我们将探讨这些功能。我不会给出如何使用一个或另一个IDE的精确和精确的介绍。这样的书籍不是这样的教程的好媒介。
- en: IDEs differ on menu placement, keyboard shortcuts, and they may even change
    as newer versions are released. It is best to look at the actual IDE tutorial
    video or online help. Their features, on the other hand, are very similar. IntelliJ
    has the video documentation at [https://www.jetbrains.com/idea/documentation/](https://www.jetbrains.com/idea/documentation/).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: IDEs在菜单位置、键盘快捷键上有所不同，甚至在新版本发布时可能会发生变化。最好是查看实际的IDE教程视频或在线帮助。另一方面，它们的特性非常相似。IntelliJ有视频文档在[https://www.jetbrains.com/idea/documentation/](https://www.jetbrains.com/idea/documentation/)。
- en: IDE screen structure
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE屏幕结构
- en: 'The different IDEs look similar, and have the same screen structure more or
    less. In the following screenshot, you can see an IntelliJ IDE:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的IDE看起来很相似，屏幕结构大致相同。在下面的屏幕截图中，您可以看到一个IntelliJ IDE：
- en: '![](img/00019.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: On the left side, you can see the file structure of a Java project. A Java project
    typically contains many files in different directories which we will discuss in
    the next chapter. The simple *HelloWorld* application contains a `pom.xml` project
    description file. This file is needed for the Maven build tool, which is also
    a topic for the next chapter. For now, you should only know that it is a file
    that describes the project structure for maven. The IDE also keeps track of some
    administrative data for itself. It is stored in `HelloWorld.iml`. The main program
    file is stored in the `src/main/java` directory and named `HelloWorld.java`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，您可以看到Java项目的文件结构。Java项目通常包含不同目录中的许多文件，我们将在下一章中讨论。简单的*HelloWorld*应用程序包含一个`pom.xml`项目描述文件。这个文件是Maven构建工具所需的，这也是下一章的主题。现在，您只需知道它是一个描述maven项目结构的文件。IDE还会跟踪一些自己的管理数据。它存储在`HelloWorld.iml`中。主程序文件存储在`src/main/java`目录中，命名为`HelloWorld.java`。
- en: On the right side, you can see the files. In the screenshot, we have only one
    file opened. In case there is more than one file opened, then there are tabs-one
    for each file. Now, the active file is `HelloWorld.java` that can be edited in
    the source code editor.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，您可以看到文件。在屏幕截图上，我们只有一个文件被打开。如果有多个文件被打开，那么会有标签页——每个文件一个标签页。现在，活动文件是`HelloWorld.java`，可以在源代码编辑器中编辑。
- en: Editing files
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑文件
- en: When editing, you can type in characters or delete characters, words, and lines,
    but this is something that all editors can do. IDEs offer extra. IDEs analyze
    the source code and format it, which, in turn, automatically indents the lines.
    It also continuously compiles the code in the background while you edit it and
    if there is some syntax error, then it underlines it with a red waiving line.
    When you fix the error, the red underlining disappears.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑时，您可以输入字符或删除字符、单词和行，但这所有编辑器都能做到。IDEs提供额外的功能。IDEs分析源代码并格式化它，这反过来又自动缩进行。同时，在您编辑代码的背景下，它还会持续编译代码，如果存在语法错误，则用红色波浪线下划线标记。当您修复错误时，红色下划线消失。
- en: '![](img/00020.jpeg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: 'The editor also automatically gives suggestions for further characters as you
    type. You can ignore the window that pops up and continue typing. However, many
    times, it is easier to stop after a character and use the up and down arrows to
    select the word that needs finishing before pressing *Enter*: the word will be
    inserted into the source code automatically.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器在您键入时也会自动给出后续字符的建议。您可以忽略弹出的窗口并继续键入。然而，很多时候，在键入一个字符后停下来，使用上下箭头选择需要完成的单词，然后按*Enter*键会更简单：单词将自动插入到源代码中。
- en: In the screenshot, you can see that I wrote `System.o` and the editor immediately
    suggested that I wanted to write `out`. The other alternatives are the other static
    fields and methods that are in the class `System` and which contain the letter
    `o`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图上，你可以看到我写了 `System.o`，编辑器立即建议我写 `out`。其他选项是类 `System` 中包含字母 `o` 的其他静态字段和方法。
- en: The IDE editor gives you hints not only when it can type for you, but also when
    it cannot type instead of you. In the screenshot, the IDE tells you to type some
    expression as argument to the `println()`method that is `boolean`, `char`, `int`,
    and so on. The IDE has absolutely no idea what to type there. You have to construct
    the expression. Still, it can tell you that it needs to be of a certain type.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 编辑器不仅在你需要它为你输入时提供提示，而且在它不能代替你输入时也提供提示。在截图上，IDE 告诉你将某些表达式作为 `println()` 方法的参数，这些表达式是
    `boolean`、`char`、`int` 等类型。IDE 完全不知道在那里输入什么。你必须构造这个表达式。尽管如此，它仍然可以告诉你它需要是某种类型。
- en: '![](img/00021.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00021.jpeg)'
- en: It is not only the built-in types that the editor knows. The editor integrated
    with the JDK continuously scans the source files and knows what classes, methods,
    and fields are there in the source code which are usable at the place of editing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器不仅知道内置类型。与 JDK 集成的编辑器会持续扫描源文件，并知道在源代码中哪些类、方法和字段在编辑位置是可用的。
- en: This knowledge is also heavily used when you want to rename a method or variable.
    The old method was to rename the field or method in the source file and then do
    an exhaustive search for all references to the variable. Using the IDE, the mechanical
    work is done by it. It knows all the uses of a field or method and automatically
    replaces the old identifier with the new one. It also recognizes whether a local
    variable happens to have the same name as the one that we rename, and the IDE
    only renames those occurrences that are really referring to the one we are renaming.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想重命名一个方法或变量时，这种知识也会被大量使用。以前的方法是在源文件中重命名字段或方法，然后对变量的所有引用进行彻底搜索。使用 IDE，机械工作由它来完成。它知道字段或方法的全部用法，并自动将旧标识符替换为新标识符。它还识别出是否有局部变量恰好与我们要重命名的变量同名，IDE
    只重命名那些真正指向我们要重命名的变量。
- en: You can usually do more than just renaming. There are more or less mechanical
    tasks that programmers call **refactoring**. These are supported by the IDEs using
    some keyboard shortcut and context sensitive menu in the editor—right click on
    the mouse and click Menu.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以做的不仅仅是重命名。程序员称之为**重构**的机械任务或多或少。这些任务由 IDE 使用一些键盘快捷键和编辑器中的上下文相关菜单来支持——鼠标右键单击并点击菜单。
- en: '![](img/00022.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: 'The IDE also helps you to read the documentation of the libraries and source
    code as shown in the following image:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 还帮助你阅读库和源代码的文档，如下面的图像所示：
- en: '![](img/00023.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00023.jpeg)'
- en: Libraries provide *Javadoc* documentation for the `public` methods and you should
    also write Javadoc for your own method. Javadoc documentation is extracted from
    special comments in the source code and we will learn how to create those in [Chapter
    4](part0111.html), *Mastermind - Creating a Game*. These are located in comments
    in front of the actual method head. As creating compiled documentation is part
    of the compilation flow, the IDE also knows the documentation and it displays
    as a hovering box over the method names, class names, or whatever element you
    want to use in the source file when you position the cursor on the element.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 库为 `public` 方法提供 *Javadoc* 文档，你也应该为自己的方法编写 Javadoc。Javadoc 文档是从源代码中的特殊注释中提取出来的，我们将在第
    4 章[Mastermind - 创建一个游戏]中学习如何创建这些注释。这些注释位于实际方法头部前面的注释中。由于创建编译文档是编译流程的一部分，IDE 也知道文档，并在将光标置于源文件中的方法名称、类名称或其他元素上时，将其显示为悬停框。
- en: Managing projects
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理项目
- en: On the left side of the IDE window, you can see the directory structure of the
    project. The IDE knows the different types of files and shows them in a way that
    is meaningful from the programming point of view. For example, it does not display
    `Main.java` as a filename. Instead, it displays `Main` and an icon that signals
    that `Main` is a class. It can also be an interface still in a file named `Main.java`
    but, in that case, the icon will show that this is an interface. This is again
    done by the IDE continuously scanning and compiling the code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE窗口的左侧，你可以看到项目的目录结构。IDE知道不同类型的文件，并以编程角度有意义的方式显示它们。例如，它不会将`Main.java`显示为文件名。相反，它显示`Main`和一个表示`Main`是一个类的图标。它也可以是一个名为`Main.java`的文件中的接口，但在那种情况下，图标将显示这是一个接口。这是通过IDE持续扫描和编译代码来实现的。
- en: The files are structured into subdirectories when we develop a Java code. These
    subdirectories follow the packaging structure of the code. Many times, in Java,
    we use compound and long package names, and displaying it as a deep and nested
    directory structure will not be so easy to handle.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发Java代码时，文件会被组织到子目录中。这些子目录遵循代码的打包结构。在Java中，我们经常使用复合和长的包名，将它们显示为深层的嵌套目录结构将不容易处理。
- en: Packages are used to group the source files. The source files for classes that
    are related in some way should go into one package. We will discuss the notion
    of packages and how to use them in the next chapter
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 包用于组织源文件。那些以某种方式相关的类的源文件应该放在一个包中。我们将在下一章讨论包的概念以及如何使用它们。
- en: The IDE is capable of showing the package structure instead of the nested directories
    for those directories of the project that contain source files.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含源文件的那些项目目录，IDE能够显示包结构而不是嵌套目录。
- en: '![](img/00024.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00024.jpeg)'
- en: When you move a class or an interface from one package to another, it happens
    in a similar way as renaming or other refactoring. All references to the class
    or interface in the source files get renamed to the new package. If a file contains
    an `import` statement referring to the class, the name of the class in the statement
    is corrected. To move a class, you can open the package and use the good old drag
    and drop.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个类或接口从一个包移动到另一个包时，这和重命名或其他重构操作类似。源文件中对类或接口的所有引用都会被重命名为新的包名。如果一个文件包含一个引用该类的`import`语句，那么该语句中的类名会被修正。要移动一个类，你可以打开包并使用传统的拖放操作。
- en: Package hierarchy is not the only hierarchy displayed in the IDE. The classes
    are in packages but, at the same time, there is an inheritance hierarchy. Classes
    may implement interfaces and can extend other classes. The Java IDEs help us by
    showing type hierarchies where you can navigate across a graphical interface along
    the inheritance relations.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 包层次结构不是IDE中显示的唯一层次结构。类在包中，但同时也存在一个继承层次结构。类可以实现接口并扩展其他类。Java IDE通过显示类型层次结构来帮助我们，在这些层次结构中，你可以沿着继承关系在图形界面中导航。
- en: 'There is another hierarchy that IDEs can show to help us with development:
    method call hierarchy. After analyzing the code, the IDE can show us the graph
    displaying the relations between the methods: which method calls which other methods.
    Sometimes, this call graph is also important in showing the dependencies of methods
    on each other.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: IDE还可以显示另一种层次结构，以帮助我们进行开发：方法调用层次结构。在分析代码后，IDE可以显示显示方法之间关系的图形：哪个方法调用了哪个其他方法。有时，这个调用图在显示方法之间的依赖关系时也非常重要。
- en: Build the code and run it
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译代码并运行它
- en: The IDEs usually compile the code for analysis to help us spot syntax errors
    or undefined classes and methods on the fly. This compilation is usually partial,
    covering a part of the code, and as it runs all the time, the source code changes
    and is never actually complete. To create the deployable file, that is, the final
    deliverable code of the project, a separate build process has to be started. Most
    of the IDEs have some built-in tool for that, but it's not recommended to use
    these except for the smallest projects. Professional development projects use
    Ant, Maven, or Gradle instead. Here is an example of Maven.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: IDE通常会编译代码以进行分析，帮助我们即时发现语法错误或未定义的类和方法。这种编译通常是局部的，覆盖代码的一部分，并且由于它持续运行，源代码会发生变化，因此永远不会真正完整。要创建可部署的文件，即项目的最终交付代码，必须启动一个单独的构建过程。大多数IDE都有一些内置工具用于此目的，但除了最小的项目外，不建议使用这些工具。专业开发项目通常使用Ant、Maven或Gradle。以下是一个Maven的例子。
- en: '![](img/00025.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00025.jpeg)'
- en: The IDEs are prepared to use such an external tool, and they can help us in
    starting them. This way, the build process can run on the developer machine without
    starting a new shell window. IDEs can also import the settings from the configuration
    file of these external build tools to recognize the project structure, where source
    files are, and what to compile to support the error checking while editing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The building process usually contains the execution of certain checks on the
    code. A bunch of the Java source file may compile smoothly and the code may still
    contain a lot of bugs and may be written in bad style, which will make the project
    becomes unmaintainable in the long run. To avoid such problems, we will use unit
    tests and static code analysis tools. These do not guarantee error free code but
    the chances are much better.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: IDEs have plugins to run the static code analysis tools as well as unit tests.
    Being integrated into the IDE has a huge advantage. When there is any problem
    identified by the analysis tool, or by some unit tests, the IDE provides an error
    message that also functions like a link on a web page. If you click on the message,
    usually blue and underlined, exactly like on a web page, the editor opens the
    problematic file and places the cursor where the issue is.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Java
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing code needs debugging. Java has very good facilities to debug code
    during development. JVM supports debuggers via the Java Platform Debugger Architecture.
    This lets you execute code in debug mode and JVM will accept external debugger
    tools to attach to it via a network, or it will try to attach to a debugger depending
    on command-line options. JDK contains a client, the `jdb` tool, which contains
    a debugger; however, it is so cumbersome to use when compared to the graphical
    client built into the IDEs that I have never heard of anyone using it for real
    work.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a Java program in debug mode so that JVM will accept a debugger client
    to attach the options to it, execute the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Xagentlib` option instructs the Java runtime to load the `jdwp` agent.
    The part of the option that follows `-Xagentlib:jdwp=` is interpreted by the debugger
    agent. These options are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`transport`: This should specify which transport to use. It can be a shared
    memory (`dt_shmem`) socket or a TCP/IP socket transport but, in practice, you
    will always use the latter. This is specified in the preceding `dt_socket` sample.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server`: This specifies if the debugged JVM starts in server mode or client
    mode. When you start the JVM in server mode, it starts to listen on a socket and
    accepts the debugger to connect to it. If it is started in client mode, then it
    tries to connect a debugger that is supposed to be started in server mode, listening
    on a port. The value of the option is `y` meaning server mode or `n` meaning nonserver,
    a.k.a. client mode.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suspend`: This can also be `y` or `n`. If JVM is started in suspend mode,
    it will not start the Java code until a debugger is attached to it. If it is started
    with `suspend=n`, then the JVM starts and when a debugger attaches, it stops as
    soon as a breakpoint is reached. If you start a standalone Java application, you
    will usually start the debugging with `suspend=y`, which is the default. If you
    want to debug an application in an application server or servlet-container environment,
    then it is better to start with `suspend=n`; otherwise, the server does not start
    until the debugger attaches to it. Starting the Java process in `suspend=y` mode
    in case servlet application is only useful when you want to debug the servlet
    static initializer code, which is executed when the server is starting up. Without
    suspend mode, you will be required to attach the debugger very fast. It is better
    that JVM just waits for you in that situation.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`: This should specify the address that JVM communicates with. If the
    JVM started in client mode, then it will start to connect to this address. If
    the JVM runs in server mode, then it will accept connections from the debugger
    on that address. The address may specify only the port. In this case, the IP address
    is that of the local machine.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other options the debugger agent may handle are for special cases. For the
    topics covered in this book, the preceding options are enough.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a typical debugging session where we debug the
    simplest program in IntelliJ IDE:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: When you start a program from the IDE in debug mode, all these options are automatically
    set for you. You can set breakpoint just by clicking on the source code in the
    editor. You can have a separate form to add, remove, and edit breakpoints. Breakpoints
    can be attached to specific lines or specific events, like when an exception is
    thrown. Breakpoints attached to a specific line can also have conditions that
    tell the debugger to stop the execution of the code only when the condition is
    true; for example, if a variable has some predefined value.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we were introduced to each other with Java. We do not know
    too much from each other but we got acquainted. We have installed the Java environment:
    Java, JDK and integrated development environment. We have written a small program
    and had a brief look at what can be done using the development tools. This is
    far from mastery but even the longest journey starts with a first step, which
    is sometimes the hardest to make. We have done it in our Java journey. We started
    rolling and for the enthusiasts that we are, nothing can stop us walking all the
    way long.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
