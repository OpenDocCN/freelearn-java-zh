<html><head></head><body>
		<div id="_idContainer201">
			<h1 id="_idParaDest-317" class="chapter-number"><a id="_idTextAnchor317"/>13</h1>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor318"/>Generics and Collections</h1>
			<p>Organizing data is another important software development topic. Java hands us collections to deal with various data structures. It also gives us generics to achieve type safety and avoid duplicate code in our applications. We cannot say we’re masters of Java without understanding how to use collections <span class="No-Break">and generics.</span></p>
			<p>That’s why we devoted this chapter to the Java collections framework. In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>The collections framework and its interfaces – <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, <strong class="source-inline">Map</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Queue</strong></span></li>
				<li>Several implementations of each collection type and their <span class="No-Break">basic operations</span></li>
				<li>Sorting collections using natural ordering and the <strong class="source-inline">Comparable</strong> and <span class="No-Break"><strong class="source-inline">Comparator</strong></span><span class="No-Break"> interfaces</span></li>
				<li>Working <span class="No-Break">with generics</span></li>
				<li>Basic hashing concepts and <span class="No-Break">their relevance</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of the Java collections framework and generics, and you’ll be ready to manage data and use collections in <span class="No-Break">your programs.</span></p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor319"/>Technical requirements</h1>
			<p>The code for this chapter (<em class="italic">Exercise</em> section) can be found on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor320"/>Getting to know collections</h1>
			<p><strong class="bold">Collections</strong> are <a id="_idIndexMarker959"/>worth getting to know. Collections are a much more elegant way of dealing with multiple values in one variable than arrays. A common example of a collection would be <span class="No-Break">a list.</span></p>
			<p>Writing any proper Java application without collections would be very complicated. You’d probably start by creating some classes that will act like Java’s built-in collections. They play a vital role in software development as they provide a means to manage and <span class="No-Break">organize data.</span></p>
			<p>There are many<a id="_idIndexMarker960"/> reasons why we need them, but let’s just list (collection pun) <span class="No-Break">a few:</span></p>
			<ul>
				<li><strong class="bold">Managing large amounts of data</strong>: As applications grow in complexity, they often need to deal with large amounts of data. Collections help store and manage these datasets. They also come with helpful methods that make it easier to perform typical operations on data, such as searching <span class="No-Break">and filtering.</span></li>
				<li><strong class="bold">Storing and manipulating various data structures</strong>: Different data structures have unique characteristics and are suited for specific tasks. Collections provide a diverse set of data structures. This way, we get to choose the most appropriate one for <span class="No-Break">our requirements.</span></li>
				<li><strong class="bold">Ensuring efficient data management and access</strong>: Collections offer a wide range of functionality. This helps us optimize data management and data access in <span class="No-Break">our applications.</span></li>
			</ul>
			<p>Since there are different data structures, we also need to have different collection types. Let’s have a look <span class="No-Break">at them.</span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor321"/>Overview of different collection types</h2>
			<p>The Java collections framework offers quite a few <a id="_idIndexMarker961"/>different collection types. This ensures that developers don’t go ahead and build custom data structure classes for all sorts of problems. This would make it very hard for different applications to communicate and there would be a lot of boilerplate code necessary for so many tasks. It’s a good thing Java comes with these built-in collection interfaces and implementations. Let’s have a look at the main interfaces first. You don’t need to understand the tiniest details of the coding examples; we’ll explain all of it in more <span class="No-Break">detail after.</span></p>
			<h3>List</h3>
			<p>One of the <a id="_idIndexMarker962"/>most common<a id="_idIndexMarker963"/> data structures is the list. <strong class="bold">Lists</strong> are ordered and indexed collections that allow duplicate elements. They are useful when the order of elements is important, and you need to access elements based on <span class="No-Break">their index.</span></p>
			<p>Here’s an example of<a id="_idIndexMarker964"/> a list where we are storing a sequence of student names in a class, where the order of names is significant. This is a list that only holds elements of the <strong class="source-inline">String</strong> type. As you can see, <strong class="source-inline">List</strong> is an interface. When we instantiate it, we need to choose a class that implements <strong class="source-inline">List</strong>. In this case, we’re choosing <strong class="source-inline">ArrayList</strong>. This is a very common choice, but there are other options as well, such as <strong class="source-inline">LinkedList</strong>. There are a few important differences, but we won’t dive into <span class="No-Break">those here:</span></p>
			<pre class="source-code">
List&lt;String&gt; studentNames = new ArrayList&lt;&gt;();studentNames.add("Sarah-Milou");
studentNames.add("Tjed");
studentNames.add("Fahya");</pre>
			<p>With that, we have seen that <strong class="source-inline">List</strong> can hold strings, but collections can hold any type of object, including custom objects. Let’s say we have a <strong class="source-inline">Person</strong> object. This is what that may <span class="No-Break">look like:</span></p>
			<pre class="source-code">
List&lt;Person&gt; personNames = new ArrayList&lt;&gt;();personNames.add(new Person("Sarah-Milou", 4));
personNames.add(new Person("Tjed", 6));
personNames.add(new Person("Fahya", 8));</pre>
			<p>For simplicity, we’ll mostly use <strong class="source-inline">String</strong> for our examples but do keep in mind that this could be any object (and that includes <span class="No-Break">other collections).</span></p>
			<p>There are<a id="_idIndexMarker965"/> unordered<a id="_idIndexMarker966"/> collections that don’t allow duplicates as well. These are of the <strong class="source-inline">Set</strong> type. Let’s have a look <span class="No-Break">at them.</span></p>
			<h3>Sets</h3>
			<p><strong class="bold">Sets</strong> are (commonly) unordered <a id="_idIndexMarker967"/>collections that do not allow duplicate elements. They are useful <a id="_idIndexMarker968"/>when you need to store unique elements but don’t need to care about <span class="No-Break">their order.</span></p>
			<p>Let’s say we need a data structure for all the email addresses we need to send a newsletter to. We don’t want to have any duplicates present because that would result in duplicate mail for <span class="No-Break">the receiver:</span></p>
			<pre class="source-code">
Set&lt;String&gt; emailAddresses = new HashSet&lt;&gt;();emailAddresses.add("sarahmilou@amsterdam.com");
emailAddresses.add("tjed@amsterdam.com");
emailAddresses.add("fahya@amsterdam.com");</pre>
			<p>You don’t need to worry about adding duplicates, nothing happens if you try to do that. You’ll see different implementations of <strong class="source-inline">Set</strong> later, including two types that maintain a particular order of their elements. But let’s have a look at another data structure <span class="No-Break">first: maps.</span></p>
			<h3>Maps</h3>
			<p><strong class="bold">Maps</strong> store<a id="_idIndexMarker969"/> key-value pairs and provide lookups based on the key. They are useful when you need to associate values with unique keys, such as storing user information based on <span class="No-Break">their </span><span class="No-Break"><a id="_idIndexMarker970"/></span><span class="No-Break">usernames:</span></p>
			<pre class="source-code">
Map&lt;String, String&gt; userInfo = new HashMap&lt;&gt;();userInfo.put("Sarah-Milou", "Sarah-Milou Doyle");
userInfo.put("Tjed", "Tjed Quist");
userInfo.put("Fahya", "Fahya Osei");</pre>
			<p>As you can see, maps use different methods. Even though <strong class="source-inline">Map</strong> is part of the collections framework, it’s a bit of an odd one. <strong class="source-inline">Map</strong> is the only main interface that doesn’t extend the <strong class="source-inline">Collection</strong> interface. <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <span class="No-Break"><strong class="source-inline">Queue</strong></span><span class="No-Break"> do.</span></p>
			<p>Sometimes, we need an ordered collection that only allows access to the beginning and/or the end of the collection. We can use queues <span class="No-Break">for this.</span></p>
			<h3>Queues and deques</h3>
			<p><strong class="bold">Queues</strong> allow <a id="_idIndexMarker971"/>you to add <a id="_idIndexMarker972"/>elements to the beginning of the queue and access elements at the ends. There’s a special queue that allows insertion and removal at both ends. This is known <a id="_idIndexMarker973"/>as a <strong class="bold">deque</strong>. Deque stands for double-ended queue. So, queues follow<a id="_idIndexMarker974"/> the <strong class="bold">First-In, First-Out</strong> (<strong class="bold">FIFO</strong>) principle, while deques can be used as both a queue (FIFO) and a stack, which follows <a id="_idIndexMarker975"/>the <strong class="bold">Last-In, First-Out</strong> (<span class="No-Break"><strong class="bold">LIFO</strong></span><span class="No-Break">) principle.</span></p>
			<p>They are useful for tasks that require processing elements in a specific order, such as when implementing a task scheduler. Here’s an example of a print job queue where tasks are processed in the order they <span class="No-Break">are received:</span></p>
			<pre class="source-code">
Queue&lt;String&gt; printQueue = new LinkedList&lt;&gt;();printQueue.add("Document1");
printQueue.add("Document2");
printQueue.add("Document3");
String nextJob = printQueue.poll(); // "Document1"</pre>
			<p>Let’s look at these interfaces in a bit more detail, starting again <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor322"/>List</h1>
			<p>So, the <strong class="source-inline">List</strong> interface<a id="_idIndexMarker976"/> is a part of the Java collections framework and it is used to represent an ordered collection of elements. Elements in a <strong class="source-inline">List</strong> interface can be accessed by their position (index) and can include duplicates. Since <strong class="source-inline">List</strong> is an interface, it cannot be instantiated. Two commonly used implementations of the <strong class="source-inline">List</strong> interface are <strong class="source-inline">ArrayList</strong> and <strong class="source-inline">LinkedList</strong>. Since these are implementation classes, they can be instantiated. Let’s explore what <span class="No-Break">they are.</span></p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor323"/>ArrayList</h2>
			<p><strong class="source-inline">ArrayList</strong> is a resizable<a id="_idIndexMarker977"/> array-backed implementation of the <strong class="source-inline">List</strong> interface. It<a id="_idIndexMarker978"/> provides fast random access to elements and is efficient for read-heavy operations. Random access means directly reaching any item using its <span class="No-Break">index quickly.</span></p>
			<p><strong class="source-inline">ArrayList</strong> dynamically resizes itself when elements are added or removed. Adding and removing elements is somewhat slower. <strong class="source-inline">LinkedList</strong> is optimized <span class="No-Break">for this.</span></p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor324"/>LinkedList</h2>
			<p><strong class="source-inline">LinkedList</strong> is an <a id="_idIndexMarker979"/>implementation of the <strong class="source-inline">List</strong> interface based on a doubly linked list data<a id="_idIndexMarker980"/> structure. Not only does it implement <strong class="source-inline">List</strong> but it also implements <strong class="source-inline">Queue</strong> and <strong class="source-inline">Deque</strong>. It provides fast insertion and deletion of elements at the beginning and end of the list, as well as efficient traversal in both directions. However, accessing elements by index can be slower in <strong class="source-inline">LinkedList</strong> compared to <strong class="source-inline">ArrayList</strong> as elements must be traversed from the head or tail of <span class="No-Break">the list.</span></p>
			<p>The upcoming examples could be happening on both an <strong class="source-inline">ArrayList</strong> and a <strong class="source-inline">LinkedList</strong> in the same way. The difference is the performance (which is not a significant difference for the small amounts of data in <span class="No-Break">these examples).</span></p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor325"/>Exploring the basic operations for lists</h2>
			<p>We can add, remove, alter, and<a id="_idIndexMarker981"/> access items on lists. Let’s have a look at how to perform these everyday operations. There are a lot of other useful methods for lists, but we’ll stick to the must-haves and start with adding elements to <span class="No-Break">a list.</span></p>
			<h3>Adding elements to a list</h3>
			<p>We <a id="_idIndexMarker982"/>can add elements to a <strong class="source-inline">List</strong> interface using the <strong class="source-inline">add()</strong> method. The <strong class="source-inline">add()</strong> method has two forms: <strong class="source-inline">add(E element)</strong> and <strong class="source-inline">add(int index, E element</strong>). The first one adds the element to the end of the list, while the second one adds the element at the specified index. This will shift all the other elements that follow one index up. Here, <strong class="source-inline">E</strong> is the placeholder for the actual type. If it’s a list of the <strong class="source-inline">String</strong> type, we can only add strings to <span class="No-Break">the list.</span></p>
			<p>Let’s have a look at a simple example that uses a list <span class="No-Break">of names:</span></p>
			<pre class="source-code">
List&lt;String&gt; names = new ArrayList&lt;&gt;();names.add("Julie"); // Adds "Julie" at the end of the list
names.add(0, "Janice"); // Inserts "Janice" at index 0</pre>
			<p>First, we create an instance of <strong class="source-inline">ArrayList</strong>. This is a list of the <strong class="source-inline">String</strong> type, as we can see by the word <strong class="source-inline">String</strong> between the angle (<strong class="source-inline">&lt;&gt;</strong>) brackets. We then go ahead and add <strong class="source-inline">Julie</strong> to the list. After that, we specify the position. Instead of adding <strong class="source-inline">Janice</strong> after <strong class="source-inline">Julie</strong>, we add <strong class="source-inline">Janice</strong> at index <strong class="source-inline">0</strong>. This makes <strong class="source-inline">Julie</strong> change from index <strong class="source-inline">0</strong> to <span class="No-Break">index </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<p>After this, we have a<a id="_idIndexMarker983"/> list with two <strong class="source-inline">String</strong> elements in it. Let’s see how we can access <span class="No-Break">these elements.</span></p>
			<h3>Getting elements from a list</h3>
			<p>You can get elements from a <strong class="source-inline">List</strong> interface using the <strong class="source-inline">get()</strong> method, which<a id="_idIndexMarker984"/> takes an index as an argument. We’ll continue from our previous example. Here’s how to <span class="No-Break">do it:</span></p>
			<pre class="source-code">
String name = names.get(1);</pre>			<p>This will get the element at index <strong class="source-inline">1</strong>, which is <strong class="source-inline">Julie</strong>, and store it in a variable called <strong class="source-inline">name</strong>. We can also alter the elements in a list. This can be done with the <span class="No-Break"><strong class="source-inline">set()</strong></span><span class="No-Break"> method.</span></p>
			<h3>Changing elements in a list</h3>
			<p>We can change<a id="_idIndexMarker985"/> elements in a <strong class="source-inline">List</strong> interface using the <strong class="source-inline">set()</strong> method, which takes an index and a new element as arguments. We’re going to alter the element at index <span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break"> here:</span></p>
			<p><span class="No-Break">ames.set(1, "Monica");</span></p>
			<p>With that, we have updated the value of <strong class="source-inline">Julie</strong> to <strong class="source-inline">Monica</strong>. If we want, we can also remove elements from <span class="No-Break">a list.</span></p>
			<h3>Removing elements from a list</h3>
			<p>We can <a id="_idIndexMarker986"/>use the <strong class="source-inline">remove()</strong> method to remove elements. The <strong class="source-inline">remove()</strong> method has two forms: <strong class="source-inline">remove(int index)</strong> and <strong class="source-inline">remove(Object o</strong>). The first one removes an element at a certain position, while the second one removes an element with a <span class="No-Break">certain value:</span></p>
			<pre class="source-code">
names.remove(1); // Removes the element at index 1names.remove("Janice"); // Removes the first occurrence</pre>
			<p>At this point, the <a id="_idIndexMarker987"/>list is empty again, because we’ve removed both elements. We removed <strong class="source-inline">Monica</strong> by using index <strong class="source-inline">1</strong> and we removed <strong class="source-inline">Janice</strong> by looking for an element with <span class="No-Break">that value.</span></p>
			<h3>Iterating through a list</h3>
			<p>There are<a id="_idIndexMarker988"/> different ways to iterate through a list. We’re going to have a look at the two most common ways of <span class="No-Break">doing this.</span></p>
			<p>Firstly, we can use a regular <strong class="source-inline">for</strong> loop to iterate through a list. In this case, we’re iterating over the list names. Let’s assume we didn’t remove both elements just now and it still has <strong class="source-inline">Janice</strong> and <strong class="source-inline">Monica</strong> <span class="No-Break">in there:</span></p>
			<pre class="source-code">
for (int i = 0; i &lt; names.size(); i++) {    System.out.println(names.get(i));
}</pre>
			<p>The output will be <span class="No-Break">as follows:</span></p>
			<pre class="console">
JaniceMonica</pre>
			<p>We can also achieve this same output by using a <span class="No-Break">for-each loop:</span></p>
			<pre class="source-code">
for (String name : names) {    System.out.println(name);
}</pre>
			<p>The difference between the regular for and for-each loop is that we have access to the index with the regular for. The for-each loop makes it easier to access the elements since we don’t need to make sure we stay within the bounds, use the index, and update <span class="No-Break">the index.</span></p>
			<p>There are quite a <a id="_idIndexMarker989"/>few more methods available, but these are the most important ones to get you started. Now, let’s have a look at the <span class="No-Break"><strong class="source-inline">Set</strong></span><span class="No-Break"> interface.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find more information about all the collection in the official <span class="No-Break">documentation here:</span> <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html"><span class="No-Break">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor326"/>Set</h1>
			<p>The <strong class="source-inline">Set</strong> interface<a id="_idIndexMarker990"/> is part of the Java collections framework and represents a generally unordered collection of unique elements. This means that an element can only be in the set once. The commonly used implementations of the <strong class="source-inline">Set</strong> interface are <strong class="source-inline">HashSet</strong>, <strong class="source-inline">TreeSet</strong>, and <strong class="source-inline">LinkedHashSet</strong>. Let’s have a quick look <span class="No-Break">at each.</span></p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor327"/>HashSet</h2>
			<p>Let’s look at the most popular<a id="_idIndexMarker991"/> set first: <strong class="source-inline">HashSet</strong>. This is a widely used implementation<a id="_idIndexMarker992"/> of the <strong class="source-inline">Set</strong> interface based on a hash table. A hash table stores data in key-value pairs, enabling fast lookup by computing an item’s key hash. It provides constant-time performance for basic operations such as <strong class="source-inline">add</strong>, <strong class="source-inline">remove</strong>, and <strong class="source-inline">contains</strong> (checking whether a <strong class="source-inline">Set</strong> interface contains a <span class="No-Break">certain value).</span></p>
			<p><em class="italic">Constant-time complexity</em> means that the time it takes to perform these operations does not increase when the number of elements in the set grows, assuming that the hash function used to distribute the elements among the buckets does its job well. We’ll cover hashing and bucket distribution in more detail at the end of this chapter, but hashing is pretty much the process of turning a certain value into another value – for example, turning a string into <span class="No-Break">a number.</span></p>
			<p>Please note that hash-based data structures such as <strong class="source-inline">HashSet</strong> do not guarantee any specific order of the elements stored in them. This is because the elements are placed in the set based on their hash values, which might not be related to any meaningful order to humans such as ascending or <span class="No-Break">chronological order.</span></p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor328"/>TreeSet</h2>
			<p><strong class="source-inline">TreeSet</strong> is an implementation<a id="_idIndexMarker993"/> of the <strong class="source-inline">Set</strong> interface based on a tree. It maintains elements in a<a id="_idIndexMarker994"/> sorted order according to their natural ordering or according to a custom comparator provided during instantiation. <strong class="source-inline">TreeSet</strong> provides logarithmic time performance for common operations such as <strong class="source-inline">add</strong>, <strong class="source-inline">remove</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">contains</strong></span><span class="No-Break">.</span></p>
			<p><em class="italic">Logarithmic time complexity</em> means that the time it takes to perform these operations increases logarithmically with the size of the input, making <strong class="source-inline">TreeSet</strong> an efficient choice for reasonably <span class="No-Break">large datasets.</span></p>
			<p>As opposed to hash-based data structures such as <strong class="source-inline">HashSet</strong>, which do not maintain any specific order of elements, <strong class="source-inline">TreeSets</strong> are an excellent choice when you need a set that maintains elements in sorted order. This can be useful for tasks such as maintaining a list of unique items in sorted order, finding the smallest or largest element in a set quickly, or performing range queries on a set <span class="No-Break">of data.</span></p>
			<p class="callout-heading">Tree explained</p>
			<p class="callout">A <em class="italic">tree</em> in computer <a id="_idIndexMarker995"/>science is not something you’d have in your backyard. In computer science, a tree is a hierarchical data structure that represents relationships between different nodes. Each node is a data point. The first node, called the root, has no parents. Every other node descends (directly or indirectly) from the root along a single path. The nodes at the very ends of the paths, which have no children, are called <em class="italic">leaf nodes</em>. This <a id="_idIndexMarker996"/>structure is ideal for representing hierarchical relationships because each node has a parent (except for the root) and potentially many children, much like the branches and leaves of a <span class="No-Break">natural tree.</span></p>
			<p class="callout">In a tree, you can think of a path from the root to any node as a journey. Each step in the path represents a relationship between parent and <a id="_idIndexMarker997"/>child nodes. The <em class="italic">height</em> of a tree is the number of steps in the longest path from the root to a leaf. The <em class="italic">depth</em> of a <a id="_idIndexMarker998"/>node is the number of steps in the path from the root to that node. Trees with small heights relative to the number of nodes they contain are often efficient at finding nodes or adding and removing them. They are valuable for several use cases, such as organizing files in a filesystem or storing sorted data for efficient lookups, such as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">TreeSet</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor329"/>LinkedHashSet</h2>
			<p><strong class="source-inline">LinkedHashSet</strong> is an<a id="_idIndexMarker999"/> implementation<a id="_idIndexMarker1000"/> of the <strong class="source-inline">Set</strong> interface that maintains elements in the order they were inserted and it is backed by a combination of a hash table and a doubly-linked list. <strong class="source-inline">LinkedHashSet</strong> provides constant-time performance for basic operations while preserving <span class="No-Break">insertion order.</span></p>
			<p>You would typically choose this implementation when the insertion order is important and the elements don’t need to be sorted. And, since it’s a <strong class="source-inline">Set</strong>, of course, the elements need to be unique (otherwise, <strong class="source-inline">List</strong> might be more logical). An example of a use case for <strong class="source-inline">LinkedHashSet</strong> would be maintaining a list of unique items in the order they were visited, such as web page browsing history or a playlist of unique songs in the order they were added. Another example is tracking events or user actions in an application in the order they occurred while ensuring that each event or action is processed <span class="No-Break">only once.</span></p>
			<p>To do all this, we do need to be able to perform some basic operations. So, let’s have a look at how to <span class="No-Break">do this.</span></p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor330"/>Performing basic operations on a set</h2>
			<p>The <a id="_idIndexMarker1001"/>operations on a <strong class="source-inline">Set</strong> interface are very similar to the operations on <strong class="source-inline">List</strong>. Of course, we don’t work with the index for the methods on <strong class="source-inline">Set</strong>. We’ll start by learning how to add <span class="No-Break">to sets.</span></p>
			<h3>Adding elements to a set</h3>
			<p>Just like we did <a id="_idIndexMarker1002"/>for <strong class="source-inline">List</strong>, we can add elements to a <strong class="source-inline">Set</strong> interface using the <strong class="source-inline">add()</strong> method. Here’s how to <span class="No-Break">do it:</span></p>
			<pre class="source-code">
Set&lt;String&gt; names = new HashSet&lt;&gt;();names.add("Elizabeth");
names.add("Janie");</pre>
			<p>Sets cannot contain duplicate values. Adding the same value twice won’t give an error and won’t add the value <span class="No-Break">another time.</span></p>
			<p>With the same ease, we could have created a <strong class="source-inline">LinkedHashSet</strong> class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();</pre>			<p>We could <a id="_idIndexMarker1003"/>have also created a <span class="No-Break"><strong class="source-inline">TreeSet</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
Set&lt;String&gt; names = new TreeSet&lt;&gt;();</pre>			<p>The operations on these sets would be <span class="No-Break">the same.</span></p>
			<h3>Changing the elements in a set</h3>
			<p>We cannot change elements in a <strong class="source-inline">Set</strong> directly. To modify an element, we <a id="_idIndexMarker1004"/>must remove the old element and add the new one. So, let’s learn how to <span class="No-Break">remove elements.</span></p>
			<h3>Removing elements from a set</h3>
			<p>We can<a id="_idIndexMarker1005"/> remove elements from a <strong class="source-inline">Set</strong> interface using the <strong class="source-inline">remove()</strong> method. We cannot remove by index like we can for <strong class="source-inline">List</strong>, because the elements don’t have <span class="No-Break">an index:</span></p>
			<pre class="source-code">
names.remove("Janie");</pre>			<p>After this, the set will only have one value, namely <strong class="source-inline">Elizabeth</strong>. Since sets don’t have indexes, accessing the elements works a bit differently for them as well. We can access elements <span class="No-Break">via iteration.</span></p>
			<h3>Iterating through a set</h3>
			<p>We can iterate through <a id="_idIndexMarker1006"/>a set using a <strong class="source-inline">for-each</strong> loop. We can’t use a regular <strong class="source-inline">for</strong> loop since we don’t have <span class="No-Break">an index.</span></p>
			<p>Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
for (String name : names) {    System.out.println(name);
}</pre>
			<p>After the removal, our <strong class="source-inline">Set</strong> interface only has one name left. So, this <strong class="source-inline">for-each</strong> loop will output <span class="No-Break">the following:</span></p>
			<pre class="console">
Elizabeth</pre>			<p>And that’s it for <strong class="source-inline">Set</strong>. Now, let’s explore the <strong class="source-inline">Map</strong> <span class="No-Break">data structure.</span></p>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor331"/>Map</h1>
			<p>Another member of the collections framework <a id="_idIndexMarker1007"/>is the <strong class="source-inline">Map</strong> interface. This interface represents a collection of key-value pairs. Keys are unique, while values can be duplicated. That’s why we use the key to add and access the key-value pairs in a map. The commonly used implementations of the <strong class="source-inline">Map</strong> interface that we’ll discuss are <strong class="source-inline">HashMap</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor332"/>HashMap</h2>
			<p>Probably the most<a id="_idIndexMarker1008"/> popular one is <strong class="source-inline">HashMap</strong>. This is a widely used<a id="_idIndexMarker1009"/> implementation of the <strong class="source-inline">Map</strong> interface that’s based on a hash table. Just like <strong class="source-inline">HashSet</strong>, it provides constant-time performance for basic operations. However, it does not guarantee any specific order of the keys. <strong class="source-inline">HashMap</strong> is suitable for situations where you need fast lookups and modifications, such as storing configuration settings or counting word occurrences in a piece of text. When the order is important, we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor333"/>TreeMap</h2>
			<p><strong class="source-inline">TreeMap</strong> is an<a id="_idIndexMarker1010"/> implementation of the <strong class="source-inline">Map</strong> interface that’s based on a tree. It maintains key-value pairs in a sorted order according to their natural ordering or a custom comparator <a id="_idIndexMarker1011"/>provided during instantiation. We’ll look at custom comparators soon as well, but it’s pretty much a way of specifying the order in which it needs to <span class="No-Break">be sorted.</span></p>
			<p><strong class="source-inline">TreeMap</strong> provides logarithmic time performance for common operations such as getting elements from the map and adding elements to the map. <strong class="source-inline">TreeMap</strong> is useful for scenarios where you need to maintain a sorted collection of key-value pairs, such as managing a leaderboard or tracking <span class="No-Break">time-based events.</span></p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor334"/>LinkedHashMap</h2>
			<p><strong class="source-inline">LinkedHashMap</strong> is another <a id="_idIndexMarker1012"/>implementation of the <strong class="source-inline">Map</strong> interface. It combines the <a id="_idIndexMarker1013"/>strengths of <strong class="source-inline">HashMap</strong> and <strong class="source-inline">TreeMap</strong> by providing constant-time performance for basic operations, similar to <strong class="source-inline">HashMap</strong>, while also maintaining the insertion order of key-value pairs. This order is the sequence in which keys are added to <span class="No-Break">the map.</span></p>
			<p><strong class="source-inline">LinkedHashMap</strong> is essentially a <strong class="source-inline">HashMap</strong> implementation with an additional linked list that connects all entries, which allows it to remember the order of insertion. This is particularly useful in scenarios where the sequence of data matters, such as caching operations or maintaining a record of <span class="No-Break">user activities.</span></p>
			<p>Its usage is very similar to the other two implementations. We won’t be showing all the implementations here because the basic operations are the same for each implementation. The only difference is that they have a specific order when you iterate over them, but iterating over them is done in the <span class="No-Break">same way.</span></p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor335"/>Basic operations on maps</h1>
			<p><strong class="source-inline">Map</strong> is quite different from the other <a id="_idIndexMarker1014"/>collections. Let’s learn how to perform the basic operations <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">Map</strong></span><span class="No-Break">.</span></p>
			<h3>Adding elements to a map</h3>
			<p>There is <a id="_idIndexMarker1015"/>no <strong class="source-inline">add()</strong> method for <strong class="source-inline">Map</strong>. We can add elements to a <strong class="source-inline">Map</strong> interface using the <span class="No-Break"><strong class="source-inline">put()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
Map&lt;String, Integer&gt; gfNrMap = new HashMap&lt;&gt;();gfNrMap.put("Ross", 12);
gfNrMap.put("Chandler", 8);</pre>
			<p>This adds two key-value pairs to <strong class="source-inline">Map</strong>. Let’s see how we can get the values <span class="No-Break">out again.</span></p>
			<h3>Getting elements from a map</h3>
			<p>We can<a id="_idIndexMarker1016"/> get elements from a <strong class="source-inline">Map</strong> interface using the <strong class="source-inline">get()</strong> method. This is how we can get the <strong class="source-inline">Integer</strong> value associated with the <span class="No-Break"><strong class="source-inline">Ross</strong></span><span class="No-Break"> key:</span></p>
			<pre class="source-code">
int rossNrOfGfs = gfNrMap.get("Ross");</pre>			<p>We can also use the key to modify the values of <span class="No-Break">the map.</span></p>
			<h3>Changing the elements of a map</h3>
			<p>We can <a id="_idIndexMarker1017"/>change the elements in a <strong class="source-inline">Map</strong> interface using the <strong class="source-inline">put()</strong> method with an <span class="No-Break">existing key:</span></p>
			<pre class="source-code">
gfNrMap.put("Chandler", 9);</pre>			<p>The preceding code changes the value of <strong class="source-inline">8</strong> to <strong class="source-inline">9</strong> for the <strong class="source-inline">Chandler</strong> key. We cannot change the key. If we need to do this, we need to remove the key-value pair and add a <span class="No-Break">new one.</span></p>
			<h3>Removing elements from a map</h3>
			<p>The key is also used for removing elements from a map. We can<a id="_idIndexMarker1018"/> do this with the <span class="No-Break"><strong class="source-inline">remove()</strong></span><span class="No-Break"> method.</span></p>
			<pre class="source-code">
gfNrMap.remove("Ross");</pre>			<p>At this point, our map only contains one key-value pair. We can iterate through a map as well. This is a bit different than what we did for <strong class="source-inline">List</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Set</strong></span><span class="No-Break">.</span></p>
			<h3>Iterating through a map</h3>
			<p>We can iterate<a id="_idIndexMarker1019"/> through the key-value pairs, the values, and the keys with a for-each loop. We need to call different methods on our map object to achieve this. We can use the <strong class="source-inline">entrySet()</strong>, <strong class="source-inline">keySet()</strong>, and <strong class="source-inline">values()</strong> methods <span class="No-Break">for this.</span></p>
			<p>Let’s assume that we still have two key-value pairs in our map, with <strong class="source-inline">Ross</strong> and <strong class="source-inline">Chandler</strong> as keys. The following code snippet loops through the key-value pairs using the <span class="No-Break"><strong class="source-inline">entrySet()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
for (Map.Entry&lt;String, Integer&gt; entry : gfNrMap.entrySet()) {    System.out.println(entry.getKey() + ": " +
      entry.getValue());
}</pre>
			<p><strong class="source-inline">entrySet()</strong> provides a set of <strong class="source-inline">Map.Entry</strong> objects. On this object, we can use the <strong class="source-inline">getKey()</strong> and <strong class="source-inline">getValue()</strong> methods to get the key and the value, respectively. This will output <span class="No-Break">the following:</span></p>
			<pre class="console">
Ross: 12Chandler: 9</pre>
			<p>We can also loop through <span class="No-Break">the keys:</span></p>
			<pre class="source-code">
for (String key : gfNrMap.keySet()) {    System.out.println(key + ": " + gfNrMap.get(key));
}</pre>
			<p>This will output <span class="No-Break">the following:</span></p>
			<pre class="console">
Ross: 12Chandler: 9</pre>
			<p>You might be <a id="_idIndexMarker1020"/>surprised that this is the same output as the previous snippet and contains the values as well, but this is because we are using the key to obtain the value. This is not possible when we loop through the values. Here’s how we can <span class="No-Break">do this:</span></p>
			<pre class="source-code">
for (Integer value : gfNrMap.values()) {    System.out.println(value);
}</pre>
			<p>This will output <span class="No-Break">the following:</span></p>
			<pre class="console">
129</pre>
			<p>Now, we can only see the values, since that is what we’re looping through. Next, let’s have a look at the last main <span class="No-Break">interface: </span><span class="No-Break"><strong class="source-inline">Queue</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor336"/>Queue</h1>
			<p>The last in line is the <strong class="source-inline">Queue</strong> interface. It’s part of the Java collections framework and allows FIFO data storage. The<a id="_idIndexMarker1021"/> head of the queue is the oldest element, and the tail is the newest element. Queues are useful for processing tasks in the order they are received. There<a id="_idIndexMarker1022"/> is also a sub-interface called <strong class="source-inline">Deque</strong>, which is a special type of queue that allows you to get elements from both the head and the tail of the queue. This is why it can also be used for <span class="No-Break">LIFO systems.</span></p>
			<p>We’ll only briefly deal with the different types of queues since this is the collection that’s typically least used in <span class="No-Break">the wild.</span></p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor337"/>Queue implementations</h2>
			<p>The <strong class="source-inline">Queue</strong> interface<a id="_idIndexMarker1023"/> extends the <strong class="source-inline">Collection</strong> interface. There are several implementations, with some of the most common ones being <strong class="source-inline">PriorityQueue</strong>, <strong class="source-inline">LinkedList</strong>, and <strong class="source-inline">ArrayDeque</strong>. The <strong class="source-inline">Deque</strong> interface, which extends the <strong class="source-inline">Queue</strong> interface, adds support for double-ended queues, allowing the insertion and removal of elements from both ends of the queue. <strong class="source-inline">LinkedList</strong> and <strong class="source-inline">ArrayDeque</strong> are <span class="No-Break"><strong class="source-inline">Deque</strong></span><span class="No-Break"> implementations.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor338"/>Basic operations on the Queue interface</h2>
			<p>The basic<a id="_idIndexMarker1024"/> operations on the <strong class="source-inline">Queue</strong> interface are a bit special because the elements can only be accessed at the ends of <span class="No-Break">the queue.</span></p>
			<h3>Adding elements to a queue</h3>
			<p>We can add<a id="_idIndexMarker1025"/> elements to a queue using the <strong class="source-inline">add()</strong> or <strong class="source-inline">offer()</strong> methods. If a queue is at its maximum capacity, the <strong class="source-inline">add()</strong> method throws an exception when it cannot add to the queue. <strong class="source-inline">offer()</strong> would return <strong class="source-inline">false</strong> if it cannot add the element to the queue. Looking at the verbs it seems logical; <em class="italic">offer</em> is without obligation and the queue can turn down the offer when it’s full, hence there is no exception if it’s full. It simply returns false if it cannot append it to the queue. Whereas <em class="italic">add</em> really intents to add, if it doesn’t work an exception will <span class="No-Break">be thrown.</span></p>
			<p>Here’s how we can use both <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">LinkedList</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();queue.add("Task 1");
queue.offer("Task 2");</pre>
			<p>For objects of the <strong class="source-inline">Deque</strong> type, adding to the beginning of the queue works with different methods. <strong class="source-inline">LinkedList</strong> so happens to be of the <strong class="source-inline">Deque</strong> type. The <strong class="source-inline">add</strong> and <strong class="source-inline">offer</strong> methods add to the end of the queue, and so do the <strong class="source-inline">Deque</strong> type’s special methods, <strong class="source-inline">addLast()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">offerLast()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Deque&lt;String&gt; queue = new LinkedList&lt;&gt;();queue.addLast("Task 1"); // or add
queue.offer("Task 2"); // or offerLast</pre>
			<p>Here’s how to add to <span class="No-Break">the beginning:</span></p>
			<pre class="source-code">
queue.addFirst("Task 3");queue.offerFirst("Task 4");</pre>
			<p>The order of the <a id="_idIndexMarker1026"/>elements in the queue is now (from head to tail) <em class="italic">Task 4, Task 3, Task 1, </em><span class="No-Break"><em class="italic">Task 2</em></span><span class="No-Break">.</span></p>
			<h3>Getting elements from a queue</h3>
			<p>We can get the element at the head of a <strong class="source-inline">Queue</strong> interface <a id="_idIndexMarker1027"/>using the <strong class="source-inline">peek()</strong> or <strong class="source-inline">element()</strong> method. They just return the value, without removing it from <span class="No-Break">the queue.</span></p>
			<p>Here’s how to get the head of the queue with the <span class="No-Break"><strong class="source-inline">peek()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
String head = queue.peek();</pre>			<p>The value of <strong class="source-inline">head</strong> becomes <em class="italic">Task 4</em>. The <strong class="source-inline">element()</strong> method throws an exception when it cannot return a value, while the <strong class="source-inline">peek()</strong> method doesn’t. The <strong class="source-inline">peek()</strong> method returns <strong class="source-inline">null</strong> when the queue <span class="No-Break">is empty.</span></p>
			<p>For <strong class="source-inline">Deque</strong>, we can get elements at both the head and the tail. For the head, we can use <strong class="source-inline">getFirst()</strong> and <strong class="source-inline">peekFirst()</strong>. For the tail, we can use <strong class="source-inline">getLast()</strong> and <strong class="source-inline">peekLast()</strong>. Please note that <strong class="source-inline">getFirst()</strong> is the <strong class="source-inline">Deque</strong> equivalent of Queue’s <strong class="source-inline">element()</strong>, even though these differ in name quite <span class="No-Break">a bit.</span></p>
			<p>You may wonder, why do we have two methods that do the same for all of these. They don’t do the same, there’s an important difference. The <strong class="source-inline">getFirst()</strong>, <strong class="source-inline">getLast()</strong>, and <strong class="source-inline">element()</strong> methods attempt to retrieve an end of the queue, but if the queue is empty, it throws a <strong class="source-inline">NoSuchElementException</strong>. In contrast, the<strong class="source-inline"> peek()</strong>, <strong class="source-inline">peekFirst()</strong>, and <strong class="source-inline">peekLast()</strong> methods <a id="_idIndexMarker1028"/>also retrieve the ends of the queue but return <strong class="source-inline">null</strong> if the queue is empty, thus they will not throw <span class="No-Break">an exception.</span></p>
			<h3>Changing the elements in a queue</h3>
			<p>We cannot <a id="_idIndexMarker1029"/>change elements in a <strong class="source-inline">Queue</strong> interface directly. To modify an element, we must remove the old element and add the new one. So, let’s see how to <span class="No-Break">remove elements.</span></p>
			<h3>Removing elements from a queue</h3>
			<p>We can remove elements from a queue using the <strong class="source-inline">remove()</strong> or <strong class="source-inline">poll()</strong> methods. These<a id="_idIndexMarker1030"/> methods do <span class="No-Break">two things:</span></p>
			<ol>
				<li>Return the head of <span class="No-Break">the queue.</span></li>
				<li>Remove the head of <span class="No-Break">the queue.</span></li>
			</ol>
			<p>Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
String removedElement = queue.poll();</pre>			<p>This is going to store <em class="italic">Task 4</em> in <strong class="source-inline">removedElement</strong>. At this point, the values in the queue will be <em class="italic">Task 3</em>, <em class="italic">Task 1</em>, <span class="No-Break"><em class="italic">Task 2</em></span><span class="No-Break">.</span></p>
			<p>This may not surprise you, but for <strong class="source-inline">Deque</strong>, we can remove elements from both ends. For the head, we use <strong class="source-inline">removeFirst()</strong> and <strong class="source-inline">pollFirst()</strong>. For the tail, we can use <strong class="source-inline">removeLast()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">pollLast()</strong></span><span class="No-Break">.</span></p>
			<p>Again, the difference is in how they deal with <span class="No-Break">null values:</span></p>
			<ul>
				<li><strong class="source-inline">remove()</strong>, <strong class="source-inline">removeFirst()</strong>, and <strong class="source-inline">removeLast()</strong> throw a <strong class="source-inline">NoSuchElementException</strong> if the queue <span class="No-Break">is empty.</span></li>
				<li><strong class="source-inline">poll()</strong>, <strong class="source-inline">pollFirst()</strong>, and <strong class="source-inline">pollLast()</strong> return null without throwing an exception, signaling <a id="_idIndexMarker1031"/>that the queue <span class="No-Break">was empty.</span></li>
			</ul>
			<p>Now that we know how to remove elements, let’s learn how to iterate through a <span class="No-Break"><strong class="source-inline">Queue</strong></span><span class="No-Break"> interface.</span></p>
			<h3>Iterating through a queue or deque</h3>
			<p>We can iterate through a <a id="_idIndexMarker1032"/>queue or deque using a for-each loop. This doesn’t remove the<a id="_idIndexMarker1033"/>iterating through”  elements from <span class="No-Break">the queue:</span></p>
			<pre class="source-code">
for (String element : queue) {    System.out.println(element);
}</pre>
			<p>This will output <span class="No-Break">the following:</span></p>
			<pre class="console">
Task 3Task 1
Task 2</pre>
			<p>The reason it’s not printing <em class="italic">Task 4</em> is that we removed it in the <span class="No-Break">previous section.</span></p>
			<p>We have now covered the basics of the four main interfaces and some of the most common implementations. We can do more with collections, such as sorting them. Let’s have a look at how to <span class="No-Break">do that.</span></p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor339"/>Sorting collections</h1>
			<p>So far, we’ve learned how to create<a id="_idIndexMarker1034"/> collections and how to perform basic operations on them. They have a lot of useful built-in methods, and one of them helps us sort collections. The reason we are paying attention to this one is because it’s not as straightforward as some of <span class="No-Break">the others.</span></p>
			<p>Some types have a natural order, such as numbers. They can be easily sorted from small to large. The same goes for strings – we can sort them A-Z. But how do we sort a collection that <a id="_idIndexMarker1035"/>contains custom objects of the <span class="No-Break"><strong class="source-inline">Task</strong></span><span class="No-Break"> type?</span></p>
			<p>Stick with me – soon, you’ll be able to do both natural ordering and custom ordering while using the <strong class="source-inline">sort</strong> method that’s built <span class="No-Break">into collections.</span></p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor340"/>Natural ordering</h2>
			<p>When<a id="_idIndexMarker1036"/> we talk about <a id="_idIndexMarker1037"/>natural ordering, we mean the default sorting order for a particular data type. For example, numbers are sorted in ascending order, while strings are sorted lexicographically. But still, Java wouldn’t know this without us telling them that’s what we want. That’s why Java’s built-in classes, such as <strong class="source-inline">Integer</strong> and <strong class="source-inline">String</strong>, implement the <strong class="source-inline">Comparable</strong> interface. This is what tells Java what the natural order is. Two interfaces are relevant for ordering: <strong class="source-inline">Comparable</strong> and <strong class="source-inline">Comparator</strong>. We will cover <span class="No-Break">these next.</span></p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor341"/>The Comparable and Comparator interfaces</h2>
			<p>When a class <a id="_idIndexMarker1038"/>implements the <strong class="source-inline">Comparable</strong> interface, we need to<a id="_idIndexMarker1039"/> implement the <strong class="source-inline">compareTo()</strong> method. Here’s an example of how a class would implement <span class="No-Break">that interface:</span></p>
			<pre class="source-code">
public class Person implements Comparable&lt;Person&gt; {...}</pre>			<p>The code is<a id="_idIndexMarker1040"/> omitted, but as you can see it implements the interface. Now it needs to override the <span class="No-Break"><strong class="source-inline">compareTo</strong></span><span class="No-Break"> method.</span></p>
			<p>This method defines how to<a id="_idIndexMarker1041"/> sort two objects of the same type. The <strong class="source-inline">compareTo()</strong> method takes another object of the same type as an argument and returns a negative, zero, or positive integer based on how the two <span class="No-Break">objects compare.</span></p>
			<p>This is what the <span class="No-Break">outcomes mean:</span></p>
			<ul>
				<li>0 if the two objects <span class="No-Break">are equal</span></li>
				<li>A positive value if the object is greater than the <span class="No-Break">passed-in object</span></li>
				<li>A negative value if the object the method is called on is less than the <span class="No-Break">passed-in object</span></li>
			</ul>
			<p>The <strong class="source-inline">Comparator</strong> interface<a id="_idIndexMarker1042"/> does something similar but is not meant to be implemented by a class. This interface is used for creating a <a id="_idIndexMarker1043"/>custom <strong class="source-inline">Comparator</strong> on the fly and is typically implemented with a Lambda expression. We haven’t seen Lambda expressions yet, but we will in the next chapter. <strong class="source-inline">Comparator</strong> can be passed to the <strong class="source-inline">sort</strong> method, to tell the <strong class="source-inline">sort</strong> method how to sort <span class="No-Break">the items.</span></p>
			<p><strong class="source-inline">Comparator</strong> is not for natural sorting orders but for “one-off” sorting orders. It contains one method, <strong class="source-inline">compare()</strong>. This method takes two objects as arguments and returns a negative, zero, or positive integer based on the comparison. Here are what the values mean for the <a id="_idIndexMarker1044"/>result <span class="No-Break">of</span><span class="No-Break"><a id="_idIndexMarker1045"/></span><span class="No-Break"> compare:</span></p>
			<ul>
				<li>0 if the two objects <span class="No-Break">are equal.</span></li>
				<li>A positive value if the first object is greater than the second (hence they are in the <span class="No-Break">wrong order).</span></li>
				<li>A negative value if the first object is less than the second (hence they are in the <span class="No-Break">right order).</span></li>
			</ul>
			<p>Alright, enough talking. Let’s see some implementations of <strong class="source-inline">Comparable</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Comparator</strong></span><span class="No-Break">.</span></p>
			<h3>Implementing compareTo()</h3>
			<p>So, there <a id="_idIndexMarker1046"/>are roughly two<a id="_idIndexMarker1047"/> options when we want to sort our <span class="No-Break">custom types:</span></p>
			<ul>
				<li>Give them a natural order by making them <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">Comparable.</strong></span></li>
				<li>Implement <strong class="source-inline">Comparator</strong> and pass this to the <span class="No-Break"><strong class="source-inline">sort</strong></span><span class="No-Break"> method.</span></li>
			</ul>
			<p>Let’s start with the first one. We’re going to give our <strong class="source-inline">Person</strong> class a natural order. To implement the natural ordering for a custom class, we need to implement the <strong class="source-inline">Comparable</strong> interface and the <strong class="source-inline">compareTo()</strong> method. Here’s how to <span class="No-Break">do that:</span></p>
			<pre class="source-code">
public class Person implements Comparable&lt;Person&gt; {    int age; // not private to keep the example short
    String name;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }
}</pre>
			<p>Here, the <strong class="source-inline">Person</strong> class is given a natural order by implementing the <span class="No-Break"><strong class="source-inline">Comparable</strong></span><span class="No-Break"> interface.</span></p>
			<p>The <strong class="source-inline">Person</strong> class <a id="_idIndexMarker1048"/>now implements <strong class="source-inline">Comparable&lt;Person&gt;</strong>. This means that <strong class="source-inline">Person</strong> objects can now be compared to each other based on a natural ordering, which is determined by the <strong class="source-inline">compareTo()</strong> method. This method takes one input parameter. And it is always going to compare that one to the instance the <strong class="source-inline">compareTo()</strong> was called. It should return <strong class="source-inline">0</strong> if the objects are equal, a positive value if the object the method is called on is greater than the input parameter, and a negative value if the input parameter <span class="No-Break">is bigger.</span></p>
			<p>The <strong class="source-inline">Person</strong> class has two attributes: <strong class="source-inline">age</strong> (an integer) and <strong class="source-inline">name</strong> (a string). The constructor initializes these attributes with the given values. The <strong class="source-inline">compareTo()</strong> method is defined to compare <strong class="source-inline">Person</strong> objects based on their age, but we could also have chosen the length of the name to just give an example. In this <strong class="source-inline">compareTo()</strong> method, we use the <strong class="source-inline">Integer.compare()</strong> method to perform the comparison. It takes two integer values as arguments and returns <span class="No-Break">the following:</span></p>
			<ul>
				<li>0 if the two integers <span class="No-Break">are equal</span></li>
				<li>A positive value if the first integer is greater than <span class="No-Break">the second</span></li>
				<li>A negative value if the first integer is less than <span class="No-Break">the second</span></li>
			</ul>
			<p>In the <a id="_idIndexMarker1049"/>context of the <strong class="source-inline">compareTo()</strong> method, this means <span class="No-Break">the following:</span></p>
			<ul>
				<li>If two <strong class="source-inline">Person</strong> objects have the same age, the method will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">0.</strong></span></li>
				<li>If the current <strong class="source-inline">Person</strong> object’s age is greater than the other object’s age, the method will return a <span class="No-Break">positive value.</span></li>
				<li>If the current <strong class="source-inline">Person</strong> object’s age is less than the other object’s age, the method will return a <span class="No-Break">negative value.</span></li>
			</ul>
			<p>These return <a id="_idIndexMarker1050"/>values determine the natural ordering of the <strong class="source-inline">Person</strong> objects when they’re sorted. In this case, the objects will be sorted by their age. Let’s have a look at how to <span class="No-Break">do this:</span></p>
			<pre class="source-code">
List&lt;Person&gt; personList = new ArrayList&lt;&gt;();personList.add(new Person("Huub", 1));
personList.add(new Person("Joep", 4));
personList.add(new Person("Anne", 3));
Collections.sort(personList);</pre>
			<p>Before sorting, the elements have the order they were added in. After sorting, they are sorted from age low to high, so we get <strong class="source-inline">Huub</strong>, <strong class="source-inline">Anne</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Joep</strong></span><span class="No-Break">.</span></p>
			<p>But again, since we wrote it, we could have chosen anything. And whatever we choose determines the natural order. Natural order is, for example, to sort strings A-Z and numbers 0-9. What the natural order for your custom class is, is up to you. It depends on how you implement the <span class="No-Break"><strong class="source-inline">compareTo()</strong></span><span class="No-Break"> method.</span></p>
			<p>Sometimes, we’ll need a different order than specified in the <strong class="source-inline">compareTo()</strong> method. For example, sorting strings by the length of the word. Luckily, we can also create an order that is not connected to the class. Let’s have a look at how to do custom <span class="No-Break">sorting next.</span></p>
			<h3>Implementing compare()</h3>
			<p>There are several ways to implement <a id="_idIndexMarker1051"/>custom ordering<a id="_idIndexMarker1052"/> using the <span class="No-Break"><strong class="source-inline">Comparator</strong></span><span class="No-Break"> interface:</span></p>
			<ul>
				<li>Create a separate class (<span class="No-Break">not typical)</span></li>
				<li>Use an anonymous inner <span class="No-Break">class (better)</span></li>
				<li>Implement it with a Lambda expression (<span class="No-Break">most common)</span></li>
			</ul>
			<p>For example, to sort a list of <strong class="source-inline">Person</strong> objects by their names, we can create this <span class="No-Break">anonymous class:</span></p>
			<pre class="source-code">
Comparator&lt;Person&gt; nameComparator = new  Comparator&lt;Person&gt;() {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
};</pre>
			<p>Here, we created a new <strong class="source-inline">Comparator</strong> object called <strong class="source-inline">nameComparator</strong> that implements the <strong class="source-inline">Comparator</strong> interface. This custom comparator will be used to compare <strong class="source-inline">Person</strong> objects based on their names. The <strong class="source-inline">compare()</strong> method is implemented within the anonymous inner class. Inside the <strong class="source-inline">compare()</strong> method, we use the <strong class="source-inline">compareTo()</strong> method of the <strong class="source-inline">String</strong> class to perform a lexicographic comparison between the names of the two <span class="No-Break"><strong class="source-inline">Person</strong></span><span class="No-Break"> objects.</span></p>
			<p>The <strong class="source-inline">compare()</strong> method in the <strong class="source-inline">Comparator</strong> interface follows the same rules for return values as the <strong class="source-inline">compareTo()</strong> method in the <span class="No-Break"><strong class="source-inline">Comparable</strong></span><span class="No-Break"> interface:</span></p>
			<ul>
				<li>If the two objects being compared are equal, the method will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">0.</strong></span></li>
				<li>If the first object is greater than the second, the method will return a <span class="No-Break">positive value.</span></li>
				<li>If the first object is less than the second, the method will return a <span class="No-Break">negative value.</span></li>
			</ul>
			<p>To use the custom <a id="_idIndexMarker1053"/>comparator to sort a list of <strong class="source-inline">Person</strong> objects, we can pass the <strong class="source-inline">nameComparator</strong> object as an argument to the <strong class="source-inline">Collections.sort()</strong> method, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
List&lt;Person&gt; personList = new ArrayList&lt;&gt;();personList.add(new Person("Huub", 1));
personList.add(new Person("Joep", 4));
personList.add(new Person("Anne", 3));
Collections.sort(personList, nameComparator);</pre>
			<p>In this example, <strong class="source-inline">personList</strong> will be<a id="_idIndexMarker1054"/> sorted according to the names of the <strong class="source-inline">Person</strong> objects in alphabetical order, as specified by <strong class="source-inline">nameComparator</strong>. If we don’t specify <strong class="source-inline">nameComparator</strong>, it will use the natural order and sort by age. Before sorting, the elements have the order they were added in. After sorting, they are sorted by name, A-Z, so we get <strong class="source-inline">Anne</strong>, <strong class="source-inline">Huub</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Joep</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Implementing Comparator with a Lambda expression</p>
			<p class="callout">It is more common to use a Lambda expression to implement the <strong class="source-inline">Comparator</strong> interface. This way, we have a shorter syntax for creating a comparator without the need for an anonymous inner class. You don’t need to understand this yet, but here’s an example of using a Lambda expression to create a comparator that sorts Person objects by <span class="No-Break">their names:</span></p>
			<p class="callout"><strong class="source-inline">Comparator&lt;Person&gt; nameComparatorLambda = (p1, </strong><span class="No-Break"><strong class="source-inline">p2) -&gt;</strong></span></p>
			<p class="callout"><strong class="source-inline">  </strong><span class="No-Break"><strong class="source-inline">p1.getName().compareTo(p2.getName());</strong></span></p>
			<p class="callout">This works the same. We can pass it as an argument to the <span class="No-Break"><strong class="source-inline">Collections.sort()</strong></span><span class="No-Break"> method:</span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">Collections.sort(personList, nameComparatorLambda);</strong></span></p>
			<p class="callout">Since we now have custom comparators, we can create as many as we can think of. Here’s another example of sorting <strong class="source-inline">Person</strong> objects by the length of their names using a <span class="No-Break">Lambda expression:</span></p>
			<p class="callout"><strong class="source-inline">Comparator&lt;Person&gt; nameLengthComparator = (p1, </strong><span class="No-Break"><strong class="source-inline">p2) -&gt;</strong></span></p>
			<p class="callout"><strong class="source-inline">  </strong><span class="No-Break"><strong class="source-inline">Integer.compare(p1.getName().length(),</strong></span></p>
			<p class="callout"><strong class="source-inline">    </strong><span class="No-Break"><strong class="source-inline">p2.getName().length());</strong></span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">Collections.sort(personList, nameLengthComparator);</strong></span></p>
			<p class="callout">Here, <strong class="source-inline">nameLengthComparator</strong> compares <strong class="source-inline">Person</strong> objects based on the length of their names. <strong class="source-inline">personList</strong> will be sorted in ascending order of the name lengths. Our names all have a length of four, and therefore they will remain in the order they <span class="No-Break">were added.</span></p>
			<p>The<a id="_idIndexMarker1055"/> advantage of <a id="_idIndexMarker1056"/>using <strong class="source-inline">Comparator</strong> over the natural order defined by the <strong class="source-inline">Comparable</strong> interface is that you can define multiple custom orderings for the same class without modifying the class itself. In addition, we can easily change the ordering criteria at runtime by providing a different <strong class="source-inline">Comparator</strong> object to the <span class="No-Break"><strong class="source-inline">Collections.sort()</strong></span><span class="No-Break"> method.</span></p>
			<p>Which option we choose depends on what we need. If we want to give our object a natural order, we have to implement the <strong class="source-inline">Comparable</strong> interface. If we don’t have access to the class directly, or we want to specify an order that should not be the natural order, we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Comparator</strong></span><span class="No-Break">.</span></p>
			<p>We can also use comparators when we create <strong class="source-inline">TreeSets</strong> and <strong class="source-inline">TreeMaps</strong>. This will determine how the values in these collections are going to <span class="No-Break">be sorted.</span></p>
			<h3>TreeSets and TreeMaps</h3>
			<p><strong class="source-inline">TreeSet</strong> and <strong class="source-inline">TreeMap</strong> are sorted <a id="_idIndexMarker1057"/>collections that use the natural order of their<a id="_idIndexMarker1058"/> elements or a custom comparator for sorting. This is why we cannot <a id="_idIndexMarker1059"/>create <strong class="source-inline">TreeSets </strong>or <strong class="source-inline">TreeMaps</strong> for <a id="_idIndexMarker1060"/>objects that don’t have a natural order (they don’t implement the <strong class="source-inline">Comparable</strong> interface) without providing a custom comparator during the creation of <strong class="source-inline">TreeSet</strong> or <strong class="source-inline">TreeMap</strong>. Let’s see how to do this for each <span class="No-Break">of them.</span></p>
			<h3>The order of elements in TreeSet</h3>
			<p>As a<a id="_idIndexMarker1061"/> quick reminder, <strong class="source-inline">TreeSet</strong> is a <strong class="source-inline">Set</strong> implementation that stores elements in sorted order. That’s why the elements in <strong class="source-inline">TreeSet</strong> must implement the <strong class="source-inline">Comparable</strong> interface or a custom comparator must be passed along during the construction <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">TreeSet</strong></span><span class="No-Break">.</span></p>
			<p>Here’s an example of creating a <strong class="source-inline">TreeSet</strong> class of <strong class="source-inline">Person</strong> objects using the <span class="No-Break">natural order:</span></p>
			<pre class="source-code">
TreeSet&lt;Person&gt; personTreeSet = new TreeSet&lt;&gt;();personTreeSet.add(new Person("Huub", 1));
personTreeSet.add(new Person("Joep", 4));
personTreeSet.add(new Person("Anne", 3));</pre>
			<p>In this example, the <strong class="source-inline">Person</strong> class implements the <strong class="source-inline">Comparable</strong> interface, so <strong class="source-inline">TreeSet</strong> will use the natural order defined by the <strong class="source-inline">compareTo()</strong> method in the <strong class="source-inline">Person</strong> class (this was sorted <span class="No-Break">by age).</span></p>
			<p>If you want to create a <strong class="source-inline">TreeSet</strong> class with a custom comparator, you can pass the comparator as an argument to the <strong class="source-inline">TreeSet</strong> constructor, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Comparator&lt;Person&gt; nameComparator = (p1, p2) -&gt;  p1.getName().compareTo(p2.getName());
TreeSet&lt;Person&gt; personTreeSetByName = new
  TreeSet&lt;&gt;(nameComparator);
personTreeSetByName.add(new Person("Huub", 1));
personTreeSetByName.add(new Person("Joep", 4));
personTreeSetByName.add(new Person("Anne", 3));</pre>
			<p>In this <a id="_idIndexMarker1062"/>example, <strong class="source-inline">TreeSet</strong> will be sorted by the names of the <strong class="source-inline">Person</strong> objects, as specified by <strong class="source-inline">nameComparator</strong>. We can do something similar <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break">.</span></p>
			<h3>The order of elements in TreeMap</h3>
			<p>In case you’ve<a id="_idIndexMarker1063"/> forgotten, <strong class="source-inline">TreeMap</strong> is a <strong class="source-inline">Map</strong> implementation that stores key-value pairs in a sorted order based on the keys. That’s why the keys in <strong class="source-inline">TreeMap</strong> must implement the <strong class="source-inline">Comparable</strong> interface or we should send in a custom comparator when we <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break">.</span></p>
			<p>Let’s start with a <strong class="source-inline">TreeMap</strong> class of <strong class="source-inline">Person</strong> objects as keys and their ages as values using the <span class="No-Break">natural order:</span></p>
			<pre class="source-code">
TreeMap&lt;Person, Integer&gt; personTreeMap = new TreeMap&lt;&gt;();personTreeMap.put(new Person("Huub", 1), 1);
personTreeMap.put(new Person("Joep", 4), 4);
personTreeMap.put(new Person("Anne", 3), 3);</pre>
			<p>In this example, the <strong class="source-inline">Person</strong> class implements the <strong class="source-inline">Comparable</strong> interface, so <strong class="source-inline">TreeMap</strong> will use the natural order defined by the <strong class="source-inline">compareTo()</strong> method in the <span class="No-Break"><strong class="source-inline">Person</strong></span><span class="No-Break"> class.</span></p>
			<p>If you want to create a <strong class="source-inline">TreeMap</strong> class with a custom comparator, you can pass the comparator as an argument to the <strong class="source-inline">TreeMap</strong> constructor, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Comparator&lt;Person&gt; nameComparator = (p1, p2) -&gt;  p1.getName().compareTo(p2.getName());
TreeMap&lt;Person, Integer&gt; personTreeMapByName = new
  TreeMap&lt;&gt;(nameComparator);
personTreeMapByName.put(new Person("Huub", 1), 1);
personTreeMapByName.put(new Person("Joep", 4), 4);
personTreeMapByName.put(new Person("Anne", 3), 3);</pre>
			<p>Now, this <strong class="source-inline">TreeMap</strong> will be sorted by the names of the <strong class="source-inline">Person</strong> objects, as specified <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">nameComparator</strong></span><span class="No-Break">.</span></p>
			<p>So, <strong class="source-inline">TreeSet</strong> and <strong class="source-inline">TreeMap</strong> are<a id="_idIndexMarker1064"/> sorted collections that use either the natural order of their elements or a custom comparator to sort <span class="No-Break">their contents.</span></p>
			<p>By using the <strong class="source-inline">Comparable</strong> interface and custom comparators, you can define multiple orderings for your custom classes and easily control the sorting behavior of <span class="No-Break">your collections.</span></p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor342"/>Working with generics</h1>
			<p>We have been working<a id="_idIndexMarker1065"/> with generics in this chapter. Generics are flexible and used for (amongst others) collections. We were passing in values to these collections by the specified type between the angle brackets. We can create a collection with a type parameter <span class="No-Break">like this:</span></p>
			<pre class="source-code">
List&lt;String&gt; names = new ArrayList&lt;&gt;();</pre>			<p>This is because the <strong class="source-inline">List</strong> interface and the <strong class="source-inline">ArrayList</strong> class are created with a type parameter (generic). This makes the class a lot more flexible, while still ensuring type safety. Let’s have a look at how this was done before generics to understand why they are <span class="No-Break">so great.</span></p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor343"/>Life before generics – objects</h2>
			<p>When we didn’t have generics, all collections would<a id="_idIndexMarker1066"/> have objects. You’d have to manually check to make sure the item in the list was of the type you hoped it was. And if it was, you’d have to cast it to this type to use this, much <span class="No-Break">like this:</span></p>
			<pre class="source-code">
List = new ArrayList();list.add("Hello");
list.add("World");
list.add(123); // Integer inserted in a List of strings.
               //  Allowed, but not logical.
for (int i = 0; i &lt; list.size(); i++) {
    Object item = list.get(i);
    if (item instanceof String) {
        String strItem = (String) item; // Type casting
                                        //  required
        System.out.println(strItem);
    } else {
        System.out.println("Item is not a String");
    }
}</pre>
			<p>In the preceding code, we created a list without specifying any type. This creates a list of the <strong class="source-inline">Object</strong> type. And as you probably remember, all Java objects are of the <strong class="source-inline">Object</strong> type. Then, we added two strings and an integer to it. This is technically allowed since the list accepts objects of any type, but it can lead to logical errors in <span class="No-Break">your code.</span></p>
			<p>Later, when we iterate <a id="_idIndexMarker1067"/>over the list, we must manually check the type of each item with <strong class="source-inline">instanceof</strong> before we can safely cast it to a string with <strong class="source-inline">(String) item</strong>. If we try to cast an item of the wrong type, the code will throw a <strong class="source-inline">ClassCastException</strong> error at runtime. This can be time-consuming and error-prone, which is one of the main reasons why generics <span class="No-Break">were introduced.</span></p>
			<p>Let’s have a closer look at generics and see them outside of the collection use case. We’ll learn how to create a class with a generic and why we would <span class="No-Break">do that.</span></p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor344"/>Use case of generics</h2>
			<p>Let’s start by creating two types that we <a id="_idIndexMarker1068"/>are going to be putting in a bag class. We’ll do this first <span class="No-Break">without generics.</span></p>
			<p>Here is a public <strong class="source-inline">class</strong> <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">Laptop</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Laptop {    private String brand;
    private String model;
    public Laptop(String brand, String model) {
        this.brand = brand;
        this.model = model;
    }
    // Getters and setters omitted
}</pre>
			<p>And here is<a id="_idIndexMarker1069"/> a public <strong class="source-inline">class</strong> <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">Book</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Book {    private String title;
    private String author;
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }
    // Getters and setters omitted
}</pre>
			<p>A book and a laptop are typical things to store in a bag. Let’s write the Java code to do this. Without generics, we would need two classes. The first will be <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Laptop</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class LaptopBag {    private Laptop;
    public LaptopBag(Laptop laptop) {
        this.laptop = laptop;
    }
    public Laptop getLaptop() {
        return laptop;
    }
    public void setLaptop(Laptop laptop) {
        this.laptop = laptop;
    }
}</pre>
			<p>The second <a id="_idIndexMarker1070"/>will be <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Book</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class BookBag {    private Book;
    public BookBag(Book book) {
        this.book = book;
    }
    public Book getBook() {
        return book;
    }
    public void setBook(Book book) {
        this.book = book;
    }
}</pre>
			<p>Now, we have two <a id="_idIndexMarker1071"/>custom classes, <strong class="source-inline">Laptop</strong> and <strong class="source-inline">Book</strong>, and two bag classes, <strong class="source-inline">LaptopBag</strong> and <strong class="source-inline">BookBag</strong>, each holding a specific type of item. However, there is a lot of duplicate code in the <strong class="source-inline">LaptopBag</strong> and <strong class="source-inline">BookBag</strong> classes. We could solve this by, instead of making <strong class="source-inline">Bag</strong> specific for one type, allowing it to hold <strong class="source-inline">Object</strong> types, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public class ObjectBag {    private Object;
    public ObjectBag(Object object) {
        this.object = object;
    }
    public Object getObject() {
        return object;
    }
    public void setObject(Object object) {
        this.object = object;
    }
}</pre>
			<p>This class allows us to add a <strong class="source-inline">Laptop</strong>, <strong class="source-inline">Book</strong>, or <strong class="source-inline">Person</strong> class. Pretty much anything – it doesn’t care. But that comes with some disadvantages as well. Since the <strong class="source-inline">ObjectBag</strong> class can store any type of object, there is no way to ensure type safety at compile time. This can lead to runtime exceptions, such as <strong class="source-inline">ClassCastException</strong>, if we accidentally mix different types of objects in <span class="No-Break">our code.</span></p>
			<p>Very much related to this is the casting we need to do when retrieving an object from <strong class="source-inline">ObjectBag</strong>. To get access to all its methods and fields, we need to explicitly cast it back to its original type. This adds verbosity to our code and increases the chances of getting a <span class="No-Break"><strong class="source-inline">ClassCastException</strong></span><span class="No-Break"> error.</span></p>
			<p>Luckily, generics<a id="_idIndexMarker1072"/> come to the rescue! Generics offer a way to create flexible and type-safe classes that can handle different types without the disadvantages associated with using an <strong class="source-inline">Object</strong> type. So, let’s see how we can rewrite the <strong class="source-inline">ObjectBag</strong> class <span class="No-Break">using generics.</span></p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor345"/>Syntax generics</h2>
			<p>Generics are used by specifying a type <a id="_idIndexMarker1073"/>parameter within angle brackets, such as <strong class="source-inline">&lt;T&gt;</strong>, where <strong class="source-inline">T</strong> represents a <a id="_idIndexMarker1074"/>type. Here’s a generic solution that uses a single <span class="No-Break"><strong class="source-inline">Bag</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public class Bag&lt;T&gt; {    private T content;
    public Bag(T content) {
        this.content = content;
    }
    public T getContent() {
        return content;
    }
    public void setContent(T content) {
        this.content = content;
    }
}</pre>
			<p>By using the generic type parameter, <strong class="source-inline">&lt;T&gt;</strong>, we can now create a more flexible <strong class="source-inline">Bag</strong> class that can hold any type of item, such as <strong class="source-inline">Laptop</strong> or <strong class="source-inline">Book</strong>. At the same time, we can ensure type safety and avoid the need for explicit casting. Here’s how we can use the <span class="No-Break"><strong class="source-inline">Bag</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
Bag&lt;Laptop&gt; laptopBag = new Bag&lt;&gt;(new Laptop("Dell", "XPS  15"));
Bag&lt;Book&gt; bookBag = new Bag&lt;&gt;(new Book("Why Java is fun",
  "Maaike and Seán"));</pre>
			<p>To conclude, generics add<a id="_idIndexMarker1075"/> flexibility when you’re creating reusable classes, all<a id="_idIndexMarker1076"/> while maintaining type safety. However, sometimes, we may want to restrict the types that can be used with a generic class. This is where bounded generics come into play. Let’s take <span class="No-Break">a look.</span></p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor346"/>Bounded generics</h2>
			<p>Without bounded generics, we <a id="_idIndexMarker1077"/>may run into situations where we need to call methods specific to a<a id="_idIndexMarker1078"/> certain type or its subclasses within the generic class. We cannot do that directly as the generic class knows nothing about the specific methods of the types it handles. Here’s a short example to illustrate the need for <span class="No-Break">bounded generics.</span></p>
			<p>Let’s suppose we have an interface <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">Measurable</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public interface Measurable {    double getMeasurement();
}</pre>
			<p>We want to have a class that is a lot like <strong class="source-inline">Bag</strong>, but only accepts generics that implement the <strong class="source-inline">Measurable</strong> interface. That’s why we need to create a generic <strong class="source-inline">MeasurementBag</strong> class that can only hold objects that implement the <strong class="source-inline">Measurable</strong> interface. We can use bounded generics to <span class="No-Break">achieve this:</span></p>
			<pre class="source-code">
public class MeasurementBag&lt;T extends Measurable&gt; {    private T content;
    public MeasurementBag(T content) {
        this.content = content;
    }
    public T getContent() {
        return content;
    }
    public void setContent(T content) {
        this.content = content;
    }
    public double getContentMeasurement() {
        return content.getMeasurement();
    }
}</pre>
			<p>By using <strong class="source-inline">&lt;T extends Measurable&gt;</strong>, we specify that the generic type, <strong class="source-inline">T</strong>, must be a class that<a id="_idIndexMarker1079"/> implements the <strong class="source-inline">Measurable</strong> interface. This ensures that only<a id="_idIndexMarker1080"/> objects of types that implement <strong class="source-inline">Measurable</strong> can be used with the <strong class="source-inline">MeasurementBag</strong> class. That’s why we can safely call the <strong class="source-inline">getMeasurement()</strong> method within the <strong class="source-inline">MeasurementBag</strong> class – since we know that <strong class="source-inline">T</strong> is guaranteed to implement the <span class="No-Break"><strong class="source-inline">Measurable</strong></span><span class="No-Break"> interface.</span></p>
			<p>So, these bounded generics allow us to restrict the types that are used in the generic class and ensure that they share a common set of methods. That’s why it’s safe to call those methods within the generic class. Does this sound familiar to what collections do? For example, <strong class="source-inline">Collections.sort()</strong> requires a collection with objects that implement <strong class="source-inline">Comparable</strong> when we only pass in one argument (the collection). Generics and bounded type parameters are actually very common in Java’s <span class="No-Break">own code.</span></p>
			<p>We have now<a id="_idIndexMarker1081"/> seen bounded generics that specify an upper bound (a superclass or interface) for the generic type. This ensures that only objects of that type or its <a id="_idIndexMarker1082"/>subclasses can be used with the generic class. There are also lower bounds, but these are out of scope here. You may run into these in the Java source code, but it’s not very likely you’ll be working with <span class="No-Break">these yourself.</span></p>
			<p>Let’s dive into another concept that’s important for using custom objects with <strong class="source-inline">HashMap</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">HashSet</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor347"/>Hashing and overriding hashCode()</h1>
			<p>Hashing<a id="_idIndexMarker1083"/> is an important concept in Java. It is used to efficiently store and retrieve data in various data structures, such as <strong class="source-inline">HashMaps </strong>and <strong class="source-inline">HashSets</strong>. It’s also a very interesting topic. You’ll get quite far without understanding what this does, but at some point, you may wonder about the horrible performance of your <strong class="source-inline">HashMap</strong> class. And understanding what is going on is not possible without understanding hashing. So, let’s discuss the basic concepts of hashing, the role of the <strong class="source-inline">hashCode()</strong> method in collections, and best practices for overriding<a id="_idIndexMarker1084"/> the <strong class="source-inline">hashCode()</strong> method in your <span class="No-Break">custom classes.</span></p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor348"/>Understanding basic hashing concepts</h2>
			<p>Hashing is a<a id="_idIndexMarker1085"/> method that transforms data into a piece of code called a hash code. Think of it like taking a huge pile of books and assigning each book a unique number. A good hash function should give different books different numbers and spread them evenly. This makes it easy to find and organize the books. All objects in Java have a <span class="No-Break"><strong class="source-inline">hashCode()</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor349"/>hashCode() and its role in collections</h2>
			<p>The <strong class="source-inline">Object</strong> class has the <strong class="source-inline">hashCode()</strong> method defined. Since all classes inherit from <strong class="source-inline">Object</strong> (indirectly), all the objects have the <strong class="source-inline">hashCode()</strong> method. This method returns an integer value. Two <a id="_idIndexMarker1086"/>objects that are the same should have the same <span class="No-Break">hash code.</span></p>
			<p>When you use an object in a <strong class="source-inline">HashMap</strong> or <strong class="source-inline">HashSet</strong> class, its <strong class="source-inline">hashCode()</strong> is used to decide its position in the data structure. When we create custom classes, we sometimes need to <span class="No-Break">override </span><span class="No-Break"><strong class="source-inline">hashCode()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor350"/>Overriding hashCode() and best practices</h2>
			<p>When we create <a id="_idIndexMarker1087"/>a custom class and plan to use it as a key in a <strong class="source-inline">HashMap</strong> class or an element in a <strong class="source-inline">HashSet</strong> class, we need to override the <strong class="source-inline">hashCode()</strong> method. This ensures that our class has a consistent and efficient <span class="No-Break">hash function.</span></p>
			<p>Here are some best practices for <span class="No-Break">overriding </span><span class="No-Break"><strong class="source-inline">hashCode()</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Include all fields that are used in the <strong class="source-inline">equals()</strong> method. This way, equal objects have the same <span class="No-Break">hash code.</span></li>
				<li>Use a simple algorithm to combine the hash codes of individual fields, such as multiplying by a prime number and adding the hash codes of <span class="No-Break">the fields.</span></li>
			</ul>
			<p>Here’s an example of <strong class="source-inline">hashCode()</strong> implemented in our <span class="No-Break"><strong class="source-inline">Person</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public class Person {    private String name;
    private int age;
    // Constructor, getters, and setters
    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + (name == null ? 0 :
          name.hashCode());
        result = 31 * result + age;
        return result;
    }
}</pre>
			<p>As you can see, the <strong class="source-inline">hashCode()</strong> method <a id="_idIndexMarker1088"/>has <span class="No-Break">been added.</span></p>
			<p class="callout-heading">Explaining hashCode() in more detail</p>
			<p class="callout">The numbers <strong class="source-inline">17</strong> and <strong class="source-inline">31</strong> are used as part of the hash code calculation for the <strong class="source-inline">Person</strong> class. These are both prime numbers and using prime numbers in hash code calculations helps to produce a better distribution of hash codes and reduces the likelihood of hashcode collisions. <strong class="source-inline">17</strong> is used as the initial value for the result variable. It’s an arbitrary prime number that helps ensure that the hash code calculation starts with a <span class="No-Break">non-zero value.</span></p>
			<p class="callout">By doing so, it reduces the likelihood of generating similar hash codes for different objects, which, in turn, helps minimize collisions. <strong class="source-inline">31</strong> is used as a multiplier in the hashcode calculation. Multiplying the current result by a prime number (<strong class="source-inline">31</strong>, in this case) before adding the next field’s hash code helps mix the hash codes of individual fields more effectively. This results in a better distribution of hash codes across the possible range. <strong class="source-inline">31</strong> is often chosen because it can be computed efficiently using bitwise operations (that is, <strong class="source-inline">x * 31</strong> is the same as <strong class="source-inline">(x &lt;&lt; 5) - </strong><span class="No-Break"><strong class="source-inline">x)</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor351"/>Using hashCode() in custom generic types</h2>
			<p>When <a id="_idIndexMarker1089"/>creating custom generic classes, we may<a id="_idIndexMarker1090"/> need to use the <strong class="source-inline">hashCode()</strong> method of the objects being stored. To do this, we can simply call the <strong class="source-inline">hashCode()</strong> method on the object or use the <strong class="source-inline">Objects.hashCode()</strong> utility method, which handles null <span class="No-Break">values gracefully:</span></p>
			<pre class="source-code">
public class Bag&lt;T&gt; {    private T content;
    // Constructor, getters, and setters
    @Override
    public int hashCode() {
        return Objects.hashCode(content);
    }
}</pre>
			<p>Understanding <a id="_idIndexMarker1091"/>hashing and the <strong class="source-inline">hashCode()</strong> method<a id="_idIndexMarker1092"/> is important when working with Java collections, especially when using custom classes combined with hashed collections. If we follow best practices for overriding <strong class="source-inline">hashCode()</strong> and using it in custom generic types, we can achieve better performance when adding and accessing elements in <span class="No-Break">our collections.</span></p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor352"/>Exercises</h1>
			<p>You may not have noticed directly, but we’ve been longing for this! We can finally add collections and generics to the applications of our apps. Life will get easier. Let’s look at <span class="No-Break">some exercises:</span></p>
			<ol>
				<li>Our park has an assortment of dinosaurs and their related data. Implement a <strong class="source-inline">List</strong> interface that stores a custom <span class="No-Break">dinosaur class.</span></li>
				<li>We need to ensure that the most dangerous dinosaurs are taken care of first. Write a <strong class="source-inline">PriorityQueue</strong> class that sorts dinosaurs based on a custom <strong class="source-inline">Comparator</strong> interface, such as their <span class="No-Break">danger level.</span></li>
				<li>Generics can make our code more reusable. Create a class called <strong class="source-inline">Crate</strong> with a generic for the thing you’d like to store in there. This could be food or drinks for the restaurant, but also dinosaurs if we need to <span class="No-Break">relocate them.</span></li>
				<li>Create three instances of your <strong class="source-inline">Crate</strong> class with different classes in your program – for example, <strong class="source-inline">Dinosaur</strong>, <strong class="source-inline">Jeep</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DinosaurFood</strong></span><span class="No-Break">.</span></li>
				<li>Hashing is essential for efficient data handling. Override the <strong class="source-inline">hashCode()</strong> method in your <span class="No-Break">dinosaur class.</span></li>
				<li>Challenging: We have some issues with finding personnel for the restaurants. Let’s automate the ordering at the ice cream store in our park. Write a program that does <span class="No-Break">the following:</span><ul><li>Ask how many ice creams the guest <span class="No-Break">would list.</span></li><li>For every ice cream, ask what flavor they would like (come up with a few choices for flavors, make them dinosaur-themed if you dare) and how <span class="No-Break">many scoops.</span></li><li>For simplicity, let’s assume that each guest can only order every flavor once. Add all the ice creams and their descriptions to a <strong class="source-inline">List</strong> interface that contains maps. These maps will represent the ice creams and the amount <span class="No-Break">of scoops.</span></li></ul></li>
				<li>Challenging: Elaborate on <em class="italic">Exercise 13.6</em>. Print the order (loop over the list!) and say it will be ready at the current time plus 10 minutes (you need to calculate this, not print <span class="No-Break">that literally!)</span></li>
			</ol>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor353"/>Project – advanced dinosaur care system</h1>
			<p>As the number of <a id="_idIndexMarker1093"/>dinosaurs in our park increases, the need for a more sophisticated data management system becomes apparent. Generics and collections to <span class="No-Break">the rescue!</span></p>
			<p>We will continue to build on the dinosaur care system. The system should handle collections of dinosaurs, allowing functionalities such as sorting dinosaurs based on various parameters, ensuring the uniqueness of dinosaurs, and <span class="No-Break">so on.</span></p>
			<p>Here are the steps we’re going <span class="No-Break">to take.</span></p>
			<p><strong class="bold">Step 1: Add additional </strong><span class="No-Break"><strong class="bold">Java classes</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Create a new package <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">collections</strong></span><span class="No-Break">.</span></li>
				<li>Inside this package, create a class named <strong class="source-inline">DinosaurComparator</strong>. This class should implement <strong class="source-inline">Comparator&lt;Dinosaur&gt;</strong>. Override the <strong class="source-inline">compare()</strong> method to sort dinosaurs based on various parameters, such as age, size, and <span class="No-Break">so on.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Normally you don’t create a class for comparator, but we don’t see lambdas until the <span class="No-Break">next chapter.</span></p>
			<p><strong class="bold">Step 2: Extend the dinosaur </strong><span class="No-Break"><strong class="bold">care system</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Change the <strong class="source-inline">List</strong> interface in the <strong class="source-inline">DinosaurCareSystem</strong> class that holds the <strong class="source-inline">Dinosaur</strong> objects to a <strong class="source-inline">Set</strong> interface. This will ensure the uniqueness of <span class="No-Break">the dinosaurs.</span></li>
				<li>Create a method called <strong class="source-inline">sortDinosaurs()</strong> that sorts the <strong class="source-inline">Dinosaur</strong> set <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">DinosaurComparator</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Here is some<a id="_idIndexMarker1094"/> sample code to get <span class="No-Break">you started:</span></p>
			<pre class="source-code">
import java.util.*;public class DinosaurCareSystem {
    private Set&lt;Dinosaur&gt; dinosaurs;
    private List&lt;Activity&gt; activities;
    public DinosaurCareSystem() {
        dinosaurs = new HashSet&lt;&gt;();
        activities = new ArrayList&lt;&gt;();
    }
    public void addDinosaur(Dinosaur dinosaur) {
        dinosaurs.add(dinosaur);
    }
    public void logActivity(Activity activity) {
        activities.add(activity);
    }
    public List&lt;Dinosaur&gt; sortDinosaurs() {
        List&lt;Dinosaur&gt; sortedDinosaurs = new
          ArrayList&lt;&gt;(dinosaurs);
        Collections.sort(sortedDinosaurs, new
          DinosaurComparator());
        return sortedDinosaurs;
    }
    //... existing methods for handling exceptions and
          other functionalities here
}</pre>
			<p>And here’s<a id="_idIndexMarker1095"/> the <strong class="source-inline">DinosaurComparator</strong> class that you <span class="No-Break">could use:</span></p>
			<pre class="source-code">
import java.util.Comparator;public class DinosaurComparator implements
  Comparator&lt;Dinosaur&gt; {
    @Override
    public int compare(Dinosaur d1, Dinosaur d2) {
    // assume Dinosaur has a getSize() method
        return d1.getSize().compareTo(d2.getSize());      }
}</pre>
			<p> <strong class="bold">Step 3: Interact with </strong><span class="No-Break"><strong class="bold">the system</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>In your <strong class="source-inline">main </strong>class, you can interact with the <strong class="source-inline">DinosaurCareSystem</strong> object similar to what did in the previous steps, but now, add the functionality to sort the<a id="_idIndexMarker1096"/> dinosaurs based on <span class="No-Break">the parameters.</span></li>
			</ul>
			<p>Do you want more? You can expand on this by adding more functionalities, such as sorting based on different parameters, searching for dinosaurs based on their properties, <span class="No-Break">and more.</span></p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor354"/>Summary</h1>
			<p>Alright, you’ve made your way through another tough chapter. In this chapter, we explored the fundamentals of collections and generics in Java. We began by discussing the need for collections in programming and provided an overview of the different collection types available in Java, including <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, <strong class="source-inline">Map</strong>, <strong class="source-inline">Queue</strong>, and <strong class="source-inline">Deque</strong>. We examined the specific implementations of each collection type, such as <strong class="source-inline">ArrayList</strong>, <strong class="source-inline">LinkedList</strong>, <strong class="source-inline">HashSet</strong>, <strong class="source-inline">TreeSet</strong>, <strong class="source-inline">HashMap</strong>, <strong class="source-inline">TreeMap</strong>, and more, along with their differences and appropriate use cases. We also covered basic operations, such as adding, removing, and iterating through elements in <span class="No-Break">each collection.</span></p>
			<p>Then, we moved on to sorting collections. We made the distinction between natural ordering and custom ordering with the use of the <strong class="source-inline">Comparable</strong> and <strong class="source-inline">Comparator</strong> interfaces. We learned how to implement the <strong class="source-inline">compareTo()</strong> and <strong class="source-inline">compare()</strong> methods, as well as how to sort lists, sets, and maps using <strong class="source-inline">Collections.sort()</strong> and the <strong class="source-inline">TreeSet</strong> and <span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break"> classes.</span></p>
			<p>We then delved into generics, explaining their importance in providing type safety. The syntax and basic usage of generics were demonstrated, including the use of the <strong class="source-inline">extends</strong> keyword in <span class="No-Break">bounded generics.</span></p>
			<p>Next, we proceeded to learn how to create custom generic types by defining generic classes. We also covered the implications of not having generics, and how to create instances of <span class="No-Break">generic types.</span></p>
			<p>Lastly, we discussed basic hashing concepts and the role of the <strong class="source-inline">hashCode()</strong> method in collections. We provided guidelines for overriding <strong class="source-inline">hashCode()</strong> and best practices for its implementation, emphasizing its significance in custom <span class="No-Break">generic types.</span></p>
			<p>At this point, you should have gained a solid understanding of the differences between <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, <strong class="source-inline">Map</strong>, and <strong class="source-inline">Queue</strong>, as well as have basic knowledge of working with generics and hashing. You are now ready for the next exciting topic: <span class="No-Break">Lambda expressions.</span></p>
		</div>
	</body></html>