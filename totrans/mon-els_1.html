<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Introduction to Monitoring Elasticsearch"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introduction to Monitoring Elasticsearch</h1></div></div></div><p>Elasticsearch is a<a id="id0" class="indexterm"/> distributed and horizontally scalable full-text search engine with built-in data redundancy. It is a powerful and incredibly useful tool. However, as with any distributed system, problems may arise as it scales with more nodes and more data.</p><p>The information provided by Elasticsearch monitoring tools can drastically improve your ability to solve cluster issues and greatly increase cluster reliability and performance as a result. This chapter gives an overview of Elasticsearch and talks about why and how to monitor a cluster.</p><p>Specifically, this chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of Elasticsearch</li><li class="listitem" style="list-style-type: disc">Monitoring Elasticsearch</li><li class="listitem" style="list-style-type: disc">Resourcefulness and problem solving</li></ul></div><div class="section" title="An overview of Elasticsearch"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>An overview of Elasticsearch</h1></div></div></div><p>This section gives a<a id="id1" class="indexterm"/> high-level overview of Elasticsearch and discusses some related full-text search products.</p><div class="section" title="Learning more about Elasticsearch"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Learning more about Elasticsearch</h2></div></div></div><p>Elasticsearch is a free and open source full-text search engine that is built on top of Apache Lucene. Out of the box, Elasticsearch supports horizontal scaling and data redundancy. Released in 2010, Elasticsearch quickly gained recognition in the full-text search space. Its scalability features helped the tool gain market share against similar technologies <a id="id2" class="indexterm"/>such as Apache Solr.</p><p>Elasticsearch is a persistent document store and retrieval system, and it is similar to a database. However, it is different from relational databases such as MySQL, PostgreSQL, and Oracle in many ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Distributed</strong></span>: Elasticsearch stores data and executes queries across multiple data nodes. This improves <a id="id3" class="indexterm"/>scalability, reliability, and performance.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fault tolerant</strong></span>: Data is<a id="id4" class="indexterm"/> replicated across multiple nodes in an Elasticsearch cluster, so if one node goes down, data is still available.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Full-text search</strong></span>: Elasticsearch is built on top of Lucene, a full-text search technology, allowing it to <a id="id5" class="indexterm"/>understand and search natural language text.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JSON document store</strong></span>: Elasticsearch<a id="id6" class="indexterm"/> stores documents as JSON instead of as rows in a table.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>NoSQL</strong></span>: Elasticsearch uses <a id="id7" class="indexterm"/>a JSON-based query language as opposed to a sequel query language (SQL).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Non-relational</strong></span>: Unlike relational<a id="id8" class="indexterm"/> databases, Elasticsearch doesn't support <span class="emphasis"><em>JOINS</em></span> across tables.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Analytics</strong></span>: Elasticsearch has <a id="id9" class="indexterm"/>built-in analytical capabilities, such as word aggregations, geospatial queries, and scripting language support.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dynamic Mappings</strong></span>: A <span class="emphasis"><em>mapping</em></span> in Elasticsearch is analogous to a <span class="emphasis"><em>schema</em></span> in the relational database<a id="id10" class="indexterm"/> world. If the data type for a document field isn't explicitly defined, Elasticsearch will dynamically assign a type to it.</li></ul></div></div><div class="section" title="Data distribution, redundancy, and fault tolerance"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Data distribution, redundancy, and fault tolerance</h2></div></div></div><p>
<span class="emphasis"><em>Figures 1.1</em></span> through <span class="emphasis"><em>1.4</em></span> explain<a id="id11" class="indexterm"/> how Elasticsearch distributes data across <a id="id12" class="indexterm"/>multiple nodes and how it automatically recovers from <a id="id13" class="indexterm"/>node failures:</p><div class="mediaobject"><img src="graphics/B03798_01_01.jpg" alt="Data distribution, redundancy, and fault tolerance"/><div class="caption"><p>Figure 1.1: Elasticsearch Data Distribution</p></div></div><p>In this figure, we have an Elasticsearch cluster made up of three nodes: <code class="literal">elasticsearch-node-01</code>, <code class="literal">elasticsearch-node-02</code>, and <code class="literal">elasticsearch-node-03</code>. Our data index, is broken into three pieces, called <a id="id14" class="indexterm"/>
<span class="strong"><strong>shards</strong></span>. These shards are labeled <code class="literal">0</code>, <code class="literal">1</code>, and <code class="literal">2</code>. Each shard is replicated once; this means that there is a redundant<a id="id15" class="indexterm"/> copy of all shards. The cluster is colored<a id="id16" class="indexterm"/> green because the cluster is in good health; all data shards and replicas are available.</p><p>Let's say that the <code class="literal">elasticsearch-node-03</code> host experiences a hardware failure and shuts down. The following figures show what happens to the cluster in this scenario:</p><div class="mediaobject"><img src="graphics/B03798_01_02.jpg" alt="Data distribution, redundancy, and fault tolerance"/><div class="caption"><p>Figure 1.2: Node failure</p></div></div><p>
<span class="emphasis"><em>Figure 1.2</em></span> shows <code class="literal">elasticsearch-node-03</code> experiencing a failure, and the cluster entering a <code class="literal">yellow</code> state. This<a id="id17" class="indexterm"/> state means that there is at least one copy of each shard active in the cluster, but not all shard replicas are active. In our case, a copy of the <code class="literal">1</code> and <code class="literal">2</code> shards <a id="id18" class="indexterm"/>were on the node that failed, <code class="literal">elasticsearch-node-03</code>. A <code class="literal">yellow</code> state also warns us that if there's another hardware failure, it's <a id="id19" class="indexterm"/>possible that not all data shards will be available.</p><p>When <code class="literal">elasticsearch-node-03</code> goes down, Elasticsearch will automatically start rebuilding redundant copies of the <code class="literal">1</code> and <code class="literal">2</code> shards on the remaining nodes; in our case, this is <code class="literal">elasticsearch-node-01</code> and <code class="literal">elasticsearch-node-02</code>. This is shown in the following figure:</p><div class="mediaobject"><img src="graphics/B03798_01_03.jpg" alt="Data distribution, redundancy, and fault tolerance"/><div class="caption"><p>Figure 1.3: Cluster recovering</p></div></div><p>Once Elasticsearch finishes<a id="id20" class="indexterm"/> rebuilding the data replicas, the cluster enters a <code class="literal">green</code> state <a id="id21" class="indexterm"/>once again. Now, all data and shards<a id="id22" class="indexterm"/> are available to query.</p><div class="mediaobject"><img src="graphics/B03798_01_04.jpg" alt="Data distribution, redundancy, and fault tolerance"/><div class="caption"><p>Figure 1.4: Cluster recovered</p></div></div><p>The cluster recovery<a id="id23" class="indexterm"/> process demonstrated in <span class="emphasis"><em>Figures 1.3</em></span> and <span class="emphasis"><em>1.4</em></span> happens automatically<a id="id24" class="indexterm"/> in Elasticsearch. No extra configuration or user action<a id="id25" class="indexterm"/> is required.</p></div><div class="section" title="Full-text search"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Full-text search</h2></div></div></div><p>
<span class="strong"><strong>Full-text</strong></span> search refers to<a id="id26" class="indexterm"/> running keyword queries against natural-language text documents. A document can be something, such as a newspaper article, a blog post, a forum post, or a tweet. In fact, many popular newspapers, forums, and social media websites, such as The New York Times, Stack Overflow, and Foursquare, use Elasticsearch.</p><p>Assume that we were to store the following text string in Elasticsearch:</p><div class="informalexample"><pre class="programlisting">We demand rigidly defined areas of doubt and uncertainty!</pre></div><p>A user can find this document by searching Elasticsearch using keywords, such as <span class="emphasis"><em>demand</em></span> or <span class="emphasis"><em>doubt</em></span>. Elasticsearch also supports word stemming. This means that if we searched for the word <span class="emphasis"><em>define</em></span>, Elasticsearch would still find this document because the root word of <span class="emphasis"><em>defined</em></span> is <span class="emphasis"><em>define</em></span>.</p><p>This piece of text, along with some additional metadata, may be stored as follows in Elasticsearch in the JSON format:</p><div class="informalexample"><pre class="programlisting">{
    "text" : "We demand rigidly defined areas of doubt and uncertainty!",
    "author" : "Douglas Adams",
    "published" : "1979-10-12",
    "likes" : 583,
    "source" : "The Hitchhiker's Guide to the Galaxy",
    "tags" : ["science fiction", "satire"]
}</pre></div><p>If we let Elasticsearch <a id="id27" class="indexterm"/>dynamically assign a mapping (think <span class="emphasis"><em>schema</em></span>) to this document, it would look like this:</p><div class="informalexample"><pre class="programlisting">{
    "quote" : {
        "properties" : {
            "author" : {
                "type" : "string"
            },
            "likes" : {
                "type" : "long"
            },
            "published" : {
                "type" : "date",
                "format" : "strict_date_optional_time||epoch_millis"
            },
            "source" : {
                "type" : "string"
            },
            "tags" : {
                "type" : "string"
            },
            "text" : {
                "type" : "string"
            }
        }
    }
}</pre></div><p>Note that Elasticsearch was able to pick up that the <code class="literal">published</code> field looked like a date.</p><p>An Elasticsearch query that searches for this document looks like this:</p><div class="informalexample"><pre class="programlisting">{
    "query" : {
        "query_string" : {
            "query" : "demand rigidly"
        }
    },
    "size" : 10
}</pre></div><p>Specifics about Elasticsearch mappings<a id="id28" class="indexterm"/> and the Search API are beyond the scope of this book, but you can learn more about them through the official Elasticsearch documentation at the following links:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Elasticsearch</strong></span><a id="id29" class="indexterm"/><span class="strong"><strong> Mappings</strong></span>: <a class="ulink" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Elasticsearch Search</strong></span><a id="id30" class="indexterm"/><span class="strong"><strong> API</strong></span>: <a class="ulink" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html</a></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Elasticsearch should <a id="id31" class="indexterm"/>not be your primary data store. It does not provide guarantees, such as the <span class="strong"><strong>Atomicity, Consistency, Isolation, and Durability</strong></span> (<span class="strong"><strong>ACID</strong></span>) of a traditional SQL data store, nor the reliability guarantees of other NoSQL databases such as HBase or Cassandra. Even though Elasticsearch has built-in data redundancy and fault tolerance, it's best practice to archive your data in a separate data store in order to re-index data into Elasticsearch if needed.</p></div></div></div><div class="section" title="Similar technologies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Similar technologies</h2></div></div></div><p>This section explains a few <a id="id32" class="indexterm"/>of the many open source full-text search engines available, and discusses how they match up to Elasticsearch.</p><div class="section" title="Apache Lucene"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Apache Lucene</h3></div></div></div><p>Apache Lucene (<a class="ulink" href="https://lucene.apache.org/core/">https://lucene.apache.org/core/</a>) is an open source full-text search Java library. As<a id="id33" class="indexterm"/> mentioned earlier, Lucene is Elasticsearch's underlying search technology. Lucene also<a id="id34" class="indexterm"/> provides Elasticsearch's analytics features such as text aggregations and geospatial search. Using Apache Lucene directly is a good choice if you perform full-text search in Java on a small scale, or are building your own full-text search engine.</p><p>The benefits of<a id="id35" class="indexterm"/> using Elasticsearch over Lucene are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">REST API instead of a Java API</li><li class="listitem" style="list-style-type: disc">JSON document store</li><li class="listitem" style="list-style-type: disc">Horizontal scalability, reliability, and fault tolerance</li></ul></div><p>On the other hand, Lucene is much more lightweight and flexible to build custom applications that require full-text search integrated from the ground up.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Lucene.NET is a popular .NET port of the library written in C#</p></div></div></div><div class="section" title="Solr"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Solr</h3></div></div></div><p>Solr is another full-text search engine built on top of Apache Lucene. It has similar search, analytic, and<a id="id36" class="indexterm"/> scaling capabilities to Elasticsearch. For most applications that need a full-text search engine, choosing between Solr and Elasticsearch comes down to personal preference.</p></div><div class="section" title="Ferret"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Ferret</h3></div></div></div><p>Ferret is a full-text search <a id="id37" class="indexterm"/>engine for Ruby. It's similar to Lucene, but it is not as feature-rich. It's generally better used for Ruby applications that don't require the power (or complexity) of a search engine, such as Elasticsearch or Solr.</p></div></div></div></div>
<div class="section" title="Monitoring Elasticsearch"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Monitoring Elasticsearch</h1></div></div></div><p>Monitoring distributed systems is difficult because as the number of nodes, the number of users, and the amount of <a id="id38" class="indexterm"/>data increase, problems will begin to crop up.</p><p>Furthermore, it may not be immediately obvious if there is an error. Often, the cluster will keep running and try to recover from the error automatically. As shown in <span class="emphasis"><em>Figures 1.2</em></span>, <span class="emphasis"><em>1.3</em></span>, and <span class="emphasis"><em>1.4</em></span> earlier, a node failed, but Elasticsearch brought itself back to a <code class="literal">green</code> state without any action on our part. Unless monitored, failures such as these can go unnoticed. This can have a detrimental impact on system performance and reliability. Fewer nodes means less processing power to respond to queries, and, as in the previous example, if another node fails, our cluster won't be able to return to a <code class="literal">green</code> state.</p><p>The aspects of an Elasticsearch cluster that we'll want to keep track of include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cluster health and data availability</li><li class="listitem" style="list-style-type: disc">Node failures</li><li class="listitem" style="list-style-type: disc">Elasticsearch JVM memory usage</li><li class="listitem" style="list-style-type: disc">Elasticsearch cache size</li><li class="listitem" style="list-style-type: disc">System utilization (CPU, Memory, and Disk)</li><li class="listitem" style="list-style-type: disc">Query response times</li><li class="listitem" style="list-style-type: disc">Query rate</li><li class="listitem" style="list-style-type: disc">Data index times</li><li class="listitem" style="list-style-type: disc">Data index rate</li><li class="listitem" style="list-style-type: disc">Number of indices and shards</li><li class="listitem" style="list-style-type: disc">Index and shard size</li><li class="listitem" style="list-style-type: disc">System configuration</li></ul></div><p>In this book, we'll go over how to understand each of these variables in context and how understanding them<a id="id39" class="indexterm"/> can help diagnose, recover from, and prevent problems in our cluster. It's certainly not possible to preemptively stop all Elasticsearch errors. However, by proactively monitoring our cluster, we'll have a good idea of when things are awry and will be better positioned to take corrective action.</p><p>In the following chapters, we'll go over everything from web-based cluster monitoring tools to Unix command line tools and log file monitoring. Some of the specific tools this book covers are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Elasticsearch-head</li><li class="listitem" style="list-style-type: disc">Bigdesk</li><li class="listitem" style="list-style-type: disc">Marvel</li><li class="listitem" style="list-style-type: disc">Kopf</li><li class="listitem" style="list-style-type: disc">Kibana</li><li class="listitem" style="list-style-type: disc">Nagios</li><li class="listitem" style="list-style-type: disc">Unix command-line tools</li></ul></div><p>These tools will give us the information we need to effectively diagnose, solve, and prevent problems with Elasticsearch.</p></div>
<div class="section" title="Resourcefulness and problem solving"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Resourcefulness and problem solving</h1></div></div></div><p>Monitoring tools do a great job of telling you what is going on in your cluster, and they can often point out if there is a problem. However, these tools won't give you a recipe for how to actually fix a problem. Resolving issues takes critical thinking, attention to detail, and persistence. Some of the<a id="id40" class="indexterm"/> problem-solving themes this book talks about are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Always try to recreate the problem</li><li class="listitem" style="list-style-type: disc">Be on the lookout for configuration and user errors</li><li class="listitem" style="list-style-type: disc">Only make one configuration change at a time before testing</li></ul></div><p>This book also provides some real-world case studies that help you turn the information provided by monitoring tools into insights to resolve Elasticsearch issues.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>This chapter gave you an overview of Elasticsearch and why it's important to proactively monitor a cluster. To summarize the points from the chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Elasticsearch is an open source scalable, fast, and fault-tolerant search engine</li><li class="listitem" style="list-style-type: disc">Elasticsearch is built on top of Apache Lucene, the same library that powers Apache Solr</li><li class="listitem" style="list-style-type: disc">Monitoring tools will help us get a better understanding of our cluster and will let us know when problems arise</li><li class="listitem" style="list-style-type: disc">As helpful as monitoring tools are, it's up to us to actually diagnose and fix cluster issues</li></ul></div><p>In the next chapter, we'll cover how to get a simple Elasticsearch cluster running and loaded with data, and how to install several monitoring tools.</p></div></body></html>