<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Concurrent Programming Design</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Using immutable objects when possible</li>
<li class="calibre18">Avoiding deadlocks by ordering locks</li>
<li class="calibre18">Using atomic variables instead of synchronization</li>
<li class="calibre18">Holding locks for as short time as possible</li>
<li class="calibre18">Delegating the management of threads to executors</li>
<li class="calibre18">Using concurrent data structures instead of programming yourselves</li>
<li class="calibre18">Taking precautions using lazy initialization</li>
<li class="calibre18">Using the fork/join framework instead of executors</li>
<li class="calibre18">Avoiding the use of blocking operations inside a lock</li>
<li class="calibre18">Avoiding the use of deprecated methods</li>
<li class="calibre18">Using executors instead of thread groups</li>
<li class="calibre18">Using streams to process big data sets</li>
<li class="calibre18">Other tips and tricks</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">Implementing a concurrent application is a difficult task. You have more than one thread in an execution at a time and all of them share resources, such as files, memory, objects, and so on. You have to be very careful with the design decisions you take. A bad decision can affect your program in a way that it would lead to poor performance or simply provoke data inconsistency situations.</p>
<p class="calibre4">In this chapter, I've included some suggestions to help you take correct design decisions, which would make your concurrent application better.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using immutable objects when possible</h1>
            

            <article>
                
<p class="calibre4">When you develop an application in Java using object-oriented programming, you create some classes formed by attributes and methods. The methods of a class determine the operations that you can do with the class. Attributes store the data that defines the object. Normally, in each class, you implement some methods to establish the value of the attributes. Also, objects change as the application runs, and you use those methods to change the value of their attributes.</p>
<p class="calibre4">When you develop a concurrent application, you have to pay special attention to the objects shared by more than one thread. You must use a synchronization mechanism to protect access to such objects. If you don't use it, you may have data inconsistency problems in your application.</p>
<p class="calibre4">There are special kinds of objects that you can implement when you work with concurrent applications. They are called <strong class="calibre1">immutable objects</strong>; their main characteristic is that they can't be modified after they are created. If you need to change an immutable object, you must create a new one instead of changing the values of the attributes of the object.</p>
<p class="calibre4">This mechanism presents the following advantages when you use them in concurrent applications:</p>
<ul class="calibre17">
<li class="calibre18">These objects cannot be modified by any thread once they are created, so you won't need to use any synchronization mechanism to protect access to their attributes.</li>
<li class="calibre18">You won't have any data inconsistency problems. As the attributes of these objects cannot be modified, you will always have access to a coherent copy of the data.</li>
</ul>
<p class="calibre4">The only drawback of this approach is the overhead: creating new objects instead of modifying existing ones.</p>
<p class="calibre4">Java provides some immutable classes, such as the <kbd class="calibre15">String</kbd> class. When you have a <kbd class="calibre15">String</kbd> object and you try to assign a new value to it, you are creating a new <kbd class="calibre15">String</kbd> object instead of modifying the old value of the object. For example, check out the following code:</p>
<pre class="calibre23">
    String var = "hello"; <br class="title-page-name"/>    var = "new";
</pre>
<p class="calibre4">In the second line, JVM creates a new <kbd class="calibre15">String</kbd> object.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement an immutable class:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Mark the class as <kbd class="calibre15">final</kbd>. It should not be extended by another class.</li>
<li value="2" class="calibre18">All the attributes must be <kbd class="calibre15">final</kbd> and <kbd class="calibre15">private</kbd>. You can assign a value to an attribute only once.</li>
<li value="3" class="calibre18">Don't provide methods that can assign a value to an attribute. Attributes must be initialized in the constructor of the class.</li>
</ol>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">If any field value object is mutable (for example, <kbd class="calibre15">java.util.Date</kbd>), always return a defensive copy in the getter field.</li>
<li value="5" class="calibre18">Don't leak the <kbd class="calibre15">this</kbd> reference from the immutable class constructor (for example, the following code that leaks the <kbd class="calibre15">this</kbd> reference before the constructor is complete):</li>
</ol>
<pre class="calibre23">
        public final NotSoImmutable implements Listener { <br class="title-page-name"/>          private final int x; <br class="title-page-name"/>          public NotSoImmutable(int x, Observable o) { <br class="title-page-name"/>            this.x = x; <br class="title-page-name"/>            o.registerListener(this); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">If you want to implement a class that stores the first and last name of a person, you would normally implement something like this:</p>
<pre class="calibre23">
    public class PersonMutable { <br class="title-page-name"/>      private String firstName; <br class="title-page-name"/>      private String lastName; <br class="title-page-name"/>      private Date birthDate; <br class="title-page-name"/> <br class="title-page-name"/>      public String getFirstName() { <br class="title-page-name"/>        return firstName; <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>      public void setFirstName(String firstName) { <br class="title-page-name"/>        this.firstName = firstName; <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>      public String getLastName() { <br class="title-page-name"/>        return lastName; <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>      public void setLastName(String lastName) { <br class="title-page-name"/>        this.lastName = lastName; <br class="title-page-name"/>      } <br class="title-page-name"/>      public Date getBirthDate() { <br class="title-page-name"/>        return birthDate; <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>      public void setBirthDate(Date birthDate) { <br class="title-page-name"/>        this.birthDate = birthDate; <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>    }
</pre>
<p class="calibre4">You can convert this class into an immutable class by following the rules explained earlier. The following is the result:</p>
<pre class="calibre23">
    public final class PersonImmutable { <br class="title-page-name"/> <br class="title-page-name"/>      final private String firstName; <br class="title-page-name"/>      final private String lastName; <br class="title-page-name"/>      final private Date birthDate; <br class="title-page-name"/> <br class="title-page-name"/>      public PersonImmutable (String firstName, String lastName,<br class="title-page-name"/>                              String address, Date birthDate) { <br class="title-page-name"/>        this.firstName=firstName; <br class="title-page-name"/>        this.lastName=lastName; <br class="title-page-name"/>        this.birthDate=birthDate; <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>      public String getFirstName() { <br class="title-page-name"/>        return firstName; <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>      public String getLastName() { <br class="title-page-name"/>        return lastName; <br class="title-page-name"/>      }
</pre>
<pre class="calibre23">
      public Date getBirthDate() { <br class="title-page-name"/>        return new Date(birthDate.getTime()); <br class="title-page-name"/>      } <br class="title-page-name"/> <br class="title-page-name"/>    }
</pre>
<p class="calibre4">Essentially, you followed the basic principles of an immutable class, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">The class is marked as <kbd class="calibre15">final</kbd>.</li>
<li class="calibre18">The attributes are marked as <kbd class="calibre15">final</kbd> and <kbd class="calibre15">private</kbd>.</li>
<li class="calibre18">The value of the attributes can only be established in the constructor of the class.<br class="title-page-name"/>
Its methods return the value of an attribute, but they don't modify them.</li>
<li class="calibre18">For mutable attributes (the <kbd class="calibre15">birthDate</kbd> attribute in our case), we return a defensive copy of the <kbd class="calibre15">get()</kbd> method by creating a new object.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">Immutable objects can't always be used. Analyze each class of your application to decide whether you can implement them as immutable objects or not. If you can't implement a class as an immutable class and its objects are shared by more than one thread, you must use a synchronization mechanism to protect access to the attributes of the class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using atomic variables instead of synchronization</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Avoiding deadlocks by ordering locks</h1>
            

            <article>
                
<p class="calibre4">When you need to acquire more than one lock in the methods of your application, you must be very careful with the order in which you get control of your locks. A bad choice can lead to a deadlock situation.</p>
<p class="calibre4">In this recipe, you will implement an example of a deadlock situation, then learn how to solve it.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">BadLocks</kbd> with two methods, named <kbd class="calibre15">operation1()</kbd> and <kbd class="calibre15">operation2()</kbd>:</li>
</ol>
<pre class="calibre23">
        public class BadLocks { <br class="title-page-name"/> <br class="title-page-name"/>          private Lock lock1, lock2; <br class="title-page-name"/> <br class="title-page-name"/>          public BadLocks(Lock lock1, Lock lock2) { <br class="title-page-name"/>            this.lock1=lock1; <br class="title-page-name"/>            this.lock2=lock2; <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>          public void operation1(){ <br class="title-page-name"/>            lock1.lock(); <br class="title-page-name"/>            lock2.lock(); <br class="title-page-name"/> <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } finally { <br class="title-page-name"/>              lock2.unlock(); <br class="title-page-name"/>              lock1.unlock(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>          public void operation2(){ <br class="title-page-name"/>            lock2.lock(); <br class="title-page-name"/>            lock1.lock(); <br class="title-page-name"/> <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } finally { <br class="title-page-name"/>              lock1.unlock(); <br class="title-page-name"/>              lock2.unlock(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Let's analyze the preceding code. If a thread calls the <kbd class="calibre15">operation1()</kbd> method and another thread calls the <kbd class="calibre15">operation2()</kbd> method, you can have a deadlock. If both <kbd class="calibre15">operation1()</kbd> and <kbd class="calibre15">operation2()</kbd> execute their respective first sentences at the same time, you will have the <kbd class="calibre15">operation1()</kbd> method waiting to get control of <kbd class="calibre15">lock2</kbd> and the <kbd class="calibre15">operation2()</kbd> method waiting to get control of <kbd class="calibre15">lock1</kbd>. Now you have a deadlock situation.</li>
<li value="3" class="calibre18">To solve this situation, you can follow this rule:</li>
</ol>
<div class="calibre26">
<ul class="calibre17">
<li class="calibre18">If you have to get control of more than one lock in different operations, try to lock them in the same order in all methods.</li>
<li class="calibre18">Then, release them in inverse order and encapsulate the locks and their unlocks in a single class. This is so that you don't have synchronization-related code distributed throughout the code.</li>
</ul>
</div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">Using this rule, you will avoid deadlock situations. For example, in the case presented earlier, you can change <kbd class="calibre15">operation2()</kbd> to first get <kbd class="calibre15">lock1</kbd> and then <kbd class="calibre15">lock2</kbd>. Now if both <kbd class="calibre15">operation1()</kbd> and <kbd class="calibre15">operation2()</kbd> execute their respective first sentences, one of them will be blocked waiting for <kbd class="calibre15">lock1</kbd> and the other will get <kbd class="calibre15">lock1</kbd> and <kbd class="calibre15">lock2</kbd> and they will do their operations. After this, the blocked thread will get the <kbd class="calibre15">lock1</kbd> and <kbd class="calibre15">lock2</kbd> locks and it will do its operation.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You can find a situation where a requirement prevents you from getting the locks in the same order in all the operations. In this situation, you can use the <kbd class="calibre15">tryLock()</kbd> method of the <kbd class="calibre15">Lock</kbd> class. This method returns a <kbd class="calibre15">Boolean</kbd> value to indicate whether you have control of the lock. You can try to get all the locks that you need to do the operation using the <kbd class="calibre15">tryLock()</kbd> method. If you can't get control of one of the locks, you must release all the locks that you may have had and start the operation again.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Holding locks for as short a time period as possible</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using atomic variables instead of synchronization</h1>
            

            <article>
                
<p class="calibre4">When you have to share data between multiple threads, you have to protect access to that piece of data using a synchronization mechanism. You can use the <kbd class="calibre15">synchronized</kbd> keyword in the declaration of the method that modifies the data so that only one thread can modify data at a time. Another possibility is the utilization of a <kbd class="calibre15">Lock</kbd> class to create a critical section with instructions that modify data.</p>
<p class="calibre4">Since version 5, Java includes atomic variables. When a thread is doing an operation with an atomic variable, the implementation of the class includes a mechanism to check that the operation is done in one step. Basically, the operation gets the value of the variable, changes the value in a local variable, and then tries to change the old value with the new one. If the old value is still the same, it does the change. If not, the method begins the operation again. Java provides the following types of atomic variables:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">AtomicBoolean</kbd></li>
<li class="calibre18"><kbd class="calibre15">AtomicInteger</kbd></li>
<li class="calibre18"><kbd class="calibre15">AtomicLong</kbd></li>
<li class="calibre18"><kbd class="calibre15">AtomicReference</kbd></li>
</ul>
<p class="calibre4">In some cases, Java's atomic variables offer a better performance than solutions based on synchronization mechanisms (specially when we care about atomicity within each separate variable). Some classes of the <kbd class="calibre15">java.util.concurrent</kbd> package use atomic variables instead of synchronization. In this recipe, you will develop an example that shows how an atomic attribute provides better performance than synchronization.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">TaskAtomic</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class TaskAtomic implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">AtomicInteger</kbd> attribute named <kbd class="calibre15">number</kbd>:</li>
</ol>
<pre class="calibre23">
        private final AtomicInteger number;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public TaskAtomic () { <br class="title-page-name"/>          this.number=new AtomicInteger(); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. In a loop with 1,000,000 steps, assign the number of steps to the atomic attribute as a value, using the <kbd class="calibre15">set()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;1000000; i++) { <br class="title-page-name"/>            number.set(i); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">TaskLock</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class TaskLock implements Runnable {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">number</kbd> and a private <kbd class="calibre15">Lock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private Lock lock; <br class="title-page-name"/>        private int number;
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public TaskLock() { <br class="title-page-name"/>          this.lock=new ReentrantLock(); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. In a loop with 1,000,000 steps, assign the number of the steps to the integer attribute. You have to get the lock before the assignment and release it after:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;1000000; i++) { <br class="title-page-name"/>            lock.lock(); <br class="title-page-name"/>            number=i; <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a <kbd class="calibre15">TaskAtomic</kbd> object named <kbd class="calibre15">atomicTask</kbd>:</li>
</ol>
<pre class="calibre23">
        TaskAtomic atomicTask=new TaskAtomic();
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a <kbd class="calibre15">TaskLock</kbd> object named <kbd class="calibre15">lockTask</kbd>:</li>
</ol>
<pre class="calibre23">
        TaskLock lockTask=new TaskLock();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Declare the number of threads and create an array of <kbd class="calibre15">Thread</kbd> objects to store the threads:</li>
</ol>
<pre class="calibre23">
        int numberThreads=50; <br class="title-page-name"/>        Thread threads[]=new Thread[numberThreads]; <br class="title-page-name"/>        Date begin, end;
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Launch the specified number of threads to execute the <kbd class="calibre15">TaskLock</kbd> object. Calculate and write its execution time in the console:</li>
</ol>
<pre class="calibre23">
        begin=new Date(); <br class="title-page-name"/>        for (int i=0; i&lt;numberThreads; i++) { <br class="title-page-name"/>          threads[i]=new Thread(lockTask); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        }
</pre>
<pre class="calibre23">
        for (int i=0; i&lt;numberThreads; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        end=new Date(); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("Main: Lock results: %d\n",<br class="title-page-name"/>                          (end.getTime()-begin.getTime()));
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Launch the specified number of threads to execute the <kbd class="calibre15">TaskAtomic</kbd> object. Calculate and write its execution time in the console:</li>
</ol>
<pre class="calibre23">
        begin=new Date(); <br class="title-page-name"/>        for (int i=0; i&lt;numberThreads; i++) { <br class="title-page-name"/>          threads[i]=new Thread(atomicTask); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        for (int i=0; i&lt;numberThreads; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        end=new Date(); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("Main: Atomic results: %d\n",<br class="title-page-name"/>                          (end.getTime()-begin.getTime()));
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">When you execute the example, you will see how the execution time of the <kbd class="calibre15">TaskAtomic</kbd> tasks that use atomic variables are always better than the <kbd class="calibre15">TaskLock</kbd> tasks that use locks. You will obtain a similar result if you use the <kbd class="calibre15">synchronized</kbd> keyword instead of locks.</p>
<p class="calibre4">The conclusion of this recipe is that utilization of atomic variables will give you better performance than other synchronization methods. If you don't have an atomic type that fits your needs, maybe you can try to implement your own atomic type.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Implementing your own atomic object</em> recipe in <a href="part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9">Chapter 8</a>, <em class="calibre14">Customizing Concurrency Classes</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Holding locks for as short time as possible</h1>
            

            <article>
                
<p class="calibre4">Locks, just like other synchronization mechanisms, allow the definition of a critical section that only one thread can execute at a time. You must be very careful to define the critical section. It must only include those instructions that really need mutual exclusion. This is especially true if the critical section includes long operations. If the critical section includes lengthy operations that do not use shared resources, application performance will be worse than it could be.</p>
<p class="calibre4">In this recipe, you will implement an example to see the difference in the performance of a task with a long operation inside the critical section and a task with a long operation outside the critical section.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Operations</kbd>:</li>
</ol>
<pre class="calibre23">
        public class Operations {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement a <kbd class="calibre15">public static</kbd> method named <kbd class="calibre15">readData()</kbd>. It puts the current thread to sleep for 500 milliseconds:</li>
</ol>
<pre class="calibre23">
        public static void readData(){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(500); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement a <kbd class="calibre15">public static</kbd> method named <kbd class="calibre15">writeData()</kbd>. It puts the current thread to sleep for 500 milliseconds:</li>
</ol>
<pre class="calibre23">
        public static void writeData(){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(500); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement a <kbd class="calibre15">public static</kbd> method named <kbd class="calibre15">processData()</kbd>. It puts the current thread to sleep for 2,000 milliseconds:</li>
</ol>
<pre class="calibre23">
        public static void processData(){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement a class named <kbd class="calibre15">Task1</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task1 implements Runnable {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare a private <kbd class="calibre15">Lock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Lock lock;
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task1 (Lock lock) { <br class="title-page-name"/>          this.lock=lock; <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Acquire the lock, call the three operations of the <kbd class="calibre15">Operations</kbd> class, and release the lock:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          Operations.readData(); <br class="title-page-name"/>          Operations.processData(); <br class="title-page-name"/>          Operations.writeData(); <br class="title-page-name"/>          lock.unlock(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement a class named <kbd class="calibre15">Task2</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task2 implements Runnable {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a private <kbd class="calibre15">Lock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Lock lock;
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task2 (Lock lock) { <br class="title-page-name"/>          this.lock=lock; <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Acquire the lock, call the <kbd class="calibre15">readData()</kbd> operation, and release the lock. Then, call the <kbd class="calibre15">processData()</kbd> method, acquire the lock, call the <kbd class="calibre15">writeData()</kbd> operation, and release the lock:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          Operations.readData(); <br class="title-page-name"/>          lock.unlock(); <br class="title-page-name"/>          Operations.processData(); <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          Operations.writeData(); <br class="title-page-name"/>          lock.unlock(); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create a <kbd class="calibre15">Lock</kbd> object named <kbd class="calibre15">lock</kbd>, a <kbd class="calibre15">Task1</kbd> object named <kbd class="calibre15">task1</kbd>, a <kbd class="calibre15">Task2</kbd> object named <kbd class="calibre15">task2</kbd>, and an array of 10 threads:</li>
</ol>
<pre class="calibre23">
        Lock lock=new ReentrantLock(); <br class="title-page-name"/>        Task1 task1=new Task1(lock); <br class="title-page-name"/>        Task2 task2=new Task2(lock); <br class="title-page-name"/>        Thread threads[]=new Thread[10];
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Launch 10 threads to execute the first task by controlling its execution time:</li>
</ol>
<pre class="calibre23">
        Date begin, end; <br class="title-page-name"/> <br class="title-page-name"/>        begin=new Date(); <br class="title-page-name"/>        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          threads[i]=new Thread(task1); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        end=new Date(); <br class="title-page-name"/>        System.out.printf("Main: First Approach: %d\n",<br class="title-page-name"/>                          (end.getTime()-begin.getTime()));
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Launch 10 threads to execute the second task by controlling its execution time:</li>
</ol>
<pre class="calibre23">
        begin=new Date(); <br class="title-page-name"/>        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          threads[i]=new Thread(task2); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        end=new Date(); <br class="title-page-name"/>        System.out.printf("Main: Second Approach: %d\n",<br class="title-page-name"/>                          (end.getTime()-begin.getTime()));
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">If you execute the example, you will see a big difference between the execution time of the two approaches. The task that has all the operations inside the critical section takes longer than the other task.</p>
<p class="calibre4">When you need to implement a block of code protected by a lock, analyze it carefully to only include necessary instructions. Split the method into various critical sections, and use more than one lock if necessary to get the best performance of your application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Avoiding deadlocks by ordering locks</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Delegating the management of threads to executors</h1>
            

            <article>
                
<p class="calibre4">Before Java 5, the Java Concurrency API, when we wanted to implement a concurrent application, we had to manage the threads by ourselves. First we used to implement the <kbd class="calibre15">Runnable</kbd> interface or an extension of the <kbd class="calibre15">Thread</kbd> class. Then, we used to create a <kbd class="calibre15">thread</kbd> object and start its execution using its <kbd class="calibre15">start()</kbd> method. We also had to control its status to know whether the thread had finished its execution or was still running.</p>
<p class="calibre4">In Java version 5, the concept of executor as a provider of a pool of execution threads appeared. This mechanism, implemented by the <kbd class="calibre15">Executor</kbd> and <kbd class="calibre15">ExecutorService</kbd> interfaces and the <kbd class="calibre15">ThreadPoolExecutor</kbd> and <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> classes, allows you to concentrate only on the implementation of the logic of the task. You implement the task and send it to the executor. It has a pool of threads, and it is this pool that is responsible for the creation, management, and finalization of the threads. In Java version 7, another implementation of the executor mechanism in the fork/join framework, specialized in problems that can be broken down into smaller subproblems, appeared. This approach has numerous advantages, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">We don't have to create threads for all the tasks. When we send a task to the executor and it's executed by a thread of the pool, we save the time used in creating a new thread. If our application has to execute a lot of tasks, the total saved time will be significant and the performance of the application will be better.</li>
<li class="calibre18">If we create fewer threads, our application will use less memory as well. This can also extract better performance from our application.</li>
<li class="calibre18">We can build concurrent tasks executed in the executor by implementing either the <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> interface. The <kbd class="calibre15">Callable</kbd> interface allows us to implement tasks that return a result, which provide a big advantage over traditional tasks.</li>
<li class="calibre18">When we send a task to an executor, it returns a <kbd class="calibre15">Future</kbd> object that allows us to know the status of the task and the returned result, whether it has finished its execution easily.</li>
<li class="calibre18">We can schedule our tasks and execute them repeatedly with the special executor implemented by the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class.</li>
<li class="calibre18">We can easily control the resources used by an executor. We can establish the maximum number of threads in the pool, so our executor will never have more than that number of tasks running at a time.</li>
</ul>
<p class="calibre4">The use of executors has a lot of advantages over direct utilization of threads. In this recipe, you are going to implement an example that shows how you can obtain better performance using an executor than creating the threads yourself.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Create a loop with 1,000,000 steps, and in each step, do some mathematical operations with an integer variable:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          int r; <br class="title-page-name"/>          for (int i=0; i&lt;1000000; i++) { <br class="title-page-name"/>            r=0; <br class="title-page-name"/>            r++; <br class="title-page-name"/>            r++; <br class="title-page-name"/>            r*=r; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create 1,000 threads to execute 1,000 task objects and wait for their finalization, controlling the total execution time:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[1000]; <br class="title-page-name"/>        Date start,end; <br class="title-page-name"/> <br class="title-page-name"/>        start=new Date(); <br class="title-page-name"/>        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          Task task=new Task(); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        end=new Date(); <br class="title-page-name"/>        System.out.printf("Main: Threads: %d\n",<br class="title-page-name"/>                          (end.getTime()-start.getTime()));
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create an <kbd class="calibre15">Executor</kbd> object, send 1,000 <kbd class="calibre15">Task</kbd> objects to it, and wait for their finalization. Measure the total execution time:</li>
</ol>
<pre class="calibre23">
        ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors<br class="title-page-name"/>                                                .newCachedThreadPool(); <br class="title-page-name"/> <br class="title-page-name"/>        start=new Date();
</pre>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          Task task=new Task(); <br class="title-page-name"/>          executor.execute(task); <br class="title-page-name"/>        } <br class="title-page-name"/>        executor.shutdown(); <br class="title-page-name"/>        try { <br class="title-page-name"/>          executor.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>        end=new Date(); <br class="title-page-name"/>        System.out.printf("Main: Executor: %d\n",<br class="title-page-name"/>                          (end.getTime()-start.getTime()));
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the entire execution of this example, we always obtained a smaller execution time for the executor than creating the thread directly. If your application has to execute a lot of tasks, better employ an executor.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using executors instead of thread groups</em> and <em class="calibre14">Using the fork/join framework instead of executors</em> recipes in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using concurrent data structures instead of programming yourself</h1>
            

            <article>
                
<p class="calibre4">Data structures are an essential part of every program. You always have to manage the data that you store in a data structure. Arrays, lists, or trees are examples of common data structures. The Java API provides a lot of ready-to-use data structures, but when you work with concurrent applications, you have to be careful because not all structures provided by the Java API are <strong class="calibre1">thread-safe</strong>. If you choose a data structure that is not thread-safe, you can have inconsistent data in your applications.</p>
<p class="calibre4">When you want to use a data structure in your concurrent application, you have to review the documentation of the class that implements that data structure to check that it supports concurrent operations. Java provides the following two kinds of concurrent data structures:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Non-blocking data structures</strong>: All the operations provided by these data structures to either insert in or take off elements from the data structure return a null value if they can't be done currently because the data structure is full or empty respectively.</li>
<li class="calibre18"><strong class="calibre1">Blocking data structures</strong>: These data structures provide the same operations that are provided by non-blocking data structures. However, they also provide operations to insert and take off data that, if not done immediately, would block the thread until you're able to do the operations.</li>
</ul>
<p class="calibre4">These are some data structures provided by the Java API that you can use in your concurrent applications:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">ConcurrentLinkedDeque</kbd>: This is a non-blocking data structure based on linked nodes that allow you to insert data at the beginning or end of the structure.</li>
<li class="calibre18"><kbd class="calibre15">LinkedBlockingDeque</kbd>: This is a blocking data structure based on linked nodes. It can have fixed capacity. You can insert elements at the beginning or end of the structure. It provides operations that, if not done immediately, block the thread until you're able to do the operation.</li>
<li class="calibre18"><kbd class="calibre15">ConcurrentLinkedQueue</kbd>: This is a non-blocking queue that allows you to insert elements at the end of the queue and take elements from its beginning.</li>
<li class="calibre18"><kbd class="calibre15">ArrayBlockingQueue</kbd>: This is a blocking queue with fixed size. You insert elements at the end of the queue and take elements from its beginning. It provides operations that, if not done because the queue is either full or empty, puts the thread to sleep until you're able to do the operation.</li>
<li class="calibre18"><kbd class="calibre15">LinkedBlockingQueue</kbd>: This is a blocking queue that allows you to insert elements at the end of the queue and take off elements from its beginning. It provides operations that, if not done because the queue is either full or empty, puts the thread to sleep until you're able to do the operation.</li>
<li class="calibre18"><kbd class="calibre15">DelayQueue</kbd>: This is a <kbd class="calibre15">LinkedBlockingQueue</kbd> queue with delayed elements. Every element inserted in this queue must implement the <kbd class="calibre15">Delayed</kbd> interface. An element can't be taken off the list until its delay is 0.</li>
<li class="calibre18"><kbd class="calibre15">LinkedTransferQueue</kbd>: This is a blocking queue that provides operations to work in situations that can be implemented as a producer/consumer problem. It provides operations that, if not done because the queue is either full or empty, puts the thread to sleep until you're able to do the operation.</li>
<li class="calibre18"><kbd class="calibre15">PriorityBlockingQueue</kbd>: This is a blocking queue that orders its elements based on priority. All the elements inserted in this queue must implement the <kbd class="calibre15">Comparable</kbd> interface. The value returned by the <kbd class="calibre15">compareTo()</kbd> method will determine the position of the element in the queue. Just like all the blocking data structures, it provides operations that, if done immediately, puts the thread to sleep until you're able to do the operation.</li>
<li class="calibre18"><kbd class="calibre15">SynchronousQueue</kbd>: This is a blocking queue where every <kbd class="calibre15">insert</kbd> operation must wait for a <kbd class="calibre15">remove</kbd> operation for the other thread. The two operations must be done at the same time.</li>
<li class="calibre18"><kbd class="calibre15">ConcurrentHashMap</kbd>: This is a <kbd class="calibre15">HashMap</kbd> that allows concurrent operations. It's a non-blocking data structure.</li>
<li class="calibre18"><kbd class="calibre15">ConcurrentSkipListMap</kbd>: This data structure associates keys with values. Every key can have only one value. It stores the keys in an ordered way and provides a method to find elements and get some elements from the map. It's a non-blocking data structure.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">If you need to use a data structure in your concurrent application, look in the Java API documentation to find the data structure that best fits your needs. Implement your own concurrent data structure that has some problems, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">They have a complex internal structure</li>
<li class="calibre18">You have to take into account a lot of different situations</li>
<li class="calibre18">You have to design a lot of tests to guarantee that it works correctly</li>
</ul>
<p class="calibre4">If you don't find a data structure that fits your needs completely, try to extend one of the existing concurrent data structures to implement one adequately to your problem.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The recipes in <a href="part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre14">Concurrent Collections</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Taking precautions using lazy initialization</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">Lazy initialization</strong> is a common programming technique that delays object creation until it is needed for the first time. This normally causes the initialization of the objects to be made in the implementation of the operations, instead of the constructor of the classes. The main advantage of this technique is that you can save memory. This is because you only create the indispensable objects needed for the execution of your applications. You could have declared a lot of objects in one class, but you don't use every object in every execution of your program; therefore, your application doesn't use the memory needed for the objects that you don't use in an execution of the program. This advantage can be very useful for applications that run in environments with limited resources.</p>
<p class="calibre4">By contrast, this technique has the disadvantage of having performance issues in your application, as you create objects the first time they are used inside an operation.</p>
<p class="calibre4">This technique can also provoke problems if you use it in concurrent applications. As more than one thread can be executing an operation at a time, they can be creating an object at the same time, and this situation can be problematic. This has a special importance with <strong class="calibre1">singleton</strong> classes. An application has only one object of these classes and, as mentioned earlier, a concurrent application can create more than one object. Consider the following code:</p>
<pre class="calibre23">
    public static DBConnection getConnection(){ <br class="title-page-name"/>      if (connection==null) { <br class="title-page-name"/>        connection=new DBConnection(); <br class="title-page-name"/>      } <br class="title-page-name"/>      return connection; <br class="title-page-name"/>    }
</pre>
<p class="calibre4">This is the typical method in a singleton class to obtain the reference of the unique object of that class existing in the application, using lazy initialization. If the object hasn't been created yet, it creates the object. Finally, it always returns it.</p>
<p class="calibre4">If two or more threads executes at the same time the comparison of the first sentence (<kbd class="calibre15">connection == null</kbd>), all of them will create a <kbd class="calibre15">Connection</kbd> object. This isn't a desirable situation.</p>
<p class="calibre4">In this recipe, you will implement an elegant solution to the lazy initialization problem.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">DBConnectionOK</kbd>:</li>
</ol>
<pre class="calibre23">
        public class DBConnectionOK {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a <kbd class="calibre15">private</kbd> constructor. Write the name of the thread that executes it:</li>
</ol>
<pre class="calibre23">
        private DBConnectionOK() { <br class="title-page-name"/>          System.out.printf("%s: Connection created.\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a <kbd class="calibre15">private static</kbd> class named <kbd class="calibre15">LazyDBConnectionOK</kbd>. It has a <kbd class="calibre15">private static final DBConnectionOK</kbd> instance named <kbd class="calibre15">INSTANCE</kbd>:</li>
</ol>
<pre class="calibre23">
        private static class LazyDBConnection { <br class="title-page-name"/>          private static final DBConnectionOK INSTANCE = new<br class="title-page-name"/>                                                   DBConnectionOK(); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">getConnection()</kbd> method. It doesn't receive any parameter and returns a <kbd class="calibre15">DBConnectionOK</kbd> object. It returns the <kbd class="calibre15">INSTANCE</kbd> object:</li>
</ol>
<pre class="calibre23">
        public static DBConnectionOK getConnection() { <br class="title-page-name"/>          return LazyDBConnection.INSTANCE; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. Implement the <kbd class="calibre15">run()</kbd> method. Call the <kbd class="calibre15">getConnection()</kbd> method of the <kbd class="calibre15">DBConnectionOK()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable { <br class="title-page-name"/> <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void run() { <br class="title-page-name"/> <br class="title-page-name"/>            System.out.printf("%s: Getting the connection...\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/>            DBConnectionOK connection=DBConnectionOK.getConnection(); <br class="title-page-name"/>            System.out.printf("%s: End\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create 20 <kbd class="calibre15">Task</kbd> objects and 20 threads to execute them:</li>
</ol>
<pre class="calibre23">
            for (int i=0; i&lt;20; i++){ <br class="title-page-name"/>              Task task=new Task(); <br class="title-page-name"/>              Thread thread=new Thread(task); <br class="title-page-name"/>              thread.start(); <br class="title-page-name"/>            } <br class="title-page-name"/>          }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key of the example is the <kbd class="calibre15">getConnection()</kbd> method and the <kbd class="calibre15">private static class LazyDBConnection</kbd> instance. When the first thread calls the <kbd class="calibre15">getConnection()</kbd> method, the <kbd class="calibre15">LazyDBConnection</kbd> class initializes the <kbd class="calibre15">INSTANCE</kbd> object by calling the constructor of the <kbd class="calibre15">DBConnection</kbd> class. This object is returned by the <kbd class="calibre15">getConnection()</kbd> method. When the rest of the threads call the <kbd class="calibre15">getConnection()</kbd> method, the object is already created, so all the threads use the same object that is created only once.</p>
<p class="calibre4">When you run the example, you will see the start and end messages of 20 tasks, but only one creation message.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using the fork/join framework instead of executors</h1>
            

            <article>
                
<p class="calibre4">Executors allow you to avoid the creation and management of threads. You implement tasks by implementing <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> interfaces and sending them to the executor. It has a pool of threads and uses one of them to execute the tasks.</p>
<p class="calibre4">Java 7 provides a new kind of executor with the fork/join framework. This executor, implemented in the <kbd class="calibre15">ForkJoinPool</kbd> class, is designed for problems that can be split into smaller parts using the divide and conquer technique. When you implement a task for the fork/join framework, you have to check the size of the problem you have to resolve. If it's bigger than a predefined size, you divide the problem into two or more subcategories and create as many subtasks as the number of divisions you have made. The task sends these subtasks to the <kbd class="calibre15">ForkJoinPool</kbd> class using the <kbd class="calibre15">fork()</kbd> operation and waits for its finalization using the <kbd class="calibre15">join()</kbd> operation.</p>
<p class="calibre4">For these kinds of problems, fork/join pools get better performance than classical executors. In this recipe, you are going to implement an example where you can check this point.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">TaskFJ</kbd> and specify that it extends the <kbd class="calibre15">RecursiveAction</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class TaskFJ extends RecursiveAction {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private array of <kbd class="calibre15">int</kbd> numbers named <kbd class="calibre15">array</kbd>:</li>
</ol>
<pre class="calibre23">
        private final int array[];
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare two private <kbd class="calibre15">int</kbd> attributes, named <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd>:</li>
</ol>
<pre class="calibre23">
        private final int start, end;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public TaskFJ(int array[], int start, int end) { <br class="title-page-name"/>          this.array=array; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method. If this task has to process a block of more than 1,000 elements (determined by the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes), create two <kbd class="calibre15">TaskFJ</kbd> objects, send them to the <kbd class="calibre15">ForkJoinPool</kbd> class using the <kbd class="calibre15">fork()</kbd> method, and wait for their finalization using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void compute() { <br class="title-page-name"/>          if (end-start&gt;1000) { <br class="title-page-name"/>            int mid=(start+end)/2; <br class="title-page-name"/>            TaskFJ task1=new TaskFJ(array,start,mid); <br class="title-page-name"/>            TaskFJ task2=new TaskFJ(array,mid,end); <br class="title-page-name"/>            task1.fork(); <br class="title-page-name"/>            task2.fork(); <br class="title-page-name"/>            task1.join(); <br class="title-page-name"/>            task2.join();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Otherwise, increment the elements that this task has to process. After every increment operation, put the thread to sleep for 1 millisecond:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>          for (int i=start; i&lt;end; i++) { <br class="title-page-name"/>            array[i]++; <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.MILLISECONDS.sleep(1); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a private array of <kbd class="calibre15">int</kbd> number named <kbd class="calibre15">array</kbd>:</li>
</ol>
<pre class="calibre23">
        private final int array[];
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Task(int array[]) { <br class="title-page-name"/>          this.array=array; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Increment all the elements of the array. After every increment operation, put the thread to sleep for 1 millisecond:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;array.length; i++ ){ <br class="title-page-name"/>            array[i]++; <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.MILLISECONDS.sleep(1); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create an <kbd class="calibre15">int</kbd> array with 100,000 elements:</li>
</ol>
<pre class="calibre23">
        int array[]=new int[100000];
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object and a <kbd class="calibre15">ThreadPoolExecutor</kbd> object and execute them. Execute the task by controlling the time during which the task is running:</li>
</ol>
<pre class="calibre23">
        Task task=new Task(array); <br class="title-page-name"/>        ExecutorService executor=Executors.newCachedThreadPool(); <br class="title-page-name"/> <br class="title-page-name"/>        Date start,end; <br class="title-page-name"/>        start=new Date(); <br class="title-page-name"/>        executor.execute(task); <br class="title-page-name"/>        executor.shutdown(); <br class="title-page-name"/>        try { <br class="title-page-name"/>          executor.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>        end=new Date(); <br class="title-page-name"/>        System.out.printf("Main: Executor: %d\n",<br class="title-page-name"/>                          (end.getTime()-start.getTime()));
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create a <kbd class="calibre15">TaskFJ</kbd> object and a <kbd class="calibre15">ForkJoinPool</kbd> object and execute them. Execute the task by controlling the time during which the task is running:</li>
</ol>
<pre class="calibre23">
          TaskFJ taskFJ=new TaskFJ(array,1,100000); <br class="title-page-name"/>          ForkJoinPool pool=new ForkJoinPool(); <br class="title-page-name"/>          start=new Date(); <br class="title-page-name"/>          pool.execute(taskFJ); <br class="title-page-name"/>          pool.shutdown(); <br class="title-page-name"/>          try { <br class="title-page-name"/>            pool.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          end=new Date(); <br class="title-page-name"/>          System.out.printf("Core: Fork/Join: %d\n",<br class="title-page-name"/>                            (end.getTime()-start.getTime())); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">When you execute the example, you will see how the <kbd class="calibre15">ForkJoinPool</kbd> and <kbd class="calibre15">TaskFJ</kbd> classes get better performance than the <kbd class="calibre15">ThreadPoolExecutor</kbd> and <kbd class="calibre15">Task</kbd> classes.</p>
<p class="calibre4">If you have to solve a problem that can be split using the divide and conquer technique, use a <kbd class="calibre15">ForkJoinPool</kbd> class instead of a <kbd class="calibre15">ThreadPoolExecutor</kbd> class. You will get better performance.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Delegating the management of threads to executors</em> recipe of this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Avoiding the use of blocking operations inside a lock</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">Blocking operations</strong> are operations that block the execution of the current thread until an event occurs. Typical blocking operations are those that involve input or output operations with the console, a file, or network.</p>
<p class="calibre4">If you use a blocking operation inside the critical section of a lock, you're deteriorating the performance of the application. While a thread is waiting for the event that would finish the blocking operation, the rest of the application might be waiting for the same event as well; however, none of the other threads will have access to the critical section and execute its code (the code of the critical section).</p>
<p class="calibre4">In this recipe, you will implement an example of this situation. The threads read a line from the console inside the critical section. This instruction makes the rest of the threads of the application will be blocked until the user introduces the line.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">Lock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Lock lock;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Task (Lock lock) { <br class="title-page-name"/>          this.lock=lock; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("%s: Starting\n",<br class="title-page-name"/>                            Thread.currentThread().getName());
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Acquire the lock using the <kbd class="calibre15">lock()</kbd> method:</li>
</ol>
<pre class="calibre23">
        lock.lock();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Call the <kbd class="calibre15">criticalSection()</kbd> method:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          criticalSection();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Read a line from the console:</li>
</ol>
<pre class="calibre23">
          System.out.printf("%s: Press a key to continue: \n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          InputStreamReader converter = new InputStreamReader<br class="title-page-name"/>                                                    (System.in); <br class="title-page-name"/>          BufferedReader in = new BufferedReader(converter); <br class="title-page-name"/>          String line=in.readLine(); <br class="title-page-name"/>        } catch (IOException e) { <br class="title-page-name"/>          e.printStackTrace();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Free the lock using the <kbd class="calibre15">unlock()</kbd> method in the finally section:</li>
</ol>
<pre class="calibre23">
          } finally {          <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">criticalSection()</kbd> method. Wait for a random period of time:</li>
</ol>
<pre class="calibre23">
        private void criticalSection() { <br class="title-page-name"/>          Random random=new Random(); <br class="title-page-name"/>          int wait=random.nextInt(10); <br class="title-page-name"/>          System.out.printf("%s: Wait for %d seconds\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),wait); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(wait); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the main class of the application by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a new <kbd class="calibre15">ReentrantLock</kbd> object named <kbd class="calibre15">lock</kbd>. Create 10 <kbd class="calibre15">Task</kbd> objects and 10 threads to execute them:</li>
</ol>
<pre class="calibre23">
        ReentrantLock lock=new ReentrantLock(); <br class="title-page-name"/>        for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>          Task task=new Task(lock); <br class="title-page-name"/>          Thread thread=new Thread(task); <br class="title-page-name"/>          thread.start(); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">When you execute this example, 10 threads start their execution, but only one enters in the critical section, which gets implemented in the <kbd class="calibre15">run()</kbd> method. As every task reads a line from the console before releasing the lock, all the applications will be blocked until you introduce text in the console.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Holding locks for as short a time period as possible</em> recipe</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Avoiding the use of deprecated methods</h1>
            

            <article>
                
<p class="calibre4">The Java concurrency API also has deprecated operations. These are operations that were included in the first versions of the API, but now you shouldn't use them. They have been replaced by other operations that implement better practices than the original ones.</p>
<p class="calibre4">The more critical deprecated operations are those that are provided by the <kbd class="calibre15">Thread</kbd> class. These operations are:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">destroy()</kbd>: In the past, this method destroyed the thread. Actually, it throws a <kbd class="calibre15">NoSuchMethodError</kbd> exception.</li>
<li class="calibre18"><kbd class="calibre15">suspend()</kbd>: This method suspends the execution of the thread until it's resumed.</li>
<li class="calibre18"><kbd class="calibre15">stop()</kbd>: This method forces the thread to finish its execution.</li>
<li class="calibre18"><kbd class="calibre15">resume()</kbd>: This method resumes the execution of the thread.</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">ThreadGroup</kbd> class also has some deprecated methods, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">suspend()</kbd>: This method suspends the execution of all the threads that belong to this thread group until they resume</li>
<li class="calibre18"><kbd class="calibre15">stop()</kbd>: This method forces the execution of all the threads of this thread group to finish</li>
<li class="calibre18"><kbd class="calibre15">resume()</kbd>: This method resumes the execution of all the threads of this thread group</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">stop()</kbd> operation has been deprecated because it can provoke inconsistent errors. As it forces the thread to finish its execution, you can have a thread that finishes its execution before the completion of an operation and can leave the data in an inconsistent status. For example, if you have a thread that is modifying a bank account and it's stopped before it is finished, the bank account will probably have erroneous data.</p>
<p class="calibre4">The <kbd class="calibre15">stop()</kbd> operation can also cause a deadlock situation. If this operation is called when the thread is executing a critical section protected by a synchronization mechanism (for example, a lock), this synchronization mechanism will continue to block and no thread will be able to enter the critical section. This is the reason why the <kbd class="calibre15">suspend()</kbd> and <kbd class="calibre15">resume()</kbd> operations have been deprecated.</p>
<p class="calibre4">If you need an alternative to these operations, you can use an internal attribute to store the status of the thread. This attribute must be protected with synchronized access, or use an atomic variable. You must check the value of this attribute and take actions according to it. Take into account that you have to avoid data inconsistency and deadlock situations to guarantee the correct operation of your application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using executors instead of thread groups</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ThreadGroup</kbd> class provides a mechanism to group threads in a hierarchical structure so you can do operations with all the threads that belong to a thread group with only one call. By default, all the threads belong to the same group, but you can specify a different one when you create the thread.</p>
<p class="calibre4">Anyway, thread groups don't provide any features that make their use interesting:</p>
<ul class="calibre17">
<li class="calibre18">You have to create the threads and manage their status</li>
<li class="calibre18">The methods that control the status of all the threads of the thread group have been deprecated and their use is discouraged</li>
</ul>
<p class="calibre4">If you need to group threads under a common structure, it is better to use an <kbd class="calibre15">Executor</kbd> implementation, such as <kbd class="calibre15">ThreadPoolExecutor</kbd>. It provides more functionalities, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">You don't have to worry about the management of the threads. The executor creates and reuses them to save execution resources.</li>
<li class="calibre18">You can implement your concurrent tasks by implementing either the <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> interface. The <kbd class="calibre15">Callable</kbd> interface allows you to implement tasks that return a result, which provides a big advantage over traditional tasks.</li>
<li class="calibre18">When you send a task to an executor, it returns a <kbd class="calibre15">Future</kbd> object that allows you to know the status of the task and the returned result if it has finished its execution easily.</li>
<li class="calibre18">You can schedule your tasks and execute them repeatedly with the special executor implemented by the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class.</li>
<li class="calibre18">You can easily control the resources used by an executor. You can establish the maximum number of threads in the pool so your executor will never have more than that number of tasks running at a time.</li>
</ul>
<p class="calibre4">For these reasons, it is better that you don't use thread groups and use executors instead.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Delegating the management of threads to executors</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using streams to process big data sets</h1>
            

            <article>
                
<p class="calibre4">A <kbd class="calibre15">Stream</kbd> interface is a sequence of elements that can be filtered and transformed to get a final result sequentially or in parallel. This final result can be a primitive data type (an integer, a long ...), an object or a data structure. These are the characteristics that better define <kbd class="calibre15">Stream</kbd>:</p>
<ul class="calibre17">
<li class="calibre18">A stream is a sequence of data, not a data structure.</li>
<li class="calibre18">You can create streams from different sources as collections (lists, arrays...), files, strings, or a class that provides the elements of the stream.</li>
<li class="calibre18">You can't access an individual element of the streams.</li>
<li class="calibre18">You can't modify the source of the stream.</li>
<li class="calibre18">Streams define two kinds of operations: intermediate operations that produce a new <kbd class="calibre15">Stream</kbd> interface that allows you to transform, filter, map, or sort the elements of the stream and terminal operations that generate the final result of the operation. A stream pipeline is formed by zero or more intermediate operations and a final operation.</li>
<li class="calibre18">Intermediate operations are lazy. They're not executed until the terminal operation begins its execution. Java can avoid the execution of an intermediate operation over an element or a set of elements of the stream if it detects that it doesn't affect the final result of the operation.</li>
</ul>
<p class="calibre4">When you need to implement an operation that processes a big set of data in a concurrent way, you can use different elements of the <strong class="calibre1">Java Concurrency API</strong> to implement it. Java threads to either the <strong class="calibre1">fork/join framework</strong> or the <strong class="calibre1">Executor framework</strong>, but I think parallel streams are the best option. In this recipe, we will implement an example to explain the advantages that are provided by the use of parallel streams.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Person</kbd>. This class will have six attributes to define some basic characteristics of a person. We will implement the methods to <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">set()</kbd> the values of the attributes, but they won't be included here:</li>
</ol>
<pre class="calibre23">
        public class Person { <br class="title-page-name"/>          private int id; <br class="title-page-name"/>          private String firstName; <br class="title-page-name"/>          private String lastName; <br class="title-page-name"/>          private Date birthDate; <br class="title-page-name"/>          private int salary; <br class="title-page-name"/>          private double coeficient;
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Now, implement a class named <kbd class="calibre15">PersonGenerator</kbd>. This class will only have a method named <kbd class="calibre15">generatedPersonList()</kbd> to generate a list of <kbd class="calibre15">Person</kbd> objects with random values with the size specified in parameters. This is the source code of this class:</li>
</ol>
<pre class="calibre23">
        public class PersonGenerator { <br class="title-page-name"/>          public static List&lt;Person&gt; generatePersonList (int size) { <br class="title-page-name"/>            List&lt;Person&gt; ret = new ArrayList&lt;&gt;(); <br class="title-page-name"/> <br class="title-page-name"/>            String firstNames[] = {"Mary","Patricia","Linda",<br class="title-page-name"/>                                   "Barbara","Elizabeth","James",<br class="title-page-name"/>                                   "John","Robert","Michael","William"}; <br class="title-page-name"/>            String lastNames[] = {"Smith","Jones","Taylor",<br class="title-page-name"/>                                  "Williams","Brown","Davies",<br class="title-page-name"/>                                  "Evans","Wilson","Thomas","Roberts"}; <br class="title-page-name"/> <br class="title-page-name"/>            Random randomGenerator=new Random(); <br class="title-page-name"/>            for (int i=0; i&lt;size; i++) { <br class="title-page-name"/>              Person person=new Person(); <br class="title-page-name"/>              person.setId(i); <br class="title-page-name"/>              person.setFirstName(firstNames<br class="title-page-name"/>                                       [randomGenerator.nextInt(10)]); <br class="title-page-name"/>              person.setLastName(lastNames<br class="title-page-name"/>                                     [randomGenerator.nextInt(10)]); <br class="title-page-name"/>              person.setSalary(randomGenerator.nextInt(100000)); <br class="title-page-name"/>              person.setCoeficient(randomGenerator.nextDouble()*10); <br class="title-page-name"/>              Calendar calendar=Calendar.getInstance(); <br class="title-page-name"/>              calendar.add(Calendar.YEAR, -randomGenerator<br class="title-page-name"/>                                                     .nextInt(30)); <br class="title-page-name"/>              Date birthDate=calendar.getTime(); <br class="title-page-name"/>              person.setBirthDate(birthDate); <br class="title-page-name"/> <br class="title-page-name"/>              ret.add(person); <br class="title-page-name"/>            } <br class="title-page-name"/>            return ret; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Now, implement a task named <kbd class="calibre15">PersonMapTask</kbd>. The main purpose of this task will be to convert a list of persons on a map, where the keys will be the name of the persons and the values will be a list with <kbd class="calibre15">Person</kbd> objects whose name is equal to the key. We will use the fork/join framework to implement this transformation, so the <kbd class="calibre15">PersonMapTask</kbd>  will extend the <kbd class="calibre15">RecursiveAction</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class PersonMapTask extends RecursiveAction {
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">The <kbd class="calibre15">PersonMapTask</kbd> class will have two private attributes: <kbd class="calibre15">List</kbd> of <kbd class="calibre15">Person</kbd> objects to process and <kbd class="calibre15">ConcurrentHashMap</kbd> to store results. We will use the constructor of the class to initialize both the attributes:</li>
</ol>
<pre class="calibre23">
        private List&lt;Person&gt; persons; <br class="title-page-name"/>        private ConcurrentHashMap&lt;String, ConcurrentLinkedDeque<br class="title-page-name"/>                                                &lt;Person&gt;&gt; personMap; <br class="title-page-name"/> <br class="title-page-name"/>        public PersonMapTask(List&lt;Person&gt; persons, ConcurrentHashMap<br class="title-page-name"/>                   &lt;String, ConcurrentLinkedDeque&lt;Person&gt;&gt; personMap) { <br class="title-page-name"/>          this.persons = persons; <br class="title-page-name"/>          this.personMap = personMap; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Now it's time to implement the <kbd class="calibre15">compute()</kbd> method. If the list has less than 1,000 elements, we will process the elements and insert them in <kbd class="calibre15">ConcurrentHashMap</kbd>. We will use the <kbd class="calibre15">computeIfAbsent()</kbd> method to get <kbd class="calibre15">List</kbd> associated with a key or generate a new <kbd class="calibre15">ConcurrentMapedDeque</kbd> object if the key doesn't exist in the map:</li>
</ol>
<pre class="calibre23">
        protected void compute() { <br class="title-page-name"/> <br class="title-page-name"/>          if (persons.size() &lt; 1000) { <br class="title-page-name"/> <br class="title-page-name"/>            for (Person person: persons) { <br class="title-page-name"/>              ConcurrentLinkedDeque&lt;Person&gt; personList=personMap<br class="title-page-name"/>                     .computeIfAbsent(person.getFirstName(), name -&gt; { <br class="title-page-name"/>              return new ConcurrentLinkedDeque&lt;&gt;(); <br class="title-page-name"/>              }); 
</pre>
<pre class="calibre23">
              personList.add(person); <br class="title-page-name"/>            } <br class="title-page-name"/>            return; <br class="title-page-name"/>          }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">If <kbd class="calibre15">List</kbd> has more than 1,000 elements, we will create two child tasks and delegate the process of a part of the list to them:</li>
</ol>
<pre class="calibre23">
          PersonMapTask child1, child2; <br class="title-page-name"/> <br class="title-page-name"/>          child1=new PersonMapTask(persons.subList(0,persons.size()/2),<br class="title-page-name"/>                                   personMap); <br class="title-page-name"/>          child2=new PersonMapTask(persons.subList(persons.size()/2,<br class="title-page-name"/>                                                   persons.size()),<br class="title-page-name"/>                                   personMap); <br class="title-page-name"/> <br class="title-page-name"/>            invokeAll(child1,child2);   <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Finally, implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, generate a list with 100,000 random <kbd class="calibre15">Person</kbd> objects:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main (String[] args) { <br class="title-page-name"/>            List&lt;Person&gt; persons=PersonGenerator<br class="title-page-name"/>                                        .generatePersonList(100000);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, compare two methods to generate <kbd class="calibre15">Map</kbd> with the names as keys, which are part of <kbd class="calibre15">List</kbd>, and <kbd class="calibre15">Person</kbd> as value. List will use a parallel <kbd class="calibre15">Stream</kbd> function and the <kbd class="calibre15">collect()</kbd> method using the <kbd class="calibre15">groupingByConcurrent()</kbd> collector:</li>
</ol>
<pre class="calibre23">
        Date start, end; <br class="title-page-name"/> <br class="title-page-name"/>        start =  new Date(); <br class="title-page-name"/>        Map&lt;String, List&lt;Person&gt;&gt; personsByName = persons<br class="title-page-name"/>                                                  .parallelStream() <br class="title-page-name"/>        .collect(Collectors.groupingByConcurrent(p -&gt; p<br class="title-page-name"/>                                                   .getFirstName())); <br class="title-page-name"/>        end = new Date(); <br class="title-page-name"/>        System.out.printf("Collect: %d - %d\n", personsByName.size(),<br class="title-page-name"/>                          end.getTime()-start.getTime());
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">The second option is using the fork/join framework and the <kbd class="calibre15">PersonMapTask</kbd> class:</li>
</ol>
<pre class="calibre23">
            start = new Date(); <br class="title-page-name"/>            ConcurrentHashMap&lt;String, ConcurrentLinkedDeque&lt;Person&gt;&gt;<br class="title-page-name"/>                          forkJoinMap=new ConcurrentHashMap&lt;&gt;(); <br class="title-page-name"/>            PersonMapTask personMapTask=new PersonMapTask<br class="title-page-name"/>                                            (persons,forkJoinMap); <br class="title-page-name"/>            ForkJoinPool.commonPool().invoke(personMapTask); <br class="title-page-name"/>            end = new Date(); <br class="title-page-name"/> <br class="title-page-name"/>            System.out.printf("Collect ForkJoinPool: %d - %d\n",<br class="title-page-name"/>                              forkJoinMap.size(),<br class="title-page-name"/>                              end.getTime()-start.getTime()); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we implemented two different versions of the same algorithm to obtain <kbd class="calibre15">Map</kbd> from <kbd class="calibre15">List</kbd>. If you execute it, you will obtain the same results and a similar execution time (at least the latter is true in my case when I executed the example in a four core computer). The biggest advantage we obtained using streams is the simplicity of the solution and its development time. With only one line of code, we implemented the solution. While in the other case, we implemented a new class (the <kbd class="calibre15">PersonMapTask</kbd>) using concurrent data structures and then executed it in the fork/join framework.</p>
<p class="calibre4">With Streams, you can divide your algorithm into simple steps that can be expressed in an elegant way, be easy to program and understand.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em>, <em class="calibre14">Reducing the elements of a stream</em> and <em class="calibre14">Sorting the elements of a stream</em> recipes in <a href="part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 6</span></a>, <em class="calibre14">Parallel and reactive streams</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Other tips and tricks</h1>
            

            <article>
                
<p class="calibre4">In this final recipe, we have included other tips and tricks that haven't been included in other recipes of the chapter:</p>
<ul class="calibre17">
<li class="calibre18">Whenever possible, use concurrent design patterns: In software engineering, a design pattern is a solution to a common problem. They are commonly used in software development and concurrency applications and are not an exception. Patterns such as signaling, rendezvous, and mutex define how to implement concurrent applications in concrete situations, and they have been used to implement concurrent utilities.</li>
<li class="calibre18">Implement concurrency at the highest possible level: Rich threading APIs, such as the Java concurrency API, offer you different classes to implement concurrency in your applications. Try to use the ones that provide you a higher level of abstraction. It will make it easier for you to implement your algorithm, and they are optimized to give better performance than using threads directly. Therefore, performance won't be a problem.</li>
<li class="calibre18">Take scalability into account: One of the main objectives when you implement a concurrent algorithm is to take advantage of all the resources of your computer, especially the number of processors or cores. But this number may change over time. When you design a concurrent algorithm, don't presuppose the number of cores or processors that your application will execute on. Get information about the system dynamically. For example, in Java, you can get it with the <kbd class="calibre15">Runtime.getRuntime().availableProcessors()</kbd> method and make your algorithm use this information to calculate the number of tasks it's going to execute.</li>
<li class="calibre18">Prefer local thread variables over static and shared when possible: Thread local variables are a special kind of variable. Every task will have an independent value for this variable, so you don't need any synchronization mechanism to protect access to it.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">All the recipes in this <span>chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>