- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Behavioral Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: 'Code maintainability plays a key role in applications across the spectrum of
    the industry, but it’s not fair to stop there and look no further. This means
    skipping over code behavior at runtime, which has an impact on physical and virtual
    memory usage. The primary motivation for using behavior patterns is transparent
    communication between objects, or in other words, the efficient usage of memory
    allocation for this communication. Utilizing behavioral patterns improves the
    flexibility of communication and helps complete a task with a single object or
    multiple objects exchanging information with each other. Structural design patterns
    can sometimes seem close to behavioral ones, but as we will see in each case,
    the purpose is slightly different. Let us dive deeper and learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可维护性在跨行业的应用中起着关键作用，但仅仅停留在那里并不再深入是不公平的。这意味着跳过运行时代码的行为，这会影响物理和虚拟内存的使用。使用行为模式的主要动机是对象之间的透明通信，换句话说，是提高内存分配的效率。利用行为模式提高了通信的灵活性，并有助于通过单个对象或多个对象之间交换信息来完成一项任务。结构设计模式有时似乎接近行为模式，但正如我们将看到的那样，每个案例的目的略有不同。让我们深入了解以下内容：
- en: Limiting expensive initialization using the caching pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存模式限制昂贵的初始化
- en: Handling events using the chain of responsibility pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用责任链模式处理事件
- en: Turning information into action with the command pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令模式将信息转化为行动
- en: Giving meaning to the context using an interpreter pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解释器模式为上下文赋予意义
- en: Checking all the elements with the iterator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器模式检查所有元素
- en: Utilizing the mediator pattern for information exchange
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用中介者模式进行信息交换
- en: Restoring the desired state with the memento pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用备忘录模式恢复所需状态
- en: Avoiding a null pointer exception state with the null object pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空对象模式避免空指针异常状态
- en: Keeping all interested parties informed using the observer pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用观察者模式让所有相关方保持知情
- en: Dealing with instance stages by using the pipeline pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道模式处理实例阶段
- en: Changing object behavior with the state pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态模式改变对象行为
- en: Using the strategy pattern to change object behavior
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略模式改变对象行为
- en: Standardizing processes with the template pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板模式标准化流程
- en: Executing code based on the object type using the visitor pattern
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问者模式根据对象类型执行代码
- en: By the end of this chapter, you will have a good foundation for understanding
    the importance of program behavior, not only for resource utilization but also
    from the perspective of SOLID design principles.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将有一个很好的基础来理解程序行为的重要性，这不仅涉及资源利用，而且从SOLID设计原则的角度来看。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05)。
- en: Limiting expensive initialization using the caching pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存模式限制昂贵的初始化
- en: The caching pattern is not found in the traditional list from the **Gang of
    Four** (**GoF**). However, due to industry requirements and resource usage, it
    has been identified as a commonly used approach and has gained importance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存模式在传统的**四人帮**（**GoF**）列表中找不到。然而，由于行业需求和资源使用，它已被确定为常用的方法，并获得了重要性。
- en: Motivation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The caching pattern supports element reuse. It does not create a new element
    on demand – instead, it reuses an already-created element stored in the cache.
    It stores frequently needed data in fast-access storage for increased performance.
    Reading data from the cache is faster than instantiating a new entity given the
    low complexity of fetching the required element.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存模式支持元素重用。它不会根据需求创建新元素，而是重用存储在缓存中的已创建元素。它将频繁需要的数据存储在快速访问存储中，以提高性能。从缓存中读取数据比实例化新实体要快，因为获取所需元素的操作复杂度较低。
- en: Finding it in the JDK
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: The `java.base` module and its `java.lang` package provide wrapper classes for
    primitive types. The `valueOf` method for double, float, integer, byte, or character
    types uses a caching mechanism for frequently requested values to reduce memory
    space and improve performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.base` 模块及其 `java.lang` 包为原始类型提供包装类。对于 double、float、integer、byte 或 character
    类型，`valueOf` 方法使用缓存机制来减少频繁请求的值所占用的内存空间并提高性能。'
- en: Sample code
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us imagine the following caching example by creating a `Vehicle` class.
    It contains references to its internal systems (*Figure 5**.1*):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个 `Vehicle` 类来想象以下缓存示例。它包含对其内部系统的引用（*图 5**.1*）：
- en: '![Figure 5.1 – The UML class diagram showing the considered VehicleSystem types
    for the Vehicle class](img/B18884_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 显示考虑的 VehicleSystem 类型的 UML 类图，用于 Vehicle 类](img/B18884_05_01.jpg)'
- en: Figure 5.1 – The UML class diagram showing the considered VehicleSystem types
    for the Vehicle class
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 显示考虑的 VehicleSystem 类型的 UML 类图，用于 Vehicle 类
- en: 'This means that the vehicle is precisely defined and does not mutate. When
    a client requests a specific system, it always initiates the one that corresponds
    to the object. This pattern also enforces control over the storage procedure (*Example
    5.1*):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着车辆被精确定义且不会改变。当客户端请求特定的系统时，它总是启动与对象相对应的那个。此模式还强制控制存储过程（*示例 5.1*）：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 5.1 – The caching pattern provides a guarantee to always get the required
    element and gain control over the storage
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.1 – 缓存模式提供保证，始终获取所需元素并控制存储
- en: In other words, it is not necessary to create another instance such as `EngineSystem`
    to access its functions. Those object accesses or that program behavior can easily
    lead to undesirable conditions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，没有必要创建另一个实例，如 `EngineSystem`，来访问其功能。这些对象访问或程序行为很容易导致不希望出现的情况。
- en: 'The vehicle’s `SystemCache` only considers specific types of instances and
    is also limited by size (*Example 5.2*):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆的 `SystemCache` 只考虑特定类型的实例，并且也受大小的限制（*示例 5.2*）：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 5.2 – The SystemCache instance provides features to ensure program stability
    and may give additional guarantees
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.2 – SystemCache 实例提供确保程序稳定性的功能，并可能提供额外的保证
- en: Conclusion
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The example (from *Figure 5**.1*) showed that implementing caching is simple.
    It may be a good idea to consider when clients require repeated access to the
    same set of elements. This can have a positive impact on performance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例子（来自 *图 5**.1*）显示实现缓存很简单。当客户端需要重复访问同一组元素时，这可能是一个好主意。这可能会对性能产生积极影响。
- en: Some of these elements may be responsible for the program’s runtime behavior.
    Let’s dive deeper into this in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素中的一些可能负责程序的运行时行为。让我们在下一节中深入了解这一点。
- en: Handling events using the chain of responsibility pattern
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用责任链模式处理事件
- en: The chain of responsibility pattern helps avoid tying the handler logic to the
    sender that fired the event. This pattern was identified by the GoF’s book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式有助于避免将处理逻辑绑定到触发事件的发送者。这种模式是由 GoF 的书中确定的。
- en: Motivation
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The program receives an initial triggered event. Each chained handler decides
    whether to process the request or pass it on to the next handler without responding.
    A pattern can consist of command objects that are processed by a series of handler
    objects. Some handlers can act as dispatchers, capable of sending commands in
    different directions to form a responsibility tree.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序接收一个初始触发事件。每个链式处理程序决定是否处理请求或将其传递给下一个处理程序而不做出响应。一个模式可以由一系列处理对象处理的命令对象组成。一些处理程序可以作为调度器，能够将命令发送到不同的方向以形成一个责任树。
- en: The chain of responsibility pattern allows you to build a chain of implementations
    in which a certain action is performed before or after calling the next handler
    in the chain.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式允许你构建一个实现链，在该链中，在调用链中的下一个处理程序之前或之后执行某个操作。
- en: Finding it in the JDK
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: The `java.logging` module includes the `java.util.logging` package, which contains
    a `Logger` class, intended for recording application component messages. Loggers
    can be chained and the logged message is only processed by the desired `Logger`
    instances.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.logging` 模块包括 `java.util.logging` 包，其中包含一个 `Logger` 类，用于记录应用程序组件消息。记录器可以串联，并且记录的消息只由所需的
    `Logger` 实例处理。'
- en: Another example provided in the JDK is the `DirectoryStream` class, which comes
    with the `java.base` module and is located in the `java.nio` package. This class
    is responsible for iterating over entire directories and contains a nested filter
    interface. The interface provides an `accept` method. The actual representation
    of the chained filter differentiates depending on whether the directory is to
    be processed or excluded.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中提供的另一个示例是`DirectoryStream`类，它包含在`java.base`模块中，位于`java.nio`包中。这个类负责遍历整个目录，并包含一个嵌套的过滤器接口。该接口提供了一个`accept`方法。链式过滤器的实际表示取决于目录是否需要处理或排除。
- en: Sample code
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us examine an example of how the chain of responsibility design pattern
    can be used to respond to a trigger event from the driver system (*Example 5.3*):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个示例，说明如何使用职责链设计模式来响应来自驱动系统的触发事件（*示例5.3*）：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 5.3 – The DriverSystem instance initiates the powerOn event that is
    propagated through the chained instances
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5.3 – DriverSystem实例启动通过链式实例传播的powerOn事件
- en: 'The behavior of the system chain created is transparent, and the logic is properly
    encapsulated by each system. The provided generic abstract `VehicleSystem` instance
    defines the functionality, what function each element must fulfill, and how the
    following elements should be chained (*Example 5.4*):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的系统链的行为是透明的，并且每个系统都适当地封装了逻辑。提供的通用抽象`VehicleSystem`实例定义了功能，每个元素必须完成的功能，以及后续元素应该如何链式连接（*示例5.4*）：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 5.4 – The sealed classes usage provides additional stability and control
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5.4 – 封闭类使用提供了额外的稳定性和控制
- en: 'The client receives a framework for how and which classes can be considered
    when building a chain (*Figure 5**.2*):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端接收一个框架，说明在构建链时可以考虑哪些类（*图5**.2*）：
- en: '![Figure 5.2 – The UML class diagram showing which elements participate in
    the powerOn event](img/B18884_05_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – UML类图显示参与powerOn事件的元素](img/B18884_05_02.jpg)'
- en: Figure 5.2 – The UML class diagram showing which elements participate in the
    powerOn event
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – UML类图显示参与powerOn事件的元素
- en: Conclusion
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The chain of responsibility pattern showed that an incoming event that affects
    the runtime behavior of a program can result in the creation of multiple objects.
    The manipulators are encapsulated and the logic is properly isolated according
    to SOLID principles. Using this pattern, the client gets the opportunity to dynamically
    decide which handlers should be involved in the event process. Therefore, it is
    a hot candidate for security frameworks or similar.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 职责链模式表明，影响程序运行行为的传入事件可以导致创建多个对象。操作符被封装，并且根据SOLID原则，逻辑被适当隔离。使用此模式，客户端有机会动态决定哪些处理器应参与事件处理。因此，它是安全框架或类似应用的热门候选。
- en: Chained handlers can issue multiple commands to the client at runtime. Let’s
    explore command responses in more detail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的处理器可以在运行时向客户端发出多个命令。让我们更详细地探讨命令响应。
- en: Turning information into action with the command pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令模式将信息转化为行动
- en: The command pattern is sometimes known as action. The command pattern encapsulates
    the triggered event as an object that allows the client to act. This pattern was
    early identified and described in the GoF’s book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式有时也被称为动作。命令模式封装了触发的事件作为一个对象，允许客户端进行操作。这种模式在GoF的书中被早期识别和描述。
- en: Motivation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The command pattern dictates which instances of the command interface perform
    which actions on the receiver client. A command object can be parameterized to
    define an action in greater detail. The commands can include a callback function
    to notify others of the occurrence of an event. Sometimes, commands can be thought
    of as object-oriented replacements for callback functions. A newly created command
    object can have different dynamics depending on the event that initiated it. The
    client can react to it according to an already scheduled scenario.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式指定命令接口的哪些实例在接收客户端上执行哪些动作。命令对象可以被参数化以更详细地定义一个动作。命令可以包括一个回调函数来通知其他人事件的发生。有时，命令可以被视为面向对象的回调函数的替代品。新创建的命令对象可以根据启动它的事件具有不同的动态。客户端可以根据已安排的场景对其进行反应。
- en: Finding it in the JDK
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中查找
- en: Nice examples are provided in the JDK by the `Callable` and `Runnable` interfaces
    from the `java.base` module and the `java.util.concurrent` package. The implementation
    of each interface is scheduled for execution based on a known scenario.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 中提供了很好的示例，来自 `java.base` 模块中的 `Callable` 和 `Runnable` 接口以及 `java.util.concurrent`
    包。每个接口的实现都是基于已知场景进行执行的。
- en: Other uses of the command pattern can be found in the `java.desktop` module
    in the `javax.swing` package and a class implementing the `Action` interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的其它用途可以在 `java.desktop` 模块中的 `javax.swing` 包以及实现 `Action` 接口的一个类中找到。
- en: Sample code
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The following example shows how a `Driver` object controls a vehicle using
    well-defined commands (*Example 5.5*):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用定义良好的命令来控制 `Driver` 对象（*示例 5.5*）：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 5.5 – The triggered start_stop event is translated and transformed by
    the Driver instance into actions
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.5 – 触发的 start_stop 事件被 Driver 实例转换成动作
- en: 'Commands are properly encapsulated and may contain additional logic for interacting
    with different clients or may decide on execution steps (*Example 5.6*):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命令被适当封装，可能包含与不同客户端交互的额外逻辑，或者可能决定执行步骤（*示例 5.6*）：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 5.6 – To preserve the intended command design, the concept of sealed
    classes may be appropriated
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.6 – 为了保留预期的命令设计，可以采用密封类的概念
- en: 'Commands can be transparently extended as the driver functionality evolves
    (*Figure 5**.3*):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着驱动器功能的演变，命令可以透明地扩展（*图 5**.3*）：
- en: '![Figure 5.3 – The UML class diagram showing which command can be considered
    a driver](img/B18884_05_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 展示哪些命令可以被视为驱动器的 UML 类图](img/B18884_05_03.jpg)'
- en: Figure 5.3 – The UML class diagram showing which command can be considered a
    driver
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 展示哪些命令可以被视为驱动器的 UML 类图
- en: Conclusion
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: A simple example (*Figure 5**.3*) showed the value of the command pattern. The
    command object is separate from the logic and may contain additional valuable
    information. A command has its own lifecycle and makes it easy to implement callback
    functions that can trigger another event.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的示例（*图 5**.3*）展示了命令模式的价值。命令对象与逻辑分离，可能包含额外的有价值信息。命令有其自己的生命周期，并使得实现可以触发另一个事件的回调函数变得容易。
- en: Representing these commands textually can be tricky. The following section shows
    how the client can understand them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以文本形式表示这些命令可能很棘手。以下部分展示了客户端如何理解它们。
- en: Giving meaning to the context using the interpreter pattern
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用解释器模式为上下文赋予意义
- en: The interpreter pattern interprets sequences of characters into desired actions.
    It was identified early due to its use in SQL statement translation and described
    in more detail in the GoF’s book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式将字符序列解释为期望的动作。由于其用于 SQL 语句翻译而被早期识别，并在 GoF 的书中进行了更详细的描述。
- en: Motivation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The interpreter pattern defines two types of objects that refer to specific
    sequences of characters. They are terminal and non-terminal actions or operations
    that can be performed on the sequence of characters under consideration. These
    operations represent the computer language that is used and have their own semantics.
    The syntactic tree of a given sentence – a sequence of characters – is an instance
    of a compound pattern and is used to evaluate and interpret meaning for the client
    program.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式定义了两种类型的对象，它们指向特定的字符序列。它们是终端和非终端动作或操作，可以在考虑的字符序列上执行。这些操作代表了使用的计算机语言，并具有自己的语义。给定句子的句法树——字符序列——是复合模式的实例，用于评估和解释客户端程序的意义。
- en: Finding it in the JDK
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: The `java.base` module contains the `java.util.regex` package with the `Pattern`
    class. This class represents the compilation of regular expressions. Specific
    semantics are applied to a sequence of characters to verify the required match.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.base` 模块包含 `java.util.regex` 包和 `Pattern` 类。这个类代表了正则表达式的编译。特定的语义应用于字符序列以验证所需的匹配。'
- en: Another example comes from a similar module and the `java.text` package. The
    abstract `Format` class implementation serves locale-sensitive information such
    as dates, number formats, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子来自类似的模块和 `java.text` 包。抽象的 `Format` 类实现用于表示与位置敏感的信息，如日期、数字格式等。
- en: Sample code
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let’s create a simple string math formula. The formula contains values from
    different sensors and their contribution to the result. The result represents
    the final value of the formula (*Example 5.7*):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的字符串数学公式。该公式包含来自不同传感器的值及其对结果的影响。结果表示公式的最终值（*示例 5.7*）：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s the output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 5.7 – The parser converts the math string formula into the appropriate
    Expression types
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.7 – 解析器将数学字符串公式转换为适当的表达式类型
- en: 'The basic element is the interface and its `interpret` method. The `1 - 3 +
    100 + 1` formula is evaluated sequentially, and the last element contains the
    result. Each expression is encapsulated, and the interpreter can be conveniently
    extended (*Figure 5**.4*):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基本元素是接口及其 `interpret` 方法。`1 - 3 + 100 + 1` 公式按顺序评估，最后一个元素包含结果。每个表达式都被封装，解释器可以方便地扩展（*图
    5**.4*）：
- en: '![Figure 5.4 – The UML class diagram showing which participants are required
    for evaluation](img/B18884_05_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 显示哪些参与者需要用于评估的 UML 类图](img/B18884_05_04.jpg)'
- en: Figure 5.4 – The UML class diagram showing which participants are required for
    evaluation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – UML 类图显示哪些参与者需要用于评估
- en: Conclusion
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: An interpreter pattern is a powerful design pattern in which a client requires
    a textual representation of commands with known semantics to be processed. It
    allows you to create a grammar represented by a hierarchy of classes that can
    be easily extended and even dynamically modified at runtime.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式是一种强大的设计模式，其中客户端需要处理具有已知语义的命令的文本表示。它允许您创建一个由类层次结构表示的语法，该语法可以轻松扩展，甚至可以在运行时动态修改。
- en: The next section shows us how to navigate through a collection of commands.
    Let’s dive into it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将向我们展示如何遍历命令集合。让我们深入探讨。
- en: Checking all the elements with the iterator pattern
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器模式检查所有元素
- en: This iterator pattern can be close to the abstraction of a cursor pointing to
    the desired position. Since array construction is a commonly used structure type,
    this pattern was soon identified. It is considered one of the core patterns contained
    in the GoF’s book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种迭代器模式可以接近于指向所需位置的游标抽象。由于数组构造是一个常用的结构类型，这种模式很快就被识别出来。它被认为是 GoF 书籍中包含的核心模式之一。
- en: Motivation
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The iterator pattern defines a transparent way to iterate through a collection
    of objects without having to expose or be aware of any of the internal details
    of an object. To step between elements, the iterator pattern uses an iteration
    function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式定义了一种透明的方式来遍历对象集合，而无需暴露或了解任何对象的内部细节。为了在元素之间移动，迭代器模式使用迭代函数。
- en: Finding it in the JDK
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: The `java.base` module contains multiple implementations of the iterator pattern.
    The first implementation can be considered the one provided by the collection
    framework located in the `java.util` package. An implementation of the `Iterator`
    interface traverses through a collection without knowing about the element’s membership.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.base` 模块包含多个迭代器模式的实现。第一个实现可以被认为是位于 `java.util` 包中的集合框架提供的实现。`Iterator`
    接口的实现遍历集合，而不了解元素的成员资格。'
- en: Another example that can be considered is the iterator provided by the `BaseStream`
    interface and its `iterator` method. This class comes from a similar module and
    the `java.util.stream` package, namely the Stream API. It represents the terminal
    operation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以考虑的例子是 `BaseStream` 接口及其 `iterator` 方法提供的迭代器。此类来自类似的模块和 `java.util.stream`
    包，即流 API。它表示终端操作。
- en: Sample code
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'Every vehicle has several common parts. The following example shows the use
    of the iterator pattern to loop through them (*Example 5.8*):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个车辆都有几个共同的部分。以下示例展示了使用迭代器模式遍历它们的用法（*示例 5.8*）：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 5.8 – To preserve the intended command design, the concept of sealed
    classes may be appropriated
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.8 – 为了保留预期的命令设计，可以采用密封类的概念
- en: 'The vehicle can provide a common abstraction vehicle that handles the iterator
    (*Example 5.9*):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该车辆可以提供一个通用的抽象车辆，用于处理迭代器（*示例 5.9*）：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example 5.9 – A program can implement different iterators with different dynamics
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.9 – 一个程序可以实现具有不同动态的不同迭代器
- en: 'The client can traverse all elements individually. An implementation of this
    kind of iterator can be thought of as a nested class of a concrete implementation
    (*Example 5.10*):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以单独遍历所有元素。这种迭代器的实现可以被视为具体实现的一个嵌套类（*示例 5.10*）：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 5.10 – A program can implement different iterators with different dynamics
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.10 – 一个程序可以实现具有不同动态的不同迭代器
- en: 'The sample program behavior is transparent to the client, and it provides a
    framework for extending the intended implementation of the vehicle with new parts
    and a way to navigate through them (*Figure 5**.5*):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 样本程序的行为对客户端是透明的，它提供了一个框架来扩展车辆的预期实现，以及一种导航它们的方式（*图 5**.5*）：
- en: '![Figure 5.5 – The UML class diagram representing a collection of parts designed
    for StandardVehicle](img/B18884_05_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 代表为 StandardVehicle 设计的部件集合的 UML 类图](img/B18884_05_05.jpg)'
- en: Figure 5.5 – The UML class diagram representing a collection of parts designed
    for StandardVehicle
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 代表为 StandardVehicle 设计的部件集合的 UML 类图
- en: Conclusion
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The strength of the iterator pattern is that it can be implemented in a very
    general way – no need to understand the element types being considered. The iterator
    loops through them all without touching their internal representation at runtime.
    Along with another pattern, it can change strategies on the fly or only consider
    specific object types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式的优点是它可以非常通用地实现 – 无需了解正在考虑的元素类型。迭代器遍历它们而不在运行时触及它们的内部表示。结合另一个模式，它可以在运行时更改策略或仅考虑特定的对象类型。
- en: The next section explores runtime communication between specific object types
    – let’s rock it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将探讨特定对象类型之间的运行时通信 – 让我们开始吧。
- en: Utilizing the mediator pattern for information exchange
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用中介者模式进行信息交换
- en: A common situation across different types of applications is the requirement
    to manage communication between clients that require the exchange of information
    in order to maintain a process. This pattern was identified early and is one of
    the core patterns of the GoF’s book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同类型的应用程序中，一个常见的场景是管理需要交换信息以维持流程的客户端之间的通信。这个模式被早期识别，并且是 GoF 书籍的核心模式之一。
- en: Motivation
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The mediator pattern represents an object, a man in the middle, that defines
    the way that a group of objects interacts within the group. The mediator establishes
    a free connection for client communication. Clients can refer to each other explicitly
    through an intermediary. In this way, communication can be moderated.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式代表一个对象，一个中间人，它定义了对象组内对象之间相互作用的规则。中介为客户端通信建立了一个自由连接。客户端可以通过中介明确地相互引用。这样，通信可以被调节。
- en: Finding it in the JDK
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: Although it may not be obvious at first glance, the mediator pattern can be
    easily found in the `java.base` module and the `java.util.concurrent` package.
    The `ExecutorService` class defines a `submit` method. Its parent class, `Executor`,
    exposes the `execute` method. These methods can be used to pass implementations
    of the `Callable` or `Runnable` interfaces, which were previously referred to
    as implementations of the command pattern.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能不明显，但中介者模式可以在 `java.base` 模块和 `java.util.concurrent` 包中轻松找到。`ExecutorService`
    类定义了一个 `submit` 方法。其父类 `Executor` 公开了 `execute` 方法。这些方法可以用来传递 `Callable` 或 `Runnable`
    接口的实现，这些实现之前被称为命令模式的实现。
- en: Sample code
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The following example is quite trivial compared to others, but it shows how
    a processor can maintain vehicle sensor communication (*Example 5.11*):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例相比，以下示例相当简单，但它展示了处理器如何维护车辆传感器通信（*示例 5.11*）：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s the output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example 5.11 – Communication is handled by a VehicleProcessor instance
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.11 – 通信由一个 VehicleProcessor 实例处理
- en: 'The central element of the example is the `VehicleProcessor` instance, which
    obtains all the messages emitted and can react to them (*Figure 5**.6*):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的核心元素是 `VehicleProcessor` 实例，它获取所有发出的消息并能对它们做出反应（*图 5**.6*）：
- en: '![Figure 5.6 – The UML class diagram emphasizing the communication that takes
    place via the processor](img/B18884_05_06.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 强调通过处理器进行的通信的 UML 类图](img/B18884_05_06.jpg)'
- en: Figure 5.6 – The UML class diagram emphasizing the communication that takes
    place via the processor
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 强调通过处理器进行的通信的 UML 类图
- en: Conclusion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The mediator pattern introduces the ability to isolate complex communication
    between different objects. The number of participating objects may vary at runtime.
    The pattern provides an encapsulated and decoupled way to allow all clients to
    communicate with each other.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式引入了隔离不同对象之间复杂通信的能力。参与的对象数量可能在运行时变化。该模式提供了一种封装和解耦的方式，允许所有客户端相互通信。
- en: Communication can bring about various states. In the next section, we’ll explore
    how to remember and restore them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通信可以导致各种状态。在下一节中，我们将探讨如何记住和恢复它们。
- en: Restoring the desired state with the memento pattern
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用备忘录模式恢复所需状态
- en: Sometimes, it may be useful to consider keeping minimal information about the
    state of an object in order to continue or restore it. The memento pattern provides
    this functionality and was described in the GoF’s book.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，考虑保留关于对象状态的最小信息，以便继续或恢复它，可能是有用的。备忘录模式提供了这种功能，并在 GoF 的书中进行了描述。
- en: Motivation
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Without breaking encapsulation, the internal state of an object, a memento,
    needs to be captured and externalized so that the object can later be restored
    to that state. The memento pattern provides a client function to restore the desired
    state of an object, a memento, on demand.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在不破坏封装的情况下，需要捕获和外部化对象的内部状态，即备忘录，以便对象可以稍后恢复到该状态。备忘录模式提供了一个客户端函数，可以在需要时恢复对象的所需状态，即备忘录。
- en: Finding it in the JDK
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: The `Date` class that comes with the `java.base` module and its `java.util`
    package is a nice implementation of the memento pattern. An instance of a class
    represents a specific point on a timeline, and the date can be restored to that
    timeline referring to the calendar or zone used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.base` 模块及其 `java.util` 包中包含的 `Date` 类是对备忘录模式的一个很好的实现。类的实例代表时间线上的一个特定点，可以通过引用日历或时区将日期恢复到该时间线。'
- en: Sample code
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us look at the example of air conditioning in a vehicle. The controller
    gives us several options for setting the cockpit temperature, which also means
    that the driver can restore an already selected state (*Example 5.12*):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看车辆空调的例子。控制器为我们提供了几个设置驾驶舱温度的选项，这也意味着驾驶员可以恢复已选状态（*示例 5.12*）：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s the output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 5.12 – Each state is memorized and the driver can restore it on demand
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.12 – 每个状态都被记住，驾驶员可以按需恢复
- en: 'The `AirConditionSystemCareTaker` instance, playing the role of a memento provider,
    contains links to already used states (*Example 5.13*):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 扮演备忘录提供者角色的 `AirConditionSystemCareTaker` 实例包含指向已使用状态的链接（*示例 5.13*）：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 5.13 – Each state is remembered with an identifier for restoration
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.13 – 每个状态都通过一个标识符记住，以便恢复
- en: 'The `AirConditionSystemOriginator` instance considers creating a memento state
    and restoring the previous one from the memento object. The client is required
    to remember the provided state identifier to ask the caretaker for a memento state
    (*Example 5.14*):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`AirConditionSystemOriginator` 实例考虑创建备忘录状态，并从备忘录对象中恢复先前的状态。客户端需要记住提供的状态标识符，以便向保管人请求备忘录状态（*示例
    5.14*）：'
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 5.14 – The originator holds the mutable states and updates the caretaker
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.14 – 发起者持有可变状态并更新保管人
- en: 'The program allows the client to only work on a few considered states without
    creating any other instances (*Figure 5**.7*):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 程序允许客户端仅对几个考虑的状态进行操作，而不创建任何其他实例（*图 5**.7*）：
- en: '![Figure 5.7 – The UML class diagram showing that only a few classes are involved](img/B18884_05_07.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 显示只涉及少数类的 UML 类图](img/B18884_05_07.jpg)'
- en: Figure 5.7 – The UML class diagram showing that only a few classes are involved
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 显示只涉及少数类的 UML 类图
- en: Conclusion
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The memento pattern is very useful when a program needs to perform any undo
    operation or rewind the timeline. It provides transparent implementation and the
    separation of logic to enforce the sustainability of the code base.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序需要执行任何撤销操作或回滚时间线时，备忘录模式非常有用。它提供了透明的实现和逻辑分离，以强制代码库的可持续性。
- en: Let us see the program behaving as expected and examine this in the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序按预期运行，并在下一节中对其进行检查。
- en: Avoiding a null pointer exception state with the null object pattern
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空对象模式避免空指针异常状态
- en: The null object pattern provides a way to gracefully deal with an unidentified
    object and not cause unexpected or undefined program behavior.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式提供了一种优雅地处理未识别对象的方法，而不会导致意外的或未定义的程序行为。
- en: Motivation
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: 'Instead of using the Java `null` construct to indicate the absence of an object,
    consider introducing the Null object pattern. A null object is considered to belong
    to a specific family of objects. The object implements the expected interface,
    but implementing its methods does not cause any actions. The advantage of this
    approach over using an undefined null reference is that the null object is very
    predictable and has no side effects: it does nothing. It also attempts to eliminate
    the unpleasant null pointer exception.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 Java 的 `null` 构造来表示对象不存在相比，考虑引入空对象模式。空对象被认为属于特定对象家族。该对象实现了预期的接口，但实现其方法不会引起任何操作。与使用未定义的空引用相比，这种方法的优势在于空对象非常可预测，并且没有副作用：它什么也不做。它还试图消除令人不快的空指针异常。
- en: Finding it in the JDK
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中找到它
- en: The traditionally mentioned `java.base` module and the `Collection` framework,
    located in the `java.util` package, define the `Collections` utility class. This
    class contains an internal private `EmptyIterator` class to serve an `elementless`
    iterator instance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上提到的 `java.base` 模块和位于 `java.util` 包中的 `Collection` 框架定义了 `Collections` 工具类。该类包含一个内部私有
    `EmptyIterator` 类，用于提供无元素的迭代器实例。
- en: Another nice example can be found in the `java.io` module and package. The abstract
    class, `InputStream`, defines the `nullInpuStream` method that serves the input
    stream with zero bytes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的例子可以在 `java.io` 模块和包中找到。抽象类 `InputStream` 定义了 `nullInputStream` 方法，该方法提供零字节的输入流。
- en: Sample code
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us examine the usage of the null object pattern more closely. Today’s vehicles
    contain a dramatic number of different sensors. In order to take advantage of
    more than just the functionality of the Stream API, it is quite useful to define
    a null object that contains the sensor type and that the program can transparently
    respond to (*Example 5.15*):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查空对象模式的使用。今天的车辆包含大量不同类型的传感器。为了利用 Stream API 的更多功能，定义一个包含传感器类型且程序可以透明响应的空对象非常有用（*示例
    5.15*）：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s the output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 5.15 – The client receives information that the requested sensor is
    not available as a NullSensor instance
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.15 – 客户端收到信息，请求的传感器作为 NullSensor 实例不可用
- en: 'A `VehicleSensorProvider` instance always returns a result of the expected
    type, and implementing the pattern is very straightforward (*Figure 5**.8*):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleSensorProvider` 实例总是返回预期类型的结果，实现该模式非常简单（*图 5**.8*）：'
- en: '![Figure 5.8 – The UML class diagram showing the relationships used in the
    type maintenance](img/B18884_05_08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 显示类型维护中使用的关系的 UML 类图](img/B18884_05_08.jpg)'
- en: Figure 5.8 – The UML class diagram showing the relationships used in the type
    maintenance
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 显示类型维护中使用的关系的 UML 类图
- en: Conclusion
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The examples showed that the pattern can not only improve the maintainability
    of the code base but also reduce unwanted runtime states, such as a null pointer
    exception.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例子表明，该模式不仅可以提高代码库的可维护性，还可以减少不想要的运行时状态，例如空指针异常。
- en: An undefined program state can be resolved using an approach that we’ll explore
    in the next section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用我们将在下一节中探讨的方法来解决未定义的程序状态。
- en: Keeping all interested parties informed using the observer pattern
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用观察者模式保持所有相关方的信息
- en: The observer pattern is sometimes known as the producer-customer pattern. Again,
    this is a very common use case that appears across applications and is therefore
    mentioned in the GoF’s book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式有时也被称为生产者-消费者模式。再次强调，这是一个非常常见的用例，它出现在各种应用程序中，因此被 GoF 的书中提到。
- en: Motivation
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: A pattern represents a direct relationship between objects. One object has the
    role of the producer. A producer may have many customers to whom the information
    should be delivered. These objects are sometimes called receivers. When an observer
    changes its state, all the registered clients are informed of this change. In
    other words, any changes that occur to the object will cause the observers to
    be notified.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模式代表对象之间的直接关系。一个对象扮演生产者的角色。生产者可能有许多客户，信息需要发送给这些客户。这些对象有时被称为接收者。当观察者改变其状态时，所有已注册的客户端都会被通知这一变化。换句话说，对象发生的任何变化都会导致观察者被通知。
- en: Finding it in the JDK
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中找到它
- en: The observer pattern is another fairly commonly used pattern across JDK modules.
    An example is the `Observer` interface from the `java.base` module and the `java.util`
    package. Although the interfaces have already been deprecated, they are still
    used through the `Observable` class in the compiler’s implementations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是 JDK 模块中另一种相当常用的模式。一个例子是来自 `java.base` 模块和 `java.util` 包的 `Observer` 接口。尽管接口已经被弃用，但它们仍然通过编译器实现中的
    `Observable` 类被使用。
- en: Sample code
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us examine temperature control at different locations in the vehicle. The
    `VehicleSystem` instance should always inform all the interested parties about
    the temperature goal that each system can adjust itself to (*Example 5.16*):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查车辆不同位置的温控情况。`VehicleSystem` 实例应始终通知所有相关方关于每个系统可以调整到的温度目标（*示例 5.16*）：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 5.16 – Each subsystem adjusts its temperature according to the global
    setup
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.16 – 每个子系统根据全局设置调整其温度
- en: 'The `SystemObserver` abstract class not only denotes the subsystem under consideration
    using the construction of sealed classes but also provides a basic template for
    constructing the intended subsystem (*Example 5.17*):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`SystemObserver` 抽象类不仅使用密封类的构造来表示正在考虑的子系统，还提供了一个构建预期子系统的基本模板（*示例 5.17*）：'
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 5.17 – The newly added subsystem follows the generic template to enforce
    the maintainability
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.17 – 新增的子系统遵循通用模板以确保可维护性
- en: 'Each instance contains a reference to the main system that controls the temperature
    target (*Figure 5**.9*):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实例都包含一个指向控制温度目标的主体系统的引用（*图 5**.9*）：
- en: '![Figure 5.9 – A UML class diagram emphasizes the relationships between systems](img/B18884_05_09.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 一个 UML 类图强调了系统之间的关系](img/B18884_05_09.jpg)'
- en: Figure 5.9 – A UML class diagram emphasizes the relationships between systems
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 一个 UML 类图强调了系统之间的关系
- en: Conclusion
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: 'The observer pattern is another very powerful one: it allows the client to
    keep all stakeholders informed without the need to change or understand the implementation.
    The pattern properly encapsulates and decouples the logic and allows the use of
    configurable processes at runtime.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是另一个非常强大的模式：它允许客户端在不改变或理解实现的情况下，让所有利益相关者保持知情。该模式正确地封装并解耦了逻辑，并允许在运行时使用可配置的过程。
- en: The next section shows how to solve linked processes separately.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分展示了如何单独解决链接过程。
- en: Dealing with instance stages by using the pipeline pattern
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道模式处理实例阶段
- en: The pipeline pattern can make a significant contribution to improving the organization
    of multiple downstream operations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 管道模式可以为改善多个下游操作的组织做出重大贡献。
- en: Motivation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: This pattern improves data processing in a series of stages by providing an
    initial input and passing the processed output along for use in subsequent stages.
    The processing elements are arranged in a continuous pipeline so that the output
    of one is the input of another, similar to how a physical pipe works. A pipeline
    pattern can provide some kind of buffering between successive members, represented
    by object instances. The information that flows through these pipes is often a
    stream of records.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式通过提供初始输入并传递处理后的输出以供后续阶段使用，在一系列阶段中改进数据处理。处理元素被安排在一个连续的管道中，以便一个的输出是另一个的输入，类似于物理管道的工作方式。管道模式可以在连续成员之间提供某种类型的缓冲，由对象实例表示。通过这些管道流动的信息通常是记录流。
- en: Finding it in the JDK
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: The most obvious example of the use of the pipeline pattern is the `Stream`
    interface and its implementations. The interface is part of the Stream API and
    is shipped together with the `java.base` module and the `java.util.stream` package.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 管道模式最明显的例子是 `Stream` 接口及其实现。该接口是 Stream API 的一部分，与 `java.base` 模块和 `java.util.stream`
    包一起分发。
- en: Sample code
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let’s imagine a sequence of processes that need to be carried out in a vehicle,
    define them, and put them in sequence. We then initialize a `SystemElement` container
    that collects information about the results of each process (*Example 5.18*):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一系列需要在车辆中执行的过程，定义它们，并将它们按顺序排列。然后我们初始化一个 `SystemElement` 容器，该容器收集每个过程的结果信息（*示例
    5.18*）：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Example 5.18 – Each process result is considered in the final summary
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.18 – 每个过程的结果都被考虑在最终总结中
- en: 'The basic construction is `PipeElement`, which defines not only input types
    but also outputs. Moreover, it defines the order of information processing (*Example
    5.19*):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构是`PipeElement`，它不仅定义了输入类型，还定义了输出。此外，它还定义了信息处理的顺序（*示例 5.19*）：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Example 5.19 – The addProcessor method defines the order of the processor’s
    process method execution
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.19 – `addProcessor`方法定义了处理器过程方法执行的顺序
- en: 'Each processor implementation can be considered a functional interface construct,
    and the `Element` implementation can be changed on demand without breaking the
    pipeline base code (*Figure 5**.10*):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器实现都可以被视为一个功能接口构造，并且可以根据需要更改`Element`实现，而不会破坏管道基础代码（*图 5**.10*）：
- en: '![Figure 5.10 – The UML class diagram showing how pipeline type safety is maintained](img/B18884_05_10.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 显示如何维护管道类型安全的 UML 类图](img/B18884_05_10.jpg)'
- en: Figure 5.10 – The UML class diagram showing how pipeline type safety is maintained
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 显示如何维护管道类型安全的 UML 类图
- en: Conclusion
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The presented example shows the advantages of a clear separation of processes
    contributing to the final result. The pipeline pattern has the potential to create
    complex operational sequences that can be easily tested and also dynamically changed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的示例显示了清晰分离过程以贡献最终结果的优点。管道模式有潜力创建复杂的操作序列，这些序列可以轻松测试，并且可以动态更改。
- en: Let’s explore how each intended element can change its state in the next section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中探讨每个预期元素如何改变其状态。
- en: Changing object behavior with the state pattern
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态模式改变对象行为
- en: The behavior state pattern defines the procedure for influencing an object’s
    internal processes based on the mutation of its internal state. This pattern is
    part of the GoF’s book.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 行为状态模式定义了基于对象内部状态的突变来影响对象内部过程的过程。这个模式是GoF（设计模式：可复用面向对象软件的基础）一书的一部分。
- en: Motivation
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Object states can be thought of as representing the concept of a finite machine.
    A pattern allows an object to change its behavior when its internal state changes.
    The state pattern enforces that an object describes its internal states with specific
    classes, and maps responses to those states to specific instances.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将对象状态视为代表有限机器的概念。一个模式允许对象在其内部状态改变时改变其行为。状态模式强制对象使用特定的类来描述其内部状态，并将对这些状态的响应映射到特定的实例。
- en: Finding it in the JDK
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: Usage of the state pattern can be found in the implementation of the `jlink`
    plugin, the `jdk.jlink` module, and the `jdk.tools.jlink.plugin` package. The
    interface plugin defines a nested enum class, `State`, whose values are references
    to the states in question.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式的使用可以在`jlink`插件的实现、`jdk.jlink`模块以及`jdk.tools.jlink.plugin`包中找到。接口插件定义了一个嵌套枚举类`State`，其值是对所讨论状态的引用。
- en: Sample code
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The next example considers that each vehicle has different states that are
    well identified (*Example 5.20*):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例考虑了每辆车都有不同的、被良好识别的状态（*示例 5.20*）：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Example 5.20 – Vehicle states are nicely encapsulated and separated from the
    client logic
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.20 – 车辆状态被很好地封装并从客户端逻辑中分离出来
- en: 'Each `Vehicle` state considered can be developed independently and properly
    separated from the client logic (*Figure 5**.11*):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到的每个`Vehicle`状态都可以独立且正确地与客户端逻辑分离（*图 5**.11*）：
- en: '![Figure 5.11 – The UML class diagram showing the relation between the states
    considered](img/B18884_05_11.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 显示考虑到的状态之间关系的 UML 类图](img/B18884_05_11.jpg)'
- en: Figure 5.11 – The UML class diagram showing the relation between the states
    considered
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 显示考虑到的状态之间关系的 UML 类图
- en: Conclusion
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The state pattern shows the advantages of concretely representing a state as
    a dedicated instance of an object. Not only does it improve testability but it
    also greatly contributes to the maintainability of the underlying code, as each
    state is clearly encapsulated and conforms to the single responsibility principle
    according to the SOLID concept. Program execution becomes transparent to the client
    without implementing any additional exception-handling logic.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式展示了将状态具体表示为对象的专用实例的优点。这不仅提高了可测试性，而且极大地促进了底层代码的可维护性，因为每个状态都被清晰地封装，并符合SOLID概念中的单一职责原则。程序执行对客户端来说是透明的，无需实现任何额外的异常处理逻辑。
- en: Each state can correspond to a specific program behavior or runtime interaction.
    Let’s dive deeper into this in the next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态都可以对应于特定的程序行为或运行时交互。让我们在下一节深入探讨这个问题。
- en: Using the strategy pattern to change object behavior
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用策略模式改变对象行为
- en: The strategy pattern can sometimes be called a policy pattern because it establishes
    precise steps for runtime execution in a particular situation or state. This pattern
    is a part of the GoF’s book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式有时也被称为策略模式，因为它在特定情况或状态下为运行时执行建立了精确的步骤。这个模式是GoF书籍的一部分。
- en: Motivation
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The strategy pattern represents a family of algorithms where each one is properly
    encapsulated. It defines the interchangeability of algorithms to which a particular
    object can respond. This strategy allows the algorithm to change independently
    of the clients using it and allows the client to choose the most appropriate one
    on the fly. In other words, the code allows the client to attach various strategy
    objects that affect the behavior of the program.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式代表了一组算法，其中每个算法都得到了适当的封装。它定义了特定对象可以响应的算法的可互换性。这种策略允许算法独立于使用它的客户端进行更改，并允许客户端在运行时选择最合适的一个。换句话说，代码允许客户端附加各种策略对象，这些对象会影响程序的行为。
- en: Finding it in the JDK
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: The strategy pattern is another pattern commonly used without being aware of
    its use. The `Collection` framework from the `java.base` module and the `java.util`
    package implements the `Comparator` class. This class is often used for sorting
    purposes, such as the implementation of the `Collections.sort()` method.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是另一种常用的模式，人们往往没有意识到它的使用。`java.base`模块的`Collection`框架和`java.util`包实现了`Comparator`类。这个类通常用于排序目的，例如`Collections.sort()`方法的实现。
- en: Another possibly even more widely used implementation is the `map` or `filter`
    methods introduced by the Stream API, which also comes from the `java.base` module
    but in the `java.util.stream` package.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能更广泛使用的实现是Stream API中引入的`map`或`filter`方法，这也来自`java.base`模块，但在`java.util.stream`包中。
- en: Sample code
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Suppose a driver has multiple driving licenses required for specific types
    of vehicles. Each vehicle requires a slightly different driving strategy (*Example
    5.21*):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个驾驶员拥有多种驾驶执照，这些执照是针对特定类型的车辆所需的。每种车辆都需要略微不同的驾驶策略（*示例5.21*）：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s the output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Example 5.21 – The VehicleDriver instance can change the transport strategy
    at the runtime
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5.21 – VehicleDriver实例可以在运行时更改运输策略
- en: 'The `VehicleDriver` instance only holds the reference to the currently used
    `TransportStrategy` instance (*Example 5.22*):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleDriver`实例仅持有当前使用的`TransportStrategy`实例的引用（*示例5.22*）：'
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Example 5.22 – The VehicleDriver instance communicates with strategy through
    the visible method
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5.22 – VehicleDriver实例通过可见方法与策略进行通信
- en: 'The client can decide which strategy to use at runtime. Each strategy is properly
    encapsulated (*Figure 5**.12*):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以在运行时决定使用哪种策略。每个策略都得到了适当的封装（*图5**.12*）：
- en: '![Figure 5.12 – The UML class diagram showing how simply a new strategy can
    be defined](img/B18884_05_12.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12 – 显示如何简单地定义新策略的UML类图](img/B18884_05_12.jpg)'
- en: Figure 5.12 – The UML class diagram showing how simply a new strategy can be
    defined
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 显示如何简单地定义新策略的UML类图
- en: Conclusion
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: This trivial example showed a nicely isolated strategic pattern in action. Drivers
    can change their abilities based on the type of vehicle provided. This pattern’s
    ability to separate its logic from the rest of the code base makes it perfectly
    suited to implementing complex algorithms or operations that should not be exposed
    to clients.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了在行动中一个很好地隔离的战略模式。驾驶员可以根据提供的车辆类型改变他们的能力。这种模式将逻辑与代码库的其他部分分离的能力使其非常适合实现不应向客户端暴露的复杂算法或操作。
- en: Many running events have a general basis. Let’s explore how to deal with this
    kind of situation in the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 许多跑步活动都有一个一般的基础。让我们在下一节探讨如何处理这种情况。
- en: Standardizing processes with the template pattern
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板模式标准化流程
- en: The template method pattern unifies the generalization of intensive actions
    with a templating approach. The template pattern was recognized early and considered
    as part of the GoF’s book.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式统一了密集操作的泛化与模板方法。模板模式被早期认可，并被认为是GoF书籍的一部分。
- en: Motivation
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The template method pattern is based on identifying similarly used steps. These
    steps define the skeleton of an algorithm. Each operation can defer its steps
    to specific subclasses. The template method introduces subclasses to redefine
    certain parts of an algorithm without changing its structure. A template can be
    used to execute the internal methods in the desired order.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式基于识别类似使用的步骤。这些步骤定义了一个算法的骨架。每个操作都可以将其步骤推迟到特定的子类。模板方法引入子类来重新定义算法的某些部分，而不改变其结构。模板可以用来按所需顺序执行内部方法。
- en: Finding it in the JDK
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: Java uses input or output byte streams defined by the I/O API located in the
    `java.base` module and the `java.io` package. The `InputStream` class contains
    an overloaded `read` method that represents a byte-handling template. It’s a similar
    approach to the `OutputStream` class defining an overloaded `write` method.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Java 使用位于 `java.base` 模块和 `java.io` 包中的 I/O API 定义的输入或输出字节流。`InputStream` 类包含一个重载的
    `read` 方法，它代表一个字节处理模板。这与定义重载 `write` 方法的 `OutputStream` 类类似的方法。
- en: Another use of the template pattern can be found in the `Collection` framework,
    which resides in the same module and the `java.util` package. The abstract `AbstractList`,
    `AbstractSet`, and `AbstractMap` classes implement the `indexOf` and `lastIndexOf`
    methods with different templates – for example, `AbstractList` uses `ListIterator`,
    in comparison to the common `Iterator` interface implementation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式在 `Collection` 框架中也有另一种用途，该框架位于同一模块和 `java.util` 包中。抽象的 `AbstractList`、`AbstractSet`
    和 `AbstractMap` 类使用不同的模板实现了 `indexOf` 和 `lastIndexOf` 方法 – 例如，`AbstractList` 使用
    `ListIterator`，与常见的 `Iterator` 接口实现相比。
- en: Sample code
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us examine how the template method pattern can simplify creating a new
    sensor (*Example 5.23*):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模板方法模式如何简化创建一个新的传感器（*示例 5.23*）：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s the output:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Example 5.23 – The template provides generic activation steps valid for each
    sensor
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.23 – 模板提供了对每个传感器都有效的通用激活步骤
- en: 'The `VehicleSensor` abstract class represents the core element of the example
    by defining a final `activate` method (*Example 5.24*):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleSensor` 抽象类通过定义一个最终的 `activate` 方法（*示例 5.24*）来表示示例的核心元素：'
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Example 5.24 – The activate() template method defines the steps for each implementation
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5.24 – `activate()` 模板方法定义了每个实现的步骤
- en: 'In other words, the template method pattern also describes an approach to expanding
    the vehicle’s sensor base (*Figure 5**.13*):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，模板方法模式还描述了一种扩展车辆传感器库的方法（*图 5**.13*）：
- en: '![Figure 5.13 – The UML class diagram highlighting the simplicity of adding
    a new sensor](img/B18884_05_13.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 突出显示添加新传感器的简单性的 UML 类图](img/B18884_05_13.jpg)'
- en: Figure 5.13 – The UML class diagram highlighting the simplicity of adding a
    new sensor
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 突出显示添加新传感器的简单性的 UML 类图
- en: Conclusion
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The template method pattern demonstrates its great advantages for generalized
    actions. It seamlessly separates the internal logic from the client and provides
    transparent and generic steps for performing actions. It is easy to maintain the
    code base or to discover potential issues within it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式展示了它在通用动作方面的巨大优势。它无缝地将内部逻辑与客户端分离，并为执行动作提供了透明和通用的步骤。维护代码库或在其中发现潜在问题都很容易。
- en: The runtime environment can be complex. It’s always good to be aware of which
    instances are present. We will find out how to do this in the next section.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时环境可能很复杂。始终了解哪些实例存在是很好的。我们将在下一节中了解如何做到这一点。
- en: Executing code based on the object type using the visitor pattern
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问者模式根据对象类型执行代码
- en: The visitor pattern introduces the separation of algorithm execution from the
    object instance in question. This pattern is mentioned in the GoF’s book.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式引入了算法执行与相关对象实例的分离。此模式在 GoF 的书中被提及。
- en: Motivation
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The visitor pattern allows a client to define a new operation without changing
    the instance of the class it is working on. This pattern provides a way to separate
    the underlying code from the object structure. The separation practically results
    in providing the ability to add new operations to an existing object without any
    modifications to its structure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式允许客户端在不改变它正在工作的类的实例的情况下定义一个新的操作。此模式提供了一种将底层代码与对象结构分离的方法。这种分离实际上提供了在不修改其结构的情况下向现有对象添加新操作的能力。
- en: Finding it in the JDK
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: Usage of the visitor pattern can be found in the `java.base` module and the
    `java.nio.file` package. The `FileVisitor` interface used by the `Files` utility
    class and its `walkFileTree` method uses a pattern to traverse the directory structure
    and associated files.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式的用法可以在`java.base`模块和`java.nio.file`包中找到。`Files`实用类使用的`FileVisitor`接口及其`walkFileTree`方法使用了一种模式来遍历目录结构和相关文件。
- en: Sample code
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'A vehicle’s security normally relies on the robustness of its sensors. The
    example shows how to ensure the presence of each specific sensor (*Example 5.25*):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆的安全通常依赖于其传感器的稳健性。示例展示了如何确保每个特定传感器的存在（*示例5.25*）：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s the output:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Example 5.25 – The client also double-checks each sensor’s presence
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5.25 – 客户端也双重检查每个传感器的存在
- en: 'The `VehicleSystemCheackVisitor` class defines an overloaded implementation
    of the `visit` method. Each particular sensor instance can be considered simply
    by overloading the `visit` method (*Example 5.26*):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleSystemCheackVisitor`类定义了`visit`方法的重载实现。每个特定的传感器实例可以通过重载`visit`方法简单地考虑（*示例5.26*）：'
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Example 5.26 – Pattern matching in the instanceof concept can enforce code maintainability
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5.26 – 在`instanceof`概念中应用模式匹配可以强制代码可维护性
- en: 'Each system check correctly registers the intended sensor and increases confidence
    in the vehicle’s safety systems (*Figure 5**.14*):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统检查都正确地注册了预期的传感器，并增加了对车辆安全系统的信心（*图5**.14*）：
- en: '![Figure 5.14 – The UML class diagram for the vehicle sensors and their abstractions](img/B18884_05_14.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14 – 车辆传感器及其抽象的UML类图](img/B18884_05_14.jpg)'
- en: Figure 5.14 – The UML class diagram for the vehicle sensors and their abstractions
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 车辆传感器及其抽象的UML类图
- en: Conclusion
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: This example showed how the `VehicleCheck` system can ensure the presence of
    each part. Each control is self-contained and new ones can be easily added or
    removed as needed. The downside is that it requires creating a dedicated instance
    for each type of control. This also means that at least two classes reference
    a similar state in the hierarchy. Another advantage or disadvantage is that the
    pattern does not cause the compilation to fail when a new element that may be
    discovered at runtime is added. Potential duplication can be overcome and type
    safety – following the maintenance of the Liskov substitution principle, which
    is violated by a standard visitor pattern – can be ensured through the utilization
    of a newly added `switch` statement with pattern matching and a number of other
    improvements. *Example 5.26* shows the `visitBySwitch` method, which accepts `SystemCheck`
    objects as input.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`VehicleCheck`系统如何确保每个部件的存在。每个控制都是自包含的，可以根据需要轻松添加或删除新控制。缺点是它需要为每种类型的控制创建一个专用实例。这也意味着至少有两个类在层次结构中引用相似的状态。另一个优点或缺点是，当在运行时可能发现的新的元素被添加时，该模式不会导致编译失败。可以通过利用新添加的具有模式匹配的`switch`语句和其他一些改进来克服潜在的重复，并确保类型安全——遵循维护Liskov替换原则，而标准访问者模式违反了这一原则。*示例5.26*展示了`visitBySwitch`方法，该方法接受`SystemCheck`对象作为输入。
- en: Having explored the visitor pattern, we’ve come to the end of the chapter –
    let’s briefly summarize what we’ve learned.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了访问者模式之后，我们来到了本章的结尾——让我们简要总结一下我们学到了什么。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about the importance of the runtime environment
    and the dynamic nature of program execution. Behavioral design patterns can improve
    a program’s interaction with the internal parts of the Java platform. The JIT
    compiler can handle dynamic bytecode translation at runtime better, or a garbage
    collector can perform more efficient memory reclamation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了运行时环境的重要性以及程序执行的动态特性。行为设计模式可以改善程序与Java平台内部部分的交互。JIT编译器可以更好地处理运行时的动态字节码转换，或者垃圾收集器可以执行更有效的内存回收。
- en: Most of these design patterns comply with SOLID principles – only the visitor
    pattern has left some room for thought. However, recently added improvements to
    the Java platform can help overcome this. Whether sealed classes, `switch` statements,
    pattern-matching enhancements, or records, the platform provides a solid foundation
    for strengthening the program’s immutability and code stability and simplifying
    the use of design patterns. Some of them may come out of the box, such as a factory
    method and `switch-case` statement enhancements.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些设计模式都符合SOLID原则——只有访问者模式留下了一些思考的空间。然而，最近添加到Java平台上的改进可以帮助克服这一点。无论是密封类、`switch`语句、模式匹配增强还是记录，该平台为加强程序的不可变性和代码稳定性以及简化设计模式的使用提供了坚实的基础。其中一些可能直接可用，例如工厂方法和`switch-case`语句增强。
- en: In this chapter, we learned how to solve challenges at runtime using examples.
    We explored how to process a chained task and command the required actors. The
    formula interpreter translates the text into objects and we figured out how to
    iterate over them. The mediator pattern centralizes complex communication between
    objects. We learned how to avoid a null-pointer exception and give an undefined
    object a type using the null object pattern.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过示例学习了如何在运行时解决问题。我们探讨了如何处理链式任务并指挥所需的演员。公式解释器将文本转换为对象，我们弄清楚了如何遍历它们。中介模式集中了对象之间的复杂通信。我们学习了如何使用空对象模式避免空指针异常，并给未定义的对象赋予类型。
- en: The pipeline formula processes a collection of clients sequentially. We explored
    how to change the state of particular actors and reviewed how to monitor these
    changes with the observer pattern. The last pattern we learned about was the visitor
    pattern, which showed us how to perform a specific operation based on the object
    type.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 管道公式按顺序处理一组客户端。我们探讨了如何改变特定演员的状态，并回顾了如何使用观察者模式来监控这些变化。我们最后学习到的模式是访问者模式，它展示了如何根据对象类型执行特定操作。
- en: With the knowledge gained from behavioral patterns, we have added the missing
    piece to the complete lifecycle of a single-thread program. This includes the
    creation of objects, the programming structure for working with these objects,
    and the dynamic behavior and communication between these objects at runtime.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从行为模式中获得的知识，我们为单线程程序的完整生命周期增添了缺失的一块。这包括对象的创建、与这些对象一起工作的编程结构，以及在运行时这些对象之间的动态行为和通信。
- en: Although the intended program starts from the main thread and may meet be single-threaded
    as required, neither the Java platform nor most business requirements are single-threaded.
    The shared nature of tasks lends itself to multi-threaded communication. This
    can be done using various frameworks. As we will see in the next chapter, we can
    explore some common concurrency patterns to solve the most common challenges in
    this regard. Let’s shake it up!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管预期的程序从主线程开始，可能需要是单线程的，但Java平台以及大多数业务需求都不是单线程的。任务的共享性质使其适合多线程通信。这可以通过各种框架来实现。正如我们将在下一章中看到的，我们可以探索一些常见的并发模式来解决这方面的最常见挑战。让我们来点刺激的！
- en: Questions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What principle is broken by the standard visitor pattern?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准访问者模式违反了哪个原则？
- en: Which pattern helps us traverse over elements in a collection without knowing
    the type?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模式帮助我们遍历集合中的元素而无需知道其类型？
- en: Is there a pattern that allows us to change an instance’s behavior at runtime?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否存在一种模式允许我们在运行时改变实例的行为？
- en: Which pattern helps the runtime transparently identify an undefined state?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模式有助于在运行时透明地识别未定义的状态？
- en: What are the most used patterns by the Java Stream API?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java Stream API最常用的模式有哪些？
- en: Is there a way to notify all clustered clients at runtime?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有方法可以在运行时通知所有集群客户端？
- en: Which pattern can be used to implement callbacks?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模式可以用来实现回调？
- en: Further reading
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式：可复用面向对象软件元素》由埃里希·伽玛、理查德·赫尔姆、拉尔夫·约翰逊和约翰·弗利西斯，Addison-Wesley，1995年出版
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计原则与设计模式》由罗伯特·C·马丁，Object Mentor，2000年出版
- en: '*JEP-358: Helpful* *NullPointerExceptions* ([https://openjdk.org/jeps/358](https://openjdk.org/jeps/358))'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP-358: 有益的* *NullPointerExceptions* ([https://openjdk.org/jeps/358](https://openjdk.org/jeps/358))'
- en: '*JEP-361: Switch* *Expression* ([https://openjdk.org/jeps/361](https://openjdk.org/jeps/361))'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP-361: Switch* *表达式* ([https://openjdk.org/jeps/361](https://openjdk.org/jeps/361))'
- en: '*JEP-394: Pattern Matching for* *instanceof* ([https://openjdk.org/jeps/394](https://openjdk.org/jeps/394))'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP-394: 为* *instanceof* *提供* *模式匹配* ([https://openjdk.org/jeps/394](https://openjdk.org/jeps/394))'
- en: '*JEP-395:* *Records* ([https://openjdk.org/jeps/395](https://openjdk.org/jeps/395))'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP-395:* *记录* ([https://openjdk.org/jeps/395](https://openjdk.org/jeps/395))'
- en: '*JEP-405: Sealed* *Classes* ([https://openjdk.org/jeps/405](https://openjdk.org/jeps/405))'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP-405: 密封* *类* ([https://openjdk.org/jeps/405](https://openjdk.org/jeps/405))'
- en: '*JEP-409: Sealed* *Classes* ([https://openjdk.org/jeps/409](https://openjdk.org/jeps/409))'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP-409: 密封* *类* ([https://openjdk.org/jeps/409](https://openjdk.org/jeps/409))'
- en: 'Part 3: Other Essential Patterns and Anti-Patterns'
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：其他重要模式和反模式
- en: This part covers design principles and patterns for building highly concurrent
    applications. It also discusses several anti-patterns, meaning inappropriate software
    design solutions to given challenges.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分涵盖了构建高度并发应用程序的设计原则和模式。它还讨论了几个反模式，即针对给定挑战的不适当的软件设计解决方案。
- en: 'This part contains the following chapters:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含以下章节：
- en: '[*Chapter 6*](B18884_06.xhtml#_idTextAnchor388), *Concurrency Design Patterns*'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18884_06.xhtml#_idTextAnchor388), *并发设计模式*'
- en: '[*Chapter 7*](B18884_07.xhtml#_idTextAnchor481), *Understanding Common Anti-Patterns*'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18884_07.xhtml#_idTextAnchor481), *理解常见反模式*'
