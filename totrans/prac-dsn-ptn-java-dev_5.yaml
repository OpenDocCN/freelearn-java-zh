- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code maintainability plays a key role in applications across the spectrum of
    the industry, but it’s not fair to stop there and look no further. This means
    skipping over code behavior at runtime, which has an impact on physical and virtual
    memory usage. The primary motivation for using behavior patterns is transparent
    communication between objects, or in other words, the efficient usage of memory
    allocation for this communication. Utilizing behavioral patterns improves the
    flexibility of communication and helps complete a task with a single object or
    multiple objects exchanging information with each other. Structural design patterns
    can sometimes seem close to behavioral ones, but as we will see in each case,
    the purpose is slightly different. Let us dive deeper and learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting expensive initialization using the caching pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events using the chain of responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning information into action with the command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving meaning to the context using an interpreter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking all the elements with the iterator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the mediator pattern for information exchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring the desired state with the memento pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding a null pointer exception state with the null object pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping all interested parties informed using the observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with instance stages by using the pipeline pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing object behavior with the state pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the strategy pattern to change object behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardizing processes with the template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing code based on the object type using the visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good foundation for understanding
    the importance of program behavior, not only for resource utilization but also
    from the perspective of SOLID design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Limiting expensive initialization using the caching pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The caching pattern is not found in the traditional list from the **Gang of
    Four** (**GoF**). However, due to industry requirements and resource usage, it
    has been identified as a commonly used approach and has gained importance.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The caching pattern supports element reuse. It does not create a new element
    on demand – instead, it reuses an already-created element stored in the cache.
    It stores frequently needed data in fast-access storage for increased performance.
    Reading data from the cache is faster than instantiating a new entity given the
    low complexity of fetching the required element.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.base` module and its `java.lang` package provide wrapper classes for
    primitive types. The `valueOf` method for double, float, integer, byte, or character
    types uses a caching mechanism for frequently requested values to reduce memory
    space and improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us imagine the following caching example by creating a `Vehicle` class.
    It contains references to its internal systems (*Figure 5**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The UML class diagram showing the considered VehicleSystem types
    for the Vehicle class](img/B18884_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The UML class diagram showing the considered VehicleSystem types
    for the Vehicle class
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the vehicle is precisely defined and does not mutate. When
    a client requests a specific system, it always initiates the one that corresponds
    to the object. This pattern also enforces control over the storage procedure (*Example
    5.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.1 – The caching pattern provides a guarantee to always get the required
    element and gain control over the storage
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it is not necessary to create another instance such as `EngineSystem`
    to access its functions. Those object accesses or that program behavior can easily
    lead to undesirable conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vehicle’s `SystemCache` only considers specific types of instances and
    is also limited by size (*Example 5.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.2 – The SystemCache instance provides features to ensure program stability
    and may give additional guarantees
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example (from *Figure 5**.1*) showed that implementing caching is simple.
    It may be a good idea to consider when clients require repeated access to the
    same set of elements. This can have a positive impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these elements may be responsible for the program’s runtime behavior.
    Let’s dive deeper into this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events using the chain of responsibility pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chain of responsibility pattern helps avoid tying the handler logic to the
    sender that fired the event. This pattern was identified by the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program receives an initial triggered event. Each chained handler decides
    whether to process the request or pass it on to the next handler without responding.
    A pattern can consist of command objects that are processed by a series of handler
    objects. Some handlers can act as dispatchers, capable of sending commands in
    different directions to form a responsibility tree.
  prefs: []
  type: TYPE_NORMAL
- en: The chain of responsibility pattern allows you to build a chain of implementations
    in which a certain action is performed before or after calling the next handler
    in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.logging` module includes the `java.util.logging` package, which contains
    a `Logger` class, intended for recording application component messages. Loggers
    can be chained and the logged message is only processed by the desired `Logger`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Another example provided in the JDK is the `DirectoryStream` class, which comes
    with the `java.base` module and is located in the `java.nio` package. This class
    is responsible for iterating over entire directories and contains a nested filter
    interface. The interface provides an `accept` method. The actual representation
    of the chained filter differentiates depending on whether the directory is to
    be processed or excluded.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us examine an example of how the chain of responsibility design pattern
    can be used to respond to a trigger event from the driver system (*Example 5.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.3 – The DriverSystem instance initiates the powerOn event that is
    propagated through the chained instances
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of the system chain created is transparent, and the logic is properly
    encapsulated by each system. The provided generic abstract `VehicleSystem` instance
    defines the functionality, what function each element must fulfill, and how the
    following elements should be chained (*Example 5.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.4 – The sealed classes usage provides additional stability and control
  prefs: []
  type: TYPE_NORMAL
- en: 'The client receives a framework for how and which classes can be considered
    when building a chain (*Figure 5**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The UML class diagram showing which elements participate in
    the powerOn event](img/B18884_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The UML class diagram showing which elements participate in the
    powerOn event
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The chain of responsibility pattern showed that an incoming event that affects
    the runtime behavior of a program can result in the creation of multiple objects.
    The manipulators are encapsulated and the logic is properly isolated according
    to SOLID principles. Using this pattern, the client gets the opportunity to dynamically
    decide which handlers should be involved in the event process. Therefore, it is
    a hot candidate for security frameworks or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Chained handlers can issue multiple commands to the client at runtime. Let’s
    explore command responses in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Turning information into action with the command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command pattern is sometimes known as action. The command pattern encapsulates
    the triggered event as an object that allows the client to act. This pattern was
    early identified and described in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command pattern dictates which instances of the command interface perform
    which actions on the receiver client. A command object can be parameterized to
    define an action in greater detail. The commands can include a callback function
    to notify others of the occurrence of an event. Sometimes, commands can be thought
    of as object-oriented replacements for callback functions. A newly created command
    object can have different dynamics depending on the event that initiated it. The
    client can react to it according to an already scheduled scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nice examples are provided in the JDK by the `Callable` and `Runnable` interfaces
    from the `java.base` module and the `java.util.concurrent` package. The implementation
    of each interface is scheduled for execution based on a known scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Other uses of the command pattern can be found in the `java.desktop` module
    in the `javax.swing` package and a class implementing the `Action` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example shows how a `Driver` object controls a vehicle using
    well-defined commands (*Example 5.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.5 – The triggered start_stop event is translated and transformed by
    the Driver instance into actions
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are properly encapsulated and may contain additional logic for interacting
    with different clients or may decide on execution steps (*Example 5.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.6 – To preserve the intended command design, the concept of sealed
    classes may be appropriated
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands can be transparently extended as the driver functionality evolves
    (*Figure 5**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The UML class diagram showing which command can be considered
    a driver](img/B18884_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The UML class diagram showing which command can be considered a
    driver
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple example (*Figure 5**.3*) showed the value of the command pattern. The
    command object is separate from the logic and may contain additional valuable
    information. A command has its own lifecycle and makes it easy to implement callback
    functions that can trigger another event.
  prefs: []
  type: TYPE_NORMAL
- en: Representing these commands textually can be tricky. The following section shows
    how the client can understand them.
  prefs: []
  type: TYPE_NORMAL
- en: Giving meaning to the context using the interpreter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interpreter pattern interprets sequences of characters into desired actions.
    It was identified early due to its use in SQL statement translation and described
    in more detail in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interpreter pattern defines two types of objects that refer to specific
    sequences of characters. They are terminal and non-terminal actions or operations
    that can be performed on the sequence of characters under consideration. These
    operations represent the computer language that is used and have their own semantics.
    The syntactic tree of a given sentence – a sequence of characters – is an instance
    of a compound pattern and is used to evaluate and interpret meaning for the client
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.base` module contains the `java.util.regex` package with the `Pattern`
    class. This class represents the compilation of regular expressions. Specific
    semantics are applied to a sequence of characters to verify the required match.
  prefs: []
  type: TYPE_NORMAL
- en: Another example comes from a similar module and the `java.text` package. The
    abstract `Format` class implementation serves locale-sensitive information such
    as dates, number formats, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a simple string math formula. The formula contains values from
    different sensors and their contribution to the result. The result represents
    the final value of the formula (*Example 5.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.7 – The parser converts the math string formula into the appropriate
    Expression types
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic element is the interface and its `interpret` method. The `1 - 3 +
    100 + 1` formula is evaluated sequentially, and the last element contains the
    result. Each expression is encapsulated, and the interpreter can be conveniently
    extended (*Figure 5**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The UML class diagram showing which participants are required
    for evaluation](img/B18884_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The UML class diagram showing which participants are required for
    evaluation
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interpreter pattern is a powerful design pattern in which a client requires
    a textual representation of commands with known semantics to be processed. It
    allows you to create a grammar represented by a hierarchy of classes that can
    be easily extended and even dynamically modified at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows us how to navigate through a collection of commands.
    Let’s dive into it.
  prefs: []
  type: TYPE_NORMAL
- en: Checking all the elements with the iterator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This iterator pattern can be close to the abstraction of a cursor pointing to
    the desired position. Since array construction is a commonly used structure type,
    this pattern was soon identified. It is considered one of the core patterns contained
    in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator pattern defines a transparent way to iterate through a collection
    of objects without having to expose or be aware of any of the internal details
    of an object. To step between elements, the iterator pattern uses an iteration
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.base` module contains multiple implementations of the iterator pattern.
    The first implementation can be considered the one provided by the collection
    framework located in the `java.util` package. An implementation of the `Iterator`
    interface traverses through a collection without knowing about the element’s membership.
  prefs: []
  type: TYPE_NORMAL
- en: Another example that can be considered is the iterator provided by the `BaseStream`
    interface and its `iterator` method. This class comes from a similar module and
    the `java.util.stream` package, namely the Stream API. It represents the terminal
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every vehicle has several common parts. The following example shows the use
    of the iterator pattern to loop through them (*Example 5.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.8 – To preserve the intended command design, the concept of sealed
    classes may be appropriated
  prefs: []
  type: TYPE_NORMAL
- en: 'The vehicle can provide a common abstraction vehicle that handles the iterator
    (*Example 5.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.9 – A program can implement different iterators with different dynamics
  prefs: []
  type: TYPE_NORMAL
- en: 'The client can traverse all elements individually. An implementation of this
    kind of iterator can be thought of as a nested class of a concrete implementation
    (*Example 5.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.10 – A program can implement different iterators with different dynamics
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample program behavior is transparent to the client, and it provides a
    framework for extending the intended implementation of the vehicle with new parts
    and a way to navigate through them (*Figure 5**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The UML class diagram representing a collection of parts designed
    for StandardVehicle](img/B18884_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The UML class diagram representing a collection of parts designed
    for StandardVehicle
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strength of the iterator pattern is that it can be implemented in a very
    general way – no need to understand the element types being considered. The iterator
    loops through them all without touching their internal representation at runtime.
    Along with another pattern, it can change strategies on the fly or only consider
    specific object types.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explores runtime communication between specific object types
    – let’s rock it.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the mediator pattern for information exchange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common situation across different types of applications is the requirement
    to manage communication between clients that require the exchange of information
    in order to maintain a process. This pattern was identified early and is one of
    the core patterns of the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mediator pattern represents an object, a man in the middle, that defines
    the way that a group of objects interacts within the group. The mediator establishes
    a free connection for client communication. Clients can refer to each other explicitly
    through an intermediary. In this way, communication can be moderated.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it may not be obvious at first glance, the mediator pattern can be
    easily found in the `java.base` module and the `java.util.concurrent` package.
    The `ExecutorService` class defines a `submit` method. Its parent class, `Executor`,
    exposes the `execute` method. These methods can be used to pass implementations
    of the `Callable` or `Runnable` interfaces, which were previously referred to
    as implementations of the command pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example is quite trivial compared to others, but it shows how
    a processor can maintain vehicle sensor communication (*Example 5.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.11 – Communication is handled by a VehicleProcessor instance
  prefs: []
  type: TYPE_NORMAL
- en: 'The central element of the example is the `VehicleProcessor` instance, which
    obtains all the messages emitted and can react to them (*Figure 5**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The UML class diagram emphasizing the communication that takes
    place via the processor](img/B18884_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The UML class diagram emphasizing the communication that takes
    place via the processor
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mediator pattern introduces the ability to isolate complex communication
    between different objects. The number of participating objects may vary at runtime.
    The pattern provides an encapsulated and decoupled way to allow all clients to
    communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Communication can bring about various states. In the next section, we’ll explore
    how to remember and restore them.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring the desired state with the memento pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it may be useful to consider keeping minimal information about the
    state of an object in order to continue or restore it. The memento pattern provides
    this functionality and was described in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without breaking encapsulation, the internal state of an object, a memento,
    needs to be captured and externalized so that the object can later be restored
    to that state. The memento pattern provides a client function to restore the desired
    state of an object, a memento, on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Date` class that comes with the `java.base` module and its `java.util`
    package is a nice implementation of the memento pattern. An instance of a class
    represents a specific point on a timeline, and the date can be restored to that
    timeline referring to the calendar or zone used.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at the example of air conditioning in a vehicle. The controller
    gives us several options for setting the cockpit temperature, which also means
    that the driver can restore an already selected state (*Example 5.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.12 – Each state is memorized and the driver can restore it on demand
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AirConditionSystemCareTaker` instance, playing the role of a memento provider,
    contains links to already used states (*Example 5.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.13 – Each state is remembered with an identifier for restoration
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AirConditionSystemOriginator` instance considers creating a memento state
    and restoring the previous one from the memento object. The client is required
    to remember the provided state identifier to ask the caretaker for a memento state
    (*Example 5.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.14 – The originator holds the mutable states and updates the caretaker
  prefs: []
  type: TYPE_NORMAL
- en: 'The program allows the client to only work on a few considered states without
    creating any other instances (*Figure 5**.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The UML class diagram showing that only a few classes are involved](img/B18884_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The UML class diagram showing that only a few classes are involved
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The memento pattern is very useful when a program needs to perform any undo
    operation or rewind the timeline. It provides transparent implementation and the
    separation of logic to enforce the sustainability of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see the program behaving as expected and examine this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding a null pointer exception state with the null object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The null object pattern provides a way to gracefully deal with an unidentified
    object and not cause unexpected or undefined program behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using the Java `null` construct to indicate the absence of an object,
    consider introducing the Null object pattern. A null object is considered to belong
    to a specific family of objects. The object implements the expected interface,
    but implementing its methods does not cause any actions. The advantage of this
    approach over using an undefined null reference is that the null object is very
    predictable and has no side effects: it does nothing. It also attempts to eliminate
    the unpleasant null pointer exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditionally mentioned `java.base` module and the `Collection` framework,
    located in the `java.util` package, define the `Collections` utility class. This
    class contains an internal private `EmptyIterator` class to serve an `elementless`
    iterator instance.
  prefs: []
  type: TYPE_NORMAL
- en: Another nice example can be found in the `java.io` module and package. The abstract
    class, `InputStream`, defines the `nullInpuStream` method that serves the input
    stream with zero bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us examine the usage of the null object pattern more closely. Today’s vehicles
    contain a dramatic number of different sensors. In order to take advantage of
    more than just the functionality of the Stream API, it is quite useful to define
    a null object that contains the sensor type and that the program can transparently
    respond to (*Example 5.15*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.15 – The client receives information that the requested sensor is
    not available as a NullSensor instance
  prefs: []
  type: TYPE_NORMAL
- en: 'A `VehicleSensorProvider` instance always returns a result of the expected
    type, and implementing the pattern is very straightforward (*Figure 5**.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The UML class diagram showing the relationships used in the
    type maintenance](img/B18884_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The UML class diagram showing the relationships used in the type
    maintenance
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples showed that the pattern can not only improve the maintainability
    of the code base but also reduce unwanted runtime states, such as a null pointer
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: An undefined program state can be resolved using an approach that we’ll explore
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping all interested parties informed using the observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern is sometimes known as the producer-customer pattern. Again,
    this is a very common use case that appears across applications and is therefore
    mentioned in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pattern represents a direct relationship between objects. One object has the
    role of the producer. A producer may have many customers to whom the information
    should be delivered. These objects are sometimes called receivers. When an observer
    changes its state, all the registered clients are informed of this change. In
    other words, any changes that occur to the object will cause the observers to
    be notified.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The observer pattern is another fairly commonly used pattern across JDK modules.
    An example is the `Observer` interface from the `java.base` module and the `java.util`
    package. Although the interfaces have already been deprecated, they are still
    used through the `Observable` class in the compiler’s implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us examine temperature control at different locations in the vehicle. The
    `VehicleSystem` instance should always inform all the interested parties about
    the temperature goal that each system can adjust itself to (*Example 5.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.16 – Each subsystem adjusts its temperature according to the global
    setup
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SystemObserver` abstract class not only denotes the subsystem under consideration
    using the construction of sealed classes but also provides a basic template for
    constructing the intended subsystem (*Example 5.17*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.17 – The newly added subsystem follows the generic template to enforce
    the maintainability
  prefs: []
  type: TYPE_NORMAL
- en: 'Each instance contains a reference to the main system that controls the temperature
    target (*Figure 5**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – A UML class diagram emphasizes the relationships between systems](img/B18884_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – A UML class diagram emphasizes the relationships between systems
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The observer pattern is another very powerful one: it allows the client to
    keep all stakeholders informed without the need to change or understand the implementation.
    The pattern properly encapsulates and decouples the logic and allows the use of
    configurable processes at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to solve linked processes separately.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with instance stages by using the pipeline pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pipeline pattern can make a significant contribution to improving the organization
    of multiple downstream operations.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern improves data processing in a series of stages by providing an
    initial input and passing the processed output along for use in subsequent stages.
    The processing elements are arranged in a continuous pipeline so that the output
    of one is the input of another, similar to how a physical pipe works. A pipeline
    pattern can provide some kind of buffering between successive members, represented
    by object instances. The information that flows through these pipes is often a
    stream of records.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most obvious example of the use of the pipeline pattern is the `Stream`
    interface and its implementations. The interface is part of the Stream API and
    is shipped together with the `java.base` module and the `java.util.stream` package.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s imagine a sequence of processes that need to be carried out in a vehicle,
    define them, and put them in sequence. We then initialize a `SystemElement` container
    that collects information about the results of each process (*Example 5.18*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.18 – Each process result is considered in the final summary
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic construction is `PipeElement`, which defines not only input types
    but also outputs. Moreover, it defines the order of information processing (*Example
    5.19*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.19 – The addProcessor method defines the order of the processor’s
    process method execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Each processor implementation can be considered a functional interface construct,
    and the `Element` implementation can be changed on demand without breaking the
    pipeline base code (*Figure 5**.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The UML class diagram showing how pipeline type safety is maintained](img/B18884_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The UML class diagram showing how pipeline type safety is maintained
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The presented example shows the advantages of a clear separation of processes
    contributing to the final result. The pipeline pattern has the potential to create
    complex operational sequences that can be easily tested and also dynamically changed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how each intended element can change its state in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Changing object behavior with the state pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The behavior state pattern defines the procedure for influencing an object’s
    internal processes based on the mutation of its internal state. This pattern is
    part of the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object states can be thought of as representing the concept of a finite machine.
    A pattern allows an object to change its behavior when its internal state changes.
    The state pattern enforces that an object describes its internal states with specific
    classes, and maps responses to those states to specific instances.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usage of the state pattern can be found in the implementation of the `jlink`
    plugin, the `jdk.jlink` module, and the `jdk.tools.jlink.plugin` package. The
    interface plugin defines a nested enum class, `State`, whose values are references
    to the states in question.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next example considers that each vehicle has different states that are
    well identified (*Example 5.20*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.20 – Vehicle states are nicely encapsulated and separated from the
    client logic
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Vehicle` state considered can be developed independently and properly
    separated from the client logic (*Figure 5**.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The UML class diagram showing the relation between the states
    considered](img/B18884_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The UML class diagram showing the relation between the states
    considered
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state pattern shows the advantages of concretely representing a state as
    a dedicated instance of an object. Not only does it improve testability but it
    also greatly contributes to the maintainability of the underlying code, as each
    state is clearly encapsulated and conforms to the single responsibility principle
    according to the SOLID concept. Program execution becomes transparent to the client
    without implementing any additional exception-handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: Each state can correspond to a specific program behavior or runtime interaction.
    Let’s dive deeper into this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the strategy pattern to change object behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy pattern can sometimes be called a policy pattern because it establishes
    precise steps for runtime execution in a particular situation or state. This pattern
    is a part of the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy pattern represents a family of algorithms where each one is properly
    encapsulated. It defines the interchangeability of algorithms to which a particular
    object can respond. This strategy allows the algorithm to change independently
    of the clients using it and allows the client to choose the most appropriate one
    on the fly. In other words, the code allows the client to attach various strategy
    objects that affect the behavior of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy pattern is another pattern commonly used without being aware of
    its use. The `Collection` framework from the `java.base` module and the `java.util`
    package implements the `Comparator` class. This class is often used for sorting
    purposes, such as the implementation of the `Collections.sort()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibly even more widely used implementation is the `map` or `filter`
    methods introduced by the Stream API, which also comes from the `java.base` module
    but in the `java.util.stream` package.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose a driver has multiple driving licenses required for specific types
    of vehicles. Each vehicle requires a slightly different driving strategy (*Example
    5.21*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.21 – The VehicleDriver instance can change the transport strategy
    at the runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VehicleDriver` instance only holds the reference to the currently used
    `TransportStrategy` instance (*Example 5.22*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.22 – The VehicleDriver instance communicates with strategy through
    the visible method
  prefs: []
  type: TYPE_NORMAL
- en: 'The client can decide which strategy to use at runtime. Each strategy is properly
    encapsulated (*Figure 5**.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The UML class diagram showing how simply a new strategy can
    be defined](img/B18884_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The UML class diagram showing how simply a new strategy can be
    defined
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This trivial example showed a nicely isolated strategic pattern in action. Drivers
    can change their abilities based on the type of vehicle provided. This pattern’s
    ability to separate its logic from the rest of the code base makes it perfectly
    suited to implementing complex algorithms or operations that should not be exposed
    to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Many running events have a general basis. Let’s explore how to deal with this
    kind of situation in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Standardizing processes with the template pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template method pattern unifies the generalization of intensive actions
    with a templating approach. The template pattern was recognized early and considered
    as part of the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The template method pattern is based on identifying similarly used steps. These
    steps define the skeleton of an algorithm. Each operation can defer its steps
    to specific subclasses. The template method introduces subclasses to redefine
    certain parts of an algorithm without changing its structure. A template can be
    used to execute the internal methods in the desired order.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java uses input or output byte streams defined by the I/O API located in the
    `java.base` module and the `java.io` package. The `InputStream` class contains
    an overloaded `read` method that represents a byte-handling template. It’s a similar
    approach to the `OutputStream` class defining an overloaded `write` method.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of the template pattern can be found in the `Collection` framework,
    which resides in the same module and the `java.util` package. The abstract `AbstractList`,
    `AbstractSet`, and `AbstractMap` classes implement the `indexOf` and `lastIndexOf`
    methods with different templates – for example, `AbstractList` uses `ListIterator`,
    in comparison to the common `Iterator` interface implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us examine how the template method pattern can simplify creating a new
    sensor (*Example 5.23*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.23 – The template provides generic activation steps valid for each
    sensor
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VehicleSensor` abstract class represents the core element of the example
    by defining a final `activate` method (*Example 5.24*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.24 – The activate() template method defines the steps for each implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the template method pattern also describes an approach to expanding
    the vehicle’s sensor base (*Figure 5**.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The UML class diagram highlighting the simplicity of adding
    a new sensor](img/B18884_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – The UML class diagram highlighting the simplicity of adding a
    new sensor
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The template method pattern demonstrates its great advantages for generalized
    actions. It seamlessly separates the internal logic from the client and provides
    transparent and generic steps for performing actions. It is easy to maintain the
    code base or to discover potential issues within it.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime environment can be complex. It’s always good to be aware of which
    instances are present. We will find out how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Executing code based on the object type using the visitor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The visitor pattern introduces the separation of algorithm execution from the
    object instance in question. This pattern is mentioned in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The visitor pattern allows a client to define a new operation without changing
    the instance of the class it is working on. This pattern provides a way to separate
    the underlying code from the object structure. The separation practically results
    in providing the ability to add new operations to an existing object without any
    modifications to its structure.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usage of the visitor pattern can be found in the `java.base` module and the
    `java.nio.file` package. The `FileVisitor` interface used by the `Files` utility
    class and its `walkFileTree` method uses a pattern to traverse the directory structure
    and associated files.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A vehicle’s security normally relies on the robustness of its sensors. The
    example shows how to ensure the presence of each specific sensor (*Example 5.25*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.25 – The client also double-checks each sensor’s presence
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VehicleSystemCheackVisitor` class defines an overloaded implementation
    of the `visit` method. Each particular sensor instance can be considered simply
    by overloading the `visit` method (*Example 5.26*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Example 5.26 – Pattern matching in the instanceof concept can enforce code maintainability
  prefs: []
  type: TYPE_NORMAL
- en: 'Each system check correctly registers the intended sensor and increases confidence
    in the vehicle’s safety systems (*Figure 5**.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The UML class diagram for the vehicle sensors and their abstractions](img/B18884_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – The UML class diagram for the vehicle sensors and their abstractions
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example showed how the `VehicleCheck` system can ensure the presence of
    each part. Each control is self-contained and new ones can be easily added or
    removed as needed. The downside is that it requires creating a dedicated instance
    for each type of control. This also means that at least two classes reference
    a similar state in the hierarchy. Another advantage or disadvantage is that the
    pattern does not cause the compilation to fail when a new element that may be
    discovered at runtime is added. Potential duplication can be overcome and type
    safety – following the maintenance of the Liskov substitution principle, which
    is violated by a standard visitor pattern – can be ensured through the utilization
    of a newly added `switch` statement with pattern matching and a number of other
    improvements. *Example 5.26* shows the `visitBySwitch` method, which accepts `SystemCheck`
    objects as input.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the visitor pattern, we’ve come to the end of the chapter –
    let’s briefly summarize what we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the importance of the runtime environment
    and the dynamic nature of program execution. Behavioral design patterns can improve
    a program’s interaction with the internal parts of the Java platform. The JIT
    compiler can handle dynamic bytecode translation at runtime better, or a garbage
    collector can perform more efficient memory reclamation.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these design patterns comply with SOLID principles – only the visitor
    pattern has left some room for thought. However, recently added improvements to
    the Java platform can help overcome this. Whether sealed classes, `switch` statements,
    pattern-matching enhancements, or records, the platform provides a solid foundation
    for strengthening the program’s immutability and code stability and simplifying
    the use of design patterns. Some of them may come out of the box, such as a factory
    method and `switch-case` statement enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to solve challenges at runtime using examples.
    We explored how to process a chained task and command the required actors. The
    formula interpreter translates the text into objects and we figured out how to
    iterate over them. The mediator pattern centralizes complex communication between
    objects. We learned how to avoid a null-pointer exception and give an undefined
    object a type using the null object pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline formula processes a collection of clients sequentially. We explored
    how to change the state of particular actors and reviewed how to monitor these
    changes with the observer pattern. The last pattern we learned about was the visitor
    pattern, which showed us how to perform a specific operation based on the object
    type.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge gained from behavioral patterns, we have added the missing
    piece to the complete lifecycle of a single-thread program. This includes the
    creation of objects, the programming structure for working with these objects,
    and the dynamic behavior and communication between these objects at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Although the intended program starts from the main thread and may meet be single-threaded
    as required, neither the Java platform nor most business requirements are single-threaded.
    The shared nature of tasks lends itself to multi-threaded communication. This
    can be done using various frameworks. As we will see in the next chapter, we can
    explore some common concurrency patterns to solve the most common challenges in
    this regard. Let’s shake it up!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What principle is broken by the standard visitor pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which pattern helps us traverse over elements in a collection without knowing
    the type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a pattern that allows us to change an instance’s behavior at runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which pattern helps the runtime transparently identify an undefined state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the most used patterns by the Java Stream API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a way to notify all clustered clients at runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which pattern can be used to implement callbacks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-358: Helpful* *NullPointerExceptions* ([https://openjdk.org/jeps/358](https://openjdk.org/jeps/358))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-361: Switch* *Expression* ([https://openjdk.org/jeps/361](https://openjdk.org/jeps/361))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-394: Pattern Matching for* *instanceof* ([https://openjdk.org/jeps/394](https://openjdk.org/jeps/394))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-395:* *Records* ([https://openjdk.org/jeps/395](https://openjdk.org/jeps/395))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-405: Sealed* *Classes* ([https://openjdk.org/jeps/405](https://openjdk.org/jeps/405))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-409: Sealed* *Classes* ([https://openjdk.org/jeps/409](https://openjdk.org/jeps/409))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Other Essential Patterns and Anti-Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part covers design principles and patterns for building highly concurrent
    applications. It also discusses several anti-patterns, meaning inappropriate software
    design solutions to given challenges.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18884_06.xhtml#_idTextAnchor388), *Concurrency Design Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18884_07.xhtml#_idTextAnchor481), *Understanding Common Anti-Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
