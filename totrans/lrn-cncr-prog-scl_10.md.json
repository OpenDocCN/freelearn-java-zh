["```java\nresolvers ++= Seq( \n  \"Sonatype OSS Snapshots\" at \"https://oss.sonatype.org/content/repositories/snapshots\", \n  \"Sonatype OSS Releases\" at \"https://oss.sonatype.org/content/repositories/releases\" \n) \nlibraryDependencies ++= Seq( \n  \"io.reactors\" %% \"reactors\" % \"0.8\") \n\n```", "```java\nimport io.reactors._ \n\n```", "```java\nobject ReactorHelloWorld { \n  def main(args: Array[String]): Unit = { \n    val welcomeReactor = Reactor[String] { self => \n      self.main.events onEvent { name => \n        println(s\"Welcome, $name!\") \n        self.main.seal() \n      } \n    } \n    val system = ReactorSystem.default(\"test-system\") \n    val ch = system.spawn(welcomeReactor) \n    ch ! \"Alan\" \n  } \n} \n\n```", "```java\nval myEvents: Events[String] = createEventStreamOfStrings() \n\n```", "```java\nmyEvents.onEvent(x => println(x)) \n\n```", "```java\ndef trace[T](events: Events[T]): Unit = { \n  events.onEvent(println) \n} \n\n```", "```java\nval emitter = new Events.Emitter[Int] \n\n```", "```java\nvar luckyNumber = 0 \nemitter.onEvent(luckyNumber = _) \nemitter.react(7) \nassert(luckyNumber == 7) \nemitter.react(8) \nassert(luckyNumber == 8) \n\n```", "```java\nvar seen = List[Int]() \nvar errors = List[String]() \nvar done = 0 \nval e = new Events.Emitter[Int] \ne.onReaction(new Observer[Int] { \n  def react(x: Int, hint: Any) = seen ::= x \n  def except(t: Throwable) = errors ::= t.getMessage \n  def unreact() = done += 1 \n}) \n\n```", "```java\ne.react(1) \ne.react(2) \ne.except(new Exception(\"^_^\")) \ne.react(3) \nassert(seen == 3 :: 2 :: 1 :: Nil) \nassert(errors == \"^_^\" :: Nil) \nassert(done == 0) \ne.unreact() \nassert(done == 1) \ne.react(4) \ne.except(new Exception(\"o_O\")) \nassert(seen == 3 :: 2 :: 1 :: Nil) \nassert(errors == \"^_^\" :: Nil) \nassert(done == 1) \n\n```", "```java\nvar squareSum = 0 \nval e = new Events.Emitter[Int] \ne.onEvent(x => squareSum += x * x) \nfor (i <- 0 until 5) e react i \n\n```", "```java\nval ne = new Events.Emitter[Int] \ne onEvent { x => \n  squareSum += x * x \n  ne.react(squareSum) \n} \n\n```", "```java\nval e = new Events.Emitter[Int] \nval sum = e.map(x => x * x).scanPast(0)(_ + _) \nfor (i <- 0 until 5) e react i \n\n```", "```java\nval numbers = new Events.Emitter[Int] \nval even = numbers.filter(_ % 2 == 0) \nval odd = numbers.filter(_ % 2 == 1) \nval numbersAgain = even union odd \n\n```", "```java\nval system = new ReactorSystem(\"test-system\") \n\n```", "```java\nval proto: Proto[Reactor[String]] = Reactor[String] { self => \n  self.main.events onEvent { \n    x => println(x) \n  } \n} \n\n```", "```java\nval ch: Channel[String] = system.spawn(proto) \n\n```", "```java\nch ! \"Hola!\" \n\n```", "```java\nclass HelloReactor extends Reactor[String] { \n  main.events onEvent { \n    x => println(x) \n  } \n} \n\n```", "```java\nval ch = system.spawn(Proto[HelloReactor]) \nch ! \"Howdee!\" \n\n```", "```java\nsystem.spawn( \n  Proto[HelloReactor].withScheduler(JvmScheduler.Key.newThread)) \n\n```", "```java\ntrait Op[K, V] \ncase class Put[K, V](k: K, v: V) extends Op[K, V] \ncase class Get[K, V](k: K, ch: Channel[V]) extends Op[K, V] \n\n```", "```java\nclass MapReactor[K, V] extends Reactor[Op[K, V]] { \n  val map = mutable.Map[K, V]() \n  main.events onEvent { \n    case Put(k, v) => map(k) = v \n    case Get(k, ch) => ch ! map(k) \n  } \n} \n\n```", "```java\nval mapper = system.spawn(Proto[MapReactor[String, List[String]]]) \n\n```", "```java\nmapper ! Put(\"dns-main\", \"dns1\" :: \"lan\" :: Nil) \nmapper ! Put(\"dns-backup\", \"dns2\" :: \"com\" :: Nil) \n\n```", "```java\nval c: Connector[EventType] = system.channels.open[EventType] \n\n```", "```java\nval ch = system.spawn(Reactor[String] { self => \n  self.main.events onMatch { \n    case \"start\" => \n      val reply = self.system.channels.daemon.open[List[String]] \n      mapper ! Get(\"dns-main\", reply.channel) \n      reply.events onEvent { url => \n        println(url) \n      } \n    case \"end\" => \n      self.main.seal() \n  } \n}) \n\n```", "```java\nch ! \"start\" \n\n```", "```java\nch ! \"end\" \n\n```", "```java\nclass Logger extends Reactor[String] { \n  var count = 3 \n  sysEvents onMatch { \n    case ReactorScheduled => \n      println(\"scheduled\") \n    case ReactorPreempted => \n      count -= 1 \n      if (count == 0) { \n        main.seal() \n        println(\"terminating\") \n      } \n  } \n  main.events.onEvent(println) \n\n```", "```java\nval system = new ReactorSystem(\"test-system\") \n\n```", "```java\nval proto = Proto[Logger].withScheduler( \n  JvmScheduler.Key.globalExecutionContext) \nval ch = system.spawn(proto) \n\n```", "```java\nch ! \"event 1\" \n\n```", "```java\nch ! \"event 2\" \n\n```", "```java\nsystem.bundle.registerScheduler(\"customTimer\", \n  new JvmScheduler.Timer(1000)) \nval periodic = system.spawn( \n  Proto[Logger].withScheduler(\"customTimer\")) \n\n```", "```java\nclass LifecycleReactor extends Reactor[String] { \n  var first = true \n  sysEvents onMatch { \n    case ReactorStarted => \n      println(\"started\") \n    case ReactorScheduled => \n      println(\"scheduled\") \n    case ReactorPreempted => \n      println(\"preempted\") \n      if (first) first = false \n      else throw new Exception \n    case ReactorDied(_) => \n      println(\"died\") \n    case ReactorTerminated => \n      println(\"terminated\") \n  } \n} \n\n```", "```java\nval ch = system.spawn(Proto[LifecycleReactor]) \n\n```", "```java\nch ! \"event\" \n\n```", "```java\nimport io.reactors.services.Log \n\n```", "```java\nsystem.spawn(Reactor[String] { self => \n  val log = system.service[Log] \n  log(\"Test reactor started!\") \n  self.main.seal() \n}) \n\n```", "```java\nimport scala.concurrent.duration._ \nsystem.spawn(Reactor[String] { self => \n  system.clock.timeout(1.second) on { \n    println(\"done\") \n    self.main.seal() \n  } \n}) \n\n```", "```java\nval first = Reactor[String] { self => \n  system.clock.timeout(1.second) on { \n    val c = system.channels.daemon.named(\"hidden\").open[Int] \n    c.events on { \n      println(\"event received\") \n      self.main.seal() \n    } \n  } \n} \nsystem.spawn(first.withName(\"first\")) \nsystem.spawn(Reactor[String] { self => \n  system.channels.await[Int](\"first\", \"hidden\") onEvent { ch => \n    ch ! 7 \n    self.main.seal() \n  } \n}) \n\n```", "```java\nclass CustomService(val system: ReactorSystem) \nextends Protocol.Service { \n  def shutdown(): Unit = ??? \n} \n\n```", "```java\nclass Shutdown(val system: ReactorSystem) \nextends Protocol.Service { \n  private val subscribers = mutable.Set[Channel[Boolean]]() \n  private val lock = new AnyRef \n  def state: Signal[Boolean] = { \n    val shut = system.channels.daemon.open[Boolean] \n    lock.synchronized { \n      subscribers += shut.channel \n    } \n    shut.events.toSignal(false) \n  } \n  def shutdown() { \n    lock.synchronized { \n      for (ch <- subscribers) ch ! true \n    } \n  } \n} \n\n```", "```java\nval system = ReactorSystem.default(\"test-shutdown-system\") \nsystem.spawn(Reactor[Unit] { self => \n  system.service[Shutdown].state on { \n    println(\"Releasing important resource.\") \n    self.main.seal() \n  } \n}) \n\n```", "```java\nsystem.shutdown() \n\n```", "```java\nval system = ReactorSystem.default(\"system\") \n\n```", "```java\ntype Req[T, S] = (T, Channel[S]) \ntype Server[T, S] = Channel[Req[T, S]] \n\n```", "```java\ndef server[T, S](f: T => S): Server[T, S] = { \n  val c = system.channels.open[Req[T, S]] \n  c.events onMatch { \n    case (x, reply) => reply ! f(x) \n  } \n  c.channel \n} \n\n```", "```java\nval proto = Reactor[Unit] { self => \n  val s = server[String, String](_.toUpperCase) \n} \nsystem.spawn(proto) \n\n```", "```java\nimplicit class ServerOps[T, S: Arrayable](val s: Server[T, S]) { \n  def ?(x: T): Events[S] = { \n    val reply = system.channels.daemon.open[S] \n    s ! (x, reply.channel) \n    reply.events \n  } \n} \n\n```", "```java\nval serverClient = Reactor[Unit] { self => \n  val s = server[String, String](_.toUpperCase) \n\n  (s ? \"hello\") onEvent { upper => \n    println(upper) \n  } \n} \nsystem.spawn(serverClient) \n\n```", "```java\nval proto = Reactor[Server.Req[Int, Int]] { self => \n  self.main.serve(x => x * 2) \n} \nval server = system.spawn(proto) \n\n```", "```java\nsystem.spawnLocal[Unit] { self => \n  (server ? 7) onEvent { response => \n    println(response) \n  } \n} \n\n```", "```java\nval proto = Reactor[String] { self => \n  self.main.events onMatch { \n    case \"terminate\" => self.main.seal() \n  } \n  self.system.channels.daemon.named(\"server\") \n    .server[Int, Int].serve(_ * 2) \n} \nsystem.spawn(proto.withName(\"Multiplier\")) \n\n```", "```java\nsystem.spawnLocal[Unit] { self => \n  self.system.channels.await[Server.Req[Int, Int]]( \n    \"Multiplier\", \"server\" \n  ) onEvent { server => \n    (server ? 7) onEvent { response => \n      println(response) \n    } \n  } \n} \n\n```", "```java\nval proto = Reactor.server[Int, Int]((state, x) => x * 2) \nval server = system.spawn(proto) \n\nsystem.spawnLocal[Unit] { self => \n  (server ? 7) onEvent { response => \n    println(response) \n  } \n} \n\n```", "```java\nval server = system.server[Int, Int]((state, x) => x * 2) \n\nsystem.spawnLocal[Unit] { self => \n  (server ? 7) onEvent { response => println(response)  } \n} \n\n```", "```java\nval worker1 = system.spawnLocal[String] { self => \n  self.main.events.onEvent(x => println(s\"1: ${x}\")) \n} \nval worker2 = system.spawnLocal[String] { self => \n  self.main.events.onEvent(x => println(s\"2: ${x}\")) \n} \n\n```", "```java\nsystem.spawnLocal[Unit] { self => \n  val router = system.channels.daemon.router[String] \n    .route(Router.roundRobin(Seq(worker1, worker2))) \n  router.channel ! \"one\" \n  router.channel ! \"two\" \n} \n\n```", "```java\nval clientTwoWay: TwoWay[In, Out] \n\n```", "```java\nval serverTwoWay: TwoWay[Out, In] \n\n```", "```java\nval seeker = Reactor[Unit] { self => \n  val lengthServer = self.system.channels \n    .twoWayServer[Int, String].serveTwoWay() \n\n```", "```java\n  lengthServer.connections.onEvent { serverTwoWay => \n    serverTwoWay.input.onEvent { s => \n      serverTwoWay.output ! s.length \n    } \n  } \n\n```", "```java\n  lengthServer.channel.connect() onEvent { clientTwoWay => \n    clientTwoWay.output ! \"What's my length?\" \n    clientTwoWay.input onEvent { len => \n      if (len == 17) println(\"received correct reply\") \n      else println(\"reply incorrect: \" + len) \n    } \n  } \n} \n\nsystem.spawn(seeker) \n\n```", "```java\n            def twice[T](target: Channel[T]): Channel[T] \n\n    ```", "```java\n            def throttle[T](target: Channel[T]): Channel[T] \n\n    ```", "```java\n            def reliableServer[T](): Channel[Reliable.Req[T]] \n            def openReliable[T] \n            (s: Channel[Reliable.Req[T]]): Events[Channel[T]] \n\n    ```", "```java\n            def broadcast(targets: Seq[Channel[T]]): Channel[T] \n\n    ```", "```java\n            def failureDetector(s: Server[Unit, Unit]): Signal[Boolean] \n\n    ```"]