<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Animation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Animation</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Study without desire spoils the memory, and it retains nothing that it takes in."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Leonardo da Vinci</em></span></span></td></tr></table></div><p>It is fairly simple to move actors around in Greenfoot scenarios by handling keyboard or mouse events and using <code class="literal">setLocation()</code> appropriately. However, we can do better. By animating our actors further, we can breath life into them. We can give our players/users the illusion of a vibrant, living world.</p><p>In essence, programming animation is the art of illusion. By adding small movements or image changes at the right time, we beguile our users into believing our creations are more than just static pixels on a screen. In this chapter, you will learn the following techniques for animating Greenfoot actors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Image swapping and movement</li><li class="listitem">Timing and synchronization</li><li class="listitem">Easing</li></ul></div><p>Greenfoot is a wonderful platform for creating interactive and engaging applications that you can share on the Internet or use as a desktop application. It is your desire to create these types of applications that brought you here, and, according to Leonardo da Vinci, it is that desire that will help you retain the information in this book indefinitely.</p><div class="section" title="Revisiting Avoider Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>Revisiting Avoider Game</h1></div></div></div><p>In this chapter, we are<a id="id93" class="indexterm"/> going to continue to work on Avoider Game, which we created in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>. If you skipped that chapter, or just prefer to start off with a fresh copy, you can download the code for this game from this book's product page on the Packt Publishing website at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>. Any concepts I gloss over in this chapter were most likely covered in detail in the previous chapter; be sure to refer to that chapter as needed. Now, open the <code class="literal">AvoiderGame</code> scenario in Greenfoot and read on.</p></div></div>
<div class="section" title="Image swapping and movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Image swapping and movement</h1></div></div></div><p>Image swapping<a id="id94" class="indexterm"/> is the <a id="id95" class="indexterm"/>age-old technique for animating. Perhaps as a child, you drew a stick figure in the corner of a pad of paper and slightly changed it on every succeeding page. When you rapidly flipped through the pages, your stick figure came to life. <span class="emphasis"><em>Figure 2</em></span> shows my attempt at this type of animation.</p><div class="mediaobject"><img src="../Images/image00265.jpeg" alt="Image swapping and movement"/><div class="caption"><p>Figure 1: This shows old-school stick figure animation</p></div></div><p style="clear:both; height: 1em;"> </p><p>In Greenfoot, we are going to animate actors by rapidly switching between images and achieve the same effect as the paper animation shown in <span class="emphasis"><em>Figure 1</em></span>. We will learn how to use Greenfoot's <code class="literal">setImage()</code> method to do this.</p><div class="section" title="Using setImage()"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Using setImage()</h2></div></div></div><p>When we create a new <code class="literal">Actor</code> in<a id="id96" class="indexterm"/> Greenfoot by subclassing from the <code class="literal">Actor</code> class, or one of our subclasses of <code class="literal">Actor</code>, Greenfoot prompts us to enter in the name of our new class and to select an image for it. Greenfoot also allows us to dynamically set the image of our <code class="literal">Actor</code> objects while the scenario is running, using the method <code class="literal">setImage()</code>provided by Greenfoot's <code class="literal">Actor</code> class. The following is an excerpt from Greenfoot's documentation:</p><div class="informalexample"><pre class="programlisting">public void setImage(java.lang.String filename)
throws java.lang.IllegalArgumentException

Set an image for this actor from an image file. The file may be in jpeg, gif or png format. The file should be located in the project directory.

Parameters:
filename - The name of the image file.</pre></div><p>As you can see, <code class="literal">setImage()</code> allows us to set an image of an actor by specifying the path to any <code class="literal">JPEG</code>, <code class="literal">GIF</code>, or <code class="literal">PNG</code> file. By default, Greenfoot looks in the <code class="literal">images</code> folder contained in your Greenfoot project. You should place all images you are going to use in your scenario in this folder.</p><p>Let's use this method to<a id="id97" class="indexterm"/> animate the enemies in Avoider Game.</p><div class="section" title="Making enemies less happy"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Making enemies less happy</h3></div></div></div><p>The enemies in <a id="id98" class="indexterm"/>Avoider<a id="id99" class="indexterm"/> Game are just too happy. Let's animate them to get sad and disappointed, as they realize that our hero is going to avoid them.</p><div class="section" title="Finding assets"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec18"/>Finding assets</h4></div></div></div><p>The first thing we need to <a id="id100" class="indexterm"/>do, is to find a set of appropriate smiley images that we can switch to for our <code class="literal">Enemy</code> actor in our scenario. Often, you'll need to create your own image assets using Greenfoot's built-in image editor, or tools such as GIMP or Adobe Illustrator, or you could download images from the Internet; there are plenty of free images available. Luckily, the default installation of Greenfoot already contains all the images we need. On OSX, the images are in the following folder:</p><div class="informalexample"><pre class="programlisting">/Applications/Greenfoot 2.3.0/Greenfoot.app/Contents /Resources/Java/greenfoot/imagelib/symbols</pre></div><p>On Windows, the images are in the following folder:</p><div class="informalexample"><pre class="programlisting">C:/Program Files/Greenfoot/lib/greenfoot/imagelib/symbols</pre></div><p>For your convenience, I have made all the smiley images available in this book's file repository on the Packt Publishing website at <a class="ulink" href="https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf">https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf</a>.</p><p>You'll need to place the files <code class="literal">smiley1.png</code>, <code class="literal">smiley3.png</code>, <code class="literal">smiley4.png</code>, and <code class="literal">smiley5.png</code> into the <code class="literal">images</code> folder in your <code class="literal">AvoiderGame</code> directory. After doing this, your images folder should contain the files shown in <span class="emphasis"><em>Figure 2</em></span>.</p><div class="mediaobject"><img src="../Images/image00266.jpeg" alt="Finding assets"/><div class="caption"><p>Figure 2: These are the contents of the images folder in your AvoiderGame project.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now that we have <a id="id101" class="indexterm"/>our images available to us, we can start coding.</p><div class="note" title="Note"><h3 class="title"><a id="tip09"/>Tip</h3><p>Notice that once you set an actor's image to one provided by Greenfoot at creation time, such as <code class="literal">skull.png</code> in <span class="emphasis"><em>Figure 2</em></span>, Greenfoot automatically places the image in your <code class="literal">images</code> folder. So, instead of copying the smiley images from their location on the disk, you could have created a new actor and then set the image of this actor to be each of the smiley faces in turn. Then, you could just delete this new actor. You will see that your images folder will look like that shown in <span class="emphasis"><em>Figure 2</em></span>.</p></div></div><div class="section" title="Calling setImage() based on Actor location"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec19"/>Calling setImage() based on Actor location</h4></div></div></div><p>Double-click on<a id="id102" class="indexterm"/> the <code class="literal">Enemy</code> actor in the <span class="strong"><strong>Actor classes</strong></span> section of Greenfoot's main scenario window to begin editing the <code class="literal">Enemy</code> code. We practice good functional decomposition and simply add a call to <code class="literal">changeDispositon()</code> in the <code class="literal">act()</code> method of <code class="literal">Enemy</code>; we will write that method soon. Your <code class="literal">act()</code> method should now look like this:</p><div class="informalexample"><pre class="programlisting">public void act() {
  setLocation(getX(), getY() + speed);
  changeDisposition();
  checkRemove();
}</pre></div><p>Now, we will implement the <code class="literal">changeDisposition()</code> method. In this method, we want to change the disposition of the enemies, as they slowly realize they will not get the hero. Let's presume our enemies remain optimistic until they reach the middle of the screen. After that, we will slowly have them succumb to despair.</p><p>In the<a id="id103" class="indexterm"/> implementation of <code class="literal">changeDisposition()</code>, we are going to use an instance variable to keep track of what image we need to display next. You need to add this variable <span class="emphasis"><em>declaration</em></span> and <span class="emphasis"><em>initialization</em></span> right below the declaration of the speed instance variable (at the top of the class outside of any method):</p><div class="informalexample"><pre class="programlisting">private int timeToChange = 1;</pre></div><p>With that in place, we can now view the implementation of <code class="literal">changeDisposition()</code>. The following is our code:</p><div class="informalexample"><pre class="programlisting">private void changeDisposition() {
  int ypos = getY();
  int worldHeight = getWorld().getHeight();
  int marker1 = (int) (worldHeight * 0.5);
  int marker2 = (int) (worldHeight * 0.75);
  int marker3 = (int) (worldHeight * 0.90);
  if( timeToChange == 1 &amp;&amp; ypos &gt; marker1) {
    setImage("smiley4.png");
    timeToChange++;
  }
  else if( timeToChange == 2 &amp;&amp; ypos &gt; marker2) {
    setImage("smiley3.png");
    timeToChange++;
  }
  else if( timeToChange == 3 &amp;&amp; ypos &gt; marker3) {
    setImage("smiley5.png");
    timeToChange++;
  }
}</pre></div><p>The logic behind this code is simple. We want to pick specific locations in the downward motion of the enemy to change the image. One complication is that the enemy's speed can be changed through the <code class="literal">setSpeed()</code> method. We use this method in the <code class="literal">AvoiderWorld</code> class to increase the speed of the enemy, so as to increase the difficulty of the game. So, we cannot simply change the image of the enemy with code such as <code class="literal">if( ypos == 300)</code> because the actor might never have a <span class="emphasis"><em>y</em></span> position of exactly <code class="literal">300</code>. For example, if the enemy's speed was 7, then it would have the following <span class="emphasis"><em>y</em></span> positions as it went down: 7, 14, 21, …, 294, 301, 308, and so on.</p><p>As we can see, the enemy never has a <span class="emphasis"><em>y</em></span> position of exactly 300. You might next want to try code such as <code class="literal">if( ypos &gt; 300 )</code>; however, this is suboptimal, as this will cause the image to <span class="emphasis"><em>continually be set for every y position it has over 300</em></span>. Therefore, we should take the approach demonstrated in <code class="literal">changeDisposition()</code> and use <code class="literal">timeToChange</code> to control a one-time, sequential image change.</p><p>Now that we<a id="id104" class="indexterm"/> understand the logic behind <code class="literal">changeDisposition()</code>, let's go over it line by line. The first thing we do is create variables to hold the positions where we want to change the image of the enemy. These positions are based on the height of the scenario; <code class="literal">marker1</code> is at 50 percent of this height, <code class="literal">marker2</code> is at 75 percent of this height, and <code class="literal">marker3</code> is at a position slightly before the enemy exits off the bottom of the screen. The <code class="literal">if</code> statements test for two conditions before changing the image of the actor. It checks to see whether to use <code class="literal">timeToChange</code> to that specific image and whether the actor has passed a given <span class="emphasis"><em>y</em></span> position.</p><div class="note" title="Note"><h3 class="title"><a id="tip10"/>Tip</h3><p>In the previous code, there are lines that convert a decimal number (of type <code class="literal">double</code>) into a whole number (of type <code class="literal">int</code>), such as this one:</p><div class="informalexample"><pre class="programlisting">int marker1 = (int) (worldHeight * 0.5)</pre></div><p>For more information on converting one variable into another (also called casting), refer to the following link:</p><p><a class="ulink" href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html">http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html</a></p></div><p>Compile your Greenfoot scenario and play the game. See if you can get a score greater than 250! <span class="emphasis"><em>Full disclosure: after writing that last sentence I played the game four times in a row and got the following scores: 52, 33, 28, 254. Woot! 254!</em></span></p><div class="note" title="Note"><h3 class="title"><a id="note09"/>Note</h3><p><span class="strong"><strong>Functional decomposition</strong></span></p><p>Functional decomposition <a id="id105" class="indexterm"/>is closely related to the top-down design, a process of repeatedly redefining the problem in terms of smaller, less complex subproblems. When you are writing code for a specific action or functionality in your program, try to think of smaller methods you could write that you could compose to solve the larger issue.</p><p>Typically, you would like to write methods that contain less than 40 lines of code and which only implement one well-defined task. I actually prefer to go much smaller when possible. You'll find code is easier to write, debug, and modify if you follow this practice. In this book, I use functional decomposition. You'll notice that the <code class="literal">act()</code> methods throughout the book mainly contain a sequence of calls to other methods.</p></div></div></div></div><div class="section" title="Using setLocation()"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Using setLocation()</h2></div></div></div><p>The method <code class="literal">setImage()</code> is by far the <a id="id106" class="indexterm"/>most useful Greenfoot method for animating actors; however, moving an actor in certain ways can also produce interesting effects. We already use <code class="literal">setLocation()</code> to move both the enemies and our hero; let's use it now to animate the background star field to make it seem like we are flying through space.</p><div class="section" title="Creating a star field"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec21"/>Creating a star field</h3></div></div></div><p>Our star field is going to provide <a id="id107" class="indexterm"/>various sized stars moving in the background at<a id="id108" class="indexterm"/> various speeds, to produce the effect of moving through space at high speed. Creating a star field is very simple and we have already written very similar code. Imagine that our enemies had the image of a small speck of light, instead of a smiley face and we had many more of them. Voila! You have a star field.</p><div class="section" title="A blank slate"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec20"/>A blank slate</h4></div></div></div><p>If we are going to<a id="id109" class="indexterm"/> create <a id="id110" class="indexterm"/>our own dynamic star field, then we no longer need the current background image associated with <code class="literal">AvoiderWorld</code>. However, if we change this class to have no image associated with it, then we will get a white background—not a very good representation of outer space.</p><p>The solution is to create a new pure black, 600 x 400 pixel image and then select that as the background image for the <code class="literal">AvoiderWorld</code> class. Start up your favorite image editor or use Greenfoot's built-in editor, create a big black rectangle, save it as a PNG file in your <span class="strong"><strong>Avoider</strong></span> project's <code class="literal">images</code> folder, and then set <code class="literal">AvoiderWorld</code> to use this new image as the background.</p></div><div class="section" title="The Star class"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec21"/>The Star class</h4></div></div></div><p>For our stars, we <a id="id111" class="indexterm"/>are <a id="id112" class="indexterm"/>going to do something a little different. Instead of setting the image of the star to a file containing a graphic, we are going to dynamically draw the image. This will be easy to do since a speck of light is not very complicated.</p><p>To create our star actor, right-click on the <code class="literal">Actor</code> class in the <span class="strong"><strong>Actor classes</strong></span> section and choose <span class="strong"><strong>New subclass…</strong></span>. In the <span class="strong"><strong>New class</strong></span> window that pops up, enter <code class="literal">Star</code> as <span class="strong"><strong>New class name</strong></span> and choose <span class="strong"><strong>No image</strong></span> as <span class="strong"><strong>New class image</strong></span>.</p><div class="note" title="Note"><h3 class="title"><a id="tip12"/>Tip</h3><p>Remember, we went over how to create new actors in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>.</p></div><p>Open up a code editor window for your new <code class="literal">Star</code> class and add the following constructor to it:</p><div class="informalexample"><pre class="programlisting">public Star() {
  GreenfootImage img = new GreenfootImage(10,10);
  img.setColor(Color.white);
  img.fillOval(0,0,10,10);
  setImage(img);
}</pre></div><p>This constructor dynamically creates an image to use for the image of our <code class="literal">Star</code> class. First, we create a new image that has a width of <code class="literal">10</code> pixels and a height of <code class="literal">10</code> pixels. Next, we set the color to use for any drawing we do in this image. We gain access to the <code class="literal">Color</code> class (see the information box below to learn more about it) by adding the following <code class="literal">import</code> statement at the top of our class file:</p><div class="informalexample"><pre class="programlisting">import java.awt.Color;</pre></div><p>After setting the color, we draw an oval using the <code class="literal">fillOval()</code> method. The first two parameters of <code class="literal">fillOval()</code> specify the offset of the upper-left corner of the shape we are drawing from the offset of the upper-left corner of our image. <span class="emphasis"><em>Figure 3</em></span> displays this mapping. The next two parameters of <code class="literal">fillOval()</code> specify the width and height of the bounding box containing our oval. Since our width and height are the same, <code class="literal">fillOval()</code> will draw a circle. Finally, we set the image of our actor to be the new image we just created.</p><div class="mediaobject"><img src="../Images/image00267.jpeg" alt="The Star class"/><div class="caption"><p>Figure 3: This shows the effect of using values of 8 and 5 for the first two parameters of fillOval()</p></div></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note10"/>Note</h3><p><span class="strong"><strong>Working with color</strong></span></p><p>In the <code class="literal">Star()</code> constructor, we <a id="id113" class="indexterm"/>do an operation that involves color. There are several different ways to represent color on computers (and basically anything with a screen), and we are going to use an <a id="id114" class="indexterm"/>RGBA color model. If you are curious, you can read more about it at <a class="ulink" href="http://en.wikipedia.org/wiki/RGBA_color_space">http://en.wikipedia.org/wiki/RGBA_color_space</a>.</p><p>Luckily, we don't have to know much about the theory. Java provides a class—<code class="literal">Color</code>—that manages most of the complexity for us. To get this <code class="literal">Color</code> class into your code, you need to have an <code class="literal">import</code> statement at the top of the file. The import statement is <code class="literal">import java.awt.Color;</code>. If you don't add this to the code above, you'll get compile errors.</p><p>To learn more about<a id="id115" class="indexterm"/> this <code class="literal">Color</code> class, look at the official documentation at <a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html">http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html</a>.</p></div><p>The next thing to do to<a id="id116" class="indexterm"/> our <code class="literal">Star</code> class, is fill in the <code class="literal">act()</code> method. We just need to<a id="id117" class="indexterm"/> slowly move this actor down the screen and then remove it once it has exited off the bottom of the screen. We use <code class="literal">setLocation()</code> to do the former and the <code class="literal">checkRemove()</code> method to do the latter. The following is the completed code for both <code class="literal">act()</code> and <code class="literal">checkRemove()</code>:</p><div class="informalexample"><pre class="programlisting">public void act() {
  setLocation(getX(), getY()+1);
  checkRemove();
}

private void checkRemove() {
  World w = getWorld();
  if( getY() &gt; w.getHeight() + 30 ) {
    w.removeObject(this);
  }
}</pre></div><p>The <code class="literal">checkRemove()</code> method is exactly the same code as the one used in the <code class="literal">Enemy</code> class and explained <a id="id118" class="indexterm"/>in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>. In fact, there are many <a id="id119" class="indexterm"/>similarities between the <code class="literal">Star</code> class and the <code class="literal">Enemy</code> class, so much so, that I think we should pre-emptively add the <code class="literal">setSpeed()</code> method the <code class="literal">Enemy</code> has to the <code class="literal">Star</code> class, as it is very likely we will need it later in our implementation of a moving star field. Add this method to the <code class="literal">Star</code> class:</p><div class="informalexample"><pre class="programlisting">public void setSpeed( int s) {
  speed = s;
}</pre></div><p>Just as we did in the <code class="literal">Enemy</code> class, we need to add the instance variable <code class="literal">speed</code> at the top of the class. Here's the code for the variable declaration:</p><div class="informalexample"><pre class="programlisting">int speed = 1;</pre></div><p>We should make one more change in the <code class="literal">act()</code> method to now use the <code class="literal">speed</code> variable to move <code class="literal">Star</code> objects. Change the <code class="literal">setLocation()</code> code in the <code class="literal">act()</code> method to this:</p><div class="informalexample"><pre class="programlisting">setLocation(getX(), getY() + speed);</pre></div><p>The complete code for the <code class="literal">Star</code> class is shown in <span class="emphasis"><em>Figure 4</em></span>.</p><div class="mediaobject"><img src="../Images/image00268.jpeg" alt="The Star class"/><div class="caption"><p>Figure 4: This shows the completed Star class implementation</p></div></div><p style="clear:both; height: 1em;"> </p><p>This would be a<a id="id120" class="indexterm"/> great time to compile the scenario and make sure you do not have <a id="id121" class="indexterm"/>any spelling errors. We have not added any stars to our game, so you will not notice any difference in the game. Adding stars is what we are going to do next.</p></div><div class="section" title="Creating a moving field"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec22"/>Creating a moving field</h4></div></div></div><p>We will generate our<a id="id122" class="indexterm"/> stars in the <code class="literal">AvoiderWorld</code> class. Open the editor window for this class and add a line of code to the <code class="literal">act()</code> method to call the method <code class="literal">generateStars()</code>, which we haven't written yet, but will soon. Your <code class="literal">act()</code> method should now look like this:</p><div class="informalexample"><pre class="programlisting">public void act() {
  generateEnemies();
  generateStars();
  increaseLevel();
}</pre></div><p>The <code class="literal">generateStars()</code> method creates new stars in a way similar to how <code class="literal">generateEnemies()</code> creates new enemies. Here is the code for <code class="literal">generateStars()</code>:</p><div class="informalexample"><pre class="programlisting">private void generateStars() {
  if( Greenfoot.getRandomNumber(1000) &lt; 350) {
    Star s = new Star();
    addObject( s, Greenfoot.getRandomNumber(getWidth()-20)+10, -1);
  }
}</pre></div><p>The <code class="literal">if</code> statement determines<a id="id123" class="indexterm"/> whether or not we want to create a star at this point in time. With a 35 percent probability, we will create a star, which ultimately creates a fairly dense star field. Inside the <code class="literal">if</code> statement, we create a new <code class="literal">Star</code> object and add it to the <code class="literal">World</code>. Add this code and compile and run the game, and see what you think. Do you like the stars? They're OK, but it looks a little more like it's raining golf balls. We can do better.</p></div><div class="section" title="Using parallax"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec23"/>Using parallax</h4></div></div></div><p>Parallax<a id="id124" class="indexterm"/> is the effect that<a id="id125" class="indexterm"/> closer objects seem to be in different positions relative to farther objects based on the viewing angle. For example, if you have ever looked out of a car window and watched trees go by, you'll notice that the trees closer to you seem to move faster than the trees in the background. We can use this phenomenon to give the illusion of depth to our star field.</p><p>Let's change our <code class="literal">generateStars()</code> method to create two types of stars. Some will be near and some will be far. Nearer stars will move faster and be brighter than stars that are further away, but we will generate more stars that are far away. If you imagine our screen as a window out into space, we will have a wider view of objects that are far away, as opposed to close by. Therefore, we need more of them. <span class="emphasis"><em>Figure 5</em></span> illustrates this point.</p><div class="mediaobject"><img src="../Images/image00269.jpeg" alt="Using parallax"/><div class="caption"><p>Figure 5: This demonstrates that you have a wider field of view for objects that are further away when looking through a window</p></div></div><p style="clear:both; height: 1em;"> </p><p>Finally, we want to <a id="id126" class="indexterm"/>add some <a id="id127" class="indexterm"/>random variation in the stars, so that the resulting star field does not look too uniform. Here's our parallax-augmented <code class="literal">generateStars()</code> method:</p><div class="informalexample"><pre class="programlisting">private void generateStars() {
  if( Greenfoot.getRandomNumber(1000) &lt; 350) {
    Star s = new Star();
    GreenfootImage image = s.getImage();
    if( Greenfoot.getRandomNumber(1000) &lt; 300) {
      // this is a close bright star
      s.setSpeed(3);
      image.setTransparency(
      Greenfoot.getRandomNumber(25) + 225);
      image.scale(4,4);
    } else {
      // this is a further dim star
      s.setSpeed(2);
      image.setTransparency(
      Greenfoot.getRandomNumber(50) + 100);
      image.scale(2,2);
    }
    s.setImage(image);
    addObject( s, Greenfoot.getRandomNumber(
    getWidth()-20)+10, -1);
  }
}</pre></div><p>We have added accessing the current image of the star, changing the image, and then setting it to be the new image for the star. The inner <code class="literal">if-else</code> statement handles the changes for nearby and faraway stars. With a 30 percent chance, the star will be a near one. Nearby stars are faster (<code class="literal">setSpeed()</code>), brighter (<code class="literal">setTransparency()</code>), and larger (<code class="literal">scale()</code>).</p><p>The <code class="literal">setTransparency()</code> method <a id="id128" class="indexterm"/>accepts one integer parameter that specifies how <span class="emphasis"><em>see-through</em></span> the image is. You would enter in the value <code class="literal">255</code> for a completely opaque object and 0 for a completely transparent object. We make stars that are far away more transparent so that more of the black background will come through and make it less bright. The <code class="literal">scale()</code> method on <code class="literal">GreenfootImages</code> changes the size of the image, so that it fits into the bounding box defined by the first two parameters of this method. As we can see in the code, nearby stars are scaled to fit into a 4 x 4 pixel image and stars further away are scaled to fit into a 2 x 2 pixel image.</p><p>We are so close to finishing <a id="id129" class="indexterm"/>our star field. Compile and run the scenario and see what you think of it up to now.</p><p>The star field is looking great, but there are still two problems. First, when the game starts, the background is completely black, and then stars start to fall. To really keep the illusion that you are in space, we need the game to start in a field of stars. Second, the stars are being generated over the enemies, our hero, and the score counter; this really wrecks the illusion that they are far away. Let's fix this.</p><p>Solving the issue that the stars are in front of other actors on the screen is a one-liner. Here's the line of code you need to add to the constructor in <code class="literal">AvoiderWorld</code>:</p><div class="informalexample"><pre class="programlisting">setPaintOrder(Avatar.class, Enemy.class, Counter.class);</pre></div><p>The <code class="literal">setPaintOrder()</code>method is defined in the <code class="literal">World</code> class that <code class="literal">AvoiderWorld</code> subclasses. This method allows you set the order of classes displayed on the screen. So, we list the <code class="literal">Avatar</code> class first (it will be at the top of everything), then the <code class="literal">Enemy</code> class, and last the <code class="literal">Counter</code> class. With this ordering, for example, our enemies will be displayed above the score. Any class not listed will be drawn behind all the ones listed; therefore, our stars will be behind all actors on the screen.</p><p>Drawing the initial field of stars is easy if we make a small change to the <code class="literal">generateStars()</code> method. Presently, our stars are hardcoded to start with a <span class="emphasis"><em>y</em></span> coordinate of <code class="literal">-1</code> because of this line:</p><div class="informalexample"><pre class="programlisting">addObject( s, Greenfoot.getRandomNumber(getWidth()-20)+10, -1);</pre></div><p>If we change <code class="literal">generateStars()</code> to take one integer parameter that specifies the <span class="emphasis"><em>y</em></span> value to draw the star at, then we can use this <a id="id130" class="indexterm"/>method to create the initial star field. Take the first line of <code class="literal">generateStars()</code>:</p><div class="informalexample"><pre class="programlisting">private void generateStars() {</pre></div><p>Change it to this:</p><div class="informalexample"><pre class="programlisting">private void generateStars(int yLoc) {</pre></div><p>Take the last line of the method:</p><div class="informalexample"><pre class="programlisting">addObject( s, Greenfoot.getRandomNumber(getWidth()-20)+10, -1);</pre></div><p>Change it to this:</p><div class="informalexample"><pre class="programlisting">addObject( s, Greenfoot.getRandomNumber(getWidth()-20)+10, yLoc);</pre></div><p>These two line changes allow us to specify any starting <span class="emphasis"><em>y</em></span> value for our stars. Because of this change, we need to change the call to <code class="literal">generateStars()</code> in our <code class="literal">act()</code> method to the following line of code:</p><div class="informalexample"><pre class="programlisting">generateStars(-1);</pre></div><p>If you compile and run the <a id="id131" class="indexterm"/>scenario, the only difference you should see is that the stars are now truly in the background. We still need to add one simple method definition and call to draw the initial star field. The method definition is as follows:</p><div class="informalexample"><pre class="programlisting">private void generateInitialStarField() {
  for( int i=0; i&lt;getHeight(); i++ ) {
    generateStars(i);
  }
}</pre></div><p>If the height of our game is four hundred, then this method calls <code class="literal">generateStars()</code> four hundred times. Each time, it supplies a different <span class="emphasis"><em>y</em></span> value to draw stars on. We will fill up the screen with stars by adding this line to our constructor:</p><div class="informalexample"><pre class="programlisting">generateInitialStarField();</pre></div><p>We have made a lot of changes to the <code class="literal">AvoiderWorld</code> class definition, making it increasingly likely that you may have put code in the wrong place. Here is the full listing of the <code class="literal">AvoiderWorld</code> class you can use to check your code against:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class AvoiderWorld extends World {
  private GreenfootSound bkgMusic;
  private Counter scoreBoard;
  private int enemySpawnRate = 20;
  private int enemySpeed = 1;
  private int nextLevel = 100;
  
  public AvoiderWorld() {
    super(600, 400, 1, false);
    bkgMusic = new GreenfootSound("sounds/UFO_T-Balt.mp3")
    // Music Credit:
    //	http://www.newgrounds.com/audio/listen/504436 by T-balt
    bkgMusic.playLoop();
    setPaintOrder(Avatar.class, Enemy.class, Counter.class);
    prepare();
    generateInitialStarField();
  }
  
  public void act() {
    generateEnemies();
    generateStars(-1);
    increaseLevel();
  }
  
  private void generateEnemies() {
    if( Greenfoot.getRandomNumber(1000) &lt; enemySpawnRate) {
      Enemy e = new Enemy();
      e.setSpeed(enemySpeed);
      addObject( e, Greenfoot.getRandomNumber(
      getWidth()-20)+10, -30);
      scoreBoard.setValue(scoreBoard.getValue() + 1);
    }
  }
  
  private void generateStars(int yLoc) {
    if( Greenfoot.getRandomNumber(1000) &lt; 350) {
      Star s = new Star();
      GreenfootImage image = s.getImage();
      if( Greenfoot.getRandomNumber(1000) &lt; 300) {
        // this is a close bright star
        s.setSpeed(3);
        image.setTransparency(
        Greenfoot.getRandomNumber(25) + 225);
        image.scale(4,4);
      } else {
        // this is a further dim star
        s.setSpeed(2);
        image.setTransparency(
        Greenfoot.getRandomNumber(50) + 100);
        image.scale(2,2);
      }
      s.setImage(image);
      addObject( s, Greenfoot.getRandomNumber(
      getWidth()-20)+10, yLoc);
    }
  }
  
  private void increaseLevel() {
    int score = scoreBoard.getValue();
    if( score &gt; nextLevel ) {
      enemySpawnRate += 2;
      enemySpeed++;
      nextLevel += 100;
    }
  }
  
  public void endGame() {
    bkgMusic.stop();
    AvoiderGameOverWorld go = new AvoiderGameOverWorld();
    Greenfoot.setWorld(go);
  }
  
  private void prepare() {
    Avatar avatar = new Avatar();
    addObject(avatar, 287, 232);
    scoreBoard = new Counter("Score: ");
    addObject(scoreBoard, 70, 20);
  }
  
  private void generateInitialStarField() {
    int i = 0;
    for( i=0; i&lt;getHeight(); i++ ) {
      generateStars(i);
    }
  }
}</pre></div><p>Compile and run <a id="id132" class="indexterm"/>your game. This is getting good. Your game should look like the<a id="id133" class="indexterm"/> screenshot shown in <span class="emphasis"><em>Figure 6A</em></span>.</p><div class="mediaobject"><img src="../Images/image00270.jpeg" alt="Using parallax"/><div class="caption"><p>Figure 6A: This shows our game up to now</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Using GreenfootImage"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec24"/>Using GreenfootImage</h4></div></div></div><p>Wait a minute. How <a id="id134" class="indexterm"/>did I know about Greenfoot's <code class="literal">GreenfootImage</code> class<a id="id135" class="indexterm"/> and the <code class="literal">setColor()</code> and <code class="literal">fillOval()</code> methods it contains? The answer is simply that I read the documentation. I learned that Greenfoot provides the class <code class="literal">GreenfootImage</code> to aid in the handling and manipulation of images. In general, Greenfoot provides a useful set of classes to help programmers create interactive applications. We learned about the <code class="literal">World</code> class and <code class="literal">Actor</code> class in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>. <span class="emphasis"><em>Figure 6B</em></span> displays all the classes Greenfoot provides.</p><div class="mediaobject"><img src="../Images/image00271.jpeg" alt="Using GreenfootImage"/><div class="caption"><p>Figure 6B: This shows the classes provided by Greenfoot to help you write applications. This screenshot is taken directly from Greenfoot's help documentation.</p></div></div><p style="clear:both; height: 1em;"> </p><p>You can access<a id="id136" class="indexterm"/> Greenfoot's documentation by going <a id="id137" class="indexterm"/>to Greenfoot's website, as I suggested in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>. If you are not online, you can access the documentation by selecting the <span class="strong"><strong>Help</strong></span> menu option in Greenfoot's main menu and then selecting <span class="strong"><strong>Greenfoot Class Documentation</strong></span> from the drop-down menu. This will bring up Greenfoot's class documentation in your default web browser.</p><div class="note" title="Note"><h3 class="title"><a id="tip13"/>Tip</h3><p>Greenfoot's class documentation is very short and concise. You should take 20–30 minutes to read about each class Greenfoot provides and each method contained in those classes. This will be a very good investment of your time.</p></div></div></div></div></div>
<div class="section" title="Timing and synchronization"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Timing and synchronization</h1></div></div></div><p>Timing <a id="id138" class="indexterm"/>is very important in <a id="id139" class="indexterm"/>creating realistic animations in Greenfoot. Often, we have the need for an actor to do temporary animation in response to an event. We need a way to allow (or prevent) things for a certain amount of time. It is possible to wait for a specific amount of time using the <code class="literal">SimpleTimer</code> class provided by Greenfoot (you can import it into your scenario in the same way you imported the <code class="literal">Counter</code> class in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>); however, waiting for a specific amount of time is rarely the right choice.</p><p>Why is that? Well, Greenfoot provides the player/user with the ability to slow down and speed up a scenario via the <span class="strong"><strong>Speed</strong></span> slider that is located at the bottom of Greenfoot's main scenario window. If you waited for 2 seconds in your code and then the player sped the game up, the 2 seconds wait would last much longer in the game relative to the speed of everything else; the reverse effect would happen if the user slowed down the scenario. We want to use a method for "waiting" in Greenfoot that scales with the speed of the game.</p><p>We will look at <a id="id140" class="indexterm"/>three different ways to<a id="id141" class="indexterm"/> time events in Greenfoot: delay variables, random actions, and triggered events.</p><div class="section" title="Delay variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Delay variables</h2></div></div></div><p>Delay variables<a id="id142" class="indexterm"/> are very similar to the concept of a timer. However, instead of counting seconds (or milliseconds), we will count the number of calls to the <code class="literal">act()</code> method that have gone by. This will exactly scale with the <span class="strong"><strong>Speed</strong></span> slider, as this slider controls the time between <code class="literal">act()</code> method calls. Next, we will take a look at an example of using a delay variable.</p><div class="section" title="Hurting the avatar"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Hurting the avatar</h3></div></div></div><p>Our game is a little <a id="id143" class="indexterm"/>unforgiving. If you touch an enemy once, you die. Let's change the game, so that you take damage for every hit and it takes four hits to kill our hero. The first thing we need to do, is create an instance variable that is going to keep track of the health of our hero. Add this instance variable to the top of the <code class="literal">Avatar</code> class outside of any method:</p><div class="informalexample"><pre class="programlisting">private int health = 3;</pre></div><p>Every time our hero touches an enemy, we are going to subtract one from this variable. When this variable is <code class="literal">0</code>, we will end the game.</p><p>When our hero is hit by an enemy, we want to provide visual feedback to the player. We could do this with a health bar or life indicator at the top of the game; however, let's just animate our hero so that it <span class="emphasis"><em>looks</em></span> injured. To do this, we need to create copies of the <code class="literal">skull.png</code> image that is used to represent an instance of the <code class="literal">Avatar</code> class and augment them to look damaged. You can make the changes using an image editor, such as GIMP, Adobe Illustrator, or others. <span class="emphasis"><em>Figure 7</em></span> shows my versions of the damaged <code class="literal">skull.png</code> image. Make sure you name your skull images exactly the way I did. The first image <code class="literal">skull.png</code> is already in the images folder; the other three need to be named <code class="literal">skull1.png</code>, <code class="literal">skull2.png</code>, and <code class="literal">skull3.png</code>. The reason why it is so important to name them in this manner will become apparent soon.</p><div class="mediaobject"><img src="../Images/image00272.jpeg" alt="Hurting the avatar"/><div class="caption"><p>Figure 7: These are my four copies of skull.png showing increased damage. They are named skull.png, skull1.png, skull2.png, and skull3.png, respectively.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Presently, our <code class="literal">act()</code> method<a id="id144" class="indexterm"/> in the <code class="literal">Avatar</code> class looks like the following code snippet:</p><div class="informalexample"><pre class="programlisting">public void act() {
  followMouse();
  checkForCollisions();
}</pre></div><p>We are going to change the implementation of <code class="literal">checkForCollisions()</code> to handle our hero having life and looking damaged. It presently looks like the following code snippet:</p><div class="informalexample"><pre class="programlisting">private void checkForCollisions() {
  Actor enemy = getOneIntersectingObject(Enemy.class);
  if( enemy != null ) {
    getWorld().removeObject(this);
    Greenfoot.stop();
  }
}</pre></div><p>We need to change it to this:</p><div class="informalexample"><pre class="programlisting">private void checkForCollisions() {
  Actor enemy = getOneIntersectingObject(Enemy.class);
  if( hitDelay == 0 &amp;&amp; enemy != null ) {
    if( health == 0 ) {
      AvoiderWorld world = (AvoiderWorld) getWorld();
      world.endGame();
    }
    else {
      health--;
      setImage("skull" + ++nextImage + ".png"););
      hitDelay = 50;
    }
  }
  if( hitDelay &gt; 0 ) hitDelay--;
}</pre></div><p>As we can see, we added quite<a id="id145" class="indexterm"/> a bit of code. The first <code class="literal">if </code>statement checks the two conditions that need to be true before we take damage from an enemy: firstly, that enough time has passed since the last time we took damage from an enemy, and secondly, that we are presently touching an instance of the <code class="literal">Enemy</code> class. When the hero touches an enemy and takes damage, we want to give our hero a short time of invulnerability in order to move away, without continuing to take damage every time the <code class="literal">act()</code> method is called. If we didn't do this, the hero would take four hits before you could blink your eye. We use the <code class="literal">hitDelay</code> integer variable to count how long to wait. If we have been hit, we set <code class="literal">hitDelay</code> to <code class="literal">50</code>, as shown in the <code class="literal">else</code> part of the inner <code class="literal">if-else</code> statement. The last <code class="literal">if </code>statement in the function continues to decrement <code class="literal">hitDelay</code>. When <code class="literal">hitDelay</code> gets to <code class="literal">0</code>, we can be hit by an enemy and no longer decrement <code class="literal">hitDelay</code>.</p><div class="note" title="Note"><h3 class="title"><a id="note11"/>Note</h3><p><span class="strong"><strong>Java increment and decrement operators</strong></span></p><p>In the last bit of code, we <a id="id146" class="indexterm"/>used Java's increment (<code class="literal">++</code>) and <a id="id147" class="indexterm"/>decrement (<code class="literal">--</code>) operators quite a bit. They simply add one or subtract one, respectively, from the variable they are applied to. However, there is a bit of subtlety you need to be aware of in their use. Look at the following code:</p><div class="informalexample"><pre class="programlisting">int x = 0, y=0, z=0;
y = ++x;
z = x++;</pre></div><p>Notice that the increment operator can be applied before (prefix) or after (postfix) the variable. After this code completes, <code class="literal">x</code> is <code class="literal">2</code>, <code class="literal">y</code> is <code class="literal">1</code>, and <code class="literal">z</code> is <code class="literal">1</code>. You might be surprised that <code class="literal">z</code> is <code class="literal">1</code> and not <code class="literal">2</code>. The reason is that the postfix increment operator will return the value of the variable before it is incremented. Refer to the following link for <a id="id148" class="indexterm"/>more information:</p><p><a class="ulink" href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html">http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html</a></p></div><p>In the inner <code class="literal">if-else</code> statement, we know we have been hit by an enemy. We check to see if our <code class="literal">health</code> is <code class="literal">0</code>; if it is, we are dead, and the game ends as before. If we still have <code class="literal">health</code>, we decrement our <code class="literal">health</code>, change our image, and set <code class="literal">hitDelay</code>.</p><p>The way we change our<a id="id149" class="indexterm"/> image to the next, more damaged, image is based on how we named the files earlier. We build the name of the file by concatenating the <code class="literal">skull</code> string with an integer and then again with the <code class="literal">.png</code> string. This method provides us with a short and easy programmatic way of changing the image. The alternative would be to use a <code class="literal">switch</code> statement that calls <code class="literal">setImage()</code> with different file names based on the value of <code class="literal">health</code>. In our new version of <code class="literal">checkForCollisions()</code>, we used two new instance variables; we still need to declare and initialize those variables. Add these lines at the top of the class under the declaration of the <code class="literal">health</code> variable we added at the beginning of this section:</p><div class="informalexample"><pre class="programlisting">private int hitDelay = 0;
private int nextImage = 0;</pre></div><p>Now, compile your scenario and verify that your hero takes four hits to die.</p><div class="note" title="Note"><h3 class="title"><a id="tip14"/>Tip</h3><p>The <code class="literal">hitDelay</code> variable is a good example of a delay variable. Throughout the rest of the book, we will use delay variables to time various activities. Make sure you understand how we use <code class="literal">hitDelay</code> before continuing.</p></div></div></div><div class="section" title="Random actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Random actions</h2></div></div></div><p>Random actions are<a id="id150" class="indexterm"/> one of the most effective ways to approximate simple intelligence or natural phenomena. It repeats actions in a non-predictable way and adds both suspense and challenge to a game. We already randomly generate a flow of enemies our hero has to avoid. We will now use them to improve our star field animation.</p><div class="section" title="Blinking"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec23"/>Blinking</h3></div></div></div><p>The stars already look<a id="id151" class="indexterm"/> great and provide a real sense of movement in the game. We are going to enhance them by making them twinkle like real stars. To do this, we use the method <code class="literal">setTransparency()</code> to make the star completely <span class="emphasis"><em>see-through</em></span> and use a delay variable to wait for a short period of time before making the star opaque again. We will use Greenfoot's random number generator to ensure that the stars twinkle infrequently. First, we add a method call, <code class="literal">checkTwinkle()</code>, to the <code class="literal">act()</code> method in the <code class="literal">Star</code> class:</p><div class="informalexample"><pre class="programlisting">public void act() {
  setLocation(getX(), getY()+speed);
  checkRemove();
  checkTwinkle();
}</pre></div><p>We need to add the following delay variable and the variable to hold the current transparency of the object at the top of the class under the declaration of the <code class="literal">speed</code> variable:</p><div class="informalexample"><pre class="programlisting">int twinkleTime = 0;
int currentTransparency = 0;</pre></div><p>The following is an<a id="id152" class="indexterm"/> implementation of <code class="literal">checkTwinkle()</code>:</p><div class="informalexample"><pre class="programlisting">private void checkTwinkle() {
  GreenfootImage img = getImage();
  if( twinkleTime &gt; 0 ) {
    if( twinkleTime == 1) {
      img.setTransparency(currentTransparency);
    }
    twinkleTime--;
  } else {
    if( Greenfoot.getRandomNumber(10000) &lt; 10) {
      twinkleTime = 10;
      currentTransparency = img.getTransparency();
      img.setTransparency(0);
    }
  }
}</pre></div><p>Let's look at the <code class="literal">else</code> part of the outer <code class="literal">if-else</code> statement. With a small random probability, we set <code class="literal">twinkleTime</code> (our delay variable) to <code class="literal">10</code>, save the current transparency of the star so that we can restore it later, and then set the transparency to <code class="literal">0</code>.</p><p>The <code class="literal">if</code> part of the initial <code class="literal">if-else</code> statement decrements <code class="literal">twinkleTime</code> if it is greater than <code class="literal">0</code> and restores the transparency of our star when <code class="literal">twinkleTime</code> equals <code class="literal">1</code>. Because <code class="literal">twinkleTime</code> is only set to <code class="literal">10</code>, the star will only be invisible for a very short period of time. This short flicker gives the illusion that the star twinkles.</p><p>Compile and run the scenario and see whether you can catch a star twinkling. If you have a hard time verifying this, change the frequency at which the twinkling occurs and try again.</p></div></div><div class="section" title="Triggered events"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Triggered events</h2></div></div></div><p>Triggering a change in an actor when <a id="id153" class="indexterm"/>a certain event occurs is another way to do animation. For example, you might have an enemy actor that will only chase you when you get within a certain range. You might also have an actor respond to keyboard events or location.</p><p>In this section, we are going to give our hero eyes. Obviously, our hero is very concerned with nearby enemies and definitely wants to keep an eye on them.</p><div class="note" title="Note"><h3 class="title"><a id="tip15"/>Tip</h3><p>Adding animated eyes to an actor is a fantastic way to give that actor personality. Eyes are very expressive and can easily portray excitement, sadness, or fear. Never hesitate to add animated eyes.</p></div><div class="section" title="Adding eyes"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec24"/>Adding eyes</h3></div></div></div><p>This might seem a bit weird, but we are going to <a id="id154" class="indexterm"/>create a separate <code class="literal">Eye</code> actor. We are going to do this for a couple of reasons. First, to get the eyes to look around is going to take a fair amount of code. We can encapsulate this code in the <code class="literal">Eye</code> class and keep our <code class="literal">Avatar</code> class more streamlined. Second, having the eyes as separate entities means we could add them to future actors and they would still work even if we changed the image of the <code class="literal">Avatar</code> class.</p><p>The alternative would be to create a skull image with eyes for every direction we would want to look. The fact that we have different images for our hero to show different levels of damage would further complicate matters. Therefore, we are going to create a separate <code class="literal">Eye</code> actor.</p><p>Create a new subclass of <code class="literal">Actor</code> called <code class="literal">Eye</code>. Do not associate an image with this <code class="literal">Actor</code> class. We will dynamically draw an image of an eye and redraw it appropriately when we need to look in a different direction. Here is the implementation of the <code class="literal">Eye</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 
import java.awt.Color;
import java.util.List;

public class Eye extends Actor {
  
  public Eye() {
    drawEye(2,2);
  }
  
  public void act() {
    lookAtEnemies();
  }
  
  public void lookAtEnemies() {
    List&lt;Enemy&gt; eList = getObjectsInRange(120, Enemy.class);
    if( !eList.isEmpty() ) {
      Enemy e = eList.get(0);
      if( e.getX() &lt; getX() ) {
        if( e.getY() &lt; getY() ) {
          drawEye(1,1);
        } else {
          drawEye(1,3);
        }
      } else {
        if( e.getY() &lt; getY() ) {
          drawEye(3,1);
        } else {
          drawEye(3,3);
        }
      }
    }
  }
  
  private void drawEye(int dx, int dy) {
    GreenfootImage img = new GreenfootImage(10,10);
    img.setColor(Color.white);
    img.fillOval(0,0,10,10);
    img.setColor(Color.black);
    img.fillOval(dx,dy,6,6);
    setImage(img);
  }
}</pre></div><p>The two main methods of <a id="id155" class="indexterm"/>this class are the <code class="literal">drawEye()</code> method and the <code class="literal">lookAtEnemies()</code> method. The <code class="literal">drawEye()</code> image uses the same methods to draw an eye that we used to draw the image of a star in the <code class="literal">Star</code> class. For an eye, we just need to draw one additional black circle to serve as the iris. The method <code class="literal">drawEye()</code> takes two integer parameters that provide the position of the iris in the eye. This offset portion of <code class="literal">fillOval()</code> was demonstrated in <span class="emphasis"><em>Figure 3</em></span>. To summarize, the first <code class="literal">fillOval()</code> command draws the larger white part of the eye, and the second <code class="literal">fillOval()</code> command draws the small black iris at a given offset to simulate staring in a certain direction.</p><p>The <code class="literal">lookAtEnemies()</code> method finds all enemies within a given distance of the eye and uses <code class="literal">drawEye()</code> to stare at the first enemy it finds. Using <code class="literal">if</code> statements to compare the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> position of the <a id="id156" class="indexterm"/>enemy with its own position, the eye classifies the enemy as being in one of four quadrants: upper-left, lower-left, upper-right, and lower-right. Using this information, <code class="literal">drawEye()</code> is called with the integer parameters <code class="literal">(1,1)</code>, <code class="literal">(1,3)</code>, <code class="literal">(3,1)</code>, and <code class="literal">(3,3)</code>, respectively. <span class="emphasis"><em>Figure 8</em></span> demonstrates the correlation between the quadrant the enemy is in and the call to <code class="literal">drawEye()</code>.</p><div class="mediaobject"><img src="../Images/image00273.jpeg" alt="Adding eyes"/><div class="caption"><p>Figure 8: This shows the mapping between the position of the enemy and the call to drawEye()</p></div></div><p style="clear:both; height: 1em;"> </p><p>In <code class="literal">lookAtEnemies()</code>, we used a new collision detection method called <code class="literal">getObjectsInRange()</code>. This method differs from <code class="literal">getOneIntersectingObject()</code> in two ways. First, instead of using the bounding box of the calling <code class="literal">Actor</code> class to determine whether a collision occurred, it draws a circle around the calling <code class="literal">Actor</code> class that has a radius of the size defined by the first parameter of <code class="literal">getObjectsInRange()</code>. This method returns all of the enemies found in that circle, instead of just one enemy. The enemies are returned in a Java <code class="literal">List</code> array. At the top of our <code class="literal">Eye</code> class, we need to include the code <code class="literal">import java.util.List;</code> to work with the <code class="literal">List</code> data type. We only have the ability to stare at one enemy at a time, so we choose to stare at the first enemy in this list using the method <code class="literal">get()</code> and passing it the integer value <code class="literal">0</code> to access it. Here's Greenfoot's documentation on <code class="literal">getObjectsInRange()</code>:</p><div class="informalexample"><pre class="programlisting">protected java.util.List getObjectsInRange(int radius, java.lang.Class cls)</pre></div><p>The preceding line of code returns all objects within range <code class="literal">radius</code> around this object. An object is within range if the distance between its center and this object's center is less than, or equal to, <code class="literal">radius</code>.</p><p>The parameters of the <a id="id157" class="indexterm"/>the <code class="literal">getObjectsInRange()</code> methods are described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">radius</code>: This is the radius of the circle (in cells)</li><li class="listitem"><code class="literal">cls</code>: This is the class of objects to look for (passing <code class="literal">null</code> will find all objects)</li></ul></div></div><div class="section" title="Giving our hero sight"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec25"/>Giving our hero sight</h3></div></div></div><p>Now that we<a id="id158" class="indexterm"/> have an <code class="literal">Actor</code> class called <code class="literal">Eye</code>, we just need to make a few modifications to the <code class="literal">Avatar</code> class in order to add eyes to our hero. We need to create two eyes, place them on our hero, and then we need to make sure the eyes stay in place every time our hero moves. We start by adding instance variables to the <code class="literal">Avatar</code> class:</p><div class="informalexample"><pre class="programlisting">private Eye leftEye;
private Eye rightEye;</pre></div><p>We then create and place those eyes on the skull image by adding this method:</p><div class="informalexample"><pre class="programlisting">protected void addedToWorld(World w) {
  leftEye = new Eye();
  rightEye = new Eye();
  w.addObject(leftEye, getX()-10, getY()-8);
  w.addObject(rightEye, getX()+10, getY()-8);
}</pre></div><p>Initially, you might think that we could create the eyes and add them in the constructor method for <code class="literal">Avatar</code>. Normally, this would be an excellent location for code that is run once at creation time. The problem is that before we can add the eyes to the world, an instance of the <code class="literal">Avatar</code> class needs to be in a world. If we look at the code in <code class="literal">AvoiderWorld</code> that adds our hero, we see this:</p><div class="informalexample"><pre class="programlisting">Avatar avatar = new Avatar();
addObject(avatar, 287, 232);</pre></div><p>The creation of our hero is a two-step process. First, an instance of the <code class="literal">Avatar</code> class is created (the first line), and then we add this instance to the world (the second line). Notice that the constructor runs before that object is placed in a world, so we cannot access the instance of the world we are in via the method <code class="literal">getWorld()</code>. The developers of Greenfoot recognized <a id="id159" class="indexterm"/>that some actors will need to access the world they are in to complete their initialization, so they added the <code class="literal">addedToWorld()</code> method to the <code class="literal">Actor</code> class. The <code class="literal">Actor</code> class overrides this method when initialization requires world access, and it will be called by Greenfoot every time an actor is added to a world. We use this method in our <code class="literal">Avatar</code> class in order to place the eyes on our hero.</p><p>We have now created our eyes and added them to our hero. Now, we just need to ensure that the eyes stay with our hero whenever it moves. To do that, we add the following lines to our <code class="literal">followMouse()</code> function in the <code class="literal">Avatar</code> class:</p><div class="informalexample"><pre class="programlisting">leftEye.setLocation(getX()-10, getY()-8);
rightEye.setLocation(getX()+10, getY()-8);</pre></div><p>The preceding code is added after the following line of code:</p><div class="informalexample"><pre class="programlisting">setLocation(mi.getX(), mi.getY());</pre></div><p>Why do the 10s and 8s in the <code class="literal">setLocation()</code> call <code class="literal">leftEye</code> and <code class="literal">rightEye</code>? These are the values that correctly place the eyes in the sockets of our hero. I determined these values through trial and error. <span class="emphasis"><em>Figure 9</em></span> presents the details.</p><div class="mediaobject"><img src="../Images/image00274.jpeg" alt="Giving our hero sight"/><div class="caption"><p>Figure 9: This shows how the location of the eyes was determined</p></div></div><p style="clear:both; height: 1em;"> </p><p>It is now time to have some fun. Compile and run your game and enjoy the fruits of your labor. Your game should look like the screenshot shown in <span class="emphasis"><em>Figure 10</em></span>.</p><div class="mediaobject"><img src="../Images/image00275.jpeg" alt="Giving our hero sight"/><div class="caption"><p>Figure 10: Our game has animated enemies, a moving background star field (with twinkles), and a hero with eyes that visually changes when hit</p></div></div><p style="clear:both; height: 1em;"> </p></div></div></div>
<div class="section" title="Easing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Easing</h1></div></div></div><p>For our last major section of this<a id="id160" class="indexterm"/> chapter, we are going to look at using easing equations to move our actors around in interesting ways. Easing functions use easing equations to calculate position as a function of time. Just about every animation you've seen on the web, your mobile device, or in the movies uses easing at some point in time. We are going to add three new actors to our game that move according to three different easing functions: linear, exponential, and sinusoidal.</p><div class="section" title="Power-ups and power-downs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Power-ups and power-downs</h2></div></div></div><p>Power-ups are <a id="id161" class="indexterm"/>an excellent<a id="id162" class="indexterm"/> way to add new <a id="id163" class="indexterm"/>challenges and balance <a id="id164" class="indexterm"/>player skill. Power-ups provide players with momentary boosts in speed, power, health, or some other game-related skill. They often appear randomly and might not be in the most convenient location, so they require players to make fast, real-time decisions where they have to weigh the risk of moving to the power-up versus its beneficial effects.</p><p>Similarly, we can create randomly appearing game objects that negatively affect the player's ability to do well. I call these <span class="emphasis"><em>power-downs</em></span>. They also require the player to make fast, real-time decisions, but now they are deciding between avoiding them and staying on their current trajectory and suffering the negative impact.</p><p>We are going to add two new actors to our game that will be power-downs and one new actor that will be a power-up. All three of them will use easing for movement. We will first introduce a new <code class="literal">Actor</code> class that will contain all the common code for easing and being a power item (power-up or power-down.) Our power-ups and power-downs will inherit from this class. It is good object-oriented programming practice to use inheritance and polymorphism to write concise, flexible, and maintainable code.</p><div class="section" title="Base class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec26"/>Base class</h3></div></div></div><p>Creating a well-thought-out <a id="id165" class="indexterm"/>base class for our power items will provide the means to easily create new power items and augment existing ones in the future. Before we talk about the code for our new class, we need to import a new Greenfoot-supplied class into our project, in the same way we imported the <code class="literal">Counter</code> class in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>. The class we are going to import is <code class="literal">SmoothMover</code>. We need this class as it more accurately tracks the position of <code class="literal">Actor</code>. Here's an excerpt from its documentation:</p><div class="informalexample"><pre class="programlisting">public abstract class SmoothMover extends greenfoot.Actor

A variation of an actor that maintains a precise location (using doubles for the co-ordinates instead of ints). This allows small precise movements (e.g. movements of 1 pixel or less) that do not lose precision.</pre></div><p>To import this class, click on <span class="strong"><strong>Edit</strong></span> in Greenfoot's main menu and then click on <span class="strong"><strong>Import Class…</strong></span> in the drop-down menu that appears. In the <span class="strong"><strong>Import Class</strong></span> window that appears next, select <code class="literal">SmoothMover</code> on the left-hand side and then click on the <span class="strong"><strong>Import</strong></span> button.</p><p>Now that we have <code class="literal">SmoothMover</code> in our project, we can create the <code class="literal">PowerItems</code> class. Right-click <code class="literal">SmoothMover</code> and choose <span class="strong"><strong>New subclass…</strong></span>. You will not need to associate an image with this class, so choose <span class="strong"><strong>No Image</strong></span> in the <span class="strong"><strong>Scenario Images</strong></span> section in the <span class="strong"><strong>New class</strong></span> window.</p><p>Let's take a look at the implementation of <code class="literal">PowerItems</code> (our new base class for power-ups and power-downs):</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public abstract class PowerItems extends SmoothMover
{
  protected double targetX, targetY, expireTime;
  protected double origX, origY;
  protected double duration;
  protected int counter;
  
  public PowerItems( int tX, int tY, int eT ) {
    targetX = tX;
    targetY = tY;
    expireTime = eT;
    counter = 0;
    duration = expireTime;
  }
  
  protected void addedToWorld(World w) {
    origX = getX();
    origY = getY();
  }
  
  public void act() {
    easing();
    checkHitAvatar();
    checkExpire();
  }
  
  protected abstract double curveX(double f);
  
  protected abstract double curveY(double f);
  
  protected abstract void checkHitAvatar();
  
  protected void easing() {
    double fX = ++counter/duration;
    double fY = counter/duration;
    fX = curveX(fX);
    fY = curveY(fY);
    setLocation((targetX * fX) + (origX * (1-fX)),
    (targetY * fY) + (origY * (1-fY)));
  }
  
  private void checkExpire() {
    if( expireTime-- &lt; 0 ) {
      World w = getWorld();
      if( w != null ) w.removeObject(this);
    }
  }
}</pre></div><p>We first need to <a id="id166" class="indexterm"/>discuss all the instance variables of this class. There are seven of them. Two of them are used to track the starting coordinates (<code class="literal">origX</code> and <code class="literal">origY</code>) and two of them are used to track the ending coordinates (<code class="literal">targetX</code> and <code class="literal">targetY</code>). The instance variable <code class="literal">expireTime</code> specifies how many calls of the <code class="literal">act()</code> method this actor should execute before removing itself. In other words, it specifies the lifespan of the actor. The <code class="literal">duration</code> instance variable simply saves the initial value of <code class="literal">expireTime</code>. The <code class="literal">expireTime</code> variable is continually decremented until it reaches a value of 0, but we need to know its original value for our easing equations. The <code class="literal">counter</code> variable records how many times this actor has moved. <span class="emphasis"><em>Figure 11</em></span> shows these variables pictorially.</p><div class="mediaobject"><img src="../Images/image00276.jpeg" alt="Base class"/><div class="caption"><p>Figure 11: This shows the meaning of the instance variables in PowerItems graphically</p></div></div><p style="clear:both; height: 1em;"> </p><p>The instance variables are initialized in the constructor except for <code class="literal">origX</code> and <code class="literal">origY</code>, which are initialized in the method <code class="literal">addedToWorld()</code> (the purpose of this method was discussed earlier in this chapter), so that we can set them to the current <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> location of the actor.</p><p>Because of our <a id="id167" class="indexterm"/>judicious use of functional decomposition, the <code class="literal">act()</code> method is straightforward to understand. First, it moves the actor by calling <code class="literal">easing()</code>. Next, <code class="literal">checkHitAvatar()</code> is called to see if it collided with our hero. This method is <code class="literal">abstract</code>, which means its implementation is left to subclasses of this class. This is done because each subclass will want to apply its own unique effect on our hero if they did collide. Last, it checks to see whether the <code class="literal">act()</code> method has been called <code class="literal">expireTime</code> times. If so, <code class="literal">PowerItem</code> has had its desired lifespan, and it's time to remove it. We will talk about the specific implementation of <code class="literal">easing()</code>, <code class="literal">checkHitAvatar()</code>, and <code class="literal">checkExpire()</code> next.</p><p>The <code class="literal">easing()</code> method is really the key method of this class. It contains a generic form of an easing equation that is flexible enough to allow us to define many different types of interesting movements. The method moves the actor some fraction of the way between the starting point and the endpoint. It starts by calculating the percentage of the distance we need to travel at this point in time between the origin value and the target value in the <span class="emphasis"><em>x</em></span> direction and a similar calculation for the <span class="emphasis"><em>y</em></span> direction and saves those values in the local variables <code class="literal">fX</code> and <code class="literal">fY</code>, respectively. Next, we use the <code class="literal">curveX()</code> and <code class="literal">curveY()</code> functions to manipulate these percentages, and then we use those percentages in a call to <code class="literal">setLocation()</code>. As with <code class="literal">checkHitAvatar()</code>, <code class="literal">curveX()</code> and <code class="literal">curveY()</code> are <code class="literal">abstract</code>, as their details depend on the classes that subclass from <code class="literal">PowerItems</code>. We'll discuss the <code class="literal">abstract</code> methods <code class="literal">checkHitAvatar()</code>, <code class="literal">curveX()</code>, and <code class="literal">curveY()</code>, as well as provide a detailed example in the next section.</p><p>Before that, let's look quickly at the last method in the <code class="literal">act()</code> method of <code class="literal">PowerItems</code>. The last method, <code class="literal">checkExpire()</code>, simply removes the actor when <code class="literal">expireTime</code> reaches 0.</p><div class="note" title="Note"><h3 class="title"><a id="note13"/>Note</h3><p><span class="strong"><strong>Abstract classes</strong></span></p><p>Abstract classes<a id="id168" class="indexterm"/> are an effective way to share code and instance variables between several related classes. In the abstract class, you implement as much code as you can without needing specific knowledge that would be contained in a child class (subclass). For us, the class <code class="literal">PowerItems</code> is an abstract class that contains the code common to all of our power-ups and <a id="id169" class="indexterm"/>power-downs. Visit <a class="ulink" href="http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</a> for more information on abstract classes.</p></div></div><div class="section" title="Linear easing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec27"/>Linear easing</h3></div></div></div><p>The first <a id="id170" class="indexterm"/>power-down we<a id="id171" class="indexterm"/> are going to add to the game is one that temporarily stuns our hero if touched. Keeping with our game's motif, where good things (smiley faces) are bad, we will make our new power-down look like a cupcake. To create our new <code class="literal">Actor</code>, right-click <code class="literal">PowerItems</code> in the <span class="strong"><strong>Actor classes</strong></span> section of Greenfoot's main scenario window, and select <span class="strong"><strong>New subclass…</strong></span> from the menu that appears. Name the class <code class="literal">Cupcake</code> and choose the image of the muffin (it looks like a cupcake to me!) located in the <span class="strong"><strong>food</strong></span> category.</p><p>Open up the <code class="literal">Cupcake</code> class in an editor window, and make it look like this:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Cupcake extends PowerItems
{  
  public Cupcake( int tX, int tY, int eT) {
    super(tX, tY, eT);
  }
      
  protected double curveX(double f) {
    return f;
  }

  protected double curveY(double f) {
    return f;
  }

  protected void checkHitAvatar() {
    Avatar a = (Avatar) getOneIntersectingObject(Avatar.class);
    if( a != null ) {
      a.stun();
      getWorld().removeObject(this);
    }
  }
}</pre></div><p>Because we are inheriting from the code from <code class="literal">PowerItems</code>, <code class="literal">Cupcake</code> is pretty short and concise. The constructor for this class merely passes its parameters to the constructor in <code class="literal">PowerItems</code>. Since <code class="literal">PowerItems</code> is an abstract class, we need to implement the abstract methods in <code class="literal">PowerItems</code> (<code class="literal">curveX()</code>, <code class="literal">curveY()</code>, and <code class="literal">checkHitAvatar()</code>) here.</p><p>The <code class="literal">Cupcake</code> class is going to be our example of <span class="emphasis"><em>linear easing</em></span>. It will move in constant, linear steps <a id="id172" class="indexterm"/>from<a id="id173" class="indexterm"/> the starting position to the ending position. Because it is linear, our <code class="literal">curveX()</code> and <code class="literal">curveY()</code> methods are extremely simple. They don't change the input parameter at all.</p><div class="mediaobject"><img src="../Images/image00277.jpeg" alt="Linear easing"/><div class="caption"><p>Figure 12: This is an example showing how instances of the Cupcake class move linearly across the screen</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's look at the example shown in <span class="emphasis"><em>Figure 12</em></span>. In this example, <code class="literal">Cupcake</code> was called with the target location <span class="strong"><strong>(150, 100)</strong></span> and an expire time of <code class="literal">4</code> and was added to the world at the location <span class="strong"><strong>(10,10)</strong></span>. Location <span class="strong"><strong>(a)</strong></span> shows the initial values of the object. Locations <span class="strong"><strong>(b)</strong></span>, <span class="strong"><strong>(c)</strong></span>, <span class="strong"><strong>(d)</strong></span>, and <span class="strong"><strong>(e)</strong></span> show the values associated with the object after one, two, three, and four <code class="literal">act()</code> method calls, respectively. As we can see, this actor moves in a straight line. To better understand linear easing, let's discuss why the values are as shown at location <span class="strong"><strong>(b)</strong></span>. After initialization (shown at location <span class="strong"><strong>(a)</strong></span>), the functions in the <code class="literal">act()</code> method (inherited from <code class="literal">PowerItems</code>) are called. The <code class="literal">easing()</code> method sets <code class="literal">counter</code> to 1 and then sets <code class="literal">fX</code> and <code class="literal">fY</code> to 0.25, as shown in this code:</p><div class="informalexample"><pre class="programlisting">double fX = ++counter/duration; // counter is incremented to 1 
double fy= counter/duration;  // counter remains 1</pre></div><p>The <code class="literal">curveX()</code> and <code class="literal">curveY()</code> methods in <code class="literal">Cupcake</code> do not alter <code class="literal">fX</code> and <code class="literal">fY</code>. For the given values, the first parameter to <code class="literal">setLocation()</code> has a value of 45 <span class="emphasis"><em>((150 * 0.25) + (10 * 0.75))</em></span> for its first parameter and 32.5 <span class="emphasis"><em>((100*0.25) + (10 * 0.75))</em></span> for its second parameter.</p><p>After <code class="literal">easing()</code>, the <a id="id174" class="indexterm"/>next method called in the <code class="literal">act()</code> method is <code class="literal">checkHitAvatar()</code>. This method simply invokes the method <code class="literal">stun()</code> on an instance of <code class="literal">Avatar</code> (our hero) if it collides <a id="id175" class="indexterm"/>with it. The <code class="literal">stun()</code> method will be shown after all the power-ups and power-downs have been discussed. At this time, we will show all the changes needed to the <code class="literal">Avatar</code> class.</p></div><div class="section" title="Exponential easing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec28"/>Exponential easing</h3></div></div></div><p>Now that we have<a id="id176" class="indexterm"/> discussed most of the theory behind power-ups and <a id="id177" class="indexterm"/>power-downs, we can quickly discuss the remaining ones. The next actor we are going to add is a power-up. It will heal our hero from some of the damage sustained. Given the motif of our game, this beneficial actor will have to look bad. We will make it a rock.</p><p>To create our new <code class="literal">Actor</code> class, right-click on <code class="literal">PowerItems</code> in the <span class="strong"><strong>Actor classes</strong></span> section of Greenfoot's main scenario window and select <span class="strong"><strong>New subclass…</strong></span> from the menu that appears. Name the class <code class="literal">Rock</code> and choose the image <code class="literal">rock.png</code> located in the <span class="strong"><strong>nature</strong></span> category.</p><p>Open up the <code class="literal">Rock</code> class in an editor window and change it to this:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Rock extends PowerItems
{
  
  public Rock( int tX, int tY, int eT ) {
    super(tX, tY, eT);
  }
  
  protected double curveX(double f) {
    return f; 
}
  
  protected double curveY(double f) {
    return f * f * f; 
}
  
  protected void checkHitAvatar() {
    Avatar a = (Avatar) getOneIntersectingObject(Avatar.class);
    if( a != null ) {
      a.addHealth();
      getWorld().removeObject(this);
    }
  }
}</pre></div><p>The two main <a id="id178" class="indexterm"/>differences between the <code class="literal">Cupcake</code> class and the <code class="literal">Rock</code> class <a id="id179" class="indexterm"/>are the implementation of <code class="literal">curveY()</code> and the fact that <code class="literal">checkHitAvatar()</code> calls <code class="literal">addHealth()</code> instead of <code class="literal">stun()</code>. We will describe <code class="literal">addHealth()</code> later, as mentioned earlier. The changes in <code class="literal">curveY()</code> give this actor a curved directory by cubing the value it is given. The effect of this is demonstrated in the example shown in <span class="emphasis"><em>Figure 13</em></span>. Compare the changes in the <span class="emphasis"><em>y</em></span> position for each location. The <span class="emphasis"><em>y</em></span> value grows exponentially. First, it only moves 1.4 pixels (from location <span class="strong"><strong>(a)</strong></span> to location <span class="strong"><strong>(b)</strong></span>) and in the end, jumps approximately 52 pixels (from location <span class="strong"><strong>(d)</strong></span> to location <span class="strong"><strong>(e)</strong></span>).</p><div class="mediaobject"><img src="../Images/image00278.jpeg" alt="Exponential easing"/><div class="caption"><p>Figure 13: This is an example showing how instances of the Rock class move exponentially in the y direction across the screen</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Sinusoidal easing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec29"/>Sinusoidal easing</h3></div></div></div><p>The last power-down<a id="id180" class="indexterm"/> we are adding is <code class="literal">Clover</code>. It will slow our hero down for a <a id="id181" class="indexterm"/>short time and employ <span class="emphasis"><em>sinusoidal easing</em></span>. To create this class, right-click on <code class="literal">PowerItems</code> in the <span class="strong"><strong>Actor classes</strong></span> section of Greenfoot's main scenario window and select <span class="strong"><strong>New subclass…</strong></span> from the menu that appears. Name the class <code class="literal">Clover</code> and choose the image of the <code class="literal">shamrock</code> located in the <span class="strong"><strong>nature</strong></span> category. Open it in an editor window and change it to this:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.lang.Math;

public class Clover extends PowerItems
{
  public Clover(int tX, int tY, int eT) {
    super(tX, tY, eT);
  }
  
  protected double curveX(double f) {
    return f;
  }
  
  protected double curveY(double f) {
    return Math.sin(4*f);
  }
  
  protected void checkHitAvatar() {
    Avatar a = (Avatar)
    getOneIntersectingObject(Avatar.class);
    if( a != null ) {
      a.lagControls();
      getWorld().removeObject(this);
    }
  }
}</pre></div><p>Like the <code class="literal">Rock</code> class, the <code class="literal">Clover</code> class does something unique in its <code class="literal">curveY()</code> method. It imports Java's math library at the top of the class and uses <code class="literal">Math.sin()</code> in its implementation of <code class="literal">curveY()</code>. This makes the <span class="emphasis"><em>y</em></span> motion oscillate like a sine wave.</p><p>In <code class="literal">Clover</code>, <code class="literal">checkHitAvatar()</code> calls <code class="literal">lagControls()</code>on the instance of the <code class="literal">Avatar</code> class it collided with<a id="id182" class="indexterm"/>, instead of <code class="literal">stun()</code> or <code class="literal">addHealth()</code>. In the next<a id="id183" class="indexterm"/> section, we will implement <code class="literal">stun()</code>, <code class="literal">addHealth()</code>, and <code class="literal">lagControls()</code> in the <code class="literal">Avatar</code> class.</p></div><div class="section" title="Changes to the Avatar class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec30"/>Changes to the Avatar class</h3></div></div></div><p>To accommodate the <a id="id184" class="indexterm"/>effects of our new power items, the <code class="literal">Avatar</code> class needs to implement a few methods and change some existing ones. These methods are <code class="literal">stun()</code>, <code class="literal">addHealth()</code>, and <code class="literal">lagControls()</code>.</p><div class="note" title="Note"><h3 class="title"><a id="tip16"/>Tip</h3><p>Here's an extra challenge before continuing ahead in the chapter. Try to implement these methods yourself. Think each one through and rough them out on paper. The worst case scenario for attempting this is that you learn a lot.</p></div><p>The implementations of <code class="literal">stun()</code> and <code class="literal">lagControls()</code> involves adding delay variables and using them to affect movement. In the <code class="literal">Avatar</code> class, all movement is handled in the <code class="literal">followMouse()</code> method. To stun our hero, we only need to disable the <code class="literal">followMouse()</code> method for a small period of time. Here is how we would change this method:</p><div class="informalexample"><pre class="programlisting">private void followMouse() {
  MouseInfo mi = Greenfoot.getMouseInfo();
  if( stunDelay &lt; 0 ) {
    if( mi != null ) {
      setLocation(mi.getX(), mi.getY());
      leftEye.setLocation(getX()-10, getY()-8);
      rightEye.setLocation(getX()+10, getY()-8);
    }
  } else {
    stunDelay--;
  }
}</pre></div><p>We also need to define the <code class="literal">stunDelay</code> instance variable at the top of the class:</p><div class="informalexample"><pre class="programlisting">private int stunDelay = -1;</pre></div><p>This follows the pattern of usage for the instance variable <code class="literal">hitDelay</code> we added at the beginning of this chapter. It was our example of a delay variable. Now, we implement <code class="literal">stun()</code>:</p><div class="informalexample"><pre class="programlisting">public void stun() {
  stunDelay = 50;
}</pre></div><p>Every time <code class="literal">stun()</code> is invoked, the <code class="literal">followMouse()</code> method will not work for 50 cycles (calls of the <code class="literal">act()</code> method).</p><p>Implementing <code class="literal">lagControls()</code> is<a id="id185" class="indexterm"/> similar, except that we need to temporarily change the movement, instead of blocking it. Again, we need to change the <code class="literal">followMouse()</code> method:</p><div class="informalexample"><pre class="programlisting">private void followMouse() {
  MouseInfo mi = Greenfoot.getMouseInfo();
  if( stunDelay &lt; 0 ) {
    if( mi != null ) {
      if( lagDelay &gt; 0 ) {
        int stepX = (mi.getX() - getX())/40;
        int stepY = (mi.getY() - getY())/40;
        setLocation(stepX + getX(), stepY + getY());
        --lagDelay;
      } else {
        setLocation(mi.getX(), mi.getY());
      }
      leftEye.setLocation(getX()-10, getY()-8);
      rightEye.setLocation(getX()+10, getY()-8);
    }
  } else {
    stunDelay--;
  }
}</pre></div><p>Let's first add the instance variable <code class="literal">lagDelay</code> and then talk about how it is used in <code class="literal">followMouse()</code>. Add this line at the top of the class under <code class="literal">stunDelay</code>:</p><div class="informalexample"><pre class="programlisting">private int lagDelay = -1;</pre></div><p>While <code class="literal">lagDelay</code> is a value greater than 0, it will implement the laggy controls. In the inner <code class="literal">if-else</code> statement in the above method, the lag is implemented by only moving our hero one-fortieth of the way to the location of the mouse. This makes our hero slowly crawl towards the location of the mouse. The delay variable, <code class="literal">lagDelay</code>, is decremented until it is less than 0. How does it get above 0? It is set in the <code class="literal">lagControls()</code> method called by the <code class="literal">Clover</code> class. Here is the code for that method:</p><div class="informalexample"><pre class="programlisting">public void lagControls() {
  lagDelay = 150;
}</pre></div><p>All we need to do now is implement the <code class="literal">addHealth()</code> method. Here is the code:</p><div class="informalexample"><pre class="programlisting">public void addHealth() {
  if( health &lt; 3 ) {
    health++;
    if( --nextImage == 0 ) {
      setImage("skull.png");
    } else {
      setImage("skull" + nextImage + ".png");
    }
  }
}</pre></div><p>This method simply undoes <a id="id186" class="indexterm"/>the damage that occurs when we hit an enemy. This method does nothing if we are already at full health; otherwise, it increments the <code class="literal">health</code> instance variable, decrements <code class="literal">nextImage</code>, so that it stays in sync with the image we are displaying, and sets the image of the <code class="literal">Avatar</code> to the previous, less damaged image. Pretty cool!</p><p>We made some substantial changes to the <code class="literal">Avatar</code> class. Here is its code in its entirety:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
public class Avatar extends Actor {
  private int health = 3;
  private int hitDelay = 0;
  private int stunDelay = -1;
  private int lagDelay = -1;
  private int nextImage = 0;
  private Eye leftEye;
  private Eye rightEye;
  
  protected void addedToWorld(World w) {
    leftEye = new Eye();
    rightEye = new Eye();
    w.addObject(leftEye, getX()-10, getY()-8);
    w.addObject(rightEye, getX()+10, getY()-8);
  }
  
  public void act() {
    followMouse();
    checkForCollisions();
  }
  
  public void addHealth() {
    if( health &lt; 3 ) {
      health++;
      if( --nextImage == 0 ) {
        setImage("skull.png");
      } else {
        setImage("skull" + nextImage + ".png");
      }
    }
  }
  
  public void lagControls() {
    lagDelay = 150;
  }
  
  public void stun() {
    stunDelay = 50;
  }
  
  private void checkForCollisions() {
    Actor enemy = getOneIntersectingObject(Enemy.class);
    if( hitDelay == 0 &amp;&amp; enemy != null ) {
      if( health == 0 ) {
        AvoiderWorld world = (AvoiderWorld) getWorld();
        world.endGame();
      }
      else {
        health--;
        setImage("skull" + ++nextImage + ".png");
        hitDelay = 50;
      }
    }
    if( hitDelay &gt; 0 ) hitDelay--;
  }
  
  private void followMouse() {
    MouseInfo mi = Greenfoot.getMouseInfo();
    if( stunDelay &lt; 0 ) {
      if( mi != null ) {
        if( lagDelay &gt; 0 ) {
          int stepX = (mi.getX() - getX())/40;
          int stepY = (mi.getY() - getY())/40;
          setLocation(stepX + getX(), stepY + getY());
          --lagDelay;
        } else {
          setLocation(mi.getX(), mi.getY());
        }
        leftEye.setLocation(getX()-10, getY()-8);
        rightEye.setLocation(getX()+10, getY()-8);
      }
    } else {
      stunDelay--;
    }
  }
}</pre></div><p>We are so close to trying <a id="id187" class="indexterm"/>all this out. We just need to randomly create and add the power-ups and power-downs in the <code class="literal">AvoiderWorld</code> class.</p></div><div class="section" title="Changes to the AvoiderWorld class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec31"/>Changes to the AvoiderWorld class</h3></div></div></div><p>We need to create three <a id="id188" class="indexterm"/>new instance variables at the top of the <code class="literal">AvoiderWorld</code> class to specify the probability we use to generate one of our new power items. Add these lines of code under the declaration and initialization of <code class="literal">nextLevel</code>:</p><div class="informalexample"><pre class="programlisting">private int cupcakeFrequency = 10;
private int cloverFrequency = 10;
private int rockFrequency = 1;</pre></div><p>Initially, the creation of these items will not be very frequent, but we will change that by incrementing them in the <code class="literal">increaseLevel()</code> function. Here is the code:</p><div class="informalexample"><pre class="programlisting">private void increaseLevel() {
  int score = scoreBoard.getValue();

  if( score &gt; nextLevel ) {
    enemySpawnRate += 3;
    enemySpeed++;
    cupcakeFrequency += 3;
    cloverFrequency += 3;
    rockFrequency += 2;
    nextLevel += 50;
  }
}</pre></div><p>In the <code class="literal">act()</code> method, we call a function to generate enemies and another to generate stars. Following this pattern, add this line to the <code class="literal">act()</code> method:</p><div class="informalexample"><pre class="programlisting">generatePowerItems();</pre></div><p>Because all of the power item classes inherits from <code class="literal">PowerItems</code>, we can use polymorphism to write some pretty concise code. Here is the implementation of <code class="literal">generatePowerItems()</code>:</p><div class="informalexample"><pre class="programlisting">private void generatePowerItems() {
  generatePowerItem(0, cupcakeFrequency); // new Cupcake
  generatePowerItem(1, cloverFrequency); // new Clover
  generatePowerItem(2, rockFrequency); // new Health
}</pre></div><p>It's pretty nice that we can <a id="id189" class="indexterm"/>use one method to create our new power items—<code class="literal">generatePowerItem()</code>. This method takes an integer describing the type of power item we want to create and a frequency to generate those particular items. Here's the implementation:</p><div class="informalexample"><pre class="programlisting">private void generatePowerItem(int type, int freq) {
  if( Greenfoot.getRandomNumber(1000) &lt; freq ) {
    int targetX = Greenfoot.getRandomNumber(
    getWidth() -80) + 40;
    int targetY = Greenfoot.getRandomNumber(
    getHeight()/2) + 20;
    Actor a = createPowerItem(type, targetX, targetY, 100);
    if( Greenfoot.getRandomNumber(100) &lt; 50) {
      addObject(a, getWidth() + 20,
      Greenfoot.getRandomNumber(getHeight()/2) + 30);
    } else {
      addObject(a, -20,
      Greenfoot.getRandomNumber(getHeight()/2) + 30);
    }
  }
}</pre></div><p>This method looks a lot like our other methods that generate actors. It will generate an item at a given random rate and place those items to emerge from either the left or the right of the screen towards a randomly generated place in the interior of the screen. The local variable <code class="literal">targetX</code> will be any valid <span class="emphasis"><em>x</em></span> coordinate on the screen, except for a <code class="literal">40</code> pixel wide border on the left and right of the screen. We just want to ensure that it travels long enough to be seen and that<a id="id190" class="indexterm"/> it has an impact on the game. The variable <code class="literal">targetY</code> has slightly tighter constraints. We only want to generate a <span class="emphasis"><em>y</em></span> value in the upper half of the screen, plus an initial <code class="literal">20</code> pixels to prevent the actor from traveling too close to the top of the screen. The inner <code class="literal">if-else</code> statement simply chooses from placing the object either on the left or the right of the screen for its initial location.</p><p>The real difference here, from how we generated other actors, is the call to <code class="literal">createPowerItem()</code>. Since we are using this method to generate any one of three power items, we can't hardcode the creation of a specific item, such as, <code class="literal">new Cupcake();</code>. We use <code class="literal">createPowerItem()</code> to create the right object that matches the type parameter of <code class="literal">generatePowerItems()</code>. Here's the implementation of <code class="literal">createPowerItem()</code>:</p><div class="informalexample"><pre class="programlisting">private Actor createPowerItem(int type, int targetX, int targetY, int expireTime) {
  switch(type) {
    case 0: return new Cupcake(targetX, targetY,
    expireTime);
    case 1: return new Clover(targetX, targetY,
    expireTime);
    case 2: return new Rock(targetX, targetY,
    expireTime);
  }
  return null;
}</pre></div><p>This method creates a new <code class="literal">Cupcake</code>, <code class="literal">Clover</code>, or <code class="literal">Rock</code> power item based on type.</p><p>We have really added a lot to this game, and now it's time to compile and test it out. Normally, you would not want to add this much code without testing small parts along the way. For example, we could have just implemented the <code class="literal">Rock</code> power-up completely and tested it before adding the other power items. For pedagogical reasons, it made sense to continue in the manner we did. I hope you don't encounter too many typos when you compile your code. By methodically checking your code against the code in this chapter and paying close attention to the compile error messages, you should be able to eliminate any mistakes quickly.</p><div class="note" title="Note"><h3 class="title"><a id="tip17"/>Tip</h3><p>If you need to refresh yourself on how a Java switch statement<a id="id191" class="indexterm"/> works, refer to the following link:</p><p><a class="ulink" href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html">http://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html</a></p></div><p>Compile, debug, and play. This <a id="id192" class="indexterm"/>game is getting good. Check out my screenshot in <span class="emphasis"><em>Figure 14</em></span>.</p><div class="mediaobject"><img src="../Images/image00279.jpeg" alt="Changes to the AvoiderWorld class"/><div class="caption"><p>Figure 14: Here's Avoider Game complete with power-ups, power-downs, and all sorts of bling</p></div></div><p style="clear:both; height: 1em;"> </p></div></div></div>
<div class="section" title="Avoider Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Avoider Game</h1></div></div></div><p>Our Avoider Game is getting <a id="id193" class="indexterm"/>more complete and fun to play. In <a class="link" title="Chapter 5. Interactive Application Design and Theory" href="part0034.xhtml">Chapter 5</a>, <span class="emphasis"><em>Interactive Application Design and Theory</em></span>, we will look at game design theory on how to build fun and engaging games. At that time, we will revisit our game and increase its playability.</p></div>
<div class="section" title="Your assignment"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Your assignment</h1></div></div></div><p>When an <code class="literal">Avatar</code> object is hit, it is invulnerable to being hit again for a short time. Unfortunately, we have provided no visual feedback to the player that indicates this is happening or when it expires. Your assignment is to make the hero blink while it cannot be hit. Look at the <code class="literal">Star</code> class for a hint on how to make an object blink.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>We covered a lot of material in this chapter. You learned several important techniques for animating actors, including image swapping, delay variables, parallax, and easing. Our enemies, our hero, and the background, all have more life. You should use all the techniques of this chapter when creating games, simulations, animated shots, or educational applications.</p></div></body></html>